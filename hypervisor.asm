
bin/hypervisor:     file format elf32-i386


Disassembly of section .init:

00200000 <_ZN4Acpi5setupEv>:
{
    write (RESET, reset_val);
}

void Acpi::setup()
{
  200000:	53                   	push   %ebx
  200001:	83 ec 0c             	sub    $0xc,%esp
    Acpi_rsdp::parse();
  200004:	e8 37 09 00 00       	call   200940 <_ZN9Acpi_rsdp5parseEv>

    if (xsdt)
  200009:	8b 1d 34 a3 01 c0    	mov    0xc001a334,%ebx
  20000f:	85 db                	test   %ebx,%ebx
  200011:	74 13                	je     200026 <_ZN4Acpi5setupEv+0x26>
        static_cast<Acpi_table_rsdt *>(Hpt::remap (Pd::kern.quota, xsdt))->parse (xsdt, sizeof (uint64));
  200013:	89 da                	mov    %ebx,%edx
  200015:	b8 50 b4 01 c0       	mov    $0xc001b450,%eax
  20001a:	e8 cf 5b e0 bf       	call   c0005bee <_ZN3Hpt5remapER5Quotam>
  20001f:	b9 08 00 00 00       	mov    $0x8,%ecx
  200024:	eb 1b                	jmp    200041 <_ZN4Acpi5setupEv+0x41>
    else if (rsdt)
  200026:	8b 1d 38 a3 01 c0    	mov    0xc001a338,%ebx
  20002c:	85 db                	test   %ebx,%ebx
  20002e:	74 18                	je     200048 <_ZN4Acpi5setupEv+0x48>
        static_cast<Acpi_table_rsdt *>(Hpt::remap (Pd::kern.quota, rsdt))->parse (rsdt, sizeof (uint32));
  200030:	89 da                	mov    %ebx,%edx
  200032:	b8 50 b4 01 c0       	mov    $0xc001b450,%eax
  200037:	e8 b2 5b e0 bf       	call   c0005bee <_ZN3Hpt5remapER5Quotam>
  20003c:	b9 04 00 00 00       	mov    $0x4,%ecx
  200041:	89 da                	mov    %ebx,%edx
  200043:	e8 68 09 00 00       	call   2009b0 <_ZNK15Acpi_table_rsdt5parseEmj>

    if (fadt)
  200048:	8b 15 48 a3 01 c0    	mov    0xc001a348,%edx
  20004e:	85 d2                	test   %edx,%edx
  200050:	74 0f                	je     200061 <_ZN4Acpi5setupEv+0x61>
        static_cast<Acpi_table_fadt *>(Hpt::remap (Pd::kern.quota, fadt))->parse();
  200052:	b8 50 b4 01 c0       	mov    $0xc001b450,%eax
  200057:	e8 92 5b e0 bf       	call   c0005bee <_ZN3Hpt5remapER5Quotam>
  20005c:	e8 b7 03 00 00       	call   200418 <_ZNK15Acpi_table_fadt5parseEv>
    if (hpet)
  200061:	8b 15 44 a3 01 c0    	mov    0xc001a344,%edx
  200067:	85 d2                	test   %edx,%edx
  200069:	74 0f                	je     20007a <_ZN4Acpi5setupEv+0x7a>
        static_cast<Acpi_table_hpet *>(Hpt::remap (Pd::kern.quota, hpet))->parse();
  20006b:	b8 50 b4 01 c0       	mov    $0xc001b450,%eax
  200070:	e8 79 5b e0 bf       	call   c0005bee <_ZN3Hpt5remapER5Quotam>
  200075:	e8 de 05 00 00       	call   200658 <_ZNK15Acpi_table_hpet5parseEv>
    if (madt)
  20007a:	8b 15 40 a3 01 c0    	mov    0xc001a340,%edx
  200080:	85 d2                	test   %edx,%edx
  200082:	74 0f                	je     200093 <_ZN4Acpi5setupEv+0x93>
        static_cast<Acpi_table_madt *>(Hpt::remap (Pd::kern.quota, madt))->parse();
  200084:	b8 50 b4 01 c0       	mov    $0xc001b450,%eax
  200089:	e8 60 5b e0 bf       	call   c0005bee <_ZN3Hpt5remapER5Quotam>
  20008e:	e8 e3 07 00 00       	call   200876 <_ZNK15Acpi_table_madt5parseEv>
    if (mcfg)
  200093:	8b 15 3c a3 01 c0    	mov    0xc001a33c,%edx
  200099:	85 d2                	test   %edx,%edx
  20009b:	74 0f                	je     2000ac <_ZN4Acpi5setupEv+0xac>
        static_cast<Acpi_table_mcfg *>(Hpt::remap (Pd::kern.quota, mcfg))->parse();
  20009d:	b8 50 b4 01 c0       	mov    $0xc001b450,%eax
  2000a2:	e8 47 5b e0 bf       	call   c0005bee <_ZN3Hpt5remapER5Quotam>
  2000a7:	e8 18 08 00 00       	call   2008c4 <_ZNK15Acpi_table_mcfg5parseEv>
    if (dmar)
  2000ac:	8b 15 4c a3 01 c0    	mov    0xc001a34c,%edx
  2000b2:	85 d2                	test   %edx,%edx
  2000b4:	74 0f                	je     2000c5 <_ZN4Acpi5setupEv+0xc5>
        static_cast<Acpi_table_dmar *>(Hpt::remap (Pd::kern.quota, dmar))->parse();
  2000b6:	b8 50 b4 01 c0       	mov    $0xc001b450,%eax
  2000bb:	e8 2e 5b e0 bf       	call   c0005bee <_ZN3Hpt5remapER5Quotam>
  2000c0:	e8 d3 02 00 00       	call   200398 <_ZNK15Acpi_table_dmar5parseEv>

    if (!Acpi_table_madt::sci_overridden) {
  2000c5:	80 3d 80 a2 01 c0 00 	cmpb   $0x0,0xc001a280
  2000cc:	75 20                	jne    2000ee <_ZN4Acpi5setupEv+0xee>
        Acpi_intr sci_override;
        sci_override.bus = 0;
        sci_override.irq = static_cast<uint8>(irq);
  2000ce:	a1 88 a2 01 c0       	mov    0xc001a288,%eax
    if (dmar)
        static_cast<Acpi_table_dmar *>(Hpt::remap (Pd::kern.quota, dmar))->parse();

    if (!Acpi_table_madt::sci_overridden) {
        Acpi_intr sci_override;
        sci_override.bus = 0;
  2000d3:	c6 44 24 04 00       	movb   $0x0,0x4(%esp)
        sci_override.irq = static_cast<uint8>(irq);
        sci_override.gsi = irq;
        sci_override.flags.pol = Acpi_inti::POL_CONFORMING;
        sci_override.flags.trg = Acpi_inti::TRG_CONFORMING;
  2000d8:	80 64 24 0a f0       	andb   $0xf0,0xa(%esp)
        static_cast<Acpi_table_dmar *>(Hpt::remap (Pd::kern.quota, dmar))->parse();

    if (!Acpi_table_madt::sci_overridden) {
        Acpi_intr sci_override;
        sci_override.bus = 0;
        sci_override.irq = static_cast<uint8>(irq);
  2000dd:	88 44 24 05          	mov    %al,0x5(%esp)
        sci_override.gsi = irq;
  2000e1:	89 44 24 06          	mov    %eax,0x6(%esp)
        sci_override.flags.pol = Acpi_inti::POL_CONFORMING;
        sci_override.flags.trg = Acpi_inti::TRG_CONFORMING;
        Acpi_table_madt::parse_intr (&sci_override);
  2000e5:	8d 44 24 02          	lea    0x2(%esp),%eax
  2000e9:	e8 b6 05 00 00       	call   2006a4 <_ZN15Acpi_table_madt10parse_intrEPK9Acpi_apic>
    }

    Gsi::set (gsi = Gsi::irq_to_gsi (irq));
  2000ee:	a1 88 a2 01 c0       	mov    0xc001a288,%eax
        static void unmask (unsigned);

        ALWAYS_INLINE
        static inline unsigned irq_to_gsi (unsigned irq)
        {
            assert (irq < NUM_IRQ);
  2000f3:	83 f8 0f             	cmp    $0xf,%eax
  2000f6:	76 1b                	jbe    200113 <_ZN4Acpi5setupEv+0x113>
  2000f8:	68 e0 60 01 c0       	push   $0xc00160e0
  2000fd:	6a 38                	push   $0x38
  2000ff:	68 eb 5f 01 c0       	push   $0xc0015feb
  200104:	68 5b 60 01 c0       	push   $0xc001605b
  200109:	68 69 60 01 c0       	push   $0xc0016069
  20010e:	e8 33 18 e0 bf       	call   c0001946 <_ZN7Console5panicEPKcz>
            return irq_table[irq];
  200113:	8b 04 85 a0 a4 01 c0 	mov    -0x3ffe5b60(,%eax,4),%eax
  20011a:	31 c9                	xor    %ecx,%ecx
  20011c:	31 d2                	xor    %edx,%edx
  20011e:	a3 84 a2 01 c0       	mov    %eax,0xc001a284
  200123:	e8 58 55 e0 bf       	call   c0005680 <_ZN3Gsi3setEjjj>

    write (PM1_ENA, PM1_ENA_TMR);
  200128:	ba 01 00 00 00       	mov    $0x1,%edx
  20012d:	b8 01 00 00 00       	mov    $0x1,%eax
  200132:	e8 2f 09 e0 bf       	call   c0000a66 <_ZN4Acpi5writeENS_8RegisterEj>

    clear (GPE0_ENA, 0);
  200137:	31 d2                	xor    %edx,%edx
  200139:	b8 05 00 00 00       	mov    $0x5,%eax
  20013e:	e8 f3 08 e0 bf       	call   c0000a36 <_ZN4Acpi5clearENS_8RegisterEj>
    clear (GPE1_ENA, 0);
  200143:	31 d2                	xor    %edx,%edx
  200145:	b8 07 00 00 00       	mov    $0x7,%eax
  20014a:	e8 e7 08 e0 bf       	call   c0000a36 <_ZN4Acpi5clearENS_8RegisterEj>

    for (; tmr_ovf = read (PM_TMR) >> tmr_msb(), read (PM1_STS) & PM1_STS_TMR; write (PM1_STS, PM1_STS_TMR)) ;
  20014f:	b8 08 00 00 00       	mov    $0x8,%eax
  200154:	e8 bd 07 e0 bf       	call   c0000916 <_ZN4Acpi4readENS_8RegisterE>
        static void hw_write (Acpi_gas *, unsigned, bool = false);
        static void write (Register, unsigned);
        static void clear (Register, unsigned);

        ALWAYS_INLINE
        static inline mword tmr_msb() { return feature & 0x100 ? 31 : 23; }
  200159:	8b 15 90 a2 01 c0    	mov    0xc001a290,%edx
  20015f:	81 e2 00 01 00 00    	and    $0x100,%edx
  200165:	83 fa 01             	cmp    $0x1,%edx
  200168:	19 c9                	sbb    %ecx,%ecx
  20016a:	83 e1 f8             	and    $0xfffffff8,%ecx
  20016d:	83 c1 1f             	add    $0x1f,%ecx
  200170:	d3 e8                	shr    %cl,%eax
  200172:	a3 94 a2 01 c0       	mov    %eax,0xc001a294
  200177:	31 c0                	xor    %eax,%eax
  200179:	e8 98 07 e0 bf       	call   c0000916 <_ZN4Acpi4readENS_8RegisterE>
  20017e:	a8 01                	test   $0x1,%al
  200180:	74 0e                	je     200190 <_ZN4Acpi5setupEv+0x190>
  200182:	ba 01 00 00 00       	mov    $0x1,%edx
  200187:	31 c0                	xor    %eax,%eax
  200189:	e8 d8 08 e0 bf       	call   c0000a66 <_ZN4Acpi5writeENS_8RegisterEj>
  20018e:	eb bf                	jmp    20014f <_ZN4Acpi5setupEv+0x14f>

    trace (TRACE_ACPI, "ACPI: GSI:%#x TMR:%lu", gsi, tmr_msb() + 1);
}
  200190:	83 c4 0c             	add    $0xc,%esp
  200193:	5b                   	pop    %ebx
  200194:	c3                   	ret    
  200195:	90                   	nop

00200196 <_ZNK9Acpi_dmar5parseEv>:
#include "ioapic.hpp"
#include "pci.hpp"
#include "pd.hpp"

void Acpi_dmar::parse() const
{
  200196:	55                   	push   %ebp
    public:
        INIT
        Dmar (Paddr);

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
  200197:	ba 50 b4 01 c0       	mov    $0xc001b450,%edx
  20019c:	57                   	push   %edi
  20019d:	89 c7                	mov    %eax,%edi
  20019f:	56                   	push   %esi
  2001a0:	b8 54 a4 01 c0       	mov    $0xc001a454,%eax
  2001a5:	53                   	push   %ebx
  2001a6:	83 ec 14             	sub    $0x14,%esp
  2001a9:	e8 c8 00 e1 bf       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
    Dmar *dmar = new (Pd::kern.quota) Dmar (static_cast<Paddr>(phys));
  2001ae:	8b 57 08             	mov    0x8(%edi),%edx
  2001b1:	89 c5                	mov    %eax,%ebp
  2001b3:	e8 82 0b 00 00       	call   200d3a <_ZN4DmarC1Em>
  2001b8:	a1 bc b0 01 c0       	mov    0xc001b0bc,%eax

    if (flags & 1)
  2001bd:	f6 47 04 01          	testb  $0x1,0x4(%edi)
  2001c1:	89 04 24             	mov    %eax,(%esp)
  2001c4:	75 17                	jne    2001dd <_ZNK9Acpi_dmar5parseEv+0x47>
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline bool claim_dev (unsigned r, unsigned i)
        {
            for (Ioapic *ioapic = list; ioapic; ioapic = ioapic->next)
  2001c6:	a1 58 b0 01 c0       	mov    0xc001b058,%eax
        Pci::claim_all (dmar);

    for (Acpi_scope const *s = scope; s < reinterpret_cast<Acpi_scope *>(reinterpret_cast<mword>(this) + length); s = reinterpret_cast<Acpi_scope *>(reinterpret_cast<mword>(s) + s->length)) {
  2001cb:	8d 57 10             	lea    0x10(%edi),%edx
  2001ce:	89 44 24 0c          	mov    %eax,0xc(%esp)
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline bool claim_dev (unsigned r, unsigned i)
        {
            for (Hpet *hpet = list; hpet; hpet = hpet->next)
  2001d2:	a1 e8 aa 01 c0       	mov    0xc001aae8,%eax
  2001d7:	89 44 24 10          	mov    %eax,0x10(%esp)
  2001db:	eb 43                	jmp    200220 <_ZNK9Acpi_dmar5parseEv+0x8a>
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void claim_all (Dmar *d)
        {
            for (Pci *pci = list; pci; pci = pci->next)
  2001dd:	8b 04 24             	mov    (%esp),%eax
  2001e0:	85 c0                	test   %eax,%eax
  2001e2:	74 e2                	je     2001c6 <_ZNK9Acpi_dmar5parseEv+0x30>
                if (!pci->dmar)
  2001e4:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
  2001e8:	75 03                	jne    2001ed <_ZNK9Acpi_dmar5parseEv+0x57>
                    pci->dmar = d;
  2001ea:	89 68 0c             	mov    %ebp,0xc(%eax)
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void claim_all (Dmar *d)
        {
            for (Pci *pci = list; pci; pci = pci->next)
  2001ed:	8b 00                	mov    (%eax),%eax
  2001ef:	eb ef                	jmp    2001e0 <_ZNK9Acpi_dmar5parseEv+0x4a>

        switch (s->type) {
  2001f1:	8a 02                	mov    (%edx),%al
  2001f3:	3c 03                	cmp    $0x3,%al
  2001f5:	74 7e                	je     200275 <_ZNK9Acpi_dmar5parseEv+0xdf>
  2001f7:	77 36                	ja     20022f <_ZNK9Acpi_dmar5parseEv+0x99>
  2001f9:	3c 01                	cmp    $0x1,%al
  2001fb:	72 1d                	jb     20021a <_ZNK9Acpi_dmar5parseEv+0x84>
        uint8       length;
        uint16      reserved;
        uint8       id, b, d, f;

        ALWAYS_INLINE
        inline unsigned rid() const { return b << 8 | d << 3 | f; }
  2001fd:	0f b6 4a 05          	movzbl 0x5(%edx),%ecx
  200201:	0f b6 42 06          	movzbl 0x6(%edx),%eax
  200205:	c1 e1 08             	shl    $0x8,%ecx
  200208:	c1 e0 03             	shl    $0x3,%eax
  20020b:	09 c1                	or     %eax,%ecx
  20020d:	0f b6 42 07          	movzbl 0x7(%edx),%eax
  200211:	09 c1                	or     %eax,%ecx
        inline void write (Register r, T v) { *reinterpret_cast<T volatile *>(reg_base + r) = v; }

        ALWAYS_INLINE
        static inline Pci *find_dev (unsigned long r)
        {
            for (Pci *pci = list; pci; pci = pci->next)
  200213:	8b 04 24             	mov    (%esp),%eax
  200216:	85 c0                	test   %eax,%eax
  200218:	75 36                	jne    200250 <_ZNK9Acpi_dmar5parseEv+0xba>
    Dmar *dmar = new (Pd::kern.quota) Dmar (static_cast<Paddr>(phys));

    if (flags & 1)
        Pci::claim_all (dmar);

    for (Acpi_scope const *s = scope; s < reinterpret_cast<Acpi_scope *>(reinterpret_cast<mword>(this) + length); s = reinterpret_cast<Acpi_scope *>(reinterpret_cast<mword>(s) + s->length)) {
  20021a:	0f b6 42 01          	movzbl 0x1(%edx),%eax
  20021e:	01 c2                	add    %eax,%edx
  200220:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  200224:	01 f8                	add    %edi,%eax
  200226:	39 c2                	cmp    %eax,%edx
  200228:	72 c7                	jb     2001f1 <_ZNK9Acpi_dmar5parseEv+0x5b>
  20022a:	e9 bc 00 00 00       	jmp    2002eb <_ZNK9Acpi_dmar5parseEv+0x155>

        switch (s->type) {
  20022f:	3c 04                	cmp    $0x4,%al
  200231:	75 e7                	jne    20021a <_ZNK9Acpi_dmar5parseEv+0x84>
                break;
            case 3:
                Ioapic::claim_dev (s->rid(), s->id);
                break;
            case 4:
                Hpet::claim_dev (s->rid(), s->id);
  200233:	0f b6 42 04          	movzbl 0x4(%edx),%eax
  200237:	0f b6 4a 05          	movzbl 0x5(%edx),%ecx
  20023b:	0f b6 5a 06          	movzbl 0x6(%edx),%ebx
  20023f:	8b 74 24 10          	mov    0x10(%esp),%esi
  200243:	89 44 24 04          	mov    %eax,0x4(%esp)
  200247:	8a 42 07             	mov    0x7(%edx),%al
  20024a:	88 44 24 0b          	mov    %al,0xb(%esp)
  20024e:	eb 71                	jmp    2002c1 <_ZNK9Acpi_dmar5parseEv+0x12b>
                if (pci->rid == r)
  200250:	0f b7 58 08          	movzwl 0x8(%eax),%ebx
  200254:	39 cb                	cmp    %ecx,%ebx
  200256:	75 06                	jne    20025e <_ZNK9Acpi_dmar5parseEv+0xc8>
            Pci *pci = find_dev (r);

            if (!pci)
                return false;

            unsigned l = pci->lev;
  200258:	0f b7 48 0a          	movzwl 0xa(%eax),%ecx
  20025c:	eb 0c                	jmp    20026a <_ZNK9Acpi_dmar5parseEv+0xd4>
        inline void write (Register r, T v) { *reinterpret_cast<T volatile *>(reg_base + r) = v; }

        ALWAYS_INLINE
        static inline Pci *find_dev (unsigned long r)
        {
            for (Pci *pci = list; pci; pci = pci->next)
  20025e:	8b 00                	mov    (%eax),%eax
  200260:	eb b4                	jmp    200216 <_ZNK9Acpi_dmar5parseEv+0x80>

            if (!pci)
                return false;

            unsigned l = pci->lev;
            do pci->dmar = d; while ((pci = pci->next) && pci->lev > l);
  200262:	0f b7 58 0a          	movzwl 0xa(%eax),%ebx
  200266:	39 cb                	cmp    %ecx,%ebx
  200268:	76 b0                	jbe    20021a <_ZNK9Acpi_dmar5parseEv+0x84>
  20026a:	89 68 0c             	mov    %ebp,0xc(%eax)
  20026d:	8b 00                	mov    (%eax),%eax
  20026f:	85 c0                	test   %eax,%eax
  200271:	75 ef                	jne    200262 <_ZNK9Acpi_dmar5parseEv+0xcc>
  200273:	eb a5                	jmp    20021a <_ZNK9Acpi_dmar5parseEv+0x84>
  200275:	8a 42 07             	mov    0x7(%edx),%al
        switch (s->type) {
            case 1 ... 2:
                Pci::claim_dev (dmar, s->rid());
                break;
            case 3:
                Ioapic::claim_dev (s->rid(), s->id);
  200278:	0f b6 72 04          	movzbl 0x4(%edx),%esi
  20027c:	0f b6 4a 05          	movzbl 0x5(%edx),%ecx
  200280:	0f b6 5a 06          	movzbl 0x6(%edx),%ebx
  200284:	88 44 24 04          	mov    %al,0x4(%esp)
  200288:	8b 44 24 0c          	mov    0xc(%esp),%eax
  20028c:	85 c0                	test   %eax,%eax
  20028e:	74 8a                	je     20021a <_ZNK9Acpi_dmar5parseEv+0x84>
                if (ioapic->rid == 0 && ioapic->id == i) {
  200290:	66 83 78 10 00       	cmpw   $0x0,0x10(%eax)
  200295:	75 1d                	jne    2002b4 <_ZNK9Acpi_dmar5parseEv+0x11e>
  200297:	39 70 0c             	cmp    %esi,0xc(%eax)
  20029a:	75 18                	jne    2002b4 <_ZNK9Acpi_dmar5parseEv+0x11e>
  20029c:	c1 e1 08             	shl    $0x8,%ecx
  20029f:	c1 e3 03             	shl    $0x3,%ebx
  2002a2:	09 cb                	or     %ecx,%ebx
  2002a4:	0f b6 4c 24 04       	movzbl 0x4(%esp),%ecx
  2002a9:	09 cb                	or     %ecx,%ebx
                    ioapic->rid  = static_cast<uint16>(r);
  2002ab:	66 89 58 10          	mov    %bx,0x10(%eax)
  2002af:	e9 66 ff ff ff       	jmp    20021a <_ZNK9Acpi_dmar5parseEv+0x84>
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline bool claim_dev (unsigned r, unsigned i)
        {
            for (Ioapic *ioapic = list; ioapic; ioapic = ioapic->next)
  2002b4:	8b 00                	mov    (%eax),%eax
  2002b6:	eb d4                	jmp    20028c <_ZNK9Acpi_dmar5parseEv+0xf6>
                if (hpet->rid == 0 && hpet->id == i) {
  2002b8:	66 83 7e 0c 00       	cmpw   $0x0,0xc(%esi)
  2002bd:	74 0b                	je     2002ca <_ZNK9Acpi_dmar5parseEv+0x134>
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline bool claim_dev (unsigned r, unsigned i)
        {
            for (Hpet *hpet = list; hpet; hpet = hpet->next)
  2002bf:	8b 36                	mov    (%esi),%esi
  2002c1:	85 f6                	test   %esi,%esi
  2002c3:	75 f3                	jne    2002b8 <_ZNK9Acpi_dmar5parseEv+0x122>
  2002c5:	e9 50 ff ff ff       	jmp    20021a <_ZNK9Acpi_dmar5parseEv+0x84>
                if (hpet->rid == 0 && hpet->id == i) {
  2002ca:	8b 44 24 04          	mov    0x4(%esp),%eax
  2002ce:	39 46 08             	cmp    %eax,0x8(%esi)
  2002d1:	75 ec                	jne    2002bf <_ZNK9Acpi_dmar5parseEv+0x129>
  2002d3:	c1 e1 08             	shl    $0x8,%ecx
  2002d6:	c1 e3 03             	shl    $0x3,%ebx
  2002d9:	09 cb                	or     %ecx,%ebx
  2002db:	0f b6 4c 24 0b       	movzbl 0xb(%esp),%ecx
  2002e0:	09 cb                	or     %ecx,%ebx
                    hpet->rid = static_cast<uint16>(r);
  2002e2:	66 89 5e 0c          	mov    %bx,0xc(%esi)
  2002e6:	e9 2f ff ff ff       	jmp    20021a <_ZNK9Acpi_dmar5parseEv+0x84>
            case 4:
                Hpet::claim_dev (s->rid(), s->id);
                break;
        }
    }
}
  2002eb:	83 c4 14             	add    $0x14,%esp
  2002ee:	5b                   	pop    %ebx
  2002ef:	5e                   	pop    %esi
  2002f0:	5f                   	pop    %edi
  2002f1:	5d                   	pop    %ebp
  2002f2:	c3                   	ret    
  2002f3:	90                   	nop

002002f4 <_ZNK9Acpi_rmrr5parseEv>:

void Acpi_rmrr::parse() const
{
  2002f4:	55                   	push   %ebp
  2002f5:	89 c5                	mov    %eax,%ebp
  2002f7:	57                   	push   %edi
  2002f8:	56                   	push   %esi
  2002f9:	53                   	push   %ebx
    for (uint64 hpa = base & ~PAGE_MASK; hpa < limit; hpa += PAGE_SIZE)
  2002fa:	8b 40 08             	mov    0x8(%eax),%eax
  2002fd:	8b 7d 0c             	mov    0xc(%ebp),%edi
  200300:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  200305:	89 c6                	mov    %eax,%esi
  200307:	3b 7d 14             	cmp    0x14(%ebp),%edi
  20030a:	73 27                	jae    200333 <_ZNK9Acpi_rmrr5parseEv+0x3f>
        Pd::kern.dpt.update (Pd::kern.quota, hpa, 0, hpa, Dpt::DPT_R | Dpt::DPT_W);
  20030c:	6a 00                	push   $0x0
  20030e:	ba 50 b4 01 c0       	mov    $0xc001b450,%edx
  200313:	6a 03                	push   $0x3
  200315:	b8 18 b4 01 c0       	mov    $0xc001b418,%eax
  20031a:	57                   	push   %edi
  20031b:	56                   	push   %esi
  20031c:	6a 00                	push   $0x0
  20031e:	57                   	push   %edi
  20031f:	56                   	push   %esi
  200320:	e8 55 d7 e0 bf       	call   c000da7a <_ZN3PteI3DptyLj4ELj9ELb1EE6updateER5QuotaymymNS1_4TypeE>
    }
}

void Acpi_rmrr::parse() const
{
    for (uint64 hpa = base & ~PAGE_MASK; hpa < limit; hpa += PAGE_SIZE)
  200325:	81 c6 00 10 00 00    	add    $0x1000,%esi
  20032b:	83 d7 00             	adc    $0x0,%edi
  20032e:	83 c4 1c             	add    $0x1c,%esp
  200331:	eb d4                	jmp    200307 <_ZNK9Acpi_rmrr5parseEv+0x13>
  200333:	77 05                	ja     20033a <_ZNK9Acpi_rmrr5parseEv+0x46>
  200335:	3b 75 10             	cmp    0x10(%ebp),%esi
  200338:	72 d2                	jb     20030c <_ZNK9Acpi_rmrr5parseEv+0x18>
        Pd::kern.dpt.update (Pd::kern.quota, hpa, 0, hpa, Dpt::DPT_R | Dpt::DPT_W);

    for (Acpi_scope const *s = scope; s < reinterpret_cast<Acpi_scope *>(reinterpret_cast<mword>(this) + length); s = reinterpret_cast<Acpi_scope *>(reinterpret_cast<mword>(s) + s->length)) {
  20033a:	8d 5d 18             	lea    0x18(%ebp),%ebx
  20033d:	0f b7 45 02          	movzwl 0x2(%ebp),%eax
  200341:	01 e8                	add    %ebp,%eax
  200343:	39 c3                	cmp    %eax,%ebx
  200345:	73 4b                	jae    200392 <_ZNK9Acpi_rmrr5parseEv+0x9e>

        Dmar *dmar = nullptr;

        switch (s->type) {
  200347:	80 3b 01             	cmpb   $0x1,(%ebx)
  20034a:	75 3e                	jne    20038a <_ZNK9Acpi_rmrr5parseEv+0x96>
  20034c:	0f b6 53 05          	movzbl 0x5(%ebx),%edx
  200350:	0f b6 43 06          	movzbl 0x6(%ebx),%eax
  200354:	c1 e2 08             	shl    $0x8,%edx
  200357:	c1 e0 03             	shl    $0x3,%eax
  20035a:	09 c2                	or     %eax,%edx
  20035c:	0f b6 43 07          	movzbl 0x7(%ebx),%eax
  200360:	09 c2                	or     %eax,%edx
        inline void write (Register r, T v) { *reinterpret_cast<T volatile *>(reg_base + r) = v; }

        ALWAYS_INLINE
        static inline Pci *find_dev (unsigned long r)
        {
            for (Pci *pci = list; pci; pci = pci->next)
  200362:	a1 bc b0 01 c0       	mov    0xc001b0bc,%eax
  200367:	85 c0                	test   %eax,%eax
  200369:	74 1f                	je     20038a <_ZNK9Acpi_rmrr5parseEv+0x96>
                if (pci->rid == r)
  20036b:	0f b7 48 08          	movzwl 0x8(%eax),%ecx
  20036f:	39 d1                	cmp    %edx,%ecx
  200371:	75 13                	jne    200386 <_ZNK9Acpi_rmrr5parseEv+0x92>
        ALWAYS_INLINE
        static inline Dmar *find_dmar (unsigned long r)
        {
            Pci *pci = find_dev (r);

            return pci ? pci->dmar : nullptr;
  200373:	8b 40 0c             	mov    0xc(%eax),%eax
            case 1:
                dmar = Pci::find_dmar (s->rid());
                break;
        }

        if (dmar)
  200376:	85 c0                	test   %eax,%eax
  200378:	74 10                	je     20038a <_ZNK9Acpi_rmrr5parseEv+0x96>
            dmar->assign (s->rid(), &Pd::kern);
  20037a:	b9 c0 b2 01 c0       	mov    $0xc001b2c0,%ecx
  20037f:	e8 b6 21 e0 bf       	call   c000253a <_ZN4Dmar6assignEmP2Pd>
  200384:	eb 04                	jmp    20038a <_ZNK9Acpi_rmrr5parseEv+0x96>
        inline void write (Register r, T v) { *reinterpret_cast<T volatile *>(reg_base + r) = v; }

        ALWAYS_INLINE
        static inline Pci *find_dev (unsigned long r)
        {
            for (Pci *pci = list; pci; pci = pci->next)
  200386:	8b 00                	mov    (%eax),%eax
  200388:	eb dd                	jmp    200367 <_ZNK9Acpi_rmrr5parseEv+0x73>
void Acpi_rmrr::parse() const
{
    for (uint64 hpa = base & ~PAGE_MASK; hpa < limit; hpa += PAGE_SIZE)
        Pd::kern.dpt.update (Pd::kern.quota, hpa, 0, hpa, Dpt::DPT_R | Dpt::DPT_W);

    for (Acpi_scope const *s = scope; s < reinterpret_cast<Acpi_scope *>(reinterpret_cast<mword>(this) + length); s = reinterpret_cast<Acpi_scope *>(reinterpret_cast<mword>(s) + s->length)) {
  20038a:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  20038e:	01 c3                	add    %eax,%ebx
  200390:	eb ab                	jmp    20033d <_ZNK9Acpi_rmrr5parseEv+0x49>
        }

        if (dmar)
            dmar->assign (s->rid(), &Pd::kern);
    }
}
  200392:	5b                   	pop    %ebx
  200393:	5e                   	pop    %esi
  200394:	5f                   	pop    %edi
  200395:	5d                   	pop    %ebp
  200396:	c3                   	ret    
  200397:	90                   	nop

00200398 <_ZNK15Acpi_table_dmar5parseEv>:

void Acpi_table_dmar::parse() const
{
    if (!Cmdline::iommu)
  200398:	80 3d 8c a3 01 c0 00 	cmpb   $0x0,0xc001a38c
  20039f:	74 75                	je     200416 <_ZNK15Acpi_table_dmar5parseEv+0x7e>
            dmar->assign (s->rid(), &Pd::kern);
    }
}

void Acpi_table_dmar::parse() const
{
  2003a1:	56                   	push   %esi
  2003a2:	89 c6                	mov    %eax,%esi
  2003a4:	53                   	push   %ebx
    if (!Cmdline::iommu)
        return;

    for (Acpi_remap const *r = remap; r < reinterpret_cast<Acpi_remap *>(reinterpret_cast<mword>(this) + length); r = reinterpret_cast<Acpi_remap *>(reinterpret_cast<mword>(r) + r->length)) {
  2003a5:	8d 58 30             	lea    0x30(%eax),%ebx
  2003a8:	8b 46 04             	mov    0x4(%esi),%eax
  2003ab:	01 f0                	add    %esi,%eax
  2003ad:	39 c3                	cmp    %eax,%ebx
  2003af:	73 22                	jae    2003d3 <_ZNK15Acpi_table_dmar5parseEv+0x3b>
        switch (r->type) {
  2003b1:	0f b7 03             	movzwl (%ebx),%eax
  2003b4:	85 c0                	test   %eax,%eax
  2003b6:	74 0c                	je     2003c4 <_ZNK15Acpi_table_dmar5parseEv+0x2c>
  2003b8:	48                   	dec    %eax
  2003b9:	75 10                	jne    2003cb <_ZNK15Acpi_table_dmar5parseEv+0x33>
            case Acpi_remap::DMAR:
                static_cast<Acpi_dmar const *>(r)->parse();
                break;
            case Acpi_remap::RMRR:
                static_cast<Acpi_rmrr const *>(r)->parse();
  2003bb:	89 d8                	mov    %ebx,%eax
  2003bd:	e8 32 ff ff ff       	call   2002f4 <_ZNK9Acpi_rmrr5parseEv>
                break;
  2003c2:	eb 07                	jmp    2003cb <_ZNK15Acpi_table_dmar5parseEv+0x33>
        return;

    for (Acpi_remap const *r = remap; r < reinterpret_cast<Acpi_remap *>(reinterpret_cast<mword>(this) + length); r = reinterpret_cast<Acpi_remap *>(reinterpret_cast<mword>(r) + r->length)) {
        switch (r->type) {
            case Acpi_remap::DMAR:
                static_cast<Acpi_dmar const *>(r)->parse();
  2003c4:	89 d8                	mov    %ebx,%eax
  2003c6:	e8 cb fd ff ff       	call   200196 <_ZNK9Acpi_dmar5parseEv>
void Acpi_table_dmar::parse() const
{
    if (!Cmdline::iommu)
        return;

    for (Acpi_remap const *r = remap; r < reinterpret_cast<Acpi_remap *>(reinterpret_cast<mword>(this) + length); r = reinterpret_cast<Acpi_remap *>(reinterpret_cast<mword>(r) + r->length)) {
  2003cb:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  2003cf:	01 c3                	add    %eax,%ebx
  2003d1:	eb d5                	jmp    2003a8 <_ZNK15Acpi_table_dmar5parseEv+0x10>

        ALWAYS_INLINE
        static inline void enable (unsigned flags)
        {
            if (!(flags & 1))
  2003d3:	f6 46 25 01          	testb  $0x1,0x25(%esi)
  2003d7:	75 0a                	jne    2003e3 <_ZNK15Acpi_table_dmar5parseEv+0x4b>
                gcmd &= ~GCMD_IRE;
  2003d9:	81 25 a8 9f 01 c0 ff 	andl   $0xfdffffff,0xc0019fa8
  2003e0:	ff ff fd 

            for (Dmar *dmar = list; dmar; dmar = dmar->next)
  2003e3:	a1 50 a4 01 c0       	mov    0xc001a450,%eax
  2003e8:	85 c0                	test   %eax,%eax
  2003ea:	74 20                	je     20040c <_ZNK15Acpi_table_dmar5parseEv+0x74>
                dmar->command (gcmd);
  2003ec:	8b 15 a8 9f 01 c0    	mov    0xc0019fa8,%edx

        template <typename T>
        ALWAYS_INLINE
        inline void write (Reg reg, T val)
        {
            *reinterpret_cast<T volatile *>(reg_base + reg) = val;
  2003f2:	8b 48 04             	mov    0x4(%eax),%ecx
  2003f5:	89 51 18             	mov    %edx,0x18(%ecx)

        template <typename T>
        ALWAYS_INLINE
        inline T read (Reg reg)
        {
            return *reinterpret_cast<T volatile *>(reg_base + reg);
  2003f8:	8b 48 04             	mov    0x4(%eax),%ecx
  2003fb:	8b 49 1c             	mov    0x1c(%ecx),%ecx

        ALWAYS_INLINE
        inline void command (uint32 val)
        {
            write<uint32>(REG_GCMD, val);
            while ((read<uint32>(REG_GSTS) & val) != val)
  2003fe:	21 d1                	and    %edx,%ecx
  200400:	39 d1                	cmp    %edx,%ecx
  200402:	74 04                	je     200408 <_ZNK15Acpi_table_dmar5parseEv+0x70>
}

ALWAYS_INLINE
static inline void pause()
{
    asm volatile ("pause" : : : "memory");
  200404:	f3 90                	pause  
  200406:	eb f0                	jmp    2003f8 <_ZNK15Acpi_table_dmar5parseEv+0x60>
        static inline void enable (unsigned flags)
        {
            if (!(flags & 1))
                gcmd &= ~GCMD_IRE;

            for (Dmar *dmar = list; dmar; dmar = dmar->next)
  200408:	8b 00                	mov    (%eax),%eax
  20040a:	eb dc                	jmp    2003e8 <_ZNK15Acpi_table_dmar5parseEv+0x50>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }
  20040c:	f0 83 0d 10 e0 01 c0 	lock orl $0x1,0xc001e010
  200413:	01 
    }

    Dmar::enable (flags);

    Hip::set_feature (Hip::FEAT_IOMMU);
}
  200414:	5b                   	pop    %ebx
  200415:	5e                   	pop    %esi
  200416:	c3                   	ret    
  200417:	90                   	nop

00200418 <_ZNK15Acpi_table_fadt5parseEv>:
#include "acpi_fadt.hpp"
#include "io.hpp"
#include "x86.hpp"

void Acpi_table_fadt::parse() const
{
  200418:	57                   	push   %edi
  200419:	56                   	push   %esi
  20041a:	53                   	push   %ebx
    Acpi::irq     = sci_irq;
  20041b:	0f b7 50 2e          	movzwl 0x2e(%eax),%edx
  20041f:	89 15 88 a2 01 c0    	mov    %edx,0xc001a288
    Acpi::feature = flags;
  200425:	8b 50 70             	mov    0x70(%eax),%edx
  200428:	89 15 90 a2 01 c0    	mov    %edx,0xc001a290

    // XXX: Use x_pm blocks if they exist

    if (pm1a_evt_blk) {
  20042e:	8b 50 38             	mov    0x38(%eax),%edx
  200431:	85 d2                	test   %edx,%edx
  200433:	74 47                	je     20047c <_ZNK15Acpi_table_fadt5parseEv+0x64>
        Acpi::pm1a_sts.init (Acpi_gas::IO, pm1_evt_len >> 1, pm1a_evt_blk);
  200435:	0f b6 48 58          	movzbl 0x58(%eax),%ecx
  200439:	89 15 2c a3 01 c0    	mov    %edx,0xc001a32c
            FIXED       = 0x7f
        };

        void init (Asid reg_asid, unsigned reg_bytes, uint64 reg_addr)
        {
            asid = reg_asid;
  20043f:	c6 05 28 a3 01 c0 01 	movb   $0x1,0xc001a328
  200446:	c7 05 30 a3 01 c0 00 	movl   $0x0,0xc001a330
  20044d:	00 00 00 
  200450:	d1 f9                	sar    %ecx
            bits = static_cast<uint8>(reg_bytes * 8);
  200452:	88 cb                	mov    %cl,%bl
        Acpi::pm1a_ena.init (Acpi_gas::IO, pm1_evt_len >> 1, pm1a_evt_blk + (pm1_evt_len >> 1));
  200454:	01 ca                	add    %ecx,%edx
  200456:	c0 e3 03             	shl    $0x3,%bl
  200459:	88 1d 29 a3 01 c0    	mov    %bl,0xc001a329
            FIXED       = 0x7f
        };

        void init (Asid reg_asid, unsigned reg_bytes, uint64 reg_addr)
        {
            asid = reg_asid;
  20045f:	c6 05 10 a3 01 c0 01 	movb   $0x1,0xc001a310
            bits = static_cast<uint8>(reg_bytes * 8);
  200466:	88 1d 11 a3 01 c0    	mov    %bl,0xc001a311
  20046c:	89 15 14 a3 01 c0    	mov    %edx,0xc001a314
  200472:	c7 05 18 a3 01 c0 00 	movl   $0x0,0xc001a318
  200479:	00 00 00 
    }
    if (pm1b_evt_blk) {
  20047c:	8b 50 3c             	mov    0x3c(%eax),%edx
  20047f:	85 d2                	test   %edx,%edx
  200481:	74 47                	je     2004ca <_ZNK15Acpi_table_fadt5parseEv+0xb2>
        Acpi::pm1b_sts.init (Acpi_gas::IO, pm1_evt_len >> 1, pm1b_evt_blk);
  200483:	0f b6 48 58          	movzbl 0x58(%eax),%ecx
  200487:	89 15 20 a3 01 c0    	mov    %edx,0xc001a320
            FIXED       = 0x7f
        };

        void init (Asid reg_asid, unsigned reg_bytes, uint64 reg_addr)
        {
            asid = reg_asid;
  20048d:	c6 05 1c a3 01 c0 01 	movb   $0x1,0xc001a31c
  200494:	c7 05 24 a3 01 c0 00 	movl   $0x0,0xc001a324
  20049b:	00 00 00 
  20049e:	d1 f9                	sar    %ecx
            bits = static_cast<uint8>(reg_bytes * 8);
  2004a0:	88 cb                	mov    %cl,%bl
        Acpi::pm1b_ena.init (Acpi_gas::IO, pm1_evt_len >> 1, pm1b_evt_blk + (pm1_evt_len >> 1));
  2004a2:	01 ca                	add    %ecx,%edx
  2004a4:	c0 e3 03             	shl    $0x3,%bl
  2004a7:	88 1d 1d a3 01 c0    	mov    %bl,0xc001a31d
            FIXED       = 0x7f
        };

        void init (Asid reg_asid, unsigned reg_bytes, uint64 reg_addr)
        {
            asid = reg_asid;
  2004ad:	c6 05 04 a3 01 c0 01 	movb   $0x1,0xc001a304
            bits = static_cast<uint8>(reg_bytes * 8);
  2004b4:	88 1d 05 a3 01 c0    	mov    %bl,0xc001a305
  2004ba:	89 15 08 a3 01 c0    	mov    %edx,0xc001a308
  2004c0:	c7 05 0c a3 01 c0 00 	movl   $0x0,0xc001a30c
  2004c7:	00 00 00 
    }

    if (pm1a_cnt_blk)
  2004ca:	8b 48 40             	mov    0x40(%eax),%ecx
  2004cd:	85 c9                	test   %ecx,%ecx
  2004cf:	74 23                	je     2004f4 <_ZNK15Acpi_table_fadt5parseEv+0xdc>
  2004d1:	8a 50 59             	mov    0x59(%eax),%dl
            FIXED       = 0x7f
        };

        void init (Asid reg_asid, unsigned reg_bytes, uint64 reg_addr)
        {
            asid = reg_asid;
  2004d4:	c6 05 f8 a2 01 c0 01 	movb   $0x1,0xc001a2f8
        Acpi::pm1a_cnt.init (Acpi_gas::IO, pm1_cnt_len, pm1a_cnt_blk);
  2004db:	89 0d fc a2 01 c0    	mov    %ecx,0xc001a2fc
  2004e1:	c7 05 00 a3 01 c0 00 	movl   $0x0,0xc001a300
  2004e8:	00 00 00 
            bits = static_cast<uint8>(reg_bytes * 8);
  2004eb:	c0 e2 03             	shl    $0x3,%dl
  2004ee:	88 15 f9 a2 01 c0    	mov    %dl,0xc001a2f9

    if (pm1b_cnt_blk)
  2004f4:	8b 48 44             	mov    0x44(%eax),%ecx
  2004f7:	85 c9                	test   %ecx,%ecx
  2004f9:	74 23                	je     20051e <_ZNK15Acpi_table_fadt5parseEv+0x106>
  2004fb:	8a 50 59             	mov    0x59(%eax),%dl
            FIXED       = 0x7f
        };

        void init (Asid reg_asid, unsigned reg_bytes, uint64 reg_addr)
        {
            asid = reg_asid;
  2004fe:	c6 05 ec a2 01 c0 01 	movb   $0x1,0xc001a2ec
        Acpi::pm1b_cnt.init (Acpi_gas::IO, pm1_cnt_len, pm1b_cnt_blk);
  200505:	89 0d f0 a2 01 c0    	mov    %ecx,0xc001a2f0
  20050b:	c7 05 f4 a2 01 c0 00 	movl   $0x0,0xc001a2f4
  200512:	00 00 00 
            bits = static_cast<uint8>(reg_bytes * 8);
  200515:	c0 e2 03             	shl    $0x3,%dl
  200518:	88 15 ed a2 01 c0    	mov    %dl,0xc001a2ed

    if (pm2_cnt_blk)
  20051e:	8b 48 48             	mov    0x48(%eax),%ecx
  200521:	85 c9                	test   %ecx,%ecx
  200523:	74 23                	je     200548 <_ZNK15Acpi_table_fadt5parseEv+0x130>
  200525:	8a 50 5a             	mov    0x5a(%eax),%dl
            FIXED       = 0x7f
        };

        void init (Asid reg_asid, unsigned reg_bytes, uint64 reg_addr)
        {
            asid = reg_asid;
  200528:	c6 05 e0 a2 01 c0 01 	movb   $0x1,0xc001a2e0
        Acpi::pm2_cnt.init (Acpi_gas::IO, pm2_cnt_len, pm2_cnt_blk);
  20052f:	89 0d e4 a2 01 c0    	mov    %ecx,0xc001a2e4
  200535:	c7 05 e8 a2 01 c0 00 	movl   $0x0,0xc001a2e8
  20053c:	00 00 00 
            bits = static_cast<uint8>(reg_bytes * 8);
  20053f:	c0 e2 03             	shl    $0x3,%dl
  200542:	88 15 e1 a2 01 c0    	mov    %dl,0xc001a2e1

    if (pm_tmr_blk)
  200548:	8b 48 4c             	mov    0x4c(%eax),%ecx
  20054b:	85 c9                	test   %ecx,%ecx
  20054d:	74 23                	je     200572 <_ZNK15Acpi_table_fadt5parseEv+0x15a>
  20054f:	8a 50 5b             	mov    0x5b(%eax),%dl
            FIXED       = 0x7f
        };

        void init (Asid reg_asid, unsigned reg_bytes, uint64 reg_addr)
        {
            asid = reg_asid;
  200552:	c6 05 d4 a2 01 c0 01 	movb   $0x1,0xc001a2d4
        Acpi::pm_tmr.init (Acpi_gas::IO, pm_tmr_len, pm_tmr_blk);
  200559:	89 0d d8 a2 01 c0    	mov    %ecx,0xc001a2d8
  20055f:	c7 05 dc a2 01 c0 00 	movl   $0x0,0xc001a2dc
  200566:	00 00 00 
            bits = static_cast<uint8>(reg_bytes * 8);
  200569:	c0 e2 03             	shl    $0x3,%dl
  20056c:	88 15 d5 a2 01 c0    	mov    %dl,0xc001a2d5

    if (gpe0_blk) {
  200572:	8b 50 50             	mov    0x50(%eax),%edx
  200575:	85 d2                	test   %edx,%edx
  200577:	74 47                	je     2005c0 <_ZNK15Acpi_table_fadt5parseEv+0x1a8>
        Acpi::gpe0_sts.init (Acpi_gas::IO, gpe0_blk_len >> 1, gpe0_blk);
  200579:	0f b6 48 5c          	movzbl 0x5c(%eax),%ecx
  20057d:	89 15 c0 a2 01 c0    	mov    %edx,0xc001a2c0
            FIXED       = 0x7f
        };

        void init (Asid reg_asid, unsigned reg_bytes, uint64 reg_addr)
        {
            asid = reg_asid;
  200583:	c6 05 bc a2 01 c0 01 	movb   $0x1,0xc001a2bc
  20058a:	c7 05 c4 a2 01 c0 00 	movl   $0x0,0xc001a2c4
  200591:	00 00 00 
  200594:	d1 f9                	sar    %ecx
            bits = static_cast<uint8>(reg_bytes * 8);
  200596:	88 cb                	mov    %cl,%bl
        Acpi::gpe0_ena.init (Acpi_gas::IO, gpe0_blk_len >> 1, gpe0_blk + (gpe0_blk_len >> 1));
  200598:	01 ca                	add    %ecx,%edx
  20059a:	c0 e3 03             	shl    $0x3,%bl
  20059d:	88 1d bd a2 01 c0    	mov    %bl,0xc001a2bd
            FIXED       = 0x7f
        };

        void init (Asid reg_asid, unsigned reg_bytes, uint64 reg_addr)
        {
            asid = reg_asid;
  2005a3:	c6 05 a4 a2 01 c0 01 	movb   $0x1,0xc001a2a4
            bits = static_cast<uint8>(reg_bytes * 8);
  2005aa:	88 1d a5 a2 01 c0    	mov    %bl,0xc001a2a5
  2005b0:	89 15 a8 a2 01 c0    	mov    %edx,0xc001a2a8
  2005b6:	c7 05 ac a2 01 c0 00 	movl   $0x0,0xc001a2ac
  2005bd:	00 00 00 
    }

    if (gpe1_blk) {
  2005c0:	8b 50 54             	mov    0x54(%eax),%edx
  2005c3:	85 d2                	test   %edx,%edx
  2005c5:	74 47                	je     20060e <_ZNK15Acpi_table_fadt5parseEv+0x1f6>
        Acpi::gpe1_sts.init (Acpi_gas::IO, gpe1_blk_len >> 1, gpe1_blk);
  2005c7:	0f b6 48 5d          	movzbl 0x5d(%eax),%ecx
  2005cb:	89 15 b4 a2 01 c0    	mov    %edx,0xc001a2b4
            FIXED       = 0x7f
        };

        void init (Asid reg_asid, unsigned reg_bytes, uint64 reg_addr)
        {
            asid = reg_asid;
  2005d1:	c6 05 b0 a2 01 c0 01 	movb   $0x1,0xc001a2b0
  2005d8:	c7 05 b8 a2 01 c0 00 	movl   $0x0,0xc001a2b8
  2005df:	00 00 00 
  2005e2:	d1 f9                	sar    %ecx
            bits = static_cast<uint8>(reg_bytes * 8);
  2005e4:	88 cb                	mov    %cl,%bl
        Acpi::gpe1_ena.init (Acpi_gas::IO, gpe1_blk_len >> 1, gpe1_blk + (gpe1_blk_len >> 1));
  2005e6:	01 ca                	add    %ecx,%edx
  2005e8:	c0 e3 03             	shl    $0x3,%bl
  2005eb:	88 1d b1 a2 01 c0    	mov    %bl,0xc001a2b1
            FIXED       = 0x7f
        };

        void init (Asid reg_asid, unsigned reg_bytes, uint64 reg_addr)
        {
            asid = reg_asid;
  2005f1:	c6 05 98 a2 01 c0 01 	movb   $0x1,0xc001a298
            bits = static_cast<uint8>(reg_bytes * 8);
  2005f8:	88 1d 99 a2 01 c0    	mov    %bl,0xc001a299
  2005fe:	89 15 9c a2 01 c0    	mov    %edx,0xc001a29c
  200604:	c7 05 a0 a2 01 c0 00 	movl   $0x0,0xc001a2a0
  20060b:	00 00 00 
    }

    if (length >= 129) {
  20060e:	81 78 04 80 00 00 00 	cmpl   $0x80,0x4(%eax)
  200615:	76 1b                	jbe    200632 <_ZNK15Acpi_table_fadt5parseEv+0x21a>
        Acpi::reset_reg = reset_reg;
  200617:	bf c8 a2 01 c0       	mov    $0xc001a2c8,%edi
  20061c:	b9 03 00 00 00       	mov    $0x3,%ecx
        Acpi::reset_val = reset_value;
  200621:	8a 90 80 00 00 00    	mov    0x80(%eax),%dl
        Acpi::gpe1_sts.init (Acpi_gas::IO, gpe1_blk_len >> 1, gpe1_blk);
        Acpi::gpe1_ena.init (Acpi_gas::IO, gpe1_blk_len >> 1, gpe1_blk + (gpe1_blk_len >> 1));
    }

    if (length >= 129) {
        Acpi::reset_reg = reset_reg;
  200627:	8d 70 74             	lea    0x74(%eax),%esi
  20062a:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
        Acpi::reset_val = reset_value;
  20062c:	88 15 8c a2 01 c0    	mov    %dl,0xc001a28c
    }

    if (smi_cmd && acpi_enable) {
  200632:	8b 50 30             	mov    0x30(%eax),%edx
  200635:	85 d2                	test   %edx,%edx
  200637:	74 1a                	je     200653 <_ZNK15Acpi_table_fadt5parseEv+0x23b>
  200639:	8a 40 34             	mov    0x34(%eax),%al
  20063c:	84 c0                	test   %al,%al
  20063e:	74 13                	je     200653 <_ZNK15Acpi_table_fadt5parseEv+0x23b>

        template <typename T>
        ALWAYS_INLINE
        static inline void out (unsigned port, T val)
        {
            asm volatile ("out %0, %w1" : : "a" (val), "Nd" (port));
  200640:	ee                   	out    %al,(%dx)
        Io::out (smi_cmd, acpi_enable);
        while (!(Acpi::read (Acpi::PM1_CNT) & Acpi::PM1_CNT_SCI_EN))
  200641:	b8 02 00 00 00       	mov    $0x2,%eax
  200646:	e8 cb 02 e0 bf       	call   c0000916 <_ZN4Acpi4readENS_8RegisterE>
  20064b:	a8 01                	test   $0x1,%al
  20064d:	75 04                	jne    200653 <_ZNK15Acpi_table_fadt5parseEv+0x23b>
  20064f:	f3 90                	pause  
  200651:	eb ee                	jmp    200641 <_ZNK15Acpi_table_fadt5parseEv+0x229>
            pause();
    }
}
  200653:	5b                   	pop    %ebx
  200654:	5e                   	pop    %esi
  200655:	5f                   	pop    %edi
  200656:	c3                   	ret    
  200657:	90                   	nop

00200658 <_ZNK15Acpi_table_hpet5parseEv>:
#include "hpet.hpp"
#include "pd.hpp"

void Acpi_table_hpet::parse() const
{
    if (hpet.asid == Acpi_gas::MEMORY)
  200658:	80 78 28 00          	cmpb   $0x0,0x28(%eax)
  20065c:	75 45                	jne    2006a3 <_ZNK15Acpi_table_hpet5parseEv+0x4b>
#include "acpi_hpet.hpp"
#include "hpet.hpp"
#include "pd.hpp"

void Acpi_table_hpet::parse() const
{
  20065e:	56                   	push   %esi
    public:
        ALWAYS_INLINE
        explicit inline Hpet (Paddr p, unsigned i) : List<Hpet> (list), phys (p), id (i), rid (0) {}

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
  20065f:	ba 50 b4 01 c0       	mov    $0xc001b450,%edx
  200664:	53                   	push   %ebx
  200665:	89 c3                	mov    %eax,%ebx
  200667:	b8 ec aa 01 c0       	mov    $0xc001aaec,%eax
  20066c:	e8 05 fc e0 bf       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
    if (hpet.asid == Acpi_gas::MEMORY)
        new (Pd::kern.quota) Hpet (static_cast<Paddr>(hpet.addr), id);
  200671:	0f b6 73 34          	movzbl 0x34(%ebx),%esi

    public:
        ALWAYS_INLINE
        explicit inline List (T *&list) : next (nullptr)
        {
            T **ptr; for (ptr = &list; *ptr; ptr = &(*ptr)->next) ; *ptr = static_cast<T *>(this);
  200675:	b9 e8 aa 01 c0       	mov    $0xc001aae8,%ecx
  20067a:	8b 5b 2c             	mov    0x2c(%ebx),%ebx
    protected:
        T *next;

    public:
        ALWAYS_INLINE
        explicit inline List (T *&list) : next (nullptr)
  20067d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        {
            T **ptr; for (ptr = &list; *ptr; ptr = &(*ptr)->next) ; *ptr = static_cast<T *>(this);
  200683:	8b 15 e8 aa 01 c0    	mov    0xc001aae8,%edx
  200689:	85 d2                	test   %edx,%edx
  20068b:	74 06                	je     200693 <_ZNK15Acpi_table_hpet5parseEv+0x3b>
  20068d:	89 d1                	mov    %edx,%ecx
  20068f:	8b 12                	mov    (%edx),%edx
  200691:	eb f6                	jmp    200689 <_ZNK15Acpi_table_hpet5parseEv+0x31>
  200693:	89 01                	mov    %eax,(%ecx)
        static Hpet *       list;
        static Slab_cache   cache;

    public:
        ALWAYS_INLINE
        explicit inline Hpet (Paddr p, unsigned i) : List<Hpet> (list), phys (p), id (i), rid (0) {}
  200695:	89 58 04             	mov    %ebx,0x4(%eax)
  200698:	89 70 08             	mov    %esi,0x8(%eax)
  20069b:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
}
  2006a1:	5b                   	pop    %ebx
  2006a2:	5e                   	pop    %esi
  2006a3:	c3                   	ret    

002006a4 <_ZN15Acpi_table_madt10parse_intrEPK9Acpi_apic>:
    for (unsigned short i = 0; i <= max && gsi < NUM_GSI; i++, gsi++)
        Gsi::gsi_table[gsi].ioapic = ioapic;
}

void Acpi_table_madt::parse_intr (Acpi_apic const *ptr)
{
  2006a4:	55                   	push   %ebp
  2006a5:	57                   	push   %edi
  2006a6:	89 c7                	mov    %eax,%edi
  2006a8:	56                   	push   %esi
  2006a9:	53                   	push   %ebx
    Acpi_intr const *p = static_cast<Acpi_intr const *>(ptr);

    unsigned irq = p->irq;
  2006aa:	0f b6 70 03          	movzbl 0x3(%eax),%esi
    unsigned gsi = p->gsi;
  2006ae:	8b 48 04             	mov    0x4(%eax),%ecx

    if (EXPECT_FALSE (gsi >= NUM_GSI || irq >= NUM_IRQ || p->bus))
  2006b1:	83 fe 0f             	cmp    $0xf,%esi
  2006b4:	0f 97 c3             	seta   %bl
  2006b7:	83 f9 7f             	cmp    $0x7f,%ecx
  2006ba:	0f 97 c2             	seta   %dl
  2006bd:	08 da                	or     %bl,%dl
  2006bf:	75 7f                	jne    200740 <_ZN15Acpi_table_madt10parse_intrEPK9Acpi_apic+0x9c>
  2006c1:	80 78 02 00          	cmpb   $0x0,0x2(%eax)
  2006c5:	75 79                	jne    200740 <_ZN15Acpi_table_madt10parse_intrEPK9Acpi_apic+0x9c>
        return;

    Gsi::irq_table[irq] = gsi;
  2006c7:	89 0c b5 a0 a4 01 c0 	mov    %ecx,-0x3ffe5b60(,%esi,4)

    Gsi::gsi_table[gsi].pol = p->flags.pol == Acpi_inti::POL_LOW   || (p->flags.pol == Acpi_inti::POL_CONFORMING && irq == Acpi::irq);
  2006ce:	8a 58 08             	mov    0x8(%eax),%bl
  2006d1:	b0 01                	mov    $0x1,%al
  2006d3:	80 e3 03             	and    $0x3,%bl
  2006d6:	80 fb 03             	cmp    $0x3,%bl
  2006d9:	74 0f                	je     2006ea <_ZN15Acpi_table_madt10parse_intrEPK9Acpi_apic+0x46>
  2006db:	31 c0                	xor    %eax,%eax
  2006dd:	84 db                	test   %bl,%bl
  2006df:	75 09                	jne    2006ea <_ZN15Acpi_table_madt10parse_intrEPK9Acpi_apic+0x46>
  2006e1:	3b 35 88 a2 01 c0    	cmp    0xc001a288,%esi
  2006e7:	0f 94 c0             	sete   %al
  2006ea:	6b e9 0c             	imul   $0xc,%ecx,%ebp
  2006ed:	c0 e0 05             	shl    $0x5,%al
  2006f0:	8a 9d e9 a4 01 c0    	mov    -0x3ffe5b17(%ebp),%bl
  2006f6:	80 e3 df             	and    $0xdf,%bl
  2006f9:	08 c3                	or     %al,%bl
  2006fb:	88 9d e9 a4 01 c0    	mov    %bl,-0x3ffe5b17(%ebp)
    Gsi::gsi_table[gsi].trg = p->flags.trg == Acpi_inti::TRG_LEVEL || (p->flags.trg == Acpi_inti::TRG_CONFORMING && irq == Acpi::irq);
  200701:	8a 47 08             	mov    0x8(%edi),%al
  200704:	24 0c                	and    $0xc,%al
  200706:	3c 0c                	cmp    $0xc,%al
  200708:	74 0f                	je     200719 <_ZN15Acpi_table_madt10parse_intrEPK9Acpi_apic+0x75>
  20070a:	84 c0                	test   %al,%al
  20070c:	75 0d                	jne    20071b <_ZN15Acpi_table_madt10parse_intrEPK9Acpi_apic+0x77>
  20070e:	3b 35 88 a2 01 c0    	cmp    0xc001a288,%esi
  200714:	0f 94 c2             	sete   %dl
  200717:	eb 02                	jmp    20071b <_ZN15Acpi_table_madt10parse_intrEPK9Acpi_apic+0x77>
  200719:	b2 01                	mov    $0x1,%dl
  20071b:	6b c9 0c             	imul   $0xc,%ecx,%ecx
  20071e:	c0 e2 07             	shl    $0x7,%dl
  200721:	8a 81 e9 a4 01 c0    	mov    -0x3ffe5b17(%ecx),%al
  200727:	24 7f                	and    $0x7f,%al
  200729:	08 c2                	or     %al,%dl

    if (irq == Acpi::irq)
  20072b:	3b 35 88 a2 01 c0    	cmp    0xc001a288,%esi
        return;

    Gsi::irq_table[irq] = gsi;

    Gsi::gsi_table[gsi].pol = p->flags.pol == Acpi_inti::POL_LOW   || (p->flags.pol == Acpi_inti::POL_CONFORMING && irq == Acpi::irq);
    Gsi::gsi_table[gsi].trg = p->flags.trg == Acpi_inti::TRG_LEVEL || (p->flags.trg == Acpi_inti::TRG_CONFORMING && irq == Acpi::irq);
  200731:	88 91 e9 a4 01 c0    	mov    %dl,-0x3ffe5b17(%ecx)

    if (irq == Acpi::irq)
  200737:	75 07                	jne    200740 <_ZN15Acpi_table_madt10parse_intrEPK9Acpi_apic+0x9c>
        sci_overridden = true;
  200739:	c6 05 80 a2 01 c0 01 	movb   $0x1,0xc001a280
}
  200740:	5b                   	pop    %ebx
  200741:	5e                   	pop    %esi
  200742:	5f                   	pop    %edi
  200743:	5d                   	pop    %ebp
  200744:	c3                   	ret    
  200745:	90                   	nop

00200746 <_ZN15Acpi_table_madt11parse_lapicEPK9Acpi_apic>:

void Acpi_table_madt::parse_lapic (Acpi_apic const *ptr)
{
    Acpi_lapic const *p = static_cast<Acpi_lapic const *>(ptr);

    if (p->flags & 1 && Cpu::online < NUM_CPU) {
  200746:	f6 40 04 01          	testb  $0x1,0x4(%eax)
  20074a:	74 26                	je     200772 <_ZN15Acpi_table_madt11parse_lapicEPK9Acpi_apic+0x2c>
  20074c:	8b 15 40 a4 01 c0    	mov    0xc001a440,%edx
  200752:	83 fa 3f             	cmp    $0x3f,%edx
  200755:	77 1b                	ja     200772 <_ZN15Acpi_table_madt11parse_lapicEPK9Acpi_apic+0x2c>
        Cpu::acpi_id[Cpu::online]   = p->acpi_id;
  200757:	8a 48 02             	mov    0x2(%eax),%cl
  20075a:	88 8a 00 a4 01 c0    	mov    %cl,-0x3ffe5c00(%edx)
        Cpu::apic_id[Cpu::online++] = p->apic_id;
  200760:	8d 4a 01             	lea    0x1(%edx),%ecx
  200763:	89 0d 40 a4 01 c0    	mov    %ecx,0xc001a440
  200769:	8a 40 03             	mov    0x3(%eax),%al
  20076c:	88 82 c0 a3 01 c0    	mov    %al,-0x3ffe5c40(%edx)
  200772:	c3                   	ret    
  200773:	90                   	nop

00200774 <_ZN15Acpi_table_madt12parse_ioapicEPK9Acpi_apic>:
    }
}

void Acpi_table_madt::parse_ioapic (Acpi_apic const *ptr)
{
  200774:	55                   	push   %ebp
    public:
        INIT
        Ioapic (Paddr, unsigned, unsigned);

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
  200775:	ba 50 b4 01 c0       	mov    $0xc001b450,%edx
  20077a:	57                   	push   %edi
  20077b:	56                   	push   %esi
  20077c:	53                   	push   %ebx
  20077d:	89 c3                	mov    %eax,%ebx
  20077f:	b8 5c b0 01 c0       	mov    $0xc001b05c,%eax
  200784:	e8 ed fa e0 bf       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
    Acpi_ioapic const *p = static_cast<Acpi_ioapic const *>(ptr);

    Ioapic *ioapic = new (Pd::kern.quota) Ioapic (p->phys, p->id, p->gsi);
  200789:	0f b6 4b 02          	movzbl 0x2(%ebx),%ecx
  20078d:	8b 53 04             	mov    0x4(%ebx),%edx
  200790:	ff 73 08             	pushl  0x8(%ebx)
  200793:	89 c6                	mov    %eax,%esi
  200795:	e8 6a 0b 00 00       	call   201304 <_ZN6IoapicC1Emjj>

    unsigned gsi = p->gsi;
  20079a:	8b 7b 08             	mov    0x8(%ebx),%edi
        }

        ALWAYS_INLINE
        inline uint32 read (Register reg)
        {
            Lock_guard <Spinlock> guard (lock);
  20079d:	8d 46 12             	lea    0x12(%esi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
  2007a0:	9c                   	pushf  
  2007a1:	5b                   	pop    %ebx
            return flags & 0x200;
  2007a2:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
  2007a5:	80 e3 01             	and    $0x1,%bl
  2007a8:	5a                   	pop    %edx
  2007a9:	74 27                	je     2007d2 <_ZN15Acpi_table_madt12parse_ioapicEPK9Acpi_apic+0x5e>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
  2007ab:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
  2007b2:	75 16                	jne    2007ca <_ZN15Acpi_table_madt12parse_ioapicEPK9Acpi_apic+0x56>
  2007b4:	68 e0 61 01 c0       	push   $0xc00161e0
  2007b9:	68 b7 00 00 00       	push   $0xb7
  2007be:	68 12 61 01 c0       	push   $0xc0016112
  2007c3:	68 83 61 01 c0       	push   $0xc0016183
  2007c8:	eb 3d                	jmp    200807 <_ZN15Acpi_table_madt12parse_ioapicEPK9Acpi_apic+0x93>

            asm volatile ("cli" : : : "memory");
  2007ca:	fa                   	cli    
            preemption = false;
  2007cb:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
  2007d2:	e8 55 03 e0 bf       	call   c0000b2c <_ZN8Spinlock4lockEv>
        };

        ALWAYS_INLINE
        inline void index (Register reg)
        {
            *reinterpret_cast<uint8 volatile *>(reg_base + IOAPIC_IDX) = reg;
  2007d7:	8b 46 04             	mov    0x4(%esi),%eax
  2007da:	c6 00 01             	movb   $0x1,(%eax)
        ALWAYS_INLINE
        inline uint32 read (Register reg)
        {
            Lock_guard <Spinlock> guard (lock);
            index (reg);
            return *reinterpret_cast<uint32 volatile *>(reg_base + IOAPIC_WND);
  2007dd:	8b 46 04             	mov    0x4(%esi),%eax
  2007e0:	8b 40 10             	mov    0x10(%eax),%eax
        }

        ALWAYS_INLINE
        inline void unlock()
        {
            asm volatile ("incb %0" : "=m" (val) : : "memory");
  2007e3:	fe 46 12             	incb   0x12(%esi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
  2007e6:	84 db                	test   %bl,%bl
  2007e8:	74 2f                	je     200819 <_ZN15Acpi_table_madt12parse_ioapicEPK9Acpi_apic+0xa5>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
  2007ea:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
  2007f1:	74 1e                	je     200811 <_ZN15Acpi_table_madt12parse_ioapicEPK9Acpi_apic+0x9d>
  2007f3:	68 a0 61 01 c0       	push   $0xc00161a0
  2007f8:	68 c0 00 00 00       	push   $0xc0
  2007fd:	68 12 61 01 c0       	push   $0xc0016112
  200802:	68 82 61 01 c0       	push   $0xc0016182
  200807:	68 69 60 01 c0       	push   $0xc0016069
  20080c:	e8 35 11 e0 bf       	call   c0001946 <_ZN7Console5panicEPKcz>

            preemption = true;
  200811:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
  200818:	fb                   	sti    
  200819:	6b ef 0c             	imul   $0xc,%edi,%ebp

        ALWAYS_INLINE
        inline unsigned prq() { return read (IOAPIC_VER) >> 15 & 0x1; }

        ALWAYS_INLINE
        inline unsigned irt_max() { return read (IOAPIC_VER) >> 16 & 0xff; }
  20081c:	c1 e8 10             	shr    $0x10,%eax
  20081f:	0f b6 d8             	movzbl %al,%ebx
    unsigned max = ioapic->irt_max();

    for (unsigned short i = 0; i <= max && gsi < NUM_GSI; i++, gsi++)
  200822:	31 c0                	xor    %eax,%eax
  200824:	8d 14 38             	lea    (%eax,%edi,1),%edx
  200827:	83 fa 7f             	cmp    $0x7f,%edx
  20082a:	0f 96 c1             	setbe  %cl
  20082d:	39 d8                	cmp    %ebx,%eax
  20082f:	0f 96 c2             	setbe  %dl
  200832:	40                   	inc    %eax
  200833:	84 d1                	test   %dl,%cl
  200835:	74 0c                	je     200843 <_ZN15Acpi_table_madt12parse_ioapicEPK9Acpi_apic+0xcf>
  200837:	6b d0 0c             	imul   $0xc,%eax,%edx
        Gsi::gsi_table[gsi].ioapic = ioapic;
  20083a:	89 b4 15 d8 a4 01 c0 	mov    %esi,-0x3ffe5b28(%ebp,%edx,1)
  200841:	eb e1                	jmp    200824 <_ZN15Acpi_table_madt12parse_ioapicEPK9Acpi_apic+0xb0>
}
  200843:	5b                   	pop    %ebx
  200844:	5e                   	pop    %esi
  200845:	5f                   	pop    %edi
  200846:	5d                   	pop    %ebp
  200847:	c3                   	ret    

00200848 <_ZNK15Acpi_table_madt11parse_entryEN9Acpi_apic4TypeEPFvPKS0_E>:
        Io::out<uint8>(0x21, 0xff);
    }
}

void Acpi_table_madt::parse_entry (Acpi_apic::Type type, void (*handler)(Acpi_apic const *)) const
{
  200848:	55                   	push   %ebp
  200849:	89 cd                	mov    %ecx,%ebp
  20084b:	57                   	push   %edi
  20084c:	89 d7                	mov    %edx,%edi
  20084e:	56                   	push   %esi
  20084f:	89 c6                	mov    %eax,%esi
  200851:	53                   	push   %ebx
    for (Acpi_apic const *ptr = apic; ptr < reinterpret_cast<Acpi_apic *>(reinterpret_cast<mword>(this) + length); ptr = reinterpret_cast<Acpi_apic *>(reinterpret_cast<mword>(ptr) + ptr->length))
  200852:	8d 58 2c             	lea    0x2c(%eax),%ebx
  200855:	8b 46 04             	mov    0x4(%esi),%eax
  200858:	01 f0                	add    %esi,%eax
  20085a:	39 c3                	cmp    %eax,%ebx
  20085c:	73 13                	jae    200871 <_ZNK15Acpi_table_madt11parse_entryEN9Acpi_apic4TypeEPFvPKS0_E+0x29>
        if (ptr->type == type)
  20085e:	0f b6 03             	movzbl (%ebx),%eax
  200861:	39 f8                	cmp    %edi,%eax
  200863:	75 04                	jne    200869 <_ZNK15Acpi_table_madt11parse_entryEN9Acpi_apic4TypeEPFvPKS0_E+0x21>
            (*handler)(ptr);
  200865:	89 d8                	mov    %ebx,%eax
  200867:	ff d5                	call   *%ebp
    }
}

void Acpi_table_madt::parse_entry (Acpi_apic::Type type, void (*handler)(Acpi_apic const *)) const
{
    for (Acpi_apic const *ptr = apic; ptr < reinterpret_cast<Acpi_apic *>(reinterpret_cast<mword>(this) + length); ptr = reinterpret_cast<Acpi_apic *>(reinterpret_cast<mword>(ptr) + ptr->length))
  200869:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  20086d:	01 c3                	add    %eax,%ebx
  20086f:	eb e4                	jmp    200855 <_ZNK15Acpi_table_madt11parse_entryEN9Acpi_apic4TypeEPFvPKS0_E+0xd>
        if (ptr->type == type)
            (*handler)(ptr);
}
  200871:	5b                   	pop    %ebx
  200872:	5e                   	pop    %esi
  200873:	5f                   	pop    %edi
  200874:	5d                   	pop    %ebp
  200875:	c3                   	ret    

00200876 <_ZNK15Acpi_table_madt5parseEv>:
#include "lapic.hpp"
#include "vectors.hpp"
#include "pd.hpp"

void Acpi_table_madt::parse() const
{
  200876:	53                   	push   %ebx
    parse_entry (Acpi_apic::LAPIC,  &parse_lapic);
  200877:	31 d2                	xor    %edx,%edx
#include "lapic.hpp"
#include "vectors.hpp"
#include "pd.hpp"

void Acpi_table_madt::parse() const
{
  200879:	89 c3                	mov    %eax,%ebx
    parse_entry (Acpi_apic::LAPIC,  &parse_lapic);
  20087b:	b9 46 07 20 00       	mov    $0x200746,%ecx
  200880:	e8 c3 ff ff ff       	call   200848 <_ZNK15Acpi_table_madt11parse_entryEN9Acpi_apic4TypeEPFvPKS0_E>
    parse_entry (Acpi_apic::IOAPIC, &parse_ioapic);
  200885:	b9 74 07 20 00       	mov    $0x200774,%ecx
  20088a:	ba 01 00 00 00       	mov    $0x1,%edx
  20088f:	89 d8                	mov    %ebx,%eax
  200891:	e8 b2 ff ff ff       	call   200848 <_ZNK15Acpi_table_madt11parse_entryEN9Acpi_apic4TypeEPFvPKS0_E>
    parse_entry (Acpi_apic::INTR,   &parse_intr);
  200896:	b9 a4 06 20 00       	mov    $0x2006a4,%ecx
  20089b:	ba 02 00 00 00       	mov    $0x2,%edx
  2008a0:	89 d8                	mov    %ebx,%eax
  2008a2:	e8 a1 ff ff ff       	call   200848 <_ZNK15Acpi_table_madt11parse_entryEN9Acpi_apic4TypeEPFvPKS0_E>

    if (flags & 1) {
  2008a7:	f6 43 28 01          	testb  $0x1,0x28(%ebx)
  2008ab:	74 14                	je     2008c1 <_ZNK15Acpi_table_madt5parseEv+0x4b>
  2008ad:	b0 11                	mov    $0x11,%al
  2008af:	e6 20                	out    %al,$0x20
  2008b1:	b0 20                	mov    $0x20,%al
  2008b3:	e6 21                	out    %al,$0x21
  2008b5:	b0 04                	mov    $0x4,%al
  2008b7:	e6 21                	out    %al,$0x21
  2008b9:	b0 01                	mov    $0x1,%al
  2008bb:	e6 21                	out    %al,$0x21
  2008bd:	b0 ff                	mov    $0xff,%al
  2008bf:	e6 21                	out    %al,$0x21
        Io::out<uint8>(0x21, VEC_GSI);
        Io::out<uint8>(0x21, 0x4);
        Io::out<uint8>(0x21, 0x1);
        Io::out<uint8>(0x21, 0xff);
    }
}
  2008c1:	5b                   	pop    %ebx
  2008c2:	c3                   	ret    
  2008c3:	90                   	nop

002008c4 <_ZNK15Acpi_table_mcfg5parseEv>:

#include "acpi_mcfg.hpp"
#include "pci.hpp"

void Acpi_table_mcfg::parse() const
{
  2008c4:	53                   	push   %ebx
    for (Acpi_mcfg const *x = mcfg; x + 1 <= reinterpret_cast<Acpi_mcfg *>(reinterpret_cast<mword>(this) + length); x++)
  2008c5:	8d 50 2c             	lea    0x2c(%eax),%edx
  2008c8:	03 40 04             	add    0x4(%eax),%eax
  2008cb:	83 c2 10             	add    $0x10,%edx
  2008ce:	39 c2                	cmp    %eax,%edx
  2008d0:	77 2c                	ja     2008fe <_ZNK15Acpi_table_mcfg5parseEv+0x3a>
        if (!x->seg) {
  2008d2:	66 83 7a f8 00       	cmpw   $0x0,-0x8(%edx)
  2008d7:	75 f2                	jne    2008cb <_ZNK15Acpi_table_mcfg5parseEv+0x7>
            Pci::bus_base = x->bus_s;
  2008d9:	0f b6 5a fa          	movzbl -0x6(%edx),%ebx
  2008dd:	89 1d c8 b0 01 c0    	mov    %ebx,0xc001b0c8
            Pci::cfg_base = static_cast<Paddr>(x->addr);
  2008e3:	8b 4a f0             	mov    -0x10(%edx),%ecx
  2008e6:	89 0d c4 b0 01 c0    	mov    %ecx,0xc001b0c4
            Pci::cfg_size = ((x->bus_e - x->bus_s + 1) << 8) * PAGE_SIZE;
  2008ec:	0f b6 4a fb          	movzbl -0x5(%edx),%ecx
  2008f0:	29 d9                	sub    %ebx,%ecx
  2008f2:	41                   	inc    %ecx
  2008f3:	c1 e1 14             	shl    $0x14,%ecx
  2008f6:	89 0d c0 b0 01 c0    	mov    %ecx,0xc001b0c0
  2008fc:	eb cd                	jmp    2008cb <_ZNK15Acpi_table_mcfg5parseEv+0x7>
        }

    Pci::init();
}
  2008fe:	5b                   	pop    %ebx
            Pci::bus_base = x->bus_s;
            Pci::cfg_base = static_cast<Paddr>(x->addr);
            Pci::cfg_size = ((x->bus_e - x->bus_s + 1) << 8) * PAGE_SIZE;
        }

    Pci::init();
  2008ff:	31 d2                	xor    %edx,%edx
  200901:	31 c0                	xor    %eax,%eax
  200903:	e9 dc 0d 00 00       	jmp    2016e4 <_ZN3Pci4initEjj>

00200908 <_ZN9Acpi_rsdp4findEmj>:
#include "acpi_rsdp.hpp"
#include "hpt.hpp"
#include "pd.hpp"

Acpi_rsdp *Acpi_rsdp::find (mword start, unsigned len)
{
  200908:	56                   	push   %esi
    for (mword addr = start; addr < start + len; addr += 16) {
  200909:	01 c2                	add    %eax,%edx
#include "acpi_rsdp.hpp"
#include "hpt.hpp"
#include "pd.hpp"

Acpi_rsdp *Acpi_rsdp::find (mword start, unsigned len)
{
  20090b:	53                   	push   %ebx
    for (mword addr = start; addr < start + len; addr += 16) {
  20090c:	39 d0                	cmp    %edx,%eax
  20090e:	73 2b                	jae    20093b <_ZN9Acpi_rsdp4findEmj+0x33>
        uint8   extended_checksum;

        ALWAYS_INLINE
        bool good_signature() const
        {
            return signature[0] == SIG ('R','S','D',' ') &&
  200910:	81 38 52 53 44 20    	cmpl   $0x20445352,(%eax)
  200916:	75 1e                	jne    200936 <_ZN9Acpi_rsdp4findEmj+0x2e>
  200918:	81 78 04 50 54 52 20 	cmpl   $0x20525450,0x4(%eax)
  20091f:	75 15                	jne    200936 <_ZN9Acpi_rsdp4findEmj+0x2e>
  200921:	89 c1                	mov    %eax,%ecx
  200923:	31 db                	xor    %ebx,%ebx
        ALWAYS_INLINE
        bool good_checksum (unsigned len = 20) const
        {
            uint8 check = 0;
            for (uint8 const *ptr = reinterpret_cast<uint8 const *>(this);
                              ptr < reinterpret_cast<uint8 const *>(this) + len;
  200925:	8d 70 14             	lea    0x14(%eax),%esi

        ALWAYS_INLINE
        bool good_checksum (unsigned len = 20) const
        {
            uint8 check = 0;
            for (uint8 const *ptr = reinterpret_cast<uint8 const *>(this);
  200928:	39 f1                	cmp    %esi,%ecx
  20092a:	73 06                	jae    200932 <_ZN9Acpi_rsdp4findEmj+0x2a>
  20092c:	41                   	inc    %ecx
  20092d:	02 59 ff             	add    -0x1(%ecx),%bl
  200930:	eb f6                	jmp    200928 <_ZN9Acpi_rsdp4findEmj+0x20>
        Acpi_rsdp *rsdp = reinterpret_cast<Acpi_rsdp *>(addr);
        if (rsdp->good_signature() && rsdp->good_checksum())
  200932:	84 db                	test   %bl,%bl
  200934:	74 07                	je     20093d <_ZN9Acpi_rsdp4findEmj+0x35>
#include "hpt.hpp"
#include "pd.hpp"

Acpi_rsdp *Acpi_rsdp::find (mword start, unsigned len)
{
    for (mword addr = start; addr < start + len; addr += 16) {
  200936:	83 c0 10             	add    $0x10,%eax
  200939:	eb d1                	jmp    20090c <_ZN9Acpi_rsdp4findEmj+0x4>
        Acpi_rsdp *rsdp = reinterpret_cast<Acpi_rsdp *>(addr);
        if (rsdp->good_signature() && rsdp->good_checksum())
            return rsdp;
    }

    return nullptr;
  20093b:	31 c0                	xor    %eax,%eax
}
  20093d:	5b                   	pop    %ebx
  20093e:	5e                   	pop    %esi
  20093f:	c3                   	ret    

00200940 <_ZN9Acpi_rsdp5parseEv>:

void Acpi_rsdp::parse()
{
  200940:	53                   	push   %ebx
    Acpi_rsdp *rsdp;

    mword map = reinterpret_cast<mword>(Hpt::remap (Pd::kern.quota, 0));
  200941:	31 d2                	xor    %edx,%edx
  200943:	b8 50 b4 01 c0       	mov    $0xc001b450,%eax
  200948:	e8 a1 52 e0 bf       	call   c0005bee <_ZN3Hpt5remapER5Quotam>

    if (!(rsdp = Acpi_rsdp::find (map + (*reinterpret_cast<uint16 *>(map + 0x40e) << 4), 0x400)) &&
  20094d:	ba 00 04 00 00       	mov    $0x400,%edx

void Acpi_rsdp::parse()
{
    Acpi_rsdp *rsdp;

    mword map = reinterpret_cast<mword>(Hpt::remap (Pd::kern.quota, 0));
  200952:	89 c3                	mov    %eax,%ebx

    if (!(rsdp = Acpi_rsdp::find (map + (*reinterpret_cast<uint16 *>(map + 0x40e) << 4), 0x400)) &&
  200954:	0f b7 80 0e 04 00 00 	movzwl 0x40e(%eax),%eax
  20095b:	c1 e0 04             	shl    $0x4,%eax
  20095e:	01 d8                	add    %ebx,%eax
  200960:	e8 a3 ff ff ff       	call   200908 <_ZN9Acpi_rsdp4findEmj>
  200965:	85 c0                	test   %eax,%eax
  200967:	89 c2                	mov    %eax,%edx
  200969:	75 16                	jne    200981 <_ZN9Acpi_rsdp5parseEv+0x41>
  20096b:	ba 00 00 02 00       	mov    $0x20000,%edx
        !(rsdp = Acpi_rsdp::find (map + 0xe0000, 0x20000)))
  200970:	8d 83 00 00 0e 00    	lea    0xe0000(%ebx),%eax
{
    Acpi_rsdp *rsdp;

    mword map = reinterpret_cast<mword>(Hpt::remap (Pd::kern.quota, 0));

    if (!(rsdp = Acpi_rsdp::find (map + (*reinterpret_cast<uint16 *>(map + 0x40e) << 4), 0x400)) &&
  200976:	e8 8d ff ff ff       	call   200908 <_ZN9Acpi_rsdp4findEmj>
  20097b:	85 c0                	test   %eax,%eax
  20097d:	89 c2                	mov    %eax,%edx
  20097f:	74 2d                	je     2009ae <_ZN9Acpi_rsdp5parseEv+0x6e>
        !(rsdp = Acpi_rsdp::find (map + 0xe0000, 0x20000)))
        return;

    Acpi::rsdt = rsdp->rsdt_addr;
  200981:	8b 42 10             	mov    0x10(%edx),%eax

    if (rsdp->revision > 1 && rsdp->good_checksum (rsdp->length))
  200984:	80 7a 0f 01          	cmpb   $0x1,0xf(%edx)

    if (!(rsdp = Acpi_rsdp::find (map + (*reinterpret_cast<uint16 *>(map + 0x40e) << 4), 0x400)) &&
        !(rsdp = Acpi_rsdp::find (map + 0xe0000, 0x20000)))
        return;

    Acpi::rsdt = rsdp->rsdt_addr;
  200988:	a3 38 a3 01 c0       	mov    %eax,0xc001a338

    if (rsdp->revision > 1 && rsdp->good_checksum (rsdp->length))
  20098d:	76 1f                	jbe    2009ae <_ZN9Acpi_rsdp5parseEv+0x6e>
                              ptr < reinterpret_cast<uint8 const *>(this) + len;
  20098f:	8b 5a 14             	mov    0x14(%edx),%ebx
  200992:	89 d0                	mov    %edx,%eax
        }

        ALWAYS_INLINE
        bool good_checksum (unsigned len = 20) const
        {
            uint8 check = 0;
  200994:	31 c9                	xor    %ecx,%ecx
            for (uint8 const *ptr = reinterpret_cast<uint8 const *>(this);
                              ptr < reinterpret_cast<uint8 const *>(this) + len;
  200996:	01 d3                	add    %edx,%ebx

        ALWAYS_INLINE
        bool good_checksum (unsigned len = 20) const
        {
            uint8 check = 0;
            for (uint8 const *ptr = reinterpret_cast<uint8 const *>(this);
  200998:	39 d8                	cmp    %ebx,%eax
  20099a:	73 06                	jae    2009a2 <_ZN9Acpi_rsdp5parseEv+0x62>
  20099c:	40                   	inc    %eax
  20099d:	02 48 ff             	add    -0x1(%eax),%cl
  2009a0:	eb f6                	jmp    200998 <_ZN9Acpi_rsdp5parseEv+0x58>
  2009a2:	84 c9                	test   %cl,%cl
  2009a4:	75 08                	jne    2009ae <_ZN9Acpi_rsdp5parseEv+0x6e>
        Acpi::xsdt = static_cast<Paddr>(rsdp->xsdt_addr);
  2009a6:	8b 42 18             	mov    0x18(%edx),%eax
  2009a9:	a3 34 a3 01 c0       	mov    %eax,0xc001a334
}
  2009ae:	5b                   	pop    %ebx
  2009af:	c3                   	ret    

002009b0 <_ZNK15Acpi_table_rsdt5parseEmj>:
    { SIG ('H','P','E','T'),    &Acpi::hpet },
    { SIG ('M','C','F','G'),    &Acpi::mcfg },
};

void Acpi_table_rsdt::parse (Paddr addr, size_t size) const
{
  2009b0:	55                   	push   %ebp
  2009b1:	89 e5                	mov    %esp,%ebp
  2009b3:	57                   	push   %edi
  2009b4:	56                   	push   %esi
  2009b5:	89 ce                	mov    %ecx,%esi
  2009b7:	53                   	push   %ebx
  2009b8:	89 c3                	mov    %eax,%ebx
  2009ba:	83 ec 0c             	sub    $0xc,%esp
  2009bd:	89 65 ec             	mov    %esp,-0x14(%ebp)
    if (!good_checksum (addr))
  2009c0:	e8 8b 00 00 00       	call   200a50 <_ZNK10Acpi_table13good_checksumEm>
  2009c5:	84 c0                	test   %al,%al
  2009c7:	74 7f                	je     200a48 <_ZNK15Acpi_table_rsdt5parseEmj+0x98>
            Paddr * const ptr;
        } map[];

        unsigned long entries (size_t size) const
        {
            return (length - sizeof (Acpi_table)) / size;
  2009c9:	8b 43 04             	mov    0x4(%ebx),%eax
  2009cc:	31 d2                	xor    %edx,%edx
  2009ce:	83 e8 24             	sub    $0x24,%eax
  2009d1:	f7 f6                	div    %esi
  2009d3:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return;

    unsigned long count = entries (size);

    Paddr table[count];
  2009d6:	8d 04 85 04 00 00 00 	lea    0x4(,%eax,4),%eax
  2009dd:	29 c4                	sub    %eax,%esp
    for (unsigned i = 0; i < count; i++)
  2009df:	31 c0                	xor    %eax,%eax
    if (!good_checksum (addr))
        return;

    unsigned long count = entries (size);

    Paddr table[count];
  2009e1:	89 e7                	mov    %esp,%edi
    for (unsigned i = 0; i < count; i++)
  2009e3:	3b 45 f0             	cmp    -0x10(%ebp),%eax
  2009e6:	74 15                	je     2009fd <_ZNK15Acpi_table_rsdt5parseEmj+0x4d>
        table[i] = static_cast<Paddr>(size == sizeof (*xsdt) ? xsdt[i] : rsdt[i]);
  2009e8:	83 fe 08             	cmp    $0x8,%esi
  2009eb:	75 06                	jne    2009f3 <_ZNK15Acpi_table_rsdt5parseEmj+0x43>
  2009ed:	8b 54 c3 24          	mov    0x24(%ebx,%eax,8),%edx
  2009f1:	eb 04                	jmp    2009f7 <_ZNK15Acpi_table_rsdt5parseEmj+0x47>
  2009f3:	8b 54 83 24          	mov    0x24(%ebx,%eax,4),%edx
  2009f7:	89 14 87             	mov    %edx,(%edi,%eax,4)
        return;

    unsigned long count = entries (size);

    Paddr table[count];
    for (unsigned i = 0; i < count; i++)
  2009fa:	40                   	inc    %eax
  2009fb:	eb e6                	jmp    2009e3 <_ZNK15Acpi_table_rsdt5parseEmj+0x33>
  2009fd:	31 db                	xor    %ebx,%ebx
        table[i] = static_cast<Paddr>(size == sizeof (*xsdt) ? xsdt[i] : rsdt[i]);

    for (unsigned i = 0; i < count; i++) {
  2009ff:	3b 5d f0             	cmp    -0x10(%ebp),%ebx
  200a02:	74 41                	je     200a45 <_ZNK15Acpi_table_rsdt5parseEmj+0x95>

        Acpi_table *acpi = static_cast<Acpi_table *>(Hpt::remap (Pd::kern.quota, table[i]));
  200a04:	8b 34 9f             	mov    (%edi,%ebx,4),%esi
  200a07:	b8 50 b4 01 c0       	mov    $0xc001b450,%eax
  200a0c:	89 f2                	mov    %esi,%edx
  200a0e:	e8 db 51 e0 bf       	call   c0005bee <_ZN3Hpt5remapER5Quotam>

        if (acpi->good_checksum (table[i]))
  200a13:	89 f2                	mov    %esi,%edx
    for (unsigned i = 0; i < count; i++)
        table[i] = static_cast<Paddr>(size == sizeof (*xsdt) ? xsdt[i] : rsdt[i]);

    for (unsigned i = 0; i < count; i++) {

        Acpi_table *acpi = static_cast<Acpi_table *>(Hpt::remap (Pd::kern.quota, table[i]));
  200a15:	89 c1                	mov    %eax,%ecx

        if (acpi->good_checksum (table[i]))
  200a17:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  200a1a:	e8 31 00 00 00       	call   200a50 <_ZNK10Acpi_table13good_checksumEm>
  200a1f:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  200a22:	84 c0                	test   %al,%al
  200a24:	74 1c                	je     200a42 <_ZNK15Acpi_table_rsdt5parseEmj+0x92>
  200a26:	31 c0                	xor    %eax,%eax
            for (unsigned j = 0; j < sizeof map / sizeof *map; j++)
                if (acpi->signature == map[j].sig)
  200a28:	8b 14 c5 80 1b 20 00 	mov    0x201b80(,%eax,8),%edx
  200a2f:	39 11                	cmp    %edx,(%ecx)
  200a31:	75 09                	jne    200a3c <_ZNK15Acpi_table_rsdt5parseEmj+0x8c>
                    *map[j].ptr = table[i];
  200a33:	8b 14 c5 84 1b 20 00 	mov    0x201b84(,%eax,8),%edx
  200a3a:	89 32                	mov    %esi,(%edx)
    for (unsigned i = 0; i < count; i++) {

        Acpi_table *acpi = static_cast<Acpi_table *>(Hpt::remap (Pd::kern.quota, table[i]));

        if (acpi->good_checksum (table[i]))
            for (unsigned j = 0; j < sizeof map / sizeof *map; j++)
  200a3c:	40                   	inc    %eax
  200a3d:	83 f8 05             	cmp    $0x5,%eax
  200a40:	75 e6                	jne    200a28 <_ZNK15Acpi_table_rsdt5parseEmj+0x78>

    Paddr table[count];
    for (unsigned i = 0; i < count; i++)
        table[i] = static_cast<Paddr>(size == sizeof (*xsdt) ? xsdt[i] : rsdt[i]);

    for (unsigned i = 0; i < count; i++) {
  200a42:	43                   	inc    %ebx
  200a43:	eb ba                	jmp    2009ff <_ZNK15Acpi_table_rsdt5parseEmj+0x4f>
  200a45:	8b 65 ec             	mov    -0x14(%ebp),%esp
        if (acpi->good_checksum (table[i]))
            for (unsigned j = 0; j < sizeof map / sizeof *map; j++)
                if (acpi->signature == map[j].sig)
                    *map[j].ptr = table[i];
    }
}
  200a48:	8d 65 f4             	lea    -0xc(%ebp),%esp
  200a4b:	5b                   	pop    %ebx
  200a4c:	5e                   	pop    %esi
  200a4d:	5f                   	pop    %edi
  200a4e:	5d                   	pop    %ebp
  200a4f:	c3                   	ret    

00200a50 <_ZNK10Acpi_table13good_checksumEm>:
bool Acpi_table::good_checksum (Paddr addr) const
{
    uint8 check = 0;

    for (uint8 const *ptr = reinterpret_cast<uint8 const *>(this);
                      ptr < reinterpret_cast<uint8 const *>(this) + length;
  200a50:	8b 48 04             	mov    0x4(%eax),%ecx
#include "acpi_table.hpp"
#include "stdio.hpp"

bool Acpi_table::good_checksum (Paddr addr) const
{
    uint8 check = 0;
  200a53:	31 d2                	xor    %edx,%edx

    for (uint8 const *ptr = reinterpret_cast<uint8 const *>(this);
                      ptr < reinterpret_cast<uint8 const *>(this) + length;
  200a55:	01 c1                	add    %eax,%ecx

bool Acpi_table::good_checksum (Paddr addr) const
{
    uint8 check = 0;

    for (uint8 const *ptr = reinterpret_cast<uint8 const *>(this);
  200a57:	39 c8                	cmp    %ecx,%eax
  200a59:	73 06                	jae    200a61 <_ZNK10Acpi_table13good_checksumEm+0x11>
  200a5b:	40                   	inc    %eax
  200a5c:	02 50 ff             	add    -0x1(%eax),%dl
  200a5f:	eb f6                	jmp    200a57 <_ZNK10Acpi_table13good_checksumEm+0x7>
           oem_id,
           length,
           check ? "bad" : "ok",
           static_cast<unsigned int>(checksum));

    return !check;
  200a61:	84 d2                	test   %dl,%dl
  200a63:	0f 94 c0             	sete   %al
}
  200a66:	c3                   	ret    
  200a67:	90                   	nop

00200a68 <_ZN5BuddyC1Emmmj>:
                        reinterpret_cast<mword>(&_mempool_l),
                        reinterpret_cast<mword>(&_mempool_f),
                        reinterpret_cast<mword>(&_mempool_e) -
                        reinterpret_cast<mword>(&_mempool_l));

Buddy::Buddy (mword phys, mword virt, mword f_addr, size_t size)
  200a68:	55                   	push   %ebp
  200a69:	57                   	push   %edi
  200a6a:	89 cf                	mov    %ecx,%edi
  200a6c:	56                   	push   %esi

ALWAYS_INLINE
inline long int bit_scan_reverse (mword val)
{
    if (EXPECT_FALSE (!val))
        return -1;
  200a6d:	83 c9 ff             	or     $0xffffffff,%ecx
  200a70:	53                   	push   %ebx
  200a71:	89 c6                	mov    %eax,%esi
  200a73:	8b 5c 24 18          	mov    0x18(%esp),%ebx
    private:
        uint16 val;

    public:
        ALWAYS_INLINE
        inline Spinlock() : val (0) {}
  200a77:	66 c7 00 00 00       	movw   $0x0,(%eax)
#include "util.hpp"

ALWAYS_INLINE
inline long int bit_scan_reverse (mword val)
{
    if (EXPECT_FALSE (!val))
  200a7c:	85 db                	test   %ebx,%ebx
  200a7e:	74 03                	je     200a83 <_ZN5BuddyC1Emmmj+0x1b>
        return -1;

    asm volatile ("bsr %1, %0" : "=r" (val) : "rm" (val));

    return val;
  200a80:	0f bd cb             	bsr    %ebx,%ecx
{
    // Compute maximum aligned block size
    unsigned long bit = bit_scan_reverse (size);

    // Compute maximum aligned physical block address (base)
    base = phys_to_virt (align_up (phys, 1ul << bit));
  200a83:	b8 01 00 00 00       	mov    $0x1,%eax
  200a88:	d3 e0                	shl    %cl,%eax

    // Convert block size to page order
    order = bit + 1 - PAGE_BITS;
  200a8a:	83 e9 0b             	sub    $0xb,%ecx
  200a8d:	89 4e 10             	mov    %ecx,0x10(%esi)
           phys,
           phys + size,
           order);

    // Allocate block-list heads
    size -= order * sizeof *head;
  200a90:	6b c9 0c             	imul   $0xc,%ecx,%ecx
}

ALWAYS_INLINE
static inline mword align_dn (mword val, mword align)
{
    val &= ~(align - 1);                // Expect power-of-2
  200a93:	89 c5                	mov    %eax,%ebp
  200a95:	f7 dd                	neg    %ebp
}

ALWAYS_INLINE
static inline mword align_up (mword val, mword align)
{
    val += (align - 1);                 // Expect power-of-2
  200a97:	8d 44 10 ff          	lea    -0x1(%eax,%edx,1),%eax
    head = reinterpret_cast<Block *>(virt + size);

    // Allocate block-index storage
    size -= size / (PAGE_SIZE + sizeof *index) * sizeof *index;
  200a9b:	31 d2                	xor    %edx,%edx
}

ALWAYS_INLINE
static inline mword align_dn (mword val, mword align)
{
    val &= ~(align - 1);                // Expect power-of-2
  200a9d:	21 c5                	and    %eax,%ebp
           phys,
           phys + size,
           order);

    // Allocate block-list heads
    size -= order * sizeof *head;
  200a9f:	29 cb                	sub    %ecx,%ebx
    head = reinterpret_cast<Block *>(virt + size);

    // Allocate block-index storage
    size -= size / (PAGE_SIZE + sizeof *index) * sizeof *index;
  200aa1:	b9 0c 10 00 00       	mov    $0x100c,%ecx
           phys + size,
           order);

    // Allocate block-list heads
    size -= order * sizeof *head;
    head = reinterpret_cast<Block *>(virt + size);
  200aa6:	8d 04 3b             	lea    (%ebx,%edi,1),%eax
        }

        ALWAYS_INLINE
        inline mword phys_to_virt (mword phys)
        {
            return phys + reinterpret_cast<mword>(&OFFSET);
  200aa9:	81 c5 00 00 c0 bf    	add    $0xbfc00000,%ebp
  200aaf:	89 46 18             	mov    %eax,0x18(%esi)

    // Allocate block-index storage
    size -= size / (PAGE_SIZE + sizeof *index) * sizeof *index;
  200ab2:	89 d8                	mov    %ebx,%eax
  200ab4:	f7 f1                	div    %ecx
{
    // Compute maximum aligned block size
    unsigned long bit = bit_scan_reverse (size);

    // Compute maximum aligned physical block address (base)
    base = phys_to_virt (align_up (phys, 1ul << bit));
  200ab6:	89 6e 0c             	mov    %ebp,0xc(%esi)
        }

        ALWAYS_INLINE
        inline signed long page_to_index (mword l_addr)
        {
            return l_addr / PAGE_SIZE - base / PAGE_SIZE;
  200ab9:	c1 ed 0c             	shr    $0xc,%ebp
    // Allocate block-list heads
    size -= order * sizeof *head;
    head = reinterpret_cast<Block *>(virt + size);

    // Allocate block-index storage
    size -= size / (PAGE_SIZE + sizeof *index) * sizeof *index;
  200abc:	6b c0 0c             	imul   $0xc,%eax,%eax
  200abf:	29 c3                	sub    %eax,%ebx
  200ac1:	89 f8                	mov    %edi,%eax
  200ac3:	c1 e8 0c             	shr    $0xc,%eax
    size &= ~PAGE_MASK;
  200ac6:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
  200acc:	29 e8                	sub    %ebp,%eax
    min_idx = page_to_index (virt);
    max_idx = page_to_index (virt + size);
  200ace:	01 df                	add    %ebx,%edi
    head = reinterpret_cast<Block *>(virt + size);

    // Allocate block-index storage
    size -= size / (PAGE_SIZE + sizeof *index) * sizeof *index;
    size &= ~PAGE_MASK;
    min_idx = page_to_index (virt);
  200ad0:	89 46 08             	mov    %eax,0x8(%esi)
    max_idx = page_to_index (virt + size);
    index = reinterpret_cast<Block *>(virt + size) - min_idx;
  200ad3:	6b c0 0c             	imul   $0xc,%eax,%eax
  200ad6:	89 fa                	mov    %edi,%edx
  200ad8:	c1 ea 0c             	shr    $0xc,%edx
  200adb:	89 fb                	mov    %edi,%ebx
  200add:	29 ea                	sub    %ebp,%edx
  200adf:	89 56 04             	mov    %edx,0x4(%esi)

    for (unsigned i = 0; i < order; i++)
  200ae2:	31 d2                	xor    %edx,%edx
    // Allocate block-index storage
    size -= size / (PAGE_SIZE + sizeof *index) * sizeof *index;
    size &= ~PAGE_MASK;
    min_idx = page_to_index (virt);
    max_idx = page_to_index (virt + size);
    index = reinterpret_cast<Block *>(virt + size) - min_idx;
  200ae4:	29 c3                	sub    %eax,%ebx
  200ae6:	89 5e 14             	mov    %ebx,0x14(%esi)

    for (unsigned i = 0; i < order; i++)
  200ae9:	3b 56 10             	cmp    0x10(%esi),%edx
  200aec:	73 0e                	jae    200afc <_ZN5BuddyC1Emmmj+0x94>
        head[i].next = head[i].prev = head + i;
  200aee:	6b c2 0c             	imul   $0xc,%edx,%eax
    size &= ~PAGE_MASK;
    min_idx = page_to_index (virt);
    max_idx = page_to_index (virt + size);
    index = reinterpret_cast<Block *>(virt + size) - min_idx;

    for (unsigned i = 0; i < order; i++)
  200af1:	42                   	inc    %edx
        head[i].next = head[i].prev = head + i;
  200af2:	03 46 18             	add    0x18(%esi),%eax
  200af5:	89 00                	mov    %eax,(%eax)
  200af7:	89 40 04             	mov    %eax,0x4(%eax)
  200afa:	eb ed                	jmp    200ae9 <_ZN5BuddyC1Emmmj+0x81>

    for (mword i = f_addr; i < virt + size; i += PAGE_SIZE)
  200afc:	39 7c 24 14          	cmp    %edi,0x14(%esp)
  200b00:	73 1a                	jae    200b1c <_ZN5BuddyC1Emmmj+0xb4>
        free (i, Quota::init);
  200b02:	8b 54 24 14          	mov    0x14(%esp),%edx
  200b06:	b9 70 a3 01 c0       	mov    $0xc001a370,%ecx
  200b0b:	89 f0                	mov    %esi,%eax
  200b0d:	e8 56 06 e0 bf       	call   c0001168 <_ZN5Buddy4freeEmR5Quota>
    index = reinterpret_cast<Block *>(virt + size) - min_idx;

    for (unsigned i = 0; i < order; i++)
        head[i].next = head[i].prev = head + i;

    for (mword i = f_addr; i < virt + size; i += PAGE_SIZE)
  200b12:	81 44 24 14 00 10 00 	addl   $0x1000,0x14(%esp)
  200b19:	00 
  200b1a:	eb e0                	jmp    200afc <_ZN5BuddyC1Emmmj+0x94>
        free (i, Quota::init);
}
  200b1c:	5b                   	pop    %ebx
  200b1d:	5e                   	pop    %esi
  200b1e:	5f                   	pop    %edi
  200b1f:	5d                   	pop    %ebp
  200b20:	c3                   	ret    
  200b21:	90                   	nop

00200b22 <_ZN7Cmdline7get_argEPPc>:
    { "novga",      &Cmdline::novga     },
    { "novpid",     &Cmdline::novpid    },
};

char *Cmdline::get_arg (char **line)
{
  200b22:	53                   	push   %ebx
  200b23:	89 c3                	mov    %eax,%ebx
    for (; **line == ' '; ++*line) ;
  200b25:	8b 13                	mov    (%ebx),%edx
  200b27:	8a 0a                	mov    (%edx),%cl
  200b29:	80 f9 20             	cmp    $0x20,%cl
  200b2c:	75 05                	jne    200b33 <_ZN7Cmdline7get_argEPPc+0x11>
  200b2e:	42                   	inc    %edx
  200b2f:	89 13                	mov    %edx,(%ebx)
  200b31:	eb f2                	jmp    200b25 <_ZN7Cmdline7get_argEPPc+0x3>

    if (!**line)
        return nullptr;
  200b33:	31 c0                	xor    %eax,%eax

char *Cmdline::get_arg (char **line)
{
    for (; **line == ' '; ++*line) ;

    if (!**line)
  200b35:	84 c9                	test   %cl,%cl
  200b37:	74 1b                	je     200b54 <_ZN7Cmdline7get_argEPPc+0x32>
        return nullptr;

    char *arg = *line;

    for (; **line != ' '; ++*line)
  200b39:	8b 0b                	mov    (%ebx),%ecx
  200b3b:	8a 01                	mov    (%ecx),%al
  200b3d:	3c 20                	cmp    $0x20,%al
  200b3f:	74 09                	je     200b4a <_ZN7Cmdline7get_argEPPc+0x28>
        if (!**line)
  200b41:	84 c0                	test   %al,%al
  200b43:	74 0d                	je     200b52 <_ZN7Cmdline7get_argEPPc+0x30>
    if (!**line)
        return nullptr;

    char *arg = *line;

    for (; **line != ' '; ++*line)
  200b45:	41                   	inc    %ecx
  200b46:	89 0b                	mov    %ecx,(%ebx)
  200b48:	eb ef                	jmp    200b39 <_ZN7Cmdline7get_argEPPc+0x17>
        if (!**line)
            return arg;

    *(*line)++ = 0;
  200b4a:	8d 41 01             	lea    0x1(%ecx),%eax
  200b4d:	89 03                	mov    %eax,(%ebx)
  200b4f:	c6 01 00             	movb   $0x0,(%ecx)
    { "novpid",     &Cmdline::novpid    },
};

char *Cmdline::get_arg (char **line)
{
    for (; **line == ' '; ++*line) ;
  200b52:	89 d0                	mov    %edx,%eax
            return arg;

    *(*line)++ = 0;

    return arg;
}
  200b54:	5b                   	pop    %ebx
  200b55:	c3                   	ret    

00200b56 <_ZN7Cmdline4initEm>:

void Cmdline::init (mword addr)
{
  200b56:	56                   	push   %esi
  200b57:	53                   	push   %ebx
  200b58:	52                   	push   %edx
    char *arg, *line = static_cast<char *>(Hpt::remap (Pd::kern.quota, addr));
  200b59:	89 c2                	mov    %eax,%edx
  200b5b:	b8 50 b4 01 c0       	mov    $0xc001b450,%eax
  200b60:	e8 89 50 e0 bf       	call   c0005bee <_ZN3Hpt5remapER5Quotam>
  200b65:	89 04 24             	mov    %eax,(%esp)

    while ((arg = get_arg (&line)))
  200b68:	89 e0                	mov    %esp,%eax
  200b6a:	e8 b3 ff ff ff       	call   200b22 <_ZN7Cmdline7get_argEPPc>
  200b6f:	85 c0                	test   %eax,%eax
  200b71:	74 2f                	je     200ba2 <_ZN7Cmdline4initEm+0x4c>
  200b73:	31 d2                	xor    %edx,%edx
        for (unsigned i = 0; i < sizeof map / sizeof *map; i++)
            if (!strcmp (map[i].arg, arg))
  200b75:	8b 34 d5 c0 1b 20 00 	mov    0x201bc0(,%edx,8),%esi
  200b7c:	89 c1                	mov    %eax,%ecx
}

extern "C" NONNULL
inline int strcmp (char const *s1, char const *s2)
{
    while (*s1 && *s1 == *s2)
  200b7e:	8a 1e                	mov    (%esi),%bl
  200b80:	84 db                	test   %bl,%bl
  200b82:	74 08                	je     200b8c <_ZN7Cmdline4initEm+0x36>
  200b84:	3a 19                	cmp    (%ecx),%bl
  200b86:	75 04                	jne    200b8c <_ZN7Cmdline4initEm+0x36>
        s1++, s2++;
  200b88:	46                   	inc    %esi
  200b89:	41                   	inc    %ecx
  200b8a:	eb f2                	jmp    200b7e <_ZN7Cmdline4initEm+0x28>
  200b8c:	3a 19                	cmp    (%ecx),%bl
  200b8e:	75 0a                	jne    200b9a <_ZN7Cmdline4initEm+0x44>
                *map[i].ptr = true;
  200b90:	8b 0c d5 c4 1b 20 00 	mov    0x201bc4(,%edx,8),%ecx
  200b97:	c6 01 01             	movb   $0x1,(%ecx)
void Cmdline::init (mword addr)
{
    char *arg, *line = static_cast<char *>(Hpt::remap (Pd::kern.quota, addr));

    while ((arg = get_arg (&line)))
        for (unsigned i = 0; i < sizeof map / sizeof *map; i++)
  200b9a:	42                   	inc    %edx
  200b9b:	83 fa 09             	cmp    $0x9,%edx
  200b9e:	75 d5                	jne    200b75 <_ZN7Cmdline4initEm+0x1f>
  200ba0:	eb c6                	jmp    200b68 <_ZN7Cmdline4initEm+0x12>
            if (!strcmp (map[i].arg, arg))
                *map[i].ptr = true;
}
  200ba2:	58                   	pop    %eax
  200ba3:	5b                   	pop    %ebx
  200ba4:	5e                   	pop    %esi
  200ba5:	c3                   	ret    

00200ba6 <_ZN14Console_serialC1Ev>:
#include "x86.hpp"
#include "pd.hpp"

INIT_PRIORITY (PRIO_CONSOLE) Console_serial Console_serial::con;

Console_serial::Console_serial()
  200ba6:	c7 00 10 66 01 c0    	movl   $0xc0016610,(%eax)
{
    if (!Cmdline::serial)
  200bac:	80 3d 8a a3 01 c0 00 	cmpb   $0x0,0xc001a38a
  200bb3:	74 6d                	je     200c22 <_ZN14Console_serialC1Ev+0x7c>
#include "x86.hpp"
#include "pd.hpp"

INIT_PRIORITY (PRIO_CONSOLE) Console_serial Console_serial::con;

Console_serial::Console_serial()
  200bb5:	55                   	push   %ebp
{
    if (!Cmdline::serial)
        return;

    char *mem = static_cast<char *>(Hpt::remap (Pd::kern.quota, 0));
  200bb6:	31 d2                	xor    %edx,%edx
#include "x86.hpp"
#include "pd.hpp"

INIT_PRIORITY (PRIO_CONSOLE) Console_serial Console_serial::con;

Console_serial::Console_serial()
  200bb8:	57                   	push   %edi
  200bb9:	56                   	push   %esi
  200bba:	53                   	push   %ebx
  200bbb:	89 c3                	mov    %eax,%ebx
{
    if (!Cmdline::serial)
        return;

    char *mem = static_cast<char *>(Hpt::remap (Pd::kern.quota, 0));
  200bbd:	b8 50 b4 01 c0       	mov    $0xc001b450,%eax
  200bc2:	e8 27 50 e0 bf       	call   c0005bee <_ZN3Hpt5remapER5Quotam>
    if (!(base = *reinterpret_cast<uint16 *>(mem + 0x400)) &&
  200bc7:	0f b7 90 00 04 00 00 	movzwl 0x400(%eax),%edx
  200bce:	85 d2                	test   %edx,%edx
  200bd0:	89 53 08             	mov    %edx,0x8(%ebx)
  200bd3:	75 0e                	jne    200be3 <_ZN14Console_serialC1Ev+0x3d>
        !(base = *reinterpret_cast<uint16 *>(mem + 0x402)))
  200bd5:	0f b7 80 02 04 00 00 	movzwl 0x402(%eax),%eax
{
    if (!Cmdline::serial)
        return;

    char *mem = static_cast<char *>(Hpt::remap (Pd::kern.quota, 0));
    if (!(base = *reinterpret_cast<uint16 *>(mem + 0x400)) &&
  200bdc:	85 c0                	test   %eax,%eax
  200bde:	89 43 08             	mov    %eax,0x8(%ebx)
  200be1:	74 3b                	je     200c1e <_ZN14Console_serialC1Ev+0x78>
  200be3:	8b 73 08             	mov    0x8(%ebx),%esi
  200be6:	b0 80                	mov    $0x80,%al

        ALWAYS_INLINE
        inline unsigned in (Register r) { return Io::in<uint8>(base + r); }

        ALWAYS_INLINE
        inline void out (Register r, unsigned v) { Io::out (base + r, static_cast<uint8>(v)); }
  200be8:	8d 6e 03             	lea    0x3(%esi),%ebp
  200beb:	89 ea                	mov    %ebp,%edx
  200bed:	ee                   	out    %al,(%dx)
  200bee:	b0 01                	mov    $0x1,%al
  200bf0:	89 f2                	mov    %esi,%edx
  200bf2:	ee                   	out    %al,(%dx)
  200bf3:	31 c9                	xor    %ecx,%ecx
  200bf5:	8d 7e 01             	lea    0x1(%esi),%edi
  200bf8:	88 c8                	mov    %cl,%al
  200bfa:	89 fa                	mov    %edi,%edx
  200bfc:	ee                   	out    %al,(%dx)
  200bfd:	b0 03                	mov    $0x3,%al
  200bff:	89 ea                	mov    %ebp,%edx
  200c01:	ee                   	out    %al,(%dx)
  200c02:	88 c8                	mov    %cl,%al
  200c04:	89 fa                	mov    %edi,%edx
  200c06:	ee                   	out    %al,(%dx)
  200c07:	b0 07                	mov    $0x7,%al
  200c09:	8d 56 02             	lea    0x2(%esi),%edx
  200c0c:	ee                   	out    %al,(%dx)
  200c0d:	b0 03                	mov    $0x3,%al
  200c0f:	8d 56 04             	lea    0x4(%esi),%edx
  200c12:	ee                   	out    %al,(%dx)
    out (LCR, 3);
    out (IER, 0);
    out (FCR, 7);
    out (MCR, 3);

    enable();
  200c13:	89 d8                	mov    %ebx,%eax
}
  200c15:	5b                   	pop    %ebx
  200c16:	5e                   	pop    %esi
  200c17:	5f                   	pop    %edi
  200c18:	5d                   	pop    %ebp
    out (LCR, 3);
    out (IER, 0);
    out (FCR, 7);
    out (MCR, 3);

    enable();
  200c19:	e9 90 0e e0 bf       	jmp    c0001aae <_ZN7Console6enableEv>
}
  200c1e:	5b                   	pop    %ebx
  200c1f:	5e                   	pop    %esi
  200c20:	5f                   	pop    %edi
  200c21:	5d                   	pop    %ebp
  200c22:	c3                   	ret    
  200c23:	90                   	nop

00200c24 <_ZN11Console_vgaC1Ev>:
#include "console_vga.hpp"
#include "pd.hpp"

INIT_PRIORITY (PRIO_CONSOLE) Console_vga Console_vga::con;

Console_vga::Console_vga() : num (25), row (0), col (0)
  200c24:	c7 00 30 66 01 c0    	movl   $0xc0016630,(%eax)
{
    if (Cmdline::novga)
  200c2a:	80 3d 85 a3 01 c0 00 	cmpb   $0x0,0xc001a385
#include "console_vga.hpp"
#include "pd.hpp"

INIT_PRIORITY (PRIO_CONSOLE) Console_vga Console_vga::con;

Console_vga::Console_vga() : num (25), row (0), col (0)
  200c31:	c7 40 08 19 00 00 00 	movl   $0x19,0x8(%eax)
  200c38:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  200c3f:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
{
    if (Cmdline::novga)
  200c46:	75 50                	jne    200c98 <_ZN11Console_vgaC1Ev+0x74>
#include "console_vga.hpp"
#include "pd.hpp"

INIT_PRIORITY (PRIO_CONSOLE) Console_vga Console_vga::con;

Console_vga::Console_vga() : num (25), row (0), col (0)
  200c48:	56                   	push   %esi
        }

        ALWAYS_INLINE
        inline void insert (Quota &quota, mword virt, unsigned o, mword attr, Paddr phys)
        {
            hpt.update (quota, virt, o, phys, attr);
  200c49:	b9 00 f0 bf cf       	mov    $0xcfbff000,%ecx
  200c4e:	53                   	push   %ebx
  200c4f:	ba 50 b4 01 c0       	mov    $0xc001b450,%edx
  200c54:	6a 00                	push   $0x0
  200c56:	89 c3                	mov    %eax,%ebx
  200c58:	68 13 01 00 00       	push   $0x113
  200c5d:	be d4 03 00 00       	mov    $0x3d4,%esi
  200c62:	68 00 90 0b 00       	push   $0xb9000
  200c67:	b8 14 b4 01 c0       	mov    $0xc001b414,%eax
  200c6c:	6a 00                	push   $0x0
  200c6e:	e8 4d d4 e0 bf       	call   c000e0c0 <_ZN3PteI3HptmLj2ELj10ELb0EE6updateER5QuotammmmNS1_4TypeE>
  200c73:	b0 0c                	mov    $0xc,%al
  200c75:	89 f2                	mov    %esi,%edx
  200c77:	ee                   	out    %al,(%dx)
  200c78:	b9 d5 03 00 00       	mov    $0x3d5,%ecx
  200c7d:	b0 08                	mov    $0x8,%al
  200c7f:	89 ca                	mov    %ecx,%edx
  200c81:	ee                   	out    %al,(%dx)
  200c82:	b0 0d                	mov    $0xd,%al
  200c84:	89 f2                	mov    %esi,%edx
  200c86:	ee                   	out    %al,(%dx)
  200c87:	31 c0                	xor    %eax,%eax
  200c89:	89 ca                	mov    %ecx,%edx
  200c8b:	ee                   	out    %al,(%dx)

    Pd::kern.Space_mem::insert (Pd::kern.quota, HV_GLOBAL_FBUF, 0, Hpt::HPT_NX | Hpt::HPT_G | Hpt::HPT_UC | Hpt::HPT_W | Hpt::HPT_P, 0xb9000);

    set_page (1);

    enable();
  200c8c:	83 c4 10             	add    $0x10,%esp
  200c8f:	89 d8                	mov    %ebx,%eax
}
  200c91:	5b                   	pop    %ebx
  200c92:	5e                   	pop    %esi

    Pd::kern.Space_mem::insert (Pd::kern.quota, HV_GLOBAL_FBUF, 0, Hpt::HPT_NX | Hpt::HPT_G | Hpt::HPT_UC | Hpt::HPT_W | Hpt::HPT_P, 0xb9000);

    set_page (1);

    enable();
  200c93:	e9 16 0e e0 bf       	jmp    c0001aae <_ZN7Console6enableEv>
  200c98:	c3                   	ret    
  200c99:	90                   	nop

00200c9a <_ZN11Console_vga5setupEv>:
}

void Console_vga::setup()
{
    if (Cmdline::novga || !Cmdline::spinner)
  200c9a:	80 3d 85 a3 01 c0 00 	cmpb   $0x0,0xc001a385
  200ca1:	0f 85 92 00 00 00    	jne    200d39 <_ZN11Console_vga5setupEv+0x9f>

    enable();
}

void Console_vga::setup()
{
  200ca7:	55                   	push   %ebp
  200ca8:	31 ed                	xor    %ebp,%ebp
    if (Cmdline::novga || !Cmdline::spinner)
  200caa:	80 3d 89 a3 01 c0 00 	cmpb   $0x0,0xc001a389

    enable();
}

void Console_vga::setup()
{
  200cb1:	57                   	push   %edi
  200cb2:	56                   	push   %esi
  200cb3:	53                   	push   %ebx
  200cb4:	89 c3                	mov    %eax,%ebx
    if (Cmdline::novga || !Cmdline::spinner)
  200cb6:	74 7d                	je     200d35 <_ZN11Console_vga5setupEv+0x9b>
        return;

    for (unsigned c = 0; c < min (Cpu::online, 12U); c++) {
  200cb8:	a1 40 a4 01 c0       	mov    0xc001a440,%eax

template <typename T>
ALWAYS_INLINE
static inline T min (T v1, T v2)
{
    return v1 < v2 ? v1 : v2;
  200cbd:	be 0c 00 00 00       	mov    $0xc,%esi
  200cc2:	83 f8 0c             	cmp    $0xc,%eax
  200cc5:	0f 43 c6             	cmovae %esi,%eax
  200cc8:	39 c5                	cmp    %eax,%ebp
  200cca:	73 69                	jae    200d35 <_ZN11Console_vga5setupEv+0x9b>

        if (row == --num)
  200ccc:	8b 43 08             	mov    0x8(%ebx),%eax
  200ccf:	8b 53 0c             	mov    0xc(%ebx),%edx
  200cd2:	8d 48 ff             	lea    -0x1(%eax),%ecx
  200cd5:	39 ca                	cmp    %ecx,%edx
  200cd7:	89 4b 08             	mov    %ecx,0x8(%ebx)
  200cda:	75 29                	jne    200d05 <_ZN11Console_vga5setupEv+0x6b>
        }

        ALWAYS_INLINE
        inline void clear_row (unsigned r)
        {
            memcpy (reinterpret_cast<void *>(HV_GLOBAL_FBUF), reinterpret_cast<void *>(HV_GLOBAL_FBUF + 160), 160 * r);
  200cdc:	69 d2 a0 00 00 00    	imul   $0xa0,%edx,%edx
            clear_row (row--);
  200ce2:	83 e8 02             	sub    $0x2,%eax
  200ce5:	89 43 0c             	mov    %eax,0xc(%ebx)
{
    mword dummy;
    asm volatile ("rep; movsb"
                  : "=D" (dummy), "+S" (s), "+c" (n)
                  : "0" (d)
                  : "memory");
  200ce8:	bf 00 f0 bf cf       	mov    $0xcfbff000,%edi
  200ced:	be a0 f0 bf cf       	mov    $0xcfbff0a0,%esi
  200cf2:	89 d1                	mov    %edx,%ecx
  200cf4:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
{
    mword dummy;
    asm volatile ("rep; stosb"
                  : "=D" (dummy), "+c" (n)
                  : "0" (d), "a" (c)
                  : "memory");
  200cf6:	b9 a0 00 00 00       	mov    $0xa0,%ecx
  200cfb:	31 c0                	xor    %eax,%eax
            memset (reinterpret_cast<void *>(HV_GLOBAL_FBUF + 160 * r), 0, 160);
  200cfd:	8d ba 00 f0 bf cf    	lea    -0x30401000(%edx),%edi
  200d03:	f3 aa                	rep stos %al,%es:(%edi)

    enable();
}

void Console_vga::setup()
{
  200d05:	b8 10 00 00 00       	mov    $0x10,%eax
        inline unsigned spinner (unsigned id) { return id < 25 - num ? 24 - id : 0; }

        ALWAYS_INLINE
        inline void put (unsigned long r, unsigned long c, Color color, int x)
        {
            *reinterpret_cast<unsigned short volatile *>(HV_GLOBAL_FBUF + r * 160 + c * 2) = static_cast<unsigned short>(color << 8 | x);
  200d0a:	6b 53 08 50          	imul   $0x50,0x8(%ebx),%edx
  200d0e:	8d 8c 10 00 f8 df 67 	lea    0x67dff800(%eax,%edx,1),%ecx

        if (row == --num)
            clear_row (row--);

        for (unsigned i = SPN_GSI; i < 80; i++)
            put (num, i, COLOR_LIGHT_BLACK, ((i - SPN_GSI) & 0xf)["0123456789ABCDEF"]);
  200d15:	89 c2                	mov    %eax,%edx
  200d17:	83 e2 0f             	and    $0xf,%edx
    for (unsigned c = 0; c < min (Cpu::online, 12U); c++) {

        if (row == --num)
            clear_row (row--);

        for (unsigned i = SPN_GSI; i < 80; i++)
  200d1a:	40                   	inc    %eax
  200d1b:	66 0f be 92 14 66 01 	movsbw -0x3ffe99ec(%edx),%dx
  200d22:	c0 
  200d23:	80 ce 08             	or     $0x8,%dh
  200d26:	83 f8 50             	cmp    $0x50,%eax
  200d29:	0f b7 d2             	movzwl %dx,%edx
  200d2c:	66 89 14 09          	mov    %dx,(%ecx,%ecx,1)
  200d30:	75 d8                	jne    200d0a <_ZN11Console_vga5setupEv+0x70>
void Console_vga::setup()
{
    if (Cmdline::novga || !Cmdline::spinner)
        return;

    for (unsigned c = 0; c < min (Cpu::online, 12U); c++) {
  200d32:	45                   	inc    %ebp
  200d33:	eb 83                	jmp    200cb8 <_ZN11Console_vga5setupEv+0x1e>
            clear_row (row--);

        for (unsigned i = SPN_GSI; i < 80; i++)
            put (num, i, COLOR_LIGHT_BLACK, ((i - SPN_GSI) & 0xf)["0123456789ABCDEF"]);
    }
}
  200d35:	5b                   	pop    %ebx
  200d36:	5e                   	pop    %esi
  200d37:	5f                   	pop    %edi
  200d38:	5d                   	pop    %ebp
  200d39:	c3                   	ret    

00200d3a <_ZN4DmarC1Em>:
Dmar *      Dmar::list;
Dmar_ctx *  Dmar::ctx = new (Pd::kern.quota) Dmar_ctx;
Dmar_irt *  Dmar::irt = new (Pd::kern.quota) Dmar_irt;
uint32      Dmar::gcmd = GCMD_TE;

Dmar::Dmar (Paddr p) : List<Dmar> (list), reg_base ((hwdev_addr -= PAGE_SIZE) | (p & PAGE_MASK)), invq (static_cast<Dmar_qi *>(Buddy::allocator.alloc (ord, Pd::kern.quota, Buddy::FILL_0))), invq_idx (0)
  200d3a:	57                   	push   %edi
  200d3b:	56                   	push   %esi
  200d3c:	89 d6                	mov    %edx,%esi
  200d3e:	53                   	push   %ebx
  200d3f:	89 c3                	mov    %eax,%ebx
  200d41:	ba 50 a4 01 c0       	mov    $0xc001a450,%edx
    protected:
        T *next;

    public:
        ALWAYS_INLINE
        explicit inline List (T *&list) : next (nullptr)
  200d46:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        {
            T **ptr; for (ptr = &list; *ptr; ptr = &(*ptr)->next) ; *ptr = static_cast<T *>(this);
  200d4c:	a1 50 a4 01 c0       	mov    0xc001a450,%eax
  200d51:	85 c0                	test   %eax,%eax
  200d53:	74 06                	je     200d5b <_ZN4DmarC1Em+0x21>
  200d55:	89 c2                	mov    %eax,%edx
  200d57:	8b 00                	mov    (%eax),%eax
  200d59:	eb f6                	jmp    200d51 <_ZN4DmarC1Em+0x17>
  200d5b:	89 1a                	mov    %ebx,(%edx)
  200d5d:	89 f2                	mov    %esi,%edx
  200d5f:	b9 50 b4 01 c0       	mov    $0xc001b450,%ecx
  200d64:	a1 58 a2 01 c0       	mov    0xc001a258,%eax
  200d69:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
{
    Pd::kern.Space_mem::delreg (Pd::kern.quota, p & ~PAGE_MASK);
  200d6f:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
Dmar *      Dmar::list;
Dmar_ctx *  Dmar::ctx = new (Pd::kern.quota) Dmar_ctx;
Dmar_irt *  Dmar::irt = new (Pd::kern.quota) Dmar_irt;
uint32      Dmar::gcmd = GCMD_TE;

Dmar::Dmar (Paddr p) : List<Dmar> (list), reg_base ((hwdev_addr -= PAGE_SIZE) | (p & PAGE_MASK)), invq (static_cast<Dmar_qi *>(Buddy::allocator.alloc (ord, Pd::kern.quota, Buddy::FILL_0))), invq_idx (0)
  200d75:	6a 01                	push   $0x1
  200d77:	2d 00 10 00 00       	sub    $0x1000,%eax
  200d7c:	a3 58 a2 01 c0       	mov    %eax,0xc001a258
  200d81:	09 d0                	or     %edx,%eax
  200d83:	31 d2                	xor    %edx,%edx
  200d85:	89 43 04             	mov    %eax,0x4(%ebx)
  200d88:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
  200d8d:	e8 7a 06 e0 bf       	call   c000140c <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
{
    Pd::kern.Space_mem::delreg (Pd::kern.quota, p & ~PAGE_MASK);
  200d92:	89 f1                	mov    %esi,%ecx
  200d94:	ba 50 b4 01 c0       	mov    $0xc001b450,%edx
Dmar *      Dmar::list;
Dmar_ctx *  Dmar::ctx = new (Pd::kern.quota) Dmar_ctx;
Dmar_irt *  Dmar::irt = new (Pd::kern.quota) Dmar_irt;
uint32      Dmar::gcmd = GCMD_TE;

Dmar::Dmar (Paddr p) : List<Dmar> (list), reg_base ((hwdev_addr -= PAGE_SIZE) | (p & PAGE_MASK)), invq (static_cast<Dmar_qi *>(Buddy::allocator.alloc (ord, Pd::kern.quota, Buddy::FILL_0))), invq_idx (0)
  200d99:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
  200da0:	89 43 18             	mov    %eax,0x18(%ebx)
{
    Pd::kern.Space_mem::delreg (Pd::kern.quota, p & ~PAGE_MASK);
  200da3:	b8 0c b3 01 c0       	mov    $0xc001b30c,%eax
  200da8:	e8 53 16 e0 bf       	call   c0002400 <_ZN5Space6delregER5Quotam>
  200dad:	8b 4b 04             	mov    0x4(%ebx),%ecx
  200db0:	ba 50 b4 01 c0       	mov    $0xc001b450,%edx
  200db5:	6a 00                	push   $0x0
  200db7:	b8 14 b4 01 c0       	mov    $0xc001b414,%eax
  200dbc:	68 13 01 00 00       	push   $0x113
  200dc1:	56                   	push   %esi
  200dc2:	6a 00                	push   $0x0
  200dc4:	e8 f7 d2 e0 bf       	call   c000e0c0 <_ZN3PteI3HptmLj2ELj10ELb0EE6updateER5QuotammmmNS1_4TypeE>
  200dc9:	8b 4b 04             	mov    0x4(%ebx),%ecx
#include "util.hpp"

ALWAYS_INLINE
inline long int bit_scan_reverse (mword val)
{
    if (EXPECT_FALSE (!val))
  200dcc:	83 c4 14             	add    $0x14,%esp

        template <typename T>
        ALWAYS_INLINE
        inline T read (Reg reg)
        {
            return *reinterpret_cast<T volatile *>(reg_base + reg);
  200dcf:	8b 41 08             	mov    0x8(%ecx),%eax
  200dd2:	8b 51 0c             	mov    0xc(%ecx),%edx
    Pd::kern.Space_mem::insert (Pd::kern.quota, reg_base, 0, Hpt::HPT_NX | Hpt::HPT_G | Hpt::HPT_UC | Hpt::HPT_W | Hpt::HPT_P, p & ~PAGE_MASK);

    cap  = read<uint64>(REG_CAP);
  200dd5:	89 43 08             	mov    %eax,0x8(%ebx)
        return -1;
  200dd8:	83 c8 ff             	or     $0xffffffff,%eax
  200ddb:	89 53 0c             	mov    %edx,0xc(%ebx)
    ecap = read<uint64>(REG_ECAP);

    Dpt::ord = min (Dpt::ord, static_cast<mword>(bit_scan_reverse (static_cast<mword>(cap >> 34) & 0xf) + 2) * Dpt::bpl() - 1);
  200dde:	c1 ea 02             	shr    $0x2,%edx
  200de1:	8b 71 10             	mov    0x10(%ecx),%esi
#include "util.hpp"

ALWAYS_INLINE
inline long int bit_scan_reverse (mword val)
{
    if (EXPECT_FALSE (!val))
  200de4:	83 e2 0f             	and    $0xf,%edx
  200de7:	8b 79 14             	mov    0x14(%ecx),%edi
{
    Pd::kern.Space_mem::delreg (Pd::kern.quota, p & ~PAGE_MASK);
    Pd::kern.Space_mem::insert (Pd::kern.quota, reg_base, 0, Hpt::HPT_NX | Hpt::HPT_G | Hpt::HPT_UC | Hpt::HPT_W | Hpt::HPT_P, p & ~PAGE_MASK);

    cap  = read<uint64>(REG_CAP);
    ecap = read<uint64>(REG_ECAP);
  200dea:	89 73 10             	mov    %esi,0x10(%ebx)
  200ded:	89 7b 14             	mov    %edi,0x14(%ebx)
  200df0:	74 03                	je     200df5 <_ZN4DmarC1Em+0xbb>
        return -1;

    asm volatile ("bsr %1, %0" : "=r" (val) : "rm" (val));

    return val;
  200df2:	0f bd c2             	bsr    %edx,%eax
  200df5:	8b 15 64 a2 01 c0    	mov    0xc001a264,%edx

    Dpt::ord = min (Dpt::ord, static_cast<mword>(bit_scan_reverse (static_cast<mword>(cap >> 34) & 0xf) + 2) * Dpt::bpl() - 1);
  200dfb:	83 c0 02             	add    $0x2,%eax
  200dfe:	8d 04 c0             	lea    (%eax,%eax,8),%eax
  200e01:	48                   	dec    %eax
  200e02:	39 d0                	cmp    %edx,%eax
  200e04:	0f 47 c2             	cmova  %edx,%eax

    write<uint32>(REG_FEADDR, 0xfee00000 | Cpu::apic_id[0] << 12);
    write<uint32>(REG_FEDATA, VEC_MSI_DMAR);
    write<uint32>(REG_FECTL,  0);

    write<uint64>(REG_RTADDR, Buddy::ptr_to_phys (ctx));
  200e07:	31 d2                	xor    %edx,%edx
    Pd::kern.Space_mem::insert (Pd::kern.quota, reg_base, 0, Hpt::HPT_NX | Hpt::HPT_G | Hpt::HPT_UC | Hpt::HPT_W | Hpt::HPT_P, p & ~PAGE_MASK);

    cap  = read<uint64>(REG_CAP);
    ecap = read<uint64>(REG_ECAP);

    Dpt::ord = min (Dpt::ord, static_cast<mword>(bit_scan_reverse (static_cast<mword>(cap >> 34) & 0xf) + 2) * Dpt::bpl() - 1);
  200e09:	a3 64 a2 01 c0       	mov    %eax,0xc001a264

    write<uint32>(REG_FEADDR, 0xfee00000 | Cpu::apic_id[0] << 12);
  200e0e:	0f b6 05 c0 a3 01 c0 	movzbl 0xc001a3c0,%eax
  200e15:	c1 e0 0c             	shl    $0xc,%eax
  200e18:	0d 00 00 e0 fe       	or     $0xfee00000,%eax

        template <typename T>
        ALWAYS_INLINE
        inline void write (Reg reg, T val)
        {
            *reinterpret_cast<T volatile *>(reg_base + reg) = val;
  200e1d:	89 41 40             	mov    %eax,0x40(%ecx)
  200e20:	8b 43 04             	mov    0x4(%ebx),%eax
  200e23:	c7 40 3c a6 00 00 00 	movl   $0xa6,0x3c(%eax)
  200e2a:	8b 43 04             	mov    0x4(%ebx),%eax
  200e2d:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
        }

        ALWAYS_INLINE
        inline mword virt_to_phys (mword virt)
        {
            return virt - reinterpret_cast<mword>(&OFFSET);
  200e34:	a1 4c a4 01 c0       	mov    0xc001a44c,%eax
  200e39:	8b 4b 04             	mov    0x4(%ebx),%ecx
  200e3c:	2d 00 00 c0 bf       	sub    $0xbfc00000,%eax
  200e41:	89 41 20             	mov    %eax,0x20(%ecx)
  200e44:	89 51 24             	mov    %edx,0x24(%ecx)
  200e47:	8b 43 04             	mov    0x4(%ebx),%eax
  200e4a:	c7 40 18 00 00 00 40 	movl   $0x40000000,0x18(%eax)
  200e51:	8b 4b 04             	mov    0x4(%ebx),%ecx

        template <typename T>
        ALWAYS_INLINE
        inline T read (Reg reg)
        {
            return *reinterpret_cast<T volatile *>(reg_base + reg);
  200e54:	8b 41 1c             	mov    0x1c(%ecx),%eax

        ALWAYS_INLINE
        inline void command (uint32 val)
        {
            write<uint32>(REG_GCMD, val);
            while ((read<uint32>(REG_GSTS) & val) != val)
  200e57:	a9 00 00 00 40       	test   $0x40000000,%eax
  200e5c:	75 04                	jne    200e62 <_ZN4DmarC1Em+0x128>
  200e5e:	f3 90                	pause  
  200e60:	eb ef                	jmp    200e51 <_ZN4DmarC1Em+0x117>
    write<uint32>(REG_FECTL,  0);

    write<uint64>(REG_RTADDR, Buddy::ptr_to_phys (ctx));
    command (GCMD_SRTP);

    if (ir()) {
  200e62:	f6 43 10 08          	testb  $0x8,0x10(%ebx)
  200e66:	74 40                	je     200ea8 <_ZN4DmarC1Em+0x16e>
  200e68:	a1 48 a4 01 c0       	mov    0xc001a448,%eax
        write<uint64>(REG_IRTA, Buddy::ptr_to_phys (irt) | 7);
  200e6d:	31 d2                	xor    %edx,%edx
  200e6f:	2d 00 00 c0 bf       	sub    $0xbfc00000,%eax
  200e74:	83 c8 07             	or     $0x7,%eax

        template <typename T>
        ALWAYS_INLINE
        inline void write (Reg reg, T val)
        {
            *reinterpret_cast<T volatile *>(reg_base + reg) = val;
  200e77:	89 81 b8 00 00 00    	mov    %eax,0xb8(%ecx)
  200e7d:	89 91 bc 00 00 00    	mov    %edx,0xbc(%ecx)
  200e83:	8b 43 04             	mov    0x4(%ebx),%eax
  200e86:	c7 40 18 00 00 00 01 	movl   $0x1000000,0x18(%eax)

        template <typename T>
        ALWAYS_INLINE
        inline T read (Reg reg)
        {
            return *reinterpret_cast<T volatile *>(reg_base + reg);
  200e8d:	8b 43 04             	mov    0x4(%ebx),%eax
  200e90:	8b 40 1c             	mov    0x1c(%eax),%eax

        ALWAYS_INLINE
        inline void command (uint32 val)
        {
            write<uint32>(REG_GCMD, val);
            while ((read<uint32>(REG_GSTS) & val) != val)
  200e93:	a9 00 00 00 01       	test   $0x1000000,%eax
  200e98:	75 04                	jne    200e9e <_ZN4DmarC1Em+0x164>
  200e9a:	f3 90                	pause  
  200e9c:	eb ef                	jmp    200e8d <_ZN4DmarC1Em+0x153>
        command (GCMD_SIRTP);
        gcmd |= GCMD_IRE;
  200e9e:	81 0d a8 9f 01 c0 00 	orl    $0x2000000,0xc0019fa8
  200ea5:	00 00 02 
    }

    if (qi()) {
  200ea8:	f6 43 10 02          	testb  $0x2,0x10(%ebx)
  200eac:	74 55                	je     200f03 <_ZN4DmarC1Em+0x1c9>

        template <typename T>
        ALWAYS_INLINE
        inline void write (Reg reg, T val)
        {
            *reinterpret_cast<T volatile *>(reg_base + reg) = val;
  200eae:	8b 43 04             	mov    0x4(%ebx),%eax
        write<uint64>(REG_IQT, 0);
        write<uint64>(REG_IQA, Buddy::ptr_to_phys (invq));
  200eb1:	31 d2                	xor    %edx,%edx
  200eb3:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
  200eba:	00 00 00 
  200ebd:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
  200ec4:	00 00 00 
  200ec7:	8b 43 18             	mov    0x18(%ebx),%eax
  200eca:	8b 4b 04             	mov    0x4(%ebx),%ecx
  200ecd:	2d 00 00 c0 bf       	sub    $0xbfc00000,%eax
  200ed2:	89 81 90 00 00 00    	mov    %eax,0x90(%ecx)
  200ed8:	89 91 94 00 00 00    	mov    %edx,0x94(%ecx)
  200ede:	8b 43 04             	mov    0x4(%ebx),%eax
  200ee1:	c7 40 18 00 00 00 04 	movl   $0x4000000,0x18(%eax)

        template <typename T>
        ALWAYS_INLINE
        inline T read (Reg reg)
        {
            return *reinterpret_cast<T volatile *>(reg_base + reg);
  200ee8:	8b 43 04             	mov    0x4(%ebx),%eax
  200eeb:	8b 40 1c             	mov    0x1c(%eax),%eax

        ALWAYS_INLINE
        inline void command (uint32 val)
        {
            write<uint32>(REG_GCMD, val);
            while ((read<uint32>(REG_GSTS) & val) != val)
  200eee:	a9 00 00 00 04       	test   $0x4000000,%eax
  200ef3:	75 04                	jne    200ef9 <_ZN4DmarC1Em+0x1bf>
  200ef5:	f3 90                	pause  
  200ef7:	eb ef                	jmp    200ee8 <_ZN4DmarC1Em+0x1ae>
        command (GCMD_QIE);
        gcmd |= GCMD_QIE;
  200ef9:	81 0d a8 9f 01 c0 00 	orl    $0x4000000,0xc0019fa8
  200f00:	00 00 04 
    }
}
  200f03:	5b                   	pop    %ebx
  200f04:	5e                   	pop    %esi
  200f05:	5f                   	pop    %edi
  200f06:	c3                   	ret    
  200f07:	90                   	nop

00200f08 <_ZN3Gsi5setupEv>:

Gsi         Gsi::gsi_table[NUM_GSI];
unsigned    Gsi::irq_table[NUM_IRQ];

void Gsi::setup()
{
  200f08:	55                   	push   %ebp
  200f09:	57                   	push   %edi
  200f0a:	bf e0 a4 01 c0       	mov    $0xc001a4e0,%edi
  200f0f:	56                   	push   %esi
    for (unsigned gsi = 0; gsi < NUM_GSI; gsi++) {
  200f10:	31 f6                	xor    %esi,%esi

Gsi         Gsi::gsi_table[NUM_GSI];
unsigned    Gsi::irq_table[NUM_IRQ];

void Gsi::setup()
{
  200f12:	53                   	push   %ebx
  200f13:	b3 20                	mov    $0x20,%bl

            call_rcu(true);
        }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
  200f15:	ba 50 b4 01 c0       	mov    $0xc001b450,%edx
  200f1a:	b8 b4 b4 01 c0       	mov    $0xc001b4b4,%eax
  200f1f:	e8 52 f3 e0 bf       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
    for (unsigned gsi = 0; gsi < NUM_GSI; gsi++) {

        Space_obj::insert_root (Pd::kern.quota, Gsi::gsi_table[gsi].sm = new (Pd::kern.quota) Sm (&Pd::kern, NUM_CPU + gsi));
  200f24:	8d 4e 40             	lea    0x40(%esi),%ecx
  200f27:	ba c0 b2 01 c0       	mov    $0xc001b2c0,%edx
  200f2c:	6a 00                	push   $0x0
  200f2e:	6a 00                	push   $0x0
  200f30:	6a 00                	push   $0x0
  200f32:	89 c5                	mov    %eax,%ebp
  200f34:	e8 e1 f7 e0 bf       	call   c001071a <_ZN2SmC1EP2PdmmPS_m>
  200f39:	89 ea                	mov    %ebp,%edx
  200f3b:	b8 50 b4 01 c0       	mov    $0xc001b450,%eax
  200f40:	89 2f                	mov    %ebp,(%edi)
  200f42:	e8 75 01 e1 bf       	call   c00110bc <_ZN9Space_obj11insert_rootER5QuotaP7Kobject>

        gsi_table[gsi].vec = static_cast<uint8>(VEC_GSI + gsi);

        if (gsi < NUM_IRQ) {
  200f47:	83 c4 0c             	add    $0xc,%esp
  200f4a:	83 fe 0f             	cmp    $0xf,%esi
{
    for (unsigned gsi = 0; gsi < NUM_GSI; gsi++) {

        Space_obj::insert_root (Pd::kern.quota, Gsi::gsi_table[gsi].sm = new (Pd::kern.quota) Sm (&Pd::kern, NUM_CPU + gsi));

        gsi_table[gsi].vec = static_cast<uint8>(VEC_GSI + gsi);
  200f4d:	88 5f 08             	mov    %bl,0x8(%edi)

        if (gsi < NUM_IRQ) {
  200f50:	77 13                	ja     200f65 <_ZN3Gsi5setupEv+0x5d>
            irq_table[gsi] = gsi;
            gsi_table[gsi].trg = 0;
  200f52:	6b c6 0c             	imul   $0xc,%esi,%eax
        Space_obj::insert_root (Pd::kern.quota, Gsi::gsi_table[gsi].sm = new (Pd::kern.quota) Sm (&Pd::kern, NUM_CPU + gsi));

        gsi_table[gsi].vec = static_cast<uint8>(VEC_GSI + gsi);

        if (gsi < NUM_IRQ) {
            irq_table[gsi] = gsi;
  200f55:	89 34 b5 a0 a4 01 c0 	mov    %esi,-0x3ffe5b60(,%esi,4)
            gsi_table[gsi].trg = 0;
            gsi_table[gsi].pol = 0;
  200f5c:	80 a0 e9 a4 01 c0 5f 	andb   $0x5f,-0x3ffe5b17(%eax)
  200f63:	eb 0a                	jmp    200f6f <_ZN3Gsi5setupEv+0x67>
        } else {
            gsi_table[gsi].trg = 1;
  200f65:	6b c6 0c             	imul   $0xc,%esi,%eax
            gsi_table[gsi].pol = 1;
  200f68:	80 88 e9 a4 01 c0 a0 	orb    $0xa0,-0x3ffe5b17(%eax)
Gsi         Gsi::gsi_table[NUM_GSI];
unsigned    Gsi::irq_table[NUM_IRQ];

void Gsi::setup()
{
    for (unsigned gsi = 0; gsi < NUM_GSI; gsi++) {
  200f6f:	46                   	inc    %esi
  200f70:	83 c7 0c             	add    $0xc,%edi
  200f73:	fe c3                	inc    %bl
  200f75:	81 fe 80 00 00 00    	cmp    $0x80,%esi
  200f7b:	75 98                	jne    200f15 <_ZN3Gsi5setupEv+0xd>
        } else {
            gsi_table[gsi].trg = 1;
            gsi_table[gsi].pol = 1;
        }
    }
}
  200f7d:	5b                   	pop    %ebx
  200f7e:	5e                   	pop    %esi
  200f7f:	5f                   	pop    %edi
  200f80:	5d                   	pop    %ebp
  200f81:	c3                   	ret    

00200f82 <_ZN3Hip7add_memERP7Hip_memmj>:

    h->length = static_cast<uint16>(reinterpret_cast<mword>(mem) - reinterpret_cast<mword>(h));
}

void Hip::add_mem (Hip_mem *&mem, mword addr, size_t len)
{
  200f82:	57                   	push   %edi
  200f83:	56                   	push   %esi
  200f84:	89 ce                	mov    %ecx,%esi
  200f86:	53                   	push   %ebx
  200f87:	89 c3                	mov    %eax,%ebx
    char *mmap_addr = static_cast<char *>(Hpt::remap (Pd::kern.quota, addr));
  200f89:	b8 50 b4 01 c0       	mov    $0xc001b450,%eax
  200f8e:	e8 5b 4c e0 bf       	call   c0005bee <_ZN3Hpt5remapER5Quotam>

    for (char *ptr = mmap_addr; ptr < mmap_addr + len; mem++) {
  200f93:	8d 0c 30             	lea    (%eax,%esi,1),%ecx
  200f96:	39 c8                	cmp    %ecx,%eax
  200f98:	73 37                	jae    200fd1 <_ZN3Hip7add_memERP7Hip_memmj+0x4f>

        Multiboot_mmap *map = reinterpret_cast<Multiboot_mmap *>(ptr);

        mem->addr = map->addr;
  200f9a:	8b 70 04             	mov    0x4(%eax),%esi
  200f9d:	8b 78 08             	mov    0x8(%eax),%edi
  200fa0:	8b 13                	mov    (%ebx),%edx
  200fa2:	89 32                	mov    %esi,(%edx)
  200fa4:	89 7a 04             	mov    %edi,0x4(%edx)
        mem->size = map->len;
  200fa7:	8b 78 10             	mov    0x10(%eax),%edi
  200faa:	8b 13                	mov    (%ebx),%edx
  200fac:	8b 70 0c             	mov    0xc(%eax),%esi
  200faf:	89 7a 0c             	mov    %edi,0xc(%edx)
  200fb2:	89 72 08             	mov    %esi,0x8(%edx)
        mem->type = map->type;
  200fb5:	8b 13                	mov    (%ebx),%edx
  200fb7:	8b 78 14             	mov    0x14(%eax),%edi
  200fba:	89 7a 10             	mov    %edi,0x10(%edx)
        mem->aux  = 0;
  200fbd:	8b 13                	mov    (%ebx),%edx
  200fbf:	c7 42 14 00 00 00 00 	movl   $0x0,0x14(%edx)

        ptr += map->size + 4;
  200fc6:	8b 10                	mov    (%eax),%edx

void Hip::add_mem (Hip_mem *&mem, mword addr, size_t len)
{
    char *mmap_addr = static_cast<char *>(Hpt::remap (Pd::kern.quota, addr));

    for (char *ptr = mmap_addr; ptr < mmap_addr + len; mem++) {
  200fc8:	83 03 18             	addl   $0x18,(%ebx)
        mem->addr = map->addr;
        mem->size = map->len;
        mem->type = map->type;
        mem->aux  = 0;

        ptr += map->size + 4;
  200fcb:	8d 44 10 04          	lea    0x4(%eax,%edx,1),%eax
  200fcf:	eb c5                	jmp    200f96 <_ZN3Hip7add_memERP7Hip_memmj+0x14>
    }
}
  200fd1:	5b                   	pop    %ebx
  200fd2:	5e                   	pop    %esi
  200fd3:	5f                   	pop    %edi
  200fd4:	c3                   	ret    
  200fd5:	90                   	nop

00200fd6 <_ZN3Hip7add_modERP7Hip_memmj>:

void Hip::add_mod (Hip_mem *&mem, mword addr, size_t count)
{
  200fd6:	57                   	push   %edi
  200fd7:	89 cf                	mov    %ecx,%edi
  200fd9:	56                   	push   %esi
  200fda:	53                   	push   %ebx
  200fdb:	89 c3                	mov    %eax,%ebx
    Multiboot_module *mod = static_cast<Multiboot_module *>(Hpt::remap (Pd::kern.quota, addr));
  200fdd:	b8 50 b4 01 c0       	mov    $0xc001b450,%eax
  200fe2:	e8 07 4c e0 bf       	call   c0005bee <_ZN3Hpt5remapER5Quotam>

    if (count) {
  200fe7:	85 ff                	test   %edi,%edi
  200fe9:	74 13                	je     200ffe <_ZN3Hip7add_modERP7Hip_memmj+0x28>
        root_addr = mod->s_addr;
  200feb:	8b 10                	mov    (%eax),%edx
  200fed:	89 15 e4 aa 01 c0    	mov    %edx,0xc001aae4
        root_size = mod->e_addr - mod->s_addr;
  200ff3:	8b 50 04             	mov    0x4(%eax),%edx
  200ff6:	2b 10                	sub    (%eax),%edx
  200ff8:	89 15 e0 aa 01 c0    	mov    %edx,0xc001aae0
        ptr += map->size + 4;
    }
}

void Hip::add_mod (Hip_mem *&mem, mword addr, size_t count)
{
  200ffe:	31 d2                	xor    %edx,%edx
    if (count) {
        root_addr = mod->s_addr;
        root_size = mod->e_addr - mod->s_addr;
    }

    for (unsigned i = 0; i < count; i++, mod++, mem++) {
  201000:	39 fa                	cmp    %edi,%edx
  201002:	74 39                	je     20103d <_ZN3Hip7add_modERP7Hip_memmj+0x67>
        mem->addr = mod->s_addr;
  201004:	8b 30                	mov    (%eax),%esi
    if (count) {
        root_addr = mod->s_addr;
        root_size = mod->e_addr - mod->s_addr;
    }

    for (unsigned i = 0; i < count; i++, mod++, mem++) {
  201006:	42                   	inc    %edx
  201007:	83 c0 10             	add    $0x10,%eax
        mem->addr = mod->s_addr;
  20100a:	8b 0b                	mov    (%ebx),%ecx
  20100c:	89 31                	mov    %esi,(%ecx)
  20100e:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
        mem->size = mod->e_addr - mod->s_addr;
  201015:	8b 70 f4             	mov    -0xc(%eax),%esi
  201018:	8b 0b                	mov    (%ebx),%ecx
  20101a:	2b 70 f0             	sub    -0x10(%eax),%esi
  20101d:	c7 41 0c 00 00 00 00 	movl   $0x0,0xc(%ecx)
  201024:	89 71 08             	mov    %esi,0x8(%ecx)
        mem->type = Hip_mem::MB_MODULE;
  201027:	8b 0b                	mov    (%ebx),%ecx
  201029:	c7 41 10 fe ff ff ff 	movl   $0xfffffffe,0x10(%ecx)
        mem->aux  = mod->cmdline;
  201030:	8b 70 f8             	mov    -0x8(%eax),%esi
  201033:	8b 0b                	mov    (%ebx),%ecx
  201035:	89 71 14             	mov    %esi,0x14(%ecx)
    if (count) {
        root_addr = mod->s_addr;
        root_size = mod->e_addr - mod->s_addr;
    }

    for (unsigned i = 0; i < count; i++, mod++, mem++) {
  201038:	83 03 18             	addl   $0x18,(%ebx)
  20103b:	eb c3                	jmp    201000 <_ZN3Hip7add_modERP7Hip_memmj+0x2a>
        mem->addr = mod->s_addr;
        mem->size = mod->e_addr - mod->s_addr;
        mem->type = Hip_mem::MB_MODULE;
        mem->aux  = mod->cmdline;
    }
}
  20103d:	5b                   	pop    %ebx
  20103e:	5e                   	pop    %esi
  20103f:	5f                   	pop    %edi
  201040:	c3                   	ret    
  201041:	90                   	nop

00201042 <_ZN3Hip7add_mhvERP7Hip_mem>:

void Hip::add_mhv (Hip_mem *&mem)
{
    mem->addr = reinterpret_cast<mword>(&LINK_P);
  201042:	8b 10                	mov    (%eax),%edx
  201044:	b9 00 00 40 00       	mov    $0x400000,%ecx
        mem->aux  = mod->cmdline;
    }
}

void Hip::add_mhv (Hip_mem *&mem)
{
  201049:	53                   	push   %ebx
    mem->addr = reinterpret_cast<mword>(&LINK_P);
    mem->size = reinterpret_cast<mword>(&LINK_E) - mem->addr;
  20104a:	31 db                	xor    %ebx,%ebx
    }
}

void Hip::add_mhv (Hip_mem *&mem)
{
    mem->addr = reinterpret_cast<mword>(&LINK_P);
  20104c:	89 0a                	mov    %ecx,(%edx)
    mem->size = reinterpret_cast<mword>(&LINK_E) - mem->addr;
  20104e:	b9 00 00 80 02       	mov    $0x2800000,%ecx
    }
}

void Hip::add_mhv (Hip_mem *&mem)
{
    mem->addr = reinterpret_cast<mword>(&LINK_P);
  201053:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
    mem->size = reinterpret_cast<mword>(&LINK_E) - mem->addr;
  20105a:	8b 10                	mov    (%eax),%edx
  20105c:	2b 0a                	sub    (%edx),%ecx
  20105e:	1b 5a 04             	sbb    0x4(%edx),%ebx
  201061:	89 4a 08             	mov    %ecx,0x8(%edx)
  201064:	89 5a 0c             	mov    %ebx,0xc(%edx)
    mem->type = Hip_mem::HYPERVISOR;
  201067:	8b 10                	mov    (%eax),%edx
  201069:	c7 42 10 ff ff ff ff 	movl   $0xffffffff,0x10(%edx)
    mem++;
  201070:	83 00 18             	addl   $0x18,(%eax)
}
  201073:	5b                   	pop    %ebx
  201074:	c3                   	ret    
  201075:	90                   	nop

00201076 <_ZN3Hip5buildEm>:

mword Hip::root_addr;
mword Hip::root_size;

void Hip::build (mword addr)
{
  201076:	55                   	push   %ebp
    h->sel_exc    = NUM_EXC;
    h->sel_vmi    = NUM_VMI;
    h->cfg_page   = PAGE_SIZE;
    h->cfg_utcb   = PAGE_SIZE;

    Multiboot *mbi = static_cast<Multiboot *>(Hpt::remap (Pd::kern.quota, addr));
  201077:	89 c2                	mov    %eax,%edx

mword Hip::root_addr;
mword Hip::root_size;

void Hip::build (mword addr)
{
  201079:	57                   	push   %edi
    h->sel_exc    = NUM_EXC;
    h->sel_vmi    = NUM_VMI;
    h->cfg_page   = PAGE_SIZE;
    h->cfg_utcb   = PAGE_SIZE;

    Multiboot *mbi = static_cast<Multiboot *>(Hpt::remap (Pd::kern.quota, addr));
  20107a:	b8 50 b4 01 c0       	mov    $0xc001b450,%eax

mword Hip::root_addr;
mword Hip::root_size;

void Hip::build (mword addr)
{
  20107f:	56                   	push   %esi
  201080:	53                   	push   %ebx
  201081:	83 ec 08             	sub    $0x8,%esp
    Hip *h = hip();

    h->signature  = 0x41564f4e;
  201084:	c7 05 00 e0 01 c0 4e 	movl   $0x41564f4e,0xc001e000
  20108b:	4f 56 41 
    h->cpu_offs   = reinterpret_cast<mword>(h->cpu_desc) - reinterpret_cast<mword>(h);
  20108e:	66 c7 05 08 e0 01 c0 	movw   $0x38,0xc001e008
  201095:	38 00 
    h->cpu_size   = static_cast<uint16>(sizeof (Hip_cpu));
  201097:	66 c7 05 0a e0 01 c0 	movw   $0x8,0xc001e00a
  20109e:	08 00 
    h->mem_offs   = reinterpret_cast<mword>(h->mem_desc) - reinterpret_cast<mword>(h);
  2010a0:	66 c7 05 0c e0 01 c0 	movw   $0x238,0xc001e00c
  2010a7:	38 02 
    h->mem_size   = static_cast<uint16>(sizeof (Hip_mem));
  2010a9:	66 c7 05 0e e0 01 c0 	movw   $0x18,0xc001e00e
  2010b0:	18 00 
    h->api_flg    = FEAT_VMX | FEAT_SVM;
  2010b2:	c7 05 10 e0 01 c0 06 	movl   $0x6,0xc001e010
  2010b9:	00 00 00 
    h->api_ver    = CFG_VER;
  2010bc:	c7 05 14 e0 01 c0 07 	movl   $0x7,0xc001e014
  2010c3:	00 00 00 
    h->sel_num    = Space_obj::caps;
  2010c6:	c7 05 18 e0 01 c0 00 	movl   $0x8000000,0xc001e018
  2010cd:	00 00 08 
    h->sel_gsi    = NUM_GSI;
  2010d0:	c7 05 24 e0 01 c0 80 	movl   $0x80,0xc001e024
  2010d7:	00 00 00 
    h->sel_exc    = NUM_EXC;
  2010da:	c7 05 1c e0 01 c0 20 	movl   $0x20,0xc001e01c
  2010e1:	00 00 00 
    h->sel_vmi    = NUM_VMI;
  2010e4:	c7 05 20 e0 01 c0 00 	movl   $0x100,0xc001e020
  2010eb:	01 00 00 
    h->cfg_page   = PAGE_SIZE;
  2010ee:	c7 05 28 e0 01 c0 00 	movl   $0x1000,0xc001e028
  2010f5:	10 00 00 
    h->cfg_utcb   = PAGE_SIZE;
  2010f8:	c7 05 2c e0 01 c0 00 	movl   $0x1000,0xc001e02c
  2010ff:	10 00 00 

    Multiboot *mbi = static_cast<Multiboot *>(Hpt::remap (Pd::kern.quota, addr));
  201102:	e8 e7 4a e0 bf       	call   c0005bee <_ZN3Hpt5remapER5Quotam>

    uint32 flags       = mbi->flags;
  201107:	8b 18                	mov    (%eax),%ebx
    h->sel_exc    = NUM_EXC;
    h->sel_vmi    = NUM_VMI;
    h->cfg_page   = PAGE_SIZE;
    h->cfg_utcb   = PAGE_SIZE;

    Multiboot *mbi = static_cast<Multiboot *>(Hpt::remap (Pd::kern.quota, addr));
  201109:	89 c2                	mov    %eax,%edx

    uint32 flags       = mbi->flags;
    uint32 cmdline     = mbi->cmdline;
    uint32 mmap_addr   = mbi->mmap_addr;
  20110b:	8b 6a 30             	mov    0x30(%edx),%ebp
    h->cfg_utcb   = PAGE_SIZE;

    Multiboot *mbi = static_cast<Multiboot *>(Hpt::remap (Pd::kern.quota, addr));

    uint32 flags       = mbi->flags;
    uint32 cmdline     = mbi->cmdline;
  20110e:	8b 40 10             	mov    0x10(%eax),%eax
    uint32 mmap_addr   = mbi->mmap_addr;
    uint32 mmap_len    = mbi->mmap_len;
  201111:	8b 4a 2c             	mov    0x2c(%edx),%ecx
    uint32 mods_addr   = mbi->mods_addr;
    uint32 mods_count  = mbi->mods_count;

    if (flags & Multiboot::CMDLINE)
  201114:	f6 c3 04             	test   $0x4,%bl

    uint32 flags       = mbi->flags;
    uint32 cmdline     = mbi->cmdline;
    uint32 mmap_addr   = mbi->mmap_addr;
    uint32 mmap_len    = mbi->mmap_len;
    uint32 mods_addr   = mbi->mods_addr;
  201117:	8b 72 18             	mov    0x18(%edx),%esi
    uint32 mods_count  = mbi->mods_count;
  20111a:	8b 7a 14             	mov    0x14(%edx),%edi

    if (flags & Multiboot::CMDLINE)
  20111d:	74 0b                	je     20112a <_ZN3Hip5buildEm+0xb4>
  20111f:	89 0c 24             	mov    %ecx,(%esp)
        Cmdline::init (cmdline);
  201122:	e8 2f fa ff ff       	call   200b56 <_ZN7Cmdline4initEm>
  201127:	8b 0c 24             	mov    (%esp),%ecx

    Hip_mem *mem = h->mem_desc;

    if (flags & Multiboot::MEMORY_MAP)
  20112a:	f6 c3 40             	test   $0x40,%bl
    uint32 mods_count  = mbi->mods_count;

    if (flags & Multiboot::CMDLINE)
        Cmdline::init (cmdline);

    Hip_mem *mem = h->mem_desc;
  20112d:	c7 44 24 04 38 e2 01 	movl   $0xc001e238,0x4(%esp)
  201134:	c0 

    if (flags & Multiboot::MEMORY_MAP)
  201135:	74 0b                	je     201142 <_ZN3Hip5buildEm+0xcc>
        add_mem (mem, mmap_addr, mmap_len);
  201137:	89 ea                	mov    %ebp,%edx
  201139:	8d 44 24 04          	lea    0x4(%esp),%eax
  20113d:	e8 40 fe ff ff       	call   200f82 <_ZN3Hip7add_memERP7Hip_memmj>

    if (flags & Multiboot::MODULES)
  201142:	f6 c3 08             	test   $0x8,%bl
  201145:	74 0d                	je     201154 <_ZN3Hip5buildEm+0xde>
        add_mod (mem, mods_addr, mods_count);
  201147:	89 f9                	mov    %edi,%ecx
  201149:	89 f2                	mov    %esi,%edx
  20114b:	8d 44 24 04          	lea    0x4(%esp),%eax
  20114f:	e8 82 fe ff ff       	call   200fd6 <_ZN3Hip7add_modERP7Hip_memmj>

    add_mhv (mem);
  201154:	8d 44 24 04          	lea    0x4(%esp),%eax
  201158:	e8 e5 fe ff ff       	call   201042 <_ZN3Hip7add_mhvERP7Hip_mem>

    h->length = static_cast<uint16>(reinterpret_cast<mword>(mem) - reinterpret_cast<mword>(h));
  20115d:	8b 44 24 04          	mov    0x4(%esp),%eax
  201161:	2d 00 e0 01 c0       	sub    $0xc001e000,%eax
  201166:	66 a3 06 e0 01 c0    	mov    %ax,0xc001e006
}
  20116c:	83 c4 08             	add    $0x8,%esp
  20116f:	5b                   	pop    %ebx
  201170:	5e                   	pop    %esi
  201171:	5f                   	pop    %edi
  201172:	5d                   	pop    %ebp
  201173:	c3                   	ret    

00201174 <_ZN3Idt5buildEv>:

void Idt::build()
{
    mword *ptr = handlers;

    for (unsigned vector = 0; vector < VEC_MAX; vector++, ptr++)
  201174:	31 d2                	xor    %edx,%edx
        if (*ptr)
  201176:	8b 04 95 ac 9f 01 c0 	mov    -0x3ffe6054(,%edx,4),%eax
  20117d:	85 c0                	test   %eax,%eax
  20117f:	74 2e                	je     2011af <_ZN3Idt5buildEv+0x3b>
        uint32 val[sizeof (mword) / 2];

        ALWAYS_INLINE
        inline void set (Type type, unsigned dpl, unsigned selector, mword offset)
        {
            val[0] = static_cast<uint32>(selector << 16 | (offset & 0xffff));
  201181:	89 c1                	mov    %eax,%ecx
  201183:	81 e1 fc ff 00 00    	and    $0xfffc,%ecx
  201189:	81 c9 00 00 08 00    	or     $0x80000,%ecx
  20118f:	89 0c d5 08 ab 01 c0 	mov    %ecx,-0x3ffe54f8(,%edx,8)
            val[1] = static_cast<uint32>((offset & 0xffff0000) | 1u << 15 | dpl << 13 | type);
  201196:	89 c1                	mov    %eax,%ecx
            idt[vector].set (SYS_INTR_GATE, *ptr & 3, SEL_KERN_CODE, *ptr & ~3);
  201198:	83 e0 03             	and    $0x3,%eax
  20119b:	66 31 c9             	xor    %cx,%cx
  20119e:	80 cd 8e             	or     $0x8e,%ch
  2011a1:	c1 e0 0d             	shl    $0xd,%eax
  2011a4:	09 c8                	or     %ecx,%eax
  2011a6:	89 04 d5 0c ab 01 c0 	mov    %eax,-0x3ffe54f4(,%edx,8)
  2011ad:	eb 16                	jmp    2011c5 <_ZN3Idt5buildEv+0x51>
        uint32 val[sizeof (mword) / 2];

        ALWAYS_INLINE
        inline void set (Type type, unsigned dpl, unsigned selector, mword offset)
        {
            val[0] = static_cast<uint32>(selector << 16 | (offset & 0xffff));
  2011af:	c7 04 d5 08 ab 01 c0 	movl   $0x400000,-0x3ffe54f8(,%edx,8)
  2011b6:	00 00 40 00 
            val[1] = static_cast<uint32>((offset & 0xffff0000) | 1u << 15 | dpl << 13 | type);
  2011ba:	c7 04 d5 0c ab 01 c0 	movl   $0x8500,-0x3ffe54f4(,%edx,8)
  2011c1:	00 85 00 00 

void Idt::build()
{
    mword *ptr = handlers;

    for (unsigned vector = 0; vector < VEC_MAX; vector++, ptr++)
  2011c5:	42                   	inc    %edx
  2011c6:	81 fa aa 00 00 00    	cmp    $0xaa,%edx
  2011cc:	75 a8                	jne    201176 <_ZN3Idt5buildEv+0x2>
        if (*ptr)
            idt[vector].set (SYS_INTR_GATE, *ptr & 3, SEL_KERN_CODE, *ptr & ~3);
        else
            idt[vector].set (SYS_TASK_GATE, 0, SEL_TSS_DBF, 0);
}
  2011ce:	c3                   	ret    

002011cf <kern_ptab_setup>:
#include "keyb.hpp"
#include "pd.hpp"

extern "C" INIT
mword kern_ptab_setup()
{
  2011cf:	50                   	push   %eax
    Hptp hpt;

    // Allocate and map cpu page
    hpt.update (Pd::kern.quota, CPU_LOCAL_DATA, 0,
                Buddy::ptr_to_phys (Buddy::allocator.alloc (0, Pd::kern.quota, Buddy::FILL_0)),
                Hpt::HPT_NX | Hpt::HPT_G | Hpt::HPT_W | Hpt::HPT_P);
  2011d0:	b9 50 b4 01 c0       	mov    $0xc001b450,%ecx
  2011d5:	31 d2                	xor    %edx,%edx
  2011d7:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax

        void free_up (Quota &quota, unsigned l, P *, mword, bool (*) (Paddr, mword, unsigned), bool (*) (unsigned, mword));

    public:

        Pte() : val(0) {}
  2011dc:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  2011e3:	6a 01                	push   $0x1
  2011e5:	e8 22 02 e0 bf       	call   c000140c <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
  2011ea:	b9 00 f0 ff cf       	mov    $0xcffff000,%ecx
  2011ef:	ba 50 b4 01 c0       	mov    $0xc001b450,%edx
  2011f4:	6a 00                	push   $0x0
  2011f6:	68 03 01 00 00       	push   $0x103
  2011fb:	2d 00 00 c0 bf       	sub    $0xbfc00000,%eax
  201200:	50                   	push   %eax
  201201:	6a 00                	push   $0x0
  201203:	8d 44 24 14          	lea    0x14(%esp),%eax
  201207:	e8 b4 ce e0 bf       	call   c000e0c0 <_ZN3PteI3HptmLj2ELj10ELb0EE6updateER5QuotammmmNS1_4TypeE>

    // Allocate and map kernel stack
    hpt.update (Pd::kern.quota, CPU_LOCAL_STCK, 0,
                Buddy::ptr_to_phys (Buddy::allocator.alloc (0, Pd::kern.quota, Buddy::FILL_0)),
                Hpt::HPT_NX | Hpt::HPT_G | Hpt::HPT_W | Hpt::HPT_P);
  20120c:	b9 50 b4 01 c0       	mov    $0xc001b450,%ecx
  201211:	31 d2                	xor    %edx,%edx
  201213:	6a 01                	push   $0x1
  201215:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
  20121a:	e8 ed 01 e0 bf       	call   c000140c <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
  20121f:	b9 00 d0 ff cf       	mov    $0xcfffd000,%ecx
  201224:	ba 50 b4 01 c0       	mov    $0xc001b450,%edx
  201229:	6a 00                	push   $0x0
  20122b:	68 03 01 00 00       	push   $0x103
  201230:	2d 00 00 c0 bf       	sub    $0xbfc00000,%eax
  201235:	50                   	push   %eax
  201236:	6a 00                	push   $0x0
  201238:	8d 44 24 28          	lea    0x28(%esp),%eax
  20123c:	e8 7f ce e0 bf       	call   c000e0c0 <_ZN3PteI3HptmLj2ELj10ELb0EE6updateER5QuotammmmNS1_4TypeE>

    // Sync kernel code and data
    hpt.sync_master_range (Pd::kern.quota, LINK_ADDR, CPU_LOCAL);
  201241:	83 c4 28             	add    $0x28,%esp
  201244:	b9 00 00 00 c0       	mov    $0xc0000000,%ecx
  201249:	68 00 00 c0 cf       	push   $0xcfc00000
  20124e:	ba 50 b4 01 c0       	mov    $0xc001b450,%edx
  201253:	8d 44 24 04          	lea    0x4(%esp),%eax
  201257:	e8 f0 48 e0 bf       	call   c0005b4c <_ZN3Hpt17sync_master_rangeER5Quotamm>
            PTE_S   = HPT_S,
            PTE_N   = HPT_A | HPT_U | HPT_W | HPT_P,
        };

        ALWAYS_INLINE
        inline Paddr addr() const { return static_cast<Paddr>(val) & ~PAGE_MASK; }
  20125c:	8b 44 24 04          	mov    0x4(%esp),%eax

    return hpt.addr();
}
  201260:	83 c4 08             	add    $0x8,%esp
  201263:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  201268:	c3                   	ret    

00201269 <init>:

extern "C" INIT REGPARM (1)
void init (mword mbi)
{
  201269:	57                   	push   %edi
  20126a:	ba 00 10 00 00       	mov    $0x1000,%edx
  20126f:	56                   	push   %esi
  201270:	bf 00 c0 01 c0       	mov    $0xc001c000,%edi
  201275:	53                   	push   %ebx
  201276:	89 d1                	mov    %edx,%ecx
  201278:	89 c3                	mov    %eax,%ebx
  20127a:	31 c0                	xor    %eax,%eax
  20127c:	f3 aa                	rep stos %al,%es:(%edi)
  20127e:	bf 00 d0 01 c0       	mov    $0xc001d000,%edi
  201283:	89 d1                	mov    %edx,%ecx
  201285:	83 c8 ff             	or     $0xffffffff,%eax
  201288:	f3 aa                	rep stos %al,%es:(%edi)
    // Setup 0-page and 1-page
    memset (reinterpret_cast<void *>(&PAGE_0),  0,  PAGE_SIZE);
    memset (reinterpret_cast<void *>(&PAGE_1), ~0u, PAGE_SIZE);

    for (void (**func)() = &CTORS_G; func != &CTORS_E; (*func++)()) ;
  20128a:	be 5c 9f 01 c0       	mov    $0xc0019f5c,%esi
  20128f:	81 fe a8 9f 01 c0    	cmp    $0xc0019fa8,%esi
  201295:	74 08                	je     20129f <init+0x36>
  201297:	83 c6 04             	add    $0x4,%esi
  20129a:	ff 56 fc             	call   *-0x4(%esi)
  20129d:	eb f0                	jmp    20128f <init+0x26>

    Hip::build (mbi);
  20129f:	89 d8                	mov    %ebx,%eax

    for (void (**func)() = &CTORS_C; func != &CTORS_G; (*func++)()) ;
  2012a1:	bb 54 9f 01 c0       	mov    $0xc0019f54,%ebx
    memset (reinterpret_cast<void *>(&PAGE_0),  0,  PAGE_SIZE);
    memset (reinterpret_cast<void *>(&PAGE_1), ~0u, PAGE_SIZE);

    for (void (**func)() = &CTORS_G; func != &CTORS_E; (*func++)()) ;

    Hip::build (mbi);
  2012a6:	e8 cb fd ff ff       	call   201076 <_ZN3Hip5buildEm>

    for (void (**func)() = &CTORS_C; func != &CTORS_G; (*func++)()) ;
  2012ab:	81 fb 5c 9f 01 c0    	cmp    $0xc0019f5c,%ebx
  2012b1:	74 08                	je     2012bb <init+0x52>
  2012b3:	83 c3 04             	add    $0x4,%ebx
  2012b6:	ff 53 fc             	call   *-0x4(%ebx)
  2012b9:	eb f0                	jmp    2012ab <init+0x42>

    // Now we're ready to talk to the world
    Console::print ("\fNOVA Microhypervisor v%d-%07lx (%s): %s %s [%s]\n", CFG_VER, reinterpret_cast<mword>(&GIT_VER), ARCH, __DATE__, __TIME__, COMPILER_STRING);
  2012bb:	68 af 71 01 c0       	push   $0xc00171af
  2012c0:	68 b9 71 01 c0       	push   $0xc00171b9
  2012c5:	68 c2 71 01 c0       	push   $0xc00171c2
  2012ca:	68 ce 71 01 c0       	push   $0xc00171ce
  2012cf:	68 82 78 3e 02       	push   $0x23e7882
  2012d4:	6a 07                	push   $0x7
  2012d6:	68 d5 71 01 c0       	push   $0xc00171d5
  2012db:	e8 fe 06 e0 bf       	call   c00019de <_ZN7Console5printEPKcz>

    Idt::build();
  2012e0:	e8 8f fe ff ff       	call   201174 <_ZN3Idt5buildEv>
    Gsi::setup();
  2012e5:	e8 1e fc ff ff       	call   200f08 <_ZN3Gsi5setupEv>
    Acpi::setup();
  2012ea:	e8 11 ed ff ff       	call   200000 <_ZN4Acpi5setupEv>

    Console_vga::con.setup();
  2012ef:	b8 a0 a3 01 c0       	mov    $0xc001a3a0,%eax
  2012f4:	e8 a1 f9 ff ff       	call   200c9a <_ZN11Console_vga5setupEv>

    Keyb::init();
  2012f9:	83 c4 1c             	add    $0x1c,%esp
}
  2012fc:	5b                   	pop    %ebx
  2012fd:	5e                   	pop    %esi
  2012fe:	5f                   	pop    %edi
    Gsi::setup();
    Acpi::setup();

    Console_vga::con.setup();

    Keyb::init();
  2012ff:	e9 8e 00 00 00       	jmp    201392 <_ZN4Keyb4initEv>

00201304 <_ZN6IoapicC1Emjj>:
INIT_PRIORITY (PRIO_SLAB)
Slab_cache Ioapic::cache (sizeof (Ioapic), 8);

Ioapic *Ioapic::list;

Ioapic::Ioapic (Paddr p, unsigned i, unsigned g) : List<Ioapic> (list), reg_base ((hwdev_addr -= PAGE_SIZE) | (p & PAGE_MASK)), gsi_base (g), id (i), rid (0)
  201304:	56                   	push   %esi
  201305:	be 58 b0 01 c0       	mov    $0xc001b058,%esi
  20130a:	53                   	push   %ebx
  20130b:	89 c3                	mov    %eax,%ebx
    protected:
        T *next;

    public:
        ALWAYS_INLINE
        explicit inline List (T *&list) : next (nullptr)
  20130d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        {
            T **ptr; for (ptr = &list; *ptr; ptr = &(*ptr)->next) ; *ptr = static_cast<T *>(this);
  201313:	a1 58 b0 01 c0       	mov    0xc001b058,%eax
  201318:	85 c0                	test   %eax,%eax
  20131a:	74 06                	je     201322 <_ZN6IoapicC1Emjj+0x1e>
  20131c:	89 c6                	mov    %eax,%esi
  20131e:	8b 00                	mov    (%eax),%eax
  201320:	eb f6                	jmp    201318 <_ZN6IoapicC1Emjj+0x14>
  201322:	89 1e                	mov    %ebx,(%esi)
  201324:	89 d6                	mov    %edx,%esi
{
    Pd::kern.Space_mem::delreg (Pd::kern.quota, p & ~PAGE_MASK);
  201326:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
INIT_PRIORITY (PRIO_SLAB)
Slab_cache Ioapic::cache (sizeof (Ioapic), 8);

Ioapic *Ioapic::list;

Ioapic::Ioapic (Paddr p, unsigned i, unsigned g) : List<Ioapic> (list), reg_base ((hwdev_addr -= PAGE_SIZE) | (p & PAGE_MASK)), gsi_base (g), id (i), rid (0)
  20132c:	a1 58 a2 01 c0       	mov    0xc001a258,%eax
  201331:	81 e6 ff 0f 00 00    	and    $0xfff,%esi
  201337:	89 4b 0c             	mov    %ecx,0xc(%ebx)
{
    Pd::kern.Space_mem::delreg (Pd::kern.quota, p & ~PAGE_MASK);
  20133a:	89 d1                	mov    %edx,%ecx
INIT_PRIORITY (PRIO_SLAB)
Slab_cache Ioapic::cache (sizeof (Ioapic), 8);

Ioapic *Ioapic::list;

Ioapic::Ioapic (Paddr p, unsigned i, unsigned g) : List<Ioapic> (list), reg_base ((hwdev_addr -= PAGE_SIZE) | (p & PAGE_MASK)), gsi_base (g), id (i), rid (0)
  20133c:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
  201342:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  201348:	2d 00 10 00 00       	sub    $0x1000,%eax
  20134d:	a3 58 a2 01 c0       	mov    %eax,0xc001a258
  201352:	09 f0                	or     %esi,%eax
{
    Pd::kern.Space_mem::delreg (Pd::kern.quota, p & ~PAGE_MASK);
  201354:	89 d6                	mov    %edx,%esi
INIT_PRIORITY (PRIO_SLAB)
Slab_cache Ioapic::cache (sizeof (Ioapic), 8);

Ioapic *Ioapic::list;

Ioapic::Ioapic (Paddr p, unsigned i, unsigned g) : List<Ioapic> (list), reg_base ((hwdev_addr -= PAGE_SIZE) | (p & PAGE_MASK)), gsi_base (g), id (i), rid (0)
  201356:	89 43 04             	mov    %eax,0x4(%ebx)
  201359:	8b 44 24 0c          	mov    0xc(%esp),%eax
{
    Pd::kern.Space_mem::delreg (Pd::kern.quota, p & ~PAGE_MASK);
  20135d:	ba 50 b4 01 c0       	mov    $0xc001b450,%edx
INIT_PRIORITY (PRIO_SLAB)
Slab_cache Ioapic::cache (sizeof (Ioapic), 8);

Ioapic *Ioapic::list;

Ioapic::Ioapic (Paddr p, unsigned i, unsigned g) : List<Ioapic> (list), reg_base ((hwdev_addr -= PAGE_SIZE) | (p & PAGE_MASK)), gsi_base (g), id (i), rid (0)
  201362:	89 43 08             	mov    %eax,0x8(%ebx)
{
    Pd::kern.Space_mem::delreg (Pd::kern.quota, p & ~PAGE_MASK);
  201365:	b8 0c b3 01 c0       	mov    $0xc001b30c,%eax
  20136a:	e8 91 10 e0 bf       	call   c0002400 <_ZN5Space6delregER5Quotam>
  20136f:	8b 4b 04             	mov    0x4(%ebx),%ecx
  201372:	ba 50 b4 01 c0       	mov    $0xc001b450,%edx
  201377:	6a 00                	push   $0x0
  201379:	b8 14 b4 01 c0       	mov    $0xc001b414,%eax
  20137e:	68 13 01 00 00       	push   $0x113
  201383:	56                   	push   %esi
  201384:	6a 00                	push   $0x0
  201386:	e8 35 cd e0 bf       	call   c000e0c0 <_ZN3PteI3HptmLj2ELj10ELb0EE6updateER5QuotammmmNS1_4TypeE>
  20138b:	83 c4 10             	add    $0x10,%esp
    Pd::kern.Space_mem::insert (Pd::kern.quota, reg_base, 0, Hpt::HPT_NX | Hpt::HPT_G | Hpt::HPT_UC | Hpt::HPT_W | Hpt::HPT_P, p & ~PAGE_MASK);

    trace (TRACE_APIC, "APIC:%#lx ID:%#x VER:%#x IRT:%#x PRQ:%u GSI:%u",
           p, i, version(), irt_max(), prq(), gsi_base);
}
  20138e:	5b                   	pop    %ebx
  20138f:	5e                   	pop    %esi
  201390:	c3                   	ret    
  201391:	90                   	nop

00201392 <_ZN4Keyb4initEv>:

unsigned Keyb::gsi = ~0u;

void Keyb::init()
{
    if (!Cmdline::keyb)
  201392:	80 3d 8b a3 01 c0 00 	cmpb   $0x0,0xc001a38b
  201399:	75 01                	jne    20139c <_ZN4Keyb4initEv+0xa>
  20139b:	c3                   	ret    
        template <typename T>
        ALWAYS_INLINE
        static inline unsigned in (unsigned port)
        {
            T val;
            asm volatile ("in %w1, %0" : "=a" (val) : "Nd" (port));
  20139c:	e4 64                	in     $0x64,%al
        return;

    while (status() & STS_OUTB)
  20139e:	24 01                	and    $0x1,%al
  2013a0:	84 c0                	test   %al,%al
  2013a2:	74 04                	je     2013a8 <_ZN4Keyb4initEv+0x16>
  2013a4:	e4 60                	in     $0x60,%al
  2013a6:	eb f4                	jmp    20139c <_ZN4Keyb4initEv+0xa>
  2013a8:	a1 a4 a4 01 c0       	mov    0xc001a4a4,%eax

    gsi = Gsi::irq_to_gsi (irq);

    trace (TRACE_KEYB, "KEYB: GSI:%#x", gsi);

    Gsi::set (gsi);
  2013ad:	31 c9                	xor    %ecx,%ecx
  2013af:	31 d2                	xor    %edx,%edx
        return;

    while (status() & STS_OUTB)
        output();

    gsi = Gsi::irq_to_gsi (irq);
  2013b1:	a3 54 a2 01 c0       	mov    %eax,0xc001a254

    trace (TRACE_KEYB, "KEYB: GSI:%#x", gsi);

    Gsi::set (gsi);
  2013b6:	e9 c5 42 e0 bf       	jmp    c0005680 <_ZN3Gsi3setEjjj>
  2013bb:	90                   	nop

002013bc <_ZN4Mtrr4initEv>:

INIT_PRIORITY (PRIO_SLAB)
Slab_cache Mtrr::cache (sizeof (Mtrr), 8);

void Mtrr::init()
{
  2013bc:	55                   	push   %ebp
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
  2013bd:	b9 fe 00 00 00       	mov    $0xfe,%ecx
  2013c2:	57                   	push   %edi
  2013c3:	56                   	push   %esi
  2013c4:	53                   	push   %ebx
  2013c5:	52                   	push   %edx
  2013c6:	0f 32                	rdmsr  
    count = Msr::read<uint32>(Msr::IA32_MTRR_CAP) & 0xff;
  2013c8:	0f b6 c8             	movzbl %al,%ecx
  2013cb:	89 0d b8 b0 01 c0    	mov    %ecx,0xc001b0b8
  2013d1:	b9 ff 02 00 00       	mov    $0x2ff,%ecx
  2013d6:	0f 32                	rdmsr  
    dtype = Msr::read<uint32>(Msr::IA32_MTRR_DEF_TYPE) & 0xff;
  2013d8:	0f b6 c8             	movzbl %al,%ecx

    for (unsigned i = 0; i < count; i++)
  2013db:	31 f6                	xor    %esi,%esi
Slab_cache Mtrr::cache (sizeof (Mtrr), 8);

void Mtrr::init()
{
    count = Msr::read<uint32>(Msr::IA32_MTRR_CAP) & 0xff;
    dtype = Msr::read<uint32>(Msr::IA32_MTRR_DEF_TYPE) & 0xff;
  2013dd:	89 0d b4 b0 01 c0    	mov    %ecx,0xc001b0b4

    for (unsigned i = 0; i < count; i++)
  2013e3:	3b 35 b8 b0 01 c0    	cmp    0xc001b0b8,%esi
  2013e9:	73 53                	jae    20143e <_ZN4Mtrr4initEv+0x82>
  2013eb:	8d 8c 36 00 02 00 00 	lea    0x200(%esi,%esi,1),%ecx
  2013f2:	0f 32                	rdmsr  
  2013f4:	89 14 24             	mov    %edx,(%esp)
  2013f7:	89 c5                	mov    %eax,%ebp
  2013f9:	41                   	inc    %ecx
  2013fa:	0f 32                	rdmsr  
  2013fc:	89 d3                	mov    %edx,%ebx
  2013fe:	89 c7                	mov    %eax,%edi
    public:
        ALWAYS_INLINE
        explicit inline Mtrr (uint64 b, uint64 m) : List<Mtrr> (list), base (b), mask (m) {}

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
  201400:	ba 50 b4 01 c0       	mov    $0xc001b450,%edx
  201405:	b8 98 b0 01 c0       	mov    $0xc001b098,%eax
  20140a:	e8 67 ee e0 bf       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
  20140f:	b9 b0 b0 01 c0       	mov    $0xc001b0b0,%ecx
    protected:
        T *next;

    public:
        ALWAYS_INLINE
        explicit inline List (T *&list) : next (nullptr)
  201414:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        {
            T **ptr; for (ptr = &list; *ptr; ptr = &(*ptr)->next) ; *ptr = static_cast<T *>(this);
  20141a:	8b 15 b0 b0 01 c0    	mov    0xc001b0b0,%edx
  201420:	85 d2                	test   %edx,%edx
  201422:	74 06                	je     20142a <_ZN4Mtrr4initEv+0x6e>
  201424:	89 d1                	mov    %edx,%ecx
  201426:	8b 12                	mov    (%edx),%edx
  201428:	eb f6                	jmp    201420 <_ZN4Mtrr4initEv+0x64>
                                                       bit_scan_forward (static_cast<mword>(mask >> 32)) + 32);
        }

    public:
        ALWAYS_INLINE
        explicit inline Mtrr (uint64 b, uint64 m) : List<Mtrr> (list), base (b), mask (m) {}
  20142a:	8b 14 24             	mov    (%esp),%edx
  20142d:	46                   	inc    %esi
  20142e:	89 01                	mov    %eax,(%ecx)
  201430:	89 68 04             	mov    %ebp,0x4(%eax)
  201433:	89 78 0c             	mov    %edi,0xc(%eax)
  201436:	89 50 08             	mov    %edx,0x8(%eax)
  201439:	89 58 10             	mov    %ebx,0x10(%eax)
  20143c:	eb a5                	jmp    2013e3 <_ZN4Mtrr4initEv+0x27>
        new (Pd::kern.quota) Mtrr (Msr::read<uint64>(Msr::Register (Msr::IA32_MTRR_PHYS_BASE + 2 * i)),
                                   Msr::read<uint64>(Msr::Register (Msr::IA32_MTRR_PHYS_MASK + 2 * i)));
}
  20143e:	58                   	pop    %eax
  20143f:	5b                   	pop    %ebx
  201440:	5e                   	pop    %esi
  201441:	5f                   	pop    %edi
  201442:	5d                   	pop    %ebp
  201443:	c3                   	ret    

00201444 <_ZN4Mtrr7memtypeEyRy>:

unsigned Mtrr::memtype (uint64 phys, uint64 &next)
{
  201444:	55                   	push   %ebp
  201445:	57                   	push   %edi
  201446:	56                   	push   %esi
  201447:	53                   	push   %ebx
  201448:	89 cb                	mov    %ecx,%ebx
  20144a:	83 ec 1c             	sub    $0x1c,%esp
  20144d:	89 54 24 04          	mov    %edx,0x4(%esp)
    if (phys < 0x80000) {
  201451:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
        new (Pd::kern.quota) Mtrr (Msr::read<uint64>(Msr::Register (Msr::IA32_MTRR_PHYS_BASE + 2 * i)),
                                   Msr::read<uint64>(Msr::Register (Msr::IA32_MTRR_PHYS_MASK + 2 * i)));
}

unsigned Mtrr::memtype (uint64 phys, uint64 &next)
{
  201456:	89 04 24             	mov    %eax,(%esp)
    if (phys < 0x80000) {
  201459:	0f 87 e9 00 00 00    	ja     201548 <_ZN4Mtrr7memtypeEyRy+0x104>
  20145f:	81 3c 24 ff ff 07 00 	cmpl   $0x7ffff,(%esp)
  201466:	77 2e                	ja     201496 <_ZN4Mtrr7memtypeEyRy+0x52>
        next = 1 + (phys | 0xffff);
  201468:	8b 34 24             	mov    (%esp),%esi
  20146b:	8b 54 24 04          	mov    0x4(%esp),%edx
  20146f:	81 ce ff ff 00 00    	or     $0xffff,%esi
  201475:	89 f0                	mov    %esi,%eax
  201477:	83 c0 01             	add    $0x1,%eax
  20147a:	83 d2 00             	adc    $0x0,%edx
  20147d:	89 01                	mov    %eax,(%ecx)
  20147f:	89 51 04             	mov    %edx,0x4(%ecx)
  201482:	b9 50 02 00 00       	mov    $0x250,%ecx
  201487:	0f 32                	rdmsr  
        return static_cast<unsigned>(Msr::read<uint64>(Msr::IA32_MTRR_FIX64K_BASE) >>
                                    (phys >> 13 & 0x38)) & 0xff;
  201489:	8b 0c 24             	mov    (%esp),%ecx
  20148c:	8b 5c 24 04          	mov    0x4(%esp),%ebx
  201490:	0f ac d9 0d          	shrd   $0xd,%ebx,%ecx
  201494:	eb 4f                	jmp    2014e5 <_ZN4Mtrr7memtypeEyRy+0xa1>
    }

    if (phys < 0xc0000) {
  201496:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
  20149b:	0f 87 a7 00 00 00    	ja     201548 <_ZN4Mtrr7memtypeEyRy+0x104>
  2014a1:	81 3c 24 ff ff 0b 00 	cmpl   $0xbffff,(%esp)
  2014a8:	77 51                	ja     2014fb <_ZN4Mtrr7memtypeEyRy+0xb7>
        next = 1 + (phys | 0x3fff);
  2014aa:	8b 34 24             	mov    (%esp),%esi
  2014ad:	8b 54 24 04          	mov    0x4(%esp),%edx
        return static_cast<unsigned>(Msr::read<uint64>(Msr::Register (Msr::IA32_MTRR_FIX16K_BASE + (phys >> 17 & 0x1))) >>
  2014b1:	8b 5c 24 04          	mov    0x4(%esp),%ebx
        return static_cast<unsigned>(Msr::read<uint64>(Msr::IA32_MTRR_FIX64K_BASE) >>
                                    (phys >> 13 & 0x38)) & 0xff;
    }

    if (phys < 0xc0000) {
        next = 1 + (phys | 0x3fff);
  2014b5:	81 ce ff 3f 00 00    	or     $0x3fff,%esi
  2014bb:	89 f0                	mov    %esi,%eax
  2014bd:	83 c0 01             	add    $0x1,%eax
  2014c0:	83 d2 00             	adc    $0x0,%edx
  2014c3:	89 01                	mov    %eax,(%ecx)
  2014c5:	89 51 04             	mov    %edx,0x4(%ecx)
        return static_cast<unsigned>(Msr::read<uint64>(Msr::Register (Msr::IA32_MTRR_FIX16K_BASE + (phys >> 17 & 0x1))) >>
  2014c8:	8b 0c 24             	mov    (%esp),%ecx
  2014cb:	0f ac d9 11          	shrd   $0x11,%ebx,%ecx
  2014cf:	83 e1 01             	and    $0x1,%ecx
  2014d2:	81 c1 58 02 00 00    	add    $0x258,%ecx
  2014d8:	0f 32                	rdmsr  
                                    (phys >> 11 & 0x38)) & 0xff;
  2014da:	8b 0c 24             	mov    (%esp),%ecx
  2014dd:	8b 5c 24 04          	mov    0x4(%esp),%ebx
  2014e1:	0f ac d9 0b          	shrd   $0xb,%ebx,%ecx
                                    (phys >> 13 & 0x38)) & 0xff;
    }

    if (phys < 0xc0000) {
        next = 1 + (phys | 0x3fff);
        return static_cast<unsigned>(Msr::read<uint64>(Msr::Register (Msr::IA32_MTRR_FIX16K_BASE + (phys >> 17 & 0x1))) >>
  2014e5:	83 e1 38             	and    $0x38,%ecx
  2014e8:	0f ad d0             	shrd   %cl,%edx,%eax
  2014eb:	d3 ea                	shr    %cl,%edx
  2014ed:	f6 c1 20             	test   $0x20,%cl
  2014f0:	0f 45 c2             	cmovne %edx,%eax
                                    (phys >> 11 & 0x38)) & 0xff;
  2014f3:	0f b6 c0             	movzbl %al,%eax
  2014f6:	e9 76 01 00 00       	jmp    201671 <_ZN4Mtrr7memtypeEyRy+0x22d>
    }

    if (phys < 0x100000) {
  2014fb:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
  201500:	77 46                	ja     201548 <_ZN4Mtrr7memtypeEyRy+0x104>
  201502:	81 3c 24 ff ff 0f 00 	cmpl   $0xfffff,(%esp)
  201509:	77 3d                	ja     201548 <_ZN4Mtrr7memtypeEyRy+0x104>
        next = 1 + (phys | 0xfff);
  20150b:	8b 34 24             	mov    (%esp),%esi
  20150e:	8b 54 24 04          	mov    0x4(%esp),%edx
        return static_cast<unsigned>(Msr::read<uint64>(Msr::Register (Msr::IA32_MTRR_FIX4K_BASE  + (phys >> 15 & 0x7))) >>
  201512:	8b 5c 24 04          	mov    0x4(%esp),%ebx
        return static_cast<unsigned>(Msr::read<uint64>(Msr::Register (Msr::IA32_MTRR_FIX16K_BASE + (phys >> 17 & 0x1))) >>
                                    (phys >> 11 & 0x38)) & 0xff;
    }

    if (phys < 0x100000) {
        next = 1 + (phys | 0xfff);
  201516:	81 ce ff 0f 00 00    	or     $0xfff,%esi
  20151c:	89 f0                	mov    %esi,%eax
  20151e:	83 c0 01             	add    $0x1,%eax
  201521:	83 d2 00             	adc    $0x0,%edx
  201524:	89 01                	mov    %eax,(%ecx)
  201526:	89 51 04             	mov    %edx,0x4(%ecx)
        return static_cast<unsigned>(Msr::read<uint64>(Msr::Register (Msr::IA32_MTRR_FIX4K_BASE  + (phys >> 15 & 0x7))) >>
  201529:	8b 0c 24             	mov    (%esp),%ecx
  20152c:	0f ac d9 0f          	shrd   $0xf,%ebx,%ecx
  201530:	83 e1 07             	and    $0x7,%ecx
  201533:	81 c1 68 02 00 00    	add    $0x268,%ecx
  201539:	0f 32                	rdmsr  
                                    (phys >>  9 & 0x38)) & 0xff;
  20153b:	8b 0c 24             	mov    (%esp),%ecx
  20153e:	8b 5c 24 04          	mov    0x4(%esp),%ebx
  201542:	0f ac d9 09          	shrd   $0x9,%ebx,%ecx
  201546:	eb 9d                	jmp    2014e5 <_ZN4Mtrr7memtypeEyRy+0xa1>
    }

    unsigned type = ~0U; next = ~0ULL;
  201548:	c7 03 ff ff ff ff    	movl   $0xffffffff,(%ebx)

    for (Mtrr *mtrr = list; mtrr; mtrr = mtrr->next) {
  20154e:	8b 35 b0 b0 01 c0    	mov    0xc001b0b0,%esi
        next = 1 + (phys | 0xfff);
        return static_cast<unsigned>(Msr::read<uint64>(Msr::Register (Msr::IA32_MTRR_FIX4K_BASE  + (phys >> 15 & 0x7))) >>
                                    (phys >>  9 & 0x38)) & 0xff;
    }

    unsigned type = ~0U; next = ~0ULL;
  201554:	c7 43 04 ff ff ff ff 	movl   $0xffffffff,0x4(%ebx)
  20155b:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp)
  201562:	ff 

    for (Mtrr *mtrr = list; mtrr; mtrr = mtrr->next) {
  201563:	85 f6                	test   %esi,%esi
  201565:	0f 84 f6 00 00 00    	je     201661 <_ZN4Mtrr7memtypeEyRy+0x21d>

        if (!(mtrr->mask & 0x800))
  20156b:	8b 7e 0c             	mov    0xc(%esi),%edi
  20156e:	8b 6e 10             	mov    0x10(%esi),%ebp
  201571:	89 f8                	mov    %edi,%eax
  201573:	25 00 08 00 00       	and    $0x800,%eax
  201578:	85 c0                	test   %eax,%eax
  20157a:	0f 84 da 00 00 00    	je     20165a <_ZN4Mtrr7memtypeEyRy+0x216>
            continue;

        uint64 base = mtrr->base & ~PAGE_MASK;
  201580:	8b 56 04             	mov    0x4(%esi),%edx
  201583:	8b 46 08             	mov    0x8(%esi),%eax
  201586:	89 d1                	mov    %edx,%ecx
  201588:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx

        if (phys < base)
  20158e:	39 44 24 04          	cmp    %eax,0x4(%esp)
    for (Mtrr *mtrr = list; mtrr; mtrr = mtrr->next) {

        if (!(mtrr->mask & 0x800))
            continue;

        uint64 base = mtrr->base & ~PAGE_MASK;
  201592:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  201596:	89 44 24 0c          	mov    %eax,0xc(%esp)

        if (phys < base)
  20159a:	77 30                	ja     2015cc <_ZN4Mtrr7memtypeEyRy+0x188>
  20159c:	72 09                	jb     2015a7 <_ZN4Mtrr7memtypeEyRy+0x163>
  20159e:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  2015a2:	39 0c 24             	cmp    %ecx,(%esp)
  2015a5:	73 25                	jae    2015cc <_ZN4Mtrr7memtypeEyRy+0x188>
  2015a7:	8b 43 04             	mov    0x4(%ebx),%eax
  2015aa:	3b 44 24 0c          	cmp    0xc(%esp),%eax
  2015ae:	8b 13                	mov    (%ebx),%edx
  2015b0:	72 10                	jb     2015c2 <_ZN4Mtrr7memtypeEyRy+0x17e>
  2015b2:	77 06                	ja     2015ba <_ZN4Mtrr7memtypeEyRy+0x176>
  2015b4:	3b 54 24 08          	cmp    0x8(%esp),%edx
  2015b8:	76 08                	jbe    2015c2 <_ZN4Mtrr7memtypeEyRy+0x17e>
  2015ba:	8b 54 24 08          	mov    0x8(%esp),%edx
  2015be:	8b 44 24 0c          	mov    0xc(%esp),%eax
            next = min (next, base);
  2015c2:	89 13                	mov    %edx,(%ebx)
  2015c4:	89 43 04             	mov    %eax,0x4(%ebx)
  2015c7:	e9 8e 00 00 00       	jmp    20165a <_ZN4Mtrr7memtypeEyRy+0x216>

        else if (((phys ^ mtrr->base) & mtrr->mask) >> PAGE_BITS == 0) {
  2015cc:	33 14 24             	xor    (%esp),%edx
  2015cf:	33 44 24 04          	xor    0x4(%esp),%eax
  2015d3:	21 fa                	and    %edi,%edx
  2015d5:	21 e8                	and    %ebp,%eax
  2015d7:	89 54 24 14          	mov    %edx,0x14(%esp)
  2015db:	89 44 24 18          	mov    %eax,0x18(%esp)
  2015df:	8b 44 24 14          	mov    0x14(%esp),%eax
  2015e3:	8b 54 24 18          	mov    0x18(%esp),%edx
  2015e7:	0f ac d0 0c          	shrd   $0xc,%edx,%eax
  2015eb:	c1 ea 0c             	shr    $0xc,%edx
  2015ee:	89 d1                	mov    %edx,%ecx
  2015f0:	09 c1                	or     %eax,%ecx
  2015f2:	75 66                	jne    20165a <_ZN4Mtrr7memtypeEyRy+0x216>
        static Mtrr *       list;
        static Slab_cache   cache;

        uint64 size() const
        {
            return 1ULL << (static_cast<mword>(mask) ? bit_scan_forward (static_cast<mword>(mask >> 12)) + 12 :
  2015f4:	85 ff                	test   %edi,%edi
  2015f6:	74 13                	je     20160b <_ZN4Mtrr7memtypeEyRy+0x1c7>
  2015f8:	0f ac ef 0c          	shrd   $0xc,%ebp,%edi

ALWAYS_INLINE
inline long int bit_scan_forward (mword val)
{
    if (EXPECT_FALSE (!val))
        return -1;
  2015fc:	83 c9 ff             	or     $0xffffffff,%ecx
}

ALWAYS_INLINE
inline long int bit_scan_forward (mword val)
{
    if (EXPECT_FALSE (!val))
  2015ff:	85 ff                	test   %edi,%edi
  201601:	74 03                	je     201606 <_ZN4Mtrr7memtypeEyRy+0x1c2>
        return -1;

    asm volatile ("bsf %1, %0" : "=r" (val) : "rm" (val));

    return val;
  201603:	0f bc cf             	bsf    %edi,%ecx
  201606:	83 c1 0c             	add    $0xc,%ecx
  201609:	eb 0d                	jmp    201618 <_ZN4Mtrr7memtypeEyRy+0x1d4>

ALWAYS_INLINE
inline long int bit_scan_forward (mword val)
{
    if (EXPECT_FALSE (!val))
        return -1;
  20160b:	83 c9 ff             	or     $0xffffffff,%ecx
}

ALWAYS_INLINE
inline long int bit_scan_forward (mword val)
{
    if (EXPECT_FALSE (!val))
  20160e:	85 ed                	test   %ebp,%ebp
  201610:	74 03                	je     201615 <_ZN4Mtrr7memtypeEyRy+0x1d1>
        return -1;

    asm volatile ("bsf %1, %0" : "=r" (val) : "rm" (val));

    return val;
  201612:	0f bc cd             	bsf    %ebp,%ecx
                                                       bit_scan_forward (static_cast<mword>(mask >> 32)) + 32);
  201615:	83 c1 20             	add    $0x20,%ecx
        static Mtrr *       list;
        static Slab_cache   cache;

        uint64 size() const
        {
            return 1ULL << (static_cast<mword>(mask) ? bit_scan_forward (static_cast<mword>(mask >> 12)) + 12 :
  201618:	31 c0                	xor    %eax,%eax
  20161a:	31 d2                	xor    %edx,%edx
  20161c:	8b 3b                	mov    (%ebx),%edi
  20161e:	f6 c1 20             	test   $0x20,%cl
  201621:	0f 94 c0             	sete   %al
  201624:	0f 95 c2             	setne  %dl
  201627:	d3 e0                	shl    %cl,%eax
  201629:	d3 e2                	shl    %cl,%edx
  20162b:	8b 4b 04             	mov    0x4(%ebx),%ecx
            next = min (next, base + mtrr->size());
  20162e:	03 44 24 08          	add    0x8(%esp),%eax
  201632:	13 54 24 0c          	adc    0xc(%esp),%edx
  201636:	39 ca                	cmp    %ecx,%edx
  201638:	72 0a                	jb     201644 <_ZN4Mtrr7memtypeEyRy+0x200>
  20163a:	77 04                	ja     201640 <_ZN4Mtrr7memtypeEyRy+0x1fc>
  20163c:	39 f8                	cmp    %edi,%eax
  20163e:	76 04                	jbe    201644 <_ZN4Mtrr7memtypeEyRy+0x200>
  201640:	89 f8                	mov    %edi,%eax
  201642:	89 ca                	mov    %ecx,%edx
  201644:	89 03                	mov    %eax,(%ebx)
  201646:	89 53 04             	mov    %edx,0x4(%ebx)
            type = min (type, static_cast<unsigned>(mtrr->base) & 0xff);
  201649:	0f b6 46 04          	movzbl 0x4(%esi),%eax
  20164d:	39 44 24 10          	cmp    %eax,0x10(%esp)
  201651:	0f 46 44 24 10       	cmovbe 0x10(%esp),%eax
  201656:	89 44 24 10          	mov    %eax,0x10(%esp)
                                    (phys >>  9 & 0x38)) & 0xff;
    }

    unsigned type = ~0U; next = ~0ULL;

    for (Mtrr *mtrr = list; mtrr; mtrr = mtrr->next) {
  20165a:	8b 36                	mov    (%esi),%esi
  20165c:	e9 02 ff ff ff       	jmp    201563 <_ZN4Mtrr7memtypeEyRy+0x11f>
            next = min (next, base + mtrr->size());
            type = min (type, static_cast<unsigned>(mtrr->base) & 0xff);
        }
    }

    return type == ~0U ? dtype : type;
  201661:	83 7c 24 10 ff       	cmpl   $0xffffffff,0x10(%esp)
  201666:	8b 44 24 10          	mov    0x10(%esp),%eax
  20166a:	0f 44 05 b4 b0 01 c0 	cmove  0xc001b0b4,%eax
}
  201671:	83 c4 1c             	add    $0x1c,%esp
  201674:	5b                   	pop    %ebx
  201675:	5e                   	pop    %esi
  201676:	5f                   	pop    %edi
  201677:	5d                   	pop    %ebp
  201678:	c3                   	ret    
  201679:	90                   	nop

0020167a <_ZN3PciC1Ejj>:

struct Pci::quirk_map Pci::map[] INITDATA =
{
};

Pci::Pci (unsigned r, unsigned l) : List<Pci> (list), reg_base (hwdev_addr -= PAGE_SIZE), rid (static_cast<uint16>(r)), lev (static_cast<uint16>(l))
  20167a:	56                   	push   %esi
  20167b:	be bc b0 01 c0       	mov    $0xc001b0bc,%esi
  201680:	53                   	push   %ebx
    protected:
        T *next;

    public:
        ALWAYS_INLINE
        explicit inline List (T *&list) : next (nullptr)
  201681:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        {
            T **ptr; for (ptr = &list; *ptr; ptr = &(*ptr)->next) ; *ptr = static_cast<T *>(this);
  201687:	8b 1d bc b0 01 c0    	mov    0xc001b0bc,%ebx
  20168d:	85 db                	test   %ebx,%ebx
  20168f:	74 06                	je     201697 <_ZN3PciC1Ejj+0x1d>
  201691:	89 de                	mov    %ebx,%esi
  201693:	8b 1b                	mov    (%ebx),%ebx
  201695:	eb f6                	jmp    20168d <_ZN3PciC1Ejj+0x13>
  201697:	89 06                	mov    %eax,(%esi)
  201699:	8b 35 58 a2 01 c0    	mov    0xc001a258,%esi
  20169f:	66 89 50 08          	mov    %dx,0x8(%eax)
  2016a3:	0f b7 d2             	movzwl %dx,%edx
{
    Pd::kern.Space_mem::insert (Pd::kern.quota, reg_base, 0, Hpt::HPT_NX | Hpt::HPT_G | Hpt::HPT_UC | Hpt::HPT_W | Hpt::HPT_P, cfg_base + (rid << PAGE_BITS));
  2016a6:	c1 e2 0c             	shl    $0xc,%edx
  2016a9:	03 15 c4 b0 01 c0    	add    0xc001b0c4,%edx

struct Pci::quirk_map Pci::map[] INITDATA =
{
};

Pci::Pci (unsigned r, unsigned l) : List<Pci> (list), reg_base (hwdev_addr -= PAGE_SIZE), rid (static_cast<uint16>(r)), lev (static_cast<uint16>(l))
  2016af:	8d 9e 00 f0 ff ff    	lea    -0x1000(%esi),%ebx
  2016b5:	89 58 04             	mov    %ebx,0x4(%eax)
  2016b8:	66 89 48 0a          	mov    %cx,0xa(%eax)
  2016bc:	89 d9                	mov    %ebx,%ecx
  2016be:	b8 14 b4 01 c0       	mov    $0xc001b414,%eax
  2016c3:	6a 00                	push   $0x0
  2016c5:	68 13 01 00 00       	push   $0x113
  2016ca:	52                   	push   %edx
  2016cb:	ba 50 b4 01 c0       	mov    $0xc001b450,%edx
  2016d0:	6a 00                	push   $0x0
  2016d2:	89 1d 58 a2 01 c0    	mov    %ebx,0xc001a258
  2016d8:	e8 e3 c9 e0 bf       	call   c000e0c0 <_ZN3PteI3HptmLj2ELj10ELb0EE6updateER5QuotammmmNS1_4TypeE>
  2016dd:	83 c4 10             	add    $0x10,%esp
    Pd::kern.Space_mem::insert (Pd::kern.quota, reg_base, 0, Hpt::HPT_NX | Hpt::HPT_G | Hpt::HPT_UC | Hpt::HPT_W | Hpt::HPT_P, cfg_base + (rid << PAGE_BITS));

    for (unsigned i = 0; i < sizeof map / sizeof *map; i++)
        if (read<uint16>(REG_VID) == map[i].vid && read<uint16>(REG_DID) == map[i].did)
            (this->*map[i].func)();
}
  2016e0:	5b                   	pop    %ebx
  2016e1:	5e                   	pop    %esi
  2016e2:	c3                   	ret    
  2016e3:	90                   	nop

002016e4 <_ZN3Pci4initEjj>:

void Pci::init (unsigned b, unsigned l)
{
  2016e4:	55                   	push   %ebp
  2016e5:	57                   	push   %edi
  2016e6:	56                   	push   %esi
  2016e7:	89 d6                	mov    %edx,%esi
  2016e9:	53                   	push   %ebx
    for (unsigned r = b << 8; r < (b + 1) << 8; r++) {
  2016ea:	89 c3                	mov    %eax,%ebx
  2016ec:	40                   	inc    %eax
        if (read<uint16>(REG_VID) == map[i].vid && read<uint16>(REG_DID) == map[i].did)
            (this->*map[i].func)();
}

void Pci::init (unsigned b, unsigned l)
{
  2016ed:	83 ec 08             	sub    $0x8,%esp
    for (unsigned r = b << 8; r < (b + 1) << 8; r++) {
  2016f0:	c1 e0 08             	shl    $0x8,%eax
  2016f3:	c1 e3 08             	shl    $0x8,%ebx
  2016f6:	89 04 24             	mov    %eax,(%esp)
        Pci *p = new (Pd::kern.quota) Pci (r, l);

        unsigned h = p->read<uint8>(REG_HDR);

        if ((h & 0x7f) == 1)
            init (p->read<uint8>(REG_SBUSN), l + 1);
  2016f9:	8d 6a 01             	lea    0x1(%edx),%ebp
            (this->*map[i].func)();
}

void Pci::init (unsigned b, unsigned l)
{
    for (unsigned r = b << 8; r < (b + 1) << 8; r++) {
  2016fc:	3b 1c 24             	cmp    (%esp),%ebx
  2016ff:	73 66                	jae    201767 <_ZN3Pci4initEjj+0x83>

        if (*static_cast<uint32 *>(Hpt::remap (Pd::kern.quota, cfg_base + (r << PAGE_BITS))) == ~0U)
  201701:	89 da                	mov    %ebx,%edx
  201703:	b8 50 b4 01 c0       	mov    $0xc001b450,%eax
  201708:	c1 e2 0c             	shl    $0xc,%edx
  20170b:	03 15 c4 b0 01 c0    	add    0xc001b0c4,%edx
  201711:	e8 d8 44 e0 bf       	call   c0005bee <_ZN3Hpt5remapER5Quotam>
  201716:	83 38 ff             	cmpl   $0xffffffff,(%eax)
  201719:	74 49                	je     201764 <_ZN3Pci4initEjj+0x80>
    public:
        INIT
        Pci (unsigned, unsigned);

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
  20171b:	ba 50 b4 01 c0       	mov    $0xc001b450,%edx
  201720:	b8 cc b0 01 c0       	mov    $0xc001b0cc,%eax
  201725:	e8 4c eb e0 bf       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
            continue;

        Pci *p = new (Pd::kern.quota) Pci (r, l);
  20172a:	89 f1                	mov    %esi,%ecx
  20172c:	89 da                	mov    %ebx,%edx
  20172e:	89 c7                	mov    %eax,%edi
  201730:	e8 45 ff ff ff       	call   20167a <_ZN3PciC1Ejj>
  201735:	8b 47 04             	mov    0x4(%edi),%eax
            REG_MAX         = 0xfff,
        };

        template <typename T>
        ALWAYS_INLINE
        inline unsigned read (Register r) { return *reinterpret_cast<T volatile *>(reg_base + r); }
  201738:	8a 48 0e             	mov    0xe(%eax),%cl

        unsigned h = p->read<uint8>(REG_HDR);

        if ((h & 0x7f) == 1)
  20173b:	88 ca                	mov    %cl,%dl
  20173d:	80 e2 7f             	and    $0x7f,%dl
  201740:	fe ca                	dec    %dl
  201742:	75 13                	jne    201757 <_ZN3Pci4initEjj+0x73>
  201744:	0f b6 40 19          	movzbl 0x19(%eax),%eax
            init (p->read<uint8>(REG_SBUSN), l + 1);
  201748:	89 ea                	mov    %ebp,%edx
  20174a:	88 4c 24 07          	mov    %cl,0x7(%esp)
  20174e:	e8 91 ff ff ff       	call   2016e4 <_ZN3Pci4initEjj>
  201753:	8a 4c 24 07          	mov    0x7(%esp),%cl

        if (!(r & 0x7) && !(h & 0x80))
  201757:	f6 c3 07             	test   $0x7,%bl
  20175a:	75 08                	jne    201764 <_ZN3Pci4initEjj+0x80>
            r += 7;
  20175c:	8d 43 07             	lea    0x7(%ebx),%eax
  20175f:	84 c9                	test   %cl,%cl
  201761:	0f 49 d8             	cmovns %eax,%ebx
            (this->*map[i].func)();
}

void Pci::init (unsigned b, unsigned l)
{
    for (unsigned r = b << 8; r < (b + 1) << 8; r++) {
  201764:	43                   	inc    %ebx
  201765:	eb 95                	jmp    2016fc <_ZN3Pci4initEjj+0x18>
            init (p->read<uint8>(REG_SBUSN), l + 1);

        if (!(r & 0x7) && !(h & 0x80))
            r += 7;
    }
}
  201767:	83 c4 08             	add    $0x8,%esp
  20176a:	5b                   	pop    %ebx
  20176b:	5e                   	pop    %esi
  20176c:	5f                   	pop    %edi
  20176d:	5d                   	pop    %ebp
  20176e:	c3                   	ret    
  20176f:	90                   	nop

00201770 <_ZN2PdC1EPS_>:

INIT_PRIORITY (PRIO_BUDDY)
ALIGNED(32) Pd Pd::kern (&Pd::kern);
ALIGNED(32) Pd Pd::root (&Pd::root, NUM_EXC, 0x1f);

Pd::Pd (Pd *own) : Kobject (PD, static_cast<Space_obj *>(own))
  201770:	57                   	push   %edi
  201771:	85 d2                	test   %edx,%edx
  201773:	56                   	push   %esi
  201774:	89 d6                	mov    %edx,%esi
  201776:	53                   	push   %ebx
  201777:	89 c3                	mov    %eax,%ebx
            PT,
            SM,
            INVALID,
        };

        explicit Kobject (Type t, Space *s, mword b = 0, mword a = 0, void (*f)(Rcu_elem *) = free, void (*pref)(Rcu_elem *) = nullptr ) : Mdb (s, reinterpret_cast<mword>(this), b, a, f, pref), objtype (t) {}
  201779:	6a 00                	push   $0x0
  20177b:	89 d9                	mov    %ebx,%ecx
  20177d:	68 f2 28 00 c0       	push   $0xc00028f2
  201782:	8d 82 88 01 00 00    	lea    0x188(%edx),%eax
  201788:	ba 00 00 00 00       	mov    $0x0,%edx
  20178d:	6a 00                	push   $0x0
  20178f:	0f 45 d0             	cmovne %eax,%edx
  201792:	6a 00                	push   $0x0
  201794:	89 d8                	mov    %ebx,%eax
  201796:	e8 ab 14 e0 bf       	call   c0002c46 <_ZN3MdbC1EP5SpacemmmPFvP8Rcu_elemES5_>
            bool res = !Atomic::test_set_bit (did_c[0], NO_PCID);
            assert (res);
        }

        ALWAYS_INLINE
        inline Space_mem() : cpus(0), htlb(~0UL), gtlb(~0UL)
  20179b:	8d 53 54             	lea    0x54(%ebx),%edx
  20179e:	83 c4 10             	add    $0x10,%esp
  2017a1:	c6 43 44 00          	movb   $0x0,0x44(%ebx)
  2017a5:	31 c0                	xor    %eax,%eax
  2017a7:	66 c7 43 46 00 00    	movw   $0x0,0x46(%ebx)
    private:
        uint32 ref;

    public:
        ALWAYS_INLINE
        inline Refex() : ref (1) {}
  2017ad:	c7 43 48 01 00 00 00 	movl   $0x1,0x48(%ebx)
  2017b4:	66 c7 43 4c 00 00    	movw   $0x0,0x4c(%ebx)
    private:
        Spinlock    lock;
        Avl *       tree;

    public:
        Space() : tree (nullptr) {}
  2017ba:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
  2017c1:	c7 04 02 00 00 00 00 	movl   $0x0,(%edx,%eax,1)
  2017c8:	83 c0 04             	add    $0x4,%eax
  2017cb:	3d 00 01 00 00       	cmp    $0x100,%eax
  2017d0:	75 ef                	jne    2017c1 <_ZN2PdC1EPS_+0x51>
        {
            for (mword i = ACCESS_ONCE(did_f), j = 0; j <= LAST_PCID; i++, j++)
  2017d2:	a1 cc b4 01 c0       	mov    0xc001b4cc,%eax
  2017d7:	31 ff                	xor    %edi,%edi
  2017d9:	c7 83 54 01 00 00 00 	movl   $0x0,0x154(%ebx)
  2017e0:	00 00 00 
  2017e3:	c7 83 58 01 00 00 00 	movl   $0x0,0x158(%ebx)
  2017ea:	00 00 00 
  2017ed:	c7 83 5c 01 00 00 00 	movl   $0x0,0x15c(%ebx)
  2017f4:	00 00 00 
    private:
        mword val;

    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}
  2017f7:	c7 83 6c 01 00 00 00 	movl   $0x0,0x16c(%ebx)
  2017fe:	00 00 00 
  201801:	c7 83 70 01 00 00 ff 	movl   $0xffffffff,0x170(%ebx)
  201808:	ff ff ff 
  20180b:	c7 83 74 01 00 00 ff 	movl   $0xffffffff,0x174(%ebx)
  201812:	ff ff ff 
            {
                i %= (LAST_PCID + 1);
  201815:	83 e0 7f             	and    $0x7f,%eax

                if (ACCESS_ONCE(did_c[i]) == ~0UL)
  201818:	8b 14 85 e0 b4 01 c0 	mov    -0x3ffe4b20(,%eax,4),%edx
  20181f:	42                   	inc    %edx
  201820:	74 56                	je     201878 <_ZN2PdC1EPS_+0x108>
}

ALWAYS_INLINE
inline long int bit_scan_forward (mword val)
{
    if (EXPECT_FALSE (!val))
  201822:	8b 0c 85 e0 b4 01 c0 	mov    -0x3ffe4b20(,%eax,4),%ecx
                    continue;

                long b = bit_scan_forward (~did_c[i]);
                if (b == -1) b = 0;
  201829:	31 d2                	xor    %edx,%edx
  20182b:	83 f1 ff             	xor    $0xffffffff,%ecx
  20182e:	74 0e                	je     20183e <_ZN2PdC1EPS_+0xce>
        return -1;

    asm volatile ("bsf %1, %0" : "=r" (val) : "rm" (val));
  201830:	0f bc d1             	bsf    %ecx,%edx
  201833:	b9 00 00 00 00       	mov    $0x0,%ecx
  201838:	83 fa ff             	cmp    $0xffffffff,%edx
  20183b:	0f 44 d1             	cmove  %ecx,%edx
        template <typename T>
        ALWAYS_INLINE
        static inline bool test_set_bit (T &val, unsigned long bit)
        {
            bool ret;
            asm volatile ("lock; bts%z1 %2, %1; setc %0" : "=q" (ret), "+m" (val) : "ir" (bit) : "cc");
  20183e:	f0 0f ab 14 85 e0 b4 	lock bts %edx,-0x3ffe4b20(,%eax,4)
  201845:	01 c0 
  201847:	0f 92 c1             	setb   %cl

                if (Atomic::test_set_bit (did_c[i], b)) {
  20184a:	84 c9                	test   %cl,%cl
  20184c:	74 04                	je     201852 <_ZN2PdC1EPS_+0xe2>
                    j--;
  20184e:	4f                   	dec    %edi
                    i--;
  20184f:	48                   	dec    %eax
  201850:	eb 26                	jmp    201878 <_ZN2PdC1EPS_+0x108>
                    continue;
                }

                did = i * sizeof(did_c[0]) * 8 + b;
  201852:	89 c1                	mov    %eax,%ecx
  201854:	c1 e1 05             	shl    $0x5,%ecx
  201857:	01 ca                	add    %ecx,%edx
  201859:	89 93 68 01 00 00    	mov    %edx,0x168(%ebx)

                if (did_c[i] != ~0UL && did_f != i)
  20185f:	83 3c 85 e0 b4 01 c0 	cmpl   $0xffffffff,-0x3ffe4b20(,%eax,4)
  201866:	ff 
  201867:	74 20                	je     201889 <_ZN2PdC1EPS_+0x119>
  201869:	39 05 cc b4 01 c0    	cmp    %eax,0xc001b4cc
  20186f:	74 18                	je     201889 <_ZN2PdC1EPS_+0x119>
                    did_f = i;
  201871:	a3 cc b4 01 c0       	mov    %eax,0xc001b4cc
  201876:	eb 11                	jmp    201889 <_ZN2PdC1EPS_+0x119>
        }

        ALWAYS_INLINE
        inline Space_mem() : cpus(0), htlb(~0UL), gtlb(~0UL)
        {
            for (mword i = ACCESS_ONCE(did_f), j = 0; j <= LAST_PCID; i++, j++)
  201878:	47                   	inc    %edi
  201879:	40                   	inc    %eax
  20187a:	83 ff 7f             	cmp    $0x7f,%edi
  20187d:	76 96                	jbe    201815 <_ZN2PdC1EPS_+0xa5>
                    did_f = i;

                return;
            }

            did = NO_PCID;
  20187f:	c7 83 68 01 00 00 02 	movl   $0x2,0x168(%ebx)
  201886:	00 00 00 
  201889:	8d 83 90 01 00 00    	lea    0x190(%ebx),%eax
{
    hpt = Hptp (reinterpret_cast<mword>(&PDBR));

    Mtrr::init();

    Space_mem::insert_root (own->quota, 0, reinterpret_cast<mword>(&LINK_P));
  20188f:	81 c6 90 01 00 00    	add    $0x190,%esi
  201895:	66 c7 83 78 01 00 00 	movw   $0x0,0x178(%ebx)
  20189c:	00 00 
  20189e:	8d 7b 4c             	lea    0x4c(%ebx),%edi
  2018a1:	c7 83 7c 01 00 00 00 	movl   $0x0,0x17c(%ebx)
  2018a8:	00 00 00 

        void update (Quota &quota, bool, mword, mword);

    public:

        Space_pio() : hbmp(0), gbmp(0) {}
  2018ab:	c7 83 80 01 00 00 00 	movl   $0x0,0x180(%ebx)
  2018b2:	00 00 00 
  2018b5:	c7 83 84 01 00 00 00 	movl   $0x0,0x184(%ebx)
  2018bc:	00 00 00 
  2018bf:	66 c7 83 88 01 00 00 	movw   $0x0,0x188(%ebx)
  2018c6:	00 00 
  2018c8:	c7 83 8c 01 00 00 00 	movl   $0x0,0x18c(%ebx)
  2018cf:	00 00 00 

INIT_PRIORITY (PRIO_BUDDY)
ALIGNED(32) Pd Pd::kern (&Pd::kern);
ALIGNED(32) Pd Pd::root (&Pd::root, NUM_EXC, 0x1f);

Pd::Pd (Pd *own) : Kobject (PD, static_cast<Space_obj *>(own))
  2018d2:	e8 9f a1 e0 bf       	call   c000ba76 <_ZN5QuotaC1Ev>
{
    hpt = Hptp (reinterpret_cast<mword>(&PDBR));
  2018d7:	c7 83 54 01 00 00 00 	movl   $0x41f000,0x154(%ebx)
  2018de:	f0 41 00 

    Mtrr::init();
  2018e1:	e8 d6 fa ff ff       	call   2013bc <_ZN4Mtrr4initEv>

    Space_mem::insert_root (own->quota, 0, reinterpret_cast<mword>(&LINK_P));
  2018e6:	31 d2                	xor    %edx,%edx
  2018e8:	b8 00 00 40 00       	mov    $0x400000,%eax
  2018ed:	6a 07                	push   $0x7
  2018ef:	52                   	push   %edx
  2018f0:	89 f2                	mov    %esi,%edx
  2018f2:	50                   	push   %eax
  2018f3:	89 f8                	mov    %edi,%eax
  2018f5:	6a 00                	push   $0x0
  2018f7:	6a 00                	push   $0x0
  2018f9:	e8 5a 00 00 00       	call   201958 <_ZN9Space_mem11insert_rootER5Quotayym>
    Space_mem::insert_root (own->quota, reinterpret_cast<mword>(&LINK_E), 1ULL << 52);
  2018fe:	31 d2                	xor    %edx,%edx
  201900:	b8 00 00 80 02       	mov    $0x2800000,%eax
  201905:	6a 07                	push   $0x7
  201907:	68 00 00 10 00       	push   $0x100000
  20190c:	6a 00                	push   $0x0
  20190e:	52                   	push   %edx
  20190f:	89 f2                	mov    %esi,%edx
  201911:	50                   	push   %eax
  201912:	89 f8                	mov    %edi,%eax
  201914:	e8 3f 00 00 00       	call   201958 <_ZN9Space_mem11insert_rootER5Quotayym>

    // HIP
    Space_mem::insert_root (own->quota, reinterpret_cast<mword>(&FRAME_H), reinterpret_cast<mword>(&FRAME_H) + PAGE_SIZE, 1);
  201919:	83 c4 28             	add    $0x28,%esp
  20191c:	31 d2                	xor    %edx,%edx
  20191e:	6a 01                	push   $0x1
  201920:	b8 00 f0 41 00       	mov    $0x41f000,%eax
  201925:	52                   	push   %edx
  201926:	31 d2                	xor    %edx,%edx
  201928:	50                   	push   %eax
  201929:	b8 00 e0 41 00       	mov    $0x41e000,%eax
  20192e:	52                   	push   %edx
  20192f:	89 f2                	mov    %esi,%edx
  201931:	50                   	push   %eax
  201932:	89 f8                	mov    %edi,%eax
  201934:	e8 1f 00 00 00       	call   201958 <_ZN9Space_mem11insert_rootER5Quotayym>

    // I/O Ports
    Space_pio::addreg (own->quota, 0, 1UL << 16, 7);
  201939:	8d 83 78 01 00 00    	lea    0x178(%ebx),%eax
  20193f:	89 f2                	mov    %esi,%edx
  201941:	6a 00                	push   $0x0
  201943:	31 c9                	xor    %ecx,%ecx
  201945:	6a 07                	push   $0x7
  201947:	68 00 00 01 00       	push   $0x10000
  20194c:	e8 b7 09 e0 bf       	call   c0002308 <_ZN5Space6addregER5Quotamjmm>
  201951:	83 c4 20             	add    $0x20,%esp
}
  201954:	5b                   	pop    %ebx
  201955:	5e                   	pop    %esi
  201956:	5f                   	pop    %edi
  201957:	c3                   	ret    

00201958 <_ZN9Space_mem11insert_rootER5Quotayym>:
            asm volatile ("cli" : : : "memory");
    }
}

void Space_mem::insert_root (Quota &quota, uint64 s, uint64 e, mword a)
{
  201958:	55                   	push   %ebp
  201959:	57                   	push   %edi
  20195a:	56                   	push   %esi
  20195b:	53                   	push   %ebx
  20195c:	83 ec 20             	sub    $0x20,%esp
  20195f:	89 44 24 08          	mov    %eax,0x8(%esp)
  201963:	8b 74 24 34          	mov    0x34(%esp),%esi
  201967:	8b 7c 24 38          	mov    0x38(%esp),%edi
  20196b:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  20196f:	8b 6c 24 40          	mov    0x40(%esp),%ebp
  201973:	89 54 24 0c          	mov    %edx,0xc(%esp)
    for (uint64 p = s; p < e; s = p) {
  201977:	89 74 24 10          	mov    %esi,0x10(%esp)
            asm volatile ("cli" : : : "memory");
    }
}

void Space_mem::insert_root (Quota &quota, uint64 s, uint64 e, mword a)
{
  20197b:	89 04 24             	mov    %eax,(%esp)
    for (uint64 p = s; p < e; s = p) {
  20197e:	89 7c 24 14          	mov    %edi,0x14(%esp)
  201982:	39 6c 24 14          	cmp    %ebp,0x14(%esp)
  201986:	0f 83 c0 00 00 00    	jae    201a4c <_ZN9Space_mem11insert_rootER5Quotayym+0xf4>

        unsigned t = Mtrr::memtype (s, p);
  20198c:	8d 4c 24 10          	lea    0x10(%esp),%ecx
  201990:	89 f0                	mov    %esi,%eax
  201992:	89 fa                	mov    %edi,%edx
  201994:	e8 ab fa ff ff       	call   201444 <_ZN4Mtrr7memtypeEyRy>
  201999:	89 44 24 04          	mov    %eax,0x4(%esp)

        for (uint64 n; p < e; p = n)
  20199d:	8b 54 24 14          	mov    0x14(%esp),%edx
  2019a1:	8b 44 24 10          	mov    0x10(%esp),%eax
  2019a5:	39 ea                	cmp    %ebp,%edx
  2019a7:	73 2b                	jae    2019d4 <_ZN9Space_mem11insert_rootER5Quotayym+0x7c>
            if (Mtrr::memtype (p, n) != t)
  2019a9:	8d 4c 24 18          	lea    0x18(%esp),%ecx
  2019ad:	e8 92 fa ff ff       	call   201444 <_ZN4Mtrr7memtypeEyRy>
  2019b2:	3b 44 24 04          	cmp    0x4(%esp),%eax
  2019b6:	74 0a                	je     2019c2 <_ZN9Space_mem11insert_rootER5Quotayym+0x6a>
                break;

        if (s > ~0UL)
  2019b8:	83 ff 00             	cmp    $0x0,%edi
  2019bb:	76 20                	jbe    2019dd <_ZN9Space_mem11insert_rootER5Quotayym+0x85>
  2019bd:	e9 99 00 00 00       	jmp    201a5b <_ZN9Space_mem11insert_rootER5Quotayym+0x103>
{
    for (uint64 p = s; p < e; s = p) {

        unsigned t = Mtrr::memtype (s, p);

        for (uint64 n; p < e; p = n)
  2019c2:	8b 44 24 18          	mov    0x18(%esp),%eax
  2019c6:	8b 54 24 1c          	mov    0x1c(%esp),%edx
  2019ca:	89 44 24 10          	mov    %eax,0x10(%esp)
  2019ce:	89 54 24 14          	mov    %edx,0x14(%esp)
  2019d2:	eb c9                	jmp    20199d <_ZN9Space_mem11insert_rootER5Quotayym+0x45>
  2019d4:	77 e2                	ja     2019b8 <_ZN9Space_mem11insert_rootER5Quotayym+0x60>
  2019d6:	3b 04 24             	cmp    (%esp),%eax
  2019d9:	72 ce                	jb     2019a9 <_ZN9Space_mem11insert_rootER5Quotayym+0x51>
  2019db:	eb db                	jmp    2019b8 <_ZN9Space_mem11insert_rootER5Quotayym+0x60>
  2019dd:	8b 4c 24 14          	mov    0x14(%esp),%ecx
  2019e1:	89 ea                	mov    %ebp,%edx
  2019e3:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  2019e7:	8b 04 24             	mov    (%esp),%eax
  2019ea:	39 cd                	cmp    %ecx,%ebp
  2019ec:	72 0a                	jb     2019f8 <_ZN9Space_mem11insert_rootER5Quotayym+0xa0>
  2019ee:	77 04                	ja     2019f4 <_ZN9Space_mem11insert_rootER5Quotayym+0x9c>
  2019f0:	39 d8                	cmp    %ebx,%eax
  2019f2:	76 04                	jbe    2019f8 <_ZN9Space_mem11insert_rootER5Quotayym+0xa0>
  2019f4:	89 d8                	mov    %ebx,%eax
  2019f6:	89 ca                	mov    %ecx,%edx
                break;

        if (s > ~0UL)
            break;

        if ((p = min (p, e)) > ~0UL)
  2019f8:	83 fa 00             	cmp    $0x0,%edx
  2019fb:	77 0a                	ja     201a07 <_ZN9Space_mem11insert_rootER5Quotayym+0xaf>
  2019fd:	89 44 24 10          	mov    %eax,0x10(%esp)
  201a01:	89 54 24 14          	mov    %edx,0x14(%esp)
  201a05:	eb 10                	jmp    201a17 <_ZN9Space_mem11insert_rootER5Quotayym+0xbf>
            p = static_cast<uint64>(~0UL) + 1;
  201a07:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  201a0e:	00 
  201a0f:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  201a16:	00 

        addreg (quota, static_cast<mword>(s >> PAGE_BITS), static_cast<mword>(p - s) >> PAGE_BITS, a, t);
  201a17:	ff 74 24 04          	pushl  0x4(%esp)
  201a1b:	89 f1                	mov    %esi,%ecx
  201a1d:	0f ac f9 0c          	shrd   $0xc,%edi,%ecx
  201a21:	ff 74 24 48          	pushl  0x48(%esp)
  201a25:	8b 44 24 18          	mov    0x18(%esp),%eax
  201a29:	29 f0                	sub    %esi,%eax
  201a2b:	c1 e8 0c             	shr    $0xc,%eax
  201a2e:	50                   	push   %eax
  201a2f:	8b 54 24 18          	mov    0x18(%esp),%edx
  201a33:	8b 44 24 14          	mov    0x14(%esp),%eax
  201a37:	e8 cc 08 e0 bf       	call   c0002308 <_ZN5Space6addregER5Quotamjmm>
    }
}

void Space_mem::insert_root (Quota &quota, uint64 s, uint64 e, mword a)
{
    for (uint64 p = s; p < e; s = p) {
  201a3c:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  201a40:	8b 7c 24 20          	mov    0x20(%esp),%edi
  201a44:	83 c4 0c             	add    $0xc,%esp
  201a47:	e9 36 ff ff ff       	jmp    201982 <_ZN9Space_mem11insert_rootER5Quotayym+0x2a>
  201a4c:	77 0d                	ja     201a5b <_ZN9Space_mem11insert_rootER5Quotayym+0x103>
  201a4e:	8b 04 24             	mov    (%esp),%eax
  201a51:	39 44 24 10          	cmp    %eax,0x10(%esp)
  201a55:	0f 82 31 ff ff ff    	jb     20198c <_ZN9Space_mem11insert_rootER5Quotayym+0x34>
        if ((p = min (p, e)) > ~0UL)
            p = static_cast<uint64>(~0UL) + 1;

        addreg (quota, static_cast<mword>(s >> PAGE_BITS), static_cast<mword>(p - s) >> PAGE_BITS, a, t);
    }
}
  201a5b:	83 c4 20             	add    $0x20,%esp
  201a5e:	5b                   	pop    %ebx
  201a5f:	5e                   	pop    %esi
  201a60:	5f                   	pop    %edi
  201a61:	5d                   	pop    %ebp
  201a62:	c3                   	ret    
  201a63:	90                   	nop
  201a64:	90                   	nop
  201a65:	90                   	nop
  201a66:	90                   	nop
  201a67:	90                   	nop

00201a68 <__boot_header>:
  201a68:	02 b0 ad 1b 00 00    	add    0x1bad(%eax),%dh
  201a6e:	00 00                	add    %al,(%eax)
  201a70:	fe 4f 52             	decb   0x52(%edi)
  201a73:	e4 8d                	in     $0x8d,%al
  201a75:	74 26                	je     201a9d <__boot_gdt+0x25>
	...

00201a78 <__boot_gdt>:
  201a78:	00 00                	add    %al,(%eax)
  201a7a:	27                   	daa    
  201a7b:	00 78 1a             	add    %bh,0x1a(%eax)
  201a7e:	20 00                	and    %al,(%eax)
  201a80:	ff                   	(bad)  
  201a81:	ff 00                	incl   (%eax)
  201a83:	00 00                	add    %al,(%eax)
  201a85:	9b                   	fwait
  201a86:	cf                   	iret   
  201a87:	00 ff                	add    %bh,%bh
  201a89:	ff 00                	incl   (%eax)
  201a8b:	00 00                	add    %al,(%eax)
  201a8d:	93                   	xchg   %eax,%ebx
  201a8e:	cf                   	iret   
  201a8f:	00 ff                	add    %bh,%bh
  201a91:	ff 00                	incl   (%eax)
  201a93:	00 00                	add    %al,(%eax)
  201a95:	fb                   	sti    
  201a96:	cf                   	iret   
  201a97:	00 ff                	add    %bh,%bh
  201a99:	ff 00                	incl   (%eax)
  201a9b:	00 00                	add    %al,(%eax)
  201a9d:	f3 cf                	repz iret 
	...

00201aa0 <__boot_gdt__>:
/*
 * AP Startup Code
 */
.code16

__start_ap:             INIT_PAGING
  201aa0:	66 ba 98 06          	mov    $0x698,%dx
  201aa4:	00 00                	add    %al,(%eax)
  201aa6:	0f 22 e2             	mov    %edx,%cr4
  201aa9:	66 ba 00 f0          	mov    $0xf000,%dx
  201aad:	41                   	inc    %ecx
  201aae:	00 0f                	add    %cl,(%edi)
  201ab0:	22 da                	and    %dl,%bl
  201ab2:	66 ba 2b 00          	mov    $0x2b,%dx
  201ab6:	01 80 0f 22 c2 2e    	add    %eax,0x2ec2220f(%eax)
                        lgdtl   %cs:__gdt_desc - __start_ap
  201abc:	66 0f 01 16          	lgdtw  (%esi)
  201ac0:	2a 00                	sub    (%eax),%al
                        ljmpl   $SEL_KERN_CODE, $__start_all
  201ac2:	66 ea 41 1b 20 00    	ljmpw  $0x20,$0x1b41
  201ac8:	08 00                	or     %al,(%eax)

00201aca <__gdt_desc>:
  201aca:	27                   	daa    
  201acb:	00 78 1a             	add    %bh,0x1a(%eax)
  201ace:	20 00                	and    %al,(%eax)

00201ad0 <__start_bsp>:
/*
 * BSP Startup Code
 */
.code32

__start_bsp:            mov     $(__start_bsp - __start_ap), %ecx
  201ad0:	b9 30 00 00 00       	mov    $0x30,%ecx
                        mov     $__start_ap, %esi
  201ad5:	be a0 1a 20 00       	mov    $0x201aa0,%esi
                        mov     $0x1000, %edi
  201ada:	bf 00 10 00 00       	mov    $0x1000,%edi
                        rep     movsb
  201adf:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
                        mov     $(LVL3H + 0x27), %ecx
                        mov     %ecx, LVL4  + SIZE * (LINK_ADDR >> (3 * PTE_BPL + PAGE_BITS) & ((1 << PTE_BPL) - 1))
                        mov     $(LVL2H + 0x27), %ecx
                        mov     %ecx, LVL3H + SIZE * (LINK_ADDR >> (2 * PTE_BPL + PAGE_BITS) & ((1 << PTE_BPL) - 1))
#endif
                        mov     $0xe3, %ecx
  201ae1:	b9 e3 00 00 00       	mov    $0xe3,%ecx
                        mov     $LVL2L, %edi
  201ae6:	bf 00 f0 41 00       	mov    $0x41f000,%edi
1:                      mov     %ecx, (%edi)
  201aeb:	89 0f                	mov    %ecx,(%edi)
                        add     $(1 << (PTE_BPL + PAGE_BITS)), %ecx
  201aed:	81 c1 00 00 40 00    	add    $0x400000,%ecx
                        add     $SIZE, %edi
  201af3:	83 c7 04             	add    $0x4,%edi
                        cmp     $LOAD_E, %ecx
  201af6:	81 f9 00 30 20 00    	cmp    $0x203000,%ecx
                        jb      1b
  201afc:	72 ed                	jb     201aeb <__start_bsp+0x1b>

                        mov     $(LINK_P + 0x1e3), %ecx
  201afe:	b9 e3 01 40 00       	mov    $0x4001e3,%ecx
                        mov     $(LVL2H + SIZE * (LINK_ADDR >> (PTE_BPL + PAGE_BITS) & ((1 << PTE_BPL) - 1))), %edi
  201b03:	bf 00 fc 41 00       	mov    $0x41fc00,%edi
1:                      mov     %ecx, (%edi)
  201b08:	89 0f                	mov    %ecx,(%edi)
                        add     $(1 << (PTE_BPL + PAGE_BITS)), %ecx
  201b0a:	81 c1 00 00 40 00    	add    $0x400000,%ecx
                        add     $SIZE, %edi
  201b10:	83 c7 04             	add    $0x4,%edi
                        cmp     $LINK_E, %ecx
  201b13:	81 f9 00 00 80 02    	cmp    $0x2800000,%ecx
                        jb      1b
  201b19:	72 ed                	jb     201b08 <__start_bsp+0x38>

                        INIT_PAGING
  201b1b:	ba 98 06 00 00       	mov    $0x698,%edx
  201b20:	0f 22 e2             	mov    %edx,%cr4
  201b23:	ba 00 f0 41 00       	mov    $0x41f000,%edx
  201b28:	0f 22 da             	mov    %edx,%cr3
  201b2b:	ba 2b 00 01 80       	mov    $0x8001002b,%edx
  201b30:	0f 22 c2             	mov    %edx,%cr0
                        lgdt    __boot_gdt + 2
  201b33:	0f 01 15 7a 1a 20 00 	lgdtl  0x201a7a
                        ljmp    $SEL_KERN_CODE, $__start_all
  201b3a:	ea 41 1b 20 00 08 00 	ljmp   $0x8,$0x201b41

00201b41 <__start_all>:
 */
#ifdef __x86_64__
.code64
#endif

__start_all:            INIT_STATE
  201b41:	b9 10 00 00 00       	mov    $0x10,%ecx
  201b46:	8e d1                	mov    %ecx,%ss
  201b48:	b9 23 00 00 00       	mov    $0x23,%ecx
  201b4d:	8e d9                	mov    %ecx,%ds
  201b4f:	8e c1                	mov    %ecx,%es
  201b51:	8e e1                	mov    %ecx,%fs
  201b53:	8e e9                	mov    %ecx,%gs
  201b55:	bc 00 30 20 00       	mov    $0x203000,%esp
                        test    %REG(bx), %REG(bx)
  201b5a:	85 db                	test   %ebx,%ebx
                        je      2f
  201b5c:	74 0b                	je     201b69 <__start_all+0x28>

                        mov     %REG(bx), %ARG_1
  201b5e:	89 d8                	mov    %ebx,%eax
                        call    init
  201b60:	e8 04 f7 ff ff       	call   201269 <init>
                        jmp     3f
  201b65:	eb 0c                	jmp    201b73 <__start_all+0x32>

1:                      pause
  201b67:	f3 90                	pause  
2:                      xchg    %REG(bx), boot_lock
  201b69:	87 1d 44 a4 01 c0    	xchg   %ebx,0xc001a444
                        test    %REG(bx), %REG(bx)
  201b6f:	85 db                	test   %ebx,%ebx
                        je      1b
  201b71:	74 f4                	je     201b67 <__start_all+0x26>

3:                      call    kern_ptab_setup
  201b73:	e8 57 f6 ff ff       	call   2011cf <kern_ptab_setup>
                        jmp     1f
  201b78:	e9 4b f8 e0 bf       	jmp    c00113c8 <_ZN9Space_pio10page_faultEmm+0x76>
  201b7d:	90                   	nop
  201b7e:	90                   	nop
  201b7f:	90                   	nop

00201b80 <_ZN15Acpi_table_rsdt3mapE>:
  201b80:	41 50 49 43 40 a3 01 c0 44 4d 41 52 4c a3 01 c0     APIC@...DMARL...
  201b90:	46 41 43 50 48 a3 01 c0 48 50 45 54 44 a3 01 c0     FACPH...HPETD...
  201ba0:	4d 43 46 47 3c a3 01 c0 90 90 90 90 90 90 90 90     MCFG<...........
  201bb0:	90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90     ................

00201bc0 <_ZN7Cmdline3mapE>:
  201bc0:	3c 65 01 c0 8c a3 01 c0 42 65 01 c0 8b a3 01 c0     <e......Be......
  201bd0:	47 65 01 c0 8a a3 01 c0 4e 65 01 c0 89 a3 01 c0     Ge......Ne......
  201be0:	56 65 01 c0 88 a3 01 c0 5b 65 01 c0 87 a3 01 c0     Ve......[e......
  201bf0:	60 65 01 c0 86 a3 01 c0 67 65 01 c0 85 a3 01 c0     `e......ge......
  201c00:	6d 65 01 c0 84 a3 01 c0                             me......

Disassembly of section .text:

c0000000 <_ZN2Ec16ret_user_sysexitEv>:
        if (current != fpowner)
            Fpu::disable();
}

void Ec::ret_user_sysexit()
{
c0000000:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
    mword hzd = (Cpu::hazard | current->regs.hazard()) & (HZD_RECALL | HZD_STEP | HZD_RCU | HZD_FPU | HZD_DS_ES | HZD_SCHED);
c0000005:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
c000000b:	0b 05 00 f0 ff cf    	or     0xcffff000,%eax
    if (EXPECT_FALSE (hzd))
c0000011:	25 1b 00 00 c0       	and    $0xc000001b,%eax
c0000016:	74 0a                	je     c0000022 <_ZN2Ec16ret_user_sysexitEv+0x22>
        handle_hazard (hzd, ret_user_sysexit);
c0000018:	ba 00 00 00 c0       	mov    $0xc0000000,%edx
c000001d:	e8 24 38 00 00       	call   c0003846 <_ZN2Ec13handle_hazardEmPFvvE>

    asm volatile ("lea %0," EXPAND (PREG(sp); LOAD_GPR RET_USER_HYP) : : "m" (current->regs) : "memory");
c0000022:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0000027:	8d 60 54             	lea    0x54(%eax),%esp
c000002a:	61                   	popa   
c000002b:	fb                   	sti    
c000002c:	0f 35                	sysexit 

c000002e <ret_user_iret>:

    UNREACHED;
}

void Ec::ret_user_iret()
{
c000002e:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
    // No need to check HZD_DS_ES because IRET will reload both anyway
    mword hzd = (Cpu::hazard | current->regs.hazard()) & (HZD_RECALL | HZD_STEP | HZD_RCU | HZD_FPU | HZD_SCHED);
c0000033:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
c0000039:	0b 05 00 f0 ff cf    	or     0xcffff000,%eax
    if (EXPECT_FALSE (hzd))
c000003f:	25 19 00 00 c0       	and    $0xc0000019,%eax
c0000044:	74 0a                	je     c0000050 <ret_user_iret+0x22>
        handle_hazard (hzd, ret_user_iret);
c0000046:	ba 2e 00 00 c0       	mov    $0xc000002e,%edx
c000004b:	e8 f6 37 00 00       	call   c0003846 <_ZN2Ec13handle_hazardEmPFvvE>

    asm volatile ("lea %0," EXPAND (PREG(sp); LOAD_GPR LOAD_SEG RET_USER_EXC) : : "m" (current->regs) : "memory");
c0000050:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0000055:	8d 60 54             	lea    0x54(%eax),%esp
c0000058:	61                   	popa   
c0000059:	0f a9                	pop    %gs
c000005b:	0f a1                	pop    %fs
c000005d:	07                   	pop    %es
c000005e:	1f                   	pop    %ds
c000005f:	83 c4 08             	add    $0x8,%esp
c0000062:	cf                   	iret   
c0000063:	90                   	nop

c0000064 <chk_kern_preempt>:
    UNREACHED;
}

void Ec::chk_kern_preempt()
{
    if (!Cpu::preemption)
c0000064:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000006b:	74 1d                	je     c000008a <chk_kern_preempt+0x26>
        return;

    if (Cpu::hazard & HZD_SCHED) {
c000006d:	f6 05 00 f0 ff cf 01 	testb  $0x1,0xcffff000
c0000074:	74 14                	je     c000008a <chk_kern_preempt+0x26>
        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);

            asm volatile ("cli" : : : "memory");
c0000076:	fa                   	cli    
        Cpu::preempt_disable();
        Sc::schedule();
c0000077:	ba 01 00 00 00       	mov    $0x1,%edx
c000007c:	31 c0                	xor    %eax,%eax
            preemption = false;
c000007e:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
c0000085:	e8 28 f9 00 00       	call   c000f9b2 <_ZN2Sc8scheduleEbb>
c000008a:	c3                   	ret    
c000008b:	90                   	nop

c000008c <_ZN2Ec9recv_kernEv>:
    sys_finish<Sys_regs::COM_TIM>();
}

void Ec::recv_kern()
{
    Ec *ec = current->rcap;
c000008c:	a1 08 f0 ff cf       	mov    0xcffff008,%eax

    sys_finish<Sys_regs::COM_TIM>();
}

void Ec::recv_kern()
{
c0000091:	53                   	push   %ebx
    Ec *ec = current->rcap;
c0000092:	8b 98 b0 00 00 00    	mov    0xb0(%eax),%ebx

    bool fpu = false;

    if (ec->cont == ret_user_iret)
c0000098:	8b 53 50             	mov    0x50(%ebx),%edx
c000009b:	81 fa 2e 00 00 c0    	cmp    $0xc000002e,%edx
c00000a1:	75 10                	jne    c00000b3 <_ZN2Ec9recv_kernEv+0x27>
        fpu = current->utcb->load_exc (&ec->regs);
c00000a3:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
c00000a9:	8d 53 54             	lea    0x54(%ebx),%edx
c00000ac:	e8 a7 45 01 00       	call   c0014658 <_ZN4Utcb8load_excEP8Cpu_regs>
c00000b1:	eb 2e                	jmp    c00000e1 <_ZN2Ec9recv_kernEv+0x55>
    else if (ec->cont == ret_user_vmresume)
c00000b3:	81 fa 2c 3f 00 c0    	cmp    $0xc0003f2c,%edx
c00000b9:	75 10                	jne    c00000cb <_ZN2Ec9recv_kernEv+0x3f>
        fpu = current->utcb->load_vmx (&ec->regs);
c00000bb:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
c00000c1:	8d 53 54             	lea    0x54(%ebx),%edx
c00000c4:	e8 81 46 01 00       	call   c001474a <_ZN4Utcb8load_vmxEP8Cpu_regs>
c00000c9:	eb 16                	jmp    c00000e1 <_ZN2Ec9recv_kernEv+0x55>
    else if (ec->cont == ret_user_vmrun)
c00000cb:	81 fa 44 3a 00 c0    	cmp    $0xc0003a44,%edx
c00000d1:	75 1f                	jne    c00000f2 <_ZN2Ec9recv_kernEv+0x66>
        fpu = current->utcb->load_svm (&ec->regs);
c00000d3:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
c00000d9:	8d 53 54             	lea    0x54(%ebx),%edx
c00000dc:	e8 91 50 01 00       	call   c0015172 <_ZN4Utcb8load_svmEP8Cpu_regs>

    if (EXPECT_FALSE (fpu))
c00000e1:	84 c0                	test   %al,%al
c00000e3:	74 0d                	je     c00000f2 <_ZN2Ec9recv_kernEv+0x66>
        ec->transfer_fpu (current);
c00000e5:	8b 15 08 f0 ff cf    	mov    0xcffff008,%edx
c00000eb:	89 d8                	mov    %ebx,%eax
c00000ed:	e8 d6 43 00 00       	call   c00044c8 <_ZN2Ec12transfer_fpuEPS_>

    ret_user_sysexit();
c00000f2:	e8 09 ff ff ff       	call   c0000000 <_ZN2Ec16ret_user_sysexitEv>
c00000f7:	90                   	nop

c00000f8 <_ZN2Ec5replyEPFvvEP2Sm>:

    ret_user_sysexit();
}

void Ec::reply (void (*c)(), Sm * sm)
{
c00000f8:	55                   	push   %ebp
c00000f9:	57                   	push   %edi
c00000fa:	56                   	push   %esi
c00000fb:	89 d6                	mov    %edx,%esi
c00000fd:	53                   	push   %ebx
c00000fe:	51                   	push   %ecx
    current->cont = c;
c00000ff:	8b 15 08 f0 ff cf    	mov    0xcffff008,%edx

    if (EXPECT_FALSE (current->glb))
c0000105:	66 83 ba ce 00 00 00 	cmpw   $0x0,0xce(%edx)
c000010c:	00 
    ret_user_sysexit();
}

void Ec::reply (void (*c)(), Sm * sm)
{
    current->cont = c;
c000010d:	89 42 50             	mov    %eax,0x50(%edx)

    if (EXPECT_FALSE (current->glb))
c0000110:	74 0f                	je     c0000121 <_ZN2Ec5replyEPFvvEP2Sm+0x29>
        Sc::schedule (true);
c0000112:	ba 01 00 00 00       	mov    $0x1,%edx
c0000117:	b8 01 00 00 00       	mov    $0x1,%eax
c000011c:	e9 d3 01 00 00       	jmp    c00002f4 <_ZN2Ec5replyEPFvvEP2Sm+0x1fc>

    Ec *ec = current->rcap;
c0000121:	8b 9a b0 00 00 00    	mov    0xb0(%edx),%ebx

    if (EXPECT_FALSE (!ec))
c0000127:	85 db                	test   %ebx,%ebx
c0000129:	0f 84 da 01 00 00    	je     c0000309 <_ZN2Ec5replyEPFvvEP2Sm+0x211>
        }

        ALWAYS_INLINE
        inline unsigned clr_partner()
        {
            assert (partner == current);
c000012f:	39 93 bc 00 00 00    	cmp    %edx,0xbc(%ebx)
c0000135:	74 19                	je     c0000150 <_ZN2Ec5replyEPFvvEP2Sm+0x58>
c0000137:	68 f8 9c 01 c0       	push   $0xc0019cf8
c000013c:	68 b2 00 00 00       	push   $0xb2
c0000141:	68 83 68 01 c0       	push   $0xc0016883
c0000146:	68 59 74 01 c0       	push   $0xc0017459
c000014b:	e9 85 02 00 00       	jmp    c00003d5 <_ZN2Ec5replyEPFvvEP2Sm+0x2dd>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c0000150:	f0 ff 4b 48          	lock decl 0x48(%ebx)
            if (partner->rcap) {
                partner->rcap->del_ref();
                partner->rcap = nullptr;
c0000154:	8b 83 bc 00 00 00    	mov    0xbc(%ebx),%eax
c000015a:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
c0000161:	00 00 00 
c0000164:	8b 83 bc 00 00 00    	mov    0xbc(%ebx),%eax
c000016a:	f0 ff 48 48          	lock decl 0x48(%eax)
            }
            partner->del_ref();
            partner = nullptr;
            return Sc::ctr_link--;
c000016e:	a1 24 fa ff cf       	mov    0xcffffa24,%eax
        Sc::current->ec->activate();

    bool clr = ec->clr_partner();
c0000173:	85 c0                	test   %eax,%eax
c0000175:	8d 50 ff             	lea    -0x1(%eax),%edx
c0000178:	0f 95 44 24 02       	setne  0x2(%esp)

    if (sm)
c000017d:	85 f6                	test   %esi,%esi
            if (partner->rcap) {
                partner->rcap->del_ref();
                partner->rcap = nullptr;
            }
            partner->del_ref();
            partner = nullptr;
c000017f:	c7 83 bc 00 00 00 00 	movl   $0x0,0xbc(%ebx)
c0000186:	00 00 00 
            return Sc::ctr_link--;
c0000189:	89 15 24 fa ff cf    	mov    %edx,0xcffffa24
c000018f:	0f 84 6d 01 00 00    	je     c0000302 <_ZN2Ec5replyEPFvvEP2Sm+0x20a>
        }

        ALWAYS_INLINE
        inline void dn (bool zero, uint64 t, Ec *ec = Ec::current, bool block = true)
        {
            {   Lock_guard <Spinlock> guard (lock);
c0000195:	8d 46 46             	lea    0x46(%esi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c0000198:	9c                   	pushf  
c0000199:	59                   	pop    %ecx
            return flags & 0x200;
c000019a:	c1 e9 09             	shr    $0x9,%ecx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c000019d:	80 e1 01             	and    $0x1,%cl
c00001a0:	74 2a                	je     c00001cc <_ZN2Ec5replyEPFvvEP2Sm+0xd4>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c00001a2:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c00001a9:	75 19                	jne    c00001c4 <_ZN2Ec5replyEPFvvEP2Sm+0xcc>
c00001ab:	68 c0 9d 01 c0       	push   $0xc0019dc0
c00001b0:	68 b7 00 00 00       	push   $0xb7
c00001b5:	68 12 61 01 c0       	push   $0xc0016112
c00001ba:	68 83 61 01 c0       	push   $0xc0016183
c00001bf:	e9 11 02 00 00       	jmp    c00003d5 <_ZN2Ec5replyEPFvvEP2Sm+0x2dd>

            asm volatile ("cli" : : : "memory");
c00001c4:	fa                   	cli    
            preemption = false;
c00001c5:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
c00001cc:	88 4c 24 03          	mov    %cl,0x3(%esp)
                Cpu::preempt_disable();

            _lock.lock();
c00001d0:	e8 57 09 00 00       	call   c0000b2c <_ZN8Spinlock4lockEv>

                if (counter) {
c00001d5:	8b 46 64             	mov    0x64(%esi),%eax
c00001d8:	8a 4c 24 03          	mov    0x3(%esp),%cl
c00001dc:	85 c0                	test   %eax,%eax
c00001de:	74 79                	je     c0000259 <_ZN2Ec5replyEPFvvEP2Sm+0x161>
                    counter = zero ? 0 : counter - 1;
c00001e0:	48                   	dec    %eax
c00001e1:	89 46 64             	mov    %eax,0x64(%esi)
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c00001e4:	8b 46 50             	mov    0x50(%esi),%eax
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c00001e7:	85 c0                	test   %eax,%eax
c00001e9:	0f 84 eb 00 00 00    	je     c00002da <_ZN2Ec5replyEPFvvEP2Sm+0x1e2>
c00001ef:	8b 50 08             	mov    0x8(%eax),%edx
c00001f2:	85 d2                	test   %edx,%edx
c00001f4:	0f 84 e0 00 00 00    	je     c00002da <_ZN2Ec5replyEPFvvEP2Sm+0x1e2>
c00001fa:	8b 78 04             	mov    0x4(%eax),%edi
c00001fd:	85 ff                	test   %edi,%edi
c00001ff:	0f 84 d5 00 00 00    	je     c00002da <_ZN2Ec5replyEPFvvEP2Sm+0x1e2>
                return false;

            if (t == t->next)
c0000205:	39 d0                	cmp    %edx,%eax
c0000207:	75 09                	jne    c0000212 <_ZN2Ec5replyEPFvvEP2Sm+0x11a>
                headptr = nullptr;
c0000209:	c7 46 50 00 00 00 00 	movl   $0x0,0x50(%esi)
c0000210:	eb 17                	jmp    c0000229 <_ZN2Ec5replyEPFvvEP2Sm+0x131>

            else {
                t->next->prev = t->prev;
c0000212:	89 7a 04             	mov    %edi,0x4(%edx)
                t->prev->next = t->next;
c0000215:	8b 50 04             	mov    0x4(%eax),%edx
c0000218:	8b 78 08             	mov    0x8(%eax),%edi
c000021b:	89 7a 08             	mov    %edi,0x8(%edx)
                if (t == headptr)
c000021e:	3b 46 50             	cmp    0x50(%esi),%eax
c0000221:	75 06                	jne    c0000229 <_ZN2Ec5replyEPFvvEP2Sm+0x131>
                    headptr = t->next;
c0000223:	8b 50 08             	mov    0x8(%eax),%edx
c0000226:	89 56 50             	mov    %edx,0x50(%esi)

    public:

        mword reset(bool l = false) {
            if (l) lock.lock();
            mword c = counter;
c0000229:	8b 50 10             	mov    0x10(%eax),%edx
            }

            t->next = t->prev = nullptr;
c000022c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
c0000233:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
            counter = 0;
c000023a:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
                if (counter) {
                    counter = zero ? 0 : counter - 1;

                    Si * si;
                    if (Queue<Si>::dequeue(si = Queue<Si>::head()))
                        ec->set_si_regs(si->value, static_cast <Sm *>(si)->reset());
c0000241:	8b 40 0c             	mov    0xc(%eax),%eax

        ALWAYS_INLINE
        inline void set_si_regs(mword sig, mword cnt)
        {
            regs.ARG_2 = sig;
            regs.ARG_3 = cnt;
c0000244:	89 53 58             	mov    %edx,0x58(%ebx)
        }

        ALWAYS_INLINE
        inline void set_si_regs(mword sig, mword cnt)
        {
            regs.ARG_2 = sig;
c0000247:	89 43 54             	mov    %eax,0x54(%ebx)
c000024a:	e9 8b 00 00 00       	jmp    c00002da <_ZN2Ec5replyEPFvvEP2Sm+0x1e2>

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
                if (Atomic::cmp_swap (ref, r, r + 1))
c000024f:	8d 50 01             	lea    0x1(%eax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c0000252:	f0 0f b1 53 48       	lock cmpxchg %edx,0x48(%ebx)
c0000257:	74 07                	je     c0000260 <_ZN2Ec5replyEPFvvEP2Sm+0x168>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0000259:	8b 43 48             	mov    0x48(%ebx),%eax
c000025c:	85 c0                	test   %eax,%eax
c000025e:	75 ef                	jne    c000024f <_ZN2Ec5replyEPFvvEP2Sm+0x157>
        inline T *head() const { return headptr; }

        ALWAYS_INLINE
        inline void enqueue (T *t)
        {
            if (!headptr)
c0000260:	8b 46 4c             	mov    0x4c(%esi),%eax
c0000263:	85 c0                	test   %eax,%eax
c0000265:	75 11                	jne    c0000278 <_ZN2Ec5replyEPFvvEP2Sm+0x180>
                headptr = t->prev = t->next = t;
c0000267:	89 9b c4 00 00 00    	mov    %ebx,0xc4(%ebx)
c000026d:	89 9b c0 00 00 00    	mov    %ebx,0xc0(%ebx)
c0000273:	89 5e 4c             	mov    %ebx,0x4c(%esi)
c0000276:	eb 21                	jmp    c0000299 <_ZN2Ec5replyEPFvvEP2Sm+0x1a1>
            else {
                t->next = headptr;
c0000278:	89 83 c4 00 00 00    	mov    %eax,0xc4(%ebx)
                t->prev = headptr->prev;
c000027e:	8b 56 4c             	mov    0x4c(%esi),%edx
c0000281:	8b 92 c0 00 00 00    	mov    0xc0(%edx),%edx
c0000287:	89 93 c0 00 00 00    	mov    %edx,0xc0(%ebx)
                t->next->prev = t->prev->next = t;
c000028d:	89 9a c4 00 00 00    	mov    %ebx,0xc4(%edx)
c0000293:	89 98 c0 00 00 00    	mov    %ebx,0xc0(%eax)
        }

        ALWAYS_INLINE
        inline void unlock()
        {
            asm volatile ("incb %0" : "=m" (val) : : "memory");
c0000299:	fe 46 46             	incb   0x46(%esi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c000029c:	84 c9                	test   %cl,%cl
c000029e:	74 2a                	je     c00002ca <_ZN2Ec5replyEPFvvEP2Sm+0x1d2>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c00002a0:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c00002a7:	74 19                	je     c00002c2 <_ZN2Ec5replyEPFvvEP2Sm+0x1ca>
c00002a9:	68 80 9d 01 c0       	push   $0xc0019d80
c00002ae:	68 c0 00 00 00       	push   $0xc0
c00002b3:	68 12 61 01 c0       	push   $0xc0016112
c00002b8:	68 82 61 01 c0       	push   $0xc0016182
c00002bd:	e9 13 01 00 00       	jmp    c00003d5 <_ZN2Ec5replyEPFvvEP2Sm+0x2dd>

            preemption = true;
c00002c2:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c00002c9:	fb                   	sti    
                ec->add_ref();

                Queue<Ec>::enqueue (ec);
            }

            if (!block)
c00002ca:	80 7c 24 02 00       	cmpb   $0x0,0x2(%esp)
c00002cf:	75 28                	jne    c00002f9 <_ZN2Ec5replyEPFvvEP2Sm+0x201>
                Sc::schedule (false);
c00002d1:	ba 01 00 00 00       	mov    $0x1,%edx
c00002d6:	31 c0                	xor    %eax,%eax
c00002d8:	eb 1a                	jmp    c00002f4 <_ZN2Ec5replyEPFvvEP2Sm+0x1fc>
c00002da:	fe 46 46             	incb   0x46(%esi)
c00002dd:	84 c9                	test   %cl,%cl
c00002df:	74 21                	je     c0000302 <_ZN2Ec5replyEPFvvEP2Sm+0x20a>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c00002e1:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c00002e8:	75 bf                	jne    c00002a9 <_ZN2Ec5replyEPFvvEP2Sm+0x1b1>

            preemption = true;
c00002ea:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c00002f1:	fb                   	sti    
c00002f2:	eb 0e                	jmp    c0000302 <_ZN2Ec5replyEPFvvEP2Sm+0x20a>
c00002f4:	e8 b9 f6 00 00       	call   c000f9b2 <_ZN2Sc8scheduleEbb>

            ec->set_timeout (t, this);

            ec->block_sc();
c00002f9:	89 d8                	mov    %ebx,%eax
c00002fb:	e8 10 82 00 00       	call   c0008510 <_ZN2Ec8block_scEv>
c0000300:	eb 14                	jmp    c0000316 <_ZN2Ec5replyEPFvvEP2Sm+0x21e>
        sm->dn (false, 0, ec, clr);

    if (!clr)
c0000302:	80 7c 24 02 00       	cmpb   $0x0,0x2(%esp)
c0000307:	75 0d                	jne    c0000316 <_ZN2Ec5replyEPFvvEP2Sm+0x21e>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
c0000309:	a1 10 f0 ff cf       	mov    0xcffff010,%eax
        Sc::current->ec->activate();
c000030e:	8b 40 4c             	mov    0x4c(%eax),%eax
c0000311:	e8 02 15 01 00       	call   c0011818 <_ZN2Ec8activateEv>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c0000316:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c000031b:	83 ca ff             	or     $0xffffffff,%edx
c000031e:	f0 0f c1 50 48       	lock xadd %edx,0x48(%eax)
        }

        ALWAYS_INLINE NORETURN
        inline void make_current()
        {
            if (EXPECT_FALSE(current->del_ref())) {
c0000323:	4a                   	dec    %edx
c0000324:	75 29                	jne    c000034f <_ZN2Ec5replyEPFvvEP2Sm+0x257>
                delete current;
c0000326:	8b 35 08 f0 ff cf    	mov    0xcffff008,%esi
c000032c:	85 f6                	test   %esi,%esi
c000032e:	74 1f                	je     c000034f <_ZN2Ec5replyEPFvvEP2Sm+0x257>
c0000330:	89 f0                	mov    %esi,%eax
c0000332:	e8 d7 31 00 00       	call   c000350e <_ZN2EcD1Ev>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c0000337:	8b 86 b8 00 00 00    	mov    0xb8(%esi),%eax
c000033d:	89 f2                	mov    %esi,%edx
c000033f:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c0000345:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c000034a:	e8 11 00 01 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
        {
            if (EXPECT_FALSE(current->del_ref())) {
                delete current;
            }

            current = this;
c000034f:	89 1d 08 f0 ff cf    	mov    %ebx,0xcffff008
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0000355:	8b 43 48             	mov    0x48(%ebx),%eax
c0000358:	85 c0                	test   %eax,%eax
c000035a:	74 0a                	je     c0000366 <_ZN2Ec5replyEPFvvEP2Sm+0x26e>
                if (Atomic::cmp_swap (ref, r, r + 1))
c000035c:	8d 50 01             	lea    0x1(%eax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c000035f:	f0 0f b1 53 48       	lock cmpxchg %edx,0x48(%ebx)
c0000364:	75 ef                	jne    c0000355 <_ZN2Ec5replyEPFvvEP2Sm+0x25d>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
c0000366:	8b b3 b8 00 00 00    	mov    0xb8(%ebx),%esi

            current->add_ref();

            Tss::run.sp0 = reinterpret_cast<mword>(exc_regs() + 1);
c000036c:	8d 83 a0 00 00 00    	lea    0xa0(%ebx),%eax
c0000372:	a3 c4 fa ff cf       	mov    %eax,0xcffffac4

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
c0000377:	8b 0d 04 f0 ff cf    	mov    0xcffff004,%ecx
c000037d:	8b 86 70 01 00 00    	mov    0x170(%esi),%eax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
c0000383:	8b 96 68 01 00 00    	mov    0x168(%esi),%edx

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
c0000389:	0f a3 c8             	bt     %ecx,%eax
c000038c:	73 10                	jae    c000039e <_ZN2Ec5replyEPFvvEP2Sm+0x2a6>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
c000038e:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
c0000393:	d3 c0                	rol    %cl,%eax
c0000395:	f0 21 86 70 01 00 00 	lock and %eax,0x170(%esi)
c000039c:	eb 0c                	jmp    c00003aa <_ZN2Ec5replyEPFvvEP2Sm+0x2b2>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
c000039e:	39 35 0c f0 ff cf    	cmp    %esi,0xcffff00c
c00003a4:	0f 84 a2 00 00 00    	je     c000044c <_ZN2Ec5replyEPFvvEP2Sm+0x354>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c00003aa:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c00003af:	83 c9 ff             	or     $0xffffffff,%ecx
c00003b2:	f0 0f c1 48 48       	lock xadd %ecx,0x48(%eax)
                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
c00003b7:	49                   	dec    %ecx
c00003b8:	75 25                	jne    c00003df <_ZN2Ec5replyEPFvvEP2Sm+0x2e7>
                assert (current != this);
c00003ba:	8b 3d 0c f0 ff cf    	mov    0xcffff00c,%edi
c00003c0:	39 f7                	cmp    %esi,%edi
c00003c2:	75 1d                	jne    c00003e1 <_ZN2Ec5replyEPFvvEP2Sm+0x2e9>
c00003c4:	68 5c 9d 01 c0       	push   $0xc0019d5c
c00003c9:	6a 5e                	push   $0x5e
c00003cb:	68 18 73 01 c0       	push   $0xc0017318
c00003d0:	68 87 73 01 c0       	push   $0xc0017387
c00003d5:	68 69 60 01 c0       	push   $0xc0016069
c00003da:	e8 67 15 00 00       	call   c0001946 <_ZN7Console5panicEPKcz>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
c00003df:	31 ff                	xor    %edi,%edi
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
c00003e1:	89 35 0c f0 ff cf    	mov    %esi,0xcffff00c
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c00003e7:	8b 46 48             	mov    0x48(%esi),%eax
c00003ea:	85 c0                	test   %eax,%eax
c00003ec:	74 0a                	je     c00003f8 <_ZN2Ec5replyEPFvvEP2Sm+0x300>
                if (Atomic::cmp_swap (ref, r, r + 1))
c00003ee:	8d 48 01             	lea    0x1(%eax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c00003f1:	f0 0f b1 4e 48       	lock cmpxchg %ecx,0x48(%esi)
c00003f6:	75 ef                	jne    c00003e7 <_ZN2Ec5replyEPFvvEP2Sm+0x2ef>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
c00003f8:	31 ed                	xor    %ebp,%ebp
        }

        ALWAYS_INLINE
        inline void make_current (mword pcid)
        {
            asm volatile ("mov %0, %%cr3" : : "r" (val | pcid) : "memory");
c00003fa:	a1 04 f0 ff cf       	mov    0xcffff004,%eax
c00003ff:	f6 05 0a f7 ff cf 02 	testb  $0x2,0xcffff70a
c0000406:	0f 44 d5             	cmove  %ebp,%edx
c0000409:	0b 54 86 54          	or     0x54(%esi,%eax,4),%edx
c000040d:	0f 22 da             	mov    %edx,%cr3

            if (del_pd)
c0000410:	85 ff                	test   %edi,%edi
c0000412:	74 38                	je     c000044c <_ZN2Ec5replyEPFvvEP2Sm+0x354>
                delete del_pd;
c0000414:	89 f8                	mov    %edi,%eax

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c0000416:	89 ee                	mov    %ebp,%esi
            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);

            if (del_pd)
                delete del_pd;
c0000418:	e8 cb c5 00 00       	call   c000c9e8 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c000041d:	8b 57 28             	mov    0x28(%edi),%edx
c0000420:	85 d2                	test   %edx,%edx
c0000422:	8d 82 78 fe ff ff    	lea    -0x188(%edx),%eax
c0000428:	0f 45 f0             	cmovne %eax,%esi

            pd_del->quota.free_up(pd_to->quota);
c000042b:	81 c6 90 01 00 00    	add    $0x190,%esi
c0000431:	8d 87 90 01 00 00    	lea    0x190(%edi),%eax
c0000437:	89 f2                	mov    %esi,%edx
c0000439:	e8 8e 25 00 00       	call   c00029cc <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
c000043e:	89 f1                	mov    %esi,%ecx
c0000440:	89 fa                	mov    %edi,%edx
c0000442:	b8 64 b4 01 c0       	mov    $0xc001b464,%eax
c0000447:	e8 14 ff 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>

            pd->make_current();

            asm volatile ("mov %0," EXPAND (PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory"); UNREACHED;
c000044c:	8b 43 50             	mov    0x50(%ebx),%eax
c000044f:	bc 00 e0 ff cf       	mov    $0xcfffe000,%esp
c0000454:	ff e0                	jmp    *%eax

c0000456 <_ZN2Ec9recv_userEv>:
    ret_user_sysexit();
}

void Ec::recv_user()
{
    Ec *ec = current->rcap;
c0000456:	a1 08 f0 ff cf       	mov    0xcffff008,%eax

    ret_user_sysexit();
}

void Ec::recv_user()
{
c000045b:	57                   	push   %edi
c000045c:	bf fc 03 00 00       	mov    $0x3fc,%edi
c0000461:	56                   	push   %esi
c0000462:	53                   	push   %ebx
    Ec *ec = current->rcap;
c0000463:	8b 88 b0 00 00 00    	mov    0xb0(%eax),%ecx

    ec->utcb->save (current->utcb);
c0000469:	8b 98 b4 00 00 00    	mov    0xb4(%eax),%ebx
c000046f:	8b b1 b4 00 00 00    	mov    0xb4(%ecx),%esi
c0000475:	8b 06                	mov    (%esi),%eax
        WARN_UNUSED_RESULT bool load_svm (Cpu_regs *);
        WARN_UNUSED_RESULT bool save_exc (Cpu_regs *);
        WARN_UNUSED_RESULT bool save_vmx (Cpu_regs *);
        WARN_UNUSED_RESULT bool save_svm (Cpu_regs *);

        inline mword ucnt() const { return static_cast<uint16>(items); }
c0000477:	0f b7 d0             	movzwl %ax,%edx
c000047a:	81 fa fc 03 00 00    	cmp    $0x3fc,%edx
c0000480:	0f 47 d7             	cmova  %edi,%edx
        ALWAYS_INLINE NONNULL
        inline void save (Utcb *dst)
        {
            register mword n = ui();

            dst->items = items;
c0000483:	89 03                	mov    %eax,(%ebx)
#if 0
            mword *d = dst->mr, *s = mr;
            asm volatile ("rep; movsl" : "+D" (d), "+S" (s), "+c" (n) : : "memory");
#else
            for (unsigned long i = 0; i < n; i++)
c0000485:	31 c0                	xor    %eax,%eax
c0000487:	39 d0                	cmp    %edx,%eax
c0000489:	74 0b                	je     c0000496 <_ZN2Ec9recv_userEv+0x40>
                dst->mr[i] = mr[i];
c000048b:	8b 7c 86 10          	mov    0x10(%esi,%eax,4),%edi
c000048f:	89 7c 83 10          	mov    %edi,0x10(%ebx,%eax,4)
            dst->items = items;
#if 0
            mword *d = dst->mr, *s = mr;
            asm volatile ("rep; movsl" : "+D" (d), "+S" (s), "+c" (n) : : "memory");
#else
            for (unsigned long i = 0; i < n; i++)
c0000493:	40                   	inc    %eax
c0000494:	eb f1                	jmp    c0000487 <_ZN2Ec9recv_userEv+0x31>
c0000496:	8b 81 b4 00 00 00    	mov    0xb4(%ecx),%eax

    if (EXPECT_FALSE (ec->utcb->tcnt()))
c000049c:	66 83 78 02 00       	cmpw   $0x0,0x2(%eax)
c00004a1:	74 05                	je     c00004a8 <_ZN2Ec9recv_userEv+0x52>
        delegate<true>();
c00004a3:	e8 3a 27 01 00       	call   c0012be2 <_ZN2Ec8delegateILb1EEEvv>

    ret_user_sysexit();
c00004a8:	e8 53 fb ff ff       	call   c0000000 <_ZN2Ec16ret_user_sysexitEv>
c00004ad:	90                   	nop

c00004ae <_ZN2Ec9sys_replyEv>:

    ec->make_current();
}

void Ec::sys_reply()
{
c00004ae:	56                   	push   %esi
c00004af:	53                   	push   %ebx
c00004b0:	83 ec 08             	sub    $0x8,%esp
    Ec *ec = current->rcap;
c00004b3:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c00004b8:	8b 98 b0 00 00 00    	mov    0xb0(%eax),%ebx
    Sm *sm = nullptr;

    if (EXPECT_TRUE (ec)) {
c00004be:	85 db                	test   %ebx,%ebx
c00004c0:	0f 84 18 01 00 00    	je     c00005de <_ZN2Ec9sys_replyEv+0x130>

        enum { SYSCALL_REPLY = 1 };

        Sys_reply *r = static_cast<Sys_reply *>(current->sys_regs());

        if (EXPECT_FALSE (current->cont == sys_reply && current->regs.status() != SYSCALL_REPLY)) {
c00004c6:	81 78 50 ae 04 00 c0 	cmpl   $0xc00004ae,0x50(%eax)
c00004cd:	0f 85 97 00 00 00    	jne    c000056a <_ZN2Ec9sys_replyEv+0xbc>
c00004d3:	8b 50 70             	mov    0x70(%eax),%edx
c00004d6:	80 fa 01             	cmp    $0x1,%dl
c00004d9:	0f 84 8b 00 00 00    	je     c000056a <_ZN2Ec9sys_replyEv+0xbc>
            sm = reinterpret_cast<Sm *>(r->sm_kern());
c00004df:	89 14 24             	mov    %edx,(%esp)
                if (EXPECT_TRUE (cap.obj()->type() == Kobject::SM && (cap.prm() & 2)))
                    sm = static_cast<Sm *>(cap.obj());
            }
        }

        if (EXPECT_FALSE (sm)) {
c00004e2:	85 d2                	test   %edx,%edx
            else
                ARG_1 = (ARG_1 & ~0xfful) | s;
        }

        ALWAYS_INLINE
        inline void set_pt (mword pt) { ARG_1 = pt; }
c00004e4:	c7 40 70 01 00 00 00 	movl   $0x1,0x70(%eax)
            sm = reinterpret_cast<Sm *>(r->sm_kern());
            current->regs.set_pt(SYSCALL_REPLY);
        } else {
            if (EXPECT_FALSE (r->sm())) {
                Capability cap = Space_obj::lookup (r->sm());
                if (EXPECT_TRUE (cap.obj()->type() == Kobject::SM && (cap.prm() & 2)))
c00004eb:	0f 84 92 00 00 00    	je     c0000583 <_ZN2Ec9sys_replyEv+0xd5>
                    sm = static_cast<Sm *>(cap.obj());
            }
        }

        if (EXPECT_FALSE (sm)) {
            if (ec->cont == ret_user_sysexit)
c00004f1:	8b 53 50             	mov    0x50(%ebx),%edx
c00004f4:	81 fa 00 00 00 c0    	cmp    $0xc0000000,%edx
c00004fa:	75 0c                	jne    c0000508 <_ZN2Ec9sys_replyEv+0x5a>
                ec->cont = sys_call;
c00004fc:	c7 43 50 70 06 00 c0 	movl   $0xc0000670,0x50(%ebx)
c0000503:	e9 82 00 00 00       	jmp    c000058a <_ZN2Ec9sys_replyEv+0xdc>
            else if (ec->cont == xcpu_return)
c0000508:	81 fa 8e 40 00 c0    	cmp    $0xc000408e,%edx
c000050e:	75 06                	jne    c0000516 <_ZN2Ec9sys_replyEv+0x68>
        inline void set_status (Status s, bool c = true)
        {
            if (c)
                ARG_1 = s;
            else
                ARG_1 = (ARG_1 & ~0xfful) | s;
c0000510:	c6 43 70 03          	movb   $0x3,0x70(%ebx)
c0000514:	eb 74                	jmp    c000058a <_ZN2Ec9sys_replyEv+0xdc>
                ec->regs.set_status (Sys_regs::BAD_HYP, false);
            else if (ec->cont == sys_reply) {
c0000516:	81 fa ae 04 00 c0    	cmp    $0xc00004ae,%edx
c000051c:	75 6c                	jne    c000058a <_ZN2Ec9sys_replyEv+0xdc>
                assert (ec->regs.status() == SYSCALL_REPLY);
c000051e:	80 7b 70 01          	cmpb   $0x1,0x70(%ebx)
c0000522:	74 16                	je     c000053a <_ZN2Ec9sys_replyEv+0x8c>
c0000524:	68 dc 9c 01 c0       	push   $0xc0019cdc
c0000529:	68 fb 00 00 00       	push   $0xfb
c000052e:	68 7b 97 01 c0       	push   $0xc001977b
c0000533:	68 40 99 01 c0       	push   $0xc0019940
c0000538:	eb 26                	jmp    c0000560 <_ZN2Ec9sys_replyEv+0xb2>
        }

        ALWAYS_INLINE
        inline void set_pt (mword pt) { ARG_1 = pt; }
c000053a:	8b 04 24             	mov    (%esp),%eax
                ec->regs.set_pt(reinterpret_cast<mword>(sm));
                assert (ec->regs.status() != SYSCALL_REPLY);
                reply();
c000053d:	31 d2                	xor    %edx,%edx
            else if (ec->cont == xcpu_return)
                ec->regs.set_status (Sys_regs::BAD_HYP, false);
            else if (ec->cont == sys_reply) {
                assert (ec->regs.status() == SYSCALL_REPLY);
                ec->regs.set_pt(reinterpret_cast<mword>(sm));
                assert (ec->regs.status() != SYSCALL_REPLY);
c000053f:	80 3c 24 01          	cmpb   $0x1,(%esp)
c0000543:	89 43 70             	mov    %eax,0x70(%ebx)
c0000546:	0f 85 9c 00 00 00    	jne    c00005e8 <_ZN2Ec9sys_replyEv+0x13a>
c000054c:	68 dc 9c 01 c0       	push   $0xc0019cdc
c0000551:	68 fd 00 00 00       	push   $0xfd
c0000556:	68 7b 97 01 c0       	push   $0xc001977b
c000055b:	68 63 99 01 c0       	push   $0xc0019963
c0000560:	68 69 60 01 c0       	push   $0xc0016069
c0000565:	e8 dc 13 00 00       	call   c0001946 <_ZN7Console5panicEPKcz>

        if (EXPECT_FALSE (current->cont == sys_reply && current->regs.status() != SYSCALL_REPLY)) {
            sm = reinterpret_cast<Sm *>(r->sm_kern());
            current->regs.set_pt(SYSCALL_REPLY);
        } else {
            if (EXPECT_FALSE (r->sm())) {
c000056a:	8b 50 70             	mov    0x70(%eax),%edx
c000056d:	c1 ea 08             	shr    $0x8,%edx
c0000570:	74 11                	je     c0000583 <_ZN2Ec9sys_replyEv+0xd5>
        static unsigned const caps = (END_SPACE_LIM - SPC_LOCAL_OBJ) / sizeof (Capability);

        ALWAYS_INLINE
        static inline Capability lookup (unsigned long idx)
        {
            return *reinterpret_cast<Capability *>(idx_to_virt (idx));
c0000572:	8b 14 95 00 00 00 e0 	mov    -0x20000000(,%edx,4),%edx

    public:
        ALWAYS_INLINE
        inline Type type() const
        {
            return EXPECT_TRUE (this) ? Type (objtype) : INVALID;
c0000579:	89 d6                	mov    %edx,%esi
c000057b:	83 e6 e0             	and    $0xffffffe0,%esi
c000057e:	89 34 24             	mov    %esi,(%esp)
c0000581:	75 6c                	jne    c00005ef <_ZN2Ec9sys_replyEv+0x141>

    ec->make_current();
}

void Ec::sys_reply()
{
c0000583:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
                assert (ec->regs.status() != SYSCALL_REPLY);
                reply();
            }
        }

        Utcb *src = current->utcb;
c000058a:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax

        if (EXPECT_FALSE (src->tcnt()))
c0000590:	66 83 78 02 00       	cmpw   $0x0,0x2(%eax)
c0000595:	74 0d                	je     c00005a4 <_ZN2Ec9sys_replyEv+0xf6>
c0000597:	89 44 24 04          	mov    %eax,0x4(%esp)
            delegate<false>();
c000059b:	e8 40 27 01 00       	call   c0012ce0 <_ZN2Ec8delegateILb0EEEvv>
c00005a0:	8b 44 24 04          	mov    0x4(%esp),%eax

        bool fpu = false;

        assert (current->cont != ret_xcpu_reply);
c00005a4:	8b 15 08 f0 ff cf    	mov    0xcffff008,%edx
c00005aa:	81 7a 50 64 16 01 c0 	cmpl   $0xc0011664,0x50(%edx)
c00005b1:	75 16                	jne    c00005c9 <_ZN2Ec9sys_replyEv+0x11b>
c00005b3:	68 dc 9c 01 c0       	push   $0xc0019cdc
c00005b8:	68 09 01 00 00       	push   $0x109
c00005bd:	68 7b 97 01 c0       	push   $0xc001977b
c00005c2:	68 86 99 01 c0       	push   $0xc0019986
c00005c7:	eb 97                	jmp    c0000560 <_ZN2Ec9sys_replyEv+0xb2>

        if (EXPECT_TRUE ((ec->cont == ret_user_sysexit) || ec->cont == xcpu_return))
c00005c9:	8b 4b 50             	mov    0x50(%ebx),%ecx
c00005cc:	81 f9 00 00 00 c0    	cmp    $0xc0000000,%ecx
c00005d2:	74 29                	je     c00005fd <_ZN2Ec9sys_replyEv+0x14f>
c00005d4:	81 f9 8e 40 00 c0    	cmp    $0xc000408e,%ecx
c00005da:	75 4d                	jne    c0000629 <_ZN2Ec9sys_replyEv+0x17b>
c00005dc:	eb 1f                	jmp    c00005fd <_ZN2Ec9sys_replyEv+0x14f>
}

void Ec::sys_reply()
{
    Ec *ec = current->rcap;
    Sm *sm = nullptr;
c00005de:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)

        if (EXPECT_FALSE (fpu))
            current->transfer_fpu (ec);
    }

    reply(nullptr, sm);
c00005e5:	8b 14 24             	mov    (%esp),%edx
c00005e8:	31 c0                	xor    %eax,%eax
c00005ea:	e8 09 fb ff ff       	call   c00000f8 <_ZN2Ec5replyEPFvvEP2Sm>
            sm = reinterpret_cast<Sm *>(r->sm_kern());
            current->regs.set_pt(SYSCALL_REPLY);
        } else {
            if (EXPECT_FALSE (r->sm())) {
                Capability cap = Space_obj::lookup (r->sm());
                if (EXPECT_TRUE (cap.obj()->type() == Kobject::SM && (cap.prm() & 2)))
c00005ef:	80 7e 44 04          	cmpb   $0x4,0x44(%esi)
c00005f3:	75 8e                	jne    c0000583 <_ZN2Ec9sys_replyEv+0xd5>
c00005f5:	f6 c2 02             	test   $0x2,%dl
c00005f8:	e9 ee fe ff ff       	jmp    c00004eb <_ZN2Ec9sys_replyEv+0x3d>
c00005fd:	8b 10                	mov    (%eax),%edx
c00005ff:	be fc 03 00 00       	mov    $0x3fc,%esi
        bool fpu = false;

        assert (current->cont != ret_xcpu_reply);

        if (EXPECT_TRUE ((ec->cont == ret_user_sysexit) || ec->cont == xcpu_return))
            src->save (ec->utcb);
c0000604:	8b 9b b4 00 00 00    	mov    0xb4(%ebx),%ebx
        WARN_UNUSED_RESULT bool load_svm (Cpu_regs *);
        WARN_UNUSED_RESULT bool save_exc (Cpu_regs *);
        WARN_UNUSED_RESULT bool save_vmx (Cpu_regs *);
        WARN_UNUSED_RESULT bool save_svm (Cpu_regs *);

        inline mword ucnt() const { return static_cast<uint16>(items); }
c000060a:	0f b7 ca             	movzwl %dx,%ecx
c000060d:	81 f9 fc 03 00 00    	cmp    $0x3fc,%ecx
c0000613:	0f 47 ce             	cmova  %esi,%ecx
        ALWAYS_INLINE NONNULL
        inline void save (Utcb *dst)
        {
            register mword n = ui();

            dst->items = items;
c0000616:	89 13                	mov    %edx,(%ebx)
#if 0
            mword *d = dst->mr, *s = mr;
            asm volatile ("rep; movsl" : "+D" (d), "+S" (s), "+c" (n) : : "memory");
#else
            for (unsigned long i = 0; i < n; i++)
c0000618:	31 d2                	xor    %edx,%edx
c000061a:	39 ca                	cmp    %ecx,%edx
c000061c:	74 c7                	je     c00005e5 <_ZN2Ec9sys_replyEv+0x137>
                dst->mr[i] = mr[i];
c000061e:	8b 74 90 10          	mov    0x10(%eax,%edx,4),%esi
c0000622:	89 74 93 10          	mov    %esi,0x10(%ebx,%edx,4)
            dst->items = items;
#if 0
            mword *d = dst->mr, *s = mr;
            asm volatile ("rep; movsl" : "+D" (d), "+S" (s), "+c" (n) : : "memory");
#else
            for (unsigned long i = 0; i < n; i++)
c0000626:	42                   	inc    %edx
c0000627:	eb f1                	jmp    c000061a <_ZN2Ec9sys_replyEv+0x16c>
        else if (ec->cont == ret_user_iret)
c0000629:	81 f9 2e 00 00 c0    	cmp    $0xc000002e,%ecx
c000062f:	75 0a                	jne    c000063b <_ZN2Ec9sys_replyEv+0x18d>
            fpu = src->save_exc (&ec->regs);
c0000631:	8d 53 54             	lea    0x54(%ebx),%edx
c0000634:	e8 a7 40 01 00       	call   c00146e0 <_ZN4Utcb8save_excEP8Cpu_regs>
c0000639:	eb 1f                	jmp    c000065a <_ZN2Ec9sys_replyEv+0x1ac>
        else if (ec->cont == ret_user_vmresume)
c000063b:	81 f9 2c 3f 00 c0    	cmp    $0xc0003f2c,%ecx
c0000641:	8d 53 54             	lea    0x54(%ebx),%edx
c0000644:	75 07                	jne    c000064d <_ZN2Ec9sys_replyEv+0x19f>
            fpu = src->save_vmx (&ec->regs);
c0000646:	e8 97 46 01 00       	call   c0014ce2 <_ZN4Utcb8save_vmxEP8Cpu_regs>
c000064b:	eb 0d                	jmp    c000065a <_ZN2Ec9sys_replyEv+0x1ac>
        else if (ec->cont == ret_user_vmrun)
c000064d:	81 f9 44 3a 00 c0    	cmp    $0xc0003a44,%ecx
c0000653:	75 90                	jne    c00005e5 <_ZN2Ec9sys_replyEv+0x137>
            fpu = src->save_svm (&ec->regs);
c0000655:	e8 00 4e 01 00       	call   c001545a <_ZN4Utcb8save_svmEP8Cpu_regs>

        if (EXPECT_FALSE (fpu))
c000065a:	84 c0                	test   %al,%al
c000065c:	74 87                	je     c00005e5 <_ZN2Ec9sys_replyEv+0x137>
            current->transfer_fpu (ec);
c000065e:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0000663:	89 da                	mov    %ebx,%edx
c0000665:	e8 5e 3e 00 00       	call   c00044c8 <_ZN2Ec12transfer_fpuEPS_>
c000066a:	e9 76 ff ff ff       	jmp    c00005e5 <_ZN2Ec9sys_replyEv+0x137>
c000066f:	90                   	nop

c0000670 <_ZN2Ec8sys_callEv>:

    die ("IPC Timeout");
}

void Ec::sys_call()
{
c0000670:	55                   	push   %ebp
c0000671:	57                   	push   %edi
c0000672:	56                   	push   %esi
    Sys_call *s = static_cast<Sys_call *>(current->sys_regs());
c0000673:	8b 35 08 f0 ff cf    	mov    0xcffff008,%esi

    die ("IPC Timeout");
}

void Ec::sys_call()
{
c0000679:	53                   	push   %ebx
c000067a:	8b 7e 70             	mov    0x70(%esi),%edi
            DISABLE_DONATION    = 1ul << 1,
            DISABLE_REPLYCAP    = 1ul << 2
        };

        ALWAYS_INLINE
        inline unsigned long pt() const { return ARG_1 >> 8; }
c000067d:	89 f8                	mov    %edi,%eax
c000067f:	c1 e8 08             	shr    $0x8,%eax
        Capability() : val (0) {}

        Capability (Kobject *o, mword a) : val (a ? reinterpret_cast<mword>(o) | (a & perm) : 0) {}

        ALWAYS_INLINE
        inline Kobject *obj() const { return reinterpret_cast<Kobject *>(val & ~perm); }
c0000682:	8b 2c 85 00 00 00 e0 	mov    -0x20000000(,%eax,4),%ebp
c0000689:	83 e5 e0             	and    $0xffffffe0,%ebp
c000068c:	74 06                	je     c0000694 <_ZN2Ec8sys_callEv+0x24>
    Sys_call *s = static_cast<Sys_call *>(current->sys_regs());

    Kobject *obj = Space_obj::lookup (s->pt()).obj();
    if (EXPECT_FALSE (obj->type() != Kobject::PT)) {
c000068e:	80 7d 44 03          	cmpb   $0x3,0x44(%ebp)
c0000692:	74 05                	je     c0000699 <_ZN2Ec8sys_callEv+0x29>
//        trace (TRACE_ERROR, "%s: Bad PT CAP (%#lx)", __func__, s->pt());
        sys_finish<Sys_regs::BAD_CAP>();
c0000694:	e8 57 1a 01 00       	call   c00120f0 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>
    }

    Pt *pt = static_cast<Pt *>(obj);
    Ec *ec = pt->ec;

    if (Pd::current->quota.hit_limit()) {
c0000699:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c000069e:	31 d2                	xor    %edx,%edx
{
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
c00006a0:	8b 5d 4c             	mov    0x4c(%ebp),%ebx
c00006a3:	05 90 01 00 00       	add    $0x190,%eax
c00006a8:	e8 11 0e 01 00       	call   c00114be <_ZN5Quota9hit_limitEm>
c00006ad:	84 c0                	test   %al,%al
c00006af:	74 3d                	je     c00006ee <_ZN2Ec8sys_callEv+0x7e>

        if (!current->pt_oom)
c00006b1:	8b 96 f8 00 00 00    	mov    0xf8(%esi),%edx
c00006b7:	85 d2                	test   %edx,%edx
c00006b9:	75 05                	jne    c00006c0 <_ZN2Ec8sys_callEv+0x50>
            sys_finish<Sys_regs::QUO_OOM>();
c00006bb:	e8 f4 1c 01 00       	call   c00123b4 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE9ELb0EEEvv>

        if (current->xcpu_sm) {
c00006c0:	83 be f4 00 00 00 00 	cmpl   $0x0,0xf4(%esi)
c00006c7:	74 11                	je     c00006da <_ZN2Ec8sys_callEv+0x6a>
        inline void set_status (Status s, bool c = true)
        {
            if (c)
                ARG_1 = s;
            else
                ARG_1 = (ARG_1 & ~0xfful) | s;
c00006c9:	81 e7 00 ff ff ff    	and    $0xffffff00,%edi
c00006cf:	83 cf 09             	or     $0x9,%edi
c00006d2:	89 7e 70             	mov    %edi,0x70(%esi)
            current->regs.set_status (Sys_regs::QUO_OOM, false);
            xcpu_return();
c00006d5:	e8 b4 39 00 00       	call   c000408e <_ZN2Ec11xcpu_returnEv>
        }

        current->oom_call_cpu (current->pt_oom, current->pt_oom->id, sys_call, sys_call);
c00006da:	8b 4a 58             	mov    0x58(%edx),%ecx
c00006dd:	89 f0                	mov    %esi,%eax
c00006df:	68 70 06 00 c0       	push   $0xc0000670
c00006e4:	68 70 06 00 c0       	push   $0xc0000670
c00006e9:	e8 a2 b1 00 00       	call   c000b890 <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_>
        sys_finish<Sys_regs::QUO_OOM>();
    }

    if (EXPECT_FALSE (current->cpu != ec->xcpu))
c00006ee:	0f b7 86 cc 00 00 00 	movzwl 0xcc(%esi),%eax
c00006f5:	3b 83 cc 00 00 00    	cmp    0xcc(%ebx),%eax
c00006fb:	74 05                	je     c0000702 <_ZN2Ec8sys_callEv+0x92>
        Ec::sys_xcpu_call();
c00006fd:	e8 0a 31 01 00       	call   c001380c <_ZN2Ec13sys_xcpu_callEv>

    if (EXPECT_TRUE (!ec->cont)) {
c0000702:	83 7b 50 00          	cmpl   $0x0,0x50(%ebx)
c0000706:	0f 85 b0 01 00 00    	jne    c00008bc <_ZN2Ec8sys_callEv+0x24c>
        current->cont = current->xcpu_sm ? xcpu_return : ret_user_sysexit;
c000070c:	83 be f4 00 00 00 00 	cmpl   $0x0,0xf4(%esi)
c0000713:	ba 00 00 00 c0       	mov    $0xc0000000,%edx
c0000718:	b8 8e 40 00 c0       	mov    $0xc000408e,%eax
        inline Exc_regs *exc_regs() { return &regs; }

        ALWAYS_INLINE
        inline void set_partner (Ec *p)
        {
            partner = p;
c000071d:	89 9e bc 00 00 00    	mov    %ebx,0xbc(%esi)
c0000723:	0f 44 c2             	cmove  %edx,%eax
c0000726:	89 46 50             	mov    %eax,0x50(%esi)
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0000729:	8b 43 48             	mov    0x48(%ebx),%eax
c000072c:	85 c0                	test   %eax,%eax
c000072e:	74 0a                	je     c000073a <_ZN2Ec8sys_callEv+0xca>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0000730:	8d 50 01             	lea    0x1(%eax),%edx
c0000733:	f0 0f b1 53 48       	lock cmpxchg %edx,0x48(%ebx)
c0000738:	75 ef                	jne    c0000729 <_ZN2Ec8sys_callEv+0xb9>
            partner->add_ref();
            partner->rcap = this;
c000073a:	8b 86 bc 00 00 00    	mov    0xbc(%esi),%eax
c0000740:	89 b0 b0 00 00 00    	mov    %esi,0xb0(%eax)
            partner->rcap->add_ref();
c0000746:	8b 86 bc 00 00 00    	mov    0xbc(%esi),%eax
c000074c:	8b 90 b0 00 00 00    	mov    0xb0(%eax),%edx
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0000752:	8b 42 48             	mov    0x48(%edx),%eax
c0000755:	85 c0                	test   %eax,%eax
c0000757:	74 0a                	je     c0000763 <_ZN2Ec8sys_callEv+0xf3>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0000759:	8d 48 01             	lea    0x1(%eax),%ecx
c000075c:	f0 0f b1 4a 48       	lock cmpxchg %ecx,0x48(%edx)
c0000761:	75 ef                	jne    c0000752 <_ZN2Ec8sys_callEv+0xe2>
        current->set_partner (ec);
        ec->cont = recv_user;
c0000763:	c7 43 50 56 04 00 c0 	movl   $0xc0000456,0x50(%ebx)
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c000076a:	83 ca ff             	or     $0xffffffff,%edx
        ec->regs.set_pt (pt->id);
c000076d:	8b 45 58             	mov    0x58(%ebp),%eax
            Sc::ctr_link++;
c0000770:	ff 05 24 fa ff cf    	incl   0xcffffa24
        }

        ALWAYS_INLINE
        inline void set_pt (mword pt) { ARG_1 = pt; }
c0000776:	89 43 70             	mov    %eax,0x70(%ebx)
        ec->regs.set_ip (pt->ip);
c0000779:	8b 45 54             	mov    0x54(%ebp),%eax

        ALWAYS_INLINE
        inline void set_pt (mword pt, mword pt2, mword s) { ARG_1 = pt; ARG_2 = pt2; ARG_3 = s; }

        ALWAYS_INLINE
        inline void set_ip (mword ip) { ARG_IP = ip; }
c000077c:	89 43 68             	mov    %eax,0x68(%ebx)
c000077f:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0000784:	f0 0f c1 50 48       	lock xadd %edx,0x48(%eax)
        }

        ALWAYS_INLINE NORETURN
        inline void make_current()
        {
            if (EXPECT_FALSE(current->del_ref())) {
c0000789:	4a                   	dec    %edx
c000078a:	75 29                	jne    c00007b5 <_ZN2Ec8sys_callEv+0x145>
                delete current;
c000078c:	8b 35 08 f0 ff cf    	mov    0xcffff008,%esi
c0000792:	85 f6                	test   %esi,%esi
c0000794:	74 1f                	je     c00007b5 <_ZN2Ec8sys_callEv+0x145>
c0000796:	89 f0                	mov    %esi,%eax
c0000798:	e8 71 2d 00 00       	call   c000350e <_ZN2EcD1Ev>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c000079d:	8b 86 b8 00 00 00    	mov    0xb8(%esi),%eax
c00007a3:	89 f2                	mov    %esi,%edx
c00007a5:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c00007ab:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c00007b0:	e8 ab fb 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
        {
            if (EXPECT_FALSE(current->del_ref())) {
                delete current;
            }

            current = this;
c00007b5:	89 1d 08 f0 ff cf    	mov    %ebx,0xcffff008
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c00007bb:	8b 43 48             	mov    0x48(%ebx),%eax
c00007be:	85 c0                	test   %eax,%eax
c00007c0:	74 0a                	je     c00007cc <_ZN2Ec8sys_callEv+0x15c>
                if (Atomic::cmp_swap (ref, r, r + 1))
c00007c2:	8d 50 01             	lea    0x1(%eax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c00007c5:	f0 0f b1 53 48       	lock cmpxchg %edx,0x48(%ebx)
c00007ca:	75 ef                	jne    c00007bb <_ZN2Ec8sys_callEv+0x14b>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
c00007cc:	8b b3 b8 00 00 00    	mov    0xb8(%ebx),%esi

            current->add_ref();

            Tss::run.sp0 = reinterpret_cast<mword>(exc_regs() + 1);
c00007d2:	8d 83 a0 00 00 00    	lea    0xa0(%ebx),%eax
c00007d8:	a3 c4 fa ff cf       	mov    %eax,0xcffffac4
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
c00007dd:	8b 0d 04 f0 ff cf    	mov    0xcffff004,%ecx
c00007e3:	8b 86 70 01 00 00    	mov    0x170(%esi),%eax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
c00007e9:	8b 96 68 01 00 00    	mov    0x168(%esi),%edx

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
c00007ef:	0f a3 c8             	bt     %ecx,%eax
c00007f2:	73 10                	jae    c0000804 <_ZN2Ec8sys_callEv+0x194>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
c00007f4:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
c00007f9:	d3 c0                	rol    %cl,%eax
c00007fb:	f0 21 86 70 01 00 00 	lock and %eax,0x170(%esi)
c0000802:	eb 0c                	jmp    c0000810 <_ZN2Ec8sys_callEv+0x1a0>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
c0000804:	39 35 0c f0 ff cf    	cmp    %esi,0xcffff00c
c000080a:	0f 84 a2 00 00 00    	je     c00008b2 <_ZN2Ec8sys_callEv+0x242>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c0000810:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c0000815:	83 c9 ff             	or     $0xffffffff,%ecx
c0000818:	f0 0f c1 48 48       	lock xadd %ecx,0x48(%eax)
                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
c000081d:	49                   	dec    %ecx
c000081e:	75 25                	jne    c0000845 <_ZN2Ec8sys_callEv+0x1d5>
                assert (current != this);
c0000820:	8b 3d 0c f0 ff cf    	mov    0xcffff00c,%edi
c0000826:	39 f7                	cmp    %esi,%edi
c0000828:	75 1d                	jne    c0000847 <_ZN2Ec8sys_callEv+0x1d7>
c000082a:	68 5c 9d 01 c0       	push   $0xc0019d5c
c000082f:	6a 5e                	push   $0x5e
c0000831:	68 18 73 01 c0       	push   $0xc0017318
c0000836:	68 87 73 01 c0       	push   $0xc0017387
c000083b:	68 69 60 01 c0       	push   $0xc0016069
c0000840:	e8 01 11 00 00       	call   c0001946 <_ZN7Console5panicEPKcz>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
c0000845:	31 ff                	xor    %edi,%edi
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
c0000847:	89 35 0c f0 ff cf    	mov    %esi,0xcffff00c
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c000084d:	8b 46 48             	mov    0x48(%esi),%eax
c0000850:	85 c0                	test   %eax,%eax
c0000852:	74 0a                	je     c000085e <_ZN2Ec8sys_callEv+0x1ee>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0000854:	8d 48 01             	lea    0x1(%eax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c0000857:	f0 0f b1 4e 48       	lock cmpxchg %ecx,0x48(%esi)
c000085c:	75 ef                	jne    c000084d <_ZN2Ec8sys_callEv+0x1dd>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
c000085e:	31 ed                	xor    %ebp,%ebp
c0000860:	a1 04 f0 ff cf       	mov    0xcffff004,%eax
c0000865:	f6 05 0a f7 ff cf 02 	testb  $0x2,0xcffff70a
c000086c:	0f 44 d5             	cmove  %ebp,%edx
c000086f:	0b 54 86 54          	or     0x54(%esi,%eax,4),%edx
c0000873:	0f 22 da             	mov    %edx,%cr3

            if (del_pd)
c0000876:	85 ff                	test   %edi,%edi
c0000878:	74 38                	je     c00008b2 <_ZN2Ec8sys_callEv+0x242>
                delete del_pd;
c000087a:	89 f8                	mov    %edi,%eax

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c000087c:	89 ee                	mov    %ebp,%esi
            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);

            if (del_pd)
                delete del_pd;
c000087e:	e8 65 c1 00 00       	call   c000c9e8 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c0000883:	8b 57 28             	mov    0x28(%edi),%edx
c0000886:	85 d2                	test   %edx,%edx
c0000888:	8d 82 78 fe ff ff    	lea    -0x188(%edx),%eax
c000088e:	0f 45 f0             	cmovne %eax,%esi

            pd_del->quota.free_up(pd_to->quota);
c0000891:	81 c6 90 01 00 00    	add    $0x190,%esi
c0000897:	8d 87 90 01 00 00    	lea    0x190(%edi),%eax
c000089d:	89 f2                	mov    %esi,%edx
c000089f:	e8 28 21 00 00       	call   c00029cc <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
c00008a4:	89 f1                	mov    %esi,%ecx
c00008a6:	89 fa                	mov    %edi,%edx
c00008a8:	b8 64 b4 01 c0       	mov    $0xc001b464,%eax
c00008ad:	e8 ae fa 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>

            pd->make_current();

            asm volatile ("mov %0," EXPAND (PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory"); UNREACHED;
c00008b2:	8b 43 50             	mov    0x50(%ebx),%eax
c00008b5:	bc 00 e0 ff cf       	mov    $0xcfffe000,%esp
c00008ba:	ff e0                	jmp    *%eax
        ec->make_current();
    }

    if (EXPECT_TRUE (!(s->flags() & Sys_call::DISABLE_BLOCKING)))
c00008bc:	83 e7 10             	and    $0x10,%edi
c00008bf:	75 0c                	jne    c00008cd <_ZN2Ec8sys_callEv+0x25d>
        ec->help (sys_call);
c00008c1:	ba 70 06 00 c0       	mov    $0xc0000670,%edx
c00008c6:	89 d8                	mov    %ebx,%eax
c00008c8:	e8 d1 7b 00 00       	call   c000849e <_ZN2Ec4helpEPFvvE>

    sys_finish<Sys_regs::COM_TIM>();
c00008cd:	e8 b0 17 01 00       	call   c0012082 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE1ELb0EEEvv>

c00008d2 <_ZN4Acpi7hw_readEP8Acpi_gas>:
    }
}

unsigned Acpi::hw_read (Acpi_gas *gas)
{
    if (!gas->bits)     // Register not implemented
c00008d2:	0f b6 50 01          	movzbl 0x1(%eax),%edx
c00008d6:	84 d2                	test   %dl,%dl
c00008d8:	74 39                	je     c0000913 <_ZN4Acpi7hw_readEP8Acpi_gas+0x41>
        return 0;

    if (gas->asid == Acpi_gas::IO) {
c00008da:	0f b6 08             	movzbl (%eax),%ecx
c00008dd:	80 f9 01             	cmp    $0x1,%cl
c00008e0:	75 25                	jne    c0000907 <_ZN4Acpi7hw_readEP8Acpi_gas+0x35>
        switch (gas->bits) {
c00008e2:	80 fa 10             	cmp    $0x10,%dl
c00008e5:	74 12                	je     c00008f9 <_ZN4Acpi7hw_readEP8Acpi_gas+0x27>
c00008e7:	80 fa 20             	cmp    $0x20,%dl
c00008ea:	74 16                	je     c0000902 <_ZN4Acpi7hw_readEP8Acpi_gas+0x30>
c00008ec:	80 fa 08             	cmp    $0x8,%dl
c00008ef:	75 16                	jne    c0000907 <_ZN4Acpi7hw_readEP8Acpi_gas+0x35>
c00008f1:	8b 50 04             	mov    0x4(%eax),%edx
c00008f4:	ec                   	in     (%dx),%al
            return val;
c00008f5:	0f b6 c0             	movzbl %al,%eax
            case 8:
                return Io::in<uint8>(static_cast<unsigned>(gas->addr));
c00008f8:	c3                   	ret    
        template <typename T>
        ALWAYS_INLINE
        static inline unsigned in (unsigned port)
        {
            T val;
            asm volatile ("in %w1, %0" : "=a" (val) : "Nd" (port));
c00008f9:	8b 50 04             	mov    0x4(%eax),%edx
c00008fc:	66 ed                	in     (%dx),%ax
c00008fe:	0f b7 c0             	movzwl %ax,%eax
            case 16:
                return Io::in<uint16>(static_cast<unsigned>(gas->addr));
c0000901:	c3                   	ret    
c0000902:	8b 50 04             	mov    0x4(%eax),%edx
            case 32:
                return Io::in<uint32>(static_cast<unsigned>(gas->addr));
c0000905:	ed                   	in     (%dx),%eax
c0000906:	c3                   	ret    
        }
    }

    Console::panic ("Unimplemented ASID %d bits=%d", gas->asid, gas->bits);
c0000907:	52                   	push   %edx
c0000908:	51                   	push   %ecx
c0000909:	68 40 5f 01 c0       	push   $0xc0015f40
c000090e:	e8 33 10 00 00       	call   c0001946 <_ZN7Console5panicEPKcz>
}

unsigned Acpi::hw_read (Acpi_gas *gas)
{
    if (!gas->bits)     // Register not implemented
        return 0;
c0000913:	31 c0                	xor    %eax,%eax
                return Io::in<uint32>(static_cast<unsigned>(gas->addr));
        }
    }

    Console::panic ("Unimplemented ASID %d bits=%d", gas->asid, gas->bits);
}
c0000915:	c3                   	ret    

c0000916 <_ZN4Acpi4readENS_8RegisterE>:
    trace (TRACE_ACPI, "ACPI: GSI:%#x TMR:%lu", gsi, tmr_msb() + 1);
}

unsigned Acpi::read (Register reg)
{
    switch (reg) {
c0000916:	83 f8 09             	cmp    $0x9,%eax

    trace (TRACE_ACPI, "ACPI: GSI:%#x TMR:%lu", gsi, tmr_msb() + 1);
}

unsigned Acpi::read (Register reg)
{
c0000919:	53                   	push   %ebx
    switch (reg) {
c000091a:	77 59                	ja     c0000975 <_ZN4Acpi4readENS_8RegisterE+0x5f>
c000091c:	ff 24 85 8c 60 01 c0 	jmp    *-0x3ffe9f74(,%eax,4)
        case PM1_STS:
            return hw_read (&pm1a_sts) | hw_read (&pm1b_sts);
c0000923:	b8 28 a3 01 c0       	mov    $0xc001a328,%eax
c0000928:	e8 a5 ff ff ff       	call   c00008d2 <_ZN4Acpi7hw_readEP8Acpi_gas>
c000092d:	89 c3                	mov    %eax,%ebx
c000092f:	b8 1c a3 01 c0       	mov    $0xc001a31c,%eax
c0000934:	eb 11                	jmp    c0000947 <_ZN4Acpi4readENS_8RegisterE+0x31>
        case PM1_ENA:
            return hw_read (&pm1a_ena) | hw_read (&pm1b_ena);
c0000936:	b8 10 a3 01 c0       	mov    $0xc001a310,%eax
c000093b:	e8 92 ff ff ff       	call   c00008d2 <_ZN4Acpi7hw_readEP8Acpi_gas>
c0000940:	89 c3                	mov    %eax,%ebx
c0000942:	b8 04 a3 01 c0       	mov    $0xc001a304,%eax
c0000947:	e8 86 ff ff ff       	call   c00008d2 <_ZN4Acpi7hw_readEP8Acpi_gas>
c000094c:	09 d8                	or     %ebx,%eax
c000094e:	eb 31                	jmp    c0000981 <_ZN4Acpi4readENS_8RegisterE+0x6b>
        case PM1_CNT:
            return hw_read (&pm1a_cnt) | hw_read (&pm1b_cnt);
c0000950:	b8 f8 a2 01 c0       	mov    $0xc001a2f8,%eax
c0000955:	e8 78 ff ff ff       	call   c00008d2 <_ZN4Acpi7hw_readEP8Acpi_gas>
c000095a:	89 c3                	mov    %eax,%ebx
c000095c:	b8 ec a2 01 c0       	mov    $0xc001a2ec,%eax
c0000961:	eb e4                	jmp    c0000947 <_ZN4Acpi4readENS_8RegisterE+0x31>
        case PM2_CNT:
            return hw_read (&pm2_cnt);
c0000963:	b8 e0 a2 01 c0       	mov    $0xc001a2e0,%eax
c0000968:	eb 05                	jmp    c000096f <_ZN4Acpi4readENS_8RegisterE+0x59>
        case PM_TMR:
            return hw_read (&pm_tmr);
c000096a:	b8 d4 a2 01 c0       	mov    $0xc001a2d4,%eax
            Console::panic ("Unimplemented register Acpi::read");
            break;
    }

    return 0;
}
c000096f:	5b                   	pop    %ebx
        case PM1_CNT:
            return hw_read (&pm1a_cnt) | hw_read (&pm1b_cnt);
        case PM2_CNT:
            return hw_read (&pm2_cnt);
        case PM_TMR:
            return hw_read (&pm_tmr);
c0000970:	e9 5d ff ff ff       	jmp    c00008d2 <_ZN4Acpi7hw_readEP8Acpi_gas>
        case RESET:
            break;
        default:
            Console::panic ("Unimplemented register Acpi::read");
c0000975:	68 5e 5f 01 c0       	push   $0xc0015f5e
c000097a:	e8 c7 0f 00 00       	call   c0001946 <_ZN7Console5panicEPKcz>
            break;
    }

    return 0;
c000097f:	31 c0                	xor    %eax,%eax
}
c0000981:	5b                   	pop    %ebx
c0000982:	c3                   	ret    
c0000983:	90                   	nop

c0000984 <_ZN4Acpi5delayEj>:
unsigned    Acpi::irq, Acpi::gsi;
bool        Acpi_table_madt::sci_overridden = false;

void Acpi::delay (unsigned ms)
{
    unsigned cnt = timer_frequency * ms / 1000;
c0000984:	69 c0 99 9e 36 00    	imul   $0x369e99,%eax,%eax
c000098a:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
c000098f:	31 d2                	xor    %edx,%edx
uint8       Acpi::reset_val;
unsigned    Acpi::irq, Acpi::gsi;
bool        Acpi_table_madt::sci_overridden = false;

void Acpi::delay (unsigned ms)
{
c0000991:	56                   	push   %esi
c0000992:	53                   	push   %ebx
    unsigned cnt = timer_frequency * ms / 1000;
c0000993:	f7 f1                	div    %ecx
c0000995:	89 c3                	mov    %eax,%ebx
    unsigned val = read (PM_TMR);
c0000997:	b8 08 00 00 00       	mov    $0x8,%eax
c000099c:	e8 75 ff ff ff       	call   c0000916 <_ZN4Acpi4readENS_8RegisterE>
c00009a1:	89 c6                	mov    %eax,%esi

    while ((read (PM_TMR) - val) % (1UL << 24) < cnt)
c00009a3:	b8 08 00 00 00       	mov    $0x8,%eax
c00009a8:	e8 69 ff ff ff       	call   c0000916 <_ZN4Acpi4readENS_8RegisterE>
c00009ad:	29 f0                	sub    %esi,%eax
c00009af:	89 c1                	mov    %eax,%ecx
c00009b1:	81 e1 ff ff ff 00    	and    $0xffffff,%ecx
c00009b7:	39 d9                	cmp    %ebx,%ecx
c00009b9:	73 04                	jae    c00009bf <_ZN4Acpi5delayEj+0x3b>
c00009bb:	f3 90                	pause  
c00009bd:	eb e4                	jmp    c00009a3 <_ZN4Acpi5delayEj+0x1f>
        pause();
}
c00009bf:	5b                   	pop    %ebx
c00009c0:	5e                   	pop    %esi
c00009c1:	c3                   	ret    

c00009c2 <_ZN4Acpi8hw_writeEP8Acpi_gasjb>:

    Console::panic ("Unimplemented ASID %d bits=%d", gas->asid, gas->bits);
}

void Acpi::hw_write (Acpi_gas *gas, unsigned val, bool prm)
{
c00009c2:	56                   	push   %esi
c00009c3:	89 c6                	mov    %eax,%esi
c00009c5:	89 d0                	mov    %edx,%eax
    if (!gas->bits)     // Register not implemented
c00009c7:	0f b6 56 01          	movzbl 0x1(%esi),%edx

    Console::panic ("Unimplemented ASID %d bits=%d", gas->asid, gas->bits);
}

void Acpi::hw_write (Acpi_gas *gas, unsigned val, bool prm)
{
c00009cb:	53                   	push   %ebx
    if (!gas->bits)     // Register not implemented
c00009cc:	84 d2                	test   %dl,%dl
c00009ce:	74 62                	je     c0000a32 <_ZN4Acpi8hw_writeEP8Acpi_gasjb+0x70>
        return;

    if (gas->asid == Acpi_gas::IO) {
c00009d0:	0f b6 1e             	movzbl (%esi),%ebx
c00009d3:	80 fb 01             	cmp    $0x1,%bl
c00009d6:	75 4a                	jne    c0000a22 <_ZN4Acpi8hw_writeEP8Acpi_gasjb+0x60>
        switch (gas->bits) {
c00009d8:	80 fa 20             	cmp    $0x20,%dl
c00009db:	74 25                	je     c0000a02 <_ZN4Acpi8hw_writeEP8Acpi_gasjb+0x40>
c00009dd:	77 11                	ja     c00009f0 <_ZN4Acpi8hw_writeEP8Acpi_gasjb+0x2e>
c00009df:	80 fa 08             	cmp    $0x8,%dl
c00009e2:	74 18                	je     c00009fc <_ZN4Acpi8hw_writeEP8Acpi_gasjb+0x3a>
c00009e4:	80 fa 10             	cmp    $0x10,%dl
c00009e7:	75 39                	jne    c0000a22 <_ZN4Acpi8hw_writeEP8Acpi_gasjb+0x60>

        template <typename T>
        ALWAYS_INLINE
        static inline void out (unsigned port, T val)
        {
            asm volatile ("out %0, %w1" : : "a" (val), "Nd" (port));
c00009e9:	8b 56 04             	mov    0x4(%esi),%edx
c00009ec:	66 ef                	out    %ax,(%dx)
c00009ee:	eb 42                	jmp    c0000a32 <_ZN4Acpi8hw_writeEP8Acpi_gasjb+0x70>
c00009f0:	80 fa 40             	cmp    $0x40,%dl
c00009f3:	74 13                	je     c0000a08 <_ZN4Acpi8hw_writeEP8Acpi_gasjb+0x46>
c00009f5:	80 fa 80             	cmp    $0x80,%dl
c00009f8:	74 0e                	je     c0000a08 <_ZN4Acpi8hw_writeEP8Acpi_gasjb+0x46>
c00009fa:	eb 26                	jmp    c0000a22 <_ZN4Acpi8hw_writeEP8Acpi_gasjb+0x60>
c00009fc:	8b 56 04             	mov    0x4(%esi),%edx
c00009ff:	ee                   	out    %al,(%dx)
c0000a00:	eb 30                	jmp    c0000a32 <_ZN4Acpi8hw_writeEP8Acpi_gasjb+0x70>
c0000a02:	8b 56 04             	mov    0x4(%esi),%edx
c0000a05:	ef                   	out    %eax,(%dx)
c0000a06:	eb 2a                	jmp    c0000a32 <_ZN4Acpi8hw_writeEP8Acpi_gasjb+0x70>
            case 32:
                Io::out (static_cast<unsigned>(gas->addr), static_cast<uint32>(val));
                return;
            case 64:
            case 128:
               if (!prm)
c0000a08:	84 c9                	test   %cl,%cl
c0000a0a:	74 16                	je     c0000a22 <_ZN4Acpi8hw_writeEP8Acpi_gasjb+0x60>
                   break;

               for (unsigned i = 0; i < gas->bits / 32; i++)
c0000a0c:	c0 ea 05             	shr    $0x5,%dl
c0000a0f:	31 c9                	xor    %ecx,%ecx
c0000a11:	0f b6 da             	movzbl %dl,%ebx
                   Io::out (static_cast<unsigned>(gas->addr) + i * 4, static_cast<uint32>(val));
c0000a14:	8b 56 04             	mov    0x4(%esi),%edx
c0000a17:	8d 14 8a             	lea    (%edx,%ecx,4),%edx
c0000a1a:	ef                   	out    %eax,(%dx)
            case 64:
            case 128:
               if (!prm)
                   break;

               for (unsigned i = 0; i < gas->bits / 32; i++)
c0000a1b:	41                   	inc    %ecx
c0000a1c:	39 d9                	cmp    %ebx,%ecx
c0000a1e:	72 f4                	jb     c0000a14 <_ZN4Acpi8hw_writeEP8Acpi_gasjb+0x52>
c0000a20:	eb 10                	jmp    c0000a32 <_ZN4Acpi8hw_writeEP8Acpi_gasjb+0x70>
                   Io::out (static_cast<unsigned>(gas->addr) + i * 4, static_cast<uint32>(val));
               return;
        }
    }

    Console::panic ("Unimplemented ASID %d bits=%d prm=%u", gas->asid, gas->bits, prm);
c0000a22:	0f b6 c9             	movzbl %cl,%ecx
c0000a25:	51                   	push   %ecx
c0000a26:	52                   	push   %edx
c0000a27:	53                   	push   %ebx
c0000a28:	68 80 5f 01 c0       	push   $0xc0015f80
c0000a2d:	e8 14 0f 00 00       	call   c0001946 <_ZN7Console5panicEPKcz>
}
c0000a32:	5b                   	pop    %ebx
c0000a33:	5e                   	pop    %esi
c0000a34:	c3                   	ret    
c0000a35:	90                   	nop

c0000a36 <_ZN4Acpi5clearENS_8RegisterEj>:
    return 0;
}

void Acpi::clear (Register reg, unsigned val)
{
    switch (reg) {
c0000a36:	83 f8 05             	cmp    $0x5,%eax
c0000a39:	74 11                	je     c0000a4c <_ZN4Acpi5clearENS_8RegisterEj+0x16>
c0000a3b:	83 f8 07             	cmp    $0x7,%eax
c0000a3e:	75 1b                	jne    c0000a5b <_ZN4Acpi5clearENS_8RegisterEj+0x25>
        case GPE0_ENA:
            hw_write (&gpe0_ena, val, true);
            break;
        case GPE1_ENA:
            hw_write (&gpe1_ena, val, true);
c0000a40:	b9 01 00 00 00       	mov    $0x1,%ecx
c0000a45:	b8 98 a2 01 c0       	mov    $0xc001a298,%eax
c0000a4a:	eb 0a                	jmp    c0000a56 <_ZN4Acpi5clearENS_8RegisterEj+0x20>

void Acpi::clear (Register reg, unsigned val)
{
    switch (reg) {
        case GPE0_ENA:
            hw_write (&gpe0_ena, val, true);
c0000a4c:	b9 01 00 00 00       	mov    $0x1,%ecx
c0000a51:	b8 a4 a2 01 c0       	mov    $0xc001a2a4,%eax
            break;
        case GPE1_ENA:
            hw_write (&gpe1_ena, val, true);
c0000a56:	e9 67 ff ff ff       	jmp    c00009c2 <_ZN4Acpi8hw_writeEP8Acpi_gasjb>
            break;
        default:
            Console::panic ("Unimplemented register Acpi::clear");
c0000a5b:	68 a5 5f 01 c0       	push   $0xc0015fa5
c0000a60:	e8 e1 0e 00 00       	call   c0001946 <_ZN7Console5panicEPKcz>
c0000a65:	90                   	nop

c0000a66 <_ZN4Acpi5writeENS_8RegisterEj>:

void Acpi::write (Register reg, unsigned val)
{
    // XXX: Spec requires that certain bits be preserved.

    switch (reg) {
c0000a66:	83 f8 09             	cmp    $0x9,%eax
            break;
    }
}

void Acpi::write (Register reg, unsigned val)
{
c0000a69:	53                   	push   %ebx
    // XXX: Spec requires that certain bits be preserved.

    switch (reg) {
c0000a6a:	77 64                	ja     c0000ad0 <_ZN4Acpi5writeENS_8RegisterEj+0x6a>
c0000a6c:	89 d3                	mov    %edx,%ebx
c0000a6e:	ff 24 85 b4 60 01 c0 	jmp    *-0x3ffe9f4c(,%eax,4)
        case PM1_STS:
            hw_write (&pm1a_sts, val);
c0000a75:	31 c9                	xor    %ecx,%ecx
c0000a77:	b8 28 a3 01 c0       	mov    $0xc001a328,%eax
c0000a7c:	e8 41 ff ff ff       	call   c00009c2 <_ZN4Acpi8hw_writeEP8Acpi_gasjb>
            hw_write (&pm1b_sts, val);
c0000a81:	31 c9                	xor    %ecx,%ecx
c0000a83:	89 da                	mov    %ebx,%edx
c0000a85:	b8 1c a3 01 c0       	mov    $0xc001a31c,%eax
c0000a8a:	eb 3e                	jmp    c0000aca <_ZN4Acpi5writeENS_8RegisterEj+0x64>
            break;
        case PM1_ENA:
            hw_write (&pm1a_ena, val);
c0000a8c:	31 c9                	xor    %ecx,%ecx
c0000a8e:	b8 10 a3 01 c0       	mov    $0xc001a310,%eax
c0000a93:	e8 2a ff ff ff       	call   c00009c2 <_ZN4Acpi8hw_writeEP8Acpi_gasjb>
            hw_write (&pm1b_ena, val);
c0000a98:	31 c9                	xor    %ecx,%ecx
c0000a9a:	89 da                	mov    %ebx,%edx
c0000a9c:	b8 04 a3 01 c0       	mov    $0xc001a304,%eax
c0000aa1:	eb 27                	jmp    c0000aca <_ZN4Acpi5writeENS_8RegisterEj+0x64>
            break;
        case PM1_CNT:
            hw_write (&pm1a_cnt, val);
c0000aa3:	31 c9                	xor    %ecx,%ecx
c0000aa5:	b8 f8 a2 01 c0       	mov    $0xc001a2f8,%eax
c0000aaa:	e8 13 ff ff ff       	call   c00009c2 <_ZN4Acpi8hw_writeEP8Acpi_gasjb>
            hw_write (&pm1b_cnt, val);
c0000aaf:	31 c9                	xor    %ecx,%ecx
c0000ab1:	89 da                	mov    %ebx,%edx
c0000ab3:	b8 ec a2 01 c0       	mov    $0xc001a2ec,%eax
c0000ab8:	eb 10                	jmp    c0000aca <_ZN4Acpi5writeENS_8RegisterEj+0x64>
            break;
        case PM2_CNT:
            hw_write (&pm2_cnt, val);
c0000aba:	31 c9                	xor    %ecx,%ecx
c0000abc:	b8 e0 a2 01 c0       	mov    $0xc001a2e0,%eax
c0000ac1:	eb 07                	jmp    c0000aca <_ZN4Acpi5writeENS_8RegisterEj+0x64>
            break;
        case PM_TMR:                    // read-only
            break;
        case RESET:
            hw_write (&reset_reg, val);
c0000ac3:	31 c9                	xor    %ecx,%ecx
c0000ac5:	b8 c8 a2 01 c0       	mov    $0xc001a2c8,%eax
            break;
        default:
            Console::panic ("Unimplemented register Acpi::write");
            break;
    }
}
c0000aca:	5b                   	pop    %ebx
            hw_write (&pm2_cnt, val);
            break;
        case PM_TMR:                    // read-only
            break;
        case RESET:
            hw_write (&reset_reg, val);
c0000acb:	e9 f2 fe ff ff       	jmp    c00009c2 <_ZN4Acpi8hw_writeEP8Acpi_gasjb>
            break;
        default:
            Console::panic ("Unimplemented register Acpi::write");
c0000ad0:	68 c8 5f 01 c0       	push   $0xc0015fc8
c0000ad5:	e8 6c 0e 00 00       	call   c0001946 <_ZN7Console5panicEPKcz>
            break;
    }
}
c0000ada:	5b                   	pop    %ebx
c0000adb:	c3                   	ret    

c0000adc <_ZN4Acpi5resetEv>:
    return div64 (1000000 * ((tmr_ovf + ((c >> b ^ tmr_ovf) & 1)) * static_cast<uint64>(p) + (c & (p - 1))), timer_frequency, &dummy);
}

void Acpi::reset()
{
    write (RESET, reset_val);
c0000adc:	0f b6 15 8c a2 01 c0 	movzbl 0xc001a28c,%edx
c0000ae3:	b8 09 00 00 00       	mov    $0x9,%eax
c0000ae8:	e9 79 ff ff ff       	jmp    c0000a66 <_ZN4Acpi5writeENS_8RegisterEj>
c0000aed:	90                   	nop

c0000aee <_ZN4Acpi9interruptEv>:

    Console::panic ("Unimplemented ASID %d bits=%d prm=%u", gas->asid, gas->bits, prm);
}

void Acpi::interrupt()
{
c0000aee:	53                   	push   %ebx
    unsigned sts = read (PM1_STS);
c0000aef:	31 c0                	xor    %eax,%eax
c0000af1:	e8 20 fe ff ff       	call   c0000916 <_ZN4Acpi4readENS_8RegisterE>
c0000af6:	89 c3                	mov    %eax,%ebx
    unsigned ena = read (PM1_ENA);
c0000af8:	b8 01 00 00 00       	mov    $0x1,%eax
c0000afd:	e8 14 fe ff ff       	call   c0000916 <_ZN4Acpi4readENS_8RegisterE>

    if (sts & PM1_STS_TMR)
c0000b02:	f6 c3 01             	test   $0x1,%bl
c0000b05:	74 06                	je     c0000b0d <_ZN4Acpi9interruptEv+0x1f>
        tmr_ovf++;
c0000b07:	ff 05 94 a2 01 c0    	incl   0xc001a294

    unsigned dis = (sts & ena);
c0000b0d:	89 c2                	mov    %eax,%edx
c0000b0f:	21 da                	and    %ebx,%edx
    if (dis & PM1_ENA_TMR)
        dis ^= PM1_ENA_TMR;

    if (dis)
c0000b11:	83 e2 fe             	and    $0xfffffffe,%edx
c0000b14:	74 0c                	je     c0000b22 <_ZN4Acpi9interruptEv+0x34>
       write (PM1_ENA, ena ^ dis);
c0000b16:	31 c2                	xor    %eax,%edx
c0000b18:	b8 01 00 00 00       	mov    $0x1,%eax
c0000b1d:	e8 44 ff ff ff       	call   c0000a66 <_ZN4Acpi5writeENS_8RegisterEj>

    write (PM1_STS, sts);
c0000b22:	89 da                	mov    %ebx,%edx
c0000b24:	31 c0                	xor    %eax,%eax
}
c0000b26:	5b                   	pop    %ebx
        dis ^= PM1_ENA_TMR;

    if (dis)
       write (PM1_ENA, ena ^ dis);

    write (PM1_STS, sts);
c0000b27:	e9 3a ff ff ff       	jmp    c0000a66 <_ZN4Acpi5writeENS_8RegisterEj>

c0000b2c <_ZN8Spinlock4lockEv>:
                          "     je 2f;              "
                          "     pause;              "
                          "     movb %1, %b0;       "
                          "     jmp 1b;             "
                          "2:                       "
                          : "+Q" (tmp), "+m" (val) : : "memory");
c0000b2c:	ba 00 01 00 00       	mov    $0x100,%edx
c0000b31:	f0 66 0f c1 10       	lock xadd %dx,(%eax)
c0000b36:	38 f2                	cmp    %dh,%dl
c0000b38:	74 06                	je     c0000b40 <_ZN8Spinlock4lockEv+0x14>
c0000b3a:	f3 90                	pause  
c0000b3c:	8a 10                	mov    (%eax),%dl
c0000b3e:	eb f6                	jmp    c0000b36 <_ZN8Spinlock4lockEv+0xa>
c0000b40:	c3                   	ret    
c0000b41:	90                   	nop

c0000b42 <_ZN3Avl6rotateERPS_b>:

#include "avl.hpp"
#include "mdb.hpp"

Avl *Avl::rotate (Avl *&tree, bool d)
{
c0000b42:	57                   	push   %edi
c0000b43:	56                   	push   %esi
c0000b44:	53                   	push   %ebx
c0000b45:	0f b6 da             	movzbl %dl,%ebx
    Avl *node;

    node = tree;
c0000b48:	8b 08                	mov    (%eax),%ecx
    tree = node->lnk[d];
    node->lnk[d] = tree->lnk[!d];
c0000b4a:	80 f2 01             	xor    $0x1,%dl
c0000b4d:	0f b6 d2             	movzbl %dl,%edx
c0000b50:	8d 34 99             	lea    (%ecx,%ebx,4),%esi
Avl *Avl::rotate (Avl *&tree, bool d)
{
    Avl *node;

    node = tree;
    tree = node->lnk[d];
c0000b53:	8b 3e                	mov    (%esi),%edi
c0000b55:	89 38                	mov    %edi,(%eax)
    node->lnk[d] = tree->lnk[!d];
c0000b57:	8b 3c 97             	mov    (%edi,%edx,4),%edi
c0000b5a:	89 3e                	mov    %edi,(%esi)
    tree->lnk[!d] = node;
c0000b5c:	8b 30                	mov    (%eax),%esi
c0000b5e:	89 0c 96             	mov    %ecx,(%esi,%edx,4)

    node->bal = tree->bal = 2;
c0000b61:	8b 10                	mov    (%eax),%edx
c0000b63:	66 c7 42 08 02 00    	movw   $0x2,0x8(%edx)
c0000b69:	66 c7 41 08 02 00    	movw   $0x2,0x8(%ecx)

    return tree->lnk[d];
c0000b6f:	8b 00                	mov    (%eax),%eax
c0000b71:	8b 04 98             	mov    (%eax,%ebx,4),%eax
}
c0000b74:	5b                   	pop    %ebx
c0000b75:	5e                   	pop    %esi
c0000b76:	5f                   	pop    %edi
c0000b77:	c3                   	ret    

c0000b78 <_ZN3Avl6rotateERPS_bj>:

Avl *Avl::rotate (Avl *&tree, bool d, unsigned b)
{
c0000b78:	55                   	push   %ebp
c0000b79:	57                   	push   %edi
c0000b7a:	56                   	push   %esi
c0000b7b:	53                   	push   %ebx
    Avl *node[2];

    node[0] = tree;
    node[1] = node[0]->lnk[d];
c0000b7c:	0f b6 da             	movzbl %dl,%ebx

    return tree->lnk[d];
}

Avl *Avl::rotate (Avl *&tree, bool d, unsigned b)
{
c0000b7f:	83 ec 14             	sub    $0x14,%esp
    Avl *node[2];

    node[0] = tree;
    node[1] = node[0]->lnk[d];
    tree = node[1]->lnk[!d];
c0000b82:	80 f2 01             	xor    $0x1,%dl

Avl *Avl::rotate (Avl *&tree, bool d, unsigned b)
{
    Avl *node[2];

    node[0] = tree;
c0000b85:	8b 30                	mov    (%eax),%esi
    node[1] = node[0]->lnk[d];
    tree = node[1]->lnk[!d];
c0000b87:	0f b6 d2             	movzbl %dl,%edx
c0000b8a:	89 14 24             	mov    %edx,(%esp)
c0000b8d:	8d 3c 9e             	lea    (%esi,%ebx,4),%edi
c0000b90:	89 7c 24 04          	mov    %edi,0x4(%esp)
Avl *Avl::rotate (Avl *&tree, bool d, unsigned b)
{
    Avl *node[2];

    node[0] = tree;
    node[1] = node[0]->lnk[d];
c0000b94:	8b 3f                	mov    (%edi),%edi

Avl *Avl::rotate (Avl *&tree, bool d, unsigned b)
{
    Avl *node[2];

    node[0] = tree;
c0000b96:	89 74 24 0c          	mov    %esi,0xc(%esp)
c0000b9a:	8d 2c 97             	lea    (%edi,%edx,4),%ebp
c0000b9d:	89 6c 24 08          	mov    %ebp,0x8(%esp)
    node[1] = node[0]->lnk[d];
    tree = node[1]->lnk[!d];
c0000ba1:	8b 6d 00             	mov    0x0(%ebp),%ebp
Avl *Avl::rotate (Avl *&tree, bool d, unsigned b)
{
    Avl *node[2];

    node[0] = tree;
    node[1] = node[0]->lnk[d];
c0000ba4:	89 7c 24 10          	mov    %edi,0x10(%esp)
    tree = node[1]->lnk[!d];
c0000ba8:	89 28                	mov    %ebp,(%eax)

    node[0]->lnk[d] = tree->lnk[!d];
c0000baa:	8b 6c 95 00          	mov    0x0(%ebp,%edx,4),%ebp
c0000bae:	8b 54 24 04          	mov    0x4(%esp),%edx
c0000bb2:	89 2a                	mov    %ebp,(%edx)
    node[1]->lnk[!d] = tree->lnk[d];
c0000bb4:	8b 54 24 08          	mov    0x8(%esp),%edx
c0000bb8:	8b 28                	mov    (%eax),%ebp
c0000bba:	8b 6c 9d 00          	mov    0x0(%ebp,%ebx,4),%ebp
c0000bbe:	89 2a                	mov    %ebp,(%edx)

    tree->lnk[d] = node[1];
    tree->lnk[!d] = node[0];
c0000bc0:	8b 14 24             	mov    (%esp),%edx
    tree = node[1]->lnk[!d];

    node[0]->lnk[d] = tree->lnk[!d];
    node[1]->lnk[!d] = tree->lnk[d];

    tree->lnk[d] = node[1];
c0000bc3:	8b 28                	mov    (%eax),%ebp
c0000bc5:	89 7c 9d 00          	mov    %edi,0x0(%ebp,%ebx,4)
    tree->lnk[!d] = node[0];
c0000bc9:	8b 28                	mov    (%eax),%ebp
c0000bcb:	89 74 95 00          	mov    %esi,0x0(%ebp,%edx,4)

    tree->bal = node[0]->bal = node[1]->bal = 2;
c0000bcf:	8b 00                	mov    (%eax),%eax
c0000bd1:	66 c7 47 08 02 00    	movw   $0x2,0x8(%edi)
c0000bd7:	66 c7 46 08 02 00    	movw   $0x2,0x8(%esi)
c0000bdd:	66 c7 40 08 02 00    	movw   $0x2,0x8(%eax)

    if (b == 2)
        return nullptr;
c0000be3:	31 c0                	xor    %eax,%eax
    tree->lnk[d] = node[1];
    tree->lnk[!d] = node[0];

    tree->bal = node[0]->bal = node[1]->bal = 2;

    if (b == 2)
c0000be5:	83 f9 02             	cmp    $0x2,%ecx
c0000be8:	74 27                	je     c0000c11 <_ZN3Avl6rotateERPS_bj+0x99>
        return nullptr;

    node[b != d]->bal = !b;
c0000bea:	85 c9                	test   %ecx,%ecx
c0000bec:	0f 94 c0             	sete   %al
c0000bef:	31 d2                	xor    %edx,%edx
c0000bf1:	39 d9                	cmp    %ebx,%ecx
c0000bf3:	0f b6 f0             	movzbl %al,%esi
c0000bf6:	0f 95 c2             	setne  %dl

    return node[b == d]->lnk[!b];
c0000bf9:	0f b6 c0             	movzbl %al,%eax
    tree->bal = node[0]->bal = node[1]->bal = 2;

    if (b == 2)
        return nullptr;

    node[b != d]->bal = !b;
c0000bfc:	8b 54 94 0c          	mov    0xc(%esp,%edx,4),%edx
c0000c00:	66 89 72 08          	mov    %si,0x8(%edx)

    return node[b == d]->lnk[!b];
c0000c04:	0f 94 c2             	sete   %dl
c0000c07:	0f b6 d2             	movzbl %dl,%edx
c0000c0a:	8b 54 94 0c          	mov    0xc(%esp,%edx,4),%edx
c0000c0e:	8b 04 82             	mov    (%edx,%eax,4),%eax
}
c0000c11:	83 c4 14             	add    $0x14,%esp
c0000c14:	5b                   	pop    %ebx
c0000c15:	5e                   	pop    %esi
c0000c16:	5f                   	pop    %edi
c0000c17:	5d                   	pop    %ebp
c0000c18:	c3                   	ret    
c0000c19:	90                   	nop

c0000c1a <_ZN3Avl6insertI3MdbEEbPPS_S2_>:

template <typename S>
bool Avl::insert (Avl **tree, Avl *node)
c0000c1a:	55                   	push   %ebp
c0000c1b:	57                   	push   %edi
c0000c1c:	56                   	push   %esi
{
    Avl **p = tree;
c0000c1d:	89 c6                	mov    %eax,%esi

    return node[b == d]->lnk[!b];
}

template <typename S>
bool Avl::insert (Avl **tree, Avl *node)
c0000c1f:	53                   	push   %ebx
c0000c20:	89 d3                	mov    %edx,%ebx
c0000c22:	51                   	push   %ecx
{
    Avl **p = tree;

    for (Avl *n; (n = *tree); tree = n->lnk + static_cast<S *>(node)->larger (static_cast<S *>(n))) {
c0000c23:	8b 10                	mov    (%eax),%edx
c0000c25:	85 d2                	test   %edx,%edx
c0000c27:	74 38                	je     c0000c61 <_ZN3Avl6insertI3MdbEEbPPS_S2_+0x47>

        ALWAYS_INLINE
        inline bool larger (Mdb *x) const { return  node_base > x->node_base; }

        ALWAYS_INLINE
        inline bool equal  (Mdb *x) const { return (node_base ^ x->node_base) >> max (node_order, x->node_order) == 0; }
c0000c29:	8b 7a 30             	mov    0x30(%edx),%edi
c0000c2c:	8b 6b 30             	mov    0x30(%ebx),%ebp
c0000c2f:	89 f9                	mov    %edi,%ecx
c0000c31:	31 e9                	xor    %ebp,%ecx
c0000c33:	89 3c 24             	mov    %edi,(%esp)
c0000c36:	89 cf                	mov    %ecx,%edi
c0000c38:	8b 4a 34             	mov    0x34(%edx),%ecx
c0000c3b:	39 4b 34             	cmp    %ecx,0x34(%ebx)
c0000c3e:	0f 43 4b 34          	cmovae 0x34(%ebx),%ecx
c0000c42:	d3 ef                	shr    %cl,%edi

        if (static_cast<S *>(node)->equal (static_cast<S *>(n)))
c0000c44:	85 ff                	test   %edi,%edi
c0000c46:	0f 84 a4 00 00 00    	je     c0000cf0 <_ZN3Avl6insertI3MdbEEbPPS_S2_+0xd6>
            return false;

        if (!n->balanced())
c0000c4c:	66 83 7a 08 02       	cmpw   $0x2,0x8(%edx)
c0000c51:	0f 45 f0             	cmovne %eax,%esi
template <typename S>
bool Avl::insert (Avl **tree, Avl *node)
{
    Avl **p = tree;

    for (Avl *n; (n = *tree); tree = n->lnk + static_cast<S *>(node)->larger (static_cast<S *>(n))) {
c0000c54:	31 c0                	xor    %eax,%eax
c0000c56:	3b 2c 24             	cmp    (%esp),%ebp
c0000c59:	0f 97 c0             	seta   %al
c0000c5c:	8d 04 82             	lea    (%edx,%eax,4),%eax
c0000c5f:	eb c2                	jmp    c0000c23 <_ZN3Avl6insertI3MdbEEbPPS_S2_+0x9>

        if (!n->balanced())
            p = tree;
    }

    *tree = node;
c0000c61:	89 18                	mov    %ebx,(%eax)

    Avl *n = *p;
c0000c63:	8b 06                	mov    (%esi),%eax
c0000c65:	0f b7 68 08          	movzwl 0x8(%eax),%ebp

    if (!n->balanced()) {
c0000c69:	83 fd 02             	cmp    $0x2,%ebp
c0000c6c:	74 62                	je     c0000cd0 <_ZN3Avl6insertI3MdbEEbPPS_S2_+0xb6>
c0000c6e:	8b 7b 30             	mov    0x30(%ebx),%edi
        mword           node_attr;
        mword     const node_type;
        mword     const node_sub;

        ALWAYS_INLINE
        inline bool larger (Mdb *x) const { return  node_base > x->node_base; }
c0000c71:	3b 78 30             	cmp    0x30(%eax),%edi
c0000c74:	0f 97 c1             	seta   %cl

        bool d1, d2;

        if (n->bal != (d1 = static_cast<S *>(node)->larger (static_cast<S *>(n)))) {
c0000c77:	0f b6 d1             	movzbl %cl,%edx
c0000c7a:	39 ea                	cmp    %ebp,%edx
c0000c7c:	0f b6 d1             	movzbl %cl,%edx
c0000c7f:	74 08                	je     c0000c89 <_ZN3Avl6insertI3MdbEEbPPS_S2_+0x6f>
            n->bal = 2;
c0000c81:	66 c7 40 08 02 00    	movw   $0x2,0x8(%eax)
c0000c87:	eb 7e                	jmp    c0000d07 <_ZN3Avl6insertI3MdbEEbPPS_S2_+0xed>
            n = n->lnk[d1];
        } else if (d1 == (d2 = static_cast<S *>(node)->larger (static_cast<S *>(n->lnk[d1])))) {
c0000c89:	8b 2c 90             	mov    (%eax,%edx,4),%ebp
c0000c8c:	3b 7d 30             	cmp    0x30(%ebp),%edi
c0000c8f:	0f 97 c0             	seta   %al
c0000c92:	38 c1                	cmp    %al,%cl
c0000c94:	75 09                	jne    c0000c9f <_ZN3Avl6insertI3MdbEEbPPS_S2_+0x85>
            n = rotate (*p, d1);
c0000c96:	89 f0                	mov    %esi,%eax
c0000c98:	e8 a5 fe ff ff       	call   c0000b42 <_ZN3Avl6rotateERPS_b>
c0000c9d:	eb 31                	jmp    c0000cd0 <_ZN3Avl6insertI3MdbEEbPPS_S2_+0xb6>
        } else {
            n = n->lnk[d1]->lnk[d2];
c0000c9f:	0f b6 c0             	movzbl %al,%eax
c0000ca2:	8b 4c 85 00          	mov    0x0(%ebp,%eax,4),%ecx

        ALWAYS_INLINE
        inline bool equal  (Mdb *x) const { return (node_base ^ x->node_base) >> max (node_order, x->node_order) == 0; }
c0000ca6:	89 fd                	mov    %edi,%ebp
c0000ca8:	8b 41 30             	mov    0x30(%ecx),%eax
c0000cab:	8b 49 34             	mov    0x34(%ecx),%ecx
c0000cae:	31 c5                	xor    %eax,%ebp
c0000cb0:	39 4b 34             	cmp    %ecx,0x34(%ebx)
c0000cb3:	0f 43 4b 34          	cmovae 0x34(%ebx),%ecx
c0000cb7:	d3 ed                	shr    %cl,%ebp
            n = rotate (*p, d1, static_cast<S *>(node)->equal (static_cast<S *>(n)) ? 2 : static_cast<S *>(node)->larger (static_cast<S *>(n)));
c0000cb9:	b9 02 00 00 00       	mov    $0x2,%ecx
c0000cbe:	85 ed                	test   %ebp,%ebp
c0000cc0:	74 07                	je     c0000cc9 <_ZN3Avl6insertI3MdbEEbPPS_S2_+0xaf>
        mword           node_attr;
        mword     const node_type;
        mword     const node_sub;

        ALWAYS_INLINE
        inline bool larger (Mdb *x) const { return  node_base > x->node_base; }
c0000cc2:	31 c9                	xor    %ecx,%ecx
c0000cc4:	39 c7                	cmp    %eax,%edi
c0000cc6:	0f 97 c1             	seta   %cl
c0000cc9:	89 f0                	mov    %esi,%eax
c0000ccb:	e8 a8 fe ff ff       	call   c0000b78 <_ZN3Avl6rotateERPS_bj>
        }
    }

    for (bool d; n && !static_cast<S *>(node)->equal (static_cast<S *>(n)); n->bal = d, n = n->lnk[d])
c0000cd0:	85 c0                	test   %eax,%eax
c0000cd2:	74 20                	je     c0000cf4 <_ZN3Avl6insertI3MdbEEbPPS_S2_+0xda>

        ALWAYS_INLINE
        inline bool equal  (Mdb *x) const { return (node_base ^ x->node_base) >> max (node_order, x->node_order) == 0; }
c0000cd4:	8b 70 30             	mov    0x30(%eax),%esi
c0000cd7:	8b 7b 30             	mov    0x30(%ebx),%edi
c0000cda:	8b 48 34             	mov    0x34(%eax),%ecx
c0000cdd:	89 f2                	mov    %esi,%edx
c0000cdf:	31 fa                	xor    %edi,%edx
c0000ce1:	39 4b 34             	cmp    %ecx,0x34(%ebx)
c0000ce4:	0f 43 4b 34          	cmovae 0x34(%ebx),%ecx
c0000ce8:	d3 ea                	shr    %cl,%edx
c0000cea:	85 d2                	test   %edx,%edx
c0000cec:	75 0a                	jne    c0000cf8 <_ZN3Avl6insertI3MdbEEbPPS_S2_+0xde>
c0000cee:	eb 04                	jmp    c0000cf4 <_ZN3Avl6insertI3MdbEEbPPS_S2_+0xda>
    Avl **p = tree;

    for (Avl *n; (n = *tree); tree = n->lnk + static_cast<S *>(node)->larger (static_cast<S *>(n))) {

        if (static_cast<S *>(node)->equal (static_cast<S *>(n)))
            return false;
c0000cf0:	31 c0                	xor    %eax,%eax
c0000cf2:	eb 18                	jmp    c0000d0c <_ZN3Avl6insertI3MdbEEbPPS_S2_+0xf2>
    }

    for (bool d; n && !static_cast<S *>(node)->equal (static_cast<S *>(n)); n->bal = d, n = n->lnk[d])
        d = static_cast<S *>(node)->larger (static_cast<S *>(n));

    return true;
c0000cf4:	b0 01                	mov    $0x1,%al
c0000cf6:	eb 14                	jmp    c0000d0c <_ZN3Avl6insertI3MdbEEbPPS_S2_+0xf2>
        mword           node_attr;
        mword     const node_type;
        mword     const node_sub;

        ALWAYS_INLINE
        inline bool larger (Mdb *x) const { return  node_base > x->node_base; }
c0000cf8:	39 f7                	cmp    %esi,%edi
c0000cfa:	0f 97 c2             	seta   %dl
            n = n->lnk[d1]->lnk[d2];
            n = rotate (*p, d1, static_cast<S *>(node)->equal (static_cast<S *>(n)) ? 2 : static_cast<S *>(node)->larger (static_cast<S *>(n)));
        }
    }

    for (bool d; n && !static_cast<S *>(node)->equal (static_cast<S *>(n)); n->bal = d, n = n->lnk[d])
c0000cfd:	0f b6 ca             	movzbl %dl,%ecx
c0000d00:	0f b6 d2             	movzbl %dl,%edx
c0000d03:	66 89 48 08          	mov    %cx,0x8(%eax)
c0000d07:	8b 04 90             	mov    (%eax,%edx,4),%eax
c0000d0a:	eb c4                	jmp    c0000cd0 <_ZN3Avl6insertI3MdbEEbPPS_S2_+0xb6>
        d = static_cast<S *>(node)->larger (static_cast<S *>(n));

    return true;
}
c0000d0c:	5a                   	pop    %edx
c0000d0d:	5b                   	pop    %ebx
c0000d0e:	5e                   	pop    %esi
c0000d0f:	5f                   	pop    %edi
c0000d10:	5d                   	pop    %ebp
c0000d11:	c3                   	ret    

c0000d12 <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE>:

template <typename S>
bool Avl::remove (Avl **tree, Avl *node, State state)
c0000d12:	55                   	push   %ebp
c0000d13:	57                   	push   %edi
c0000d14:	56                   	push   %esi
c0000d15:	89 d6                	mov    %edx,%esi
c0000d17:	53                   	push   %ebx
c0000d18:	83 ec 1c             	sub    $0x1c,%esp
{
    Avl **p = tree, **item = nullptr;
    bool d = false;

    if (node->sta == state)
c0000d1b:	0f b7 52 0a          	movzwl 0xa(%edx),%edx

    return true;
}

template <typename S>
bool Avl::remove (Avl **tree, Avl *node, State state)
c0000d1f:	89 4c 24 14          	mov    %ecx,0x14(%esp)
c0000d23:	89 04 24             	mov    %eax,(%esp)
{
    Avl **p = tree, **item = nullptr;
    bool d = false;

    if (node->sta == state)
c0000d26:	39 ca                	cmp    %ecx,%edx
c0000d28:	0f 94 c1             	sete   %cl
        return false;

    if (node->sta == STALE)
c0000d2b:	83 fa 03             	cmp    $0x3,%edx
c0000d2e:	0f 94 c0             	sete   %al
c0000d31:	08 c8                	or     %cl,%al
c0000d33:	0f 85 a3 01 00 00    	jne    c0000edc <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0x1ca>
        return false;

    if (node->sta == KIM) {
c0000d39:	83 fa 02             	cmp    $0x2,%edx
c0000d3c:	74 0f                	je     c0000d4d <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0x3b>
c0000d3e:	8b 2c 24             	mov    (%esp),%ebp
c0000d41:	31 db                	xor    %ebx,%ebx
c0000d43:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0000d4a:	00 
c0000d4b:	eb 6f                	jmp    c0000dbc <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0xaa>
        node->sta = STALE;
c0000d4d:	66 c7 46 0a 03 00    	movw   $0x3,0xa(%esi)
c0000d53:	e9 80 01 00 00       	jmp    c0000ed8 <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0x1c6>

        ALWAYS_INLINE
        inline bool equal  (Mdb *x) const { return (node_base ^ x->node_base) >> max (node_order, x->node_order) == 0; }
c0000d58:	8b 7e 30             	mov    0x30(%esi),%edi
c0000d5b:	8b 5a 30             	mov    0x30(%edx),%ebx
c0000d5e:	8b 4a 34             	mov    0x34(%edx),%ecx
c0000d61:	31 fb                	xor    %edi,%ebx
c0000d63:	39 4e 34             	cmp    %ecx,0x34(%esi)
c0000d66:	0f 43 4e 34          	cmovae 0x34(%esi),%ecx
c0000d6a:	d3 eb                	shr    %cl,%ebx
        return true;
    }

    for (Avl *n; (n = *tree); tree = n->lnk + d) {

        if (static_cast<S *>(node)->equal (static_cast<S *>(n)))
c0000d6c:	85 db                	test   %ebx,%ebx
c0000d6e:	8b 5c 24 04          	mov    0x4(%esp),%ebx
c0000d72:	0f 44 1c 24          	cmove  (%esp),%ebx
        mword           node_attr;
        mword     const node_type;
        mword     const node_sub;

        ALWAYS_INLINE
        inline bool larger (Mdb *x) const { return  node_base > x->node_base; }
c0000d76:	3b 7a 30             	cmp    0x30(%edx),%edi
c0000d79:	89 5c 24 04          	mov    %ebx,0x4(%esp)
c0000d7d:	0f 97 c3             	seta   %bl
            item = tree;

        d = static_cast<S *>(node)->larger (static_cast<S *>(n));

        if (!n->lnk[d])
c0000d80:	0f b6 cb             	movzbl %bl,%ecx
c0000d83:	83 3c 8a 00          	cmpl   $0x0,(%edx,%ecx,4)
c0000d87:	74 43                	je     c0000dcc <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0xba>
c0000d89:	0f b7 7a 08          	movzwl 0x8(%edx),%edi
            break;

        if (n->balanced() || (n->bal == !d && n->lnk[!d]->balanced()))
c0000d8d:	83 ff 02             	cmp    $0x2,%edi
c0000d90:	89 7c 24 08          	mov    %edi,0x8(%esp)
c0000d94:	74 31                	je     c0000dc7 <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0xb5>
c0000d96:	88 d9                	mov    %bl,%cl
c0000d98:	80 f1 01             	xor    $0x1,%cl
c0000d9b:	0f b6 f9             	movzbl %cl,%edi
c0000d9e:	3b 7c 24 08          	cmp    0x8(%esp),%edi
c0000da2:	75 0f                	jne    c0000db3 <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0xa1>
c0000da4:	0f b6 c9             	movzbl %cl,%ecx
c0000da7:	8b 0c 8a             	mov    (%edx,%ecx,4),%ecx
c0000daa:	66 83 79 08 02       	cmpw   $0x2,0x8(%ecx)
c0000daf:	0f 44 2c 24          	cmove  (%esp),%ebp
    if (node->sta == KIM) {
        node->sta = STALE;
        return true;
    }

    for (Avl *n; (n = *tree); tree = n->lnk + d) {
c0000db3:	0f b6 cb             	movzbl %bl,%ecx
c0000db6:	8d 3c 8a             	lea    (%edx,%ecx,4),%edi
c0000db9:	89 3c 24             	mov    %edi,(%esp)
c0000dbc:	8b 3c 24             	mov    (%esp),%edi
c0000dbf:	8b 17                	mov    (%edi),%edx
c0000dc1:	85 d2                	test   %edx,%edx
c0000dc3:	75 93                	jne    c0000d58 <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0x46>
c0000dc5:	eb 05                	jmp    c0000dcc <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0xba>
c0000dc7:	8b 2c 24             	mov    (%esp),%ebp
c0000dca:	eb e7                	jmp    c0000db3 <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0xa1>

        if (n->balanced() || (n->bal == !d && n->lnk[!d]->balanced()))
            p = tree;
    }

    if (!item)
c0000dcc:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
c0000dd1:	0f 84 07 01 00 00    	je     c0000ede <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0x1cc>
        return false;

    for (Avl *n; (n = *p); p = n->lnk + d) {
c0000dd7:	8b 7d 00             	mov    0x0(%ebp),%edi
c0000dda:	85 ff                	test   %edi,%edi
c0000ddc:	0f 84 c3 00 00 00    	je     c0000ea5 <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0x193>
c0000de2:	8b 47 30             	mov    0x30(%edi),%eax
c0000de5:	39 46 30             	cmp    %eax,0x30(%esi)
c0000de8:	0f 97 c3             	seta   %bl

        d = static_cast<S *>(node)->larger (static_cast <S *>(n));

        if (!n->lnk[d])
c0000deb:	0f b6 c3             	movzbl %bl,%eax
c0000dee:	83 3c 87 00          	cmpl   $0x0,(%edi,%eax,4)
c0000df2:	89 44 24 08          	mov    %eax,0x8(%esp)
c0000df6:	0f 84 a9 00 00 00    	je     c0000ea5 <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0x193>
c0000dfc:	0f b7 47 08          	movzwl 0x8(%edi),%eax
            break;

        if (n->balanced())
c0000e00:	83 f8 02             	cmp    $0x2,%eax
c0000e03:	75 10                	jne    c0000e15 <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0x103>
            n->bal = !d;
c0000e05:	88 d8                	mov    %bl,%al
c0000e07:	34 01                	xor    $0x1,%al
c0000e09:	0f b6 c0             	movzbl %al,%eax
c0000e0c:	66 89 47 08          	mov    %ax,0x8(%edi)
c0000e10:	e9 85 00 00 00       	jmp    c0000e9a <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0x188>

        else if (n->bal == d)
c0000e15:	0f b6 d3             	movzbl %bl,%edx
c0000e18:	39 d0                	cmp    %edx,%eax
c0000e1a:	66 89 54 24 18       	mov    %dx,0x18(%esp)
c0000e1f:	75 08                	jne    c0000e29 <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0x117>
            n->bal = 2;
c0000e21:	66 c7 47 08 02 00    	movw   $0x2,0x8(%edi)
c0000e27:	eb 71                	jmp    c0000e9a <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0x188>

        else {
            unsigned b = n->lnk[!d]->bal;
c0000e29:	88 d9                	mov    %bl,%cl
c0000e2b:	80 f1 01             	xor    $0x1,%cl
c0000e2e:	0f b6 c1             	movzbl %cl,%eax
c0000e31:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0000e35:	8b 04 87             	mov    (%edi,%eax,4),%eax
c0000e38:	0f b7 50 08          	movzwl 0x8(%eax),%edx

            if (b == d)
c0000e3c:	3b 54 24 08          	cmp    0x8(%esp),%edx

        else if (n->bal == d)
            n->bal = 2;

        else {
            unsigned b = n->lnk[!d]->bal;
c0000e40:	89 54 24 10          	mov    %edx,0x10(%esp)

            if (b == d)
c0000e44:	75 18                	jne    c0000e5e <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0x14c>
                rotate (*p, !d, n->lnk[!d]->lnk[d]->bal);
c0000e46:	8b 54 24 08          	mov    0x8(%esp),%edx
c0000e4a:	8b 04 90             	mov    (%eax,%edx,4),%eax
c0000e4d:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0000e51:	0f b7 48 08          	movzwl 0x8(%eax),%ecx
c0000e55:	89 e8                	mov    %ebp,%eax
c0000e57:	e8 1c fd ff ff       	call   c0000b78 <_ZN3Avl6rotateERPS_bj>
c0000e5c:	eb 2a                	jmp    c0000e88 <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0x176>
            else {
                rotate (*p, !d);
c0000e5e:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0000e62:	89 e8                	mov    %ebp,%eax
c0000e64:	88 4c 24 1b          	mov    %cl,0x1b(%esp)
c0000e68:	e8 d5 fc ff ff       	call   c0000b42 <_ZN3Avl6rotateERPS_b>

                if (b == 2) {
c0000e6d:	0f b6 4c 24 1b       	movzbl 0x1b(%esp),%ecx
c0000e72:	83 7c 24 10 02       	cmpl   $0x2,0x10(%esp)
c0000e77:	75 0f                	jne    c0000e88 <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0x176>
                   n->bal = !d;
c0000e79:	66 89 4f 08          	mov    %cx,0x8(%edi)
                   (*p)->bal = d;
c0000e7d:	8b 54 24 18          	mov    0x18(%esp),%edx
c0000e81:	8b 45 00             	mov    0x0(%ebp),%eax
c0000e84:	66 89 50 08          	mov    %dx,0x8(%eax)
                }
            }

            if (n == node)
c0000e88:	39 f7                	cmp    %esi,%edi
c0000e8a:	75 0e                	jne    c0000e9a <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0x188>
                item = (*p)->lnk + d;
c0000e8c:	8b 44 24 08          	mov    0x8(%esp),%eax
c0000e90:	8b 55 00             	mov    0x0(%ebp),%edx
c0000e93:	8d 04 82             	lea    (%edx,%eax,4),%eax
c0000e96:	89 44 24 04          	mov    %eax,0x4(%esp)
    }

    if (!item)
        return false;

    for (Avl *n; (n = *p); p = n->lnk + d) {
c0000e9a:	0f b6 c3             	movzbl %bl,%eax
c0000e9d:	8d 2c 87             	lea    (%edi,%eax,4),%ebp
c0000ea0:	e9 32 ff ff ff       	jmp    c0000dd7 <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0xc5>
            if (n == node)
                item = (*p)->lnk + d;
        }
    }

    Avl *n = *tree;
c0000ea5:	8b 04 24             	mov    (%esp),%eax

    *item = n;
    *tree = n->lnk[!d];
c0000ea8:	80 f3 01             	xor    $0x1,%bl
        }
    }

    Avl *n = *tree;

    *item = n;
c0000eab:	8b 7c 24 04          	mov    0x4(%esp),%edi
    *tree = n->lnk[!d];
c0000eaf:	0f b6 db             	movzbl %bl,%ebx
            if (n == node)
                item = (*p)->lnk + d;
        }
    }

    Avl *n = *tree;
c0000eb2:	8b 00                	mov    (%eax),%eax

    *item = n;
c0000eb4:	89 07                	mov    %eax,(%edi)
    *tree = n->lnk[!d];
c0000eb6:	8b 14 98             	mov    (%eax,%ebx,4),%edx
c0000eb9:	8b 1c 24             	mov    (%esp),%ebx
c0000ebc:	89 13                	mov    %edx,(%ebx)
    n->lnk[0] = node->lnk[0];
c0000ebe:	8b 16                	mov    (%esi),%edx
c0000ec0:	89 10                	mov    %edx,(%eax)
    n->lnk[1] = node->lnk[1];
c0000ec2:	8b 56 04             	mov    0x4(%esi),%edx
c0000ec5:	89 50 04             	mov    %edx,0x4(%eax)
    n->bal    = node->bal;
c0000ec8:	0f b7 56 08          	movzwl 0x8(%esi),%edx
c0000ecc:	66 89 50 08          	mov    %dx,0x8(%eax)

    node->sta = state;
c0000ed0:	8b 44 24 14          	mov    0x14(%esp),%eax
c0000ed4:	66 89 46 0a          	mov    %ax,0xa(%esi)

    return true;
c0000ed8:	b0 01                	mov    $0x1,%al
c0000eda:	eb 02                	jmp    c0000ede <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0x1cc>

    if (node->sta == state)
        return false;

    if (node->sta == STALE)
        return false;
c0000edc:	31 c0                	xor    %eax,%eax
    n->bal    = node->bal;

    node->sta = state;

    return true;
}
c0000ede:	83 c4 1c             	add    $0x1c,%esp
c0000ee1:	5b                   	pop    %ebx
c0000ee2:	5e                   	pop    %esi
c0000ee3:	5f                   	pop    %edi
c0000ee4:	5d                   	pop    %ebp
c0000ee5:	c3                   	ret    

c0000ee6 <bootstrap>:
#include "hip.hpp"
#include "msr.hpp"

extern "C" NORETURN
void bootstrap()
{
c0000ee6:	56                   	push   %esi
c0000ee7:	53                   	push   %ebx
    static mword barrier;

    Cpu::init();
c0000ee8:	e8 55 0f 00 00       	call   c0001e42 <_ZN3Cpu4initEv>
        static void die (char const *, Exc_regs * = &current->regs);

        static void idl_handler();

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
c0000eed:	ba 50 b4 01 c0       	mov    $0xc001b450,%edx
c0000ef2:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax

    // Create idle EC
    Ec::current = new (Pd::kern.quota) Ec (Pd::current = &Pd::kern, Ec::idle, Cpu::id);
c0000ef7:	c7 05 0c f0 ff cf c0 	movl   $0xc001b2c0,0xcffff00c
c0000efe:	b2 01 c0 
c0000f01:	e8 70 f3 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c0000f06:	ba c0 b2 01 c0       	mov    $0xc001b2c0,%edx
c0000f0b:	b9 06 3a 00 c0       	mov    $0xc0003a06,%ecx
c0000f10:	ff 35 04 f0 ff cf    	pushl  0xcffff004
c0000f16:	89 c3                	mov    %eax,%ebx
c0000f18:	e8 9d 1d 00 00       	call   c0002cba <_ZN2EcC1EP2PdPFvvEj>
c0000f1d:	5a                   	pop    %edx
c0000f1e:	89 1d 08 f0 ff cf    	mov    %ebx,0xcffff008
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0000f24:	8b 43 48             	mov    0x48(%ebx),%eax
c0000f27:	85 c0                	test   %eax,%eax
c0000f29:	74 0a                	je     c0000f35 <bootstrap+0x4f>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0000f2b:	8d 50 01             	lea    0x1(%eax),%edx
c0000f2e:	f0 0f b1 53 48       	lock cmpxchg %edx,0x48(%ebx)
c0000f33:	75 ef                	jne    c0000f24 <bootstrap+0x3e>
    Ec::current->add_ref();
    Pd::current->add_ref();
c0000f35:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0000f3b:	8b 42 48             	mov    0x48(%edx),%eax
c0000f3e:	85 c0                	test   %eax,%eax
c0000f40:	74 0a                	je     c0000f4c <bootstrap+0x66>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0000f42:	8d 48 01             	lea    0x1(%eax),%ecx
c0000f45:	f0 0f b1 4a 48       	lock cmpxchg %ecx,0x48(%edx)
c0000f4a:	75 ef                	jne    c0000f3b <bootstrap+0x55>

        NORETURN
        static void schedule (bool = false, bool = true);

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
c0000f4c:	ba 50 b4 01 c0       	mov    $0xc001b450,%edx
c0000f51:	b8 98 b4 01 c0       	mov    $0xc001b498,%eax
c0000f56:	e8 1b f3 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
    Space_obj::insert_root (Pd::kern.quota, Sc::current = new (Pd::kern.quota) Sc (&Pd::kern, Cpu::id, Ec::current));
c0000f5b:	8b 0d 04 f0 ff cf    	mov    0xcffff004,%ecx
c0000f61:	ba c0 b2 01 c0       	mov    $0xc001b2c0,%edx
c0000f66:	ff 35 08 f0 ff cf    	pushl  0xcffff008
c0000f6c:	89 c3                	mov    %eax,%ebx
c0000f6e:	e8 e1 e3 00 00       	call   c000f354 <_ZN2ScC1EP2PdmP2Ec>
c0000f73:	89 da                	mov    %ebx,%edx
c0000f75:	b8 50 b4 01 c0       	mov    $0xc001b450,%eax
c0000f7a:	89 1d 10 f0 ff cf    	mov    %ebx,0xcffff010
c0000f80:	e8 37 01 01 00       	call   c00110bc <_ZN9Space_obj11insert_rootER5QuotaP7Kobject>
    Sc::current->add_ref();
c0000f85:	8b 15 10 f0 ff cf    	mov    0xcffff010,%edx
c0000f8b:	58                   	pop    %eax
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0000f8c:	8b 42 48             	mov    0x48(%edx),%eax
c0000f8f:	83 f8 ff             	cmp    $0xffffffff,%eax
c0000f92:	74 0a                	je     c0000f9e <bootstrap+0xb8>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0000f94:	8d 48 01             	lea    0x1(%eax),%ecx
c0000f97:	f0 0f b1 4a 48       	lock cmpxchg %ecx,0x48(%edx)
c0000f9c:	75 ee                	jne    c0000f8c <bootstrap+0xa6>

        template <typename T>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }
c0000f9e:	f0 ff 05 50 a3 01 c0 	lock incl 0xc001a350

    // Barrier: wait for all ECs to arrive here
    for (Atomic::add (barrier, 1UL); barrier != Cpu::online; pause()) ;
c0000fa5:	a1 40 a4 01 c0       	mov    0xc001a440,%eax
c0000faa:	39 05 50 a3 01 c0    	cmp    %eax,0xc001a350
c0000fb0:	74 04                	je     c0000fb6 <bootstrap+0xd0>
c0000fb2:	f3 90                	pause  
c0000fb4:	eb ef                	jmp    c0000fa5 <bootstrap+0xbf>

        template <typename T>
        ALWAYS_INLINE
        static inline void write (Register msr, T val)
        {
            asm volatile ("wrmsr" : : "a" (static_cast<mword>(val)), "d" (static_cast<mword>(static_cast<uint64>(val) >> 32)), "c" (msr));
c0000fb6:	31 c0                	xor    %eax,%eax
c0000fb8:	b9 10 00 00 00       	mov    $0x10,%ecx
c0000fbd:	89 c2                	mov    %eax,%edx
c0000fbf:	0f 30                	wrmsr  

    Msr::write<uint64>(Msr::IA32_TSC, 0);

    // Create root task
    if (Cpu::bsp) {
c0000fc1:	80 3d 01 f7 ff cf 00 	cmpb   $0x0,0xcffff701
c0000fc8:	74 78                	je     c0001042 <bootstrap+0x15c>
        Hip::add_check();
c0000fca:	e8 a9 4a 00 00       	call   c0005a78 <_ZN3Hip9add_checkEv>
c0000fcf:	ba 90 b2 01 c0       	mov    $0xc001b290,%edx
c0000fd4:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c0000fd9:	e8 98 f2 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
        Ec *root_ec = new (Pd::root.quota) Ec (&Pd::root, NUM_EXC + 1, &Pd::root, Ec::root_invoke, Cpu::id, 0, USER_ADDR - 2 * PAGE_SIZE, 0, nullptr);
c0000fde:	b9 21 00 00 00       	mov    $0x21,%ecx
c0000fe3:	ba 00 b1 01 c0       	mov    $0xc001b100,%edx
c0000fe8:	6a 00                	push   $0x0
c0000fea:	6a 00                	push   $0x0
c0000fec:	68 00 e0 ff bf       	push   $0xbfffe000
c0000ff1:	6a 00                	push   $0x0
c0000ff3:	ff 35 04 f0 ff cf    	pushl  0xcffff004
c0000ff9:	89 c6                	mov    %eax,%esi
c0000ffb:	68 fc 3b 00 c0       	push   $0xc0003bfc
c0001000:	68 00 b1 01 c0       	push   $0xc001b100
c0001005:	e8 ce 1d 00 00       	call   c0002dd8 <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt>
c000100a:	ba 90 b2 01 c0       	mov    $0xc001b290,%edx
c000100f:	b8 98 b4 01 c0       	mov    $0xc001b498,%eax
c0001014:	e8 5d f2 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
        Sc *root_sc = new (Pd::root.quota) Sc (&Pd::root, NUM_EXC + 2, root_ec, Cpu::id, Sc::default_prio, Sc::default_quantum);
c0001019:	b9 22 00 00 00       	mov    $0x22,%ecx
c000101e:	ba 00 b1 01 c0       	mov    $0xc001b100,%edx
c0001023:	68 10 27 00 00       	push   $0x2710
c0001028:	6a 01                	push   $0x1
c000102a:	ff 35 04 f0 ff cf    	pushl  0xcffff004
c0001030:	89 c3                	mov    %eax,%ebx
c0001032:	56                   	push   %esi
c0001033:	e8 b4 e3 00 00       	call   c000f3ec <_ZN2ScC1EP2PdmP2Ecjjj>
        root_sc->remote_enqueue();
c0001038:	83 c4 2c             	add    $0x2c,%esp
c000103b:	89 d8                	mov    %ebx,%eax
c000103d:	e8 fa e6 00 00       	call   c000f73c <_ZN2Sc14remote_enqueueEv>
    }

    Sc::schedule();
c0001042:	ba 01 00 00 00       	mov    $0x1,%edx
c0001047:	31 c0                	xor    %eax,%eax
c0001049:	e8 64 e9 00 00       	call   c000f9b2 <_ZN2Sc8scheduleEbb>

c000104e <_ZN5Quota5allocEm>:

        static Quota init;

        Quota () : used(0), over(0), upli(0), notr(0) { }

        void alloc(mword p)
c000104e:	57                   	push   %edi
c000104f:	89 d7                	mov    %edx,%edi
c0001051:	56                   	push   %esi
c0001052:	89 c6                	mov    %eax,%esi
c0001054:	53                   	push   %ebx

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c0001055:	9c                   	pushf  
c0001056:	5b                   	pop    %ebx
            return flags & 0x200;
c0001057:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c000105a:	80 e3 01             	and    $0x1,%bl
c000105d:	74 27                	je     c0001086 <_ZN5Quota5allocEm+0x38>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c000105f:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0001066:	75 16                	jne    c000107e <_ZN5Quota5allocEm+0x30>
c0001068:	68 c0 64 01 c0       	push   $0xc00164c0
c000106d:	68 b7 00 00 00       	push   $0xb7
c0001072:	68 12 61 01 c0       	push   $0xc0016112
c0001077:	68 83 61 01 c0       	push   $0xc0016183
c000107c:	eb 35                	jmp    c00010b3 <_ZN5Quota5allocEm+0x65>

            asm volatile ("cli" : : : "memory");
c000107e:	fa                   	cli    
            preemption = false;
c000107f:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c0001086:	89 f0                	mov    %esi,%eax
c0001088:	e8 9f fa ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
        {
            Lock_guard <Spinlock> guard (lock);
            used += p;
c000108d:	01 7e 04             	add    %edi,0x4(%esi)
        }

        ALWAYS_INLINE
        inline void unlock()
        {
            asm volatile ("incb %0" : "=m" (val) : : "memory");
c0001090:	fe 06                	incb   (%esi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c0001092:	84 db                	test   %bl,%bl
c0001094:	74 2f                	je     c00010c5 <_ZN5Quota5allocEm+0x77>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0001096:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000109d:	74 1e                	je     c00010bd <_ZN5Quota5allocEm+0x6f>
c000109f:	68 80 64 01 c0       	push   $0xc0016480
c00010a4:	68 c0 00 00 00       	push   $0xc0
c00010a9:	68 12 61 01 c0       	push   $0xc0016112
c00010ae:	68 82 61 01 c0       	push   $0xc0016182
c00010b3:	68 69 60 01 c0       	push   $0xc0016069
c00010b8:	e8 89 08 00 00       	call   c0001946 <_ZN7Console5panicEPKcz>

            preemption = true;
c00010bd:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c00010c4:	fb                   	sti    
        }
c00010c5:	5b                   	pop    %ebx
c00010c6:	5e                   	pop    %esi
c00010c7:	5f                   	pop    %edi
c00010c8:	c3                   	ret    
c00010c9:	90                   	nop

c00010ca <_ZN5Quota4freeEm>:

        void free(mword p)
c00010ca:	56                   	push   %esi
c00010cb:	89 d6                	mov    %edx,%esi
c00010cd:	53                   	push   %ebx
c00010ce:	89 c3                	mov    %eax,%ebx
c00010d0:	51                   	push   %ecx

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c00010d1:	9c                   	pushf  
c00010d2:	59                   	pop    %ecx
            return flags & 0x200;
c00010d3:	c1 e9 09             	shr    $0x9,%ecx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c00010d6:	80 e1 01             	and    $0x1,%cl
c00010d9:	74 27                	je     c0001102 <_ZN5Quota4freeEm+0x38>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c00010db:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c00010e2:	75 16                	jne    c00010fa <_ZN5Quota4freeEm+0x30>
c00010e4:	68 c0 64 01 c0       	push   $0xc00164c0
c00010e9:	68 b7 00 00 00       	push   $0xb7
c00010ee:	68 12 61 01 c0       	push   $0xc0016112
c00010f3:	68 83 61 01 c0       	push   $0xc0016183
c00010f8:	eb 46                	jmp    c0001140 <_ZN5Quota4freeEm+0x76>

            asm volatile ("cli" : : : "memory");
c00010fa:	fa                   	cli    
            preemption = false;
c00010fb:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c0001102:	89 d8                	mov    %ebx,%eax
c0001104:	88 4c 24 03          	mov    %cl,0x3(%esp)
c0001108:	e8 1f fa ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
        {
            Lock_guard <Spinlock> guard (lock);

            if (p <= used) {
c000110d:	8b 43 04             	mov    0x4(%ebx),%eax
c0001110:	8a 4c 24 03          	mov    0x3(%esp),%cl
c0001114:	39 c6                	cmp    %eax,%esi
c0001116:	77 32                	ja     c000114a <_ZN5Quota4freeEm+0x80>
                used -= p;
c0001118:	29 f0                	sub    %esi,%eax
c000111a:	89 43 04             	mov    %eax,0x4(%ebx)
c000111d:	fe 03                	incb   (%ebx)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c000111f:	84 c9                	test   %cl,%cl
c0001121:	74 40                	je     c0001163 <_ZN5Quota4freeEm+0x99>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0001123:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000112a:	74 2f                	je     c000115b <_ZN5Quota4freeEm+0x91>
c000112c:	68 80 64 01 c0       	push   $0xc0016480
c0001131:	68 c0 00 00 00       	push   $0xc0
c0001136:	68 12 61 01 c0       	push   $0xc0016112
c000113b:	68 82 61 01 c0       	push   $0xc0016182
c0001140:	68 69 60 01 c0       	push   $0xc0016069
c0001145:	e8 fc 07 00 00       	call   c0001946 <_ZN7Console5panicEPKcz>
                return;
            }

            over += p - used;
c000114a:	29 c6                	sub    %eax,%esi
c000114c:	01 73 08             	add    %esi,0x8(%ebx)
            upli += p - used;
c000114f:	01 73 0c             	add    %esi,0xc(%ebx)
            used = 0;
c0001152:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
c0001159:	eb c2                	jmp    c000111d <_ZN5Quota4freeEm+0x53>

            preemption = true;
c000115b:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c0001162:	fb                   	sti    
        }
c0001163:	58                   	pop    %eax
c0001164:	5b                   	pop    %ebx
c0001165:	5e                   	pop    %esi
c0001166:	c3                   	ret    
c0001167:	90                   	nop

c0001168 <_ZN5Buddy4freeEmR5Quota>:
/*
 * Free physically contiguous memory region.
 * @param virt     Linear block base address
 */
void Buddy::free (mword virt, Quota &quota)
{
c0001168:	55                   	push   %ebp
c0001169:	57                   	push   %edi
c000116a:	56                   	push   %esi
c000116b:	89 c6                	mov    %eax,%esi
c000116d:	53                   	push   %ebx
c000116e:	89 c8                	mov    %ecx,%eax
c0001170:	53                   	push   %ebx
        }

        ALWAYS_INLINE
        inline signed long page_to_index (mword l_addr)
        {
            return l_addr / PAGE_SIZE - base / PAGE_SIZE;
c0001171:	89 d3                	mov    %edx,%ebx
c0001173:	8b 4e 0c             	mov    0xc(%esi),%ecx
c0001176:	c1 eb 0c             	shr    $0xc,%ebx
c0001179:	c1 e9 0c             	shr    $0xc,%ecx
c000117c:	29 cb                	sub    %ecx,%ebx
    signed long idx = page_to_index (virt);

    // Ensure virt is within allocator range
    assert (idx >= min_idx && idx < max_idx);
c000117e:	3b 5e 08             	cmp    0x8(%esi),%ebx
c0001181:	0f 8c 62 01 00 00    	jl     c00012e9 <_ZN5Buddy4freeEmR5Quota+0x181>
c0001187:	3b 5e 04             	cmp    0x4(%esi),%ebx
c000118a:	0f 8d 59 01 00 00    	jge    c00012e9 <_ZN5Buddy4freeEmR5Quota+0x181>
        }

        ALWAYS_INLINE
        inline Block *index_to_block (signed long i)
        {
            return index + i;
c0001190:	6b db 0c             	imul   $0xc,%ebx,%ebx
c0001193:	03 5e 14             	add    0x14(%esi),%ebx

    Block *block = index_to_block (idx);

    // Ensure block is marked as used
    assert (block->tag == Block::Used);
c0001196:	66 83 7b 0a 00       	cmpw   $0x0,0xa(%ebx)
c000119b:	74 16                	je     c00011b3 <_ZN5Buddy4freeEmR5Quota+0x4b>
c000119d:	68 60 64 01 c0       	push   $0xc0016460
c00011a2:	68 8c 00 00 00       	push   $0x8c
c00011a7:	68 03 62 01 c0       	push   $0xc0016203
c00011ac:	68 71 62 01 c0       	push   $0xc0016271
c00011b1:	eb 34                	jmp    c00011e7 <_ZN5Buddy4freeEmR5Quota+0x7f>

    // Ensure corresponding physical block is order-aligned
    assert ((virt_to_phys (virt) & ((1ul << (block->ord + PAGE_BITS)) - 1)) == 0);
c00011b3:	0f b7 7b 08          	movzwl 0x8(%ebx),%edi
        }

        ALWAYS_INLINE
        inline mword virt_to_phys (mword virt)
        {
            return virt - reinterpret_cast<mword>(&OFFSET);
c00011b7:	81 ea 00 00 c0 bf    	sub    $0xbfc00000,%edx
c00011bd:	8d 4f 0c             	lea    0xc(%edi),%ecx
c00011c0:	89 3c 24             	mov    %edi,(%esp)
c00011c3:	bf 01 00 00 00       	mov    $0x1,%edi
c00011c8:	89 fd                	mov    %edi,%ebp
c00011ca:	d3 e5                	shl    %cl,%ebp
c00011cc:	89 e9                	mov    %ebp,%ecx
c00011ce:	49                   	dec    %ecx
c00011cf:	85 d1                	test   %edx,%ecx
c00011d1:	74 1e                	je     c00011f1 <_ZN5Buddy4freeEmR5Quota+0x89>
c00011d3:	68 60 64 01 c0       	push   $0xc0016460
c00011d8:	68 8f 00 00 00       	push   $0x8f
c00011dd:	68 03 62 01 c0       	push   $0xc0016203
c00011e2:	68 8b 62 01 c0       	push   $0xc001628b
c00011e7:	68 69 60 01 c0       	push   $0xc0016069
c00011ec:	e8 55 07 00 00       	call   c0001946 <_ZN7Console5panicEPKcz>

    quota.free(1ul << block->ord);
c00011f1:	8a 0c 24             	mov    (%esp),%cl
c00011f4:	d3 e7                	shl    %cl,%edi
c00011f6:	89 fa                	mov    %edi,%edx
c00011f8:	e8 cd fe ff ff       	call   c00010ca <_ZN5Quota4freeEm>

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c00011fd:	9c                   	pushf  
c00011fe:	58                   	pop    %eax
            return flags & 0x200;
c00011ff:	c1 e8 09             	shr    $0x9,%eax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c0001202:	24 01                	and    $0x1,%al
c0001204:	88 04 24             	mov    %al,(%esp)
c0001207:	74 27                	je     c0001230 <_ZN5Buddy4freeEmR5Quota+0xc8>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0001209:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0001210:	75 16                	jne    c0001228 <_ZN5Buddy4freeEmR5Quota+0xc0>
c0001212:	68 c0 64 01 c0       	push   $0xc00164c0
c0001217:	68 b7 00 00 00       	push   $0xb7
c000121c:	68 12 61 01 c0       	push   $0xc0016112
c0001221:	68 83 61 01 c0       	push   $0xc0016183
c0001226:	eb bf                	jmp    c00011e7 <_ZN5Buddy4freeEmR5Quota+0x7f>

            asm volatile ("cli" : : : "memory");
c0001228:	fa                   	cli    
            preemption = false;
c0001229:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c0001230:	89 f0                	mov    %esi,%eax
    unsigned short ord;
    for (ord = block->ord; ord < order - 1; ord++) {

        // Compute block index and corresponding buddy index
        signed long block_idx = block_to_index (block);
        signed long buddy_idx = block_idx ^ (1ul << ord);
c0001232:	bf 01 00 00 00       	mov    $0x1,%edi
c0001237:	e8 f0 f8 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    quota.free(1ul << block->ord);

    Lock_guard <Spinlock> guard (lock);

    unsigned short ord;
    for (ord = block->ord; ord < order - 1; ord++) {
c000123c:	0f b7 4b 08          	movzwl 0x8(%ebx),%ecx
c0001240:	8b 46 10             	mov    0x10(%esi),%eax
c0001243:	48                   	dec    %eax
c0001244:	39 c1                	cmp    %eax,%ecx
c0001246:	73 1b                	jae    c0001263 <_ZN5Buddy4freeEmR5Quota+0xfb>
c0001248:	8b 56 14             	mov    0x14(%esi),%edx
        Block *         head;

        ALWAYS_INLINE
        inline signed long block_to_index (Block *b)
        {
            return b - index;
c000124b:	89 d8                	mov    %ebx,%eax

        // Compute block index and corresponding buddy index
        signed long block_idx = block_to_index (block);
        signed long buddy_idx = block_idx ^ (1ul << ord);
c000124d:	89 fd                	mov    %edi,%ebp
c000124f:	d3 e5                	shl    %cl,%ebp
c0001251:	29 d0                	sub    %edx,%eax
c0001253:	c1 f8 02             	sar    $0x2,%eax
c0001256:	69 c0 ab aa aa aa    	imul   $0xaaaaaaab,%eax,%eax
c000125c:	31 e8                	xor    %ebp,%eax

        // Buddy outside mempool
        if (buddy_idx < min_idx || buddy_idx >= max_idx)
c000125e:	3b 46 08             	cmp    0x8(%esi),%eax
c0001261:	7d 27                	jge    c000128a <_ZN5Buddy4freeEmR5Quota+0x122>
        // Merge block with buddy
        if (buddy < block)
            block = buddy;
    }

    block->ord = ord;
c0001263:	66 89 4b 08          	mov    %cx,0x8(%ebx)
    block->tag = Block::Free;

    // Enqueue final-size block
    Block *h = head + ord;
c0001267:	6b c9 0c             	imul   $0xc,%ecx,%ecx
        if (buddy < block)
            block = buddy;
    }

    block->ord = ord;
    block->tag = Block::Free;
c000126a:	66 c7 43 0a 01 00    	movw   $0x1,0xa(%ebx)

    // Enqueue final-size block
    Block *h = head + ord;
c0001270:	03 4e 18             	add    0x18(%esi),%ecx
    block->prev = h;
c0001273:	89 0b                	mov    %ecx,(%ebx)
    block->next = h->next;
c0001275:	8b 41 04             	mov    0x4(%ecx),%eax
c0001278:	89 43 04             	mov    %eax,0x4(%ebx)
    block->next->prev = h->next = block;
c000127b:	89 59 04             	mov    %ebx,0x4(%ecx)
c000127e:	89 18                	mov    %ebx,(%eax)
c0001280:	fe 06                	incb   (%esi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c0001282:	80 3c 24 00          	cmpb   $0x0,(%esp)
c0001286:	75 35                	jne    c00012bd <_ZN5Buddy4freeEmR5Quota+0x155>
c0001288:	eb 78                	jmp    c0001302 <_ZN5Buddy4freeEmR5Quota+0x19a>
        // Compute block index and corresponding buddy index
        signed long block_idx = block_to_index (block);
        signed long buddy_idx = block_idx ^ (1ul << ord);

        // Buddy outside mempool
        if (buddy_idx < min_idx || buddy_idx >= max_idx)
c000128a:	3b 46 04             	cmp    0x4(%esi),%eax
c000128d:	7d d4                	jge    c0001263 <_ZN5Buddy4freeEmR5Quota+0xfb>
        }

        ALWAYS_INLINE
        inline Block *index_to_block (signed long i)
        {
            return index + i;
c000128f:	6b c0 0c             	imul   $0xc,%eax,%eax
c0001292:	01 c2                	add    %eax,%edx
            break;

        Block *buddy = index_to_block (buddy_idx);

        // Buddy in use or fragmented
        if (buddy->tag == Block::Used || buddy->ord != ord)
c0001294:	66 83 7a 0a 00       	cmpw   $0x0,0xa(%edx)
c0001299:	74 c8                	je     c0001263 <_ZN5Buddy4freeEmR5Quota+0xfb>
c000129b:	0f b7 42 08          	movzwl 0x8(%edx),%eax
c000129f:	39 c8                	cmp    %ecx,%eax
c00012a1:	75 c0                	jne    c0001263 <_ZN5Buddy4freeEmR5Quota+0xfb>
            break;

        // Dequeue buddy from block list
        buddy->prev->next = buddy->next;
c00012a3:	8b 02                	mov    (%edx),%eax
c00012a5:	39 d3                	cmp    %edx,%ebx
c00012a7:	8b 6a 04             	mov    0x4(%edx),%ebp
c00012aa:	0f 47 da             	cmova  %edx,%ebx
    quota.free(1ul << block->ord);

    Lock_guard <Spinlock> guard (lock);

    unsigned short ord;
    for (ord = block->ord; ord < order - 1; ord++) {
c00012ad:	41                   	inc    %ecx
c00012ae:	0f b7 c9             	movzwl %cx,%ecx
        // Buddy in use or fragmented
        if (buddy->tag == Block::Used || buddy->ord != ord)
            break;

        // Dequeue buddy from block list
        buddy->prev->next = buddy->next;
c00012b1:	89 68 04             	mov    %ebp,0x4(%eax)
        buddy->next->prev = buddy->prev;
c00012b4:	8b 42 04             	mov    0x4(%edx),%eax
c00012b7:	8b 2a                	mov    (%edx),%ebp
c00012b9:	89 28                	mov    %ebp,(%eax)
c00012bb:	eb 83                	jmp    c0001240 <_ZN5Buddy4freeEmR5Quota+0xd8>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c00012bd:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c00012c4:	74 19                	je     c00012df <_ZN5Buddy4freeEmR5Quota+0x177>
c00012c6:	68 80 64 01 c0       	push   $0xc0016480
c00012cb:	68 c0 00 00 00       	push   $0xc0
c00012d0:	68 12 61 01 c0       	push   $0xc0016112
c00012d5:	68 82 61 01 c0       	push   $0xc0016182
c00012da:	e9 08 ff ff ff       	jmp    c00011e7 <_ZN5Buddy4freeEmR5Quota+0x7f>

            preemption = true;
c00012df:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c00012e6:	fb                   	sti    
c00012e7:	eb 19                	jmp    c0001302 <_ZN5Buddy4freeEmR5Quota+0x19a>
void Buddy::free (mword virt, Quota &quota)
{
    signed long idx = page_to_index (virt);

    // Ensure virt is within allocator range
    assert (idx >= min_idx && idx < max_idx);
c00012e9:	68 60 64 01 c0       	push   $0xc0016460
c00012ee:	68 87 00 00 00       	push   $0x87
c00012f3:	68 03 62 01 c0       	push   $0xc0016203
c00012f8:	68 d0 62 01 c0       	push   $0xc00162d0
c00012fd:	e9 e5 fe ff ff       	jmp    c00011e7 <_ZN5Buddy4freeEmR5Quota+0x7f>
    // Enqueue final-size block
    Block *h = head + ord;
    block->prev = h;
    block->next = h->next;
    block->next->prev = h->next = block;
}
c0001302:	58                   	pop    %eax
c0001303:	5b                   	pop    %ebx
c0001304:	5e                   	pop    %esi
c0001305:	5f                   	pop    %edi
c0001306:	5d                   	pop    %ebp
c0001307:	c3                   	ret    

c0001308 <_ZN5Quota4dumpEPvb>:


void Quota::dump(void * pd, bool all)
{
c0001308:	55                   	push   %ebp
    if (all) {
c0001309:	84 c9                	test   %cl,%cl
    block->next->prev = h->next = block;
}


void Quota::dump(void * pd, bool all)
{
c000130b:	57                   	push   %edi
c000130c:	89 d5                	mov    %edx,%ebp
c000130e:	56                   	push   %esi
c000130f:	89 c7                	mov    %eax,%edi
c0001311:	53                   	push   %ebx
c0001312:	53                   	push   %ebx
    if (all) {
c0001313:	0f 84 b2 00 00 00    	je     c00013cb <_ZN5Quota4dumpEPvb+0xc3>
        trace(0, "quota after boot Quota:init - in_use=%lx limit %lx",
c0001319:	8d 74 24 ff          	lea    -0x1(%esp),%esi
c000131d:	83 cb ff             	or     $0xffffffff,%ebx
c0001320:	ff 35 7c a3 01 c0    	pushl  0xc001a37c
c0001326:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
c000132c:	81 fe 00 d0 ff cf    	cmp    $0xcfffd000,%esi
c0001332:	89 d8                	mov    %ebx,%eax
c0001334:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c000133b:	ff 35 74 a3 01 c0    	pushl  0xc001a374
c0001341:	50                   	push   %eax
c0001342:	68 f0 62 01 c0       	push   $0xc00162f0
c0001347:	e8 92 06 00 00       	call   c00019de <_ZN7Console5printEPKcz>
              Quota::init.usage(), Quota::init.upli);

        trace(0, "Pd::kern=%12p quota=%12p - in_use=%012lx limit=%012lx not_for_transfer=%012lx overrun=%lx",
c000134c:	83 c4 10             	add    $0x10,%esp
c000134f:	89 d8                	mov    %ebx,%eax
c0001351:	ff 35 58 b4 01 c0    	pushl  0xc001b458
c0001357:	81 fe 00 d0 ff cf    	cmp    $0xcfffd000,%esi
c000135d:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0001364:	ff 35 60 b4 01 c0    	pushl  0xc001b460
c000136a:	ff 35 9c b2 01 c0    	pushl  0xc001b29c
c0001370:	ff 35 54 b4 01 c0    	pushl  0xc001b454
c0001376:	68 50 b4 01 c0       	push   $0xc001b450
c000137b:	68 c0 b2 01 c0       	push   $0xc001b2c0
c0001380:	50                   	push   %eax
c0001381:	68 2a 63 01 c0       	push   $0xc001632a
c0001386:	e8 53 06 00 00       	call   c00019de <_ZN7Console5printEPKcz>
              &Pd::kern, &Pd::kern.quota, Pd::kern.quota.usage(), Pd::root.quota.upli, Pd::kern.quota.notr, Pd::kern.quota.over);
        trace(0, "Pd::root=%12p quota=%12p - in_use=%012lx limit=%012lx not_for_transfer=%012lx overrun=%lx",
c000138b:	83 c4 20             	add    $0x20,%esp
c000138e:	81 fe 00 d0 ff cf    	cmp    $0xcfffd000,%esi
c0001394:	ff 35 98 b2 01 c0    	pushl  0xc001b298
c000139a:	0f 44 1d 04 f0 ff cf 	cmove  0xcffff004,%ebx
c00013a1:	ff 35 a0 b2 01 c0    	pushl  0xc001b2a0
c00013a7:	ff 35 9c b2 01 c0    	pushl  0xc001b29c
c00013ad:	ff 35 94 b2 01 c0    	pushl  0xc001b294
c00013b3:	68 90 b2 01 c0       	push   $0xc001b290
c00013b8:	68 00 b1 01 c0       	push   $0xc001b100
c00013bd:	53                   	push   %ebx
c00013be:	68 8b 63 01 c0       	push   $0xc001638b
c00013c3:	e8 16 06 00 00       	call   c00019de <_ZN7Console5printEPKcz>
c00013c8:	83 c4 20             	add    $0x20,%esp
              &Pd::root, &Pd::root.quota, Pd::root.quota.usage(), Pd::root.quota.upli, Pd::root.quota.notr, Pd::root.quota.over);
    }

    trace(0, "Pd::this=%12p quota=%12p - in_use=%012lx limit=%012lx not_for_transfer=%012lx overrun=%lx",
c00013cb:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c00013cf:	ff 77 08             	pushl  0x8(%edi)
c00013d2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c00013d7:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c00013dc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00013e1:	8d 95 90 01 00 00    	lea    0x190(%ebp),%edx
c00013e7:	ff 77 10             	pushl  0x10(%edi)
c00013ea:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c00013f1:	ff 77 0c             	pushl  0xc(%edi)
c00013f4:	ff 77 04             	pushl  0x4(%edi)
c00013f7:	52                   	push   %edx
c00013f8:	55                   	push   %ebp
c00013f9:	50                   	push   %eax
c00013fa:	68 ec 63 01 c0       	push   $0xc00163ec
c00013ff:	e8 da 05 00 00       	call   c00019de <_ZN7Console5printEPKcz>
          pd, &static_cast<Pd *>(pd)->quota, usage(), upli, notr, over);
}
c0001404:	83 c4 24             	add    $0x24,%esp
c0001407:	5b                   	pop    %ebx
c0001408:	5e                   	pop    %esi
c0001409:	5f                   	pop    %edi
c000140a:	5d                   	pop    %ebp
c000140b:	c3                   	ret    

c000140c <_ZN5Buddy5allocEtR5QuotaNS_4FillE>:
 * @param ord       Block order (2^ord pages)
 * @param zero      Zero out block content if true
 * @return          Pointer to linear memory region
 */
void *Buddy::alloc (unsigned short ord, Quota &quota, Fill fill)
{
c000140c:	55                   	push   %ebp
c000140d:	57                   	push   %edi
c000140e:	56                   	push   %esi
c000140f:	53                   	push   %ebx
c0001410:	89 c3                	mov    %eax,%ebx
c0001412:	83 ec 10             	sub    $0x10,%esp
c0001415:	0f b7 c2             	movzwl %dx,%eax
c0001418:	89 4c 24 04          	mov    %ecx,0x4(%esp)
c000141c:	89 04 24             	mov    %eax,(%esp)

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c000141f:	9c                   	pushf  
c0001420:	58                   	pop    %eax
            return flags & 0x200;
c0001421:	c1 e8 09             	shr    $0x9,%eax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c0001424:	24 01                	and    $0x1,%al
c0001426:	88 44 24 0f          	mov    %al,0xf(%esp)
c000142a:	74 27                	je     c0001453 <_ZN5Buddy5allocEtR5QuotaNS_4FillE+0x47>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c000142c:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0001433:	75 16                	jne    c000144b <_ZN5Buddy5allocEtR5QuotaNS_4FillE+0x3f>
c0001435:	68 c0 64 01 c0       	push   $0xc00164c0
c000143a:	68 b7 00 00 00       	push   $0xb7
c000143f:	68 12 61 01 c0       	push   $0xc0016112
c0001444:	68 83 61 01 c0       	push   $0xc0016183
c0001449:	eb 5f                	jmp    c00014aa <_ZN5Buddy5allocEtR5QuotaNS_4FillE+0x9e>

            asm volatile ("cli" : : : "memory");
c000144b:	fa                   	cli    
            preemption = false;
c000144c:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c0001453:	89 d8                	mov    %ebx,%eax
c0001455:	e8 d2 f6 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    Lock_guard <Spinlock> guard (lock);

    for (unsigned short j = ord; j < order; j++) {
c000145a:	8b 73 10             	mov    0x10(%ebx),%esi
c000145d:	8b 0c 24             	mov    (%esp),%ecx
c0001460:	eb 56                	jmp    c00014b8 <_ZN5Buddy5allocEtR5QuotaNS_4FillE+0xac>
        Block *         head;

        ALWAYS_INLINE
        inline signed long block_to_index (Block *b)
        {
            return b - index;
c0001462:	89 d6                	mov    %edx,%esi
        }

        mword virt = index_to_page (block_to_index (block));

        // Ensure corresponding physical block is order-aligned
        assert ((virt_to_phys (virt) & ((1ul << (block->ord + PAGE_BITS)) - 1)) == 0);
c0001464:	0f b7 4a 08          	movzwl 0x8(%edx),%ecx
c0001468:	b8 01 00 00 00       	mov    $0x1,%eax
c000146d:	2b 73 14             	sub    0x14(%ebx),%esi
c0001470:	c1 fe 02             	sar    $0x2,%esi
c0001473:	83 c1 0c             	add    $0xc,%ecx
c0001476:	69 f6 ab aa aa aa    	imul   $0xaaaaaaab,%esi,%esi
c000147c:	d3 e0                	shl    %cl,%eax
c000147e:	89 c1                	mov    %eax,%ecx
c0001480:	8d 40 ff             	lea    -0x1(%eax),%eax
        }

        ALWAYS_INLINE
        inline mword index_to_page (signed long i)
        {
            return base + i * PAGE_SIZE;
c0001483:	c1 e6 0c             	shl    $0xc,%esi
c0001486:	03 73 0c             	add    0xc(%ebx),%esi
        }

        ALWAYS_INLINE
        inline mword virt_to_phys (mword virt)
        {
            return virt - reinterpret_cast<mword>(&OFFSET);
c0001489:	89 f2                	mov    %esi,%edx
c000148b:	81 ea 00 00 c0 bf    	sub    $0xbfc00000,%edx
c0001491:	85 c2                	test   %eax,%edx
c0001493:	0f 84 95 00 00 00    	je     c000152e <_ZN5Buddy5allocEtR5QuotaNS_4FillE+0x122>
c0001499:	68 00 65 01 c0       	push   $0xc0016500
c000149e:	6a 6f                	push   $0x6f
c00014a0:	68 03 62 01 c0       	push   $0xc0016203
c00014a5:	68 8b 62 01 c0       	push   $0xc001628b
c00014aa:	68 69 60 01 c0       	push   $0xc0016069
c00014af:	e8 92 04 00 00       	call   c0001946 <_ZN7Console5panicEPKcz>
 */
void *Buddy::alloc (unsigned short ord, Quota &quota, Fill fill)
{
    Lock_guard <Spinlock> guard (lock);

    for (unsigned short j = ord; j < order; j++) {
c00014b4:	41                   	inc    %ecx
c00014b5:	0f b7 c9             	movzwl %cx,%ecx
c00014b8:	39 f1                	cmp    %esi,%ecx
c00014ba:	0f 83 cd 00 00 00    	jae    c000158d <_ZN5Buddy5allocEtR5QuotaNS_4FillE+0x181>

        if (head[j].next == head + j)
c00014c0:	6b c1 0c             	imul   $0xc,%ecx,%eax
c00014c3:	03 43 18             	add    0x18(%ebx),%eax
c00014c6:	8b 50 04             	mov    0x4(%eax),%edx
c00014c9:	39 c2                	cmp    %eax,%edx
c00014cb:	74 e7                	je     c00014b4 <_ZN5Buddy5allocEtR5QuotaNS_4FillE+0xa8>
            continue;

        Block *block = head[j].next;
        block->prev->next = block->next;
c00014cd:	8b 02                	mov    (%edx),%eax
        block->next->prev = block->prev;
        block->ord = ord;
        block->tag = Block::Used;

        while (j-- != ord) {
            Block *buddy = block + (1ul << j);
c00014cf:	bf 0c 00 00 00       	mov    $0xc,%edi

        if (head[j].next == head + j)
            continue;

        Block *block = head[j].next;
        block->prev->next = block->next;
c00014d4:	8b 72 04             	mov    0x4(%edx),%esi
c00014d7:	89 70 04             	mov    %esi,0x4(%eax)
        block->next->prev = block->prev;
c00014da:	8b 42 04             	mov    0x4(%edx),%eax
c00014dd:	8b 32                	mov    (%edx),%esi
c00014df:	89 30                	mov    %esi,(%eax)
        block->ord = ord;
c00014e1:	8b 04 24             	mov    (%esp),%eax
        block->tag = Block::Used;
c00014e4:	66 c7 42 0a 00 00    	movw   $0x0,0xa(%edx)
            continue;

        Block *block = head[j].next;
        block->prev->next = block->next;
        block->next->prev = block->prev;
        block->ord = ord;
c00014ea:	66 89 42 08          	mov    %ax,0x8(%edx)
c00014ee:	8b 04 24             	mov    (%esp),%eax
c00014f1:	48                   	dec    %eax
c00014f2:	0f b7 c0             	movzwl %ax,%eax
c00014f5:	89 44 24 08          	mov    %eax,0x8(%esp)
        block->tag = Block::Used;

        while (j-- != ord) {
c00014f9:	49                   	dec    %ecx
c00014fa:	0f b7 c9             	movzwl %cx,%ecx
c00014fd:	3b 4c 24 08          	cmp    0x8(%esp),%ecx
c0001501:	0f 84 5b ff ff ff    	je     c0001462 <_ZN5Buddy5allocEtR5QuotaNS_4FillE+0x56>
            Block *buddy = block + (1ul << j);
            buddy->prev = buddy->next = head + j;
c0001507:	8b 6b 18             	mov    0x18(%ebx),%ebp
c000150a:	6b f1 0c             	imul   $0xc,%ecx,%esi
        block->next->prev = block->prev;
        block->ord = ord;
        block->tag = Block::Used;

        while (j-- != ord) {
            Block *buddy = block + (1ul << j);
c000150d:	89 f8                	mov    %edi,%eax
c000150f:	d3 e0                	shl    %cl,%eax
c0001511:	01 d0                	add    %edx,%eax
            buddy->prev = buddy->next = head + j;
            buddy->ord = j;
c0001513:	66 89 48 08          	mov    %cx,0x8(%eax)
        block->ord = ord;
        block->tag = Block::Used;

        while (j-- != ord) {
            Block *buddy = block + (1ul << j);
            buddy->prev = buddy->next = head + j;
c0001517:	01 f5                	add    %esi,%ebp
c0001519:	89 68 04             	mov    %ebp,0x4(%eax)
c000151c:	89 28                	mov    %ebp,(%eax)
            buddy->ord = j;
            buddy->tag = Block::Free;
c000151e:	66 c7 40 0a 01 00    	movw   $0x1,0xa(%eax)
            head[j].next = head[j].prev = buddy;
c0001524:	03 73 18             	add    0x18(%ebx),%esi
c0001527:	89 06                	mov    %eax,(%esi)
c0001529:	89 46 04             	mov    %eax,0x4(%esi)
c000152c:	eb cb                	jmp    c00014f9 <_ZN5Buddy5allocEtR5QuotaNS_4FillE+0xed>
        mword virt = index_to_page (block_to_index (block));

        // Ensure corresponding physical block is order-aligned
        assert ((virt_to_phys (virt) & ((1ul << (block->ord + PAGE_BITS)) - 1)) == 0);

        if (fill)
c000152e:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c0001533:	74 10                	je     c0001545 <_ZN5Buddy5allocEtR5QuotaNS_4FillE+0x139>
            memset (reinterpret_cast<void *>(virt), fill == FILL_0 ? 0 : -1, 1ul << (block->ord + PAGE_BITS));
c0001535:	31 c0                	xor    %eax,%eax
c0001537:	89 f7                	mov    %esi,%edi
c0001539:	83 7c 24 24 01       	cmpl   $0x1,0x24(%esp)
c000153e:	0f 95 c0             	setne  %al
c0001541:	f7 d8                	neg    %eax
c0001543:	f3 aa                	rep stos %al,%es:(%edi)

        quota.alloc(1ul << ord);
c0001545:	8a 0c 24             	mov    (%esp),%cl
c0001548:	ba 01 00 00 00       	mov    $0x1,%edx
c000154d:	8b 44 24 04          	mov    0x4(%esp),%eax
c0001551:	d3 e2                	shl    %cl,%edx
c0001553:	e8 f6 fa ff ff       	call   c000104e <_ZN5Quota5allocEm>
c0001558:	fe 03                	incb   (%ebx)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c000155a:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c000155f:	74 4a                	je     c00015ab <_ZN5Buddy5allocEtR5QuotaNS_4FillE+0x19f>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0001561:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0001568:	74 19                	je     c0001583 <_ZN5Buddy5allocEtR5QuotaNS_4FillE+0x177>
c000156a:	68 80 64 01 c0       	push   $0xc0016480
c000156f:	68 c0 00 00 00       	push   $0xc0
c0001574:	68 12 61 01 c0       	push   $0xc0016112
c0001579:	68 82 61 01 c0       	push   $0xc0016182
c000157e:	e9 27 ff ff ff       	jmp    c00014aa <_ZN5Buddy5allocEtR5QuotaNS_4FillE+0x9e>

            preemption = true;
c0001583:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000158a:	fb                   	sti    
c000158b:	eb 1e                	jmp    c00015ab <_ZN5Buddy5allocEtR5QuotaNS_4FillE+0x19f>

        return reinterpret_cast<void *>(virt);
    }

    quota.dump(Pd::current);
c000158d:	8b 44 24 04          	mov    0x4(%esp),%eax
c0001591:	b9 01 00 00 00       	mov    $0x1,%ecx
c0001596:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c000159c:	e8 67 fd ff ff       	call   c0001308 <_ZN5Quota4dumpEPvb>

    Console::panic ("Out of memory");
c00015a1:	68 4d 64 01 c0       	push   $0xc001644d
c00015a6:	e8 9b 03 00 00       	call   c0001946 <_ZN7Console5panicEPKcz>
}
c00015ab:	83 c4 10             	add    $0x10,%esp
c00015ae:	89 f0                	mov    %esi,%eax
c00015b0:	5b                   	pop    %ebx
c00015b1:	5e                   	pop    %esi
c00015b2:	5f                   	pop    %edi
c00015b3:	5d                   	pop    %ebp
c00015b4:	c3                   	ret    

c00015b5 <_GLOBAL__sub_I.00101__ZN5Quota4initE>:
 */
INIT_PRIORITY (PRIO_BUDDY)
Buddy Buddy::allocator (reinterpret_cast<mword>(&_mempool_p),
                        reinterpret_cast<mword>(&_mempool_l),
                        reinterpret_cast<mword>(&_mempool_f),
                        reinterpret_cast<mword>(&_mempool_e) -
c00015b5:	b8 00 00 40 c2       	mov    $0xc2400000,%eax

/*
 * Buddy Allocator
 */
INIT_PRIORITY (PRIO_BUDDY)
Buddy Buddy::allocator (reinterpret_cast<mword>(&_mempool_p),
c00015ba:	ba 00 c0 41 00       	mov    $0x41c000,%edx
                        reinterpret_cast<mword>(&_mempool_l),
                        reinterpret_cast<mword>(&_mempool_f),
                        reinterpret_cast<mword>(&_mempool_e) -
c00015bf:	2d 00 c0 01 c0       	sub    $0xc001c000,%eax

/*
 * Buddy Allocator
 */
INIT_PRIORITY (PRIO_BUDDY)
Buddy Buddy::allocator (reinterpret_cast<mword>(&_mempool_p),
c00015c4:	b9 00 c0 01 c0       	mov    $0xc001c000,%ecx
c00015c9:	50                   	push   %eax
c00015ca:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c00015cf:	68 00 00 02 c0       	push   $0xc0020000
    private:
        uint16 val;

    public:
        ALWAYS_INLINE
        inline Spinlock() : val (0) {}
c00015d4:	66 c7 05 70 a3 01 c0 	movw   $0x0,0xc001a370
c00015db:	00 00 

    public:

        static Quota init;

        Quota () : used(0), over(0), upli(0), notr(0) { }
c00015dd:	c7 05 74 a3 01 c0 00 	movl   $0x0,0xc001a374
c00015e4:	00 00 00 
c00015e7:	c7 05 78 a3 01 c0 00 	movl   $0x0,0xc001a378
c00015ee:	00 00 00 
c00015f1:	c7 05 7c a3 01 c0 00 	movl   $0x0,0xc001a37c
c00015f8:	00 00 00 
c00015fb:	c7 05 80 a3 01 c0 00 	movl   $0x0,0xc001a380
c0001602:	00 00 00 
c0001605:	e8 5e f4 1f 40       	call   200a68 <_ZN5BuddyC1Emmmj>
c000160a:	58                   	pop    %eax
c000160b:	5a                   	pop    %edx
c000160c:	c3                   	ret    
c000160d:	90                   	nop

c000160e <_ZN7Console9print_numEyjjj>:

Console *Console::list;
Spinlock Console::lock;

void Console::print_num (uint64 val, unsigned base, unsigned width, unsigned flags)
{
c000160e:	55                   	push   %ebp
c000160f:	57                   	push   %edi
c0001610:	56                   	push   %esi
c0001611:	53                   	push   %ebx
c0001612:	89 c3                	mov    %eax,%ebx
c0001614:	83 ec 20             	sub    $0x20,%esp
c0001617:	89 4c 24 04          	mov    %ecx,0x4(%esp)
    bool neg = false;
c000161b:	31 c9                	xor    %ecx,%ecx

    if (flags & FLAG_SIGNED && static_cast<signed long long>(val) < 0) {
c000161d:	f6 44 24 3c 01       	testb  $0x1,0x3c(%esp)

Console *Console::list;
Spinlock Console::lock;

void Console::print_num (uint64 val, unsigned base, unsigned width, unsigned flags)
{
c0001622:	89 14 24             	mov    %edx,(%esp)
    bool neg = false;

    if (flags & FLAG_SIGNED && static_cast<signed long long>(val) < 0) {
c0001625:	74 15                	je     c000163c <_ZN7Console9print_numEyjjj+0x2e>
c0001627:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
c000162c:	79 0e                	jns    c000163c <_ZN7Console9print_numEyjjj+0x2e>
        neg = true;
        val = -val;
c000162e:	f7 1c 24             	negl   (%esp)
void Console::print_num (uint64 val, unsigned base, unsigned width, unsigned flags)
{
    bool neg = false;

    if (flags & FLAG_SIGNED && static_cast<signed long long>(val) < 0) {
        neg = true;
c0001631:	b1 01                	mov    $0x1,%cl
        val = -val;
c0001633:	83 54 24 04 00       	adcl   $0x0,0x4(%esp)
c0001638:	f7 5c 24 04          	negl   0x4(%esp)
    }

    char buffer[24], *ptr = buffer + sizeof buffer;
c000163c:	8d 6c 24 20          	lea    0x20(%esp),%ebp
                  : "=A" (q),   // quotient
                    "=r" (*r)   // remainder
                  : "a"  (static_cast<uint32>(n >> 32)),
                    "d"  (0),
                    "1"  (static_cast<uint32>(n)),
                    "rm" (d));
c0001640:	31 ff                	xor    %edi,%edi
c0001642:	8b 34 24             	mov    (%esp),%esi
c0001645:	89 fa                	mov    %edi,%edx
c0001647:	8b 44 24 04          	mov    0x4(%esp),%eax
c000164b:	f7 74 24 34          	divl   0x34(%esp)
c000164f:	96                   	xchg   %eax,%esi
c0001650:	f7 74 24 34          	divl   0x34(%esp)
c0001654:	87 f2                	xchg   %esi,%edx
c0001656:	89 04 24             	mov    %eax,(%esp)

    do {
        uint32 r;
        val = div64 (val, base, &r);
        *--ptr = r["0123456789abcdef"];
c0001659:	8a 86 74 65 01 c0    	mov    -0x3ffe9a8c(%esi),%al
c000165f:	4d                   	dec    %ebp
c0001660:	89 54 24 04          	mov    %edx,0x4(%esp)
c0001664:	88 45 00             	mov    %al,0x0(%ebp)
        val = -val;
    }

    char buffer[24], *ptr = buffer + sizeof buffer;

    do {
c0001667:	8b 44 24 04          	mov    0x4(%esp),%eax
c000166b:	0b 04 24             	or     (%esp),%eax
c000166e:	75 d2                	jne    c0001642 <_ZN7Console9print_numEyjjj+0x34>
        uint32 r;
        val = div64 (val, base, &r);
        *--ptr = r["0123456789abcdef"];
    } while (val);

    if (neg)
c0001670:	84 c9                	test   %cl,%cl
c0001672:	89 e8                	mov    %ebp,%eax
c0001674:	74 05                	je     c000167b <_ZN7Console9print_numEyjjj+0x6d>
        *--ptr = '-';
c0001676:	4d                   	dec    %ebp
c0001677:	c6 40 ff 2d          	movb   $0x2d,-0x1(%eax)

    unsigned long count = buffer + sizeof buffer - ptr;
    unsigned long n = count + (flags & FLAG_ALT_FORM ? 2 : 0);
c000167b:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
    } while (val);

    if (neg)
        *--ptr = '-';

    unsigned long count = buffer + sizeof buffer - ptr;
c000167f:	8d 44 24 20          	lea    0x20(%esp),%eax
c0001683:	29 e8                	sub    %ebp,%eax
c0001685:	89 04 24             	mov    %eax,(%esp)
    unsigned long n = count + (flags & FLAG_ALT_FORM ? 2 : 0);
c0001688:	83 e7 02             	and    $0x2,%edi

    if (flags & FLAG_ZERO_PAD) {
c000168b:	f6 44 24 3c 04       	testb  $0x4,0x3c(%esp)

    if (neg)
        *--ptr = '-';

    unsigned long count = buffer + sizeof buffer - ptr;
    unsigned long n = count + (flags & FLAG_ALT_FORM ? 2 : 0);
c0001690:	8d 34 38             	lea    (%eax,%edi,1),%esi

    if (flags & FLAG_ZERO_PAD) {
c0001693:	74 2e                	je     c00016c3 <_ZN7Console9print_numEyjjj+0xb5>
        if (flags & FLAG_ALT_FORM) {
c0001695:	85 ff                	test   %edi,%edi
c0001697:	74 16                	je     c00016af <_ZN7Console9print_numEyjjj+0xa1>
            putc ('0');
c0001699:	8b 0b                	mov    (%ebx),%ecx
c000169b:	ba 30 00 00 00       	mov    $0x30,%edx
c00016a0:	89 d8                	mov    %ebx,%eax
c00016a2:	ff 11                	call   *(%ecx)
            putc ('x');
c00016a4:	8b 0b                	mov    (%ebx),%ecx
c00016a6:	ba 78 00 00 00       	mov    $0x78,%edx
c00016ab:	89 d8                	mov    %ebx,%eax
c00016ad:	ff 11                	call   *(%ecx)
        }
        while (n++ < width)
c00016af:	3b 74 24 38          	cmp    0x38(%esp),%esi
c00016b3:	73 3c                	jae    c00016f1 <_ZN7Console9print_numEyjjj+0xe3>
            putc ('0');
c00016b5:	8b 0b                	mov    (%ebx),%ecx
c00016b7:	ba 30 00 00 00       	mov    $0x30,%edx
c00016bc:	89 d8                	mov    %ebx,%eax
c00016be:	46                   	inc    %esi
c00016bf:	ff 11                	call   *(%ecx)
c00016c1:	eb ec                	jmp    c00016af <_ZN7Console9print_numEyjjj+0xa1>
    } else {
        while (n++ < width)
c00016c3:	3b 74 24 38          	cmp    0x38(%esp),%esi
c00016c7:	73 0e                	jae    c00016d7 <_ZN7Console9print_numEyjjj+0xc9>
            putc (' ');
c00016c9:	8b 0b                	mov    (%ebx),%ecx
c00016cb:	ba 20 00 00 00       	mov    $0x20,%edx
c00016d0:	89 d8                	mov    %ebx,%eax
c00016d2:	46                   	inc    %esi
c00016d3:	ff 11                	call   *(%ecx)
c00016d5:	eb ec                	jmp    c00016c3 <_ZN7Console9print_numEyjjj+0xb5>
        if (flags & FLAG_ALT_FORM) {
c00016d7:	85 ff                	test   %edi,%edi
c00016d9:	74 16                	je     c00016f1 <_ZN7Console9print_numEyjjj+0xe3>
            putc ('0');
c00016db:	8b 0b                	mov    (%ebx),%ecx
c00016dd:	ba 30 00 00 00       	mov    $0x30,%edx
c00016e2:	89 d8                	mov    %ebx,%eax
c00016e4:	ff 11                	call   *(%ecx)
            putc ('x');
c00016e6:	8b 0b                	mov    (%ebx),%ecx
c00016e8:	ba 78 00 00 00       	mov    $0x78,%edx
c00016ed:	89 d8                	mov    %ebx,%eax
c00016ef:	ff 11                	call   *(%ecx)
        *--ptr = '-';

    unsigned long count = buffer + sizeof buffer - ptr;
    unsigned long n = count + (flags & FLAG_ALT_FORM ? 2 : 0);

    if (flags & FLAG_ZERO_PAD) {
c00016f1:	31 f6                	xor    %esi,%esi
            putc ('0');
            putc ('x');
        }
    }

    while (count--)
c00016f3:	3b 34 24             	cmp    (%esp),%esi
c00016f6:	74 0e                	je     c0001706 <_ZN7Console9print_numEyjjj+0xf8>
        putc (*ptr++);
c00016f8:	8b 0b                	mov    (%ebx),%ecx
c00016fa:	89 d8                	mov    %ebx,%eax
c00016fc:	0f be 54 35 00       	movsbl 0x0(%ebp,%esi,1),%edx
c0001701:	46                   	inc    %esi
c0001702:	ff 11                	call   *(%ecx)
c0001704:	eb ed                	jmp    c00016f3 <_ZN7Console9print_numEyjjj+0xe5>
}
c0001706:	83 c4 20             	add    $0x20,%esp
c0001709:	5b                   	pop    %ebx
c000170a:	5e                   	pop    %esi
c000170b:	5f                   	pop    %edi
c000170c:	5d                   	pop    %ebp
c000170d:	c3                   	ret    

c000170e <_ZN7Console9print_strEPKcjj>:

void Console::print_str (char const *s, unsigned width, unsigned precs)
{
c000170e:	55                   	push   %ebp
c000170f:	89 cd                	mov    %ecx,%ebp
c0001711:	57                   	push   %edi
c0001712:	89 d7                	mov    %edx,%edi
c0001714:	56                   	push   %esi
c0001715:	89 c6                	mov    %eax,%esi
c0001717:	53                   	push   %ebx
c0001718:	31 db                	xor    %ebx,%ebx
    if (EXPECT_FALSE (!s))
c000171a:	85 d2                	test   %edx,%edx
c000171c:	74 33                	je     c0001751 <_ZN7Console9print_strEPKcjj+0x43>
        return;

    unsigned n;

    for (n = 0; *s && precs--; n++)
c000171e:	0f be 14 1f          	movsbl (%edi,%ebx,1),%edx
c0001722:	84 d2                	test   %dl,%dl
c0001724:	75 0a                	jne    c0001730 <_ZN7Console9print_strEPKcjj+0x22>
c0001726:	89 5c 24 14          	mov    %ebx,0x14(%esp)
c000172a:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c000172e:	eb 0f                	jmp    c000173f <_ZN7Console9print_strEPKcjj+0x31>
c0001730:	3b 5c 24 14          	cmp    0x14(%esp),%ebx
c0001734:	74 f4                	je     c000172a <_ZN7Console9print_strEPKcjj+0x1c>
        putc (*s++);
c0001736:	8b 0e                	mov    (%esi),%ecx
c0001738:	89 f0                	mov    %esi,%eax
    if (EXPECT_FALSE (!s))
        return;

    unsigned n;

    for (n = 0; *s && precs--; n++)
c000173a:	43                   	inc    %ebx
        putc (*s++);
c000173b:	ff 11                	call   *(%ecx)
c000173d:	eb df                	jmp    c000171e <_ZN7Console9print_strEPKcjj+0x10>

    while (n++ < width)
c000173f:	39 eb                	cmp    %ebp,%ebx
c0001741:	73 0e                	jae    c0001751 <_ZN7Console9print_strEPKcjj+0x43>
        putc (' ');
c0001743:	8b 0e                	mov    (%esi),%ecx
c0001745:	ba 20 00 00 00       	mov    $0x20,%edx
c000174a:	89 f0                	mov    %esi,%eax
c000174c:	43                   	inc    %ebx
c000174d:	ff 11                	call   *(%ecx)
c000174f:	eb ee                	jmp    c000173f <_ZN7Console9print_strEPKcjj+0x31>
}
c0001751:	5b                   	pop    %ebx
c0001752:	5e                   	pop    %esi
c0001753:	5f                   	pop    %edi
c0001754:	5d                   	pop    %ebp
c0001755:	c3                   	ret    

c0001756 <_ZN7Console7vprintfEPKcPc>:

void Console::vprintf (char const *format, va_list args)
{
c0001756:	55                   	push   %ebp
c0001757:	57                   	push   %edi
c0001758:	89 d7                	mov    %edx,%edi
c000175a:	56                   	push   %esi
c000175b:	89 c6                	mov    %eax,%esi
c000175d:	53                   	push   %ebx
c000175e:	89 cb                	mov    %ecx,%ebx
c0001760:	83 ec 10             	sub    $0x10,%esp
    while (*format) {
c0001763:	0f be 17             	movsbl (%edi),%edx
c0001766:	84 d2                	test   %dl,%dl
c0001768:	0f 84 c4 01 00 00    	je     c0001932 <_ZN7Console7vprintfEPKcPc+0x1dc>

        if (EXPECT_TRUE (*format != '%')) {
c000176e:	80 fa 25             	cmp    $0x25,%dl
c0001771:	75 1d                	jne    c0001790 <_ZN7Console7vprintfEPKcPc+0x3a>
c0001773:	31 c9                	xor    %ecx,%ecx
c0001775:	31 ed                	xor    %ebp,%ebp
c0001777:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c000177e:	00 
c000177f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0001786:	00 
c0001787:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c000178e:	eb 18                	jmp    c00017a8 <_ZN7Console7vprintfEPKcPc+0x52>
            putc (*format++);
c0001790:	8b 0e                	mov    (%esi),%ecx
c0001792:	89 f0                	mov    %esi,%eax
c0001794:	47                   	inc    %edi
c0001795:	ff 11                	call   *(%ecx)
            continue;
c0001797:	eb ca                	jmp    c0001763 <_ZN7Console7vprintfEPKcPc+0xd>

        unsigned flags = 0, width = 0, precs = 0, len = 0, mode = MODE_FLAGS;

        for (uint64 u;;) {

            switch (*++format) {
c0001799:	7f 53                	jg     c00017ee <_ZN7Console7vprintfEPKcPc+0x98>
c000179b:	3c 2e                	cmp    $0x2e,%al
c000179d:	75 1d                	jne    c00017bc <_ZN7Console7vprintfEPKcPc+0x66>
                        case MODE_PRECS: precs = precs * 10 + *format - '0'; break;
                    }
                    continue;

                case '.':
                    mode = MODE_PRECS;
c000179f:	b9 02 00 00 00       	mov    $0x2,%ecx

void Console::vprintf (char const *format, va_list args)
{
    while (*format) {

        if (EXPECT_TRUE (*format != '%')) {
c00017a4:	8b 7c 24 08          	mov    0x8(%esp),%edi

        unsigned flags = 0, width = 0, precs = 0, len = 0, mode = MODE_FLAGS;

        for (uint64 u;;) {

            switch (*++format) {
c00017a8:	8d 47 01             	lea    0x1(%edi),%eax
c00017ab:	89 44 24 08          	mov    %eax,0x8(%esp)
c00017af:	0f be 47 01          	movsbl 0x1(%edi),%eax
c00017b3:	3c 63                	cmp    $0x63,%al
c00017b5:	75 e2                	jne    c0001799 <_ZN7Console7vprintfEPKcPc+0x43>
c00017b7:	e9 c7 00 00 00       	jmp    c0001883 <_ZN7Console7vprintfEPKcPc+0x12d>
c00017bc:	7f 21                	jg     c00017df <_ZN7Console7vprintfEPKcPc+0x89>
c00017be:	84 c0                	test   %al,%al
c00017c0:	0f 84 51 01 00 00    	je     c0001917 <_ZN7Console7vprintfEPKcPc+0x1c1>
c00017c6:	3c 23                	cmp    $0x23,%al
c00017c8:	0f 85 4d 01 00 00    	jne    c000191b <_ZN7Console7vprintfEPKcPc+0x1c5>
                    mode = MODE_PRECS;
                    continue;

                case '#':
                    if (mode == MODE_FLAGS)
                        flags |= FLAG_ALT_FORM;
c00017ce:	8b 04 24             	mov    (%esp),%eax
c00017d1:	83 c8 02             	or     $0x2,%eax
c00017d4:	85 c9                	test   %ecx,%ecx
c00017d6:	0f 45 04 24          	cmovne (%esp),%eax
c00017da:	89 04 24             	mov    %eax,(%esp)
c00017dd:	eb c5                	jmp    c00017a4 <_ZN7Console7vprintfEPKcPc+0x4e>

        unsigned flags = 0, width = 0, precs = 0, len = 0, mode = MODE_FLAGS;

        for (uint64 u;;) {

            switch (*++format) {
c00017df:	88 c2                	mov    %al,%dl
c00017e1:	80 ea 30             	sub    $0x30,%dl
c00017e4:	80 fa 09             	cmp    $0x9,%dl
c00017e7:	76 5e                	jbe    c0001847 <_ZN7Console7vprintfEPKcPc+0xf1>
c00017e9:	e9 2d 01 00 00       	jmp    c000191b <_ZN7Console7vprintfEPKcPc+0x1c5>
c00017ee:	3c 70                	cmp    $0x70,%al
c00017f0:	0f 84 9a 00 00 00    	je     c0001890 <_ZN7Console7vprintfEPKcPc+0x13a>
c00017f6:	7f 16                	jg     c000180e <_ZN7Console7vprintfEPKcPc+0xb8>
c00017f8:	3c 64                	cmp    $0x64,%al
c00017fa:	0f 84 aa 00 00 00    	je     c00018aa <_ZN7Console7vprintfEPKcPc+0x154>
c0001800:	3c 6c                	cmp    $0x6c,%al
c0001802:	0f 85 13 01 00 00    	jne    c000191b <_ZN7Console7vprintfEPKcPc+0x1c5>
                    if (mode == MODE_FLAGS)
                        flags |= FLAG_ALT_FORM;
                    continue;

                case 'l':
                    len++;
c0001808:	ff 44 24 04          	incl   0x4(%esp)
                    continue;
c000180c:	eb 96                	jmp    c00017a4 <_ZN7Console7vprintfEPKcPc+0x4e>

        unsigned flags = 0, width = 0, precs = 0, len = 0, mode = MODE_FLAGS;

        for (uint64 u;;) {

            switch (*++format) {
c000180e:	3c 75                	cmp    $0x75,%al
c0001810:	0f 84 c2 00 00 00    	je     c00018d8 <_ZN7Console7vprintfEPKcPc+0x182>
c0001816:	3c 78                	cmp    $0x78,%al
c0001818:	0f 84 ba 00 00 00    	je     c00018d8 <_ZN7Console7vprintfEPKcPc+0x182>
c000181e:	3c 73                	cmp    $0x73,%al
c0001820:	0f 85 f5 00 00 00    	jne    c000191b <_ZN7Console7vprintfEPKcPc+0x1c5>
                case 'c':
                    putc (va_arg (args, int));
                    break;

                case 's':
                    print_str (va_arg (args, char *), width, precs ? precs : ~0u);
c0001826:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c000182b:	ba ff ff ff ff       	mov    $0xffffffff,%edx
c0001830:	89 f0                	mov    %esi,%eax
c0001832:	89 e9                	mov    %ebp,%ecx
c0001834:	0f 45 54 24 0c       	cmovne 0xc(%esp),%edx
c0001839:	8d 7b 04             	lea    0x4(%ebx),%edi
c000183c:	52                   	push   %edx
c000183d:	8b 13                	mov    (%ebx),%edx
c000183f:	e8 ca fe ff ff       	call   c000170e <_ZN7Console9print_strEPKcjj>
                    break;
c0001844:	58                   	pop    %eax
c0001845:	eb 5f                	jmp    c00018a6 <_ZN7Console7vprintfEPKcPc+0x150>
        for (uint64 u;;) {

            switch (*++format) {

                case '0'...'9':
                    switch (mode) {
c0001847:	83 f9 01             	cmp    $0x1,%ecx
c000184a:	74 14                	je     c0001860 <_ZN7Console7vprintfEPKcPc+0x10a>
c000184c:	83 f9 02             	cmp    $0x2,%ecx
c000184f:	74 20                	je     c0001871 <_ZN7Console7vprintfEPKcPc+0x11b>
                        case MODE_FLAGS:
                            if (*format == '0') {
c0001851:	3c 30                	cmp    $0x30,%al
c0001853:	75 0b                	jne    c0001860 <_ZN7Console7vprintfEPKcPc+0x10a>
                                flags |= FLAG_ZERO_PAD;
c0001855:	83 0c 24 04          	orl    $0x4,(%esp)
                                break;
c0001859:	31 c9                	xor    %ecx,%ecx
c000185b:	e9 44 ff ff ff       	jmp    c00017a4 <_ZN7Console7vprintfEPKcPc+0x4e>
                            }
                            mode = MODE_WIDTH;
                        case MODE_WIDTH: width = width * 10 + *format - '0'; break;
c0001860:	6b ed 0a             	imul   $0xa,%ebp,%ebp
c0001863:	b9 01 00 00 00       	mov    $0x1,%ecx
c0001868:	8d 6c 05 d0          	lea    -0x30(%ebp,%eax,1),%ebp
c000186c:	e9 33 ff ff ff       	jmp    c00017a4 <_ZN7Console7vprintfEPKcPc+0x4e>
                        case MODE_PRECS: precs = precs * 10 + *format - '0'; break;
c0001871:	6b 7c 24 0c 0a       	imul   $0xa,0xc(%esp),%edi
c0001876:	8d 44 07 d0          	lea    -0x30(%edi,%eax,1),%eax
c000187a:	89 44 24 0c          	mov    %eax,0xc(%esp)
c000187e:	e9 21 ff ff ff       	jmp    c00017a4 <_ZN7Console7vprintfEPKcPc+0x4e>
                case 'l':
                    len++;
                    continue;

                case 'c':
                    putc (va_arg (args, int));
c0001883:	8b 0e                	mov    (%esi),%ecx
c0001885:	89 f0                	mov    %esi,%eax
c0001887:	8b 13                	mov    (%ebx),%edx
c0001889:	8d 7b 04             	lea    0x4(%ebx),%edi
c000188c:	ff 11                	call   *(%ecx)
c000188e:	eb 16                	jmp    c00018a6 <_ZN7Console7vprintfEPKcPc+0x150>
                    }
                    print_num (u, *format == 'x' ? 16 : 10, width, flags);
                    break;

                case 'p':
                    print_num (reinterpret_cast<mword>(va_arg (args, void *)), 16, width, FLAG_ALT_FORM);
c0001890:	8b 13                	mov    (%ebx),%edx
c0001892:	31 c9                	xor    %ecx,%ecx
c0001894:	89 f0                	mov    %esi,%eax
c0001896:	6a 02                	push   $0x2
c0001898:	55                   	push   %ebp
c0001899:	6a 10                	push   $0x10
c000189b:	e8 6e fd ff ff       	call   c000160e <_ZN7Console9print_numEyjjj>
c00018a0:	8d 7b 04             	lea    0x4(%ebx),%edi
                    break;
c00018a3:	83 c4 0c             	add    $0xc,%esp
                case 'c':
                    putc (va_arg (args, int));
                    break;

                case 's':
                    print_str (va_arg (args, char *), width, precs ? precs : ~0u);
c00018a6:	89 fb                	mov    %edi,%ebx
                    break;
c00018a8:	eb 7e                	jmp    c0001928 <_ZN7Console7vprintfEPKcPc+0x1d2>

                case 'd':
                    switch (len) {
c00018aa:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
c00018af:	74 07                	je     c00018b8 <_ZN7Console7vprintfEPKcPc+0x162>
c00018b1:	83 7c 24 04 01       	cmpl   $0x1,0x4(%esp)
c00018b6:	75 0c                	jne    c00018c4 <_ZN7Console7vprintfEPKcPc+0x16e>
                        case 0:  u = va_arg (args, int);        break;
                        case 1:  u = va_arg (args, long);       break;
c00018b8:	8b 13                	mov    (%ebx),%edx
c00018ba:	83 c3 04             	add    $0x4,%ebx
c00018bd:	89 d1                	mov    %edx,%ecx
c00018bf:	c1 f9 1f             	sar    $0x1f,%ecx
c00018c2:	eb 08                	jmp    c00018cc <_ZN7Console7vprintfEPKcPc+0x176>
                        default: u = va_arg (args, long long);  break;
c00018c4:	8b 13                	mov    (%ebx),%edx
c00018c6:	83 c3 08             	add    $0x8,%ebx
c00018c9:	8b 4b fc             	mov    -0x4(%ebx),%ecx
                    }
                    print_num (u, 10, width, flags | FLAG_SIGNED);
c00018cc:	8b 04 24             	mov    (%esp),%eax
c00018cf:	83 c8 01             	or     $0x1,%eax
c00018d2:	50                   	push   %eax
c00018d3:	55                   	push   %ebp
c00018d4:	6a 0a                	push   $0xa
c00018d6:	eb 33                	jmp    c000190b <_ZN7Console7vprintfEPKcPc+0x1b5>
                    break;

                case 'u':
                case 'x':
                    switch (len) {
c00018d8:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
c00018dd:	74 07                	je     c00018e6 <_ZN7Console7vprintfEPKcPc+0x190>
c00018df:	83 7c 24 04 01       	cmpl   $0x1,0x4(%esp)
c00018e4:	75 09                	jne    c00018ef <_ZN7Console7vprintfEPKcPc+0x199>
                        case 0:  u = va_arg (args, unsigned int);        break;
                        case 1:  u = va_arg (args, unsigned long);       break;
c00018e6:	8b 13                	mov    (%ebx),%edx
c00018e8:	31 c9                	xor    %ecx,%ecx
c00018ea:	83 c3 04             	add    $0x4,%ebx
c00018ed:	eb 08                	jmp    c00018f7 <_ZN7Console7vprintfEPKcPc+0x1a1>
                        default: u = va_arg (args, unsigned long long);  break;
c00018ef:	8b 13                	mov    (%ebx),%edx
c00018f1:	83 c3 08             	add    $0x8,%ebx
c00018f4:	8b 4b fc             	mov    -0x4(%ebx),%ecx
                    }
                    print_num (u, *format == 'x' ? 16 : 10, width, flags);
c00018f7:	ff 34 24             	pushl  (%esp)
c00018fa:	3c 78                	cmp    $0x78,%al
c00018fc:	bf 0a 00 00 00       	mov    $0xa,%edi
c0001901:	b8 10 00 00 00       	mov    $0x10,%eax
c0001906:	0f 45 c7             	cmovne %edi,%eax
c0001909:	55                   	push   %ebp
c000190a:	50                   	push   %eax
c000190b:	89 f0                	mov    %esi,%eax
c000190d:	e8 fc fc ff ff       	call   c000160e <_ZN7Console9print_numEyjjj>
                    break;
c0001912:	83 c4 0c             	add    $0xc,%esp
c0001915:	eb 11                	jmp    c0001928 <_ZN7Console7vprintfEPKcPc+0x1d2>

        unsigned flags = 0, width = 0, precs = 0, len = 0, mode = MODE_FLAGS;

        for (uint64 u;;) {

            switch (*++format) {
c0001917:	89 7c 24 08          	mov    %edi,0x8(%esp)

                case 0:
                    format--;

                default:
                    putc (*format);
c000191b:	8b 44 24 08          	mov    0x8(%esp),%eax
c000191f:	8b 0e                	mov    (%esi),%ecx
c0001921:	0f be 10             	movsbl (%eax),%edx
c0001924:	89 f0                	mov    %esi,%eax
c0001926:	ff 11                	call   *(%ecx)
                    break;
            }

            format++;
c0001928:	8b 7c 24 08          	mov    0x8(%esp),%edi
c000192c:	47                   	inc    %edi

            break;
c000192d:	e9 31 fe ff ff       	jmp    c0001763 <_ZN7Console7vprintfEPKcPc+0xd>
        }
    }

    putc ('\n');
c0001932:	8b 0e                	mov    (%esi),%ecx
c0001934:	89 f0                	mov    %esi,%eax
c0001936:	ba 0a 00 00 00       	mov    $0xa,%edx
c000193b:	ff 11                	call   *(%ecx)
}
c000193d:	83 c4 10             	add    $0x10,%esp
c0001940:	5b                   	pop    %ebx
c0001941:	5e                   	pop    %esi
c0001942:	5f                   	pop    %edi
c0001943:	5d                   	pop    %ebp
c0001944:	c3                   	ret    
c0001945:	90                   	nop

c0001946 <_ZN7Console5panicEPKcz>:
        va_end (args);
    }
}

void Console::panic (char const *format, ...)
{
c0001946:	56                   	push   %esi
c0001947:	53                   	push   %ebx

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c0001948:	9c                   	pushf  
c0001949:	5b                   	pop    %ebx
            return flags & 0x200;
c000194a:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c000194d:	80 e3 01             	and    $0x1,%bl
c0001950:	74 27                	je     c0001979 <_ZN7Console5panicEPKcz+0x33>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0001952:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0001959:	75 16                	jne    c0001971 <_ZN7Console5panicEPKcz+0x2b>
c000195b:	68 e0 65 01 c0       	push   $0xc00165e0
c0001960:	68 b7 00 00 00       	push   $0xb7
c0001965:	68 12 61 01 c0       	push   $0xc0016112
c000196a:	68 83 61 01 c0       	push   $0xc0016183
c000196f:	eb 57                	jmp    c00019c8 <_ZN7Console5panicEPKcz+0x82>

            asm volatile ("cli" : : : "memory");
c0001971:	fa                   	cli    
            preemption = false;
c0001972:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c0001979:	b8 8e a3 01 c0       	mov    $0xc001a38e,%eax
c000197e:	e8 a9 f1 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    {   Lock_guard <Spinlock> guard (lock);

        for (Console *c = list; c; c = c->next) {
c0001983:	8b 35 90 a3 01 c0    	mov    0xc001a390,%esi
c0001989:	85 f6                	test   %esi,%esi
c000198b:	74 14                	je     c00019a1 <_ZN7Console5panicEPKcz+0x5b>
            va_list args;
            va_start (args, format);
            c->vprintf (format, args);
c000198d:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0001991:	89 f0                	mov    %esi,%eax
c0001993:	8d 4c 24 10          	lea    0x10(%esp),%ecx
c0001997:	e8 ba fd ff ff       	call   c0001756 <_ZN7Console7vprintfEPKcPc>

void Console::panic (char const *format, ...)
{
    {   Lock_guard <Spinlock> guard (lock);

        for (Console *c = list; c; c = c->next) {
c000199c:	8b 76 04             	mov    0x4(%esi),%esi
c000199f:	eb e8                	jmp    c0001989 <_ZN7Console5panicEPKcz+0x43>
        }

        ALWAYS_INLINE
        inline void unlock()
        {
            asm volatile ("incb %0" : "=m" (val) : : "memory");
c00019a1:	fe 05 8e a3 01 c0    	incb   0xc001a38e
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c00019a7:	84 db                	test   %bl,%bl
c00019a9:	74 2f                	je     c00019da <_ZN7Console5panicEPKcz+0x94>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c00019ab:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c00019b2:	74 1e                	je     c00019d2 <_ZN7Console5panicEPKcz+0x8c>
c00019b4:	68 a0 65 01 c0       	push   $0xc00165a0
c00019b9:	68 c0 00 00 00       	push   $0xc0
c00019be:	68 12 61 01 c0       	push   $0xc0016112
c00019c3:	68 82 61 01 c0       	push   $0xc0016182
c00019c8:	68 69 60 01 c0       	push   $0xc0016069
c00019cd:	e8 74 ff ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

            preemption = true;
c00019d2:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c00019d9:	fb                   	sti    

ALWAYS_INLINE NORETURN
inline void shutdown()
{
    for (;;)
        asm volatile ("cli; hlt");
c00019da:	fa                   	cli    
c00019db:	f4                   	hlt    
c00019dc:	eb fc                	jmp    c00019da <_ZN7Console5panicEPKcz+0x94>

c00019de <_ZN7Console5printEPKcz>:

    putc ('\n');
}

void Console::print (char const *format, ...)
{
c00019de:	56                   	push   %esi
c00019df:	53                   	push   %ebx

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c00019e0:	9c                   	pushf  
c00019e1:	5b                   	pop    %ebx
            return flags & 0x200;
c00019e2:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c00019e5:	80 e3 01             	and    $0x1,%bl
c00019e8:	74 27                	je     c0001a11 <_ZN7Console5printEPKcz+0x33>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c00019ea:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c00019f1:	75 16                	jne    c0001a09 <_ZN7Console5printEPKcz+0x2b>
c00019f3:	68 e0 65 01 c0       	push   $0xc00165e0
c00019f8:	68 b7 00 00 00       	push   $0xb7
c00019fd:	68 12 61 01 c0       	push   $0xc0016112
c0001a02:	68 83 61 01 c0       	push   $0xc0016183
c0001a07:	eb 57                	jmp    c0001a60 <_ZN7Console5printEPKcz+0x82>

            asm volatile ("cli" : : : "memory");
c0001a09:	fa                   	cli    
            preemption = false;
c0001a0a:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c0001a11:	b8 8e a3 01 c0       	mov    $0xc001a38e,%eax
c0001a16:	e8 11 f1 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    Lock_guard <Spinlock> guard (lock);

    for (Console *c = list; c; c = c->next) {
c0001a1b:	8b 35 90 a3 01 c0    	mov    0xc001a390,%esi
c0001a21:	85 f6                	test   %esi,%esi
c0001a23:	74 14                	je     c0001a39 <_ZN7Console5printEPKcz+0x5b>
        va_list args;
        va_start (args, format);
        c->vprintf (format, args);
c0001a25:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0001a29:	89 f0                	mov    %esi,%eax
c0001a2b:	8d 4c 24 10          	lea    0x10(%esp),%ecx
c0001a2f:	e8 22 fd ff ff       	call   c0001756 <_ZN7Console7vprintfEPKcPc>

void Console::print (char const *format, ...)
{
    Lock_guard <Spinlock> guard (lock);

    for (Console *c = list; c; c = c->next) {
c0001a34:	8b 76 04             	mov    0x4(%esi),%esi
c0001a37:	eb e8                	jmp    c0001a21 <_ZN7Console5printEPKcz+0x43>
c0001a39:	fe 05 8e a3 01 c0    	incb   0xc001a38e
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c0001a3f:	84 db                	test   %bl,%bl
c0001a41:	74 2f                	je     c0001a72 <_ZN7Console5printEPKcz+0x94>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0001a43:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0001a4a:	74 1e                	je     c0001a6a <_ZN7Console5printEPKcz+0x8c>
c0001a4c:	68 a0 65 01 c0       	push   $0xc00165a0
c0001a51:	68 c0 00 00 00       	push   $0xc0
c0001a56:	68 12 61 01 c0       	push   $0xc0016112
c0001a5b:	68 82 61 01 c0       	push   $0xc0016182
c0001a60:	68 69 60 01 c0       	push   $0xc0016069
c0001a65:	e8 dc fe ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

            preemption = true;
c0001a6a:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c0001a71:	fb                   	sti    
        va_list args;
        va_start (args, format);
        c->vprintf (format, args);
        va_end (args);
    }
}
c0001a72:	5b                   	pop    %ebx
c0001a73:	5e                   	pop    %esi
c0001a74:	c3                   	ret    

c0001a75 <_GLOBAL__sub_I__ZN7Console4listE>:
    private:
        uint16 val;

    public:
        ALWAYS_INLINE
        inline Spinlock() : val (0) {}
c0001a75:	66 c7 05 8e a3 01 c0 	movw   $0x0,0xc001a38e
c0001a7c:	00 00 
c0001a7e:	c3                   	ret    
c0001a7f:	90                   	nop

c0001a80 <_ZN14Console_serial4putcEi>:

void Console_serial::putc (int c)
{
c0001a80:	56                   	push   %esi
    if (c == '\n')
c0001a81:	83 fa 0a             	cmp    $0xa,%edx

    enable();
}

void Console_serial::putc (int c)
{
c0001a84:	53                   	push   %ebx
c0001a85:	89 c3                	mov    %eax,%ebx
c0001a87:	51                   	push   %ecx
c0001a88:	89 14 24             	mov    %edx,(%esp)
    if (c == '\n')
c0001a8b:	75 06                	jne    c0001a93 <_ZN14Console_serial4putcEi+0x13>
        putc ('\r');
c0001a8d:	8b 08                	mov    (%eax),%ecx
c0001a8f:	b2 0d                	mov    $0xd,%dl
c0001a91:	ff 11                	call   *(%ecx)
c0001a93:	8b 73 08             	mov    0x8(%ebx),%esi
        static unsigned const freq = 115200;

        unsigned base;

        ALWAYS_INLINE
        inline unsigned in (Register r) { return Io::in<uint8>(base + r); }
c0001a96:	8d 56 05             	lea    0x5(%esi),%edx
        template <typename T>
        ALWAYS_INLINE
        static inline unsigned in (unsigned port)
        {
            T val;
            asm volatile ("in %w1, %0" : "=a" (val) : "Nd" (port));
c0001a99:	ec                   	in     (%dx),%al

    while (EXPECT_FALSE (!(in (LSR) & 0x20)))
c0001a9a:	24 20                	and    $0x20,%al
c0001a9c:	84 c0                	test   %al,%al
c0001a9e:	75 04                	jne    c0001aa4 <_ZN14Console_serial4putcEi+0x24>
}

ALWAYS_INLINE
static inline void pause()
{
    asm volatile ("pause" : : : "memory");
c0001aa0:	f3 90                	pause  
c0001aa2:	eb ef                	jmp    c0001a93 <_ZN14Console_serial4putcEi+0x13>

        template <typename T>
        ALWAYS_INLINE
        static inline void out (unsigned port, T val)
        {
            asm volatile ("out %0, %w1" : : "a" (val), "Nd" (port));
c0001aa4:	8a 04 24             	mov    (%esp),%al
c0001aa7:	89 f2                	mov    %esi,%edx
c0001aa9:	ee                   	out    %al,(%dx)
        pause();

    out (THR, c);
}
c0001aaa:	58                   	pop    %eax
c0001aab:	5b                   	pop    %ebx
c0001aac:	5e                   	pop    %esi
c0001aad:	c3                   	ret    

c0001aae <_ZN7Console6enableEv>:

    protected:
        NOINLINE
        void enable()
        {
            Console **ptr; for (ptr = &list; *ptr; ptr = &(*ptr)->next) ; *ptr = this;
c0001aae:	8b 15 90 a3 01 c0    	mov    0xc001a390,%edx
c0001ab4:	b9 90 a3 01 c0       	mov    $0xc001a390,%ecx
c0001ab9:	85 d2                	test   %edx,%edx
c0001abb:	74 08                	je     c0001ac5 <_ZN7Console6enableEv+0x17>
c0001abd:	8d 4a 04             	lea    0x4(%edx),%ecx
c0001ac0:	8b 52 04             	mov    0x4(%edx),%edx
c0001ac3:	eb f4                	jmp    c0001ab9 <_ZN7Console6enableEv+0xb>
c0001ac5:	89 01                	mov    %eax,(%ecx)
c0001ac7:	c3                   	ret    

c0001ac8 <_GLOBAL__sub_I.65533__ZN14Console_serial3conE>:
#include "console_serial.hpp"
#include "hpt.hpp"
#include "x86.hpp"
#include "pd.hpp"

INIT_PRIORITY (PRIO_CONSOLE) Console_serial Console_serial::con;
c0001ac8:	b8 94 a3 01 c0       	mov    $0xc001a394,%eax
c0001acd:	e9 d4 f0 1f 40       	jmp    200ba6 <_ZN14Console_serialC1Ev>

c0001ad2 <_ZN11Console_vga4putcEi>:

void Console_vga::putc (int c)
{
c0001ad2:	57                   	push   %edi
    if (EXPECT_FALSE (c == '\f')) {
c0001ad3:	83 fa 0c             	cmp    $0xc,%edx
            put (num, i, COLOR_LIGHT_BLACK, ((i - SPN_GSI) & 0xf)["0123456789ABCDEF"]);
    }
}

void Console_vga::putc (int c)
{
c0001ad6:	56                   	push   %esi
c0001ad7:	53                   	push   %ebx
c0001ad8:	89 c3                	mov    %eax,%ebx
    if (EXPECT_FALSE (c == '\f')) {
c0001ada:	75 20                	jne    c0001afc <_ZN11Console_vga4putcEi+0x2a>
        }

        ALWAYS_INLINE
        inline void clear_all()
        {
            memset (reinterpret_cast<void *>(HV_GLOBAL_FBUF), 0, 160 * num);
c0001adc:	69 48 08 a0 00 00 00 	imul   $0xa0,0x8(%eax),%ecx
c0001ae3:	bf 00 f0 bf cf       	mov    $0xcfbff000,%edi
c0001ae8:	31 c0                	xor    %eax,%eax
c0001aea:	f3 aa                	rep stos %al,%es:(%edi)
        clear_all();
        row = col = 0;
c0001aec:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
c0001af3:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
        return;
c0001afa:	eb 66                	jmp    c0001b62 <_ZN11Console_vga4putcEi+0x90>
    }

    if (EXPECT_TRUE (c != '\n')) {
c0001afc:	83 fa 0a             	cmp    $0xa,%edx
c0001aff:	75 3d                	jne    c0001b3e <_ZN11Console_vga4putcEi+0x6c>
            return;
    }

    col = 0;

    if (EXPECT_TRUE (++row == num))
c0001b01:	8b 7b 0c             	mov    0xc(%ebx),%edi
        put (row, col, COLOR_LIGHT_WHITE, c);
        if (EXPECT_TRUE (++col < 80))
            return;
    }

    col = 0;
c0001b04:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)

    if (EXPECT_TRUE (++row == num))
c0001b0b:	8d 47 01             	lea    0x1(%edi),%eax
c0001b0e:	3b 43 08             	cmp    0x8(%ebx),%eax
c0001b11:	89 43 0c             	mov    %eax,0xc(%ebx)
c0001b14:	75 4c                	jne    c0001b62 <_ZN11Console_vga4putcEi+0x90>
        }

        ALWAYS_INLINE
        inline void clear_row (unsigned r)
        {
            memcpy (reinterpret_cast<void *>(HV_GLOBAL_FBUF), reinterpret_cast<void *>(HV_GLOBAL_FBUF + 160), 160 * r);
c0001b16:	69 c7 a0 00 00 00    	imul   $0xa0,%edi,%eax
{
    mword dummy;
    asm volatile ("rep; movsb"
                  : "=D" (dummy), "+S" (s), "+c" (n)
                  : "0" (d)
                  : "memory");
c0001b1c:	be a0 f0 bf cf       	mov    $0xcfbff0a0,%esi
        clear_row (--row);
c0001b21:	89 7b 0c             	mov    %edi,0xc(%ebx)
c0001b24:	bf 00 f0 bf cf       	mov    $0xcfbff000,%edi
c0001b29:	89 c1                	mov    %eax,%ecx
c0001b2b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
{
    mword dummy;
    asm volatile ("rep; stosb"
                  : "=D" (dummy), "+c" (n)
                  : "0" (d), "a" (c)
                  : "memory");
c0001b2d:	b9 a0 00 00 00       	mov    $0xa0,%ecx
            memset (reinterpret_cast<void *>(HV_GLOBAL_FBUF + 160 * r), 0, 160);
c0001b32:	8d b8 00 f0 bf cf    	lea    -0x30401000(%eax),%edi
c0001b38:	31 c0                	xor    %eax,%eax
c0001b3a:	f3 aa                	rep stos %al,%es:(%edi)
c0001b3c:	eb 24                	jmp    c0001b62 <_ZN11Console_vga4putcEi+0x90>
c0001b3e:	8b 48 10             	mov    0x10(%eax),%ecx
        inline unsigned spinner (unsigned id) { return id < 25 - num ? 24 - id : 0; }

        ALWAYS_INLINE
        inline void put (unsigned long r, unsigned long c, Color color, int x)
        {
            *reinterpret_cast<unsigned short volatile *>(HV_GLOBAL_FBUF + r * 160 + c * 2) = static_cast<unsigned short>(color << 8 | x);
c0001b41:	80 ce 0f             	or     $0xf,%dh
c0001b44:	6b 40 0c 50          	imul   $0x50,0xc(%eax),%eax
c0001b48:	0f b7 d2             	movzwl %dx,%edx
c0001b4b:	8d 84 01 00 f8 df 67 	lea    0x67dff800(%ecx,%eax,1),%eax
c0001b52:	66 89 14 00          	mov    %dx,(%eax,%eax,1)
        return;
    }

    if (EXPECT_TRUE (c != '\n')) {
        put (row, col, COLOR_LIGHT_WHITE, c);
        if (EXPECT_TRUE (++col < 80))
c0001b56:	8b 43 10             	mov    0x10(%ebx),%eax
c0001b59:	40                   	inc    %eax
c0001b5a:	83 f8 4f             	cmp    $0x4f,%eax
c0001b5d:	89 43 10             	mov    %eax,0x10(%ebx)
c0001b60:	77 9f                	ja     c0001b01 <_ZN11Console_vga4putcEi+0x2f>

    col = 0;

    if (EXPECT_TRUE (++row == num))
        clear_row (--row);
}
c0001b62:	5b                   	pop    %ebx
c0001b63:	5e                   	pop    %esi
c0001b64:	5f                   	pop    %edi
c0001b65:	c3                   	ret    

c0001b66 <_GLOBAL__sub_I.65533__ZN11Console_vga3conE>:

#include "cmdline.hpp"
#include "console_vga.hpp"
#include "pd.hpp"

INIT_PRIORITY (PRIO_CONSOLE) Console_vga Console_vga::con;
c0001b66:	b8 a0 a3 01 c0       	mov    $0xc001a3a0,%eax
c0001b6b:	e9 b4 f0 1f 40       	jmp    200c24 <_ZN11Console_vgaC1Ev>

c0001b70 <_ZN7Counter4dumpEv>:
unsigned    Counter::schedule;
unsigned    Counter::helping;
uint64      Counter::cycles_idle;

void Counter::dump()
{
c0001b70:	57                   	push   %edi
c0001b71:	56                   	push   %esi
c0001b72:	53                   	push   %ebx
c0001b73:	52                   	push   %edx

ALWAYS_INLINE
static inline uint64 rdtsc()
{
    mword h, l;
    asm volatile ("rdtsc" : "=a" (l), "=d" (h));
c0001b74:	0f 31                	rdtsc  
    trace (0, "TIME: %16llu", rdtsc());
c0001b76:	8d 7c 24 ff          	lea    -0x1(%esp),%edi
c0001b7a:	83 ce ff             	or     $0xffffffff,%esi
c0001b7d:	89 fb                	mov    %edi,%ebx
c0001b7f:	89 f1                	mov    %esi,%ecx
c0001b81:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
c0001b87:	81 fb 00 d0 ff cf    	cmp    $0xcfffd000,%ebx
c0001b8d:	0f 44 0d 04 f0 ff cf 	cmove  0xcffff004,%ecx
c0001b94:	52                   	push   %edx
c0001b95:	50                   	push   %eax
c0001b96:	51                   	push   %ecx
c0001b97:	68 34 66 01 c0       	push   $0xc0016634
c0001b9c:	e8 3d fe ff ff       	call   c00019de <_ZN7Console5printEPKcz>
    trace (0, "IDLE: %16llu", Counter::cycles_idle);
c0001ba1:	83 c4 10             	add    $0x10,%esp
c0001ba4:	89 f0                	mov    %esi,%eax
c0001ba6:	ff 35 24 f0 ff cf    	pushl  0xcffff024
c0001bac:	81 fb 00 d0 ff cf    	cmp    $0xcfffd000,%ebx
c0001bb2:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0001bb9:	ff 35 20 f0 ff cf    	pushl  0xcffff020
c0001bbf:	50                   	push   %eax
c0001bc0:	68 48 66 01 c0       	push   $0xc0016648
c0001bc5:	e8 14 fe ff ff       	call   c00019de <_ZN7Console5printEPKcz>
    trace (0, "VGPF: %16u", Counter::vtlb_gpf);
c0001bca:	83 c4 10             	add    $0x10,%esp
c0001bcd:	89 f0                	mov    %esi,%eax
c0001bcf:	81 fb 00 d0 ff cf    	cmp    $0xcfffd000,%ebx
c0001bd5:	ff 35 3c f0 ff cf    	pushl  0xcffff03c
c0001bdb:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0001be2:	50                   	push   %eax
c0001be3:	68 5c 66 01 c0       	push   $0xc001665c
c0001be8:	e8 f1 fd ff ff       	call   c00019de <_ZN7Console5printEPKcz>
    trace (0, "VHPF: %16u", Counter::vtlb_hpf);
c0001bed:	83 c4 0c             	add    $0xc,%esp
c0001bf0:	89 f0                	mov    %esi,%eax
c0001bf2:	81 fb 00 d0 ff cf    	cmp    $0xcfffd000,%ebx
c0001bf8:	ff 35 38 f0 ff cf    	pushl  0xcffff038
c0001bfe:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0001c05:	50                   	push   %eax
c0001c06:	68 6e 66 01 c0       	push   $0xc001666e
c0001c0b:	e8 ce fd ff ff       	call   c00019de <_ZN7Console5printEPKcz>
    trace (0, "VFIL: %16u", Counter::vtlb_fill);
c0001c10:	83 c4 0c             	add    $0xc,%esp
c0001c13:	89 f0                	mov    %esi,%eax
c0001c15:	81 fb 00 d0 ff cf    	cmp    $0xcfffd000,%ebx
c0001c1b:	ff 35 34 f0 ff cf    	pushl  0xcffff034
c0001c21:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0001c28:	50                   	push   %eax
c0001c29:	68 80 66 01 c0       	push   $0xc0016680
c0001c2e:	e8 ab fd ff ff       	call   c00019de <_ZN7Console5printEPKcz>
    trace (0, "VFLU: %16u", Counter::vtlb_flush);
c0001c33:	83 c4 0c             	add    $0xc,%esp
c0001c36:	89 f0                	mov    %esi,%eax
c0001c38:	81 fb 00 d0 ff cf    	cmp    $0xcfffd000,%ebx
c0001c3e:	ff 35 30 f0 ff cf    	pushl  0xcffff030
c0001c44:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0001c4b:	50                   	push   %eax
c0001c4c:	68 92 66 01 c0       	push   $0xc0016692
c0001c51:	e8 88 fd ff ff       	call   c00019de <_ZN7Console5printEPKcz>
    trace (0, "SCHD: %16u", Counter::schedule);
c0001c56:	83 c4 0c             	add    $0xc,%esp
c0001c59:	89 f0                	mov    %esi,%eax
c0001c5b:	81 fb 00 d0 ff cf    	cmp    $0xcfffd000,%ebx
c0001c61:	ff 35 2c f0 ff cf    	pushl  0xcffff02c
c0001c67:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0001c6e:	50                   	push   %eax
c0001c6f:	68 a4 66 01 c0       	push   $0xc00166a4
c0001c74:	e8 65 fd ff ff       	call   c00019de <_ZN7Console5printEPKcz>
    trace (0, "HELP: %16u", Counter::helping);
c0001c79:	83 c4 0c             	add    $0xc,%esp
c0001c7c:	81 fb 00 d0 ff cf    	cmp    $0xcfffd000,%ebx
c0001c82:	ff 35 28 f0 ff cf    	pushl  0xcffff028
c0001c88:	0f 44 35 04 f0 ff cf 	cmove  0xcffff004,%esi
c0001c8f:	56                   	push   %esi

    Counter::vtlb_gpf = Counter::vtlb_hpf = Counter::vtlb_fill = Counter::vtlb_flush = Counter::schedule = Counter::helping = 0;

    for (unsigned i = 0; i < sizeof (Counter::ipi) / sizeof (*Counter::ipi); i++)
c0001c90:	31 f6                	xor    %esi,%esi
    trace (0, "VGPF: %16u", Counter::vtlb_gpf);
    trace (0, "VHPF: %16u", Counter::vtlb_hpf);
    trace (0, "VFIL: %16u", Counter::vtlb_fill);
    trace (0, "VFLU: %16u", Counter::vtlb_flush);
    trace (0, "SCHD: %16u", Counter::schedule);
    trace (0, "HELP: %16u", Counter::helping);
c0001c92:	68 b6 66 01 c0       	push   $0xc00166b6
c0001c97:	e8 42 fd ff ff       	call   c00019de <_ZN7Console5printEPKcz>

    Counter::vtlb_gpf = Counter::vtlb_hpf = Counter::vtlb_fill = Counter::vtlb_flush = Counter::schedule = Counter::helping = 0;
c0001c9c:	83 c4 0c             	add    $0xc,%esp
c0001c9f:	c7 05 28 f0 ff cf 00 	movl   $0x0,0xcffff028
c0001ca6:	00 00 00 
c0001ca9:	c7 05 2c f0 ff cf 00 	movl   $0x0,0xcffff02c
c0001cb0:	00 00 00 
c0001cb3:	c7 05 30 f0 ff cf 00 	movl   $0x0,0xcffff030
c0001cba:	00 00 00 
c0001cbd:	c7 05 34 f0 ff cf 00 	movl   $0x0,0xcffff034
c0001cc4:	00 00 00 
c0001cc7:	c7 05 38 f0 ff cf 00 	movl   $0x0,0xcffff038
c0001cce:	00 00 00 
c0001cd1:	c7 05 3c f0 ff cf 00 	movl   $0x0,0xcffff03c
c0001cd8:	00 00 00 

    for (unsigned i = 0; i < sizeof (Counter::ipi) / sizeof (*Counter::ipi); i++)
        if (Counter::ipi[i]) {
c0001cdb:	8b 14 b5 d8 f6 ff cf 	mov    -0x30000928(,%esi,4),%edx
c0001ce2:	85 d2                	test   %edx,%edx
c0001ce4:	74 2d                	je     c0001d13 <_ZN7Counter4dumpEv+0x1a3>
            trace (0, "IPI %#4x: %12u", i, Counter::ipi[i]);
c0001ce6:	81 fb 00 d0 ff cf    	cmp    $0xcfffd000,%ebx
c0001cec:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0001cf1:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0001cf8:	52                   	push   %edx
c0001cf9:	56                   	push   %esi
c0001cfa:	50                   	push   %eax
c0001cfb:	68 c8 66 01 c0       	push   $0xc00166c8
c0001d00:	e8 d9 fc ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c0001d05:	83 c4 10             	add    $0x10,%esp
            Counter::ipi[i] = 0;
c0001d08:	c7 04 b5 d8 f6 ff cf 	movl   $0x0,-0x30000928(,%esi,4)
c0001d0f:	00 00 00 00 
    trace (0, "SCHD: %16u", Counter::schedule);
    trace (0, "HELP: %16u", Counter::helping);

    Counter::vtlb_gpf = Counter::vtlb_hpf = Counter::vtlb_fill = Counter::vtlb_flush = Counter::schedule = Counter::helping = 0;

    for (unsigned i = 0; i < sizeof (Counter::ipi) / sizeof (*Counter::ipi); i++)
c0001d13:	46                   	inc    %esi
c0001d14:	83 fe 03             	cmp    $0x3,%esi
c0001d17:	75 c2                	jne    c0001cdb <_ZN7Counter4dumpEv+0x16b>
            Counter::ipi[i] = 0;
        }

    for (unsigned i = 0; i < sizeof (Counter::lvt) / sizeof (*Counter::lvt); i++)
        if (Counter::lvt[i]) {
            trace (0, "LVT %#4x: %12u", i, Counter::lvt[i]);
c0001d19:	89 fe                	mov    %edi,%esi
c0001d1b:	31 db                	xor    %ebx,%ebx
c0001d1d:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
            trace (0, "IPI %#4x: %12u", i, Counter::ipi[i]);
            Counter::ipi[i] = 0;
        }

    for (unsigned i = 0; i < sizeof (Counter::lvt) / sizeof (*Counter::lvt); i++)
        if (Counter::lvt[i]) {
c0001d23:	8b 14 9d c0 f6 ff cf 	mov    -0x30000940(,%ebx,4),%edx
c0001d2a:	85 d2                	test   %edx,%edx
c0001d2c:	74 2d                	je     c0001d5b <_ZN7Counter4dumpEv+0x1eb>
            trace (0, "LVT %#4x: %12u", i, Counter::lvt[i]);
c0001d2e:	81 fe 00 d0 ff cf    	cmp    $0xcfffd000,%esi
c0001d34:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0001d39:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0001d40:	52                   	push   %edx
c0001d41:	53                   	push   %ebx
c0001d42:	50                   	push   %eax
c0001d43:	68 de 66 01 c0       	push   $0xc00166de
c0001d48:	e8 91 fc ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c0001d4d:	83 c4 10             	add    $0x10,%esp
            Counter::lvt[i] = 0;
c0001d50:	c7 04 9d c0 f6 ff cf 	movl   $0x0,-0x30000940(,%ebx,4)
c0001d57:	00 00 00 00 
        if (Counter::ipi[i]) {
            trace (0, "IPI %#4x: %12u", i, Counter::ipi[i]);
            Counter::ipi[i] = 0;
        }

    for (unsigned i = 0; i < sizeof (Counter::lvt) / sizeof (*Counter::lvt); i++)
c0001d5b:	43                   	inc    %ebx
c0001d5c:	83 fb 06             	cmp    $0x6,%ebx
c0001d5f:	75 c2                	jne    c0001d23 <_ZN7Counter4dumpEv+0x1b3>
            Counter::lvt[i] = 0;
        }

    for (unsigned i = 0; i < sizeof (Counter::gsi) / sizeof (*Counter::gsi); i++)
        if (Counter::gsi[i]) {
            trace (0, "GSI %#4x: %12u", i, Counter::gsi[i]);
c0001d61:	89 fe                	mov    %edi,%esi
c0001d63:	30 db                	xor    %bl,%bl
c0001d65:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
            trace (0, "LVT %#4x: %12u", i, Counter::lvt[i]);
            Counter::lvt[i] = 0;
        }

    for (unsigned i = 0; i < sizeof (Counter::gsi) / sizeof (*Counter::gsi); i++)
        if (Counter::gsi[i]) {
c0001d6b:	8b 14 9d c0 f4 ff cf 	mov    -0x30000b40(,%ebx,4),%edx
c0001d72:	85 d2                	test   %edx,%edx
c0001d74:	74 2d                	je     c0001da3 <_ZN7Counter4dumpEv+0x233>
            trace (0, "GSI %#4x: %12u", i, Counter::gsi[i]);
c0001d76:	81 fe 00 d0 ff cf    	cmp    $0xcfffd000,%esi
c0001d7c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0001d81:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0001d88:	52                   	push   %edx
c0001d89:	53                   	push   %ebx
c0001d8a:	50                   	push   %eax
c0001d8b:	68 f4 66 01 c0       	push   $0xc00166f4
c0001d90:	e8 49 fc ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c0001d95:	83 c4 10             	add    $0x10,%esp
            Counter::gsi[i] = 0;
c0001d98:	c7 04 9d c0 f4 ff cf 	movl   $0x0,-0x30000b40(,%ebx,4)
c0001d9f:	00 00 00 00 
        if (Counter::lvt[i]) {
            trace (0, "LVT %#4x: %12u", i, Counter::lvt[i]);
            Counter::lvt[i] = 0;
        }

    for (unsigned i = 0; i < sizeof (Counter::gsi) / sizeof (*Counter::gsi); i++)
c0001da3:	43                   	inc    %ebx
c0001da4:	81 fb 80 00 00 00    	cmp    $0x80,%ebx
c0001daa:	75 bf                	jne    c0001d6b <_ZN7Counter4dumpEv+0x1fb>
            Counter::gsi[i] = 0;
        }

    for (unsigned i = 0; i < sizeof (Counter::exc) / sizeof (*Counter::exc); i++)
        if (Counter::exc[i]) {
            trace (0, "EXC %#4x: %12u", i, Counter::exc[i]);
c0001dac:	89 fe                	mov    %edi,%esi
c0001dae:	30 db                	xor    %bl,%bl
c0001db0:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
            trace (0, "GSI %#4x: %12u", i, Counter::gsi[i]);
            Counter::gsi[i] = 0;
        }

    for (unsigned i = 0; i < sizeof (Counter::exc) / sizeof (*Counter::exc); i++)
        if (Counter::exc[i]) {
c0001db6:	8b 14 9d 40 f4 ff cf 	mov    -0x30000bc0(,%ebx,4),%edx
c0001dbd:	85 d2                	test   %edx,%edx
c0001dbf:	74 2d                	je     c0001dee <_ZN7Counter4dumpEv+0x27e>
            trace (0, "EXC %#4x: %12u", i, Counter::exc[i]);
c0001dc1:	81 fe 00 d0 ff cf    	cmp    $0xcfffd000,%esi
c0001dc7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0001dcc:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0001dd3:	52                   	push   %edx
c0001dd4:	53                   	push   %ebx
c0001dd5:	50                   	push   %eax
c0001dd6:	68 0a 67 01 c0       	push   $0xc001670a
c0001ddb:	e8 fe fb ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c0001de0:	83 c4 10             	add    $0x10,%esp
            Counter::exc[i] = 0;
c0001de3:	c7 04 9d 40 f4 ff cf 	movl   $0x0,-0x30000bc0(,%ebx,4)
c0001dea:	00 00 00 00 
        if (Counter::gsi[i]) {
            trace (0, "GSI %#4x: %12u", i, Counter::gsi[i]);
            Counter::gsi[i] = 0;
        }

    for (unsigned i = 0; i < sizeof (Counter::exc) / sizeof (*Counter::exc); i++)
c0001dee:	43                   	inc    %ebx
c0001def:	83 fb 20             	cmp    $0x20,%ebx
c0001df2:	75 c2                	jne    c0001db6 <_ZN7Counter4dumpEv+0x246>
c0001df4:	30 db                	xor    %bl,%bl
            Counter::exc[i] = 0;
        }

    for (unsigned i = 0; i < sizeof (Counter::vmi) / sizeof (*Counter::vmi); i++)
        if (Counter::vmi[i]) {
            trace (0, "VMI %#4x: %12u", i, Counter::vmi[i]);
c0001df6:	81 e7 00 f0 ff ff    	and    $0xfffff000,%edi
            trace (0, "EXC %#4x: %12u", i, Counter::exc[i]);
            Counter::exc[i] = 0;
        }

    for (unsigned i = 0; i < sizeof (Counter::vmi) / sizeof (*Counter::vmi); i++)
        if (Counter::vmi[i]) {
c0001dfc:	8b 14 9d 40 f0 ff cf 	mov    -0x30000fc0(,%ebx,4),%edx
c0001e03:	85 d2                	test   %edx,%edx
c0001e05:	74 2d                	je     c0001e34 <_ZN7Counter4dumpEv+0x2c4>
            trace (0, "VMI %#4x: %12u", i, Counter::vmi[i]);
c0001e07:	81 ff 00 d0 ff cf    	cmp    $0xcfffd000,%edi
c0001e0d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0001e12:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0001e19:	52                   	push   %edx
c0001e1a:	53                   	push   %ebx
c0001e1b:	50                   	push   %eax
c0001e1c:	68 20 67 01 c0       	push   $0xc0016720
c0001e21:	e8 b8 fb ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c0001e26:	83 c4 10             	add    $0x10,%esp
            Counter::vmi[i] = 0;
c0001e29:	c7 04 9d 40 f0 ff cf 	movl   $0x0,-0x30000fc0(,%ebx,4)
c0001e30:	00 00 00 00 
        if (Counter::exc[i]) {
            trace (0, "EXC %#4x: %12u", i, Counter::exc[i]);
            Counter::exc[i] = 0;
        }

    for (unsigned i = 0; i < sizeof (Counter::vmi) / sizeof (*Counter::vmi); i++)
c0001e34:	43                   	inc    %ebx
c0001e35:	81 fb 00 01 00 00    	cmp    $0x100,%ebx
c0001e3b:	75 bf                	jne    c0001dfc <_ZN7Counter4dumpEv+0x28c>
        if (Counter::vmi[i]) {
            trace (0, "VMI %#4x: %12u", i, Counter::vmi[i]);
            Counter::vmi[i] = 0;
        }
}
c0001e3d:	58                   	pop    %eax
c0001e3e:	5b                   	pop    %ebx
c0001e3f:	5e                   	pop    %esi
c0001e40:	5f                   	pop    %edi
c0001e41:	c3                   	ret    

c0001e42 <_ZN3Cpu4initEv>:

    set_cr4 (get_cr4() | Cpu::CR4_PCIDE);
}

void Cpu::init()
{
c0001e42:	55                   	push   %ebp
c0001e43:	57                   	push   %edi
c0001e44:	56                   	push   %esi
c0001e45:	53                   	push   %ebx
    for (void (**func)() = &CTORS_L; func != &CTORS_C; (*func++)()) ;
c0001e46:	bb 48 9f 01 c0       	mov    $0xc0019f48,%ebx

    set_cr4 (get_cr4() | Cpu::CR4_PCIDE);
}

void Cpu::init()
{
c0001e4b:	83 ec 14             	sub    $0x14,%esp
    for (void (**func)() = &CTORS_L; func != &CTORS_C; (*func++)()) ;
c0001e4e:	81 fb 54 9f 01 c0    	cmp    $0xc0019f54,%ebx
c0001e54:	74 08                	je     c0001e5e <_ZN3Cpu4initEv+0x1c>
c0001e56:	83 c3 04             	add    $0x4,%ebx
c0001e59:	ff 53 fc             	call   *-0x4(%ebx)
c0001e5c:	eb f0                	jmp    c0001e4e <_ZN3Cpu4initEv+0xc>

    Gdt::build();
c0001e5e:	e8 4f 37 00 00       	call   c00055b2 <_ZN3Gdt5buildEv>
    Tss::build();
c0001e63:	e8 84 27 01 00       	call   c00145ec <_ZN3Tss5buildEv>
        uint16  limit;
        mword   base;

    public:
        ALWAYS_INLINE
        inline Pseudo_descriptor (mword l, mword b) : limit (static_cast<uint16>(l)), base (b) {}
c0001e68:	66 c7 44 24 0c 4f 00 	movw   $0x4f,0xc(%esp)
c0001e6f:	c7 44 24 0e 80 f7 ff 	movl   $0xcffff780,0xe(%esp)
c0001e76:	cf 
        static void build();

        ALWAYS_INLINE
        static inline void load()
        {
            asm volatile ("lgdt %0" : : "m" (Pseudo_descriptor (sizeof (gdt) - 1, reinterpret_cast<mword>(gdt))));
c0001e77:	0f 01 54 24 0c       	lgdtl  0xc(%esp)
        static void build();

        ALWAYS_INLINE
        static inline void load()
        {
            asm volatile ("ltr %w0" : : "rm" (SEL_TSS_RUN));
c0001e7c:	b8 30 00 00 00       	mov    $0x30,%eax
c0001e81:	0f 00 d8             	ltr    %ax
c0001e84:	66 c7 44 24 0c 4f 05 	movw   $0x54f,0xc(%esp)
c0001e8b:	c7 44 24 0e 08 ab 01 	movl   $0xc001ab08,0xe(%esp)
c0001e92:	c0 
        static void build();

        ALWAYS_INLINE
        static inline void load()
        {
            asm volatile ("lidt %0" : : "m" (Pseudo_descriptor (sizeof (idt) - 1, reinterpret_cast<mword>(idt))));
c0001e93:	0f 01 5c 24 0c       	lidtl  0xc(%esp)
        }

        ALWAYS_INLINE
        static inline void cpuid (unsigned leaf, uint32 &eax, uint32 &ebx, uint32 &ecx, uint32 &edx)
        {
            asm volatile ("cpuid" : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx) : "a" (leaf));
c0001e98:	30 c0                	xor    %al,%al
c0001e9a:	0f a2                	cpuid  

    cpuid (0, eax, ebx, ecx, edx);

    size_t v;
    for (v = sizeof (vendor_string) / sizeof (*vendor_string); --v;)
        if (*reinterpret_cast<uint32 const *>(vendor_string[v] + 0) == ebx &&
c0001e9c:	39 1d 36 67 01 c0    	cmp    %ebx,0xc0016736
c0001ea2:	89 04 24             	mov    %eax,(%esp)
c0001ea5:	75 15                	jne    c0001ebc <_ZN3Cpu4initEv+0x7a>
c0001ea7:	39 15 3a 67 01 c0    	cmp    %edx,0xc001673a
c0001ead:	75 0d                	jne    c0001ebc <_ZN3Cpu4initEv+0x7a>
            *reinterpret_cast<uint32 const *>(vendor_string[v] + 4) == edx &&
c0001eaf:	39 0d 3e 67 01 c0    	cmp    %ecx,0xc001673e
    uint32 eax, ebx, ecx, edx;

    cpuid (0, eax, ebx, ecx, edx);

    size_t v;
    for (v = sizeof (vendor_string) / sizeof (*vendor_string); --v;)
c0001eb5:	be 02 00 00 00       	mov    $0x2,%esi
        if (*reinterpret_cast<uint32 const *>(vendor_string[v] + 0) == ebx &&
            *reinterpret_cast<uint32 const *>(vendor_string[v] + 4) == edx &&
c0001eba:	74 1e                	je     c0001eda <_ZN3Cpu4initEv+0x98>
    uint32 eax, ebx, ecx, edx;

    cpuid (0, eax, ebx, ecx, edx);

    size_t v;
    for (v = sizeof (vendor_string) / sizeof (*vendor_string); --v;)
c0001ebc:	31 f6                	xor    %esi,%esi
        if (*reinterpret_cast<uint32 const *>(vendor_string[v] + 0) == ebx &&
c0001ebe:	39 1d 43 67 01 c0    	cmp    %ebx,0xc0016743
c0001ec4:	75 14                	jne    c0001eda <_ZN3Cpu4initEv+0x98>
c0001ec6:	39 15 47 67 01 c0    	cmp    %edx,0xc0016747
c0001ecc:	75 0c                	jne    c0001eda <_ZN3Cpu4initEv+0x98>
            *reinterpret_cast<uint32 const *>(vendor_string[v] + 4) == edx &&
c0001ece:	39 0d 4b 67 01 c0    	cmp    %ecx,0xc001674b
c0001ed4:	0f 94 c0             	sete   %al
c0001ed7:	0f b6 f0             	movzbl %al,%esi
            *reinterpret_cast<uint32 const *>(vendor_string[v] + 8) == ecx)
            break;

    vendor = Vendor (v);
c0001eda:	89 35 6c f7 ff cf    	mov    %esi,0xcffff76c

    if (vendor == INTEL) {
c0001ee0:	4e                   	dec    %esi
c0001ee1:	75 1b                	jne    c0001efe <_ZN3Cpu4initEv+0xbc>
c0001ee3:	31 c0                	xor    %eax,%eax
c0001ee5:	b9 8b 00 00 00       	mov    $0x8b,%ecx
c0001eea:	89 c2                	mov    %eax,%edx
c0001eec:	0f 30                	wrmsr  
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
c0001eee:	b1 17                	mov    $0x17,%cl
c0001ef0:	0f 32                	rdmsr  
        Msr::write<uint64>(Msr::IA32_BIOS_SIGN_ID, 0);
        platform = static_cast<unsigned>(Msr::read<uint64>(Msr::IA32_PLATFORM_ID) >> 50) & 7;
c0001ef2:	c1 ea 12             	shr    $0x12,%edx
c0001ef5:	83 e2 07             	and    $0x7,%edx
c0001ef8:	89 15 68 f7 ff cf    	mov    %edx,0xcffff768
c0001efe:	0f b6 04 24          	movzbl (%esp),%eax
    }

    switch (static_cast<uint8>(eax)) {
c0001f02:	48                   	dec    %eax
c0001f03:	83 f8 05             	cmp    $0x5,%eax
c0001f06:	77 07                	ja     c0001f0f <_ZN3Cpu4initEv+0xcd>
c0001f08:	ff 24 85 a4 67 01 c0 	jmp    *-0x3ffe985c(,%eax,4)
        }

        ALWAYS_INLINE
        static inline void cpuid (unsigned leaf, unsigned subleaf, uint32 &eax, uint32 &ebx, uint32 &ecx, uint32 &edx)
        {
            asm volatile ("cpuid" : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx) : "a" (leaf), "c" (subleaf));
c0001f0f:	31 c9                	xor    %ecx,%ecx
c0001f11:	b8 07 00 00 00       	mov    $0x7,%eax
c0001f16:	0f a2                	cpuid  
c0001f18:	89 1d 10 f7 ff cf    	mov    %ebx,0xcffff710
        }

        ALWAYS_INLINE
        static inline void cpuid (unsigned leaf, uint32 &eax, uint32 &ebx, uint32 &ecx, uint32 &edx)
        {
            asm volatile ("cpuid" : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx) : "a" (leaf));
c0001f1e:	b8 06 00 00 00       	mov    $0x6,%eax
c0001f23:	0f a2                	cpuid  
c0001f25:	a3 0c f7 ff cf       	mov    %eax,0xcffff70c
        }

        ALWAYS_INLINE
        static inline void cpuid (unsigned leaf, unsigned subleaf, uint32 &eax, uint32 &ebx, uint32 &ecx, uint32 &edx)
        {
            asm volatile ("cpuid" : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx) : "a" (leaf), "c" (subleaf));
c0001f2a:	31 c9                	xor    %ecx,%ecx
c0001f2c:	b8 04 00 00 00       	mov    $0x4,%eax
c0001f31:	0f a2                	cpuid  
            cpuid (0x7, 0, eax, features[3], ecx, edx);
        case 0x6:
            cpuid (0x6, features[2], ebx, ecx, edx);
        case 0x4 ... 0x5:
            cpuid (0x4, 0, eax, ebx, ecx, edx);
            cpp = (eax >> 26 & 0x3f) + 1;
c0001f33:	c1 e8 1a             	shr    $0x1a,%eax
c0001f36:	8d 70 01             	lea    0x1(%eax),%esi
c0001f39:	eb 05                	jmp    c0001f40 <_ZN3Cpu4initEv+0xfe>
bool        Cpu::bsp;
bool        Cpu::preemption;

void Cpu::check_features()
{
    unsigned top, tpp = 1, cpp = 1;
c0001f3b:	be 01 00 00 00       	mov    $0x1,%esi
        }

        ALWAYS_INLINE
        static inline void cpuid (unsigned leaf, uint32 &eax, uint32 &ebx, uint32 &ecx, uint32 &edx)
        {
            asm volatile ("cpuid" : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx) : "a" (leaf));
c0001f40:	b8 01 00 00 00       	mov    $0x1,%eax
c0001f45:	0f a2                	cpuid  
c0001f47:	89 15 04 f7 ff cf    	mov    %edx,0xcffff704
        case 0x4 ... 0x5:
            cpuid (0x4, 0, eax, ebx, ecx, edx);
            cpp = (eax >> 26 & 0x3f) + 1;
        case 0x1 ... 0x3:
            cpuid (0x1, eax, ebx, features[1], features[0]);
            family   = (eax >> 8 & 0xf) + (eax >> 20 & 0xff);
c0001f4d:	89 c2                	mov    %eax,%edx
            model    = (eax >> 4 & 0xf) + (eax >> 12 & 0xf0);
            stepping =  eax & 0xf;
            brand    =  ebx & 0xff;
            top      =  ebx >> 24;
c0001f4f:	89 dd                	mov    %ebx,%ebp
        case 0x4 ... 0x5:
            cpuid (0x4, 0, eax, ebx, ecx, edx);
            cpp = (eax >> 26 & 0x3f) + 1;
        case 0x1 ... 0x3:
            cpuid (0x1, eax, ebx, features[1], features[0]);
            family   = (eax >> 8 & 0xf) + (eax >> 20 & 0xff);
c0001f51:	c1 ea 14             	shr    $0x14,%edx
c0001f54:	89 0d 08 f7 ff cf    	mov    %ecx,0xcffff708
c0001f5a:	0f b6 ca             	movzbl %dl,%ecx
c0001f5d:	89 c2                	mov    %eax,%edx
c0001f5f:	c1 ea 08             	shr    $0x8,%edx
c0001f62:	83 e2 0f             	and    $0xf,%edx
c0001f65:	01 ca                	add    %ecx,%edx
c0001f67:	89 15 64 f7 ff cf    	mov    %edx,0xcffff764
            model    = (eax >> 4 & 0xf) + (eax >> 12 & 0xf0);
c0001f6d:	89 c2                	mov    %eax,%edx
c0001f6f:	c1 ea 0c             	shr    $0xc,%edx
c0001f72:	89 d1                	mov    %edx,%ecx
c0001f74:	89 c2                	mov    %eax,%edx
c0001f76:	c1 ea 04             	shr    $0x4,%edx
c0001f79:	81 e1 f0 00 00 00    	and    $0xf0,%ecx
            stepping =  eax & 0xf;
c0001f7f:	83 e0 0f             	and    $0xf,%eax
            cpuid (0x4, 0, eax, ebx, ecx, edx);
            cpp = (eax >> 26 & 0x3f) + 1;
        case 0x1 ... 0x3:
            cpuid (0x1, eax, ebx, features[1], features[0]);
            family   = (eax >> 8 & 0xf) + (eax >> 20 & 0xff);
            model    = (eax >> 4 & 0xf) + (eax >> 12 & 0xf0);
c0001f82:	83 e2 0f             	and    $0xf,%edx
c0001f85:	01 ca                	add    %ecx,%edx
c0001f87:	b9 8b 00 00 00       	mov    $0x8b,%ecx
            stepping =  eax & 0xf;
c0001f8c:	a3 5c f7 ff cf       	mov    %eax,0xcffff75c
            brand    =  ebx & 0xff;
c0001f91:	0f b6 c3             	movzbl %bl,%eax
            top      =  ebx >> 24;
            tpp      =  ebx >> 16 & 0xff;
c0001f94:	c1 eb 10             	shr    $0x10,%ebx
            cpuid (0x4, 0, eax, ebx, ecx, edx);
            cpp = (eax >> 26 & 0x3f) + 1;
        case 0x1 ... 0x3:
            cpuid (0x1, eax, ebx, features[1], features[0]);
            family   = (eax >> 8 & 0xf) + (eax >> 20 & 0xff);
            model    = (eax >> 4 & 0xf) + (eax >> 12 & 0xf0);
c0001f97:	89 15 60 f7 ff cf    	mov    %edx,0xcffff760
            stepping =  eax & 0xf;
            brand    =  ebx & 0xff;
            top      =  ebx >> 24;
c0001f9d:	c1 ed 18             	shr    $0x18,%ebp
            tpp      =  ebx >> 16 & 0xff;
c0001fa0:	0f b6 fb             	movzbl %bl,%edi
        case 0x1 ... 0x3:
            cpuid (0x1, eax, ebx, features[1], features[0]);
            family   = (eax >> 8 & 0xf) + (eax >> 20 & 0xff);
            model    = (eax >> 4 & 0xf) + (eax >> 12 & 0xf0);
            stepping =  eax & 0xf;
            brand    =  ebx & 0xff;
c0001fa3:	a3 58 f7 ff cf       	mov    %eax,0xcffff758
c0001fa8:	0f 32                	rdmsr  
c0001faa:	b8 00 00 00 80       	mov    $0x80000000,%eax
            top      =  ebx >> 24;
            tpp      =  ebx >> 16 & 0xff;
    }

    patch = static_cast<unsigned>(Msr::read<uint64>(Msr::IA32_BIOS_SIGN_ID) >> 32);
c0001faf:	89 15 54 f7 ff cf    	mov    %edx,0xcffff754
c0001fb5:	0f a2                	cpuid  

    cpuid (0x80000000, eax, ebx, ecx, edx);

    if (eax & 0x80000000) {
c0001fb7:	85 c0                	test   %eax,%eax
c0001fb9:	0f 89 8f 00 00 00    	jns    c000204e <_ZN3Cpu4initEv+0x20c>
c0001fbf:	0f b6 c0             	movzbl %al,%eax
        switch (static_cast<uint8>(eax)) {
c0001fc2:	48                   	dec    %eax
c0001fc3:	83 f8 08             	cmp    $0x8,%eax
c0001fc6:	77 07                	ja     c0001fcf <_ZN3Cpu4initEv+0x18d>
c0001fc8:	ff 24 85 bc 67 01 c0 	jmp    *-0x3ffe9844(,%eax,4)
c0001fcf:	b8 0a 00 00 80       	mov    $0x8000000a,%eax
c0001fd4:	0f a2                	cpuid  
c0001fd6:	a3 34 fa ff cf       	mov    %eax,0xcffffa34
c0001fdb:	89 15 30 fa ff cf    	mov    %edx,0xcffffa30
c0001fe1:	b8 04 00 00 80       	mov    $0x80000004,%eax
c0001fe6:	0f a2                	cpuid  
c0001fe8:	a3 40 f7 ff cf       	mov    %eax,0xcffff740
c0001fed:	89 1d 44 f7 ff cf    	mov    %ebx,0xcffff744
c0001ff3:	89 0d 48 f7 ff cf    	mov    %ecx,0xcffff748
c0001ff9:	89 15 4c f7 ff cf    	mov    %edx,0xcffff74c
c0001fff:	b8 03 00 00 80       	mov    $0x80000003,%eax
c0002004:	0f a2                	cpuid  
c0002006:	a3 30 f7 ff cf       	mov    %eax,0xcffff730
c000200b:	89 1d 34 f7 ff cf    	mov    %ebx,0xcffff734
c0002011:	89 0d 38 f7 ff cf    	mov    %ecx,0xcffff738
c0002017:	89 15 3c f7 ff cf    	mov    %edx,0xcffff73c
c000201d:	b8 02 00 00 80       	mov    $0x80000002,%eax
c0002022:	0f a2                	cpuid  
c0002024:	a3 20 f7 ff cf       	mov    %eax,0xcffff720
c0002029:	89 1d 24 f7 ff cf    	mov    %ebx,0xcffff724
c000202f:	89 0d 28 f7 ff cf    	mov    %ecx,0xcffff728
c0002035:	89 15 2c f7 ff cf    	mov    %edx,0xcffff72c
c000203b:	b8 01 00 00 80       	mov    $0x80000001,%eax
c0002040:	0f a2                	cpuid  
c0002042:	89 0d 18 f7 ff cf    	mov    %ecx,0xcffff718
c0002048:	89 15 14 f7 ff cf    	mov    %edx,0xcffff714
                cpuid (0x80000001, eax, ebx, features[5], features[4]);
        }
    }

    if (feature (FEAT_CMP_LEGACY))
        cpp = tpp;
c000204e:	f6 05 18 f7 ff cf 02 	testb  $0x2,0xcffff718

    unsigned tpc = tpp / cpp;
c0002055:	89 f8                	mov    %edi,%eax
                cpuid (0x80000001, eax, ebx, features[5], features[4]);
        }
    }

    if (feature (FEAT_CMP_LEGACY))
        cpp = tpp;
c0002057:	0f 45 f7             	cmovne %edi,%esi

    unsigned tpc = tpp / cpp;
c000205a:	31 d2                	xor    %edx,%edx
c000205c:	f7 f6                	div    %esi

ALWAYS_INLINE
inline long int bit_scan_reverse (mword val)
{
    if (EXPECT_FALSE (!val))
        return -1;
c000205e:	83 c9 ff             	or     $0xffffffff,%ecx
#include "util.hpp"

ALWAYS_INLINE
inline long int bit_scan_reverse (mword val)
{
    if (EXPECT_FALSE (!val))
c0002061:	48                   	dec    %eax
c0002062:	74 03                	je     c0002067 <_ZN3Cpu4initEv+0x225>
        return -1;

    asm volatile ("bsr %1, %0" : "=r" (val) : "rm" (val));

    return val;
c0002064:	0f bd c8             	bsr    %eax,%ecx

ALWAYS_INLINE
inline long int bit_scan_reverse (mword val)
{
    if (EXPECT_FALSE (!val))
        return -1;
c0002067:	83 ca ff             	or     $0xffffffff,%edx
#include "util.hpp"

ALWAYS_INLINE
inline long int bit_scan_reverse (mword val)
{
    if (EXPECT_FALSE (!val))
c000206a:	4e                   	dec    %esi
    unsigned long t_bits = bit_scan_reverse (tpc - 1) + 1;
c000206b:	8d 41 01             	lea    0x1(%ecx),%eax
c000206e:	74 03                	je     c0002073 <_ZN3Cpu4initEv+0x231>
        return -1;

    asm volatile ("bsr %1, %0" : "=r" (val) : "rm" (val));

    return val;
c0002070:	0f bd d6             	bsr    %esi,%edx
    unsigned long c_bits = bit_scan_reverse (cpp - 1) + 1;

    thread  = top            & ((1u << t_bits) - 1);
c0002073:	bb 01 00 00 00       	mov    $0x1,%ebx
c0002078:	88 c1                	mov    %al,%cl
c000207a:	89 df                	mov    %ebx,%edi
    if (feature (FEAT_CMP_LEGACY))
        cpp = tpp;

    unsigned tpc = tpp / cpp;
    unsigned long t_bits = bit_scan_reverse (tpc - 1) + 1;
    unsigned long c_bits = bit_scan_reverse (cpp - 1) + 1;
c000207c:	42                   	inc    %edx

    thread  = top            & ((1u << t_bits) - 1);
c000207d:	d3 e7                	shl    %cl,%edi
c000207f:	89 f9                	mov    %edi,%ecx
    core    = top >>  t_bits & ((1u << c_bits) - 1);
c0002081:	89 ef                	mov    %ebp,%edi

    unsigned tpc = tpp / cpp;
    unsigned long t_bits = bit_scan_reverse (tpc - 1) + 1;
    unsigned long c_bits = bit_scan_reverse (cpp - 1) + 1;

    thread  = top            & ((1u << t_bits) - 1);
c0002083:	49                   	dec    %ecx
c0002084:	21 e9                	and    %ebp,%ecx
c0002086:	89 0d 70 f7 ff cf    	mov    %ecx,0xcffff770
    core    = top >>  t_bits & ((1u << c_bits) - 1);
c000208c:	88 d1                	mov    %dl,%cl
c000208e:	d3 e3                	shl    %cl,%ebx
c0002090:	88 c1                	mov    %al,%cl
c0002092:	d3 ef                	shr    %cl,%edi
c0002094:	4b                   	dec    %ebx
    package = top >> (t_bits + c_bits);
c0002095:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    unsigned tpc = tpp / cpp;
    unsigned long t_bits = bit_scan_reverse (tpc - 1) + 1;
    unsigned long c_bits = bit_scan_reverse (cpp - 1) + 1;

    thread  = top            & ((1u << t_bits) - 1);
    core    = top >>  t_bits & ((1u << c_bits) - 1);
c0002098:	21 fb                	and    %edi,%ebx
    package = top >> (t_bits + c_bits);
c000209a:	d3 ed                	shr    %cl,%ebp

    // Disable C1E on AMD Rev.F and beyond because it stops LAPIC clock
    if (vendor == AMD)
c000209c:	83 3d 6c f7 ff cf 02 	cmpl   $0x2,0xcffff76c
    unsigned tpc = tpp / cpp;
    unsigned long t_bits = bit_scan_reverse (tpc - 1) + 1;
    unsigned long c_bits = bit_scan_reverse (cpp - 1) + 1;

    thread  = top            & ((1u << t_bits) - 1);
    core    = top >>  t_bits & ((1u << c_bits) - 1);
c00020a3:	89 1d 74 f7 ff cf    	mov    %ebx,0xcffff774
    package = top >> (t_bits + c_bits);
c00020a9:	89 2d 78 f7 ff cf    	mov    %ebp,0xcffff778

    // Disable C1E on AMD Rev.F and beyond because it stops LAPIC clock
    if (vendor == AMD)
c00020af:	75 24                	jne    c00020d5 <_ZN3Cpu4initEv+0x293>
        if (family > 0xf || (family == 0xf && model >= 0x40))
c00020b1:	83 3d 64 f7 ff cf 0f 	cmpl   $0xf,0xcffff764
c00020b8:	77 0b                	ja     c00020c5 <_ZN3Cpu4initEv+0x283>
c00020ba:	75 19                	jne    c00020d5 <_ZN3Cpu4initEv+0x293>
c00020bc:	83 3d 60 f7 ff cf 3f 	cmpl   $0x3f,0xcffff760
c00020c3:	76 10                	jbe    c00020d5 <_ZN3Cpu4initEv+0x293>
c00020c5:	b9 55 00 01 c0       	mov    $0xc0010055,%ecx
c00020ca:	0f 32                	rdmsr  

        template <typename T>
        ALWAYS_INLINE
        static inline void write (Register msr, T val)
        {
            asm volatile ("wrmsr" : : "a" (static_cast<mword>(val)), "d" (static_cast<mword>(static_cast<uint64>(val) >> 32)), "c" (msr));
c00020cc:	31 d2                	xor    %edx,%edx
            Msr::write (Msr::AMD_IPMR, Msr::read<uint32>(Msr::AMD_IPMR) & ~(3ul << 27));
c00020ce:	25 ff ff ff e7       	and    $0xe7ffffff,%eax
c00020d3:	0f 30                	wrmsr  
c00020d5:	b8 01 00 00 00       	mov    $0x1,%eax
c00020da:	0f a2                	cpuid  

    // enable PAT if available
    cpuid (0x1, eax, ebx, ecx, edx);
    if (edx & (1 << 16)) {
c00020dc:	81 e2 00 00 01 00    	and    $0x10000,%edx
c00020e2:	74 12                	je     c00020f6 <_ZN3Cpu4initEv+0x2b4>
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
c00020e4:	b9 77 02 00 00       	mov    $0x277,%ecx
c00020e9:	0f 32                	rdmsr  
        uint32 cr_pat = Msr::read<uint32>(Msr::IA32_CR_PAT) & 0xffff00ff;
c00020eb:	30 e4                	xor    %ah,%ah

        template <typename T>
        ALWAYS_INLINE
        static inline void write (Register msr, T val)
        {
            asm volatile ("wrmsr" : : "a" (static_cast<mword>(val)), "d" (static_cast<mword>(static_cast<uint64>(val) >> 32)), "c" (msr));
c00020ed:	31 d2                	xor    %edx,%edx

        cr_pat |= 1 << 8;
c00020ef:	80 cc 01             	or     $0x1,%ah
c00020f2:	0f 30                	wrmsr  
c00020f4:	eb 27                	jmp    c000211d <_ZN3Cpu4initEv+0x2db>
        Msr::write<uint32>(Msr::IA32_CR_PAT, cr_pat);
    } else
        trace (0, "warning: no PAT support");
c00020f6:	8d 44 24 0b          	lea    0xb(%esp),%eax
c00020fa:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c00020ff:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c0002104:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002109:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0002110:	50                   	push   %eax
c0002111:	68 50 67 01 c0       	push   $0xc0016750
c0002116:	e8 c3 f8 ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c000211b:	58                   	pop    %eax
c000211c:	5a                   	pop    %edx
    Idt::load();

    // Initialize CPU number and check features
    check_features();

    Lapic::init();
c000211d:	e8 62 3c 00 00       	call   c0005d84 <_ZN5Lapic4initEv>

    row = Console_vga::con.spinner (id);
c0002122:	8b 15 04 f0 ff cf    	mov    0xcffff004,%edx

        INIT
        void setup();

        ALWAYS_INLINE
        inline unsigned spinner (unsigned id) { return id < 25 - num ? 24 - id : 0; }
c0002128:	b9 19 00 00 00       	mov    $0x19,%ecx
c000212d:	2b 0d a8 a3 01 c0    	sub    0xc001a3a8,%ecx
c0002133:	31 c0                	xor    %eax,%eax
c0002135:	39 ca                	cmp    %ecx,%edx
c0002137:	73 04                	jae    c000213d <_ZN3Cpu4initEv+0x2fb>
c0002139:	b0 18                	mov    $0x18,%al
c000213b:	29 d0                	sub    %edx,%eax
c000213d:	a3 50 f7 ff cf       	mov    %eax,0xcffff750

        ALWAYS_INLINE
        static inline mword current()
        {
            mword addr;
            asm volatile ("mov %%cr3, %0" : "=r" (addr));
c0002142:	0f 20 d9             	mov    %cr3,%ecx

    Paddr phys; mword attr;
    Pd::kern.Space_mem::loc[id] = Hptp (Hpt::current());
c0002145:	8d 14 95 00 b3 01 c0 	lea    -0x3ffe4d00(,%edx,4),%edx
c000214c:	89 4a 14             	mov    %ecx,0x14(%edx)
c000214f:	8d 42 14             	lea    0x14(%edx),%eax
    Pd::kern.Space_mem::loc[id].lookup (CPU_LOCAL_DATA, phys, attr);
c0002152:	8d 54 24 08          	lea    0x8(%esp),%edx
c0002156:	52                   	push   %edx
c0002157:	ba 00 f0 ff cf       	mov    $0xcffff000,%edx
c000215c:	8d 4c 24 08          	lea    0x8(%esp),%ecx
c0002160:	e8 c7 be 00 00       	call   c000e02c <_ZN3PteI3HptmLj2ELj10ELb0EE6lookupEmRmS2_>
    Pd::kern.Space_mem::insert (Pd::kern.quota, HV_GLOBAL_CPUS + id * PAGE_SIZE, 0, Hpt::HPT_NX | Hpt::HPT_G | Hpt::HPT_W | Hpt::HPT_P, phys);
c0002165:	a1 04 f0 ff cf       	mov    0xcffff004,%eax
        }

        ALWAYS_INLINE
        inline void insert (Quota &quota, mword virt, unsigned o, mword attr, Paddr phys)
        {
            hpt.update (quota, virt, o, phys, attr);
c000216a:	ba 50 b4 01 c0       	mov    $0xc001b450,%edx
c000216f:	6a 00                	push   $0x0
c0002171:	68 03 01 00 00       	push   $0x103
c0002176:	ff 74 24 10          	pushl  0x10(%esp)
c000217a:	8d 88 00 ec 0c 00    	lea    0xcec00(%eax),%ecx
c0002180:	b8 14 b4 01 c0       	mov    $0xc001b414,%eax
c0002185:	c1 e1 0c             	shl    $0xc,%ecx
c0002188:	6a 00                	push   $0x0
c000218a:	e8 31 bf 00 00       	call   c000e0c0 <_ZN3PteI3HptmLj2ELj10ELb0EE6updateER5QuotammmmNS1_4TypeE>
        static void init();

        ALWAYS_INLINE
        static inline bool feature (Feature f)
        {
            return features[f / 32] & 1U << f % 32;
c000218f:	a1 14 f7 ff cf       	mov    0xcffff714,%eax
    Hpt::ord = min (Hpt::ord, feature (FEAT_1GB_PAGES) ? 26UL : 17UL);
c0002194:	83 c4 14             	add    $0x14,%esp
c0002197:	8b 15 5c a2 01 c0    	mov    0xc001a25c,%edx
c000219d:	8b 1d 04 f7 ff cf    	mov    0xcffff704,%ebx
c00021a3:	c1 e8 1a             	shr    $0x1a,%eax
c00021a6:	83 e0 01             	and    $0x1,%eax
c00021a9:	83 f8 01             	cmp    $0x1,%eax
c00021ac:	19 c0                	sbb    %eax,%eax
c00021ae:	83 e0 f7             	and    $0xfffffff7,%eax
c00021b1:	83 c0 1a             	add    $0x1a,%eax
c00021b4:	39 d0                	cmp    %edx,%eax
c00021b6:	0f 47 c2             	cmova  %edx,%eax

    if (EXPECT_TRUE (feature (FEAT_ACPI)))
c00021b9:	f7 c3 00 00 40 00    	test   $0x400000,%ebx

    Paddr phys; mword attr;
    Pd::kern.Space_mem::loc[id] = Hptp (Hpt::current());
    Pd::kern.Space_mem::loc[id].lookup (CPU_LOCAL_DATA, phys, attr);
    Pd::kern.Space_mem::insert (Pd::kern.quota, HV_GLOBAL_CPUS + id * PAGE_SIZE, 0, Hpt::HPT_NX | Hpt::HPT_G | Hpt::HPT_W | Hpt::HPT_P, phys);
    Hpt::ord = min (Hpt::ord, feature (FEAT_1GB_PAGES) ? 26UL : 17UL);
c00021bf:	a3 5c a2 01 c0       	mov    %eax,0xc001a25c

    if (EXPECT_TRUE (feature (FEAT_ACPI)))
c00021c4:	74 0e                	je     c00021d4 <_ZN3Cpu4initEv+0x392>
c00021c6:	b9 9b 01 00 00       	mov    $0x19b,%ecx
c00021cb:	31 d2                	xor    %edx,%edx
c00021cd:	b8 10 00 00 00       	mov    $0x10,%eax
c00021d2:	0f 30                	wrmsr  
        setup_thermal();

    if (EXPECT_TRUE (feature (FEAT_SEP)))
c00021d4:	f6 c7 08             	test   $0x8,%bh
c00021d7:	74 20                	je     c00021f9 <_ZN3Cpu4initEv+0x3b7>
c00021d9:	31 d2                	xor    %edx,%edx
c00021db:	b9 74 01 00 00       	mov    $0x174,%ecx
c00021e0:	b8 08 00 00 00       	mov    $0x8,%eax
c00021e5:	0f 30                	wrmsr  
c00021e7:	b8 c4 fa ff cf       	mov    $0xcffffac4,%eax
c00021ec:	b1 75                	mov    $0x75,%cl
c00021ee:	0f 30                	wrmsr  
c00021f0:	b8 74 55 00 c0       	mov    $0xc0005574,%eax
c00021f5:	b1 76                	mov    $0x76,%cl
c00021f7:	0f 30                	wrmsr  
        }

        ALWAYS_INLINE
        static inline void defeature (Feature f)
        {
            features[f / 32] &= ~(1U << f % 32);
c00021f9:	81 25 08 f7 ff cf ff 	andl   $0xfffdffff,0xcffff708
c0002200:	ff fd ff 
        setup_sysenter();

    setup_pcid();

    if (EXPECT_TRUE (feature (FEAT_SMEP)))
c0002203:	f6 05 10 f7 ff cf 80 	testb  $0x80,0xcffff710
c000220a:	74 0b                	je     c0002217 <_ZN3Cpu4initEv+0x3d5>

ALWAYS_INLINE
static inline mword get_cr4()
{
    mword cr4;
    asm volatile ("mov %%cr4, %0" : "=r" (cr4));
c000220c:	0f 20 e0             	mov    %cr4,%eax
        set_cr4 (get_cr4() | Cpu::CR4_SMEP);
c000220f:	0d 00 00 10 00       	or     $0x100000,%eax
}

ALWAYS_INLINE
static inline void set_cr4 (mword cr4)
{
    asm volatile ("mov %0, %%cr4" : : "r" (cr4));
c0002214:	0f 22 e0             	mov    %eax,%cr4

    Vmcs::init();
c0002217:	e8 8e 36 01 00       	call   c00158aa <_ZN4Vmcs4initEv>
    Vmcb::init();
c000221c:	e8 3f f2 00 00       	call   c0011460 <_ZN4Vmcb4initEv>

    Mca::init();
c0002221:	e8 1e 3e 00 00       	call   c0006044 <_ZN3Mca4initEv>

    trace (TRACE_CPU, "CORE:%x:%x:%x %x:%x:%x:%x [%x] %.48s", package, core, thread, family, model, stepping, platform, patch, reinterpret_cast<char *>(name));
c0002226:	8d 44 24 0b          	lea    0xb(%esp),%eax
c000222a:	68 20 f7 ff cf       	push   $0xcffff720
c000222f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0002234:	ff 35 54 f7 ff cf    	pushl  0xcffff754
c000223a:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c000223f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002244:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c000224b:	ff 35 68 f7 ff cf    	pushl  0xcffff768
c0002251:	ff 35 5c f7 ff cf    	pushl  0xcffff75c
c0002257:	ff 35 60 f7 ff cf    	pushl  0xcffff760
c000225d:	ff 35 64 f7 ff cf    	pushl  0xcffff764
c0002263:	ff 35 70 f7 ff cf    	pushl  0xcffff770
c0002269:	ff 35 74 f7 ff cf    	pushl  0xcffff774
c000226f:	ff 35 78 f7 ff cf    	pushl  0xcffff778
c0002275:	50                   	push   %eax
c0002276:	68 6f 67 01 c0       	push   $0xc001676f
c000227b:	e8 5e f7 ff ff       	call   c00019de <_ZN7Console5printEPKcz>

    Hip::add_cpu();
c0002280:	83 c4 2c             	add    $0x2c,%esp
c0002283:	e8 aa 37 00 00       	call   c0005a32 <_ZN3Hip7add_cpuEv>

    boot_lock++;
c0002288:	ff 05 44 a4 01 c0    	incl   0xc001a444
}
c000228e:	83 c4 14             	add    $0x14,%esp
c0002291:	5b                   	pop    %ebx
c0002292:	5e                   	pop    %esi
c0002293:	5f                   	pop    %edi
c0002294:	5d                   	pop    %ebp
c0002295:	c3                   	ret    

c0002296 <_ZN3MdbC1EP5SpacePFvP8Rcu_elemEmmmmmm>:

        NOINLINE
        explicit Mdb (Space *s, mword p, mword b, mword a, void (*f)(Rcu_elem *), void (*pf)(Rcu_elem *) = nullptr) : Rcu_elem (f, pf), dpth (0), prev (this), next (this), prnt (nullptr), space (s), node_phys (p), node_base (b), node_order (0), node_attr (a), node_type (0), node_sub (0) {}

        NOINLINE
        explicit Mdb (Space *s, void (*f)(Rcu_elem *), mword p, mword b, mword o = 0, mword a = 0, mword t = 0, mword sub = 0) : Rcu_elem (f), dpth (0), prev (this), next (this), prnt (nullptr), space (s), node_phys (p), node_base (b), node_order (o), node_attr (a), node_type (t), node_sub (sub) {}
c0002296:	89 50 28             	mov    %edx,0x28(%eax)
c0002299:	8b 54 24 04          	mov    0x4(%esp),%edx
        enum State { REMOVED = 1, KIM = 2, STALE = 3 };

    protected:
        Avl *lnk[2];

        explicit Avl() : bal (2), sta(0) { lnk[0] = lnk[1] = nullptr; }
c000229d:	66 c7 40 08 02 00    	movw   $0x2,0x8(%eax)
c00022a3:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
c00022a9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
c00022b0:	89 50 2c             	mov    %edx,0x2c(%eax)
c00022b3:	8b 54 24 08          	mov    0x8(%esp),%edx
c00022b7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        Rcu_elem *next;
        void (*func)(Rcu_elem *);
        void (*pre_func)(Rcu_elem *);

        ALWAYS_INLINE
        explicit Rcu_elem (void (*f)(Rcu_elem *), void (*pf) (Rcu_elem *) = nullptr) : next (nullptr), func (f), pre_func(pf) {}
c00022bd:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
c00022c4:	89 48 10             	mov    %ecx,0x10(%eax)
c00022c7:	89 50 30             	mov    %edx,0x30(%eax)
c00022ca:	8b 54 24 0c          	mov    0xc(%esp),%edx
c00022ce:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
c00022d5:	66 c7 40 18 00 00    	movw   $0x0,0x18(%eax)
c00022db:	66 c7 40 1a 00 00    	movw   $0x0,0x1a(%eax)
c00022e1:	89 50 34             	mov    %edx,0x34(%eax)
c00022e4:	8b 54 24 10          	mov    0x10(%esp),%edx
c00022e8:	89 40 1c             	mov    %eax,0x1c(%eax)
c00022eb:	89 40 20             	mov    %eax,0x20(%eax)
c00022ee:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
c00022f5:	89 50 38             	mov    %edx,0x38(%eax)
c00022f8:	8b 54 24 14          	mov    0x14(%esp),%edx
c00022fc:	89 50 3c             	mov    %edx,0x3c(%eax)
c00022ff:	8b 54 24 18          	mov    0x18(%esp),%edx
c0002303:	89 50 40             	mov    %edx,0x40(%eax)
c0002306:	c3                   	ret    
c0002307:	90                   	nop

c0002308 <_ZN5Space6addregER5Quotamjmm>:
        {
            Lock_guard <Spinlock> guard (node->space->lock);
            return Mdb::remove<Mdb> (&node->space->tree, node, state);
        }

        void addreg (Quota &quota, mword addr, size_t size, mword attr, mword type = 0)
c0002308:	55                   	push   %ebp
c0002309:	57                   	push   %edi
c000230a:	56                   	push   %esi
c000230b:	89 c6                	mov    %eax,%esi
c000230d:	53                   	push   %ebx
c000230e:	89 cb                	mov    %ecx,%ebx
c0002310:	83 ec 0c             	sub    $0xc,%esp
c0002313:	89 54 24 08          	mov    %edx,0x8(%esp)

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c0002317:	9c                   	pushf  
c0002318:	58                   	pop    %eax
            return flags & 0x200;
c0002319:	c1 e8 09             	shr    $0x9,%eax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c000231c:	24 01                	and    $0x1,%al
c000231e:	88 44 24 07          	mov    %al,0x7(%esp)
c0002322:	74 2a                	je     c000234e <_ZN5Space6addregER5Quotamjmm+0x46>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0002324:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000232b:	75 19                	jne    c0002346 <_ZN5Space6addregER5Quotamjmm+0x3e>
c000232d:	68 60 68 01 c0       	push   $0xc0016860
c0002332:	68 b7 00 00 00       	push   $0xb7
c0002337:	68 12 61 01 c0       	push   $0xc0016112
c000233c:	68 83 61 01 c0       	push   $0xc0016183
c0002341:	e9 a0 00 00 00       	jmp    c00023e6 <_ZN5Space6addregER5Quotamjmm+0xde>

            asm volatile ("cli" : : : "memory");
c0002346:	fa                   	cli    
            preemption = false;
c0002347:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c000234e:	89 f0                	mov    %esi,%eax
c0002350:	e8 d7 e7 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
        {
            Lock_guard <Spinlock> guard (lock);

            for (mword o; size; size -= 1UL << o, addr += 1UL << o)
                Mdb::insert<Mdb> (&tree, new (quota) Mdb (nullptr, nullptr, addr, addr, (o = max_order (addr, size)), attr, type));
c0002355:	8d 6e 04             	lea    0x4(%esi),%ebp

        void addreg (Quota &quota, mword addr, size_t size, mword attr, mword type = 0)
        {
            Lock_guard <Spinlock> guard (lock);

            for (mword o; size; size -= 1UL << o, addr += 1UL << o)
c0002358:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c000235d:	74 61                	je     c00023c0 <_ZN5Space6addregER5Quotamjmm+0xb8>
c000235f:	0f bd 44 24 20       	bsr    0x20(%esp),%eax
ALWAYS_INLINE
inline unsigned long max_order (mword base, size_t size)
{
    long int o = bit_scan_reverse (size);

    if (base)
c0002364:	85 db                	test   %ebx,%ebx
    if (EXPECT_FALSE (!val))
        return -1;

    asm volatile ("bsr %1, %0" : "=r" (val) : "rm" (val));

    return val;
c0002366:	89 04 24             	mov    %eax,(%esp)
ALWAYS_INLINE
inline unsigned long max_order (mword base, size_t size)
{
    long int o = bit_scan_reverse (size);

    if (base)
c0002369:	74 0d                	je     c0002378 <_ZN5Space6addregER5Quotamjmm+0x70>
inline long int bit_scan_forward (mword val)
{
    if (EXPECT_FALSE (!val))
        return -1;

    asm volatile ("bsf %1, %0" : "=r" (val) : "rm" (val));
c000236b:	0f bc c3             	bsf    %ebx,%eax
c000236e:	39 04 24             	cmp    %eax,(%esp)
c0002371:	0f 4e 04 24          	cmovle (%esp),%eax
c0002375:	89 04 24             	mov    %eax,(%esp)
        bool insert_node (Mdb *, mword);
        void demote_node (mword);
        bool remove_node();

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
c0002378:	8b 54 24 08          	mov    0x8(%esp),%edx
c000237c:	b8 80 b0 01 c0       	mov    $0xc001b080,%eax
c0002381:	e8 f0 de 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
                Mdb::insert<Mdb> (&tree, new (quota) Mdb (nullptr, nullptr, addr, addr, (o = max_order (addr, size)), attr, type));
c0002386:	31 c9                	xor    %ecx,%ecx
c0002388:	31 d2                	xor    %edx,%edx
c000238a:	6a 00                	push   $0x0
c000238c:	ff 74 24 2c          	pushl  0x2c(%esp)
c0002390:	ff 74 24 2c          	pushl  0x2c(%esp)
c0002394:	89 c7                	mov    %eax,%edi
c0002396:	ff 74 24 0c          	pushl  0xc(%esp)
c000239a:	53                   	push   %ebx
c000239b:	53                   	push   %ebx
c000239c:	e8 f5 fe ff ff       	call   c0002296 <_ZN3MdbC1EP5SpacePFvP8Rcu_elemEmmmmmm>
c00023a1:	89 fa                	mov    %edi,%edx
c00023a3:	89 e8                	mov    %ebp,%eax
c00023a5:	e8 70 e8 ff ff       	call   c0000c1a <_ZN3Avl6insertI3MdbEEbPPS_S2_>

        void addreg (Quota &quota, mword addr, size_t size, mword attr, mword type = 0)
        {
            Lock_guard <Spinlock> guard (lock);

            for (mword o; size; size -= 1UL << o, addr += 1UL << o)
c00023aa:	8a 4c 24 18          	mov    0x18(%esp),%cl
c00023ae:	b8 01 00 00 00       	mov    $0x1,%eax
c00023b3:	d3 e0                	shl    %cl,%eax
c00023b5:	29 44 24 38          	sub    %eax,0x38(%esp)
c00023b9:	01 c3                	add    %eax,%ebx
c00023bb:	83 c4 18             	add    $0x18,%esp
c00023be:	eb 98                	jmp    c0002358 <_ZN5Space6addregER5Quotamjmm+0x50>
        }

        ALWAYS_INLINE
        inline void unlock()
        {
            asm volatile ("incb %0" : "=m" (val) : : "memory");
c00023c0:	fe 06                	incb   (%esi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c00023c2:	80 7c 24 07 00       	cmpb   $0x0,0x7(%esp)
c00023c7:	74 2f                	je     c00023f8 <_ZN5Space6addregER5Quotamjmm+0xf0>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c00023c9:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c00023d0:	74 1e                	je     c00023f0 <_ZN5Space6addregER5Quotamjmm+0xe8>
c00023d2:	68 20 68 01 c0       	push   $0xc0016820
c00023d7:	68 c0 00 00 00       	push   $0xc0
c00023dc:	68 12 61 01 c0       	push   $0xc0016112
c00023e1:	68 82 61 01 c0       	push   $0xc0016182
c00023e6:	68 69 60 01 c0       	push   $0xc0016069
c00023eb:	e8 56 f5 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

            preemption = true;
c00023f0:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c00023f7:	fb                   	sti    
                Mdb::insert<Mdb> (&tree, new (quota) Mdb (nullptr, nullptr, addr, addr, (o = max_order (addr, size)), attr, type));
        }
c00023f8:	83 c4 0c             	add    $0xc,%esp
c00023fb:	5b                   	pop    %ebx
c00023fc:	5e                   	pop    %esi
c00023fd:	5f                   	pop    %edi
c00023fe:	5d                   	pop    %ebp
c00023ff:	c3                   	ret    

c0002400 <_ZN5Space6delregER5Quotam>:

        void delreg (Quota &quota, mword addr)
c0002400:	55                   	push   %ebp
c0002401:	89 c5                	mov    %eax,%ebp
c0002403:	57                   	push   %edi
c0002404:	89 cf                	mov    %ecx,%edi
c0002406:	56                   	push   %esi
c0002407:	53                   	push   %ebx
c0002408:	83 ec 08             	sub    $0x8,%esp
c000240b:	89 14 24             	mov    %edx,(%esp)

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c000240e:	9c                   	pushf  
c000240f:	5b                   	pop    %ebx
            return flags & 0x200;
c0002410:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c0002413:	80 e3 01             	and    $0x1,%bl
c0002416:	74 27                	je     c000243f <_ZN5Space6delregER5Quotam+0x3f>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0002418:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000241f:	75 16                	jne    c0002437 <_ZN5Space6delregER5Quotam+0x37>
c0002421:	68 60 68 01 c0       	push   $0xc0016860
c0002426:	68 b7 00 00 00       	push   $0xb7
c000242b:	68 12 61 01 c0       	push   $0xc0016112
c0002430:	68 83 61 01 c0       	push   $0xc0016183
c0002435:	eb 6e                	jmp    c00024a5 <_ZN5Space6delregER5Quotam+0xa5>

            asm volatile ("cli" : : : "memory");
c0002437:	fa                   	cli    
            preemption = false;
c0002438:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c000243f:	89 e8                	mov    %ebp,%eax
c0002441:	e8 e6 e6 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
        {
            Mdb *node;

            {   Lock_guard <Spinlock> guard (lock);

                if (!(node = Mdb::lookup (tree, addr >>= PAGE_BITS, false)))
c0002446:	8b 75 04             	mov    0x4(%ebp),%esi
c0002449:	c1 ef 0c             	shr    $0xc,%edi
        static Mdb *lookup (Avl *tree, mword base, bool next)
        {
            Mdb *n = nullptr;
            bool d;

            for (Mdb *m = static_cast<Mdb *>(tree); m; m = static_cast<Mdb *>(m->lnk[d])) {
c000244c:	85 f6                	test   %esi,%esi
c000244e:	0f 84 c1 00 00 00    	je     c0002515 <_ZN5Space6delregER5Quotam+0x115>

                if ((m->node_base ^ base) >> m->node_order == 0)
c0002454:	8b 56 30             	mov    0x30(%esi),%edx
c0002457:	89 f8                	mov    %edi,%eax
c0002459:	8b 4e 34             	mov    0x34(%esi),%ecx
c000245c:	31 d0                	xor    %edx,%eax
c000245e:	d3 e8                	shr    %cl,%eax
c0002460:	85 c0                	test   %eax,%eax
c0002462:	75 18                	jne    c000247c <_ZN5Space6delregER5Quotam+0x7c>
                    return;

                Mdb::remove<Mdb> (&tree, node);
c0002464:	8d 45 04             	lea    0x4(%ebp),%eax
c0002467:	b9 01 00 00 00       	mov    $0x1,%ecx
c000246c:	89 f2                	mov    %esi,%edx
c000246e:	e8 9f e8 ff ff       	call   c0000d12 <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE>
c0002473:	fe 45 00             	incb   0x0(%ebp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c0002476:	84 db                	test   %bl,%bl
c0002478:	75 0e                	jne    c0002488 <_ZN5Space6delregER5Quotam+0x88>
c000247a:	eb 3b                	jmp    c00024b7 <_ZN5Space6delregER5Quotam+0xb7>
        static Mdb *lookup (Avl *tree, mword base, bool next)
        {
            Mdb *n = nullptr;
            bool d;

            for (Mdb *m = static_cast<Mdb *>(tree); m; m = static_cast<Mdb *>(m->lnk[d])) {
c000247c:	31 c0                	xor    %eax,%eax
c000247e:	39 d7                	cmp    %edx,%edi
c0002480:	0f 97 c0             	seta   %al
c0002483:	8b 34 86             	mov    (%esi,%eax,4),%esi
c0002486:	eb c4                	jmp    c000244c <_ZN5Space6delregER5Quotam+0x4c>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0002488:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000248f:	74 1e                	je     c00024af <_ZN5Space6delregER5Quotam+0xaf>
c0002491:	68 20 68 01 c0       	push   $0xc0016820
c0002496:	68 c0 00 00 00       	push   $0xc0
c000249b:	68 12 61 01 c0       	push   $0xc0016112
c00024a0:	68 82 61 01 c0       	push   $0xc0016182
c00024a5:	68 69 60 01 c0       	push   $0xc0016069
c00024aa:	e8 97 f4 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

            preemption = true;
c00024af:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c00024b6:	fb                   	sti    
            }

            mword next = addr + 1, base = node->node_base, last = base + (1UL << node->node_order);
c00024b7:	8b 4e 34             	mov    0x34(%esi),%ecx
c00024ba:	ba 01 00 00 00       	mov    $0x1,%edx
c00024bf:	8b 46 30             	mov    0x30(%esi),%eax
c00024c2:	8d 5f 01             	lea    0x1(%edi),%ebx
c00024c5:	d3 e2                	shl    %cl,%edx
c00024c7:	8d 0c 02             	lea    (%edx,%eax,1),%ecx

            addreg (quota, base, addr - base, node->node_attr, node->node_type);
c00024ca:	29 c7                	sub    %eax,%edi
                    return;

                Mdb::remove<Mdb> (&tree, node);
            }

            mword next = addr + 1, base = node->node_base, last = base + (1UL << node->node_order);
c00024cc:	89 4c 24 04          	mov    %ecx,0x4(%esp)

            addreg (quota, base, addr - base, node->node_attr, node->node_type);
c00024d0:	89 c1                	mov    %eax,%ecx
c00024d2:	89 e8                	mov    %ebp,%eax
c00024d4:	ff 76 3c             	pushl  0x3c(%esi)
c00024d7:	ff 76 38             	pushl  0x38(%esi)
c00024da:	57                   	push   %edi
c00024db:	8b 54 24 0c          	mov    0xc(%esp),%edx
c00024df:	e8 24 fe ff ff       	call   c0002308 <_ZN5Space6addregER5Quotamjmm>
            addreg (quota, next, last - next, node->node_attr, node->node_type);
c00024e4:	89 d9                	mov    %ebx,%ecx
c00024e6:	ff 76 3c             	pushl  0x3c(%esi)
c00024e9:	ff 76 38             	pushl  0x38(%esi)
c00024ec:	8b 44 24 18          	mov    0x18(%esp),%eax
c00024f0:	29 d8                	sub    %ebx,%eax
c00024f2:	50                   	push   %eax
c00024f3:	89 e8                	mov    %ebp,%eax
c00024f5:	8b 54 24 18          	mov    0x18(%esp),%edx
c00024f9:	e8 0a fe ff ff       	call   c0002308 <_ZN5Space6addregER5Quotamjmm>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void destroy (Mdb *obj, Quota &quota) { obj->~Mdb(); cache.free (obj, quota); }
c00024fe:	8b 4c 24 18          	mov    0x18(%esp),%ecx

            Mdb::destroy (node, quota);
        }
c0002502:	83 c4 20             	add    $0x20,%esp
c0002505:	5b                   	pop    %ebx
c0002506:	89 f2                	mov    %esi,%edx
c0002508:	b8 80 b0 01 c0       	mov    $0xc001b080,%eax
c000250d:	5e                   	pop    %esi
c000250e:	5f                   	pop    %edi
c000250f:	5d                   	pop    %ebp
c0002510:	e9 4b de 00 00       	jmp    c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
c0002515:	fe 45 00             	incb   0x0(%ebp)
c0002518:	84 db                	test   %bl,%bl
c000251a:	74 15                	je     c0002531 <_ZN5Space6delregER5Quotam+0x131>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000251c:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0002523:	0f 85 68 ff ff ff    	jne    c0002491 <_ZN5Space6delregER5Quotam+0x91>

            preemption = true;
c0002529:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c0002530:	fb                   	sti    
c0002531:	83 c4 08             	add    $0x8,%esp
c0002534:	5b                   	pop    %ebx
c0002535:	5e                   	pop    %esi
c0002536:	5f                   	pop    %edi
c0002537:	5d                   	pop    %ebp
c0002538:	c3                   	ret    
c0002539:	90                   	nop

c000253a <_ZN4Dmar6assignEmP2Pd>:

void Dmar::assign (unsigned long rid, Pd *p)
{
c000253a:	55                   	push   %ebp

ALWAYS_INLINE
inline long int bit_scan_reverse (mword val)
{
    if (EXPECT_FALSE (!val))
        return -1;
c000253b:	83 cd ff             	or     $0xffffffff,%ebp
c000253e:	57                   	push   %edi
c000253f:	89 cf                	mov    %ecx,%edi
c0002541:	56                   	push   %esi
c0002542:	53                   	push   %ebx
c0002543:	89 c3                	mov    %eax,%ebx
c0002545:	83 ec 08             	sub    $0x8,%esp

        template <typename T>
        ALWAYS_INLINE
        inline T read (Reg reg)
        {
            return *reinterpret_cast<T volatile *>(reg_base + reg);
c0002548:	8b 40 04             	mov    0x4(%eax),%eax
c000254b:	89 14 24             	mov    %edx,(%esp)
c000254e:	8b 40 08             	mov    0x8(%eax),%eax
    mword lev = bit_scan_reverse (read<mword>(REG_CAP) >> 8 & 0x1f);
c0002551:	c1 e8 08             	shr    $0x8,%eax
#include "util.hpp"

ALWAYS_INLINE
inline long int bit_scan_reverse (mword val)
{
    if (EXPECT_FALSE (!val))
c0002554:	83 e0 1f             	and    $0x1f,%eax
c0002557:	74 03                	je     c000255c <_ZN4Dmar6assignEmP2Pd+0x22>
        return -1;

    asm volatile ("bsr %1, %0" : "=r" (val) : "rm" (val));

    return val;
c0002559:	0f bd e8             	bsr    %eax,%ebp

    Dmar_ctx *r = ctx + (rid >> 8);
c000255c:	8b 34 24             	mov    (%esp),%esi
c000255f:	c1 ee 08             	shr    $0x8,%esi
c0002562:	c1 e6 04             	shl    $0x4,%esi
c0002565:	03 35 4c a4 01 c0    	add    0xc001a44c,%esi
    if (!r->present())
c000256b:	f6 06 01             	testb  $0x1,(%esi)
c000256e:	75 4b                	jne    c00025bb <_ZN4Dmar6assignEmP2Pd+0x81>
        r->set (0, Buddy::ptr_to_phys (new (p->quota) Dmar_ctx) | 1);
c0002570:	8d 8f 90 01 00 00    	lea    0x190(%edi),%ecx

        ALWAYS_INLINE
        inline void set (uint64 h, uint64 l) { hi = h; lo = l; flush (this); }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return flush (Buddy::allocator.alloc (0, quota, Buddy::FILL_0), PAGE_SIZE); }
c0002576:	31 d2                	xor    %edx,%edx
c0002578:	6a 01                	push   $0x1
c000257a:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c000257f:	e8 88 ee ff ff       	call   c000140c <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
c0002584:	5a                   	pop    %edx
c0002585:	8d 88 00 10 00 00    	lea    0x1000(%eax),%ecx
}

ALWAYS_INLINE NONNULL
inline void *flush (void *d, size_t n)
{
    for (char *p = static_cast<char *>(d); p < static_cast<char *>(d) + n; p += 32)
c000258b:	89 c2                	mov    %eax,%edx
c000258d:	39 ca                	cmp    %ecx,%edx
c000258f:	74 08                	je     c0002599 <_ZN4Dmar6assignEmP2Pd+0x5f>

template <typename T>
ALWAYS_INLINE
static inline void flush (T t)
{
    asm volatile ("clflush %0" : : "m" (*t) : "memory");
c0002591:	0f ae 3a             	clflush (%edx)
}

ALWAYS_INLINE NONNULL
inline void *flush (void *d, size_t n)
{
    for (char *p = static_cast<char *>(d); p < static_cast<char *>(d) + n; p += 32)
c0002594:	83 c2 20             	add    $0x20,%edx
c0002597:	eb f4                	jmp    c000258d <_ZN4Dmar6assignEmP2Pd+0x53>
c0002599:	2d 00 00 c0 bf       	sub    $0xbfc00000,%eax
c000259e:	83 c8 01             	or     $0x1,%eax

        ALWAYS_INLINE
        inline Paddr addr() const { return static_cast<Paddr>(lo) & ~PAGE_MASK; }

        ALWAYS_INLINE
        inline void set (uint64 h, uint64 l) { hi = h; lo = l; flush (this); }
c00025a1:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
c00025a8:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
c00025af:	89 06                	mov    %eax,(%esi)
c00025b1:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)

template <typename T>
ALWAYS_INLINE
static inline void flush (T t)
{
    asm volatile ("clflush %0" : : "m" (*t) : "memory");
c00025b8:	0f ae 3e             	clflush (%esi)
    public:
        ALWAYS_INLINE
        inline bool present() const { return lo & 1; }

        ALWAYS_INLINE
        inline Paddr addr() const { return static_cast<Paddr>(lo) & ~PAGE_MASK; }
c00025bb:	8b 16                	mov    (%esi),%edx

    Dmar_ctx *c = static_cast<Dmar_ctx *>(Buddy::phys_to_ptr (r->addr())) + (rid & 0xff);
c00025bd:	0f b6 04 24          	movzbl (%esp),%eax
c00025c1:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c00025c7:	c1 e0 04             	shl    $0x4,%eax
c00025ca:	8d b4 02 00 00 c0 bf 	lea    -0x40400000(%edx,%eax,1),%esi
    if (c->present())
c00025d1:	f6 06 01             	testb  $0x1,(%esi)
c00025d4:	74 1e                	je     c00025f4 <_ZN4Dmar6assignEmP2Pd+0xba>

        ALWAYS_INLINE
        inline void set (uint64 h, uint64 l) { hi = h; lo = l; flush (this); }
c00025d6:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
c00025dd:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
c00025e4:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
c00025ea:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
c00025f1:	0f ae 3e             	clflush (%esi)
        }

        ALWAYS_INLINE
        inline void flush_ctx()
        {
            if (qi()) {
c00025f4:	f6 43 10 02          	testb  $0x2,0x10(%ebx)
c00025f8:	0f 84 0f 01 00 00    	je     c000270d <_ZN4Dmar6assignEmP2Pd+0x1d3>
        }

        ALWAYS_INLINE
        inline void qi_submit (Dmar_qi const &q)
        {
            invq[invq_idx] = q;
c00025fe:	8b 43 1c             	mov    0x1c(%ebx),%eax
c0002601:	c1 e0 04             	shl    $0x4,%eax
c0002604:	03 43 18             	add    0x18(%ebx),%eax
c0002607:	c7 00 11 00 00 00    	movl   $0x11,(%eax)
c000260d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
c0002614:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
c000261b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
            invq_idx = (invq_idx + 1) % cnt;
c0002622:	8b 43 1c             	mov    0x1c(%ebx),%eax

        template <typename T>
        ALWAYS_INLINE
        inline void write (Reg reg, T val)
        {
            *reinterpret_cast<T volatile *>(reg_base + reg) = val;
c0002625:	8b 4b 04             	mov    0x4(%ebx),%ecx

        ALWAYS_INLINE
        inline void qi_submit (Dmar_qi const &q)
        {
            invq[invq_idx] = q;
            invq_idx = (invq_idx + 1) % cnt;
c0002628:	8d 50 01             	lea    0x1(%eax),%edx
c000262b:	0f b6 d2             	movzbl %dl,%edx
            write<uint64>(REG_IQT, invq_idx << 4);
c000262e:	89 d0                	mov    %edx,%eax

        ALWAYS_INLINE
        inline void qi_submit (Dmar_qi const &q)
        {
            invq[invq_idx] = q;
            invq_idx = (invq_idx + 1) % cnt;
c0002630:	89 53 1c             	mov    %edx,0x1c(%ebx)
            write<uint64>(REG_IQT, invq_idx << 4);
c0002633:	c1 e0 04             	shl    $0x4,%eax
c0002636:	31 d2                	xor    %edx,%edx

        template <typename T>
        ALWAYS_INLINE
        inline void write (Reg reg, T val)
        {
            *reinterpret_cast<T volatile *>(reg_base + reg) = val;
c0002638:	89 81 88 00 00 00    	mov    %eax,0x88(%ecx)
c000263e:	89 91 8c 00 00 00    	mov    %edx,0x8c(%ecx)
        }

        ALWAYS_INLINE
        inline void qi_submit (Dmar_qi const &q)
        {
            invq[invq_idx] = q;
c0002644:	8b 43 1c             	mov    0x1c(%ebx),%eax
c0002647:	c1 e0 04             	shl    $0x4,%eax
c000264a:	03 43 18             	add    0x18(%ebx),%eax
c000264d:	c7 00 12 00 00 00    	movl   $0x12,(%eax)
c0002653:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
c000265a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
c0002661:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
            invq_idx = (invq_idx + 1) % cnt;
c0002668:	8b 43 1c             	mov    0x1c(%ebx),%eax

        template <typename T>
        ALWAYS_INLINE
        inline void write (Reg reg, T val)
        {
            *reinterpret_cast<T volatile *>(reg_base + reg) = val;
c000266b:	8b 4b 04             	mov    0x4(%ebx),%ecx

        ALWAYS_INLINE
        inline void qi_submit (Dmar_qi const &q)
        {
            invq[invq_idx] = q;
            invq_idx = (invq_idx + 1) % cnt;
c000266e:	8d 50 01             	lea    0x1(%eax),%edx
c0002671:	0f b6 d2             	movzbl %dl,%edx
            write<uint64>(REG_IQT, invq_idx << 4);
c0002674:	89 d0                	mov    %edx,%eax

        ALWAYS_INLINE
        inline void qi_submit (Dmar_qi const &q)
        {
            invq[invq_idx] = q;
            invq_idx = (invq_idx + 1) % cnt;
c0002676:	89 53 1c             	mov    %edx,0x1c(%ebx)
            write<uint64>(REG_IQT, invq_idx << 4);
c0002679:	c1 e0 04             	shl    $0x4,%eax
c000267c:	31 d2                	xor    %edx,%edx

        template <typename T>
        ALWAYS_INLINE
        inline void write (Reg reg, T val)
        {
            *reinterpret_cast<T volatile *>(reg_base + reg) = val;
c000267e:	89 81 88 00 00 00    	mov    %eax,0x88(%ecx)
c0002684:	89 91 8c 00 00 00    	mov    %edx,0x8c(%ecx)

        template <typename T>
        ALWAYS_INLINE
        inline T read (Reg reg)
        {
            return *reinterpret_cast<T volatile *>(reg_base + reg);
c000268a:	8b 43 04             	mov    0x4(%ebx),%eax
c000268d:	8b 90 8c 00 00 00    	mov    0x8c(%eax),%edx
c0002693:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
c0002699:	89 54 24 04          	mov    %edx,0x4(%esp)
c000269d:	89 04 24             	mov    %eax,(%esp)
c00026a0:	8b 4b 04             	mov    0x4(%ebx),%ecx
c00026a3:	8b 81 80 00 00 00    	mov    0x80(%ecx),%eax
c00026a9:	8b 91 84 00 00 00    	mov    0x84(%ecx),%edx
        };

        ALWAYS_INLINE
        inline void qi_wait()
        {
            for (uint64 v = read<uint64>(REG_IQT); v != read<uint64>(REG_IQH); pause()) ;
c00026af:	39 54 24 04          	cmp    %edx,0x4(%esp)
c00026b3:	74 04                	je     c00026b9 <_ZN4Dmar6assignEmP2Pd+0x17f>
}

ALWAYS_INLINE
static inline void pause()
{
    asm volatile ("pause" : : : "memory");
c00026b5:	f3 90                	pause  
c00026b7:	eb e7                	jmp    c00026a0 <_ZN4Dmar6assignEmP2Pd+0x166>
c00026b9:	39 04 24             	cmp    %eax,(%esp)
c00026bc:	75 f7                	jne    c00026b5 <_ZN4Dmar6assignEmP2Pd+0x17b>

        ALWAYS_INLINE
        static inline unsigned max() { return L; }

        ALWAYS_INLINE
        inline E root (Quota &quota, mword l = L - 1) { return Buddy::ptr_to_phys (walk (quota, 0, l)); }
c00026be:	6a 01                	push   $0x1
        c->set (0, 0);

    flush_ctx();

    c->set (lev | p->did << 8, p->dpt.root (p->quota, lev + 1) | 1);
c00026c0:	8d 4d 01             	lea    0x1(%ebp),%ecx
c00026c3:	51                   	push   %ecx
c00026c4:	6a 00                	push   $0x0
c00026c6:	8d 97 90 01 00 00    	lea    0x190(%edi),%edx
c00026cc:	6a 00                	push   $0x0
c00026ce:	8d 87 58 01 00 00    	lea    0x158(%edi),%eax
c00026d4:	e8 d5 b1 00 00       	call   c000d8ae <_ZN3PteI3DptyLj4ELj9ELb1EE4walkER5Quotaymb>
c00026d9:	8b 97 68 01 00 00    	mov    0x168(%edi),%edx
c00026df:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
c00026e6:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
c00026ed:	c1 e2 08             	shl    $0x8,%edx
c00026f0:	09 d5                	or     %edx,%ebp
c00026f2:	2d 00 00 c0 bf       	sub    $0xbfc00000,%eax
c00026f7:	83 c8 01             	or     $0x1,%eax
c00026fa:	89 6e 08             	mov    %ebp,0x8(%esi)
c00026fd:	89 06                	mov    %eax,(%esi)

template <typename T>
ALWAYS_INLINE
static inline void flush (T t)
{
    asm volatile ("clflush %0" : : "m" (*t) : "memory");
c00026ff:	0f ae 3e             	clflush (%esi)
}
c0002702:	83 c4 10             	add    $0x10,%esp
c0002705:	83 c4 08             	add    $0x8,%esp
c0002708:	5b                   	pop    %ebx
c0002709:	5e                   	pop    %esi
c000270a:	5f                   	pop    %edi
c000270b:	5d                   	pop    %ebp
c000270c:	c3                   	ret    

        template <typename T>
        ALWAYS_INLINE
        inline void write (Reg reg, T val)
        {
            *reinterpret_cast<T volatile *>(reg_base + reg) = val;
c000270d:	8b 43 04             	mov    0x4(%ebx),%eax
c0002710:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
c0002717:	c7 40 2c 00 00 00 a0 	movl   $0xa0000000,0x2c(%eax)
c000271e:	8b 4b 04             	mov    0x4(%ebx),%ecx

        template <typename T>
        ALWAYS_INLINE
        inline T read (Reg reg)
        {
            return *reinterpret_cast<T volatile *>(reg_base + reg);
c0002721:	8b 41 28             	mov    0x28(%ecx),%eax
c0002724:	8b 51 2c             	mov    0x2c(%ecx),%edx
                qi_submit (Dmar_qi_ctx());
                qi_submit (Dmar_qi_tlb());
                qi_wait();
            } else {
                write<uint64>(REG_CCMD, 1ULL << 63 | 1ULL << 61);
                while (read<uint64>(REG_CCMD) & (1ULL << 63))
c0002727:	85 d2                	test   %edx,%edx
c0002729:	79 04                	jns    c000272f <_ZN4Dmar6assignEmP2Pd+0x1f5>
}

ALWAYS_INLINE
static inline void pause()
{
    asm volatile ("pause" : : : "memory");
c000272b:	f3 90                	pause  
c000272d:	eb ef                	jmp    c000271e <_ZN4Dmar6assignEmP2Pd+0x1e4>

        ALWAYS_INLINE
        inline mword fro() const { return static_cast<mword>(cap >> 20 & 0x3ff0) + reg_base; }

        ALWAYS_INLINE
        inline mword iro() const { return static_cast<mword>(ecap >> 4 & 0x3ff0) + reg_base; }
c000272f:	8b 43 10             	mov    0x10(%ebx),%eax
c0002732:	8b 53 14             	mov    0x14(%ebx),%edx
c0002735:	0f ac d0 04          	shrd   $0x4,%edx,%eax
c0002739:	25 f0 3f 00 00       	and    $0x3ff0,%eax

        template <typename T>
        ALWAYS_INLINE
        inline void write (Tlb tlb, T val)
        {
            *reinterpret_cast<T volatile *>(iro() + tlb) = val;
c000273e:	8d 44 01 08          	lea    0x8(%ecx,%eax,1),%eax
c0002742:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c0002748:	c7 40 04 00 00 00 90 	movl   $0x90000000,0x4(%eax)

        ALWAYS_INLINE
        inline mword fro() const { return static_cast<mword>(cap >> 20 & 0x3ff0) + reg_base; }

        ALWAYS_INLINE
        inline mword iro() const { return static_cast<mword>(ecap >> 4 & 0x3ff0) + reg_base; }
c000274f:	8b 53 14             	mov    0x14(%ebx),%edx
c0002752:	8b 43 10             	mov    0x10(%ebx),%eax
c0002755:	8b 4b 04             	mov    0x4(%ebx),%ecx
c0002758:	0f ac d0 04          	shrd   $0x4,%edx,%eax
c000275c:	25 f0 3f 00 00       	and    $0x3ff0,%eax

        template <typename T>
        ALWAYS_INLINE
        inline T read (Tlb tlb)
        {
            return *reinterpret_cast<T volatile *>(iro() + tlb);
c0002761:	8d 44 01 08          	lea    0x8(%ecx,%eax,1),%eax
c0002765:	8b 50 04             	mov    0x4(%eax),%edx
c0002768:	8b 00                	mov    (%eax),%eax
            } else {
                write<uint64>(REG_CCMD, 1ULL << 63 | 1ULL << 61);
                while (read<uint64>(REG_CCMD) & (1ULL << 63))
                    pause();
                write<uint64>(REG_IOTLB, 1ULL << 63 | 1ULL << 60);
                while (read<uint64>(REG_IOTLB) & (1ULL << 63))
c000276a:	85 d2                	test   %edx,%edx
c000276c:	0f 89 4c ff ff ff    	jns    c00026be <_ZN4Dmar6assignEmP2Pd+0x184>
c0002772:	f3 90                	pause  
c0002774:	eb d9                	jmp    c000274f <_ZN4Dmar6assignEmP2Pd+0x215>

c0002776 <_ZN4Dmar13fault_handlerEv>:

void Dmar::fault_handler()
{
c0002776:	55                   	push   %ebp
c0002777:	57                   	push   %edi
c0002778:	56                   	push   %esi
c0002779:	89 c6                	mov    %eax,%esi
c000277b:	53                   	push   %ebx
c000277c:	83 ec 14             	sub    $0x14,%esp
    for (uint32 fsts; fsts = read<uint32>(REG_FSTS), fsts & 0xff;) {

        if (fsts & 0x2) {
            uint64 hi, lo;
            for (unsigned frr = fsts >> 8 & 0xff; read (frr, hi, lo), hi & 1ull << 63; frr = (frr + 1) % nfr())
                trace (TRACE_IOMMU, "DMAR:%p FRR:%u FR:%#x BDF:%x:%x:%x FI:%#010llx",
c000277f:	8d 44 24 0f          	lea    0xf(%esp),%eax
c0002783:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0002788:	89 44 24 0c          	mov    %eax,0xc(%esp)

        template <typename T>
        ALWAYS_INLINE
        inline T read (Reg reg)
        {
            return *reinterpret_cast<T volatile *>(reg_base + reg);
c000278c:	8b 46 04             	mov    0x4(%esi),%eax
c000278f:	8b 40 34             	mov    0x34(%eax),%eax
    c->set (lev | p->did << 8, p->dpt.root (p->quota, lev + 1) | 1);
}

void Dmar::fault_handler()
{
    for (uint32 fsts; fsts = read<uint32>(REG_FSTS), fsts & 0xff;) {
c0002792:	84 c0                	test   %al,%al
c0002794:	0f 84 b8 00 00 00    	je     c0002852 <_ZN4Dmar13fault_handlerEv+0xdc>

        if (fsts & 0x2) {
c000279a:	a8 02                	test   $0x2,%al
c000279c:	75 0c                	jne    c00027aa <_ZN4Dmar13fault_handlerEv+0x34>
c000279e:	8b 46 04             	mov    0x4(%esi),%eax

        template <typename T>
        ALWAYS_INLINE
        inline void write (Reg reg, T val)
        {
            *reinterpret_cast<T volatile *>(reg_base + reg) = val;
c00027a1:	c7 40 34 7d 00 00 00 	movl   $0x7d,0x34(%eax)
c00027a8:	eb e2                	jmp    c000278c <_ZN4Dmar13fault_handlerEv+0x16>
            uint64 hi, lo;
            for (unsigned frr = fsts >> 8 & 0xff; read (frr, hi, lo), hi & 1ull << 63; frr = (frr + 1) % nfr())
c00027aa:	0f b6 fc             	movzbl %ah,%edi

        ALWAYS_INLINE
        inline unsigned nfr() const { return static_cast<unsigned>(cap >> 40 & 0xff) + 1; }

        ALWAYS_INLINE
        inline mword fro() const { return static_cast<mword>(cap >> 20 & 0x3ff0) + reg_base; }
c00027ad:	8b 56 0c             	mov    0xc(%esi),%edx
c00027b0:	8b 46 08             	mov    0x8(%esi),%eax
c00027b3:	0f ac d0 14          	shrd   $0x14,%edx,%eax
        }

        ALWAYS_INLINE
        inline void read (unsigned frr, uint64 &hi, uint64 &lo)
        {
            lo = *reinterpret_cast<uint64 volatile *>(fro() + frr * 16);
c00027b7:	89 fa                	mov    %edi,%edx

        ALWAYS_INLINE
        inline unsigned nfr() const { return static_cast<unsigned>(cap >> 40 & 0xff) + 1; }

        ALWAYS_INLINE
        inline mword fro() const { return static_cast<mword>(cap >> 20 & 0x3ff0) + reg_base; }
c00027b9:	25 f0 3f 00 00       	and    $0x3ff0,%eax
c00027be:	03 46 04             	add    0x4(%esi),%eax
        }

        ALWAYS_INLINE
        inline void read (unsigned frr, uint64 &hi, uint64 &lo)
        {
            lo = *reinterpret_cast<uint64 volatile *>(fro() + frr * 16);
c00027c1:	c1 e2 04             	shl    $0x4,%edx
c00027c4:	01 d0                	add    %edx,%eax
c00027c6:	8b 10                	mov    (%eax),%edx
c00027c8:	8b 48 04             	mov    0x4(%eax),%ecx
c00027cb:	89 54 24 04          	mov    %edx,0x4(%esp)
c00027cf:	89 4c 24 08          	mov    %ecx,0x8(%esp)
            hi = *reinterpret_cast<uint64 volatile *>(fro() + frr * 16 + 8);
c00027d3:	8b 48 08             	mov    0x8(%eax),%ecx
c00027d6:	8b 58 0c             	mov    0xc(%eax),%ebx
            *reinterpret_cast<uint64 volatile *>(fro() + frr * 16 + 8) = 1ULL << 63;
c00027d9:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
c00027e0:	c7 40 0c 00 00 00 80 	movl   $0x80000000,0xc(%eax)
c00027e7:	85 db                	test   %ebx,%ebx
c00027e9:	79 b3                	jns    c000279e <_ZN4Dmar13fault_handlerEv+0x28>
                trace (TRACE_IOMMU, "DMAR:%p FRR:%u FR:%#x BDF:%x:%x:%x FI:%#010llx",
c00027eb:	89 da                	mov    %ebx,%edx
c00027ed:	89 c8                	mov    %ecx,%eax
c00027ef:	0f ac d0 03          	shrd   $0x3,%edx,%eax
c00027f3:	89 cd                	mov    %ecx,%ebp
c00027f5:	83 e0 1f             	and    $0x1f,%eax
c00027f8:	83 e5 07             	and    $0x7,%ebp
c00027fb:	89 04 24             	mov    %eax,(%esp)
c00027fe:	89 c8                	mov    %ecx,%eax
c0002800:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c0002805:	0f ac d8 08          	shrd   $0x8,%ebx,%eax
c0002809:	0f b6 db             	movzbl %bl,%ebx
c000280c:	81 7c 24 0c 00 d0 ff 	cmpl   $0xcfffd000,0xc(%esp)
c0002813:	cf 
c0002814:	0f b6 d0             	movzbl %al,%edx
c0002817:	ff 74 24 08          	pushl  0x8(%esp)
c000281b:	0f 44 0d 04 f0 ff cf 	cmove  0xcffff004,%ecx
c0002822:	ff 74 24 08          	pushl  0x8(%esp)
c0002826:	55                   	push   %ebp
c0002827:	ff 74 24 0c          	pushl  0xc(%esp)
c000282b:	52                   	push   %edx
c000282c:	53                   	push   %ebx
c000282d:	57                   	push   %edi
c000282e:	56                   	push   %esi
c000282f:	51                   	push   %ecx
c0002830:	68 e0 67 01 c0       	push   $0xc00167e0
c0002835:	e8 a4 f1 ff ff       	call   c00019de <_ZN7Console5printEPKcz>
            GCMD_SRTP   = 1UL << 30,
            GCMD_TE     = 1UL << 31,
        };

        ALWAYS_INLINE
        inline unsigned nfr() const { return static_cast<unsigned>(cap >> 40 & 0xff) + 1; }
c000283a:	8b 4e 0c             	mov    0xc(%esi),%ecx
{
    for (uint32 fsts; fsts = read<uint32>(REG_FSTS), fsts & 0xff;) {

        if (fsts & 0x2) {
            uint64 hi, lo;
            for (unsigned frr = fsts >> 8 & 0xff; read (frr, hi, lo), hi & 1ull << 63; frr = (frr + 1) % nfr())
c000283d:	8d 47 01             	lea    0x1(%edi),%eax
c0002840:	31 d2                	xor    %edx,%edx
c0002842:	83 c4 28             	add    $0x28,%esp
c0002845:	0f b6 cd             	movzbl %ch,%ecx
c0002848:	41                   	inc    %ecx
c0002849:	f7 f1                	div    %ecx
c000284b:	89 d7                	mov    %edx,%edi
c000284d:	e9 5b ff ff ff       	jmp    c00027ad <_ZN4Dmar13fault_handlerEv+0x37>
                       lo);
        }

        write<uint32>(REG_FSTS, 0x7d);
    }
}
c0002852:	83 c4 14             	add    $0x14,%esp
c0002855:	5b                   	pop    %ebx
c0002856:	5e                   	pop    %esi
c0002857:	5f                   	pop    %edi
c0002858:	5d                   	pop    %ebp
c0002859:	c3                   	ret    

c000285a <msi_vector>:

void Dmar::vector (unsigned vector)
{
    unsigned msi = vector - VEC_MSI;

    if (EXPECT_TRUE (msi == 0))
c000285a:	3d a6 00 00 00       	cmp    $0xa6,%eax
        write<uint32>(REG_FSTS, 0x7d);
    }
}

void Dmar::vector (unsigned vector)
{
c000285f:	53                   	push   %ebx
    unsigned msi = vector - VEC_MSI;

    if (EXPECT_TRUE (msi == 0))
        for (Dmar *dmar = list; dmar; dmar = dmar->next)
c0002860:	8b 1d 50 a4 01 c0    	mov    0xc001a450,%ebx

void Dmar::vector (unsigned vector)
{
    unsigned msi = vector - VEC_MSI;

    if (EXPECT_TRUE (msi == 0))
c0002866:	74 0c                	je     c0002874 <msi_vector+0x1a>
        }

        ALWAYS_INLINE
        static inline void write (Register reg, uint32 val)
        {
            *reinterpret_cast<uint32 volatile *>(CPU_LOCAL_APIC + (reg << 4)) = val;
c0002868:	c7 05 b0 e0 ff cf 00 	movl   $0x0,0xcfffe0b0
c000286f:	00 00 00 
        for (Dmar *dmar = list; dmar; dmar = dmar->next)
            dmar->fault_handler();

    Lapic::eoi();
}
c0002872:	5b                   	pop    %ebx
c0002873:	c3                   	ret    
void Dmar::vector (unsigned vector)
{
    unsigned msi = vector - VEC_MSI;

    if (EXPECT_TRUE (msi == 0))
        for (Dmar *dmar = list; dmar; dmar = dmar->next)
c0002874:	85 db                	test   %ebx,%ebx
c0002876:	74 f0                	je     c0002868 <msi_vector+0xe>
            dmar->fault_handler();
c0002878:	89 d8                	mov    %ebx,%eax
c000287a:	e8 f7 fe ff ff       	call   c0002776 <_ZN4Dmar13fault_handlerEv>
void Dmar::vector (unsigned vector)
{
    unsigned msi = vector - VEC_MSI;

    if (EXPECT_TRUE (msi == 0))
        for (Dmar *dmar = list; dmar; dmar = dmar->next)
c000287f:	8b 1b                	mov    (%ebx),%ebx
c0002881:	eb f1                	jmp    c0002874 <msi_vector+0x1a>

c0002883 <_GLOBAL__sub_I.00102__ZN4Dmar5cacheE>:
#include "pd.hpp"
#include "stdio.hpp"
#include "vectors.hpp"

INIT_PRIORITY (PRIO_SLAB)
Slab_cache  Dmar::cache (sizeof (Dmar), 8);
c0002883:	b9 08 00 00 00       	mov    $0x8,%ecx
c0002888:	ba 20 00 00 00       	mov    $0x20,%edx
c000288d:	b8 54 a4 01 c0       	mov    $0xc001a454,%eax
c0002892:	e9 6f d9 00 00       	jmp    c0010206 <_ZN10Slab_cacheC1Emj>

c0002897 <_GLOBAL__sub_I__ZN4Dmar5cacheE>:

        ALWAYS_INLINE
        inline void set (uint64 h, uint64 l) { hi = h; lo = l; flush (this); }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return flush (Buddy::allocator.alloc (0, quota, Buddy::FILL_0), PAGE_SIZE); }
c0002897:	6a 01                	push   $0x1
c0002899:	b9 50 b4 01 c0       	mov    $0xc001b450,%ecx
c000289e:	31 d2                	xor    %edx,%edx
c00028a0:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c00028a5:	e8 62 eb ff ff       	call   c000140c <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
c00028aa:	5a                   	pop    %edx
c00028ab:	8d 88 00 10 00 00    	lea    0x1000(%eax),%ecx
}

ALWAYS_INLINE NONNULL
inline void *flush (void *d, size_t n)
{
    for (char *p = static_cast<char *>(d); p < static_cast<char *>(d) + n; p += 32)
c00028b1:	89 c2                	mov    %eax,%edx
c00028b3:	39 ca                	cmp    %ecx,%edx
c00028b5:	74 08                	je     c00028bf <_GLOBAL__sub_I__ZN4Dmar5cacheE+0x28>

template <typename T>
ALWAYS_INLINE
static inline void flush (T t)
{
    asm volatile ("clflush %0" : : "m" (*t) : "memory");
c00028b7:	0f ae 3a             	clflush (%edx)
}

ALWAYS_INLINE NONNULL
inline void *flush (void *d, size_t n)
{
    for (char *p = static_cast<char *>(d); p < static_cast<char *>(d) + n; p += 32)
c00028ba:	83 c2 20             	add    $0x20,%edx
c00028bd:	eb f4                	jmp    c00028b3 <_GLOBAL__sub_I__ZN4Dmar5cacheE+0x1c>

Dmar *      Dmar::list;
Dmar_ctx *  Dmar::ctx = new (Pd::kern.quota) Dmar_ctx;
c00028bf:	a3 4c a4 01 c0       	mov    %eax,0xc001a44c
    public:
        ALWAYS_INLINE
        inline void set (uint64 h, uint64 l) { hi = h; lo = l; flush (this); }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return flush (Buddy::allocator.alloc (0, quota, Buddy::FILL_0), PAGE_SIZE); }
c00028c4:	b9 50 b4 01 c0       	mov    $0xc001b450,%ecx
c00028c9:	31 d2                	xor    %edx,%edx
c00028cb:	6a 01                	push   $0x1
c00028cd:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c00028d2:	e8 35 eb ff ff       	call   c000140c <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
c00028d7:	5a                   	pop    %edx
c00028d8:	8d 88 00 10 00 00    	lea    0x1000(%eax),%ecx
c00028de:	89 c2                	mov    %eax,%edx
c00028e0:	39 ca                	cmp    %ecx,%edx
c00028e2:	74 08                	je     c00028ec <_GLOBAL__sub_I__ZN4Dmar5cacheE+0x55>

template <typename T>
ALWAYS_INLINE
static inline void flush (T t)
{
    asm volatile ("clflush %0" : : "m" (*t) : "memory");
c00028e4:	0f ae 3a             	clflush (%edx)
}

ALWAYS_INLINE NONNULL
inline void *flush (void *d, size_t n)
{
    for (char *p = static_cast<char *>(d); p < static_cast<char *>(d) + n; p += 32)
c00028e7:	83 c2 20             	add    $0x20,%edx
c00028ea:	eb f4                	jmp    c00028e0 <_GLOBAL__sub_I__ZN4Dmar5cacheE+0x49>
Dmar_irt *  Dmar::irt = new (Pd::kern.quota) Dmar_irt;
c00028ec:	a3 48 a4 01 c0       	mov    %eax,0xc001a448
c00028f1:	c3                   	ret    

c00028f2 <_ZN7Kobject4freeEP8Rcu_elem>:
class Kobject : public Mdb
{
    private:
        uint8 objtype;

        static void free (Rcu_elem *) {}
c00028f2:	c3                   	ret    

c00028f3 <_ZN2Ec8pre_freeEP8Rcu_elem>:
        static bool fixup (mword &);

        NOINLINE
        static void handle_hazard (mword, void (*)());

        static void pre_free (Rcu_elem * a)
c00028f3:	56                   	push   %esi
        {
            Ec * e = static_cast<Ec *>(a);
c00028f4:	85 c0                	test   %eax,%eax
        static bool fixup (mword &);

        NOINLINE
        static void handle_hazard (mword, void (*)());

        static void pre_free (Rcu_elem * a)
c00028f6:	53                   	push   %ebx
c00028f7:	89 c3                	mov    %eax,%ebx
        {
            Ec * e = static_cast<Ec *>(a);
c00028f9:	74 07                	je     c0002902 <_ZN2Ec8pre_freeEP8Rcu_elem+0xf>

            assert(e);
c00028fb:	89 c6                	mov    %eax,%esi
c00028fd:	83 ee 0c             	sub    $0xc,%esi
c0002900:	75 13                	jne    c0002915 <_ZN2Ec8pre_freeEP8Rcu_elem+0x22>
c0002902:	68 20 6e 01 c0       	push   $0xc0016e20
c0002907:	6a 7a                	push   $0x7a
c0002909:	68 83 68 01 c0       	push   $0xc0016883
c000290e:	68 96 6e 01 c0       	push   $0xc0016e96
c0002913:	eb 77                	jmp    c000298c <_ZN2Ec8pre_freeEP8Rcu_elem+0x99>

            // remove mapping in page table
            if (e->user_utcb) {
c0002915:	8b 90 e4 00 00 00    	mov    0xe4(%eax),%edx
c000291b:	85 d2                	test   %edx,%edx
c000291d:	74 3f                	je     c000295e <_ZN2Ec8pre_freeEP8Rcu_elem+0x6b>
                e->pd->remove_utcb(e->user_utcb);
c000291f:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
c0002925:	83 c0 4c             	add    $0x4c,%eax
c0002928:	e8 59 e5 00 00       	call   c0010e86 <_ZN9Space_mem11remove_utcbEm>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
c000292d:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
c0002933:	6a 00                	push   $0x0
c0002935:	8b 8b e4 00 00 00    	mov    0xe4(%ebx),%ecx
c000293b:	6a 00                	push   $0x0
c000293d:	6a 00                	push   $0x0
                e->pd->Space_mem::insert (e->pd->quota, e->user_utcb, 0, 0, 0);
c000293f:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx
c0002945:	05 54 01 00 00       	add    $0x154,%eax
c000294a:	6a 00                	push   $0x0
c000294c:	e8 6f b7 00 00       	call   c000e0c0 <_ZN3PteI3HptmLj2ELj10ELb0EE6updateER5QuotammmmNS1_4TypeE>
c0002951:	83 c4 10             	add    $0x10,%esp
                e->user_utcb = 0;
c0002954:	c7 83 e4 00 00 00 00 	movl   $0x0,0xe4(%ebx)
c000295b:	00 00 00 
            }

            // XXX If e is on another CPU and there the fpowner - this check will fail.
            // XXX For now the destruction is delayed until somebody else grabs the FPU.
            if (fpowner == e) {
c000295e:	39 35 7c f7 ff cf    	cmp    %esi,0xcffff77c
c0002964:	75 62                	jne    c00029c8 <_ZN2Ec8pre_freeEP8Rcu_elem+0xd5>
                assert (Sc::current->cpu == e->cpu);
c0002966:	8b 15 10 f0 ff cf    	mov    0xcffff010,%edx
c000296c:	0f b7 86 cc 00 00 00 	movzwl 0xcc(%esi),%eax
c0002973:	39 42 50             	cmp    %eax,0x50(%edx)
c0002976:	74 1e                	je     c0002996 <_ZN2Ec8pre_freeEP8Rcu_elem+0xa3>
c0002978:	68 20 6e 01 c0       	push   $0xc0016e20
c000297d:	68 86 00 00 00       	push   $0x86
c0002982:	68 83 68 01 c0       	push   $0xc0016883
c0002987:	68 f2 68 01 c0       	push   $0xc00168f2
c000298c:	68 69 60 01 c0       	push   $0xc0016069
c0002991:	e8 b0 ef ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c0002996:	83 c8 ff             	or     $0xffffffff,%eax
c0002999:	f0 0f c1 46 48       	lock xadd %eax,0x48(%esi)

                bool zero = fpowner->del_ref();
                assert (!zero);
c000299e:	48                   	dec    %eax
c000299f:	75 16                	jne    c00029b7 <_ZN2Ec8pre_freeEP8Rcu_elem+0xc4>
c00029a1:	68 20 6e 01 c0       	push   $0xc0016e20
c00029a6:	68 89 00 00 00       	push   $0x89
c00029ab:	68 83 68 01 c0       	push   $0xc0016883
c00029b0:	68 0d 69 01 c0       	push   $0xc001690d
c00029b5:	eb d5                	jmp    c000298c <_ZN2Ec8pre_freeEP8Rcu_elem+0x99>

                fpowner      = nullptr;
                Cpu::hazard |= HZD_FPU;
c00029b7:	83 0d 00 f0 ff cf 08 	orl    $0x8,0xcffff000
                assert (Sc::current->cpu == e->cpu);

                bool zero = fpowner->del_ref();
                assert (!zero);

                fpowner      = nullptr;
c00029be:	c7 05 7c f7 ff cf 00 	movl   $0x0,0xcffff77c
c00029c5:	00 00 00 
                Cpu::hazard |= HZD_FPU;
            }
        }
c00029c8:	5b                   	pop    %ebx
c00029c9:	5e                   	pop    %esi
c00029ca:	c3                   	ret    
c00029cb:	90                   	nop

c00029cc <_ZN5Quota7free_upERS_>:
        {
            kern.upli   = kern.used;
            root.upli  -= kern.used;
        }

        void free_up(Quota &to)
c00029cc:	55                   	push   %ebp
c00029cd:	89 c5                	mov    %eax,%ebp
c00029cf:	57                   	push   %edi
c00029d0:	56                   	push   %esi
c00029d1:	89 d6                	mov    %edx,%esi
c00029d3:	53                   	push   %ebx
c00029d4:	83 ec 08             	sub    $0x8,%esp

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c00029d7:	9c                   	pushf  
c00029d8:	5b                   	pop    %ebx
            return flags & 0x200;
c00029d9:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c00029dc:	80 e3 01             	and    $0x1,%bl
c00029df:	74 27                	je     c0002a08 <_ZN5Quota7free_upERS_+0x3c>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c00029e1:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c00029e8:	75 16                	jne    c0002a00 <_ZN5Quota7free_upERS_+0x34>
c00029ea:	68 a0 6d 01 c0       	push   $0xc0016da0
c00029ef:	68 b7 00 00 00       	push   $0xb7
c00029f4:	68 12 61 01 c0       	push   $0xc0016112
c00029f9:	68 83 61 01 c0       	push   $0xc0016183
c00029fe:	eb 51                	jmp    c0002a51 <_ZN5Quota7free_upERS_+0x85>

            asm volatile ("cli" : : : "memory");
c0002a00:	fa                   	cli    
            preemption = false;
c0002a01:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c0002a08:	89 e8                	mov    %ebp,%eax
c0002a0a:	e8 1d e1 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
        {
            mword l, u, o;
            {
                Lock_guard <Spinlock> guard (lock);
                l = upli;
c0002a0f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
                u = used;
c0002a12:	8b 55 04             	mov    0x4(%ebp),%edx
                o = over;
c0002a15:	8b 7d 08             	mov    0x8(%ebp),%edi
                upli = over = used = 0;
c0002a18:	c7 45 04 00 00 00 00 	movl   $0x0,0x4(%ebp)
c0002a1f:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
c0002a26:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%ebp)
c0002a2d:	fe 45 00             	incb   0x0(%ebp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c0002a30:	84 db                	test   %bl,%bl
c0002a32:	74 2f                	je     c0002a63 <_ZN5Quota7free_upERS_+0x97>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0002a34:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0002a3b:	74 1e                	je     c0002a5b <_ZN5Quota7free_upERS_+0x8f>
c0002a3d:	68 60 6d 01 c0       	push   $0xc0016d60
c0002a42:	68 c0 00 00 00       	push   $0xc0
c0002a47:	68 12 61 01 c0       	push   $0xc0016112
c0002a4c:	68 82 61 01 c0       	push   $0xc0016182
c0002a51:	68 69 60 01 c0       	push   $0xc0016069
c0002a56:	e8 eb ee ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

            preemption = true;
c0002a5b:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c0002a62:	fb                   	sti    

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c0002a63:	9c                   	pushf  
c0002a64:	5b                   	pop    %ebx
            return flags & 0x200;
c0002a65:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c0002a68:	80 e3 01             	and    $0x1,%bl
c0002a6b:	74 15                	je     c0002a82 <_ZN5Quota7free_upERS_+0xb6>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0002a6d:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0002a74:	0f 84 70 ff ff ff    	je     c00029ea <_ZN5Quota7free_upERS_+0x1e>

            asm volatile ("cli" : : : "memory");
c0002a7a:	fa                   	cli    
            preemption = false;
c0002a7b:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c0002a82:	89 f0                	mov    %esi,%eax
c0002a84:	89 54 24 04          	mov    %edx,0x4(%esp)
c0002a88:	89 0c 24             	mov    %ecx,(%esp)
c0002a8b:	e8 9c e0 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
            }

            Lock_guard <Spinlock> guard (to.lock);
            to.used += u;
            to.upli += l;
            to.over += o;
c0002a90:	8b 46 08             	mov    0x8(%esi),%eax
                o = over;
                upli = over = used = 0;
            }

            Lock_guard <Spinlock> guard (to.lock);
            to.used += u;
c0002a93:	8b 54 24 04          	mov    0x4(%esp),%edx
            to.upli += l;
c0002a97:	8b 0c 24             	mov    (%esp),%ecx
                o = over;
                upli = over = used = 0;
            }

            Lock_guard <Spinlock> guard (to.lock);
            to.used += u;
c0002a9a:	03 56 04             	add    0x4(%esi),%edx
            to.upli += l;
c0002a9d:	03 4e 0c             	add    0xc(%esi),%ecx
            to.over += o;
c0002aa0:	01 f8                	add    %edi,%eax

            if (to.over && to.used) {
c0002aa2:	85 c0                	test   %eax,%eax
                o = over;
                upli = over = used = 0;
            }

            Lock_guard <Spinlock> guard (to.lock);
            to.used += u;
c0002aa4:	89 56 04             	mov    %edx,0x4(%esi)
            to.upli += l;
c0002aa7:	89 4e 0c             	mov    %ecx,0xc(%esi)
            to.over += o;
c0002aaa:	89 46 08             	mov    %eax,0x8(%esi)

            if (to.over && to.used) {
c0002aad:	74 1a                	je     c0002ac9 <_ZN5Quota7free_upERS_+0xfd>
c0002aaf:	85 d2                	test   %edx,%edx
c0002ab1:	74 16                	je     c0002ac9 <_ZN5Quota7free_upERS_+0xfd>
c0002ab3:	39 d0                	cmp    %edx,%eax
c0002ab5:	89 d7                	mov    %edx,%edi
c0002ab7:	0f 46 f8             	cmovbe %eax,%edi
                mword s = min (to.used, to.over);
                to.used -= s;
c0002aba:	29 fa                	sub    %edi,%edx
                to.over -= s;
c0002abc:	29 f8                	sub    %edi,%eax
                to.upli -= s;
c0002abe:	29 f9                	sub    %edi,%ecx
            to.upli += l;
            to.over += o;

            if (to.over && to.used) {
                mword s = min (to.used, to.over);
                to.used -= s;
c0002ac0:	89 56 04             	mov    %edx,0x4(%esi)
                to.over -= s;
c0002ac3:	89 46 08             	mov    %eax,0x8(%esi)
                to.upli -= s;
c0002ac6:	89 4e 0c             	mov    %ecx,0xc(%esi)
c0002ac9:	fe 06                	incb   (%esi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c0002acb:	84 db                	test   %bl,%bl
c0002acd:	74 15                	je     c0002ae4 <_ZN5Quota7free_upERS_+0x118>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0002acf:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0002ad6:	0f 85 61 ff ff ff    	jne    c0002a3d <_ZN5Quota7free_upERS_+0x71>

            preemption = true;
c0002adc:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c0002ae3:	fb                   	sti    
            }
        }
c0002ae4:	83 c4 08             	add    $0x8,%esp
c0002ae7:	5b                   	pop    %ebx
c0002ae8:	5e                   	pop    %esi
c0002ae9:	5f                   	pop    %edi
c0002aea:	5d                   	pop    %ebp
c0002aeb:	c3                   	ret    

c0002aec <_ZN5Quota11transfer_toERS_mb>:
                 return true;

             return usage() > upli - free_space;
        }

        bool transfer_to(Quota &to, mword transfer, bool check_notr = true)
c0002aec:	55                   	push   %ebp
c0002aed:	57                   	push   %edi
c0002aee:	89 c7                	mov    %eax,%edi
c0002af0:	56                   	push   %esi
c0002af1:	89 d6                	mov    %edx,%esi
c0002af3:	53                   	push   %ebx
c0002af4:	89 cb                	mov    %ecx,%ebx
c0002af6:	83 ec 08             	sub    $0x8,%esp
c0002af9:	8a 44 24 1c          	mov    0x1c(%esp),%al
c0002afd:	88 04 24             	mov    %al,(%esp)

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c0002b00:	9c                   	pushf  
c0002b01:	5a                   	pop    %edx
            return flags & 0x200;
c0002b02:	c1 ea 09             	shr    $0x9,%edx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c0002b05:	80 e2 01             	and    $0x1,%dl
c0002b08:	74 27                	je     c0002b31 <_ZN5Quota11transfer_toERS_mb+0x45>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0002b0a:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0002b11:	75 16                	jne    c0002b29 <_ZN5Quota11transfer_toERS_mb+0x3d>
c0002b13:	68 a0 6d 01 c0       	push   $0xc0016da0
c0002b18:	68 b7 00 00 00       	push   $0xb7
c0002b1d:	68 12 61 01 c0       	push   $0xc0016112
c0002b22:	68 83 61 01 c0       	push   $0xc0016183
c0002b27:	eb 7d                	jmp    c0002ba6 <_ZN5Quota11transfer_toERS_mb+0xba>

            asm volatile ("cli" : : : "memory");
c0002b29:	fa                   	cli    
            preemption = false;
c0002b2a:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c0002b31:	89 f8                	mov    %edi,%eax
c0002b33:	88 54 24 07          	mov    %dl,0x7(%esp)
c0002b37:	e8 f0 df ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
            }
        }

        bool hit_limit(mword free_space = 0)
        {
             if (free_space > upli)
c0002b3c:	8b 47 0c             	mov    0xc(%edi),%eax
c0002b3f:	8b 4f 04             	mov    0x4(%edi),%ecx
             mword o = 0;

             {
                 Lock_guard <Spinlock> guard (lock);

                 if (hit_limit()) return false;
c0002b42:	8a 54 24 07          	mov    0x7(%esp),%dl
c0002b46:	39 c1                	cmp    %eax,%ecx
c0002b48:	0f 87 bf 00 00 00    	ja     c0002c0d <_ZN5Quota11transfer_toERS_mb+0x121>

                 mword not_for_transfer = check_notr ? notr : 0;
c0002b4e:	31 ed                	xor    %ebp,%ebp
c0002b50:	80 3c 24 00          	cmpb   $0x0,(%esp)
c0002b54:	74 03                	je     c0002b59 <_ZN5Quota11transfer_toERS_mb+0x6d>
c0002b56:	8b 6f 10             	mov    0x10(%edi),%ebp

                 if (usage() + transfer > upli - not_for_transfer) return false;
c0002b59:	01 d9                	add    %ebx,%ecx
c0002b5b:	89 0c 24             	mov    %ecx,(%esp)
c0002b5e:	89 c1                	mov    %eax,%ecx
c0002b60:	29 e9                	sub    %ebp,%ecx
c0002b62:	39 0c 24             	cmp    %ecx,(%esp)
c0002b65:	0f 87 a2 00 00 00    	ja     c0002c0d <_ZN5Quota11transfer_toERS_mb+0x121>

                 upli -= transfer;
c0002b6b:	29 d8                	sub    %ebx,%eax
c0002b6d:	89 47 0c             	mov    %eax,0xc(%edi)

                 o = min (over, transfer);
c0002b70:	8b 47 08             	mov    0x8(%edi),%eax
c0002b73:	39 c3                	cmp    %eax,%ebx
c0002b75:	89 c5                	mov    %eax,%ebp
c0002b77:	0f 46 eb             	cmovbe %ebx,%ebp
                 if (o)
c0002b7a:	85 ed                	test   %ebp,%ebp
c0002b7c:	74 05                	je     c0002b83 <_ZN5Quota11transfer_toERS_mb+0x97>
                     over -= o;
c0002b7e:	29 e8                	sub    %ebp,%eax
c0002b80:	89 47 08             	mov    %eax,0x8(%edi)
c0002b83:	fe 07                	incb   (%edi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c0002b85:	84 d2                	test   %dl,%dl
c0002b87:	74 2f                	je     c0002bb8 <_ZN5Quota11transfer_toERS_mb+0xcc>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0002b89:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0002b90:	74 1e                	je     c0002bb0 <_ZN5Quota11transfer_toERS_mb+0xc4>
c0002b92:	68 60 6d 01 c0       	push   $0xc0016d60
c0002b97:	68 c0 00 00 00       	push   $0xc0
c0002b9c:	68 12 61 01 c0       	push   $0xc0016112
c0002ba1:	68 82 61 01 c0       	push   $0xc0016182
c0002ba6:	68 69 60 01 c0       	push   $0xc0016069
c0002bab:	e8 96 ed ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

            preemption = true;
c0002bb0:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c0002bb7:	fb                   	sti    

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c0002bb8:	9c                   	pushf  
c0002bb9:	5a                   	pop    %edx
            return flags & 0x200;
c0002bba:	c1 ea 09             	shr    $0x9,%edx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c0002bbd:	80 e2 01             	and    $0x1,%dl
c0002bc0:	74 15                	je     c0002bd7 <_ZN5Quota11transfer_toERS_mb+0xeb>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0002bc2:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0002bc9:	0f 84 44 ff ff ff    	je     c0002b13 <_ZN5Quota11transfer_toERS_mb+0x27>

            asm volatile ("cli" : : : "memory");
c0002bcf:	fa                   	cli    
            preemption = false;
c0002bd0:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c0002bd7:	89 f0                	mov    %esi,%eax
c0002bd9:	88 14 24             	mov    %dl,(%esp)
c0002bdc:	e8 4b df ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
             }

             Lock_guard <Spinlock> guard (to.lock);
             to.upli += transfer;

             if (to.used && o) {
c0002be1:	8b 46 04             	mov    0x4(%esi),%eax
                 if (o)
                     over -= o;
             }

             Lock_guard <Spinlock> guard (to.lock);
             to.upli += transfer;
c0002be4:	03 5e 0c             	add    0xc(%esi),%ebx

             if (to.used && o) {
c0002be7:	85 ed                	test   %ebp,%ebp
c0002be9:	8a 14 24             	mov    (%esp),%dl
                 if (o)
                     over -= o;
             }

             Lock_guard <Spinlock> guard (to.lock);
             to.upli += transfer;
c0002bec:	89 5e 0c             	mov    %ebx,0xc(%esi)

             if (to.used && o) {
c0002bef:	74 2c                	je     c0002c1d <_ZN5Quota11transfer_toERS_mb+0x131>
c0002bf1:	85 c0                	test   %eax,%eax
c0002bf3:	74 28                	je     c0002c1d <_ZN5Quota11transfer_toERS_mb+0x131>
c0002bf5:	39 c5                	cmp    %eax,%ebp
c0002bf7:	89 c1                	mov    %eax,%ecx
c0002bf9:	0f 46 cd             	cmovbe %ebp,%ecx
                mword u = min (to.used, o);
                to.used -= u;
c0002bfc:	29 c8                	sub    %ecx,%eax
                to.upli -= u;
c0002bfe:	29 cb                	sub    %ecx,%ebx
                to.over += o - u;
c0002c00:	29 cd                	sub    %ecx,%ebp
             Lock_guard <Spinlock> guard (to.lock);
             to.upli += transfer;

             if (to.used && o) {
                mword u = min (to.used, o);
                to.used -= u;
c0002c02:	89 46 04             	mov    %eax,0x4(%esi)
                to.upli -= u;
c0002c05:	89 5e 0c             	mov    %ebx,0xc(%esi)
                to.over += o - u;
c0002c08:	01 6e 08             	add    %ebp,0x8(%esi)
c0002c0b:	eb 10                	jmp    c0002c1d <_ZN5Quota11transfer_toERS_mb+0x131>
c0002c0d:	fe 07                	incb   (%edi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c0002c0f:	84 d2                	test   %dl,%dl
c0002c11:	74 29                	je     c0002c3c <_ZN5Quota11transfer_toERS_mb+0x150>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0002c13:	8a 15 00 f7 ff cf    	mov    0xcffff700,%dl
c0002c19:	84 d2                	test   %dl,%dl
c0002c1b:	eb 0d                	jmp    c0002c2a <_ZN5Quota11transfer_toERS_mb+0x13e>
c0002c1d:	fe 06                	incb   (%esi)
c0002c1f:	84 d2                	test   %dl,%dl
c0002c21:	74 17                	je     c0002c3a <_ZN5Quota11transfer_toERS_mb+0x14e>
c0002c23:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0002c2a:	0f 85 62 ff ff ff    	jne    c0002b92 <_ZN5Quota11transfer_toERS_mb+0xa6>

            preemption = true;
c0002c30:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c0002c37:	fb                   	sti    
c0002c38:	eb 02                	jmp    c0002c3c <_ZN5Quota11transfer_toERS_mb+0x150>
             }

             return true;
c0002c3a:	b2 01                	mov    $0x1,%dl
        }
c0002c3c:	83 c4 08             	add    $0x8,%esp
c0002c3f:	88 d0                	mov    %dl,%al
c0002c41:	5b                   	pop    %ebx
c0002c42:	5e                   	pop    %esi
c0002c43:	5f                   	pop    %edi
c0002c44:	5d                   	pop    %ebp
c0002c45:	c3                   	ret    

c0002c46 <_ZN3MdbC1EP5SpacemmmPFvP8Rcu_elemES5_>:

        ALWAYS_INLINE
        inline bool equal  (Mdb *x) const { return (node_base ^ x->node_base) >> max (node_order, x->node_order) == 0; }

        NOINLINE
        explicit Mdb (Space *s, mword p, mword b, mword a, void (*f)(Rcu_elem *), void (*pf)(Rcu_elem *) = nullptr) : Rcu_elem (f, pf), dpth (0), prev (this), next (this), prnt (nullptr), space (s), node_phys (p), node_base (b), node_order (0), node_attr (a), node_type (0), node_sub (0) {}
c0002c46:	53                   	push   %ebx
c0002c47:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0002c4b:	89 50 28             	mov    %edx,0x28(%eax)
c0002c4e:	8b 54 24 08          	mov    0x8(%esp),%edx
c0002c52:	66 c7 40 08 02 00    	movw   $0x2,0x8(%eax)
c0002c58:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
c0002c5e:	89 58 10             	mov    %ebx,0x10(%eax)
c0002c61:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c0002c65:	89 50 30             	mov    %edx,0x30(%eax)
c0002c68:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0002c6c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
c0002c73:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c0002c79:	89 58 14             	mov    %ebx,0x14(%eax)
c0002c7c:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    private:
        uint16 val;

    public:
        ALWAYS_INLINE
        inline Spinlock() : val (0) {}
c0002c83:	66 c7 40 18 00 00    	movw   $0x0,0x18(%eax)
c0002c89:	66 c7 40 1a 00 00    	movw   $0x0,0x1a(%eax)
c0002c8f:	89 40 1c             	mov    %eax,0x1c(%eax)
c0002c92:	89 40 20             	mov    %eax,0x20(%eax)
c0002c95:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
c0002c9c:	89 48 2c             	mov    %ecx,0x2c(%eax)
c0002c9f:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
c0002ca6:	89 50 38             	mov    %edx,0x38(%eax)
c0002ca9:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
c0002cb0:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
c0002cb7:	5b                   	pop    %ebx
c0002cb8:	c3                   	ret    
c0002cb9:	90                   	nop

c0002cba <_ZN2EcC1EP2PdPFvvEj>:
Slab_cache Ec::cache (sizeof (Ec), 32);

Ec *Ec::current, *Ec::fpowner;

// Constructors
Ec::Ec (Pd *own, void (*f)(), unsigned c) : Kobject (EC, static_cast<Space_obj *>(own)), cont (f), utcb (nullptr), pd (own), partner (nullptr), prev (nullptr), next (nullptr), fpu (nullptr), cpu (static_cast<uint16>(c)), glb (true), evt (0), timeout (this), user_utcb (0), xcpu_sm (nullptr), pt_oom(nullptr)
c0002cba:	57                   	push   %edi
c0002cbb:	85 d2                	test   %edx,%edx
c0002cbd:	56                   	push   %esi
c0002cbe:	89 d6                	mov    %edx,%esi
c0002cc0:	53                   	push   %ebx
c0002cc1:	89 c3                	mov    %eax,%ebx
            PT,
            SM,
            INVALID,
        };

        explicit Kobject (Type t, Space *s, mword b = 0, mword a = 0, void (*f)(Rcu_elem *) = free, void (*pref)(Rcu_elem *) = nullptr ) : Mdb (s, reinterpret_cast<mword>(this), b, a, f, pref), objtype (t) {}
c0002cc3:	6a 00                	push   $0x0
c0002cc5:	89 cf                	mov    %ecx,%edi
c0002cc7:	68 f2 28 00 c0       	push   $0xc00028f2
c0002ccc:	89 d9                	mov    %ebx,%ecx
c0002cce:	8d 82 88 01 00 00    	lea    0x188(%edx),%eax
c0002cd4:	ba 00 00 00 00       	mov    $0x0,%edx
c0002cd9:	6a 00                	push   $0x0
c0002cdb:	0f 45 d0             	cmovne %eax,%edx
c0002cde:	6a 00                	push   $0x0
c0002ce0:	89 d8                	mov    %ebx,%eax
c0002ce2:	e8 5f ff ff ff       	call   c0002c46 <_ZN3MdbC1EP5SpacemmmPFvP8Rcu_elemES5_>
c0002ce7:	83 c4 10             	add    $0x10,%esp
c0002cea:	c6 43 44 01          	movb   $0x1,0x44(%ebx)
c0002cee:	66 c7 43 46 00 00    	movw   $0x0,0x46(%ebx)
    private:
        uint32 ref;

    public:
        ALWAYS_INLINE
        inline Refex() : ref (1) {}
c0002cf4:	c7 43 48 01 00 00 00 	movl   $0x1,0x48(%ebx)
    private:
        T *headptr;

    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}
c0002cfb:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
c0002d02:	89 7b 50             	mov    %edi,0x50(%ebx)
c0002d05:	c7 83 b4 00 00 00 00 	movl   $0x0,0xb4(%ebx)
c0002d0c:	00 00 00 

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0002d0f:	8b 46 48             	mov    0x48(%esi),%eax
c0002d12:	85 c0                	test   %eax,%eax
c0002d14:	74 0c                	je     c0002d22 <_ZN2EcC1EP2PdPFvvEj+0x68>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0002d16:	8d 50 01             	lea    0x1(%eax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c0002d19:	f0 0f b1 56 48       	lock cmpxchg %edx,0x48(%esi)
c0002d1e:	75 ef                	jne    c0002d0f <_ZN2EcC1EP2PdPFvvEj+0x55>
c0002d20:	eb 02                	jmp    c0002d24 <_ZN2EcC1EP2PdPFvvEj+0x6a>
    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }

        ALWAYS_INLINE
        inline Refptr (T *p) : ptr (p->add_ref() ? p : nullptr) {}
c0002d22:	31 f6                	xor    %esi,%esi
c0002d24:	8b 44 24 10          	mov    0x10(%esp),%eax
c0002d28:	89 b3 b8 00 00 00    	mov    %esi,0xb8(%ebx)
c0002d2e:	c7 83 bc 00 00 00 00 	movl   $0x0,0xbc(%ebx)
c0002d35:	00 00 00 
c0002d38:	c7 83 c0 00 00 00 00 	movl   $0x0,0xc0(%ebx)
c0002d3f:	00 00 00 
c0002d42:	c7 83 c4 00 00 00 00 	movl   $0x0,0xc4(%ebx)
c0002d49:	00 00 00 
c0002d4c:	c7 83 c8 00 00 00 00 	movl   $0x0,0xc8(%ebx)
c0002d53:	00 00 00 
c0002d56:	66 89 83 cc 00 00 00 	mov    %ax,0xcc(%ebx)
c0002d5d:	66 c7 83 ce 00 00 00 	movw   $0x1,0xce(%ebx)
c0002d64:	01 00 
c0002d66:	c7 83 d0 00 00 00 00 	movl   $0x0,0xd0(%ebx)
c0002d6d:	00 00 00 

    public:
        static Timeout *list CPULOCAL;

        ALWAYS_INLINE
        inline Timeout() : prev (nullptr), next (nullptr), time (0) {}
c0002d70:	c7 83 d8 00 00 00 00 	movl   $0x0,0xd8(%ebx)
c0002d77:	00 00 00 
c0002d7a:	c7 83 dc 00 00 00 00 	movl   $0x0,0xdc(%ebx)
c0002d81:	00 00 00 
c0002d84:	c7 83 e0 00 00 00 00 	movl   $0x0,0xe0(%ebx)
c0002d8b:	00 00 00 
c0002d8e:	c7 83 e4 00 00 00 00 	movl   $0x0,0xe4(%ebx)
c0002d95:	00 00 00 

        void trigger();

    public:
        ALWAYS_INLINE
        inline Timeout_hypercall (Ec *e) : ec (e) {}
c0002d98:	c7 83 d4 00 00 00 d0 	movl   $0xc0019ed0,0xd4(%ebx)
c0002d9f:	9e 01 c0 
c0002da2:	89 9b e8 00 00 00    	mov    %ebx,0xe8(%ebx)
c0002da8:	c7 83 f0 00 00 00 00 	movl   $0x0,0xf0(%ebx)
c0002daf:	00 00 00 
c0002db2:	c7 83 f4 00 00 00 00 	movl   $0x0,0xf4(%ebx)
c0002db9:	00 00 00 
c0002dbc:	c7 83 f8 00 00 00 00 	movl   $0x0,0xf8(%ebx)
c0002dc3:	00 00 00 
{
    trace (TRACE_SYSCALL, "EC:%p created (PD:%p Kernel)", this, own);

    regs.vtlb = nullptr;
c0002dc6:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)
    regs.vmcs = nullptr;
c0002dcd:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
    regs.vmcb = nullptr;
}
c0002dd4:	5b                   	pop    %ebx
c0002dd5:	5e                   	pop    %esi
c0002dd6:	5f                   	pop    %edi
c0002dd7:	c3                   	ret    

c0002dd8 <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt>:

Ec::Ec (Pd *own, mword sel, Pd *p, void (*f)(), unsigned c, unsigned e, mword u, mword s, Pt *oom) : Kobject (EC, static_cast<Space_obj *>(own), sel, 0xd, free, pre_free), cont (f), pd (p), partner (nullptr), prev (nullptr), next (nullptr), fpu (nullptr), cpu (static_cast<uint16>(c)), glb (!!f), evt (e), timeout (this), user_utcb (u), xcpu_sm (nullptr), pt_oom (oom)
c0002dd8:	55                   	push   %ebp
c0002dd9:	57                   	push   %edi
c0002dda:	56                   	push   %esi
c0002ddb:	53                   	push   %ebx
c0002ddc:	89 c3                	mov    %eax,%ebx
c0002dde:	83 ec 10             	sub    $0x10,%esp
c0002de1:	85 d2                	test   %edx,%edx
c0002de3:	8b 74 24 24          	mov    0x24(%esp),%esi
c0002de7:	8d 82 88 01 00 00    	lea    0x188(%edx),%eax
c0002ded:	ba 00 00 00 00       	mov    $0x0,%edx
c0002df2:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
c0002df6:	0f 45 d0             	cmovne %eax,%edx
c0002df9:	89 d8                	mov    %ebx,%eax
c0002dfb:	8b 6c 24 34          	mov    0x34(%esp),%ebp
c0002dff:	68 f3 28 00 c0       	push   $0xc00028f3
c0002e04:	68 9d 37 00 c0       	push   $0xc000379d
c0002e09:	6a 0d                	push   $0xd
c0002e0b:	51                   	push   %ecx
c0002e0c:	89 d9                	mov    %ebx,%ecx
c0002e0e:	e8 33 fe ff ff       	call   c0002c46 <_ZN3MdbC1EP5SpacemmmPFvP8Rcu_elemES5_>
c0002e13:	8b 44 24 38          	mov    0x38(%esp),%eax
c0002e17:	83 c4 10             	add    $0x10,%esp
c0002e1a:	c6 43 44 01          	movb   $0x1,0x44(%ebx)
c0002e1e:	66 c7 43 46 00 00    	movw   $0x0,0x46(%ebx)
    private:
        uint32 ref;

    public:
        ALWAYS_INLINE
        inline Refex() : ref (1) {}
c0002e24:	c7 43 48 01 00 00 00 	movl   $0x1,0x48(%ebx)
c0002e2b:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
c0002e32:	89 43 50             	mov    %eax,0x50(%ebx)

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0002e35:	8b 46 48             	mov    0x48(%esi),%eax
c0002e38:	85 c0                	test   %eax,%eax
c0002e3a:	74 0c                	je     c0002e48 <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x70>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0002e3c:	8d 50 01             	lea    0x1(%eax),%edx
c0002e3f:	f0 0f b1 56 48       	lock cmpxchg %edx,0x48(%esi)
c0002e44:	75 ef                	jne    c0002e35 <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x5d>
c0002e46:	eb 02                	jmp    c0002e4a <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x72>
    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }

        ALWAYS_INLINE
        inline Refptr (T *p) : ptr (p->add_ref() ? p : nullptr) {}
c0002e48:	31 f6                	xor    %esi,%esi
c0002e4a:	31 c0                	xor    %eax,%eax
{
    // Make sure we have a PTAB for this CPU in the PD
    pd->Space_mem::init (pd->quota, c);
c0002e4c:	89 f9                	mov    %edi,%ecx
    regs.vtlb = nullptr;
    regs.vmcs = nullptr;
    regs.vmcb = nullptr;
}

Ec::Ec (Pd *own, mword sel, Pd *p, void (*f)(), unsigned c, unsigned e, mword u, mword s, Pt *oom) : Kobject (EC, static_cast<Space_obj *>(own), sel, 0xd, free, pre_free), cont (f), pd (p), partner (nullptr), prev (nullptr), next (nullptr), fpu (nullptr), cpu (static_cast<uint16>(c)), glb (!!f), evt (e), timeout (this), user_utcb (u), xcpu_sm (nullptr), pt_oom (oom)
c0002e4e:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
{
    // Make sure we have a PTAB for this CPU in the PD
    pd->Space_mem::init (pd->quota, c);
c0002e53:	8d 96 90 01 00 00    	lea    0x190(%esi),%edx
c0002e59:	89 b3 b8 00 00 00    	mov    %esi,0xb8(%ebx)
    regs.vtlb = nullptr;
    regs.vmcs = nullptr;
    regs.vmcb = nullptr;
}

Ec::Ec (Pd *own, mword sel, Pd *p, void (*f)(), unsigned c, unsigned e, mword u, mword s, Pt *oom) : Kobject (EC, static_cast<Space_obj *>(own), sel, 0xd, free, pre_free), cont (f), pd (p), partner (nullptr), prev (nullptr), next (nullptr), fpu (nullptr), cpu (static_cast<uint16>(c)), glb (!!f), evt (e), timeout (this), user_utcb (u), xcpu_sm (nullptr), pt_oom (oom)
c0002e5f:	0f 95 c0             	setne  %al
c0002e62:	66 89 83 ce 00 00 00 	mov    %ax,0xce(%ebx)
c0002e69:	8b 44 24 30          	mov    0x30(%esp),%eax
c0002e6d:	c7 83 bc 00 00 00 00 	movl   $0x0,0xbc(%ebx)
c0002e74:	00 00 00 
c0002e77:	c7 83 c0 00 00 00 00 	movl   $0x0,0xc0(%ebx)
c0002e7e:	00 00 00 
c0002e81:	c7 83 c4 00 00 00 00 	movl   $0x0,0xc4(%ebx)
c0002e88:	00 00 00 
c0002e8b:	89 83 d0 00 00 00    	mov    %eax,0xd0(%ebx)
c0002e91:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c0002e95:	c7 83 c8 00 00 00 00 	movl   $0x0,0xc8(%ebx)
c0002e9c:	00 00 00 
c0002e9f:	66 89 bb cc 00 00 00 	mov    %di,0xcc(%ebx)
c0002ea6:	c7 83 d8 00 00 00 00 	movl   $0x0,0xd8(%ebx)
c0002ead:	00 00 00 
c0002eb0:	89 83 f8 00 00 00    	mov    %eax,0xf8(%ebx)
{
    // Make sure we have a PTAB for this CPU in the PD
    pd->Space_mem::init (pd->quota, c);
c0002eb6:	8d 46 4c             	lea    0x4c(%esi),%eax
c0002eb9:	c7 83 dc 00 00 00 00 	movl   $0x0,0xdc(%ebx)
c0002ec0:	00 00 00 
c0002ec3:	c7 83 e0 00 00 00 00 	movl   $0x0,0xe0(%ebx)
c0002eca:	00 00 00 
c0002ecd:	c7 83 e4 00 00 00 00 	movl   $0x0,0xe4(%ebx)
c0002ed4:	00 00 00 
c0002ed7:	c7 83 d4 00 00 00 d0 	movl   $0xc0019ed0,0xd4(%ebx)
c0002ede:	9e 01 c0 
c0002ee1:	89 9b e8 00 00 00    	mov    %ebx,0xe8(%ebx)
    regs.vtlb = nullptr;
    regs.vmcs = nullptr;
    regs.vmcb = nullptr;
}

Ec::Ec (Pd *own, mword sel, Pd *p, void (*f)(), unsigned c, unsigned e, mword u, mword s, Pt *oom) : Kobject (EC, static_cast<Space_obj *>(own), sel, 0xd, free, pre_free), cont (f), pd (p), partner (nullptr), prev (nullptr), next (nullptr), fpu (nullptr), cpu (static_cast<uint16>(c)), glb (!!f), evt (e), timeout (this), user_utcb (u), xcpu_sm (nullptr), pt_oom (oom)
c0002ee7:	89 ab f0 00 00 00    	mov    %ebp,0xf0(%ebx)
c0002eed:	c7 83 f4 00 00 00 00 	movl   $0x0,0xf4(%ebx)
c0002ef4:	00 00 00 
{
    // Make sure we have a PTAB for this CPU in the PD
    pd->Space_mem::init (pd->quota, c);
c0002ef7:	e8 c6 d8 00 00       	call   c00107c2 <_ZN9Space_mem4initER5Quotaj>

    regs.vtlb = nullptr;
    regs.vmcs = nullptr;
    regs.vmcb = nullptr;

    if (pt_oom)
c0002efc:	8b 93 f8 00 00 00    	mov    0xf8(%ebx),%edx
Ec::Ec (Pd *own, mword sel, Pd *p, void (*f)(), unsigned c, unsigned e, mword u, mword s, Pt *oom) : Kobject (EC, static_cast<Space_obj *>(own), sel, 0xd, free, pre_free), cont (f), pd (p), partner (nullptr), prev (nullptr), next (nullptr), fpu (nullptr), cpu (static_cast<uint16>(c)), glb (!!f), evt (e), timeout (this), user_utcb (u), xcpu_sm (nullptr), pt_oom (oom)
{
    // Make sure we have a PTAB for this CPU in the PD
    pd->Space_mem::init (pd->quota, c);

    regs.vtlb = nullptr;
c0002f02:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)
    regs.vmcs = nullptr;
c0002f09:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
    regs.vmcb = nullptr;

    if (pt_oom)
c0002f10:	85 d2                	test   %edx,%edx
c0002f12:	75 0f                	jne    c0002f23 <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x14b>
        pt_oom->add_ref();

    if (u) {
c0002f14:	85 ed                	test   %ebp,%ebp
c0002f16:	8b 8b b8 00 00 00    	mov    0xb8(%ebx),%ecx
c0002f1c:	75 16                	jne    c0002f34 <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x15c>
c0002f1e:	e9 eb 00 00 00       	jmp    c000300e <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x236>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0002f23:	8b 42 48             	mov    0x48(%edx),%eax
c0002f26:	85 c0                	test   %eax,%eax
c0002f28:	74 ea                	je     c0002f14 <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x13c>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0002f2a:	8d 48 01             	lea    0x1(%eax),%ecx
c0002f2d:	f0 0f b1 4a 48       	lock cmpxchg %ecx,0x48(%edx)
c0002f32:	eb de                	jmp    c0002f12 <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x13a>
        regs.ds  = SEL_USER_DATA;
        regs.es  = SEL_USER_DATA;
        regs.ss  = SEL_USER_DATA;
        regs.REG(fl) = Cpu::EFL_IF;

        if (glb)
c0002f34:	66 83 bb ce 00 00 00 	cmpw   $0x0,0xce(%ebx)
c0002f3b:	00 
    if (pt_oom)
        pt_oom->add_ref();

    if (u) {

        regs.cs  = SEL_USER_CODE;
c0002f3c:	c7 83 90 00 00 00 1b 	movl   $0x1b,0x90(%ebx)
c0002f43:	00 00 00 
        regs.es  = SEL_USER_DATA;
        regs.ss  = SEL_USER_DATA;
        regs.REG(fl) = Cpu::EFL_IF;

        if (glb)
            regs.REG(sp) = s;
c0002f46:	8b 44 24 38          	mov    0x38(%esp),%eax
        pt_oom->add_ref();

    if (u) {

        regs.cs  = SEL_USER_CODE;
        regs.ds  = SEL_USER_DATA;
c0002f4a:	c7 83 80 00 00 00 23 	movl   $0x23,0x80(%ebx)
c0002f51:	00 00 00 
        regs.es  = SEL_USER_DATA;
c0002f54:	c7 43 7c 23 00 00 00 	movl   $0x23,0x7c(%ebx)
        regs.ss  = SEL_USER_DATA;
c0002f5b:	c7 83 9c 00 00 00 23 	movl   $0x23,0x9c(%ebx)
c0002f62:	00 00 00 
        regs.REG(fl) = Cpu::EFL_IF;
c0002f65:	c7 83 94 00 00 00 00 	movl   $0x200,0x94(%ebx)
c0002f6c:	02 00 00 

        if (glb)
c0002f6f:	74 08                	je     c0002f79 <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x1a1>
            regs.REG(sp) = s;
c0002f71:	89 83 98 00 00 00    	mov    %eax,0x98(%ebx)
c0002f77:	eb 03                	jmp    c0002f7c <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x1a4>

        ALWAYS_INLINE
        inline void set_sp (mword sp) { ARG_SP = sp; }
c0002f79:	89 43 6c             	mov    %eax,0x6c(%ebx)

        ALWAYS_INLINE
        inline Xfer *xfer() { return reinterpret_cast<Xfer *>(this) + PAGE_SIZE / sizeof (Xfer) - 1; }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return Buddy::allocator.alloc (0, quota, Buddy::FILL_0); }
c0002f7c:	6a 01                	push   $0x1
        else
            regs.set_sp (s);

        utcb = new (pd->quota) Utcb;
c0002f7e:	81 c1 90 01 00 00    	add    $0x190,%ecx
c0002f84:	31 d2                	xor    %edx,%edx
c0002f86:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c0002f8b:	e8 7c e4 ff ff       	call   c000140c <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
            PIO = 2,
            OBJ = 3,
        };

        ALWAYS_INLINE
        inline explicit Crd() : val (0) {}
c0002f90:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
c0002f97:	89 c1                	mov    %eax,%ecx
c0002f99:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
c0002fa0:	81 e9 00 00 c0 bf    	sub    $0xbfc00000,%ecx
c0002fa6:	89 83 b4 00 00 00    	mov    %eax,0xb4(%ebx)
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
c0002fac:	8b 83 b8 00 00 00    	mov    0xb8(%ebx),%eax
c0002fb2:	6a 00                	push   $0x0
c0002fb4:	6a 07                	push   $0x7
c0002fb6:	51                   	push   %ecx
c0002fb7:	89 e9                	mov    %ebp,%ecx

        pd->Space_mem::insert (pd->quota, u, 0, Hpt::HPT_U | Hpt::HPT_W | Hpt::HPT_P, Buddy::ptr_to_phys (utcb));
c0002fb9:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx
c0002fbf:	05 54 01 00 00       	add    $0x154,%eax
c0002fc4:	6a 00                	push   $0x0
c0002fc6:	e8 f5 b0 00 00       	call   c000e0c0 <_ZN3PteI3HptmLj2ELj10ELb0EE6updateER5QuotammmmNS1_4TypeE>

        regs.dst_portal = NUM_EXC - 2;

        trace (TRACE_SYSCALL, "EC:%p created (PD:%p CPU:%#x UTCB:%#lx ESP:%lx EVT:%#x)", this, p, c, u, s, e);

        if (pd == &Pd::root)
c0002fcb:	83 c4 14             	add    $0x14,%esp
c0002fce:	81 bb b8 00 00 00 00 	cmpl   $0xc001b100,0xb8(%ebx)
c0002fd5:	b1 01 c0 

        utcb = new (pd->quota) Utcb;

        pd->Space_mem::insert (pd->quota, u, 0, Hpt::HPT_U | Hpt::HPT_W | Hpt::HPT_P, Buddy::ptr_to_phys (utcb));

        regs.dst_portal = NUM_EXC - 2;
c0002fd8:	c7 83 88 00 00 00 1e 	movl   $0x1e,0x88(%ebx)
c0002fdf:	00 00 00 

        trace (TRACE_SYSCALL, "EC:%p created (PD:%p CPU:%#x UTCB:%#lx ESP:%lx EVT:%#x)", this, p, c, u, s, e);

        if (pd == &Pd::root)
c0002fe2:	0f 85 9a 03 00 00    	jne    c0003382 <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x5aa>
c0002fe8:	8b 83 b4 00 00 00    	mov    0xb4(%ebx),%eax
            pd->insert_utcb (pd->quota, u, Buddy::ptr_to_phys(utcb) >> 12);
c0002fee:	89 e9                	mov    %ebp,%ecx
c0002ff0:	ba 90 b2 01 c0       	mov    $0xc001b290,%edx
c0002ff5:	2d 00 00 c0 bf       	sub    $0xbfc00000,%eax
c0002ffa:	c1 e8 0c             	shr    $0xc,%eax
c0002ffd:	50                   	push   %eax
c0002ffe:	b8 4c b1 01 c0       	mov    $0xc001b14c,%eax
c0003003:	e8 0c de 00 00       	call   c0010e14 <_ZN9Space_mem11insert_utcbER5Quotamm>
c0003008:	59                   	pop    %ecx
c0003009:	e9 74 03 00 00       	jmp    c0003382 <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x5aa>
        void flush (bool);

        static Reason miss (Exc_regs *, mword, mword &);

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return Buddy::allocator.alloc (0, quota, Buddy::NOFILL); }
c000300e:	6a 00                	push   $0x0
c0003010:	31 d2                	xor    %edx,%edx
    } else {

        utcb = nullptr;

        regs.dst_portal = NUM_VMI - 2;
        regs.vtlb = new (pd->quota) Vtlb;
c0003012:	81 c1 90 01 00 00    	add    $0x190,%ecx
c0003018:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
        if (pd == &Pd::root)
            pd->insert_utcb (pd->quota, u, Buddy::ptr_to_phys(utcb) >> 12);

    } else {

        utcb = nullptr;
c000301d:	c7 83 b4 00 00 00 00 	movl   $0x0,0xb4(%ebx)
c0003024:	00 00 00 

        regs.dst_portal = NUM_VMI - 2;
c0003027:	c7 83 88 00 00 00 fe 	movl   $0xfe,0x88(%ebx)
c000302e:	00 00 00 
c0003031:	e8 d6 e3 ff ff       	call   c000140c <_ZN5Buddy5allocEtR5QuotaNS_4FillE>

        void free_up (Quota &quota, unsigned l, P *, mword, bool (*) (Paddr, mword, unsigned), bool (*) (unsigned, mword));

    public:

        Pte() : val(0) {}
c0003036:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c000303c:	5a                   	pop    %edx
        };

        ALWAYS_INLINE
        inline Vtlb()
        {
            for (unsigned i = 0; i < 1UL << bpl(); i++)
c000303d:	31 d2                	xor    %edx,%edx
c000303f:	89 d6                	mov    %edx,%esi
c0003041:	c1 ee 0a             	shr    $0xa,%esi
c0003044:	75 0a                	jne    c0003050 <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x278>
                this[i].val = TLB_S;
c0003046:	c7 04 90 80 00 00 00 	movl   $0x80,(%eax,%edx,4)
        };

        ALWAYS_INLINE
        inline Vtlb()
        {
            for (unsigned i = 0; i < 1UL << bpl(); i++)
c000304d:	42                   	inc    %edx
c000304e:	eb ef                	jmp    c000303f <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x267>
        regs.vtlb = new (pd->quota) Vtlb;
c0003050:	89 43 78             	mov    %eax,0x78(%ebx)
            return reinterpret_cast<Hip *>(&PAGE_H);
        }

        static uint32 feature()
        {
            return hip()->api_flg;
c0003053:	a1 10 e0 01 c0       	mov    0xc001e010,%eax

        if (Hip::feature() & Hip::FEAT_VMX) {
c0003058:	a8 02                	test   $0x2,%al
c000305a:	0f 84 8c 02 00 00    	je     c00032ec <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x514>
c0003060:	8b 83 b8 00 00 00    	mov    0xb8(%ebx),%eax

            regs.vmcs = new (pd->quota) Vmcs (reinterpret_cast<mword>(sys_regs() + 1),
                                              pd->Space_pio::walk(pd->quota),
                                              pd->loc[c].root(pd->quota),
                                              pd->ept.root(pd->quota));
c0003066:	31 c9                	xor    %ecx,%ecx
c0003068:	6a 00                	push   $0x0
        regs.vtlb = new (pd->quota) Vtlb;

        if (Hip::feature() & Hip::FEAT_VMX) {

            regs.vmcs = new (pd->quota) Vmcs (reinterpret_cast<mword>(sys_regs() + 1),
                                              pd->Space_pio::walk(pd->quota),
c000306a:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx
c0003070:	05 78 01 00 00       	add    $0x178,%eax
                                              pd->loc[c].root(pd->quota),
                                              pd->ept.root(pd->quota));
c0003075:	e8 fa e0 00 00       	call   c0011174 <_ZN9Space_pio4walkER5Quotabm>

        ALWAYS_INLINE
        static inline unsigned max() { return L; }

        ALWAYS_INLINE
        inline E root (Quota &quota, mword l = L - 1) { return Buddy::ptr_to_phys (walk (quota, 0, l)); }
c000307a:	31 c9                	xor    %ecx,%ecx
c000307c:	89 44 24 04          	mov    %eax,0x4(%esp)
c0003080:	8b 83 b8 00 00 00    	mov    0xb8(%ebx),%eax
c0003086:	6a 01                	push   $0x1
c0003088:	6a 01                	push   $0x1

        if (Hip::feature() & Hip::FEAT_VMX) {

            regs.vmcs = new (pd->quota) Vmcs (reinterpret_cast<mword>(sys_regs() + 1),
                                              pd->Space_pio::walk(pd->quota),
                                              pd->loc[c].root(pd->quota),
c000308a:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx
c0003090:	8d 44 b8 54          	lea    0x54(%eax,%edi,4),%eax
c0003094:	e8 23 ae 00 00       	call   c000debc <_ZN3PteI3HptmLj2ELj10ELb0EE4walkER5Quotammb>
c0003099:	2d 00 00 c0 bf       	sub    $0xbfc00000,%eax
c000309e:	89 44 24 10          	mov    %eax,0x10(%esp)
c00030a2:	8b 83 b8 00 00 00    	mov    0xb8(%ebx),%eax
c00030a8:	6a 01                	push   $0x1
c00030aa:	6a 03                	push   $0x3
c00030ac:	6a 00                	push   $0x0
c00030ae:	6a 00                	push   $0x0
                                              pd->ept.root(pd->quota));
c00030b0:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx
c00030b6:	05 60 01 00 00       	add    $0x160,%eax
c00030bb:	e8 4a ab 00 00       	call   c000dc0a <_ZN3PteI3EptyLj4ELj9ELb0EE4walkER5Quotaymb>
        };

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota)
        {
            return Buddy::allocator.alloc (0, quota, Buddy::FILL_0);
c00030c0:	31 d2                	xor    %edx,%edx
c00030c2:	6a 01                	push   $0x1
c00030c4:	89 c7                	mov    %eax,%edi
c00030c6:	8b 83 b8 00 00 00    	mov    0xb8(%ebx),%eax
c00030cc:	81 ef 00 00 c0 bf    	sub    $0xbfc00000,%edi
c00030d2:	89 fe                	mov    %edi,%esi
c00030d4:	31 ff                	xor    %edi,%edi
c00030d6:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c00030dc:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c00030e1:	e8 26 e3 ff ff       	call   c000140c <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
c00030e6:	83 c4 20             	add    $0x20,%esp
c00030e9:	57                   	push   %edi
c00030ea:	56                   	push   %esi
c00030eb:	ff 74 24 0c          	pushl  0xc(%esp)
        regs.dst_portal = NUM_VMI - 2;
        regs.vtlb = new (pd->quota) Vtlb;

        if (Hip::feature() & Hip::FEAT_VMX) {

            regs.vmcs = new (pd->quota) Vmcs (reinterpret_cast<mword>(sys_regs() + 1),
c00030ef:	8d 53 74             	lea    0x74(%ebx),%edx
                                              pd->Space_pio::walk(pd->quota),
                                              pd->loc[c].root(pd->quota),
                                              pd->ept.root(pd->quota));
c00030f2:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c00030f6:	89 c5                	mov    %eax,%ebp
c00030f8:	e8 23 26 01 00       	call   c0015720 <_ZN4VmcsC1Emmmy>
        }

        static bool has_secondary() { return ctrl_cpu[0].clr & CPU_SECONDARY; }
        static bool has_ept()       { return ctrl_cpu[1].clr & CPU_EPT; }
        static bool has_vpid()      { return ctrl_cpu[1].clr & CPU_VPID; }
        static bool has_urg()       { return ctrl_cpu[1].clr & CPU_URG; }
c00030fd:	8b 15 54 fb ff cf    	mov    0xcffffb54,%edx

            regs.nst_ctrl<Vmcs>();
c0003103:	8d 43 54             	lea    0x54(%ebx),%eax
        if (Hip::feature() & Hip::FEAT_VMX) {

            regs.vmcs = new (pd->quota) Vmcs (reinterpret_cast<mword>(sys_regs() + 1),
                                              pd->Space_pio::walk(pd->quota),
                                              pd->loc[c].root(pd->quota),
                                              pd->ept.root(pd->quota));
c0003106:	89 6b 74             	mov    %ebp,0x74(%ebx)
c0003109:	c1 ea 07             	shr    $0x7,%edx
c000310c:	83 e2 01             	and    $0x1,%edx

            regs.nst_ctrl<Vmcs>();
c000310f:	e8 2e b7 00 00       	call   c000e842 <_ZN8Exc_regs8nst_ctrlI4VmcsEEvb>

            /* allocate and register the host MSR area */
            mword host_msr_area_phys = Buddy::ptr_to_phys(new (pd->quota) Msr_area);
c0003114:	8b 83 b8 00 00 00    	mov    0xb8(%ebx),%eax

    ALWAYS_INLINE
    static inline void *operator new (size_t, Quota &quota)
    {
        /* allocate one page */
        return Buddy::allocator.alloc (0, quota, Buddy::FILL_0);
c000311a:	31 d2                	xor    %edx,%edx
c000311c:	6a 01                	push   $0x1
c000311e:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c0003124:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c0003129:	e8 de e2 ff ff       	call   c000140c <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
c000312e:	ba 08 20 00 00       	mov    $0x2008,%edx
    uint32 msr_index;
    uint32 reserved;
    uint64 msr_data;

    Msr_entry(uint32 index)
    : msr_index(index), reserved(0), msr_data(0) { }
c0003133:	c7 00 81 00 00 c0    	movl   $0xc0000081,(%eax)
c0003139:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
c0003140:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
c0003147:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
c000314e:	c7 40 10 82 00 00 c0 	movl   $0xc0000082,0x10(%eax)
c0003155:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
c000315c:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
c0003163:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
c000316a:	c7 40 20 84 00 00 c0 	movl   $0xc0000084,0x20(%eax)
c0003171:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
c0003178:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
c000317f:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
c0003186:	c7 40 30 02 01 00 c0 	movl   $0xc0000102,0x30(%eax)
c000318d:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
c0003194:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
c000319b:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
c00031a2:	2d 00 00 c0 bf       	sub    $0xbfc00000,%eax
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
c00031a7:	0f 79 d0             	vmwrite %eax,%edx
c00031aa:	be 04 00 00 00       	mov    $0x4,%esi
c00031af:	b8 10 40 00 00       	mov    $0x4010,%eax
c00031b4:	0f 79 c6             	vmwrite %esi,%eax
            Vmcs::write(Vmcs::EXI_MSR_LD_ADDR, host_msr_area_phys);
            Vmcs::write(Vmcs::EXI_MSR_LD_CNT, Msr_area::MSR_COUNT);

            /* allocate and register the guest MSR area */
            mword guest_msr_area_phys = Buddy::ptr_to_phys(new (pd->quota) Msr_area);
c00031b7:	8b 83 b8 00 00 00    	mov    0xb8(%ebx),%eax

    ALWAYS_INLINE
    static inline void *operator new (size_t, Quota &quota)
    {
        /* allocate one page */
        return Buddy::allocator.alloc (0, quota, Buddy::FILL_0);
c00031bd:	66 31 d2             	xor    %dx,%dx
c00031c0:	6a 01                	push   $0x1
c00031c2:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c00031c8:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c00031cd:	e8 3a e2 ff ff       	call   c000140c <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
c00031d2:	ba 0a 20 00 00       	mov    $0x200a,%edx
    uint32 msr_index;
    uint32 reserved;
    uint64 msr_data;

    Msr_entry(uint32 index)
    : msr_index(index), reserved(0), msr_data(0) { }
c00031d7:	c7 00 81 00 00 c0    	movl   $0xc0000081,(%eax)
c00031dd:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
c00031e4:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
c00031eb:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
c00031f2:	c7 40 10 82 00 00 c0 	movl   $0xc0000082,0x10(%eax)
c00031f9:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
c0003200:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
c0003207:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
c000320e:	c7 40 20 84 00 00 c0 	movl   $0xc0000084,0x20(%eax)
c0003215:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
c000321c:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
c0003223:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
c000322a:	c7 40 30 02 01 00 c0 	movl   $0xc0000102,0x30(%eax)
c0003231:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
c0003238:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
c000323f:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
c0003246:	2d 00 00 c0 bf       	sub    $0xbfc00000,%eax
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
c000324b:	0f 79 d0             	vmwrite %eax,%edx
c000324e:	66 ba 14 40          	mov    $0x4014,%dx
c0003252:	0f 79 d6             	vmwrite %esi,%edx
c0003255:	66 ba 06 20          	mov    $0x2006,%dx
c0003259:	0f 79 d0             	vmwrite %eax,%edx
c000325c:	b8 0e 40 00 00       	mov    $0x400e,%eax
c0003261:	0f 79 c6             	vmwrite %esi,%eax
            Vmcs::write(Vmcs::ENT_MSR_LD_CNT, Msr_area::MSR_COUNT);
            Vmcs::write(Vmcs::EXI_MSR_ST_ADDR, guest_msr_area_phys);
            Vmcs::write(Vmcs::EXI_MSR_ST_CNT, Msr_area::MSR_COUNT);

            /* allocate and register the virtual APIC page */
            mword virtual_apic_page_phys = Buddy::ptr_to_phys(new (pd->quota) Virtual_apic_page);
c0003264:	8b 83 b8 00 00 00    	mov    0xb8(%ebx),%eax

    ALWAYS_INLINE
    static inline void *operator new (size_t, Quota &quota)
    {
        /* allocate one page */
        return Buddy::allocator.alloc (0, quota, Buddy::FILL_0);
c000326a:	66 31 d2             	xor    %dx,%dx
c000326d:	6a 01                	push   $0x1
c000326f:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c0003275:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c000327a:	e8 8d e1 ff ff       	call   c000140c <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
c000327f:	ba 12 20 00 00       	mov    $0x2012,%edx
c0003284:	2d 00 00 c0 bf       	sub    $0xbfc00000,%eax
c0003289:	0f 79 d0             	vmwrite %eax,%edx
            Vmcs::write(Vmcs::APIC_VIRT_ADDR, virtual_apic_page_phys);

            regs.vmcs->clear();
c000328c:	8b 43 74             	mov    0x74(%ebx),%eax
        }

        ALWAYS_INLINE
        inline void clear()
        {
            if (EXPECT_TRUE (current == this))
c000328f:	83 c4 18             	add    $0x18,%esp
c0003292:	39 05 14 f0 ff cf    	cmp    %eax,0xcffff014
c0003298:	75 0a                	jne    c00032a4 <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x4cc>
                current = nullptr;
c000329a:	c7 05 14 f0 ff cf 00 	movl   $0x0,0xcffff014
c00032a1:	00 00 00 
c00032a4:	2d 00 00 c0 bf       	sub    $0xbfc00000,%eax

            uint64 phys = Buddy::ptr_to_phys (this);
c00032a9:	89 44 24 08          	mov    %eax,0x8(%esp)
c00032ad:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c00032b4:	00 

            bool ret;
            asm volatile ("vmclear %1; seta %0" : "=q" (ret) : "m" (phys) : "cc");
c00032b5:	66 0f c7 74 24 08    	vmclear 0x8(%esp)
c00032bb:	0f 97 c0             	seta   %al
            assert (ret);
c00032be:	84 c0                	test   %al,%al
c00032c0:	75 1e                	jne    c00032e0 <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x508>
c00032c2:	68 e0 6d 01 c0       	push   $0xc0016de0
c00032c7:	68 89 01 00 00       	push   $0x189
c00032cc:	68 13 69 01 c0       	push   $0xc0016913
c00032d1:	68 83 69 01 c0       	push   $0xc0016983
c00032d6:	68 69 60 01 c0       	push   $0xc0016069
c00032db:	e8 66 e6 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>
            cont = send_msg<ret_user_vmresume>;
c00032e0:	c7 43 50 9c 19 01 c0 	movl   $0xc001199c,0x50(%ebx)
c00032e7:	e9 96 00 00 00       	jmp    c0003382 <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x5aa>
            trace (TRACE_SYSCALL, "EC:%p created (PD:%p VMCS:%p VTLB:%p)", this, p, regs.vmcs, regs.vtlb);

        } else if (Hip::feature() & Hip::FEAT_SVM) {
c00032ec:	a8 04                	test   $0x4,%al
c00032ee:	0f 84 8e 00 00 00    	je     c0003382 <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x5aa>
c00032f4:	8b 83 b8 00 00 00    	mov    0xb8(%ebx),%eax

            regs.REG(ax) = Buddy::ptr_to_phys (regs.vmcb = new (pd->quota) Vmcb (pd->quota, pd->Space_pio::walk(pd->quota), pd->npt.root(pd->quota)));
c00032fa:	31 c9                	xor    %ecx,%ecx
c00032fc:	6a 00                	push   $0x0
c00032fe:	8d a8 90 01 00 00    	lea    0x190(%eax),%ebp
c0003304:	05 78 01 00 00       	add    $0x178,%eax
c0003309:	89 ea                	mov    %ebp,%edx
c000330b:	e8 64 de 00 00       	call   c0011174 <_ZN9Space_pio4walkER5Quotabm>
c0003310:	31 c9                	xor    %ecx,%ecx
c0003312:	89 44 24 04          	mov    %eax,0x4(%esp)
c0003316:	8b 83 b8 00 00 00    	mov    0xb8(%ebx),%eax
c000331c:	6a 01                	push   $0x1
c000331e:	6a 01                	push   $0x1
c0003320:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx
c0003326:	05 60 01 00 00       	add    $0x160,%eax
c000332b:	e8 8c ab 00 00       	call   c000debc <_ZN3PteI3HptmLj2ELj10ELb0EE4walkER5Quotammb>
                                            CPU_SKINIT;

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota)
        {
            return Buddy::allocator.alloc (0, quota, Buddy::FILL_0);
c0003330:	31 d2                	xor    %edx,%edx
c0003332:	6a 01                	push   $0x1
c0003334:	2d 00 00 c0 bf       	sub    $0xbfc00000,%eax
c0003339:	89 c7                	mov    %eax,%edi
c000333b:	8b 83 b8 00 00 00    	mov    0xb8(%ebx),%eax
c0003341:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c0003347:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c000334c:	e8 bb e0 ff ff       	call   c000140c <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
c0003351:	89 ea                	mov    %ebp,%edx
c0003353:	57                   	push   %edi
c0003354:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c0003358:	89 c6                	mov    %eax,%esi
c000335a:	e8 77 e0 00 00       	call   c00113d6 <_ZN4VmcbC1ER5Quotamm>

            regs.nst_ctrl<Vmcb>();
c000335f:	8d 43 54             	lea    0x54(%ebx),%eax
c0003362:	ba 01 00 00 00       	mov    $0x1,%edx
            cont = send_msg<ret_user_vmresume>;
            trace (TRACE_SYSCALL, "EC:%p created (PD:%p VMCS:%p VTLB:%p)", this, p, regs.vmcs, regs.vtlb);

        } else if (Hip::feature() & Hip::FEAT_SVM) {

            regs.REG(ax) = Buddy::ptr_to_phys (regs.vmcb = new (pd->quota) Vmcb (pd->quota, pd->Space_pio::walk(pd->quota), pd->npt.root(pd->quota)));
c0003367:	89 73 74             	mov    %esi,0x74(%ebx)
c000336a:	81 ee 00 00 c0 bf    	sub    $0xbfc00000,%esi
c0003370:	89 73 70             	mov    %esi,0x70(%ebx)

            regs.nst_ctrl<Vmcb>();
c0003373:	e8 0e b3 00 00       	call   c000e686 <_ZN8Exc_regs8nst_ctrlI4VmcbEEvb>
c0003378:	83 c4 14             	add    $0x14,%esp
            cont = send_msg<ret_user_vmrun>;
c000337b:	c7 43 50 c4 1b 01 c0 	movl   $0xc0011bc4,0x50(%ebx)
            trace (TRACE_SYSCALL, "EC:%p created (PD:%p VMCB:%p VTLB:%p)", this, p, regs.vmcb, regs.vtlb);
        }
    }
}
c0003382:	83 c4 10             	add    $0x10,%esp
c0003385:	5b                   	pop    %ebx
c0003386:	5e                   	pop    %esi
c0003387:	5f                   	pop    %edi
c0003388:	5d                   	pop    %ebp
c0003389:	c3                   	ret    

c000338a <_ZN2EcC1EP2PdS1_PFvvEjPS_>:

Ec::Ec (Pd *own, Pd *p, void (*f)(), unsigned c, Ec *clone) : Kobject (EC, static_cast<Space_obj *>(own), 0, 0xd, free, pre_free), cont (f), regs (clone->regs), rcap (clone), utcb (clone->utcb), pd (p), partner (nullptr), prev (nullptr), next (nullptr), fpu (clone->fpu), cpu (static_cast<uint16>(c)), glb (!!f), evt (clone->evt), timeout (this), user_utcb (0), xcpu_sm (clone->xcpu_sm), pt_oom(clone->pt_oom)
c000338a:	55                   	push   %ebp
c000338b:	85 d2                	test   %edx,%edx
c000338d:	57                   	push   %edi
c000338e:	56                   	push   %esi
c000338f:	53                   	push   %ebx
c0003390:	53                   	push   %ebx
c0003391:	89 c3                	mov    %eax,%ebx
c0003393:	8b 6c 24 20          	mov    0x20(%esp),%ebp
c0003397:	8d 82 88 01 00 00    	lea    0x188(%edx),%eax
c000339d:	ba 00 00 00 00       	mov    $0x0,%edx
c00033a2:	89 0c 24             	mov    %ecx,(%esp)
c00033a5:	0f 45 d0             	cmovne %eax,%edx
c00033a8:	89 d9                	mov    %ebx,%ecx
c00033aa:	68 f3 28 00 c0       	push   $0xc00028f3
c00033af:	89 d8                	mov    %ebx,%eax
c00033b1:	68 9d 37 00 c0       	push   $0xc000379d
c00033b6:	6a 0d                	push   $0xd
c00033b8:	6a 00                	push   $0x0
c00033ba:	e8 87 f8 ff ff       	call   c0002c46 <_ZN3MdbC1EP5SpacemmmPFvP8Rcu_elemES5_>
c00033bf:	8b 44 24 28          	mov    0x28(%esp),%eax
c00033c3:	8d 7b 54             	lea    0x54(%ebx),%edi
c00033c6:	c6 43 44 01          	movb   $0x1,0x44(%ebx)
c00033ca:	8d 75 54             	lea    0x54(%ebp),%esi
c00033cd:	b9 17 00 00 00       	mov    $0x17,%ecx
c00033d2:	66 c7 43 46 00 00    	movw   $0x0,0x46(%ebx)
c00033d8:	83 c4 10             	add    $0x10,%esp
    private:
        uint32 ref;

    public:
        ALWAYS_INLINE
        inline Refex() : ref (1) {}
c00033db:	c7 43 48 01 00 00 00 	movl   $0x1,0x48(%ebx)
c00033e2:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
c00033e9:	89 43 50             	mov    %eax,0x50(%ebx)
c00033ec:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
c00033ee:	89 ab b0 00 00 00    	mov    %ebp,0xb0(%ebx)
c00033f4:	8b 85 b4 00 00 00    	mov    0xb4(%ebp),%eax
c00033fa:	89 83 b4 00 00 00    	mov    %eax,0xb4(%ebx)

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0003400:	8b 04 24             	mov    (%esp),%eax
c0003403:	8b 40 48             	mov    0x48(%eax),%eax
c0003406:	85 c0                	test   %eax,%eax
c0003408:	74 10                	je     c000341a <_ZN2EcC1EP2PdS1_PFvvEjPS_+0x90>
c000340a:	8b 34 24             	mov    (%esp),%esi
                if (Atomic::cmp_swap (ref, r, r + 1))
c000340d:	8d 50 01             	lea    0x1(%eax),%edx
c0003410:	f0 0f b1 56 48       	lock cmpxchg %edx,0x48(%esi)
c0003415:	75 e9                	jne    c0003400 <_ZN2EcC1EP2PdS1_PFvvEjPS_+0x76>
c0003417:	8b 04 24             	mov    (%esp),%eax
    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }

        ALWAYS_INLINE
        inline Refptr (T *p) : ptr (p->add_ref() ? p : nullptr) {}
c000341a:	89 83 b8 00 00 00    	mov    %eax,0xb8(%ebx)
c0003420:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
c0003424:	c7 83 bc 00 00 00 00 	movl   $0x0,0xbc(%ebx)
c000342b:	00 00 00 
{
    // Make sure we have a PTAB for this CPU in the PD
    pd->Space_mem::init (pd->quota, c);
c000342e:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
            trace (TRACE_SYSCALL, "EC:%p created (PD:%p VMCB:%p VTLB:%p)", this, p, regs.vmcb, regs.vtlb);
        }
    }
}

Ec::Ec (Pd *own, Pd *p, void (*f)(), unsigned c, Ec *clone) : Kobject (EC, static_cast<Space_obj *>(own), 0, 0xd, free, pre_free), cont (f), regs (clone->regs), rcap (clone), utcb (clone->utcb), pd (p), partner (nullptr), prev (nullptr), next (nullptr), fpu (clone->fpu), cpu (static_cast<uint16>(c)), glb (!!f), evt (clone->evt), timeout (this), user_utcb (0), xcpu_sm (clone->xcpu_sm), pt_oom(clone->pt_oom)
c0003432:	c7 83 c0 00 00 00 00 	movl   $0x0,0xc0(%ebx)
c0003439:	00 00 00 
c000343c:	c7 83 c4 00 00 00 00 	movl   $0x0,0xc4(%ebx)
c0003443:	00 00 00 
c0003446:	8b 95 c8 00 00 00    	mov    0xc8(%ebp),%edx
c000344c:	66 89 bb cc 00 00 00 	mov    %di,0xcc(%ebx)
c0003453:	89 93 c8 00 00 00    	mov    %edx,0xc8(%ebx)
c0003459:	31 d2                	xor    %edx,%edx
c000345b:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
c0003460:	0f 95 c2             	setne  %dl
c0003463:	66 89 93 ce 00 00 00 	mov    %dx,0xce(%ebx)
c000346a:	8b 95 d0 00 00 00    	mov    0xd0(%ebp),%edx
c0003470:	c7 83 d8 00 00 00 00 	movl   $0x0,0xd8(%ebx)
c0003477:	00 00 00 
c000347a:	c7 83 dc 00 00 00 00 	movl   $0x0,0xdc(%ebx)
c0003481:	00 00 00 
c0003484:	c7 83 e0 00 00 00 00 	movl   $0x0,0xe0(%ebx)
c000348b:	00 00 00 
c000348e:	89 93 d0 00 00 00    	mov    %edx,0xd0(%ebx)
c0003494:	c7 83 e4 00 00 00 00 	movl   $0x0,0xe4(%ebx)
c000349b:	00 00 00 
c000349e:	c7 83 d4 00 00 00 d0 	movl   $0xc0019ed0,0xd4(%ebx)
c00034a5:	9e 01 c0 
c00034a8:	89 9b e8 00 00 00    	mov    %ebx,0xe8(%ebx)
c00034ae:	c7 83 f0 00 00 00 00 	movl   $0x0,0xf0(%ebx)
c00034b5:	00 00 00 
c00034b8:	8b 95 f4 00 00 00    	mov    0xf4(%ebp),%edx
c00034be:	89 93 f4 00 00 00    	mov    %edx,0xf4(%ebx)
c00034c4:	8b 95 f8 00 00 00    	mov    0xf8(%ebp),%edx
c00034ca:	89 93 f8 00 00 00    	mov    %edx,0xf8(%ebx)
{
    // Make sure we have a PTAB for this CPU in the PD
    pd->Space_mem::init (pd->quota, c);
c00034d0:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx
c00034d6:	83 c0 4c             	add    $0x4c,%eax
c00034d9:	e8 e4 d2 00 00       	call   c00107c2 <_ZN9Space_mem4initER5Quotaj>

    regs.vtlb = nullptr;
    regs.vmcs = nullptr;
    regs.vmcb = nullptr;

    if (pt_oom)
c00034de:	8b 93 f8 00 00 00    	mov    0xf8(%ebx),%edx
Ec::Ec (Pd *own, Pd *p, void (*f)(), unsigned c, Ec *clone) : Kobject (EC, static_cast<Space_obj *>(own), 0, 0xd, free, pre_free), cont (f), regs (clone->regs), rcap (clone), utcb (clone->utcb), pd (p), partner (nullptr), prev (nullptr), next (nullptr), fpu (clone->fpu), cpu (static_cast<uint16>(c)), glb (!!f), evt (clone->evt), timeout (this), user_utcb (0), xcpu_sm (clone->xcpu_sm), pt_oom(clone->pt_oom)
{
    // Make sure we have a PTAB for this CPU in the PD
    pd->Space_mem::init (pd->quota, c);

    regs.vtlb = nullptr;
c00034e4:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)
    regs.vmcs = nullptr;
c00034eb:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
    regs.vmcb = nullptr;

    if (pt_oom)
c00034f2:	85 d2                	test   %edx,%edx

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
                if (Atomic::cmp_swap (ref, r, r + 1))
c00034f4:	74 11                	je     c0003507 <_ZN2EcC1EP2PdS1_PFvvEjPS_+0x17d>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c00034f6:	8b 42 48             	mov    0x48(%edx),%eax
c00034f9:	85 c0                	test   %eax,%eax
c00034fb:	74 0a                	je     c0003507 <_ZN2EcC1EP2PdS1_PFvvEjPS_+0x17d>
                if (Atomic::cmp_swap (ref, r, r + 1))
c00034fd:	8d 48 01             	lea    0x1(%eax),%ecx
c0003500:	f0 0f b1 4a 48       	lock cmpxchg %ecx,0x48(%edx)
c0003505:	eb ed                	jmp    c00034f4 <_ZN2EcC1EP2PdS1_PFvvEjPS_+0x16a>
        pt_oom->add_ref();
}
c0003507:	58                   	pop    %eax
c0003508:	5b                   	pop    %ebx
c0003509:	5e                   	pop    %esi
c000350a:	5f                   	pop    %edi
c000350b:	5d                   	pop    %ebp
c000350c:	c3                   	ret    
c000350d:	90                   	nop

c000350e <_ZN2EcD1Ev>:

//De-constructor
Ec::~Ec()
c000350e:	57                   	push   %edi
c000350f:	56                   	push   %esi
c0003510:	53                   	push   %ebx
c0003511:	89 c3                	mov    %eax,%ebx
c0003513:	83 ec 08             	sub    $0x8,%esp
{
    pre_free(this);
c0003516:	8d 40 0c             	lea    0xc(%eax),%eax
c0003519:	e8 d5 f3 ff ff       	call   c00028f3 <_ZN2Ec8pre_freeEP8Rcu_elem>

    if (pt_oom && pt_oom->del_ref())
c000351e:	8b 83 f8 00 00 00    	mov    0xf8(%ebx),%eax
c0003524:	85 c0                	test   %eax,%eax
c0003526:	74 41                	je     c0003569 <_ZN2EcD1Ev+0x5b>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c0003528:	83 ca ff             	or     $0xffffffff,%edx
c000352b:	f0 0f c1 50 48       	lock xadd %edx,0x48(%eax)
c0003530:	4a                   	dec    %edx
c0003531:	75 36                	jne    c0003569 <_ZN2EcD1Ev+0x5b>
        Pt::destroy(pt_oom, pd->quota);
c0003533:	8b 83 b8 00 00 00    	mov    0xb8(%ebx),%eax
c0003539:	8b b3 f8 00 00 00    	mov    0xf8(%ebx),%esi
c000353f:	8d b8 90 01 00 00    	lea    0x190(%eax),%edi
        inline Refptr (T *p) : ptr (p->add_ref() ? p : nullptr) {}

        ALWAYS_INLINE
        inline ~Refptr()
        {
            if (ptr && ptr->del_ref())
c0003545:	8b 46 4c             	mov    0x4c(%esi),%eax
c0003548:	85 c0                	test   %eax,%eax
c000354a:	74 0f                	je     c000355b <_ZN2EcD1Ev+0x4d>
c000354c:	83 ca ff             	or     $0xffffffff,%edx
c000354f:	f0 0f c1 50 48       	lock xadd %edx,0x48(%eax)
c0003554:	4a                   	dec    %edx
c0003555:	0f 84 c7 01 00 00    	je     c0003722 <_ZN2EcD1Ev+0x214>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void destroy(Pt *obj, Quota &quota) { obj->~Pt(); cache.free (obj, quota); }
c000355b:	89 f9                	mov    %edi,%ecx
c000355d:	89 f2                	mov    %esi,%edx
c000355f:	b8 7c b4 01 c0       	mov    $0xc001b47c,%eax
c0003564:	e8 f7 cd 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>

    if (fpu)
c0003569:	8b 93 c8 00 00 00    	mov    0xc8(%ebx),%edx
c000356f:	85 d2                	test   %edx,%edx
c0003571:	74 16                	je     c0003589 <_ZN2EcD1Ev+0x7b>
        Fpu::destroy(fpu, pd->quota);
c0003573:	8b 83 b8 00 00 00    	mov    0xb8(%ebx),%eax
c0003579:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void destroy(Fpu *obj, Quota &quota) { obj->~Fpu(); cache.free (obj, quota); }
c000357f:	b8 84 a4 01 c0       	mov    $0xc001a484,%eax
c0003584:	e8 d7 cd 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>

    if (utcb) {
c0003589:	8b 93 b4 00 00 00    	mov    0xb4(%ebx),%edx
c000358f:	8b 8b b8 00 00 00    	mov    0xb8(%ebx),%ecx
c0003595:	85 d2                	test   %edx,%edx
c0003597:	74 0b                	je     c00035a4 <_ZN2EcD1Ev+0x96>
        Utcb::destroy(utcb, pd->quota);
c0003599:	81 c1 90 01 00 00    	add    $0x190,%ecx
c000359f:	e9 59 01 00 00       	jmp    c00036fd <_ZN2EcD1Ev+0x1ef>
        return;
    }

    /* skip xCPU EC */
    if (!regs.vtlb)
c00035a4:	8b 53 78             	mov    0x78(%ebx),%edx
c00035a7:	85 d2                	test   %edx,%edx
c00035a9:	0f 84 58 01 00 00    	je     c0003707 <_ZN2EcD1Ev+0x1f9>
        return;

    /* vCPU cleanup */
    Vtlb::destroy(regs.vtlb, pd->quota);
c00035af:	81 c1 90 01 00 00    	add    $0x190,%ecx

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return Buddy::allocator.alloc (0, quota, Buddy::NOFILL); }

        ALWAYS_INLINE
        static inline void destroy(Vtlb *obj, Quota &quota) { obj->~Vtlb(); Buddy::allocator.free (reinterpret_cast<mword>(obj), quota); }
c00035b5:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c00035ba:	e8 a9 db ff ff       	call   c0001168 <_ZN5Buddy4freeEmR5Quota>
c00035bf:	a1 10 e0 01 c0       	mov    0xc001e010,%eax

    if (Hip::feature() & Hip::FEAT_VMX) {
c00035c4:	a8 02                	test   $0x2,%al
c00035c6:	0f 84 05 01 00 00    	je     c00036d1 <_ZN2EcD1Ev+0x1c3>

        regs.vmcs->make_current();
c00035cc:	8b 43 74             	mov    0x74(%ebx),%eax
        }

        ALWAYS_INLINE
        inline void make_current()
        {
            if (EXPECT_TRUE (current == this))
c00035cf:	39 05 14 f0 ff cf    	cmp    %eax,0xcffff014
c00035d5:	74 2f                	je     c0003606 <_ZN2EcD1Ev+0xf8>
                return;

            uint64 phys = Buddy::ptr_to_phys (current = this);
c00035d7:	a3 14 f0 ff cf       	mov    %eax,0xcffff014
c00035dc:	2d 00 00 c0 bf       	sub    $0xbfc00000,%eax
c00035e1:	89 04 24             	mov    %eax,(%esp)
c00035e4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c00035eb:	00 

            bool ret;
            asm volatile ("vmptrld %1; seta %0" : "=q" (ret) : "m" (phys) : "cc");
c00035ec:	0f c7 34 24          	vmptrld (%esp)
c00035f0:	0f 97 c0             	seta   %al
            assert (ret);
c00035f3:	84 c0                	test   %al,%al
c00035f5:	75 0f                	jne    c0003606 <_ZN2EcD1Ev+0xf8>
c00035f7:	68 c4 6d 01 c0       	push   $0xc0016dc4
c00035fc:	68 96 01 00 00       	push   $0x196
c0003601:	e9 a9 00 00 00       	jmp    c00036af <_ZN2EcD1Ev+0x1a1>

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
c0003606:	ba 08 20 00 00       	mov    $0x2008,%edx
c000360b:	0f 78 d2             	vmread %edx,%edx

        mword host_msr_area_phys = Vmcs::read(Vmcs::EXI_MSR_LD_ADDR);
        Msr_area *host_msr_area = reinterpret_cast<Msr_area*>(Buddy::phys_to_ptr(host_msr_area_phys));
        Msr_area::destroy(host_msr_area, pd->quota);
c000360e:	8b 83 b8 00 00 00    	mov    0xb8(%ebx),%eax
        }

        ALWAYS_INLINE
        inline mword phys_to_virt (mword phys)
        {
            return phys + reinterpret_cast<mword>(&OFFSET);
c0003614:	81 c2 00 00 c0 bf    	add    $0xbfc00000,%edx
c000361a:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
    }

    ALWAYS_INLINE
    static inline void destroy(Msr_area *obj, Quota &quota)
    {
        Buddy::allocator.free (reinterpret_cast<mword>(obj), quota);
c0003620:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c0003625:	e8 3e db ff ff       	call   c0001168 <_ZN5Buddy4freeEmR5Quota>

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
c000362a:	ba 06 20 00 00       	mov    $0x2006,%edx
c000362f:	0f 78 d2             	vmread %edx,%edx

        mword guest_msr_area_phys = Vmcs::read(Vmcs::EXI_MSR_ST_ADDR);
        Msr_area *guest_msr_area = reinterpret_cast<Msr_area*>(Buddy::phys_to_ptr(guest_msr_area_phys));
        Msr_area::destroy(guest_msr_area, pd->quota);
c0003632:	8b 83 b8 00 00 00    	mov    0xb8(%ebx),%eax
c0003638:	81 c2 00 00 c0 bf    	add    $0xbfc00000,%edx
c000363e:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
    }

    ALWAYS_INLINE
    static inline void destroy(Msr_area *obj, Quota &quota)
    {
        Buddy::allocator.free (reinterpret_cast<mword>(obj), quota);
c0003644:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c0003649:	e8 1a db ff ff       	call   c0001168 <_ZN5Buddy4freeEmR5Quota>

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
c000364e:	ba 12 20 00 00       	mov    $0x2012,%edx
c0003653:	0f 78 d2             	vmread %edx,%edx

        mword virtual_apic_page_phys = Vmcs::read(Vmcs::APIC_VIRT_ADDR);
        Virtual_apic_page *virtual_apic_page =
            reinterpret_cast<Virtual_apic_page*>(Buddy::phys_to_ptr(virtual_apic_page_phys));
        Virtual_apic_page::destroy(virtual_apic_page, pd->quota);
c0003656:	8b 83 b8 00 00 00    	mov    0xb8(%ebx),%eax
c000365c:	81 c2 00 00 c0 bf    	add    $0xbfc00000,%edx
c0003662:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
    }

    ALWAYS_INLINE
    static inline void destroy(Virtual_apic_page *obj, Quota &quota)
    {
        Buddy::allocator.free (reinterpret_cast<mword>(obj), quota);
c0003668:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c000366d:	e8 f6 da ff ff       	call   c0001168 <_ZN5Buddy4freeEmR5Quota>

        regs.vmcs->clear();
c0003672:	8b 53 74             	mov    0x74(%ebx),%edx
        }

        ALWAYS_INLINE
        inline void clear()
        {
            if (EXPECT_TRUE (current == this))
c0003675:	39 15 14 f0 ff cf    	cmp    %edx,0xcffff014
c000367b:	75 0a                	jne    c0003687 <_ZN2EcD1Ev+0x179>
                current = nullptr;
c000367d:	c7 05 14 f0 ff cf 00 	movl   $0x0,0xcffff014
c0003684:	00 00 00 
        }

        ALWAYS_INLINE
        inline mword virt_to_phys (mword virt)
        {
            return virt - reinterpret_cast<mword>(&OFFSET);
c0003687:	89 d0                	mov    %edx,%eax
c0003689:	2d 00 00 c0 bf       	sub    $0xbfc00000,%eax

            uint64 phys = Buddy::ptr_to_phys (this);
c000368e:	89 04 24             	mov    %eax,(%esp)
c0003691:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0003698:	00 

            bool ret;
            asm volatile ("vmclear %1; seta %0" : "=q" (ret) : "m" (phys) : "cc");
c0003699:	66 0f c7 34 24       	vmclear (%esp)
c000369e:	0f 97 c0             	seta   %al
            assert (ret);
c00036a1:	84 c0                	test   %al,%al
c00036a3:	75 1e                	jne    c00036c3 <_ZN2EcD1Ev+0x1b5>
c00036a5:	68 e0 6d 01 c0       	push   $0xc0016de0
c00036aa:	68 89 01 00 00       	push   $0x189
c00036af:	68 13 69 01 c0       	push   $0xc0016913
c00036b4:	68 83 69 01 c0       	push   $0xc0016983
c00036b9:	68 69 60 01 c0       	push   $0xc0016069
c00036be:	e8 83 e2 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

        Vmcs::destroy(regs.vmcs, pd->quota);
c00036c3:	8b 83 b8 00 00 00    	mov    0xb8(%ebx),%eax
c00036c9:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c00036cf:	eb 2c                	jmp    c00036fd <_ZN2EcD1Ev+0x1ef>
    } else if (Hip::feature() & Hip::FEAT_SVM)
c00036d1:	a8 04                	test   $0x4,%al
c00036d3:	74 32                	je     c0003707 <_ZN2EcD1Ev+0x1f9>
        Vmcb::destroy(regs.vmcb, pd->quota);
c00036d5:	8b 83 b8 00 00 00    	mov    0xb8(%ebx),%eax
c00036db:	8b 7b 74             	mov    0x74(%ebx),%edi
c00036de:	8d b0 90 01 00 00    	lea    0x190(%eax),%esi
        }

        ALWAYS_INLINE
        inline mword phys_to_virt (mword phys)
        {
            return phys + reinterpret_cast<mword>(&OFFSET);
c00036e4:	8b 47 48             	mov    0x48(%edi),%eax
        }

        ALWAYS_INLINE
        static inline void destroy(Vmcb *obj, Quota &quota)
        {
            Buddy::allocator.free (reinterpret_cast<mword>(Buddy::phys_to_ptr(static_cast<Paddr>(obj->base_msr))), quota);
c00036e7:	89 f1                	mov    %esi,%ecx
c00036e9:	8d 90 00 00 c0 bf    	lea    -0x40400000(%eax),%edx
c00036ef:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c00036f4:	e8 6f da ff ff       	call   c0001168 <_ZN5Buddy4freeEmR5Quota>
            obj->~Vmcb();
            Buddy::allocator.free (reinterpret_cast<mword>(obj), quota);
c00036f9:	89 f1                	mov    %esi,%ecx
c00036fb:	89 fa                	mov    %edi,%edx
c00036fd:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c0003702:	e8 61 da ff ff       	call   c0001168 <_ZN5Buddy4freeEmR5Quota>
c0003707:	8b 83 b8 00 00 00    	mov    0xb8(%ebx),%eax
c000370d:	85 c0                	test   %eax,%eax
c000370f:	0f 84 81 00 00 00    	je     c0003796 <_ZN2EcD1Ev+0x288>
c0003715:	83 cf ff             	or     $0xffffffff,%edi
c0003718:	f0 0f c1 78 48       	lock xadd %edi,0x48(%eax)
c000371d:	4f                   	dec    %edi
c000371e:	74 30                	je     c0003750 <_ZN2EcD1Ev+0x242>
c0003720:	eb 74                	jmp    c0003796 <_ZN2EcD1Ev+0x288>
                delete ptr;
c0003722:	8b 46 4c             	mov    0x4c(%esi),%eax
c0003725:	85 c0                	test   %eax,%eax
c0003727:	0f 84 2e fe ff ff    	je     c000355b <_ZN2EcD1Ev+0x4d>
c000372d:	e8 dc fd ff ff       	call   c000350e <_ZN2EcD1Ev>
c0003732:	8b 56 4c             	mov    0x4c(%esi),%edx

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c0003735:	8b 82 b8 00 00 00    	mov    0xb8(%edx),%eax
c000373b:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c0003741:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c0003746:	e8 15 cc 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
c000374b:	e9 0b fe ff ff       	jmp    c000355b <_ZN2EcD1Ev+0x4d>
c0003750:	8b 83 b8 00 00 00    	mov    0xb8(%ebx),%eax
c0003756:	85 c0                	test   %eax,%eax
c0003758:	74 3c                	je     c0003796 <_ZN2EcD1Ev+0x288>
c000375a:	e8 89 92 00 00       	call   c000c9e8 <_ZN2PdD1Ev>
c000375f:	8b b3 b8 00 00 00    	mov    0xb8(%ebx),%esi

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c0003765:	8b 56 28             	mov    0x28(%esi),%edx
c0003768:	85 d2                	test   %edx,%edx
c000376a:	8d 82 78 fe ff ff    	lea    -0x188(%edx),%eax
c0003770:	0f 45 f8             	cmovne %eax,%edi
c0003773:	89 fb                	mov    %edi,%ebx

            pd_del->quota.free_up(pd_to->quota);
c0003775:	81 c3 90 01 00 00    	add    $0x190,%ebx
c000377b:	8d 86 90 01 00 00    	lea    0x190(%esi),%eax
c0003781:	89 da                	mov    %ebx,%edx
c0003783:	e8 44 f2 ff ff       	call   c00029cc <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
c0003788:	89 d9                	mov    %ebx,%ecx
c000378a:	89 f2                	mov    %esi,%edx
c000378c:	b8 64 b4 01 c0       	mov    $0xc001b464,%eax
c0003791:	e8 ca cb 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
}
c0003796:	83 c4 08             	add    $0x8,%esp
c0003799:	5b                   	pop    %ebx
c000379a:	5e                   	pop    %esi
c000379b:	5f                   	pop    %edi
c000379c:	c3                   	ret    

c000379d <_ZN2Ec4freeEP8Rcu_elem>:
            }
        }

        static void free (Rcu_elem * a)
        {
            Ec * e = static_cast<Ec *>(a);
c000379d:	85 c0                	test   %eax,%eax
c000379f:	0f 84 96 00 00 00    	je     c000383b <_ZN2Ec4freeEP8Rcu_elem+0x9e>
                fpowner      = nullptr;
                Cpu::hazard |= HZD_FPU;
            }
        }

        static void free (Rcu_elem * a)
c00037a5:	56                   	push   %esi
c00037a6:	53                   	push   %ebx
c00037a7:	89 c3                	mov    %eax,%ebx
c00037a9:	52                   	push   %edx
        {
            Ec * e = static_cast<Ec *>(a);

            if (!e->utcb && !e->xcpu_sm) {
c00037aa:	83 b8 a8 00 00 00 00 	cmpl   $0x0,0xa8(%eax)
c00037b1:	75 32                	jne    c00037e5 <_ZN2Ec4freeEP8Rcu_elem+0x48>
c00037b3:	83 b8 e8 00 00 00 00 	cmpl   $0x0,0xe8(%eax)
c00037ba:	75 29                	jne    c00037e5 <_ZN2Ec4freeEP8Rcu_elem+0x48>
                trace(0, "leaking memory - vCPU EC memory re-usage not supported");
c00037bc:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c00037c0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c00037c5:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c00037ca:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00037cf:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c00037d6:	50                   	push   %eax
c00037d7:	68 87 69 01 c0       	push   $0xc0016987
c00037dc:	e8 fd e1 ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c00037e1:	5e                   	pop    %esi
c00037e2:	58                   	pop    %eax
c00037e3:	eb 5d                	jmp    c0003842 <_ZN2Ec4freeEP8Rcu_elem+0xa5>
c00037e5:	83 c8 ff             	or     $0xffffffff,%eax
c00037e8:	f0 0f c1 43 3c       	lock xadd %eax,0x3c(%ebx)
                return;
            }

            if (e->del_ref()) {
c00037ed:	48                   	dec    %eax
c00037ee:	75 52                	jne    c0003842 <_ZN2Ec4freeEP8Rcu_elem+0xa5>
            }
        }

        static void free (Rcu_elem * a)
        {
            Ec * e = static_cast<Ec *>(a);
c00037f0:	8d 73 f4             	lea    -0xc(%ebx),%esi
                trace(0, "leaking memory - vCPU EC memory re-usage not supported");
                return;
            }

            if (e->del_ref()) {
                assert(e != Ec::current);
c00037f3:	3b 35 08 f0 ff cf    	cmp    0xcffff008,%esi
c00037f9:	75 1e                	jne    c0003819 <_ZN2Ec4freeEP8Rcu_elem+0x7c>
c00037fb:	68 00 6e 01 c0       	push   $0xc0016e00
c0003800:	68 9a 00 00 00       	push   $0x9a
c0003805:	68 83 68 01 c0       	push   $0xc0016883
c000380a:	68 c5 69 01 c0       	push   $0xc00169c5
c000380f:	68 69 60 01 c0       	push   $0xc0016069
c0003814:	e8 2d e1 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>
                delete e;
c0003819:	89 f0                	mov    %esi,%eax
c000381b:	e8 ee fc ff ff       	call   c000350e <_ZN2EcD1Ev>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c0003820:	8b 8b ac 00 00 00    	mov    0xac(%ebx),%ecx
c0003826:	89 f2                	mov    %esi,%edx

            if (e->del_ref()) {
                assert(e != Ec::current);
                delete e;
            }
        }
c0003828:	5b                   	pop    %ebx

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c0003829:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax

            if (e->del_ref()) {
                assert(e != Ec::current);
                delete e;
            }
        }
c000382e:	5b                   	pop    %ebx

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c000382f:	81 c1 90 01 00 00    	add    $0x190,%ecx

            if (e->del_ref()) {
                assert(e != Ec::current);
                delete e;
            }
        }
c0003835:	5e                   	pop    %esi

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c0003836:	e9 25 cb 00 00       	jmp    c0010360 <_ZN10Slab_cache4freeEPvR5Quota>

        static void free (Rcu_elem * a)
        {
            Ec * e = static_cast<Ec *>(a);

            if (!e->utcb && !e->xcpu_sm) {
c000383b:	a1 b4 00 00 00       	mov    0xb4,%eax
c0003840:	0f 0b                	ud2    

            if (e->del_ref()) {
                assert(e != Ec::current);
                delete e;
            }
        }
c0003842:	58                   	pop    %eax
c0003843:	5b                   	pop    %ebx
c0003844:	5e                   	pop    %esi
c0003845:	c3                   	ret    

c0003846 <_ZN2Ec13handle_hazardEmPFvvE>:

void Ec::handle_hazard (mword hzd, void (*func)())
{
c0003846:	56                   	push   %esi
c0003847:	89 d6                	mov    %edx,%esi
c0003849:	53                   	push   %ebx
c000384a:	89 c3                	mov    %eax,%ebx
c000384c:	83 ec 08             	sub    $0x8,%esp
    if (hzd & HZD_RCU)
c000384f:	a8 10                	test   $0x10,%al
c0003851:	74 05                	je     c0003858 <_ZN2Ec13handle_hazardEmPFvvE+0x12>
        Rcu::quiet();
c0003853:	e8 2a aa 00 00       	call   c000e282 <_ZN3Rcu5quietEv>

    if (hzd & HZD_SCHED) {
c0003858:	f6 c3 01             	test   $0x1,%bl
c000385b:	74 14                	je     c0003871 <_ZN2Ec13handle_hazardEmPFvvE+0x2b>
        current->cont = func;
c000385d:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
        Sc::schedule();
c0003862:	ba 01 00 00 00       	mov    $0x1,%edx
{
    if (hzd & HZD_RCU)
        Rcu::quiet();

    if (hzd & HZD_SCHED) {
        current->cont = func;
c0003867:	89 70 50             	mov    %esi,0x50(%eax)
        Sc::schedule();
c000386a:	31 c0                	xor    %eax,%eax
c000386c:	e8 41 c1 00 00       	call   c000f9b2 <_ZN2Sc8scheduleEbb>
    }

    if (hzd & HZD_RECALL) {
c0003871:	85 db                	test   %ebx,%ebx
c0003873:	79 69                	jns    c00038de <_ZN2Ec13handle_hazardEmPFvvE+0x98>
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
c0003875:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c000387a:	f0 81 a0 a0 00 00 00 	lock andl $0x7fffffff,0xa0(%eax)
c0003881:	ff ff ff 7f 
c0003885:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
        current->regs.clr_hazard (HZD_RECALL);

        if (func == ret_user_vmresume) {
c000388a:	81 fe 2c 3f 00 c0    	cmp    $0xc0003f2c,%esi
c0003890:	75 0f                	jne    c00038a1 <_ZN2Ec13handle_hazardEmPFvvE+0x5b>
            current->regs.dst_portal = NUM_VMI - 1;
c0003892:	c7 80 88 00 00 00 ff 	movl   $0xff,0x88(%eax)
c0003899:	00 00 00 
            send_msg<ret_user_vmresume>();
c000389c:	e8 fb e0 00 00       	call   c001199c <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv>
        }

        if (func == ret_user_vmrun) {
c00038a1:	81 fe 44 3a 00 c0    	cmp    $0xc0003a44,%esi
c00038a7:	75 0f                	jne    c00038b8 <_ZN2Ec13handle_hazardEmPFvvE+0x72>
            current->regs.dst_portal = NUM_VMI - 1;
c00038a9:	c7 80 88 00 00 00 ff 	movl   $0xff,0x88(%eax)
c00038b0:	00 00 00 
            send_msg<ret_user_vmrun>();
c00038b3:	e8 0c e3 00 00       	call   c0011bc4 <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv>
        }

        if (func == ret_user_sysexit)
c00038b8:	81 fe 00 00 00 c0    	cmp    $0xc0000000,%esi
c00038be:	75 12                	jne    c00038d2 <_ZN2Ec13handle_hazardEmPFvvE+0x8c>
        }

        ALWAYS_INLINE
        inline void redirect_to_iret()
        {
            regs.REG(sp) = regs.ARG_SP;
c00038c0:	8b 50 6c             	mov    0x6c(%eax),%edx
c00038c3:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
            regs.REG(ip) = regs.ARG_IP;
c00038c9:	8b 50 68             	mov    0x68(%eax),%edx
c00038cc:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
            current->redirect_to_iret();

        current->regs.dst_portal = NUM_EXC - 1;
c00038d2:	c7 80 88 00 00 00 1f 	movl   $0x1f,0x88(%eax)
c00038d9:	00 00 00 
c00038dc:	eb 41                	jmp    c000391f <_ZN2Ec13handle_hazardEmPFvvE+0xd9>
        send_msg<ret_user_iret>();
    }

    if (hzd & HZD_STEP) {
c00038de:	f7 c3 00 00 00 40    	test   $0x40000000,%ebx
c00038e4:	74 3e                	je     c0003924 <_ZN2Ec13handle_hazardEmPFvvE+0xde>
c00038e6:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c00038eb:	f0 81 a0 a0 00 00 00 	lock andl $0xbfffffff,0xa0(%eax)
c00038f2:	ff ff ff bf 
c00038f6:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
        current->regs.clr_hazard (HZD_STEP);

        if (func == ret_user_sysexit)
c00038fb:	81 fe 00 00 00 c0    	cmp    $0xc0000000,%esi
c0003901:	75 12                	jne    c0003915 <_ZN2Ec13handle_hazardEmPFvvE+0xcf>
        }

        ALWAYS_INLINE
        inline void redirect_to_iret()
        {
            regs.REG(sp) = regs.ARG_SP;
c0003903:	8b 50 6c             	mov    0x6c(%eax),%edx
c0003906:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
            regs.REG(ip) = regs.ARG_IP;
c000390c:	8b 50 68             	mov    0x68(%eax),%edx
c000390f:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
            current->redirect_to_iret();

        current->regs.dst_portal = Cpu::EXC_DB;
c0003915:	c7 80 88 00 00 00 01 	movl   $0x1,0x88(%eax)
c000391c:	00 00 00 
        send_msg<ret_user_iret>();
c000391f:	e8 c8 e4 00 00       	call   c0011dec <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv>
    }

    if (hzd & HZD_TSC) {
c0003924:	f7 c3 00 00 00 20    	test   $0x20000000,%ebx
c000392a:	0f 84 99 00 00 00    	je     c00039c9 <_ZN2Ec13handle_hazardEmPFvvE+0x183>
c0003930:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0003935:	f0 81 a0 a0 00 00 00 	lock andl $0xdfffffff,0xa0(%eax)
c000393c:	ff ff ff df 
c0003940:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
        current->regs.clr_hazard (HZD_TSC);

        if (func == ret_user_vmresume) {
c0003945:	81 fe 2c 3f 00 c0    	cmp    $0xc0003f2c,%esi
c000394b:	75 67                	jne    c00039b4 <_ZN2Ec13handle_hazardEmPFvvE+0x16e>
            current->regs.vmcs->make_current();
c000394d:	8b 50 74             	mov    0x74(%eax),%edx
        }

        ALWAYS_INLINE
        inline void make_current()
        {
            if (EXPECT_TRUE (current == this))
c0003950:	39 15 14 f0 ff cf    	cmp    %edx,0xcffff014
c0003956:	74 40                	je     c0003998 <_ZN2Ec13handle_hazardEmPFvvE+0x152>
                return;

            uint64 phys = Buddy::ptr_to_phys (current = this);
c0003958:	89 15 14 f0 ff cf    	mov    %edx,0xcffff014
        }

        ALWAYS_INLINE
        inline mword virt_to_phys (mword virt)
        {
            return virt - reinterpret_cast<mword>(&OFFSET);
c000395e:	81 ea 00 00 c0 bf    	sub    $0xbfc00000,%edx
c0003964:	89 14 24             	mov    %edx,(%esp)
c0003967:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c000396e:	00 

            bool ret;
            asm volatile ("vmptrld %1; seta %0" : "=q" (ret) : "m" (phys) : "cc");
c000396f:	0f c7 34 24          	vmptrld (%esp)
c0003973:	0f 97 c2             	seta   %dl
            assert (ret);
c0003976:	84 d2                	test   %dl,%dl
c0003978:	75 1e                	jne    c0003998 <_ZN2Ec13handle_hazardEmPFvvE+0x152>
c000397a:	68 c4 6d 01 c0       	push   $0xc0016dc4
c000397f:	68 96 01 00 00       	push   $0x196
c0003984:	68 13 69 01 c0       	push   $0xc0016913
c0003989:	68 83 69 01 c0       	push   $0xc0016983
c000398e:	68 69 60 01 c0       	push   $0xc0016069
c0003993:	e8 ae df ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>
            Vmcs::write (Vmcs::TSC_OFFSET,    static_cast<mword>(current->regs.tsc_offset));
c0003998:	8b 90 a8 00 00 00    	mov    0xa8(%eax),%edx
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
c000399e:	b9 10 20 00 00       	mov    $0x2010,%ecx
c00039a3:	0f 79 88 a4 00 00 00 	vmwrite 0xa4(%eax),%ecx
c00039aa:	b8 11 20 00 00       	mov    $0x2011,%eax
c00039af:	0f 79 c2             	vmwrite %edx,%eax
c00039b2:	eb 15                	jmp    c00039c9 <_ZN2Ec13handle_hazardEmPFvvE+0x183>
            Vmcs::write (Vmcs::TSC_OFFSET_HI, static_cast<mword>(current->regs.tsc_offset >> 32));
        } else
            current->regs.vmcb->tsc_offset = current->regs.tsc_offset;
c00039b4:	8b 48 74             	mov    0x74(%eax),%ecx
c00039b7:	8b 90 a8 00 00 00    	mov    0xa8(%eax),%edx
c00039bd:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
c00039c3:	89 51 54             	mov    %edx,0x54(%ecx)
c00039c6:	89 41 50             	mov    %eax,0x50(%ecx)
    }

    if (hzd & HZD_DS_ES) {
c00039c9:	f6 c3 02             	test   $0x2,%bl
c00039cc:	74 10                	je     c00039de <_ZN2Ec13handle_hazardEmPFvvE+0x198>
        Cpu::hazard &= ~HZD_DS_ES;
c00039ce:	83 25 00 f0 ff cf fd 	andl   $0xfffffffd,0xcffff000
        asm volatile ("mov %0, %%ds; mov %0, %%es" : : "r" (SEL_USER_DATA));
c00039d5:	b8 23 00 00 00       	mov    $0x23,%eax
c00039da:	8e d8                	mov    %eax,%ds
c00039dc:	8e c0                	mov    %eax,%es
    }

    if (hzd & HZD_FPU)
c00039de:	f6 c3 08             	test   $0x8,%bl
c00039e1:	74 1d                	je     c0003a00 <_ZN2Ec13handle_hazardEmPFvvE+0x1ba>
        if (current != fpowner)
c00039e3:	a1 7c f7 ff cf       	mov    0xcffff77c,%eax
c00039e8:	39 05 08 f0 ff cf    	cmp    %eax,0xcffff008
c00039ee:	74 10                	je     c0003a00 <_ZN2Ec13handle_hazardEmPFvvE+0x1ba>

ALWAYS_INLINE
static inline mword get_cr0()
{
    mword cr0;
    asm volatile ("mov %%cr0, %0" : "=r" (cr0));
c00039f0:	0f 20 c0             	mov    %cr0,%eax

        ALWAYS_INLINE
        static inline void enable() { asm volatile ("clts"); Cpu::hazard |= HZD_FPU; }

        ALWAYS_INLINE
        static inline void disable() { set_cr0 (get_cr0() | Cpu::CR0_TS); Cpu::hazard &= ~HZD_FPU; }
c00039f3:	83 c8 08             	or     $0x8,%eax
}

ALWAYS_INLINE
static inline void set_cr0 (mword cr0)
{
    asm volatile ("mov %0, %%cr0" : : "r" (cr0));
c00039f6:	0f 22 c0             	mov    %eax,%cr0
c00039f9:	83 25 00 f0 ff cf f7 	andl   $0xfffffff7,0xcffff000
            Fpu::disable();
}
c0003a00:	83 c4 08             	add    $0x8,%esp
c0003a03:	5b                   	pop    %ebx
c0003a04:	5e                   	pop    %esi
c0003a05:	c3                   	ret    

c0003a06 <_ZN2Ec4idleEv>:

    UNREACHED;
}

void Ec::idle()
{
c0003a06:	57                   	push   %edi
c0003a07:	56                   	push   %esi
c0003a08:	53                   	push   %ebx
c0003a09:	83 ec 08             	sub    $0x8,%esp
    for (;;) {

        mword hzd = Cpu::hazard & (HZD_RCU | HZD_SCHED);
        if (EXPECT_FALSE (hzd))
c0003a0c:	a1 00 f0 ff cf       	mov    0xcffff000,%eax
c0003a11:	83 e0 11             	and    $0x11,%eax
c0003a14:	74 0a                	je     c0003a20 <_ZN2Ec4idleEv+0x1a>
            handle_hazard (hzd, idle);
c0003a16:	ba 06 3a 00 c0       	mov    $0xc0003a06,%edx
c0003a1b:	e8 26 fe ff ff       	call   c0003846 <_ZN2Ec13handle_hazardEmPFvvE>
ALWAYS_INLINE
static inline uint64 rdtsc()
{
    mword h, l;
    asm volatile ("rdtsc" : "=a" (l), "=d" (h));
    return static_cast<uint64>(h) << 32 | l;
c0003a20:	0f 31                	rdtsc  
c0003a22:	89 04 24             	mov    %eax,(%esp)
c0003a25:	89 54 24 04          	mov    %edx,0x4(%esp)

        uint64 t1 = rdtsc();
        asm volatile ("sti; hlt; cli" : : : "memory");
c0003a29:	fb                   	sti    
c0003a2a:	f4                   	hlt    
c0003a2b:	fa                   	cli    
c0003a2c:	0f 31                	rdtsc  
        uint64 t2 = rdtsc();

        Counter::cycles_idle += t2 - t1;
c0003a2e:	2b 04 24             	sub    (%esp),%eax
c0003a31:	1b 54 24 04          	sbb    0x4(%esp),%edx
c0003a35:	01 05 20 f0 ff cf    	add    %eax,0xcffff020
c0003a3b:	11 15 24 f0 ff cf    	adc    %edx,0xcffff024
    }
c0003a41:	eb c9                	jmp    c0003a0c <_ZN2Ec4idleEv+0x6>
c0003a43:	90                   	nop

c0003a44 <_ZN2Ec14ret_user_vmrunEv>:

    die ("VMENTRY");
}

void Ec::ret_user_vmrun()
{
c0003a44:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
    mword hzd = (Cpu::hazard | current->regs.hazard()) & (HZD_RECALL | HZD_TSC | HZD_RCU | HZD_SCHED);
c0003a49:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
c0003a4f:	0b 05 00 f0 ff cf    	or     0xcffff000,%eax
    if (EXPECT_FALSE (hzd))
c0003a55:	25 11 00 00 a0       	and    $0xa0000011,%eax
c0003a5a:	74 0a                	je     c0003a66 <_ZN2Ec14ret_user_vmrunEv+0x22>
        handle_hazard (hzd, ret_user_vmrun);
c0003a5c:	ba 44 3a 00 c0       	mov    $0xc0003a44,%edx
c0003a61:	e8 e0 fd ff ff       	call   c0003846 <_ZN2Ec13handle_hazardEmPFvvE>

    if (EXPECT_FALSE (Pd::current->gtlb.chk (Cpu::id))) {
c0003a66:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
c0003a6b:	8b 0d 04 f0 ff cf    	mov    0xcffff004,%ecx
c0003a71:	8b 90 74 01 00 00    	mov    0x174(%eax),%edx
c0003a77:	0f a3 ca             	bt     %ecx,%edx
c0003a7a:	73 35                	jae    c0003ab1 <_ZN2Ec14ret_user_vmrunEv+0x6d>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
c0003a7c:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
c0003a81:	d3 c2                	rol    %cl,%edx
c0003a83:	f0 21 90 74 01 00 00 	lock and %edx,0x174(%eax)
        Pd::current->gtlb.clr (Cpu::id);
        if (current->regs.nst_on)
c0003a8a:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0003a8f:	80 b8 94 00 00 00 00 	cmpb   $0x0,0x94(%eax)
c0003a96:	74 0c                	je     c0003aa4 <_ZN2Ec14ret_user_vmrunEv+0x60>
            current->regs.vmcb->tlb_control = 1;
c0003a98:	8b 40 74             	mov    0x74(%eax),%eax
c0003a9b:	c7 40 5c 01 00 00 00 	movl   $0x1,0x5c(%eax)
c0003aa2:	eb 0d                	jmp    c0003ab1 <_ZN2Ec14ret_user_vmrunEv+0x6d>
        else
            current->regs.vtlb->flush (true);
c0003aa4:	8b 40 78             	mov    0x78(%eax),%eax
c0003aa7:	ba 01 00 00 00       	mov    $0x1,%edx
c0003aac:	e8 5b 22 01 00       	call   c0015d0c <_ZN4Vtlb5flushEb>
                  "mov %2," EXPAND (PREG(sp);)
                  "vmload;"
                  "cli;"
                  "stgi;"
                  "jmp svm_handler;"
                  : : "m" (current->regs), "m" (Vmcb::root), "i" (CPU_LOCAL_STCK + PAGE_SIZE) : "memory");
c0003ab1:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0003ab6:	8d 60 54             	lea    0x54(%eax),%esp
c0003ab9:	61                   	popa   
c0003aba:	0f 01 dd             	clgi   
c0003abd:	fb                   	sti    
c0003abe:	0f 01 da             	vmload 
c0003ac1:	0f 01 d8             	vmrun  
c0003ac4:	0f 01 db             	vmsave 
c0003ac7:	60                   	pusha  
c0003ac8:	a1 3c fa ff cf       	mov    0xcffffa3c,%eax
c0003acd:	bc 00 e0 ff cf       	mov    $0xcfffe000,%esp
c0003ad2:	0f 01 da             	vmload 
c0003ad5:	fa                   	cli    
c0003ad6:	0f 01 dc             	stgi   
c0003ad9:	e9 46 10 00 00       	jmp    c0004b24 <svm_handler>

c0003ade <tss_handler>:
    ret_user_sysexit();
}

void Ec::handle_tss()
{
    Console::panic ("Task gate invoked");
c0003ade:	68 d6 69 01 c0       	push   $0xc00169d6
c0003ae3:	e8 5e de ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

c0003ae8 <_ZN2Ec5fixupERm>:
}

bool Ec::fixup (mword &eip)
{
    for (mword *ptr = &FIXUP_S; ptr < &FIXUP_E; ptr += 2)
c0003ae8:	ba 20 9f 01 c0       	mov    $0xc0019f20,%edx
c0003aed:	81 fa 48 9f 01 c0    	cmp    $0xc0019f48,%edx
c0003af3:	73 13                	jae    c0003b08 <_ZN2Ec5fixupERm+0x20>
        if (eip == *ptr) {
c0003af5:	8b 0a                	mov    (%edx),%ecx
c0003af7:	39 08                	cmp    %ecx,(%eax)
c0003af9:	75 08                	jne    c0003b03 <_ZN2Ec5fixupERm+0x1b>
            eip = *++ptr;
c0003afb:	8b 52 04             	mov    0x4(%edx),%edx
c0003afe:	89 10                	mov    %edx,(%eax)
            return true;
c0003b00:	b0 01                	mov    $0x1,%al
c0003b02:	c3                   	ret    
    Console::panic ("Task gate invoked");
}

bool Ec::fixup (mword &eip)
{
    for (mword *ptr = &FIXUP_S; ptr < &FIXUP_E; ptr += 2)
c0003b03:	83 c2 08             	add    $0x8,%edx
c0003b06:	eb e5                	jmp    c0003aed <_ZN2Ec5fixupERm+0x5>
        if (eip == *ptr) {
            eip = *++ptr;
            return true;
        }

    return false;
c0003b08:	31 c0                	xor    %eax,%eax
}
c0003b0a:	c3                   	ret    
c0003b0b:	90                   	nop

c0003b0c <_ZN2Ec3dieEPKcP8Exc_regs>:

void Ec::die (char const *reason, Exc_regs *r)
{
c0003b0c:	57                   	push   %edi
c0003b0d:	89 c7                	mov    %eax,%edi
c0003b0f:	56                   	push   %esi
c0003b10:	53                   	push   %ebx
c0003b11:	51                   	push   %ecx
    if (current->utcb || current->pd == &Pd::kern) {
c0003b12:	8b 0d 08 f0 ff cf    	mov    0xcffff008,%ecx
c0003b18:	83 b9 b4 00 00 00 00 	cmpl   $0x0,0xb4(%ecx)
c0003b1f:	75 10                	jne    c0003b31 <_ZN2Ec3dieEPKcP8Exc_regs+0x25>
c0003b21:	81 b9 b8 00 00 00 c0 	cmpl   $0xc001b2c0,0xb8(%ecx)
c0003b28:	b2 01 c0 
c0003b2b:	0f 85 8a 00 00 00    	jne    c0003bbb <_ZN2Ec3dieEPKcP8Exc_regs+0xaf>
c0003b31:	be e8 69 01 c0       	mov    $0xc00169e8,%esi
}

extern "C" NONNULL
inline int strcmp (char const *s1, char const *s2)
{
    while (*s1 && *s1 == *s2)
c0003b36:	8a 1f                	mov    (%edi),%bl
c0003b38:	84 db                	test   %bl,%bl
c0003b3a:	74 08                	je     c0003b44 <_ZN2Ec3dieEPKcP8Exc_regs+0x38>
c0003b3c:	3a 1e                	cmp    (%esi),%bl
c0003b3e:	75 04                	jne    c0003b44 <_ZN2Ec3dieEPKcP8Exc_regs+0x38>
        s1++, s2++;
c0003b40:	47                   	inc    %edi
c0003b41:	46                   	inc    %esi
c0003b42:	eb f2                	jmp    c0003b36 <_ZN2Ec3dieEPKcP8Exc_regs+0x2a>
        if (strcmp(reason, "PT not found"))
c0003b44:	3a 1e                	cmp    (%esi),%bl
c0003b46:	74 41                	je     c0003b89 <_ZN2Ec3dieEPKcP8Exc_regs+0x7d>
        trace (0, "Killed EC:%p SC:%p V:%#lx CS:%#lx EIP:%#lx CR2:%#lx ERR:%#lx (%s)",
c0003b48:	8d 5c 24 ff          	lea    -0x1(%esp),%ebx
c0003b4c:	50                   	push   %eax
c0003b4d:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
c0003b53:	ff 72 30             	pushl  0x30(%edx)
c0003b56:	81 fb 00 d0 ff cf    	cmp    $0xcfffd000,%ebx
c0003b5c:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
c0003b61:	0f 44 1d 04 f0 ff cf 	cmove  0xcffff004,%ebx
c0003b68:	ff 72 0c             	pushl  0xc(%edx)
c0003b6b:	ff 72 38             	pushl  0x38(%edx)
c0003b6e:	ff 72 3c             	pushl  0x3c(%edx)
c0003b71:	ff 72 34             	pushl  0x34(%edx)
c0003b74:	ff 35 10 f0 ff cf    	pushl  0xcffff010
c0003b7a:	51                   	push   %ecx
c0003b7b:	53                   	push   %ebx
c0003b7c:	68 f5 69 01 c0       	push   $0xc00169f5
c0003b81:	e8 58 de ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c0003b86:	83 c4 28             	add    $0x28,%esp
               current, Sc::current, r->vec, r->cs, r->REG(ip), r->cr2, r->err, reason);
    } else
        trace (0, "Killed EC:%p SC:%p V:%#lx CR0:%#lx CR3:%#lx CR4:%#lx (%s)",
               current, Sc::current, r->vec, r->cr0_shadow, r->cr3_shadow, r->cr4_shadow, reason);

    Ec *ec = current->rcap;
c0003b89:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0003b8e:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax

    if (ec)
c0003b94:	85 c0                	test   %eax,%eax
c0003b96:	74 17                	je     c0003baf <_ZN2Ec3dieEPKcP8Exc_regs+0xa3>
        ec->cont = ec->cont == ret_user_sysexit ? static_cast<void (*)()>(sys_finish<Sys_regs::COM_ABT>) : dead;
c0003b98:	81 78 50 00 00 00 c0 	cmpl   $0xc0000000,0x50(%eax)
c0003b9f:	b9 1a 3f 00 c0       	mov    $0xc0003f1a,%ecx
c0003ba4:	ba 14 20 01 c0       	mov    $0xc0012014,%edx
c0003ba9:	0f 45 d1             	cmovne %ecx,%edx
c0003bac:	89 50 50             	mov    %edx,0x50(%eax)

    reply (dead);
c0003baf:	31 d2                	xor    %edx,%edx
c0003bb1:	b8 1a 3f 00 c0       	mov    $0xc0003f1a,%eax
c0003bb6:	e8 3d c5 ff ff       	call   c00000f8 <_ZN2Ec5replyEPFvvEP2Sm>
    if (current->utcb || current->pd == &Pd::kern) {
        if (strcmp(reason, "PT not found"))
        trace (0, "Killed EC:%p SC:%p V:%#lx CS:%#lx EIP:%#lx CR2:%#lx ERR:%#lx (%s)",
               current, Sc::current, r->vec, r->cs, r->REG(ip), r->cr2, r->err, reason);
    } else
        trace (0, "Killed EC:%p SC:%p V:%#lx CR0:%#lx CR3:%#lx CR4:%#lx (%s)",
c0003bbb:	8d 5c 24 ff          	lea    -0x1(%esp),%ebx
c0003bbf:	50                   	push   %eax
c0003bc0:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
c0003bc6:	ff 72 30             	pushl  0x30(%edx)
c0003bc9:	81 fb 00 d0 ff cf    	cmp    $0xcfffd000,%ebx
c0003bcf:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
c0003bd4:	0f 44 1d 04 f0 ff cf 	cmove  0xcffff004,%ebx
c0003bdb:	ff 72 2c             	pushl  0x2c(%edx)
c0003bde:	ff 72 28             	pushl  0x28(%edx)
c0003be1:	ff 72 34             	pushl  0x34(%edx)
c0003be4:	ff 35 10 f0 ff cf    	pushl  0xcffff010
c0003bea:	51                   	push   %ecx
c0003beb:	53                   	push   %ebx
c0003bec:	68 3e 6a 01 c0       	push   $0xc0016a3e
c0003bf1:	e8 e8 dd ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c0003bf6:	83 c4 24             	add    $0x24,%esp
c0003bf9:	eb 8e                	jmp    c0003b89 <_ZN2Ec3dieEPKcP8Exc_regs+0x7d>
c0003bfb:	90                   	nop

c0003bfc <_ZN2Ec11root_invokeEv>:
        Counter::cycles_idle += t2 - t1;
    }
}

void Ec::root_invoke()
{
c0003bfc:	55                   	push   %ebp
    Eh *e = static_cast<Eh *>(Hpt::remap (Pd::kern.quota, Hip::root_addr));
c0003bfd:	b8 50 b4 01 c0       	mov    $0xc001b450,%eax
        Counter::cycles_idle += t2 - t1;
    }
}

void Ec::root_invoke()
{
c0003c02:	57                   	push   %edi
c0003c03:	56                   	push   %esi
c0003c04:	53                   	push   %ebx
c0003c05:	83 ec 28             	sub    $0x28,%esp
    Eh *e = static_cast<Eh *>(Hpt::remap (Pd::kern.quota, Hip::root_addr));
c0003c08:	8b 15 e4 aa 01 c0    	mov    0xc001aae4,%edx
c0003c0e:	e8 db 1f 00 00       	call   c0005bee <_ZN3Hpt5remapER5Quotam>
    if (!Hip::root_addr || e->ei_magic != 0x464c457f || e->ei_class != ELF_CLASS || e->ei_data != 1 || e->type != 2 || e->machine != ELF_MACHINE)
c0003c13:	8b 0d e4 aa 01 c0    	mov    0xc001aae4,%ecx
c0003c19:	8b 15 08 f0 ff cf    	mov    0xcffff008,%edx
c0003c1f:	85 c9                	test   %ecx,%ecx
c0003c21:	74 19                	je     c0003c3c <_ZN2Ec11root_invokeEv+0x40>
c0003c23:	81 38 7f 45 4c 46    	cmpl   $0x464c457f,(%eax)
c0003c29:	75 11                	jne    c0003c3c <_ZN2Ec11root_invokeEv+0x40>
c0003c2b:	66 81 78 04 01 01    	cmpw   $0x101,0x4(%eax)
c0003c31:	75 09                	jne    c0003c3c <_ZN2Ec11root_invokeEv+0x40>
c0003c33:	81 78 10 02 00 03 00 	cmpl   $0x30002,0x10(%eax)
c0003c3a:	74 0d                	je     c0003c49 <_ZN2Ec11root_invokeEv+0x4d>
        die ("No ELF");
c0003c3c:	83 c2 54             	add    $0x54,%edx
c0003c3f:	b8 7f 6a 01 c0       	mov    $0xc0016a7f,%eax
c0003c44:	e9 b8 00 00 00       	jmp    c0003d01 <_ZN2Ec11root_invokeEv+0x105>
            else
                ARG_1 = (ARG_1 & ~0xfful) | s;
        }

        ALWAYS_INLINE
        inline void set_pt (mword pt) { ARG_1 = pt; }
c0003c49:	8b 1d 04 f0 ff cf    	mov    0xcffff004,%ebx

    unsigned count = e->ph_count;
c0003c4f:	0f b7 78 2c          	movzwl 0x2c(%eax),%edi
c0003c53:	89 5a 70             	mov    %ebx,0x70(%edx)
    current->regs.set_pt (Cpu::id);
    current->regs.set_ip (e->entry);
c0003c56:	8b 58 18             	mov    0x18(%eax),%ebx

        ALWAYS_INLINE
        inline void set_ip (mword ip) { ARG_IP = ip; }

        ALWAYS_INLINE
        inline void set_sp (mword sp) { ARG_SP = sp; }
c0003c59:	c7 42 6c 00 f0 ff bf 	movl   $0xbffff000,0x6c(%edx)
{
    Eh *e = static_cast<Eh *>(Hpt::remap (Pd::kern.quota, Hip::root_addr));
    if (!Hip::root_addr || e->ei_magic != 0x464c457f || e->ei_class != ELF_CLASS || e->ei_data != 1 || e->type != 2 || e->machine != ELF_MACHINE)
        die ("No ELF");

    unsigned count = e->ph_count;
c0003c60:	89 7c 24 08          	mov    %edi,0x8(%esp)

        ALWAYS_INLINE
        inline void set_pt (mword pt, mword pt2, mword s) { ARG_1 = pt; ARG_2 = pt2; ARG_3 = s; }

        ALWAYS_INLINE
        inline void set_ip (mword ip) { ARG_IP = ip; }
c0003c64:	89 5a 68             	mov    %ebx,0x68(%edx)
    current->regs.set_pt (Cpu::id);
    current->regs.set_ip (e->entry);
    current->regs.set_sp (USER_ADDR - PAGE_SIZE);

    ELF_PHDR *p = static_cast<ELF_PHDR *>(Hpt::remap (Pd::kern.quota, Hip::root_addr + e->ph_offset));
c0003c67:	03 48 1c             	add    0x1c(%eax),%ecx
c0003c6a:	b8 50 b4 01 c0       	mov    $0xc001b450,%eax
c0003c6f:	89 ca                	mov    %ecx,%edx
c0003c71:	e8 78 1f 00 00       	call   c0005bee <_ZN3Hpt5remapER5Quotam>

    for (unsigned i = 0; i < count; i++, p++) {
c0003c76:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    unsigned count = e->ph_count;
    current->regs.set_pt (Cpu::id);
    current->regs.set_ip (e->entry);
    current->regs.set_sp (USER_ADDR - PAGE_SIZE);

    ELF_PHDR *p = static_cast<ELF_PHDR *>(Hpt::remap (Pd::kern.quota, Hip::root_addr + e->ph_offset));
c0003c7d:	89 c7                	mov    %eax,%edi

    for (unsigned i = 0; i < count; i++, p++) {
c0003c7f:	eb 39                	jmp    c0003cba <_ZN2Ec11root_invokeEv+0xbe>

            unsigned attr = !!(p->flags & 0x4) << 0 |   // R
                            !!(p->flags & 0x2) << 1 |   // W
                            !!(p->flags & 0x1) << 2;    // X

            if (p->f_size != p->m_size || p->v_addr % PAGE_SIZE != p->f_offs % PAGE_SIZE)
c0003c81:	8b 77 04             	mov    0x4(%edi),%esi
c0003c84:	8b 6f 08             	mov    0x8(%edi),%ebp
c0003c87:	89 f0                	mov    %esi,%eax
c0003c89:	31 e8                	xor    %ebp,%eax
c0003c8b:	a9 ff 0f 00 00       	test   $0xfff,%eax
c0003c90:	75 62                	jne    c0003cf4 <_ZN2Ec11root_invokeEv+0xf8>
                die ("Bad ELF");

            mword phys = align_dn (p->f_offs + Hip::root_addr, PAGE_SIZE);
c0003c92:	03 35 e4 aa 01 c0    	add    0xc001aae4,%esi
}

ALWAYS_INLINE
static inline mword align_up (mword val, mword align)
{
    val += (align - 1);                 // Expect power-of-2
c0003c98:	81 c3 ff 0f 00 00    	add    $0xfff,%ebx
}

ALWAYS_INLINE
static inline mword align_dn (mword val, mword align)
{
    val &= ~(align - 1);                // Expect power-of-2
c0003c9e:	81 e5 00 f0 ff ff    	and    $0xfffff000,%ebp
c0003ca4:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
c0003caa:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
            mword virt = align_dn (p->v_addr, PAGE_SIZE);
            mword size = align_up (p->f_size, PAGE_SIZE);

            for (unsigned long o; size; size -= 1UL << o, phys += 1UL << o, virt += 1UL << o)
c0003cb0:	85 db                	test   %ebx,%ebx
c0003cb2:	75 52                	jne    c0003d06 <_ZN2Ec11root_invokeEv+0x10a>
    current->regs.set_ip (e->entry);
    current->regs.set_sp (USER_ADDR - PAGE_SIZE);

    ELF_PHDR *p = static_cast<ELF_PHDR *>(Hpt::remap (Pd::kern.quota, Hip::root_addr + e->ph_offset));

    for (unsigned i = 0; i < count; i++, p++) {
c0003cb4:	ff 04 24             	incl   (%esp)
c0003cb7:	83 c7 20             	add    $0x20,%edi
c0003cba:	8b 74 24 08          	mov    0x8(%esp),%esi
c0003cbe:	39 34 24             	cmp    %esi,(%esp)
c0003cc1:	0f 83 a9 00 00 00    	jae    c0003d70 <_ZN2Ec11root_invokeEv+0x174>

        if (p->type == 1) {
c0003cc7:	83 3f 01             	cmpl   $0x1,(%edi)
c0003cca:	75 e8                	jne    c0003cb4 <_ZN2Ec11root_invokeEv+0xb8>

            unsigned attr = !!(p->flags & 0x4) << 0 |   // R
c0003ccc:	8b 47 18             	mov    0x18(%edi),%eax
                            !!(p->flags & 0x2) << 1 |   // W
                            !!(p->flags & 0x1) << 2;    // X

            if (p->f_size != p->m_size || p->v_addr % PAGE_SIZE != p->f_offs % PAGE_SIZE)
c0003ccf:	8b 5f 10             	mov    0x10(%edi),%ebx

    for (unsigned i = 0; i < count; i++, p++) {

        if (p->type == 1) {

            unsigned attr = !!(p->flags & 0x4) << 0 |   // R
c0003cd2:	89 c2                	mov    %eax,%edx
                            !!(p->flags & 0x2) << 1 |   // W
c0003cd4:	89 c1                	mov    %eax,%ecx

    for (unsigned i = 0; i < count; i++, p++) {

        if (p->type == 1) {

            unsigned attr = !!(p->flags & 0x4) << 0 |   // R
c0003cd6:	c1 ea 02             	shr    $0x2,%edx
                            !!(p->flags & 0x2) << 1 |   // W
                            !!(p->flags & 0x1) << 2;    // X
c0003cd9:	83 e0 01             	and    $0x1,%eax

    for (unsigned i = 0; i < count; i++, p++) {

        if (p->type == 1) {

            unsigned attr = !!(p->flags & 0x4) << 0 |   // R
c0003cdc:	83 e2 01             	and    $0x1,%edx
                            !!(p->flags & 0x2) << 1 |   // W
c0003cdf:	83 e1 02             	and    $0x2,%ecx
                            !!(p->flags & 0x1) << 2;    // X
c0003ce2:	f7 d8                	neg    %eax

    for (unsigned i = 0; i < count; i++, p++) {

        if (p->type == 1) {

            unsigned attr = !!(p->flags & 0x4) << 0 |   // R
c0003ce4:	09 ca                	or     %ecx,%edx
                            !!(p->flags & 0x2) << 1 |   // W
                            !!(p->flags & 0x1) << 2;    // X
c0003ce6:	83 e0 04             	and    $0x4,%eax
    for (unsigned i = 0; i < count; i++, p++) {

        if (p->type == 1) {

            unsigned attr = !!(p->flags & 0x4) << 0 |   // R
                            !!(p->flags & 0x2) << 1 |   // W
c0003ce9:	09 c2                	or     %eax,%edx
                            !!(p->flags & 0x1) << 2;    // X

            if (p->f_size != p->m_size || p->v_addr % PAGE_SIZE != p->f_offs % PAGE_SIZE)
c0003ceb:	3b 5f 14             	cmp    0x14(%edi),%ebx
    for (unsigned i = 0; i < count; i++, p++) {

        if (p->type == 1) {

            unsigned attr = !!(p->flags & 0x4) << 0 |   // R
                            !!(p->flags & 0x2) << 1 |   // W
c0003cee:	89 54 24 0c          	mov    %edx,0xc(%esp)
                            !!(p->flags & 0x1) << 2;    // X

            if (p->f_size != p->m_size || p->v_addr % PAGE_SIZE != p->f_offs % PAGE_SIZE)
c0003cf2:	74 8d                	je     c0003c81 <_ZN2Ec11root_invokeEv+0x85>
                die ("Bad ELF");
c0003cf4:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0003cf9:	8d 50 54             	lea    0x54(%eax),%edx
c0003cfc:	b8 86 6a 01 c0       	mov    $0xc0016a86,%eax
c0003d01:	e8 06 fe ff ff       	call   c0003b0c <_ZN2Ec3dieEPKcP8Exc_regs>
    if (EXPECT_FALSE (!val))
        return -1;

    asm volatile ("bsr %1, %0" : "=r" (val) : "rm" (val));

    return val;
c0003d06:	0f bd c3             	bsr    %ebx,%eax
ALWAYS_INLINE
inline unsigned long max_order (mword base, size_t size)
{
    long int o = bit_scan_reverse (size);

    if (base)
c0003d09:	85 ed                	test   %ebp,%ebp
c0003d0b:	74 08                	je     c0003d15 <_ZN2Ec11root_invokeEv+0x119>
inline long int bit_scan_forward (mword val)
{
    if (EXPECT_FALSE (!val))
        return -1;

    asm volatile ("bsf %1, %0" : "=r" (val) : "rm" (val));
c0003d0d:	0f bc d5             	bsf    %ebp,%edx
c0003d10:	39 d0                	cmp    %edx,%eax
c0003d12:	0f 4f c2             	cmovg  %edx,%eax
    if (EXPECT_FALSE (!val))
        return -1;

    asm volatile ("bsr %1, %0" : "=r" (val) : "rm" (val));

    return val;
c0003d15:	0f bd d3             	bsr    %ebx,%edx
ALWAYS_INLINE
inline unsigned long max_order (mword base, size_t size)
{
    long int o = bit_scan_reverse (size);

    if (base)
c0003d18:	85 f6                	test   %esi,%esi
c0003d1a:	74 08                	je     c0003d24 <_ZN2Ec11root_invokeEv+0x128>
inline long int bit_scan_forward (mword val)
{
    if (EXPECT_FALSE (!val))
        return -1;

    asm volatile ("bsf %1, %0" : "=r" (val) : "rm" (val));
c0003d1c:	0f bc ce             	bsf    %esi,%ecx
c0003d1f:	39 ca                	cmp    %ecx,%edx
c0003d21:	0f 4f d1             	cmovg  %ecx,%edx
c0003d24:	39 c2                	cmp    %eax,%edx
            mword phys = align_dn (p->f_offs + Hip::root_addr, PAGE_SIZE);
            mword virt = align_dn (p->v_addr, PAGE_SIZE);
            mword size = align_up (p->f_size, PAGE_SIZE);

            for (unsigned long o; size; size -= 1UL << o, phys += 1UL << o, virt += 1UL << o)
                Pd::current->delegate<Space_mem>(&Pd::kern, phys >> PAGE_BITS, virt >> PAGE_BITS, (o = min (max_order (phys, size), max_order (virt, size))) - PAGE_BITS, attr);
c0003d26:	89 f1                	mov    %esi,%ecx
c0003d28:	0f 46 c2             	cmovbe %edx,%eax
c0003d2b:	ba c0 b2 01 c0       	mov    $0xc001b2c0,%edx
c0003d30:	89 44 24 04          	mov    %eax,0x4(%esp)
c0003d34:	c1 e9 0c             	shr    $0xc,%ecx
c0003d37:	6a 00                	push   $0x0
c0003d39:	6a 00                	push   $0x0
c0003d3b:	ff 74 24 14          	pushl  0x14(%esp)
c0003d3f:	8b 44 24 10          	mov    0x10(%esp),%eax
c0003d43:	83 e8 0c             	sub    $0xc,%eax
c0003d46:	50                   	push   %eax
c0003d47:	89 e8                	mov    %ebp,%eax
c0003d49:	c1 e8 0c             	shr    $0xc,%eax
c0003d4c:	50                   	push   %eax
c0003d4d:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c0003d52:	e8 25 8f 00 00       	call   c000cc7c <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc>

            mword phys = align_dn (p->f_offs + Hip::root_addr, PAGE_SIZE);
            mword virt = align_dn (p->v_addr, PAGE_SIZE);
            mword size = align_up (p->f_size, PAGE_SIZE);

            for (unsigned long o; size; size -= 1UL << o, phys += 1UL << o, virt += 1UL << o)
c0003d57:	8a 4c 24 18          	mov    0x18(%esp),%cl
c0003d5b:	b8 01 00 00 00       	mov    $0x1,%eax
c0003d60:	83 c4 14             	add    $0x14,%esp
c0003d63:	d3 e0                	shl    %cl,%eax
c0003d65:	29 c3                	sub    %eax,%ebx
c0003d67:	01 c6                	add    %eax,%esi
c0003d69:	01 c5                	add    %eax,%ebp
c0003d6b:	e9 40 ff ff ff       	jmp    c0003cb0 <_ZN2Ec11root_invokeEv+0xb4>
                Pd::current->delegate<Space_mem>(&Pd::kern, phys >> PAGE_BITS, virt >> PAGE_BITS, (o = min (max_order (phys, size), max_order (virt, size))) - PAGE_BITS, attr);
        }
    }

    // Map hypervisor information page
    Pd::current->delegate<Space_mem>(&Pd::kern, reinterpret_cast<Paddr>(&FRAME_H) >> PAGE_BITS, (USER_ADDR - PAGE_SIZE) >> PAGE_BITS, 0, 1);
c0003d70:	6a 00                	push   $0x0
c0003d72:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c0003d77:	b9 00 e0 41 00       	mov    $0x41e000,%ecx
c0003d7c:	6a 00                	push   $0x0
c0003d7e:	ba c0 b2 01 c0       	mov    $0xc001b2c0,%edx
c0003d83:	6a 01                	push   $0x1
c0003d85:	6a 00                	push   $0x0
c0003d87:	68 ff ff 0b 00       	push   $0xbffff
c0003d8c:	c1 e9 0c             	shr    $0xc,%ecx
c0003d8f:	e8 e8 8e 00 00       	call   c000cc7c <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc>

    Space_obj::insert_root (Pd::kern.quota, Pd::current);
c0003d94:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c0003d9a:	b8 50 b4 01 c0       	mov    $0xc001b450,%eax
c0003d9f:	e8 18 d3 00 00       	call   c00110bc <_ZN9Space_obj11insert_rootER5QuotaP7Kobject>
    Space_obj::insert_root (Pd::kern.quota, Ec::current);
c0003da4:	8b 15 08 f0 ff cf    	mov    0xcffff008,%edx
c0003daa:	b8 50 b4 01 c0       	mov    $0xc001b450,%eax
c0003daf:	e8 08 d3 00 00       	call   c00110bc <_ZN9Space_obj11insert_rootER5QuotaP7Kobject>
    Space_obj::insert_root (Pd::kern.quota, Sc::current);
c0003db4:	8b 15 10 f0 ff cf    	mov    0xcffff010,%edx
c0003dba:	b8 50 b4 01 c0       	mov    $0xc001b450,%eax
c0003dbf:	e8 f8 d2 00 00       	call   c00110bc <_ZN9Space_obj11insert_rootER5QuotaP7Kobject>

        mword usage() { return used; }

        static void boot(Quota &kern, Quota &root)
        {
            kern.upli   = kern.used;
c0003dc4:	a1 54 b4 01 c0       	mov    0xc001b454,%eax
            root.upli  -= kern.used;
c0003dc9:	29 05 9c b2 01 c0    	sub    %eax,0xc001b29c
c0003dcf:	66 c7 44 24 28 00 00 	movw   $0x0,0x28(%esp)

        mword usage() { return used; }

        static void boot(Quota &kern, Quota &root)
        {
            kern.upli   = kern.used;
c0003dd6:	a3 5c b4 01 c0       	mov    %eax,0xc001b45c
    /* adjust root quota used by Pd::kern during bootstrap */
    Quota::boot(Pd::kern.quota, Pd::root.quota);

    /* preserve per CPU 4 pages quota */
    Quota cpus;
    bool s = Pd::root.quota.transfer_to(cpus, Cpu::online * 4);
c0003ddb:	a1 40 a4 01 c0       	mov    0xc001a440,%eax

    public:

        static Quota init;

        Quota () : used(0), over(0), upli(0), notr(0) { }
c0003de0:	c7 44 24 2c 00 00 00 	movl   $0x0,0x2c(%esp)
c0003de7:	00 
c0003de8:	c7 44 24 30 00 00 00 	movl   $0x0,0x30(%esp)
c0003def:	00 
c0003df0:	c7 44 24 34 00 00 00 	movl   $0x0,0x34(%esp)
c0003df7:	00 
c0003df8:	c7 44 24 38 00 00 00 	movl   $0x0,0x38(%esp)
c0003dff:	00 
c0003e00:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
c0003e07:	b8 90 b2 01 c0       	mov    $0xc001b290,%eax
c0003e0c:	6a 01                	push   $0x1
c0003e0e:	8d 54 24 2c          	lea    0x2c(%esp),%edx
c0003e12:	e8 d5 ec ff ff       	call   c0002aec <_ZN5Quota11transfer_toERS_mb>
    assert(s);
c0003e17:	83 c4 18             	add    $0x18,%esp
c0003e1a:	84 c0                	test   %al,%al
c0003e1c:	75 19                	jne    c0003e37 <_ZN2Ec11root_invokeEv+0x23b>
c0003e1e:	68 24 6d 01 c0       	push   $0xc0016d24
c0003e23:	68 9c 01 00 00       	push   $0x19c
c0003e28:	68 8e 6a 01 c0       	push   $0xc0016a8e
c0003e2d:	68 66 8e 01 c0       	push   $0xc0018e66
c0003e32:	e9 d9 00 00 00       	jmp    c0003f10 <_ZN2Ec11root_invokeEv+0x314>
             return true;
        }

        bool set_limit(mword l, mword h, Quota &from)
        {
            if (!from.transfer_to(*this, h))
c0003e37:	ba 90 b2 01 c0       	mov    $0xc001b290,%edx
c0003e3c:	31 c9                	xor    %ecx,%ecx
c0003e3e:	6a 01                	push   $0x1
c0003e40:	89 d0                	mov    %edx,%eax
c0003e42:	e8 a5 ec ff ff       	call   c0002aec <_ZN5Quota11transfer_toERS_mb>
c0003e47:	59                   	pop    %ecx
c0003e48:	84 c0                	test   %al,%al
c0003e4a:	0f 84 ac 00 00 00    	je     c0003efc <_ZN2Ec11root_invokeEv+0x300>
                return false;

            notr = l;
c0003e50:	c7 05 a0 b2 01 c0 00 	movl   $0x100,0xc001b2a0
c0003e57:	01 00 00 
        template <typename T>
        ALWAYS_INLINE
        static inline bool test_set_bit (T &val, unsigned long bit)
        {
            bool ret;
            asm volatile ("lock; bts%z1 %2, %1; setc %0" : "=q" (ret), "+m" (val) : "ir" (bit) : "cc");
c0003e5a:	f0 0f ba 2d e0 b4 01 	lock btsl $0x2,0xc001b4e0
c0003e61:	c0 02 
c0003e63:	0f 92 c0             	setb   %al

        ALWAYS_INLINE
        static inline void boot_init()
        {
            bool res = !Atomic::test_set_bit (did_c[0], NO_PCID);
            assert (res);
c0003e66:	84 c0                	test   %al,%al
c0003e68:	74 11                	je     c0003e7b <_ZN2Ec11root_invokeEv+0x27f>
c0003e6a:	68 00 6d 01 c0       	push   $0xc0016d00
c0003e6f:	6a 3a                	push   $0x3a
c0003e71:	68 f9 6a 01 c0       	push   $0xc0016af9
c0003e76:	e9 90 00 00 00       	jmp    c0003f0b <_ZN2Ec11root_invokeEv+0x30f>
    bool res = Pd::root.quota.set_limit ((1 * 1024 * 1024) >> 12, 0, Pd::root.quota);
    assert (res);

    /* setup PCID handling */
    Space_mem::boot_init();
    assert (Pd::kern.did == 0);
c0003e7b:	83 3d 28 b4 01 c0 00 	cmpl   $0x0,0xc001b428
c0003e82:	74 16                	je     c0003e9a <_ZN2Ec11root_invokeEv+0x29e>
c0003e84:	68 24 6d 01 c0       	push   $0xc0016d24
c0003e89:	68 a4 01 00 00       	push   $0x1a4
c0003e8e:	68 8e 6a 01 c0       	push   $0xc0016a8e
c0003e93:	68 73 6b 01 c0       	push   $0xc0016b73
c0003e98:	eb 76                	jmp    c0003f10 <_ZN2Ec11root_invokeEv+0x314>
    assert (Pd::root.did == 1);
c0003e9a:	83 3d 68 b2 01 c0 01 	cmpl   $0x1,0xc001b268
c0003ea1:	74 16                	je     c0003eb9 <_ZN2Ec11root_invokeEv+0x2bd>
c0003ea3:	68 24 6d 01 c0       	push   $0xc0016d24
c0003ea8:	68 a5 01 00 00       	push   $0x1a5
c0003ead:	68 8e 6a 01 c0       	push   $0xc0016a8e
c0003eb2:	68 85 6b 01 c0       	push   $0xc0016b85
c0003eb7:	eb 57                	jmp    c0003f10 <_ZN2Ec11root_invokeEv+0x314>

    /* quirk */
    if (Dpt::ord != ~0UL && Dpt::ord > 0x8) {
c0003eb9:	a1 64 a2 01 c0       	mov    0xc001a264,%eax
c0003ebe:	83 e8 09             	sub    $0x9,%eax
c0003ec1:	83 f8 f5             	cmp    $0xfffffff5,%eax
c0003ec4:	77 31                	ja     c0003ef7 <_ZN2Ec11root_invokeEv+0x2fb>
       trace (0, "disabling super pages for DMAR");
c0003ec6:	8d 44 24 0f          	lea    0xf(%esp),%eax
c0003eca:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0003ecf:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c0003ed4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0003ed9:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0003ee0:	50                   	push   %eax
c0003ee1:	68 97 6b 01 c0       	push   $0xc0016b97
c0003ee6:	e8 f3 da ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c0003eeb:	58                   	pop    %eax
       Dpt::ord = 0x8;
c0003eec:	c7 05 64 a2 01 c0 08 	movl   $0x8,0xc001a264
c0003ef3:	00 00 00 
c0003ef6:	5a                   	pop    %edx
    }

    ret_user_sysexit();
c0003ef7:	e8 04 c1 ff ff       	call   c0000000 <_ZN2Ec16ret_user_sysexitEv>
    bool s = Pd::root.quota.transfer_to(cpus, Cpu::online * 4);
    assert(s);

    /* preserve for the root task memory that is not transferable */
    bool res = Pd::root.quota.set_limit ((1 * 1024 * 1024) >> 12, 0, Pd::root.quota);
    assert (res);
c0003efc:	68 24 6d 01 c0       	push   $0xc0016d24
c0003f01:	68 a0 01 00 00       	push   $0x1a0
c0003f06:	68 8e 6a 01 c0       	push   $0xc0016a8e
c0003f0b:	68 6f 6b 01 c0       	push   $0xc0016b6f
c0003f10:	68 69 60 01 c0       	push   $0xc0016069
c0003f15:	e8 2c da ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

c0003f1a <_ZN2Ec4deadEv>:

        template <bool>
        static void delegate();

        NORETURN
        static void dead() { die ("IPC Abort"); }
c0003f1a:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0003f1f:	8d 50 54             	lea    0x54(%eax),%edx
c0003f22:	b8 bd 6b 01 c0       	mov    $0xc0016bbd,%eax
c0003f27:	e8 e0 fb ff ff       	call   c0003b0c <_ZN2Ec3dieEPKcP8Exc_regs>

c0003f2c <_ZN2Ec17ret_user_vmresumeEv>:
        Sc::schedule();
    }
}

void Ec::ret_user_vmresume()
{
c0003f2c:	57                   	push   %edi
c0003f2d:	83 ec 10             	sub    $0x10,%esp
c0003f30:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
    mword hzd = (Cpu::hazard | current->regs.hazard()) & (HZD_RECALL | HZD_TSC | HZD_RCU | HZD_SCHED);
c0003f35:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
c0003f3b:	0b 05 00 f0 ff cf    	or     0xcffff000,%eax
    if (EXPECT_FALSE (hzd))
c0003f41:	25 11 00 00 a0       	and    $0xa0000011,%eax
c0003f46:	74 0a                	je     c0003f52 <_ZN2Ec17ret_user_vmresumeEv+0x26>
        handle_hazard (hzd, ret_user_vmresume);
c0003f48:	ba 2c 3f 00 c0       	mov    $0xc0003f2c,%edx
c0003f4d:	e8 f4 f8 ff ff       	call   c0003846 <_ZN2Ec13handle_hazardEmPFvvE>

    current->regs.vmcs->make_current();
c0003f52:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0003f57:	8b 40 74             	mov    0x74(%eax),%eax
        }

        ALWAYS_INLINE
        inline void make_current()
        {
            if (EXPECT_TRUE (current == this))
c0003f5a:	39 05 14 f0 ff cf    	cmp    %eax,0xcffff014
c0003f60:	74 31                	je     c0003f93 <_ZN2Ec17ret_user_vmresumeEv+0x67>
                return;

            uint64 phys = Buddy::ptr_to_phys (current = this);
c0003f62:	a3 14 f0 ff cf       	mov    %eax,0xcffff014
c0003f67:	2d 00 00 c0 bf       	sub    $0xbfc00000,%eax
c0003f6c:	89 04 24             	mov    %eax,(%esp)
c0003f6f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0003f76:	00 

            bool ret;
            asm volatile ("vmptrld %1; seta %0" : "=q" (ret) : "m" (phys) : "cc");
c0003f77:	0f c7 34 24          	vmptrld (%esp)
c0003f7b:	0f 97 c0             	seta   %al
            assert (ret);
c0003f7e:	84 c0                	test   %al,%al
c0003f80:	75 11                	jne    c0003f93 <_ZN2Ec17ret_user_vmresumeEv+0x67>
c0003f82:	68 c4 6d 01 c0       	push   $0xc0016dc4
c0003f87:	68 96 01 00 00       	push   $0x196
c0003f8c:	68 13 69 01 c0       	push   $0xc0016913
c0003f91:	eb 7e                	jmp    c0004011 <_ZN2Ec17ret_user_vmresumeEv+0xe5>

    if (EXPECT_FALSE (Pd::current->gtlb.chk (Cpu::id))) {
c0003f93:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
c0003f98:	8b 0d 04 f0 ff cf    	mov    0xcffff004,%ecx
c0003f9e:	8b 90 74 01 00 00    	mov    0x174(%eax),%edx
c0003fa4:	0f a3 ca             	bt     %ecx,%edx
c0003fa7:	0f 83 80 00 00 00    	jae    c000402d <_ZN2Ec17ret_user_vmresumeEv+0x101>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
c0003fad:	ba 01 00 00 00       	mov    $0x1,%edx
c0003fb2:	89 d7                	mov    %edx,%edi
c0003fb4:	d3 e7                	shl    %cl,%edi
c0003fb6:	89 f9                	mov    %edi,%ecx
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
c0003fb8:	f7 d1                	not    %ecx
c0003fba:	f0 21 88 74 01 00 00 	lock and %ecx,0x174(%eax)
        Pd::current->gtlb.clr (Cpu::id);
        if (current->regs.nst_on)
c0003fc1:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0003fc6:	80 b8 94 00 00 00 00 	cmpb   $0x0,0x94(%eax)
c0003fcd:	74 51                	je     c0004020 <_ZN2Ec17ret_user_vmresumeEv+0xf4>
        static inline mword order (mword o) { return o << 8; }

        ALWAYS_INLINE
        inline void flush()
        {
            struct { uint64 eptp, rsvd; } desc = { addr() | (max() - 1) << 3 | 6, 0 };
c0003fcf:	31 c0                	xor    %eax,%eax
c0003fd1:	89 e7                	mov    %esp,%edi
c0003fd3:	b9 04 00 00 00       	mov    $0x4,%ecx
c0003fd8:	f3 ab                	rep stos %eax,%es:(%edi)

        ALWAYS_INLINE
        inline mword attr() const { return static_cast<mword>(val) & PAGE_MASK; }

        ALWAYS_INLINE
        inline Paddr addr() const { return static_cast<Paddr>(val) & ~((1UL << order()) - 1); }
c0003fda:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c0003fdf:	8b 80 60 01 00 00    	mov    0x160(%eax),%eax
c0003fe5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0003fec:	00 
c0003fed:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0003ff2:	83 c8 1e             	or     $0x1e,%eax
c0003ff5:	89 04 24             	mov    %eax,(%esp)

            bool ret;
            asm volatile ("invept %1, %2; seta %0" : "=q" (ret) : "m" (desc), "r" (1UL) : "cc", "memory");
c0003ff8:	66 0f 38 80 14 24    	invept (%esp),%edx
c0003ffe:	0f 97 c2             	seta   %dl
            assert (ret);
c0004001:	84 d2                	test   %dl,%dl
c0004003:	75 28                	jne    c000402d <_ZN2Ec17ret_user_vmresumeEv+0x101>
c0004005:	68 44 6d 01 c0       	push   $0xc0016d44
c000400a:	6a 3c                	push   $0x3c
c000400c:	68 c7 6b 01 c0       	push   $0xc0016bc7
c0004011:	68 83 69 01 c0       	push   $0xc0016983
c0004016:	68 69 60 01 c0       	push   $0xc0016069
c000401b:	e8 26 d9 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>
            Pd::current->ept.flush();
        else
            current->regs.vtlb->flush (true);
c0004020:	8b 40 78             	mov    0x78(%eax),%eax
c0004023:	ba 01 00 00 00       	mov    $0x1,%edx
c0004028:	e8 df 1c 01 00       	call   c0015d0c <_ZN4Vtlb5flushEb>

ALWAYS_INLINE
static inline mword get_cr2()
{
    mword cr2;
    asm volatile ("mov %%cr2, %0" : "=r" (cr2));
c000402d:	0f 20 d1             	mov    %cr2,%ecx
    }

    if (EXPECT_FALSE (get_cr2() != current->regs.cr2))
c0004030:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0004035:	8b 50 60             	mov    0x60(%eax),%edx
c0004038:	39 d1                	cmp    %edx,%ecx
c000403a:	74 03                	je     c000403f <_ZN2Ec17ret_user_vmresumeEv+0x113>
}

ALWAYS_INLINE
static inline void set_cr2 (mword cr2)
{
    asm volatile ("mov %0, %%cr2" : : "r" (cr2));
c000403c:	0f 22 d2             	mov    %edx,%cr2

    asm volatile ("lea %0," EXPAND (PREG(sp); LOAD_GPR)
                  "vmresume;"
                  "vmlaunch;"
                  "mov %1," EXPAND (PREG(sp);)
                  : : "m" (current->regs), "i" (CPU_LOCAL_STCK + PAGE_SIZE) : "memory");
c000403f:	8d 60 54             	lea    0x54(%eax),%esp
c0004042:	61                   	popa   
c0004043:	0f 01 c3             	vmresume 
c0004046:	0f 01 c2             	vmlaunch 
c0004049:	bc 00 e0 ff cf       	mov    $0xcfffe000,%esp

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
c000404e:	ba 00 44 00 00       	mov    $0x4400,%edx
c0004053:	0f 78 d2             	vmread %edx,%edx

    trace (0, "VM entry failed with error %#lx", Vmcs::read (Vmcs::VMX_INST_ERROR));
c0004056:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c000405a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c000405f:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c0004064:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0004069:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0004070:	52                   	push   %edx
c0004071:	50                   	push   %eax
c0004072:	68 37 6c 01 c0       	push   $0xc0016c37
c0004077:	e8 62 d9 ff ff       	call   c00019de <_ZN7Console5printEPKcz>

    die ("VMENTRY");
c000407c:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0004081:	8d 50 54             	lea    0x54(%eax),%edx
c0004084:	b8 5e 6c 01 c0       	mov    $0xc0016c5e,%eax
c0004089:	e8 7e fa ff ff       	call   c0003b0c <_ZN2Ec3dieEPKcP8Exc_regs>

c000408e <_ZN2Ec11xcpu_returnEv>:

    reply (dead);
}

void Ec::xcpu_return()
{
c000408e:	55                   	push   %ebp
c000408f:	57                   	push   %edi
c0004090:	56                   	push   %esi
c0004091:	53                   	push   %ebx
c0004092:	56                   	push   %esi
    assert (current->xcpu_sm);
c0004093:	8b 15 08 f0 ff cf    	mov    0xcffff008,%edx
c0004099:	83 ba f4 00 00 00 00 	cmpl   $0x0,0xf4(%edx)
c00040a0:	75 16                	jne    c00040b8 <_ZN2Ec11xcpu_returnEv+0x2a>
c00040a2:	68 dc 6c 01 c0       	push   $0xc0016cdc
c00040a7:	68 d4 01 00 00       	push   $0x1d4
c00040ac:	68 8e 6a 01 c0       	push   $0xc0016a8e
c00040b1:	68 66 6c 01 c0       	push   $0xc0016c66
c00040b6:	eb 1e                	jmp    c00040d6 <_ZN2Ec11xcpu_returnEv+0x48>
    assert (current->rcap);
c00040b8:	8b ba b0 00 00 00    	mov    0xb0(%edx),%edi
c00040be:	85 ff                	test   %edi,%edi
c00040c0:	75 1e                	jne    c00040e0 <_ZN2Ec11xcpu_returnEv+0x52>
c00040c2:	68 dc 6c 01 c0       	push   $0xc0016cdc
c00040c7:	68 d5 01 00 00       	push   $0x1d5
c00040cc:	68 8e 6a 01 c0       	push   $0xc0016a8e
c00040d1:	68 77 6c 01 c0       	push   $0xc0016c77
c00040d6:	68 69 60 01 c0       	push   $0xc0016069
c00040db:	e8 66 d8 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>
    assert (current->utcb);
c00040e0:	83 ba b4 00 00 00 00 	cmpl   $0x0,0xb4(%edx)
c00040e7:	75 16                	jne    c00040ff <_ZN2Ec11xcpu_returnEv+0x71>
c00040e9:	68 dc 6c 01 c0       	push   $0xc0016cdc
c00040ee:	68 d6 01 00 00       	push   $0x1d6
c00040f3:	68 8e 6a 01 c0       	push   $0xc0016a8e
c00040f8:	68 85 6c 01 c0       	push   $0xc0016c85
c00040fd:	eb d7                	jmp    c00040d6 <_ZN2Ec11xcpu_returnEv+0x48>
{
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
c00040ff:	a1 10 f0 ff cf       	mov    0xcffff010,%eax
c0004104:	8b 40 4c             	mov    0x4c(%eax),%eax
    assert (Sc::current->ec == current);
c0004107:	39 d0                	cmp    %edx,%eax
c0004109:	74 16                	je     c0004121 <_ZN2Ec11xcpu_returnEv+0x93>
c000410b:	68 dc 6c 01 c0       	push   $0xc0016cdc
c0004110:	68 d7 01 00 00       	push   $0x1d7
c0004115:	68 8e 6a 01 c0       	push   $0xc0016a8e
c000411a:	68 93 6c 01 c0       	push   $0xc0016c93
c000411f:	eb b5                	jmp    c00040d6 <_ZN2Ec11xcpu_returnEv+0x48>

    current->rcap->regs =  current->regs;
c0004121:	83 c7 54             	add    $0x54,%edi
c0004124:	b9 17 00 00 00       	mov    $0x17,%ecx
c0004129:	8d 70 54             	lea    0x54(%eax),%esi
c000412c:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)

    current->xcpu_sm->up (ret_xcpu_reply);
c000412e:	8b b8 f4 00 00 00    	mov    0xf4(%eax),%edi
        ALWAYS_INLINE
        inline void up (void (*c)() = nullptr, Sm * si = nullptr)
        {
            Ec *ec;

            {   Lock_guard <Spinlock> guard (lock);
c0004134:	8d 47 46             	lea    0x46(%edi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c0004137:	9c                   	pushf  
c0004138:	5b                   	pop    %ebx
            return flags & 0x200;
c0004139:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c000413c:	80 e3 01             	and    $0x1,%bl
c000413f:	74 2a                	je     c000416b <_ZN2Ec11xcpu_returnEv+0xdd>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0004141:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0004148:	75 19                	jne    c0004163 <_ZN2Ec11xcpu_returnEv+0xd5>
c000414a:	68 a0 6d 01 c0       	push   $0xc0016da0
c000414f:	68 b7 00 00 00       	push   $0xb7
c0004154:	68 12 61 01 c0       	push   $0xc0016112
c0004159:	68 83 61 01 c0       	push   $0xc0016183
c000415e:	e9 73 ff ff ff       	jmp    c00040d6 <_ZN2Ec11xcpu_returnEv+0x48>

            asm volatile ("cli" : : : "memory");
c0004163:	fa                   	cli    
            preemption = false;
c0004164:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c000416b:	e8 bc c9 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c0004170:	8b 77 4c             	mov    0x4c(%edi),%esi
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c0004173:	85 f6                	test   %esi,%esi
c0004175:	0f 84 93 01 00 00    	je     c000430e <_ZN2Ec11xcpu_returnEv+0x280>
c000417b:	8b 86 c4 00 00 00    	mov    0xc4(%esi),%eax
c0004181:	85 c0                	test   %eax,%eax
c0004183:	0f 84 85 01 00 00    	je     c000430e <_ZN2Ec11xcpu_returnEv+0x280>
c0004189:	8b 96 c0 00 00 00    	mov    0xc0(%esi),%edx
c000418f:	85 d2                	test   %edx,%edx
c0004191:	0f 84 77 01 00 00    	je     c000430e <_ZN2Ec11xcpu_returnEv+0x280>
                return false;

            if (t == t->next)
c0004197:	39 c6                	cmp    %eax,%esi
c0004199:	75 09                	jne    c00041a4 <_ZN2Ec11xcpu_returnEv+0x116>
                headptr = nullptr;
c000419b:	c7 47 4c 00 00 00 00 	movl   $0x0,0x4c(%edi)
c00041a2:	eb 26                	jmp    c00041ca <_ZN2Ec11xcpu_returnEv+0x13c>

            else {
                t->next->prev = t->prev;
c00041a4:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
                t->prev->next = t->next;
c00041aa:	8b 86 c0 00 00 00    	mov    0xc0(%esi),%eax
c00041b0:	8b 96 c4 00 00 00    	mov    0xc4(%esi),%edx
c00041b6:	89 90 c4 00 00 00    	mov    %edx,0xc4(%eax)
                if (t == headptr)
c00041bc:	3b 77 4c             	cmp    0x4c(%edi),%esi
c00041bf:	75 09                	jne    c00041ca <_ZN2Ec11xcpu_returnEv+0x13c>
                    headptr = t->next;
c00041c1:	8b 86 c4 00 00 00    	mov    0xc4(%esi),%eax
c00041c7:	89 47 4c             	mov    %eax,0x4c(%edi)
            }

            t->next = t->prev = nullptr;
c00041ca:	c7 86 c0 00 00 00 00 	movl   $0x0,0xc0(%esi)
c00041d1:	00 00 00 
        }

        ALWAYS_INLINE
        inline bool del_ref()
        {
            return Atomic::sub (ref, 1U) == 0;
c00041d4:	8d 6e 48             	lea    0x48(%esi),%ebp
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c00041d7:	83 c8 ff             	or     $0xffffffff,%eax
c00041da:	c7 86 c4 00 00 00 00 	movl   $0x0,0xc4(%esi)
c00041e1:	00 00 00 
c00041e4:	f0 0f c1 45 00       	lock xadd %eax,0x0(%ebp)

                    counter++;
                    return;
                }

                if (EXPECT_FALSE(ec->del_ref())) {
c00041e9:	48                   	dec    %eax
c00041ea:	75 24                	jne    c0004210 <_ZN2Ec11xcpu_returnEv+0x182>
                    delete ec;
c00041ec:	89 f0                	mov    %esi,%eax
c00041ee:	e8 1b f3 ff ff       	call   c000350e <_ZN2EcD1Ev>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c00041f3:	8b 86 b8 00 00 00    	mov    0xb8(%esi),%eax
c00041f9:	89 f2                	mov    %esi,%edx
c00041fb:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c0004201:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c0004206:	e8 55 c1 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
c000420b:	e9 60 ff ff ff       	jmp    c0004170 <_ZN2Ec11xcpu_returnEv+0xe2>
        }

        ALWAYS_INLINE
        inline void unlock()
        {
            asm volatile ("incb %0" : "=m" (val) : : "memory");
c0004210:	fe 47 46             	incb   0x46(%edi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c0004213:	84 db                	test   %bl,%bl
c0004215:	74 2a                	je     c0004241 <_ZN2Ec11xcpu_returnEv+0x1b3>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0004217:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000421e:	74 19                	je     c0004239 <_ZN2Ec11xcpu_returnEv+0x1ab>
c0004220:	68 60 6d 01 c0       	push   $0xc0016d60
c0004225:	68 c0 00 00 00       	push   $0xc0
c000422a:	68 12 61 01 c0       	push   $0xc0016112
c000422f:	68 82 61 01 c0       	push   $0xc0016182
c0004234:	e9 9d fe ff ff       	jmp    c00040d6 <_ZN2Ec11xcpu_returnEv+0x48>

            preemption = true;
c0004239:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c0004240:	fb                   	sti    

        ALWAYS_INLINE
        inline void release (void (*c)())
        {
            if (c)
                cont = c;
c0004241:	c7 46 50 64 16 01 c0 	movl   $0xc0011664,0x50(%esi)

            Lock_guard <Spinlock> guard (lock);
c0004248:	8d 46 46             	lea    0x46(%esi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c000424b:	9c                   	pushf  
c000424c:	5b                   	pop    %ebx
            return flags & 0x200;
c000424d:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c0004250:	80 e3 01             	and    $0x1,%bl
c0004253:	74 15                	je     c000426a <_ZN2Ec11xcpu_returnEv+0x1dc>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0004255:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000425c:	0f 84 e8 fe ff ff    	je     c000414a <_ZN2Ec11xcpu_returnEv+0xbc>

            asm volatile ("cli" : : : "memory");
c0004262:	fa                   	cli    
            preemption = false;
c0004263:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c000426a:	e8 bd c8 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c000426f:	8b 7e 4c             	mov    0x4c(%esi),%edi
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c0004272:	85 ff                	test   %edi,%edi
c0004274:	0f 84 a8 00 00 00    	je     c0004322 <_ZN2Ec11xcpu_returnEv+0x294>
c000427a:	8b 47 74             	mov    0x74(%edi),%eax
c000427d:	85 c0                	test   %eax,%eax
c000427f:	0f 84 9d 00 00 00    	je     c0004322 <_ZN2Ec11xcpu_returnEv+0x294>
c0004285:	8b 57 70             	mov    0x70(%edi),%edx
c0004288:	85 d2                	test   %edx,%edx
c000428a:	0f 84 92 00 00 00    	je     c0004322 <_ZN2Ec11xcpu_returnEv+0x294>
                return false;

            if (t == t->next)
c0004290:	39 c7                	cmp    %eax,%edi
c0004292:	75 09                	jne    c000429d <_ZN2Ec11xcpu_returnEv+0x20f>
                headptr = nullptr;
c0004294:	c7 46 4c 00 00 00 00 	movl   $0x0,0x4c(%esi)
c000429b:	eb 17                	jmp    c00042b4 <_ZN2Ec11xcpu_returnEv+0x226>

            else {
                t->next->prev = t->prev;
c000429d:	89 50 70             	mov    %edx,0x70(%eax)
                t->prev->next = t->next;
c00042a0:	8b 47 70             	mov    0x70(%edi),%eax
c00042a3:	8b 57 74             	mov    0x74(%edi),%edx
c00042a6:	89 50 74             	mov    %edx,0x74(%eax)
                if (t == headptr)
c00042a9:	3b 7e 4c             	cmp    0x4c(%esi),%edi
c00042ac:	75 06                	jne    c00042b4 <_ZN2Ec11xcpu_returnEv+0x226>
                    headptr = t->next;
c00042ae:	8b 47 74             	mov    0x74(%edi),%eax
c00042b1:	89 46 4c             	mov    %eax,0x4c(%esi)
            }

            t->next = t->prev = nullptr;
c00042b4:	c7 47 70 00 00 00 00 	movl   $0x0,0x70(%edi)
c00042bb:	83 c8 ff             	or     $0xffffffff,%eax
c00042be:	c7 47 74 00 00 00 00 	movl   $0x0,0x74(%edi)
c00042c5:	f0 0f c1 47 48       	lock xadd %eax,0x48(%edi)

            for (Sc *s; dequeue (s = head()); ) {
                if (EXPECT_FALSE(s->del_ref()) && (this == s->ec)) {
c00042ca:	48                   	dec    %eax
c00042cb:	75 49                	jne    c0004316 <_ZN2Ec11xcpu_returnEv+0x288>
c00042cd:	3b 77 4c             	cmp    0x4c(%edi),%esi
c00042d0:	75 44                	jne    c0004316 <_ZN2Ec11xcpu_returnEv+0x288>
c00042d2:	83 c8 ff             	or     $0xffffffff,%eax
c00042d5:	f0 0f c1 45 00       	lock xadd %eax,0x0(%ebp)
        inline Refptr (T *p) : ptr (p->add_ref() ? p : nullptr) {}

        ALWAYS_INLINE
        inline ~Refptr()
        {
            if (ptr && ptr->del_ref())
c00042da:	48                   	dec    %eax
c00042db:	75 25                	jne    c0004302 <_ZN2Ec11xcpu_returnEv+0x274>
                delete ptr;
c00042dd:	8b 47 4c             	mov    0x4c(%edi),%eax
c00042e0:	85 c0                	test   %eax,%eax
c00042e2:	74 1e                	je     c0004302 <_ZN2Ec11xcpu_returnEv+0x274>
c00042e4:	e8 25 f2 ff ff       	call   c000350e <_ZN2EcD1Ev>
c00042e9:	8b 57 4c             	mov    0x4c(%edi),%edx

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c00042ec:	8b 82 b8 00 00 00    	mov    0xb8(%edx),%eax
c00042f2:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c00042f8:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c00042fd:	e8 5e c0 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>

            Lock_guard <Spinlock> guard (lock);

            for (Sc *s; dequeue (s = head()); ) {
                if (EXPECT_FALSE(s->del_ref()) && (this == s->ec)) {
                    delete s;
c0004302:	89 f8                	mov    %edi,%eax
c0004304:	e8 3c b6 00 00       	call   c000f945 <_ZN2ScdlEPv>
c0004309:	e9 61 ff ff ff       	jmp    c000426f <_ZN2Ec11xcpu_returnEv+0x1e1>
                    if (si) {
                       if (si->queued()) return;
                       Queue<Si>::enqueue(si);
                    }

                    counter++;
c000430e:	ff 47 64             	incl   0x64(%edi)
c0004311:	fe 47 46             	incb   0x46(%edi)
c0004314:	eb 0f                	jmp    c0004325 <_ZN2Ec11xcpu_returnEv+0x297>
                    continue;
                }
                s->remote_enqueue();
c0004316:	89 f8                	mov    %edi,%eax
c0004318:	e8 1f b4 00 00       	call   c000f73c <_ZN2Sc14remote_enqueueEv>
c000431d:	e9 4d ff ff ff       	jmp    c000426f <_ZN2Ec11xcpu_returnEv+0x1e1>
c0004322:	fe 46 46             	incb   0x46(%esi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c0004325:	84 db                	test   %bl,%bl
c0004327:	74 15                	je     c000433e <_ZN2Ec11xcpu_returnEv+0x2b0>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0004329:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0004330:	0f 85 ea fe ff ff    	jne    c0004220 <_ZN2Ec11xcpu_returnEv+0x192>

            preemption = true;
c0004336:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000433d:	fb                   	sti    

    current->rcap    = nullptr;
c000433e:	8b 1d 08 f0 ff cf    	mov    0xcffff008,%ebx
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
c0004344:	8b 53 14             	mov    0x14(%ebx),%edx
    current->utcb    = nullptr;
    current->fpu     = nullptr;

    Rcu::call(current);
c0004347:	8d 73 0c             	lea    0xc(%ebx),%esi

    current->rcap->regs =  current->regs;

    current->xcpu_sm->up (ret_xcpu_reply);

    current->rcap    = nullptr;
c000434a:	c7 83 b0 00 00 00 00 	movl   $0x0,0xb0(%ebx)
c0004351:	00 00 00 
    current->utcb    = nullptr;
c0004354:	c7 83 b4 00 00 00 00 	movl   $0x0,0xb4(%ebx)
c000435b:	00 00 00 
    current->fpu     = nullptr;
c000435e:	c7 83 c8 00 00 00 00 	movl   $0x0,0xc8(%ebx)
c0004365:	00 00 00 
c0004368:	85 d2                	test   %edx,%edx
c000436a:	74 04                	je     c0004370 <_ZN2Ec11xcpu_returnEv+0x2e2>
                e->pre_func(e);
c000436c:	89 f0                	mov    %esi,%eax
c000436e:	ff d2                	call   *%edx
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
c0004370:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
c0004374:	75 09                	jne    c000437f <_ZN2Ec11xcpu_returnEv+0x2f1>
c0004376:	a1 f0 f7 ff cf       	mov    0xcffff7f0,%eax
c000437b:	39 f0                	cmp    %esi,%eax
c000437d:	75 29                	jne    c00043a8 <_ZN2Ec11xcpu_returnEv+0x31a>
                trace (0, "warning: rcu element already enqueued");
c000437f:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c0004383:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0004388:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c000438d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0004392:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0004399:	50                   	push   %eax
c000439a:	68 ae 6c 01 c0       	push   $0xc0016cae
c000439f:	e8 3a d6 ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c00043a4:	59                   	pop    %ecx
c00043a5:	5b                   	pop    %ebx
c00043a6:	eb 0e                	jmp    c00043b6 <_ZN2Ec11xcpu_returnEv+0x328>
                return;
            }

            count ++;
c00043a8:	ff 05 f4 f7 ff cf    	incl   0xcffff7f4

           *tail = e;
c00043ae:	89 30                	mov    %esi,(%eax)
            tail = &e->next;
c00043b0:	89 35 f0 f7 ff cf    	mov    %esi,0xcffff7f0

    Rcu::call(current);
    Rcu::call(Sc::current);
c00043b6:	8b 35 10 f0 ff cf    	mov    0xcffff010,%esi
c00043bc:	85 f6                	test   %esi,%esi
c00043be:	74 63                	je     c0004423 <_ZN2Ec11xcpu_returnEv+0x395>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
c00043c0:	8b 56 14             	mov    0x14(%esi),%edx
c00043c3:	8d 5e 0c             	lea    0xc(%esi),%ebx
c00043c6:	85 d2                	test   %edx,%edx
c00043c8:	74 04                	je     c00043ce <_ZN2Ec11xcpu_returnEv+0x340>
                e->pre_func(e);
c00043ca:	89 d8                	mov    %ebx,%eax
c00043cc:	ff d2                	call   *%edx
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
c00043ce:	83 7e 0c 00          	cmpl   $0x0,0xc(%esi)
c00043d2:	75 09                	jne    c00043dd <_ZN2Ec11xcpu_returnEv+0x34f>
c00043d4:	a1 f0 f7 ff cf       	mov    0xcffff7f0,%eax
c00043d9:	39 d8                	cmp    %ebx,%eax
c00043db:	75 29                	jne    c0004406 <_ZN2Ec11xcpu_returnEv+0x378>
                trace (0, "warning: rcu element already enqueued");
c00043dd:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c00043e1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c00043e6:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c00043eb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00043f0:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c00043f7:	50                   	push   %eax
c00043f8:	68 ae 6c 01 c0       	push   $0xc0016cae
c00043fd:	e8 dc d5 ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c0004402:	58                   	pop    %eax
c0004403:	5a                   	pop    %edx
c0004404:	eb 0e                	jmp    c0004414 <_ZN2Ec11xcpu_returnEv+0x386>
                return;
            }

            count ++;
c0004406:	ff 05 f4 f7 ff cf    	incl   0xcffff7f4

           *tail = e;
c000440c:	89 18                	mov    %ebx,(%eax)
            tail = &e->next;
c000440e:	89 1d f0 f7 ff cf    	mov    %ebx,0xcffff7f0

    Sc::schedule(true);
c0004414:	ba 01 00 00 00       	mov    $0x1,%edx
c0004419:	b8 01 00 00 00       	mov    $0x1,%eax
c000441e:	e8 8f b5 00 00       	call   c000f9b2 <_ZN2Sc8scheduleEbb>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
c0004423:	a1 08 00 00 00       	mov    0x8,%eax
c0004428:	0f 0b                	ud2    

c000442a <_ZN2Ec11idl_handlerEv>:
}

void Ec::idl_handler()
{
    if (Ec::current->cont == Ec::idle)
c000442a:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c000442f:	81 78 50 06 3a 00 c0 	cmpl   $0xc0003a06,0x50(%eax)
c0004436:	75 05                	jne    c000443d <_ZN2Ec11idl_handlerEv+0x13>
        Rcu::update();
c0004438:	e9 63 9e 00 00       	jmp    c000e2a0 <_ZN3Rcu6updateEv>
c000443d:	c3                   	ret    

c000443e <_GLOBAL__sub_I.00102__ZN2Ec5cacheE>:
#include "vtlb.hpp"
#include "sm.hpp"
#include "pt.hpp"

INIT_PRIORITY (PRIO_SLAB)
Slab_cache Ec::cache (sizeof (Ec), 32);
c000443e:	b9 20 00 00 00       	mov    $0x20,%ecx
c0004443:	ba 00 01 00 00       	mov    $0x100,%edx
c0004448:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c000444d:	e9 b4 bd 00 00       	jmp    c0010206 <_ZN10Slab_cacheC1Emj>

c0004452 <_ZN2Ec8load_fpuEv>:
#include "gdt.hpp"
#include "mca.hpp"
#include "stdio.hpp"

void Ec::load_fpu()
{
c0004452:	53                   	push   %ebx
c0004453:	89 c3                	mov    %eax,%ebx
    if (!utcb)
c0004455:	83 b8 b4 00 00 00 00 	cmpl   $0x0,0xb4(%eax)
c000445c:	75 0d                	jne    c000446b <_ZN2Ec8load_fpuEv+0x19>
        regs.fpu_ctrl (true);
c000445e:	8d 40 54             	lea    0x54(%eax),%eax
c0004461:	ba 01 00 00 00       	mov    $0x1,%edx
c0004466:	e8 2d a6 00 00       	call   c000ea98 <_ZN8Exc_regs8fpu_ctrlEb>

    if (EXPECT_FALSE (!fpu))
c000446b:	8b 83 c8 00 00 00    	mov    0xc8(%ebx),%eax
c0004471:	85 c0                	test   %eax,%eax
c0004473:	75 04                	jne    c0004479 <_ZN2Ec8load_fpuEv+0x27>

        ALWAYS_INLINE
        inline void load() { asm volatile ("fxrstor %0" : : "m" (*data)); }

        ALWAYS_INLINE
        static inline void init() { asm volatile ("fninit"); }
c0004475:	db e3                	fninit 
c0004477:	eb 03                	jmp    c000447c <_ZN2Ec8load_fpuEv+0x2a>
    public:
        ALWAYS_INLINE
        inline void save() { asm volatile ("fxsave %0" : "=m" (*data)); }

        ALWAYS_INLINE
        inline void load() { asm volatile ("fxrstor %0" : : "m" (*data)); }
c0004479:	0f ae 08             	fxrstor (%eax)
        Fpu::init();
    else
        fpu->load();
}
c000447c:	5b                   	pop    %ebx
c000447d:	c3                   	ret    

c000447e <_ZN2Ec8save_fpuEv>:

void Ec::save_fpu()
{
    if (EXPECT_FALSE (!this))
c000447e:	85 c0                	test   %eax,%eax
c0004480:	74 45                	je     c00044c7 <_ZN2Ec8save_fpuEv+0x49>
    else
        fpu->load();
}

void Ec::save_fpu()
{
c0004482:	53                   	push   %ebx
c0004483:	89 c3                	mov    %eax,%ebx
    if (EXPECT_FALSE (!this))
        return;

    if (!utcb)
c0004485:	83 b8 b4 00 00 00 00 	cmpl   $0x0,0xb4(%eax)
c000448c:	75 0a                	jne    c0004498 <_ZN2Ec8save_fpuEv+0x1a>
        regs.fpu_ctrl (false);
c000448e:	8d 40 54             	lea    0x54(%eax),%eax
c0004491:	31 d2                	xor    %edx,%edx
c0004493:	e8 00 a6 00 00       	call   c000ea98 <_ZN8Exc_regs8fpu_ctrlEb>

    if (EXPECT_FALSE (!fpu))
c0004498:	83 bb c8 00 00 00 00 	cmpl   $0x0,0xc8(%ebx)
c000449f:	75 1c                	jne    c00044bd <_ZN2Ec8save_fpuEv+0x3f>
        fpu = new (pd->quota) Fpu;
c00044a1:	8b 83 b8 00 00 00    	mov    0xb8(%ebx),%eax
c00044a7:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx

        ALWAYS_INLINE
        static inline void disable() { set_cr0 (get_cr0() | Cpu::CR0_TS); Cpu::hazard &= ~HZD_FPU; }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
c00044ad:	b8 84 a4 01 c0       	mov    $0xc001a484,%eax
c00044b2:	e8 bf bd 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c00044b7:	89 83 c8 00 00 00    	mov    %eax,0xc8(%ebx)

    fpu->save();
c00044bd:	8b 83 c8 00 00 00    	mov    0xc8(%ebx),%eax

        static Slab_cache cache;

    public:
        ALWAYS_INLINE
        inline void save() { asm volatile ("fxsave %0" : "=m" (*data)); }
c00044c3:	0f ae 00             	fxsave (%eax)
}
c00044c6:	5b                   	pop    %ebx
c00044c7:	c3                   	ret    

c00044c8 <_ZN2Ec12transfer_fpuEPS_>:

void Ec::transfer_fpu (Ec *ec)
{
c00044c8:	56                   	push   %esi
c00044c9:	53                   	push   %ebx
    if ((!utcb && !regs.fpu_on) ||
c00044ca:	83 b8 b4 00 00 00 00 	cmpl   $0x0,0xb4(%eax)
c00044d1:	75 0d                	jne    c00044e0 <_ZN2Ec12transfer_fpuEPS_+0x18>
c00044d3:	80 b8 95 00 00 00 00 	cmpb   $0x0,0x95(%eax)
c00044da:	0f 84 96 00 00 00    	je     c0004576 <_ZN2Ec12transfer_fpuEPS_+0xae>
c00044e0:	83 ba b4 00 00 00 00 	cmpl   $0x0,0xb4(%edx)
c00044e7:	75 0d                	jne    c00044f6 <_ZN2Ec12transfer_fpuEPS_+0x2e>
        (!ec->utcb && !ec->regs.fpu_on))
c00044e9:	80 ba 95 00 00 00 00 	cmpb   $0x0,0x95(%edx)
c00044f0:	0f 84 80 00 00 00    	je     c0004576 <_ZN2Ec12transfer_fpuEPS_+0xae>
c00044f6:	89 c6                	mov    %eax,%esi
      return;

    if (!(Cpu::hazard & HZD_FPU)) {
c00044f8:	a1 00 f0 ff cf       	mov    0xcffff000,%eax
c00044fd:	89 d3                	mov    %edx,%ebx
c00044ff:	a8 08                	test   $0x8,%al
c0004501:	75 1f                	jne    c0004522 <_ZN2Ec12transfer_fpuEPS_+0x5a>

        ALWAYS_INLINE
        static inline void init() { asm volatile ("fninit"); }

        ALWAYS_INLINE
        static inline void enable() { asm volatile ("clts"); Cpu::hazard |= HZD_FPU; }
c0004503:	0f 06                	clts   
c0004505:	83 c8 08             	or     $0x8,%eax
c0004508:	a3 00 f0 ff cf       	mov    %eax,0xcffff000

        Fpu::enable();

        if (fpowner != this) {
c000450d:	a1 7c f7 ff cf       	mov    0xcffff77c,%eax
c0004512:	39 f0                	cmp    %esi,%eax
c0004514:	74 0c                	je     c0004522 <_ZN2Ec12transfer_fpuEPS_+0x5a>
            fpowner->save_fpu();
c0004516:	e8 63 ff ff ff       	call   c000447e <_ZN2Ec8save_fpuEv>
            load_fpu();
c000451b:	89 f0                	mov    %esi,%eax
c000451d:	e8 30 ff ff ff       	call   c0004452 <_ZN2Ec8load_fpuEv>
        }
    }

    if (fpowner && fpowner->del_ref())
c0004522:	a1 7c f7 ff cf       	mov    0xcffff77c,%eax
c0004527:	85 c0                	test   %eax,%eax
c0004529:	74 34                	je     c000455f <_ZN2Ec12transfer_fpuEPS_+0x97>
c000452b:	83 ca ff             	or     $0xffffffff,%edx
c000452e:	f0 0f c1 50 48       	lock xadd %edx,0x48(%eax)
c0004533:	4a                   	dec    %edx
c0004534:	75 29                	jne    c000455f <_ZN2Ec12transfer_fpuEPS_+0x97>
        delete fpowner;
c0004536:	8b 35 7c f7 ff cf    	mov    0xcffff77c,%esi
c000453c:	85 f6                	test   %esi,%esi
c000453e:	74 1f                	je     c000455f <_ZN2Ec12transfer_fpuEPS_+0x97>
c0004540:	89 f0                	mov    %esi,%eax
c0004542:	e8 c7 ef ff ff       	call   c000350e <_ZN2EcD1Ev>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c0004547:	8b 86 b8 00 00 00    	mov    0xb8(%esi),%eax
c000454d:	89 f2                	mov    %esi,%edx
c000454f:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c0004555:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c000455a:	e8 01 be 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>

    fpowner = ec;
c000455f:	89 1d 7c f7 ff cf    	mov    %ebx,0xcffff77c
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0004565:	8b 43 48             	mov    0x48(%ebx),%eax
c0004568:	85 c0                	test   %eax,%eax
c000456a:	74 0a                	je     c0004576 <_ZN2Ec12transfer_fpuEPS_+0xae>
                if (Atomic::cmp_swap (ref, r, r + 1))
c000456c:	8d 50 01             	lea    0x1(%eax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c000456f:	f0 0f b1 53 48       	lock cmpxchg %edx,0x48(%ebx)
c0004574:	75 ef                	jne    c0004565 <_ZN2Ec12transfer_fpuEPS_+0x9d>
    fpowner->add_ref();
}
c0004576:	5b                   	pop    %ebx
c0004577:	5e                   	pop    %esi
c0004578:	c3                   	ret    
c0004579:	90                   	nop

c000457a <_ZN2Ec13handle_exc_nmEv>:
c000457a:	0f 06                	clts   

void Ec::handle_exc_nm()
{
    Fpu::enable();

    if (current == fpowner)
c000457c:	a1 7c f7 ff cf       	mov    0xcffff77c,%eax
c0004581:	83 0d 00 f0 ff cf 08 	orl    $0x8,0xcffff000
c0004588:	39 05 08 f0 ff cf    	cmp    %eax,0xcffff008
c000458e:	74 6b                	je     c00045fb <_ZN2Ec13handle_exc_nmEv+0x81>
    fpowner = ec;
    fpowner->add_ref();
}

void Ec::handle_exc_nm()
{
c0004590:	53                   	push   %ebx
    Fpu::enable();

    if (current == fpowner)
        return;

    fpowner->save_fpu();
c0004591:	e8 e8 fe ff ff       	call   c000447e <_ZN2Ec8save_fpuEv>
    current->load_fpu();
c0004596:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c000459b:	e8 b2 fe ff ff       	call   c0004452 <_ZN2Ec8load_fpuEv>

    if (fpowner && fpowner->del_ref())
c00045a0:	a1 7c f7 ff cf       	mov    0xcffff77c,%eax
c00045a5:	85 c0                	test   %eax,%eax
c00045a7:	74 34                	je     c00045dd <_ZN2Ec13handle_exc_nmEv+0x63>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c00045a9:	83 ca ff             	or     $0xffffffff,%edx
c00045ac:	f0 0f c1 50 48       	lock xadd %edx,0x48(%eax)
c00045b1:	4a                   	dec    %edx
c00045b2:	75 29                	jne    c00045dd <_ZN2Ec13handle_exc_nmEv+0x63>
        delete fpowner;
c00045b4:	8b 1d 7c f7 ff cf    	mov    0xcffff77c,%ebx
c00045ba:	85 db                	test   %ebx,%ebx
c00045bc:	74 1f                	je     c00045dd <_ZN2Ec13handle_exc_nmEv+0x63>
c00045be:	89 d8                	mov    %ebx,%eax
c00045c0:	e8 49 ef ff ff       	call   c000350e <_ZN2EcD1Ev>
c00045c5:	8b 83 b8 00 00 00    	mov    0xb8(%ebx),%eax
c00045cb:	89 da                	mov    %ebx,%edx
c00045cd:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c00045d3:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c00045d8:	e8 83 bd 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>

    fpowner = current;
c00045dd:	8b 15 08 f0 ff cf    	mov    0xcffff008,%edx
c00045e3:	89 15 7c f7 ff cf    	mov    %edx,0xcffff77c
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c00045e9:	8b 42 48             	mov    0x48(%edx),%eax
c00045ec:	85 c0                	test   %eax,%eax
c00045ee:	74 0a                	je     c00045fa <_ZN2Ec13handle_exc_nmEv+0x80>
                if (Atomic::cmp_swap (ref, r, r + 1))
c00045f0:	8d 48 01             	lea    0x1(%eax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c00045f3:	f0 0f b1 4a 48       	lock cmpxchg %ecx,0x48(%edx)
c00045f8:	75 ef                	jne    c00045e9 <_ZN2Ec13handle_exc_nmEv+0x6f>
    fpowner->add_ref();
}
c00045fa:	5b                   	pop    %ebx
c00045fb:	c3                   	ret    

c00045fc <_ZN2Ec13handle_exc_tsEP8Exc_regs>:

bool Ec::handle_exc_ts (Exc_regs *r)
{
    if (r->user())
c00045fc:	f6 40 3c 03          	testb  $0x3,0x3c(%eax)
c0004600:	75 0a                	jne    c000460c <_ZN2Ec13handle_exc_tsEP8Exc_regs+0x10>
        return false;

    // SYSENTER with EFLAGS.NT=1 and IRET faulted
    r->REG(fl) &= ~Cpu::EFL_NT;
c0004602:	81 60 40 ff bf ff ff 	andl   $0xffffbfff,0x40(%eax)

    return true;
c0004609:	b0 01                	mov    $0x1,%al
c000460b:	c3                   	ret    
}

bool Ec::handle_exc_ts (Exc_regs *r)
{
    if (r->user())
        return false;
c000460c:	31 c0                	xor    %eax,%eax

    // SYSENTER with EFLAGS.NT=1 and IRET faulted
    r->REG(fl) &= ~Cpu::EFL_NT;

    return true;
}
c000460e:	c3                   	ret    
c000460f:	90                   	nop

c0004610 <_ZN2Ec13handle_exc_gpEP8Exc_regs>:

bool Ec::handle_exc_gp (Exc_regs *)
{
    if (Cpu::hazard & HZD_TR) {
c0004610:	8b 15 00 f0 ff cf    	mov    0xcffff000,%edx
        Gdt::unbusy_tss();
        asm volatile ("ltr %w0" : : "r" (SEL_TSS_RUN));
        return true;
    }

    return false;
c0004616:	31 c0                	xor    %eax,%eax
    return true;
}

bool Ec::handle_exc_gp (Exc_regs *)
{
    if (Cpu::hazard & HZD_TR) {
c0004618:	f6 c2 04             	test   $0x4,%dl
c000461b:	74 1d                	je     c000463a <_ZN2Ec13handle_exc_gpEP8Exc_regs+0x2a>
        Cpu::hazard &= ~HZD_TR;
c000461d:	83 e2 fb             	and    $0xfffffffb,%edx
        Gdt::unbusy_tss();
        asm volatile ("ltr %w0" : : "r" (SEL_TSS_RUN));
c0004620:	b8 30 00 00 00       	mov    $0x30,%eax
}

bool Ec::handle_exc_gp (Exc_regs *)
{
    if (Cpu::hazard & HZD_TR) {
        Cpu::hazard &= ~HZD_TR;
c0004625:	89 15 00 f0 ff cf    	mov    %edx,0xcffff000
        }

        ALWAYS_INLINE
        static inline void unbusy_tss()
        {
            gdt[SEL_TSS_RUN >> 3].val[1] &= ~0x200;
c000462b:	81 25 b4 f7 ff cf ff 	andl   $0xfffffdff,0xcffff7b4
c0004632:	fd ff ff 
        Gdt::unbusy_tss();
        asm volatile ("ltr %w0" : : "r" (SEL_TSS_RUN));
c0004635:	0f 00 d8             	ltr    %ax
        return true;
c0004638:	b0 01                	mov    $0x1,%al
    }

    return false;
}
c000463a:	c3                   	ret    
c000463b:	90                   	nop

c000463c <_ZN2Ec13handle_exc_pfEP8Exc_regs>:

bool Ec::handle_exc_pf (Exc_regs *r)
{
c000463c:	57                   	push   %edi
c000463d:	56                   	push   %esi
c000463e:	89 c6                	mov    %eax,%esi
c0004640:	53                   	push   %ebx
    mword addr = r->cr2;

    if (r->err & Hpt::ERR_U)
c0004641:	f6 40 30 04          	testb  $0x4,0x30(%eax)
    return false;
}

bool Ec::handle_exc_pf (Exc_regs *r)
{
    mword addr = r->cr2;
c0004645:	8b 58 0c             	mov    0xc(%eax),%ebx

    if (r->err & Hpt::ERR_U)
c0004648:	74 3b                	je     c0004685 <_ZN2Ec13handle_exc_pfEP8Exc_regs+0x49>
        return addr < USER_ADDR && Pd::current->Space_mem::loc[Cpu::id].sync_from (Pd::current->quota, Pd::current->Space_mem::hpt, addr, USER_ADDR);
c000464a:	31 c0                	xor    %eax,%eax
c000464c:	81 fb ff ff ff bf    	cmp    $0xbfffffff,%ebx
c0004652:	0f 87 e7 00 00 00    	ja     c000473f <_ZN2Ec13handle_exc_pfEP8Exc_regs+0x103>
c0004658:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c000465d:	8b 35 04 f0 ff cf    	mov    0xcffff004,%esi
c0004663:	8b 88 54 01 00 00    	mov    0x154(%eax),%ecx
c0004669:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx
c000466f:	68 00 00 00 c0       	push   $0xc0000000
c0004674:	53                   	push   %ebx
c0004675:	8d 44 b0 54          	lea    0x54(%eax,%esi,4),%eax
c0004679:	e8 44 14 00 00       	call   c0005ac2 <_ZN3Hpt9sync_fromER5QuotaS_mm>
c000467e:	59                   	pop    %ecx
c000467f:	5b                   	pop    %ebx
c0004680:	e9 ba 00 00 00       	jmp    c000473f <_ZN2Ec13handle_exc_pfEP8Exc_regs+0x103>

    if (addr < USER_ADDR) {
c0004685:	81 fb ff ff ff bf    	cmp    $0xbfffffff,%ebx
c000468b:	77 3d                	ja     c00046ca <_ZN2Ec13handle_exc_pfEP8Exc_regs+0x8e>

        if (Pd::current->Space_mem::loc[Cpu::id].sync_from (Pd::current->quota, Pd::current->Space_mem::hpt, addr, USER_ADDR))
c000468d:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c0004692:	8b 3d 04 f0 ff cf    	mov    0xcffff004,%edi
c0004698:	8b 88 54 01 00 00    	mov    0x154(%eax),%ecx
c000469e:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx
c00046a4:	68 00 00 00 c0       	push   $0xc0000000
c00046a9:	53                   	push   %ebx
c00046aa:	8d 44 b8 54          	lea    0x54(%eax,%edi,4),%eax
c00046ae:	e8 0f 14 00 00       	call   c0005ac2 <_ZN3Hpt9sync_fromER5QuotaS_mm>
c00046b3:	5f                   	pop    %edi
c00046b4:	5a                   	pop    %edx
c00046b5:	84 c0                	test   %al,%al
c00046b7:	75 76                	jne    c000472f <_ZN2Ec13handle_exc_pfEP8Exc_regs+0xf3>
            return true;

        if (fixup (r->REG(ip))) {
c00046b9:	8d 46 38             	lea    0x38(%esi),%eax
c00046bc:	e8 27 f4 ff ff       	call   c0003ae8 <_ZN2Ec5fixupERm>
c00046c1:	84 c0                	test   %al,%al
c00046c3:	74 05                	je     c00046ca <_ZN2Ec13handle_exc_pfEP8Exc_regs+0x8e>
            r->REG(ax) = addr;
c00046c5:	89 5e 1c             	mov    %ebx,0x1c(%esi)
            return true;
c00046c8:	eb 75                	jmp    c000473f <_ZN2Ec13handle_exc_pfEP8Exc_regs+0x103>
        }
    }

    if (addr >= LINK_ADDR && addr < CPU_LOCAL && Pd::current->Space_mem::loc[Cpu::id].sync_from (Pd::current->quota, Hptp (reinterpret_cast<mword>(&PDBR)), addr, CPU_LOCAL))
c00046ca:	8d 83 00 00 00 40    	lea    0x40000000(%ebx),%eax
c00046d0:	3d ff ff bf 0f       	cmp    $0xfbfffff,%eax
c00046d5:	76 19                	jbe    c00046f0 <_ZN2Ec13handle_exc_pfEP8Exc_regs+0xb4>
        return true;

    // Kernel fault in I/O space
    if (addr >= SPC_LOCAL_IOP && addr <= SPC_LOCAL_IOP_E) {
c00046d7:	8d 83 00 00 00 30    	lea    0x30000000(%ebx),%eax
c00046dd:	3d 00 20 00 00       	cmp    $0x2000,%eax
c00046e2:	77 39                	ja     c000471d <_ZN2Ec13handle_exc_pfEP8Exc_regs+0xe1>
        Space_pio::page_fault (addr, r->err);
c00046e4:	8b 56 30             	mov    0x30(%esi),%edx
c00046e7:	89 d8                	mov    %ebx,%eax
c00046e9:	e8 64 cc 00 00       	call   c0011352 <_ZN9Space_pio10page_faultEmm>
c00046ee:	eb 3f                	jmp    c000472f <_ZN2Ec13handle_exc_pfEP8Exc_regs+0xf3>
            r->REG(ax) = addr;
            return true;
        }
    }

    if (addr >= LINK_ADDR && addr < CPU_LOCAL && Pd::current->Space_mem::loc[Cpu::id].sync_from (Pd::current->quota, Hptp (reinterpret_cast<mword>(&PDBR)), addr, CPU_LOCAL))
c00046f0:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c00046f5:	8b 0d 04 f0 ff cf    	mov    0xcffff004,%ecx
c00046fb:	68 00 00 c0 cf       	push   $0xcfc00000
c0004700:	53                   	push   %ebx
c0004701:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx
c0004707:	8d 44 88 54          	lea    0x54(%eax,%ecx,4),%eax
c000470b:	b9 00 f0 41 00       	mov    $0x41f000,%ecx
c0004710:	e8 ad 13 00 00       	call   c0005ac2 <_ZN3Hpt9sync_fromER5QuotaS_mm>
c0004715:	5a                   	pop    %edx
c0004716:	59                   	pop    %ecx
c0004717:	84 c0                	test   %al,%al
c0004719:	75 14                	jne    c000472f <_ZN2Ec13handle_exc_pfEP8Exc_regs+0xf3>
c000471b:	eb ba                	jmp    c00046d7 <_ZN2Ec13handle_exc_pfEP8Exc_regs+0x9b>
        Space_pio::page_fault (addr, r->err);
        return true;
    }

    // Kernel fault in OBJ space
    if (addr >= SPC_LOCAL_OBJ) {
c000471d:	81 fb ff ff ff df    	cmp    $0xdfffffff,%ebx
c0004723:	76 0e                	jbe    c0004733 <_ZN2Ec13handle_exc_pfEP8Exc_regs+0xf7>
        Space_obj::page_fault (addr, r->err);
c0004725:	8b 56 30             	mov    0x30(%esi),%edx
c0004728:	89 d8                	mov    %ebx,%eax
c000472a:	e8 cf c9 00 00       	call   c00110fe <_ZN9Space_obj10page_faultEmm>
        return true;

    // Kernel fault in I/O space
    if (addr >= SPC_LOCAL_IOP && addr <= SPC_LOCAL_IOP_E) {
        Space_pio::page_fault (addr, r->err);
        return true;
c000472f:	b0 01                	mov    $0x1,%al
c0004731:	eb 0c                	jmp    c000473f <_ZN2Ec13handle_exc_pfEP8Exc_regs+0x103>
    if (addr >= SPC_LOCAL_OBJ) {
        Space_obj::page_fault (addr, r->err);
        return true;
    }

    die ("#PF (kernel)", r);
c0004733:	89 f2                	mov    %esi,%edx
c0004735:	b8 44 6e 01 c0       	mov    $0xc0016e44,%eax
c000473a:	e8 cd f3 ff ff       	call   c0003b0c <_ZN2Ec3dieEPKcP8Exc_regs>
}
c000473f:	5b                   	pop    %ebx
c0004740:	5e                   	pop    %esi
c0004741:	5f                   	pop    %edi
c0004742:	c3                   	ret    
c0004743:	90                   	nop

c0004744 <exc_handler>:

void Ec::handle_exc (Exc_regs *r)
{
c0004744:	53                   	push   %ebx
c0004745:	89 c3                	mov    %eax,%ebx
    Counter::exc[r->vec]++;
c0004747:	8b 40 34             	mov    0x34(%eax),%eax
c000474a:	ff 04 85 40 f4 ff cf 	incl   -0x30000bc0(,%eax,4)

    switch (r->vec) {
c0004751:	8b 43 34             	mov    0x34(%ebx),%eax
c0004754:	83 e8 07             	sub    $0x7,%eax
c0004757:	83 f8 0b             	cmp    $0xb,%eax
c000475a:	77 31                	ja     c000478d <exc_handler+0x49>
c000475c:	ff 24 85 58 6e 01 c0 	jmp    *-0x3ffe91a8(,%eax,4)

    if (r->user())
        send_msg<ret_user_iret>();

    die ("EXC", r);
}
c0004763:	5b                   	pop    %ebx
    Counter::exc[r->vec]++;

    switch (r->vec) {

        case Cpu::EXC_NM:
            handle_exc_nm();
c0004764:	e9 11 fe ff ff       	jmp    c000457a <_ZN2Ec13handle_exc_nmEv>
            return;

        case Cpu::EXC_TS:
            if (handle_exc_ts (r))
c0004769:	89 d8                	mov    %ebx,%eax
c000476b:	e8 8c fe ff ff       	call   c00045fc <_ZN2Ec13handle_exc_tsEP8Exc_regs>
c0004770:	eb 10                	jmp    c0004782 <exc_handler+0x3e>
                return;
            break;

        case Cpu::EXC_GP:
            if (handle_exc_gp (r))
c0004772:	89 d8                	mov    %ebx,%eax
c0004774:	e8 97 fe ff ff       	call   c0004610 <_ZN2Ec13handle_exc_gpEP8Exc_regs>
c0004779:	eb 07                	jmp    c0004782 <exc_handler+0x3e>
                return;
            break;

        case Cpu::EXC_PF:
            if (handle_exc_pf (r))
c000477b:	89 d8                	mov    %ebx,%eax
c000477d:	e8 ba fe ff ff       	call   c000463c <_ZN2Ec13handle_exc_pfEP8Exc_regs>
c0004782:	84 c0                	test   %al,%al
c0004784:	74 07                	je     c000478d <exc_handler+0x49>
c0004786:	eb 1c                	jmp    c00047a4 <exc_handler+0x60>
                return;
            break;

        case Cpu::EXC_MC:
            Mca::vector();
c0004788:	e8 5f 19 00 00       	call   c00060ec <_ZN3Mca6vectorEv>
            break;
    }

    if (r->user())
c000478d:	f6 43 3c 03          	testb  $0x3,0x3c(%ebx)
c0004791:	74 05                	je     c0004798 <exc_handler+0x54>
        send_msg<ret_user_iret>();
c0004793:	e8 54 d6 00 00       	call   c0011dec <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv>

    die ("EXC", r);
c0004798:	89 da                	mov    %ebx,%edx
c000479a:	b8 51 6e 01 c0       	mov    $0xc0016e51,%eax
c000479f:	e8 68 f3 ff ff       	call   c0003b0c <_ZN2Ec3dieEPKcP8Exc_regs>
}
c00047a4:	5b                   	pop    %ebx
c00047a5:	c3                   	ret    

c00047a6 <_ZN2Ec6ifetchEm>:
#include "ec.hpp"
#include "svm.hpp"
#include "vtlb.hpp"

uint8 Ec::ifetch (mword virt)
{
c00047a6:	83 ec 0c             	sub    $0xc,%esp
c00047a9:	89 c2                	mov    %eax,%edx
    mword phys, attr = 0, type = 0;
    uint8 opcode;

    if (!Vtlb::gwalk (&current->regs, virt, phys, attr, type))
c00047ab:	8d 4c 24 08          	lea    0x8(%esp),%ecx
c00047af:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
#include "svm.hpp"
#include "vtlb.hpp"

uint8 Ec::ifetch (mword virt)
{
    mword phys, attr = 0, type = 0;
c00047b4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c00047bb:	00 
c00047bc:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c00047c3:	00 
    uint8 opcode;

    if (!Vtlb::gwalk (&current->regs, virt, phys, attr, type))
c00047c4:	51                   	push   %ecx
c00047c5:	8d 4c 24 08          	lea    0x8(%esp),%ecx
c00047c9:	83 c0 54             	add    $0x54,%eax
c00047cc:	51                   	push   %ecx
c00047cd:	8d 4c 24 08          	lea    0x8(%esp),%ecx
c00047d1:	e8 0c 13 01 00       	call   c0015ae2 <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_>
c00047d6:	5a                   	pop    %edx
c00047d7:	59                   	pop    %ecx
c00047d8:	85 c0                	test   %eax,%eax
c00047da:	75 0f                	jne    c00047eb <_ZN2Ec6ifetchEm+0x45>
        die ("SVM TLB failure");
c00047dc:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c00047e1:	8d 50 54             	lea    0x54(%eax),%edx
c00047e4:	b8 88 6e 01 c0       	mov    $0xc0016e88,%eax
c00047e9:	eb 18                	jmp    c0004803 <_ZN2Ec6ifetchEm+0x5d>
        static inline mword peek (T *addr, T &val)
        {
            mword ret;
            asm volatile ("1: mov %2, %1; or $-1, %0; 2:"
                          ".section .fixup,\"a\"; .align 8;" EXPAND (WORD) " 1b,2b; .previous"
                          : "=a" (ret), "=q" (val) : "m" (*addr));
c00047eb:	8b 04 24             	mov    (%esp),%eax
c00047ee:	8a 10                	mov    (%eax),%dl
c00047f0:	83 c8 ff             	or     $0xffffffff,%eax

    if (User::peek (reinterpret_cast<uint8 *>(phys), opcode) != ~0UL)
c00047f3:	40                   	inc    %eax
c00047f4:	74 12                	je     c0004808 <_ZN2Ec6ifetchEm+0x62>
        die ("SVM ifetch failure");
c00047f6:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c00047fb:	8d 50 54             	lea    0x54(%eax),%edx
c00047fe:	b8 98 6e 01 c0       	mov    $0xc0016e98,%eax
c0004803:	e8 04 f3 ff ff       	call   c0003b0c <_ZN2Ec3dieEPKcP8Exc_regs>

    return opcode;
}
c0004808:	88 d0                	mov    %dl,%al
c000480a:	83 c4 0c             	add    $0xc,%esp
c000480d:	c3                   	ret    

c000480e <_ZN2Ec13svm_exceptionEm>:

void Ec::svm_exception (mword reason)
{
c000480e:	55                   	push   %ebp
c000480f:	57                   	push   %edi
c0004810:	56                   	push   %esi
c0004811:	53                   	push   %ebx
c0004812:	52                   	push   %edx
    if (current->regs.vmcb->exitintinfo & 0x80000000) {
c0004813:	8b 0d 08 f0 ff cf    	mov    0xcffff008,%ecx
c0004819:	8b 51 74             	mov    0x74(%ecx),%edx
c000481c:	8b 9a 88 00 00 00    	mov    0x88(%edx),%ebx
c0004822:	8b aa 8c 00 00 00    	mov    0x8c(%edx),%ebp
c0004828:	85 db                	test   %ebx,%ebx
c000482a:	79 26                	jns    c0004852 <_ZN2Ec13svm_exceptionEm+0x44>

        mword t = static_cast<mword>(current->regs.vmcb->exitintinfo) >> 8 & 0x7;
c000482c:	89 de                	mov    %ebx,%esi
c000482e:	c1 ee 08             	shr    $0x8,%esi
        mword v = static_cast<mword>(current->regs.vmcb->exitintinfo) & 0xff;

        if (t == 0 || (t == 3 && v != 3 && v != 4))
c0004831:	83 e6 07             	and    $0x7,%esi
c0004834:	74 10                	je     c0004846 <_ZN2Ec13svm_exceptionEm+0x38>
void Ec::svm_exception (mword reason)
{
    if (current->regs.vmcb->exitintinfo & 0x80000000) {

        mword t = static_cast<mword>(current->regs.vmcb->exitintinfo) >> 8 & 0x7;
        mword v = static_cast<mword>(current->regs.vmcb->exitintinfo) & 0xff;
c0004836:	0f b6 fb             	movzbl %bl,%edi

        if (t == 0 || (t == 3 && v != 3 && v != 4))
c0004839:	83 ef 03             	sub    $0x3,%edi
c000483c:	83 ff 01             	cmp    $0x1,%edi
c000483f:	76 11                	jbe    c0004852 <_ZN2Ec13svm_exceptionEm+0x44>
c0004841:	83 fe 03             	cmp    $0x3,%esi
c0004844:	75 0c                	jne    c0004852 <_ZN2Ec13svm_exceptionEm+0x44>
            current->regs.vmcb->inj_control = current->regs.vmcb->exitintinfo;
c0004846:	89 9a a8 00 00 00    	mov    %ebx,0xa8(%edx)
c000484c:	89 aa ac 00 00 00    	mov    %ebp,0xac(%edx)
    }

    switch (reason) {
c0004852:	83 f8 47             	cmp    $0x47,%eax
c0004855:	74 10                	je     c0004867 <_ZN2Ec13svm_exceptionEm+0x59>
c0004857:	83 f8 4e             	cmp    $0x4e,%eax
c000485a:	74 12                	je     c000486e <_ZN2Ec13svm_exceptionEm+0x60>

        default:
            current->regs.dst_portal = reason;
c000485c:	89 81 88 00 00 00    	mov    %eax,0x88(%ecx)
c0004862:	e9 80 00 00 00       	jmp    c00048e7 <_ZN2Ec13svm_exceptionEm+0xd9>
            break;

        case 0x47:          // #NM
            handle_exc_nm();
c0004867:	e8 0e fd ff ff       	call   c000457a <_ZN2Ec13handle_exc_nmEv>
c000486c:	eb 74                	jmp    c00048e2 <_ZN2Ec13svm_exceptionEm+0xd4>
            ret_user_vmrun();

        case 0x4e:          // #PF
            mword err = static_cast<mword>(current->regs.vmcb->exitinfo1);
c000486e:	8b 41 74             	mov    0x74(%ecx),%eax
c0004871:	8b 50 78             	mov    0x78(%eax),%edx
            mword cr2 = static_cast<mword>(current->regs.vmcb->exitinfo2);
c0004874:	8b 98 80 00 00 00    	mov    0x80(%eax),%ebx

            switch (Vtlb::miss (&current->regs, cr2, err)) {
c000487a:	8d 41 54             	lea    0x54(%ecx),%eax
c000487d:	89 e1                	mov    %esp,%ecx
        case 0x47:          // #NM
            handle_exc_nm();
            ret_user_vmrun();

        case 0x4e:          // #PF
            mword err = static_cast<mword>(current->regs.vmcb->exitinfo1);
c000487f:	89 14 24             	mov    %edx,(%esp)
            mword cr2 = static_cast<mword>(current->regs.vmcb->exitinfo2);

            switch (Vtlb::miss (&current->regs, cr2, err)) {
c0004882:	89 da                	mov    %ebx,%edx
c0004884:	e8 a5 14 01 00       	call   c0015d2e <_ZN4Vtlb4missEP8Exc_regsmRm>
c0004889:	83 f8 01             	cmp    $0x1,%eax
c000488c:	74 26                	je     c00048b4 <_ZN2Ec13svm_exceptionEm+0xa6>
c000488e:	83 f8 02             	cmp    $0x2,%eax
c0004891:	74 06                	je     c0004899 <_ZN2Ec13svm_exceptionEm+0x8b>
c0004893:	85 c0                	test   %eax,%eax
c0004895:	75 50                	jne    c00048e7 <_ZN2Ec13svm_exceptionEm+0xd9>
c0004897:	eb 49                	jmp    c00048e2 <_ZN2Ec13svm_exceptionEm+0xd4>

                case Vtlb::GPA_HPA:
                    current->regs.nst_error = 0;
c0004899:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c000489e:	c7 80 90 00 00 00 00 	movl   $0x0,0x90(%eax)
c00048a5:	00 00 00 
                    current->regs.dst_portal = NUM_VMI - 4;
c00048a8:	c7 80 88 00 00 00 fc 	movl   $0xfc,0x88(%eax)
c00048af:	00 00 00 
                    break;
c00048b2:	eb 33                	jmp    c00048e7 <_ZN2Ec13svm_exceptionEm+0xd9>

                case Vtlb::GLA_GPA:
                    current->regs.vmcb->cr2 = cr2;
c00048b4:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
                    current->regs.vmcb->inj_control = static_cast<uint64>(err) << 32 | 0x80000b0e;
c00048b9:	8b 0c 24             	mov    (%esp),%ecx
                    current->regs.nst_error = 0;
                    current->regs.dst_portal = NUM_VMI - 4;
                    break;

                case Vtlb::GLA_GPA:
                    current->regs.vmcb->cr2 = cr2;
c00048bc:	8b 50 74             	mov    0x74(%eax),%edx
c00048bf:	89 9a 40 06 00 00    	mov    %ebx,0x640(%edx)
c00048c5:	c7 82 44 06 00 00 00 	movl   $0x0,0x644(%edx)
c00048cc:	00 00 00 
                    current->regs.vmcb->inj_control = static_cast<uint64>(err) << 32 | 0x80000b0e;
c00048cf:	8b 40 74             	mov    0x74(%eax),%eax
c00048d2:	c7 80 a8 00 00 00 0e 	movl   $0x80000b0e,0xa8(%eax)
c00048d9:	0b 00 80 
c00048dc:	89 88 ac 00 00 00    	mov    %ecx,0xac(%eax)

                case Vtlb::SUCCESS:
                    ret_user_vmrun();
c00048e2:	e8 5d f1 ff ff       	call   c0003a44 <_ZN2Ec14ret_user_vmrunEv>
            }
    }

    send_msg<ret_user_vmrun>();
c00048e7:	e8 d8 d2 00 00       	call   c0011bc4 <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv>

c00048ec <_ZN2Ec10svm_invlpgEv>:
}

void Ec::svm_invlpg()
{
    current->regs.svm_update_shadows();
c00048ec:	a1 08 f0 ff cf       	mov    0xcffff008,%eax

    send_msg<ret_user_vmrun>();
}

void Ec::svm_invlpg()
{
c00048f1:	53                   	push   %ebx
    current->regs.svm_update_shadows();
c00048f2:	83 c0 54             	add    $0x54,%eax
c00048f5:	e8 30 a4 00 00       	call   c000ed2a <_ZN8Exc_regs18svm_update_shadowsEv>

    mword virt = current->regs.linear_address<Vmcb>(static_cast<mword>(current->regs.vmcb->cs.base) + static_cast<mword>(current->regs.vmcb->rip));
c00048fa:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c00048ff:	8b 48 74             	mov    0x74(%eax),%ecx
c0004902:	83 c0 54             	add    $0x54,%eax
c0004905:	8b 91 18 04 00 00    	mov    0x418(%ecx),%edx
c000490b:	03 91 78 05 00 00    	add    0x578(%ecx),%edx
c0004911:	e8 46 a5 00 00       	call   c000ee5c <_ZNK8Exc_regs14linear_addressI4VmcbEEmm>
c0004916:	89 c3                	mov    %eax,%ebx

    assert (ifetch (virt) == 0xf && ifetch (virt + 1) == 0x1);
c0004918:	e8 89 fe ff ff       	call   c00047a6 <_ZN2Ec6ifetchEm>
c000491d:	3c 0f                	cmp    $0xf,%al
c000491f:	0f 85 ab 00 00 00    	jne    c00049d0 <_ZN2Ec10svm_invlpgEv+0xe4>
c0004925:	8d 43 01             	lea    0x1(%ebx),%eax
c0004928:	e8 79 fe ff ff       	call   c00047a6 <_ZN2Ec6ifetchEm>
c000492d:	fe c8                	dec    %al
c000492f:	0f 85 9b 00 00 00    	jne    c00049d0 <_ZN2Ec10svm_invlpgEv+0xe4>

    uint8 mrm = ifetch (virt + 2);
c0004935:	8d 43 02             	lea    0x2(%ebx),%eax
c0004938:	e8 69 fe ff ff       	call   c00047a6 <_ZN2Ec6ifetchEm>
    uint8 r_m = mrm & 7;
c000493d:	88 c2                	mov    %al,%dl

    unsigned len = 3;

    switch (mrm >> 6) {
c000493f:	0f b6 c0             	movzbl %al,%eax
c0004942:	c1 f8 06             	sar    $0x6,%eax
    mword virt = current->regs.linear_address<Vmcb>(static_cast<mword>(current->regs.vmcb->cs.base) + static_cast<mword>(current->regs.vmcb->rip));

    assert (ifetch (virt) == 0xf && ifetch (virt + 1) == 0x1);

    uint8 mrm = ifetch (virt + 2);
    uint8 r_m = mrm & 7;
c0004945:	80 e2 07             	and    $0x7,%dl

    unsigned len = 3;

    switch (mrm >> 6) {
c0004948:	83 f8 01             	cmp    $0x1,%eax
c000494b:	75 71                	jne    c00049be <_ZN2Ec10svm_invlpgEv+0xd2>
        case 0: len += (r_m == 4 ? 1 : r_m == 5 ? 4 : 0); break;
        case 1: len += (r_m == 4 ? 2 : 1); break;
c000494d:	31 c0                	xor    %eax,%eax
c000494f:	80 fa 04             	cmp    $0x4,%dl
c0004952:	0f 94 c0             	sete   %al
c0004955:	8d 58 04             	lea    0x4(%eax),%ebx
c0004958:	eb 21                	jmp    c000497b <_ZN2Ec10svm_invlpgEv+0x8f>
    uint8 mrm = ifetch (virt + 2);
    uint8 r_m = mrm & 7;

    unsigned len = 3;

    switch (mrm >> 6) {
c000495a:	85 c0                	test   %eax,%eax
    assert (ifetch (virt) == 0xf && ifetch (virt + 1) == 0x1);

    uint8 mrm = ifetch (virt + 2);
    uint8 r_m = mrm & 7;

    unsigned len = 3;
c000495c:	bb 03 00 00 00       	mov    $0x3,%ebx

    switch (mrm >> 6) {
c0004961:	75 18                	jne    c000497b <_ZN2Ec10svm_invlpgEv+0x8f>
        case 0: len += (r_m == 4 ? 1 : r_m == 5 ? 4 : 0); break;
c0004963:	80 fa 04             	cmp    $0x4,%dl
c0004966:	b8 01 00 00 00       	mov    $0x1,%eax
c000496b:	74 0b                	je     c0004978 <_ZN2Ec10svm_invlpgEv+0x8c>
c000496d:	31 c0                	xor    %eax,%eax
c000496f:	80 fa 05             	cmp    $0x5,%dl
c0004972:	0f 94 c0             	sete   %al
c0004975:	c1 e0 02             	shl    $0x2,%eax
c0004978:	8d 58 03             	lea    0x3(%eax),%ebx
        case 1: len += (r_m == 4 ? 2 : 1); break;
        case 2: len += (r_m == 4 ? 5 : 4); break;
    }

    current->regs.tlb_flush<Vmcb>(true);
c000497b:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0004980:	ba 01 00 00 00       	mov    $0x1,%edx
c0004985:	83 c0 54             	add    $0x54,%eax
c0004988:	e8 57 9b 00 00       	call   c000e4e4 <_ZNK8Exc_regs9tlb_flushI4VmcbEEvb>
    current->regs.vmcb->adjust_rip (len);
c000498d:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
        }

        ALWAYS_INLINE
        inline void adjust_rip (mword len)
        {
            rip += len;
c0004992:	31 d2                	xor    %edx,%edx
c0004994:	8b 48 74             	mov    0x74(%eax),%ecx
c0004997:	01 99 78 05 00 00    	add    %ebx,0x578(%ecx)

            if (int_shadow)
c000499d:	8b 41 6c             	mov    0x6c(%ecx),%eax
        }

        ALWAYS_INLINE
        inline void adjust_rip (mword len)
        {
            rip += len;
c00049a0:	11 91 7c 05 00 00    	adc    %edx,0x57c(%ecx)

            if (int_shadow)
c00049a6:	0b 41 68             	or     0x68(%ecx),%eax
c00049a9:	74 0e                	je     c00049b9 <_ZN2Ec10svm_invlpgEv+0xcd>
                int_shadow = 0;
c00049ab:	c7 41 68 00 00 00 00 	movl   $0x0,0x68(%ecx)
c00049b2:	c7 41 6c 00 00 00 00 	movl   $0x0,0x6c(%ecx)
    ret_user_vmrun();
c00049b9:	e8 86 f0 ff ff       	call   c0003a44 <_ZN2Ec14ret_user_vmrunEv>
    uint8 mrm = ifetch (virt + 2);
    uint8 r_m = mrm & 7;

    unsigned len = 3;

    switch (mrm >> 6) {
c00049be:	83 f8 02             	cmp    $0x2,%eax
c00049c1:	75 97                	jne    c000495a <_ZN2Ec10svm_invlpgEv+0x6e>
        case 0: len += (r_m == 4 ? 1 : r_m == 5 ? 4 : 0); break;
        case 1: len += (r_m == 4 ? 2 : 1); break;
        case 2: len += (r_m == 4 ? 5 : 4); break;
c00049c3:	31 c0                	xor    %eax,%eax
c00049c5:	80 fa 04             	cmp    $0x4,%dl
c00049c8:	0f 94 c0             	sete   %al
c00049cb:	8d 58 07             	lea    0x7(%eax),%ebx
c00049ce:	eb ab                	jmp    c000497b <_ZN2Ec10svm_invlpgEv+0x8f>
{
    current->regs.svm_update_shadows();

    mword virt = current->regs.linear_address<Vmcb>(static_cast<mword>(current->regs.vmcb->cs.base) + static_cast<mword>(current->regs.vmcb->rip));

    assert (ifetch (virt) == 0xf && ifetch (virt + 1) == 0x1);
c00049d0:	68 74 6f 01 c0       	push   $0xc0016f74
c00049d5:	6a 59                	push   $0x59
c00049d7:	68 ab 6e 01 c0       	push   $0xc0016eab
c00049dc:	68 1a 6f 01 c0       	push   $0xc0016f1a
c00049e1:	68 69 60 01 c0       	push   $0xc0016069
c00049e6:	e8 5b cf ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>
c00049eb:	90                   	nop

c00049ec <_ZN2Ec6svm_crEv>:
    current->regs.vmcb->adjust_rip (len);
    ret_user_vmrun();
}

void Ec::svm_cr()
{
c00049ec:	56                   	push   %esi
c00049ed:	53                   	push   %ebx
c00049ee:	50                   	push   %eax
    current->regs.svm_update_shadows();
c00049ef:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c00049f4:	83 c0 54             	add    $0x54,%eax
c00049f7:	e8 2e a3 00 00       	call   c000ed2a <_ZN8Exc_regs18svm_update_shadowsEv>

    mword virt = current->regs.linear_address<Vmcb>(static_cast<mword>(current->regs.vmcb->cs.base) + static_cast<mword>(current->regs.vmcb->rip));
c00049fc:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0004a01:	8b 48 74             	mov    0x74(%eax),%ecx
c0004a04:	83 c0 54             	add    $0x54,%eax
c0004a07:	8b 91 18 04 00 00    	mov    0x418(%ecx),%edx
c0004a0d:	03 91 78 05 00 00    	add    0x578(%ecx),%edx
c0004a13:	e8 44 a4 00 00       	call   c000ee5c <_ZNK8Exc_regs14linear_addressI4VmcbEEmm>
c0004a18:	89 c3                	mov    %eax,%ebx

    assert (ifetch (virt) == 0xf);
c0004a1a:	e8 87 fd ff ff       	call   c00047a6 <_ZN2Ec6ifetchEm>
c0004a1f:	3c 0f                	cmp    $0xf,%al
c0004a21:	74 1b                	je     c0004a3e <_ZN2Ec6svm_crEv+0x52>
c0004a23:	68 94 6f 01 c0       	push   $0xc0016f94
c0004a28:	6a 71                	push   $0x71
c0004a2a:	68 ab 6e 01 c0       	push   $0xc0016eab
c0004a2f:	68 4b 6f 01 c0       	push   $0xc0016f4b
c0004a34:	68 69 60 01 c0       	push   $0xc0016069
c0004a39:	e8 08 cf ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

    uint8 opc = ifetch (virt + 1);
c0004a3e:	8d 43 01             	lea    0x1(%ebx),%eax
c0004a41:	e8 60 fd ff ff       	call   c00047a6 <_ZN2Ec6ifetchEm>
c0004a46:	88 44 24 03          	mov    %al,0x3(%esp)
    uint8 mrm = ifetch (virt + 2);
c0004a4a:	8d 43 02             	lea    0x2(%ebx),%eax
c0004a4d:	e8 54 fd ff ff       	call   c00047a6 <_ZN2Ec6ifetchEm>

    unsigned len, gpr = mrm & 0x7, cr = mrm >> 3 & 0x7;

    switch (opc) {
c0004a52:	8a 54 24 03          	mov    0x3(%esp),%dl
    assert (ifetch (virt) == 0xf);

    uint8 opc = ifetch (virt + 1);
    uint8 mrm = ifetch (virt + 2);

    unsigned len, gpr = mrm & 0x7, cr = mrm >> 3 & 0x7;
c0004a56:	0f b6 d8             	movzbl %al,%ebx
c0004a59:	88 c1                	mov    %al,%cl
c0004a5b:	c1 fb 03             	sar    $0x3,%ebx
c0004a5e:	80 e1 07             	and    $0x7,%cl
c0004a61:	83 e3 07             	and    $0x7,%ebx

    switch (opc) {
c0004a64:	80 fa 20             	cmp    $0x20,%dl
    assert (ifetch (virt) == 0xf);

    uint8 opc = ifetch (virt + 1);
    uint8 mrm = ifetch (virt + 2);

    unsigned len, gpr = mrm & 0x7, cr = mrm >> 3 & 0x7;
c0004a67:	0f b6 f1             	movzbl %cl,%esi
c0004a6a:	8b 0d 08 f0 ff cf    	mov    0xcffff008,%ecx

    switch (opc) {
c0004a70:	74 2f                	je     c0004aa1 <_ZN2Ec6svm_crEv+0xb5>
c0004a72:	80 fa 22             	cmp    $0x22,%dl
c0004a75:	74 4a                	je     c0004ac1 <_ZN2Ec6svm_crEv+0xd5>
c0004a77:	80 fa 06             	cmp    $0x6,%dl
c0004a7a:	75 6a                	jne    c0004ae6 <_ZN2Ec6svm_crEv+0xfa>

        case 0x6:       // CLTS
            current->regs.write_cr<Vmcb> (0, current->regs.read_cr<Vmcb> (0) & ~Cpu::CR0_TS);
c0004a7c:	8d 41 54             	lea    0x54(%ecx),%eax
c0004a7f:	31 d2                	xor    %edx,%edx
c0004a81:	e8 da a3 00 00       	call   c000ee60 <_ZNK8Exc_regs7read_crI4VmcbEEmj>
c0004a86:	31 d2                	xor    %edx,%edx
c0004a88:	83 e0 f7             	and    $0xfffffff7,%eax
c0004a8b:	89 c1                	mov    %eax,%ecx
c0004a8d:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0004a92:	83 c0 54             	add    $0x54,%eax
c0004a95:	e8 0a a5 00 00       	call   c000efa4 <_ZN8Exc_regs8write_crI4VmcbEEvjm>
            len = 2;
c0004a9a:	b9 02 00 00 00       	mov    $0x2,%ecx
            break;
c0004a9f:	eb 52                	jmp    c0004af3 <_ZN2Ec6svm_crEv+0x107>

        case 0x20:      // MOV from CR
            current->regs.svm_write_gpr (gpr, current->regs.read_cr<Vmcb>(cr));
c0004aa1:	89 da                	mov    %ebx,%edx
c0004aa3:	8d 41 54             	lea    0x54(%ecx),%eax
c0004aa6:	e8 b5 a3 00 00       	call   c000ee60 <_ZNK8Exc_regs7read_crI4VmcbEEmj>
c0004aab:	8b 1d 08 f0 ff cf    	mov    0xcffff008,%ebx
c0004ab1:	89 f2                	mov    %esi,%edx
c0004ab3:	83 c3 54             	add    $0x54,%ebx
c0004ab6:	89 c1                	mov    %eax,%ecx
c0004ab8:	89 d8                	mov    %ebx,%eax
c0004aba:	e8 29 a3 00 00       	call   c000ede8 <_ZN8Exc_regs13svm_write_gprEjm>
c0004abf:	eb 1e                	jmp    c0004adf <_ZN2Ec6svm_crEv+0xf3>
            len = 3;
            break;

        case 0x22:      // MOV to CR
            current->regs.write_cr<Vmcb> (cr, current->regs.svm_read_gpr (gpr));
c0004ac1:	89 f2                	mov    %esi,%edx
c0004ac3:	8d 41 54             	lea    0x54(%ecx),%eax
c0004ac6:	e8 f5 a2 00 00       	call   c000edc0 <_ZN8Exc_regs12svm_read_gprEj>
c0004acb:	8b 35 08 f0 ff cf    	mov    0xcffff008,%esi
c0004ad1:	89 da                	mov    %ebx,%edx
c0004ad3:	83 c6 54             	add    $0x54,%esi
c0004ad6:	89 c1                	mov    %eax,%ecx
c0004ad8:	89 f0                	mov    %esi,%eax
c0004ada:	e8 c5 a4 00 00       	call   c000efa4 <_ZN8Exc_regs8write_crI4VmcbEEvjm>
            len = 3;
c0004adf:	b9 03 00 00 00       	mov    $0x3,%ecx
            break;
c0004ae4:	eb 0d                	jmp    c0004af3 <_ZN2Ec6svm_crEv+0x107>

        default:
            die ("SVM decode failure");
c0004ae6:	8d 51 54             	lea    0x54(%ecx),%edx
c0004ae9:	b8 60 6f 01 c0       	mov    $0xc0016f60,%eax
c0004aee:	e8 19 f0 ff ff       	call   c0003b0c <_ZN2Ec3dieEPKcP8Exc_regs>
    }

    current->regs.vmcb->adjust_rip (len);
c0004af3:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
        }

        ALWAYS_INLINE
        inline void adjust_rip (mword len)
        {
            rip += len;
c0004af8:	31 db                	xor    %ebx,%ebx
c0004afa:	8b 40 74             	mov    0x74(%eax),%eax
c0004afd:	01 88 78 05 00 00    	add    %ecx,0x578(%eax)

            if (int_shadow)
c0004b03:	8b 50 6c             	mov    0x6c(%eax),%edx
        }

        ALWAYS_INLINE
        inline void adjust_rip (mword len)
        {
            rip += len;
c0004b06:	11 98 7c 05 00 00    	adc    %ebx,0x57c(%eax)

            if (int_shadow)
c0004b0c:	0b 50 68             	or     0x68(%eax),%edx
c0004b0f:	74 0e                	je     c0004b1f <_ZN2Ec6svm_crEv+0x133>
                int_shadow = 0;
c0004b11:	c7 40 68 00 00 00 00 	movl   $0x0,0x68(%eax)
c0004b18:	c7 40 6c 00 00 00 00 	movl   $0x0,0x6c(%eax)
    ret_user_vmrun();
c0004b1f:	e8 20 ef ff ff       	call   c0003a44 <_ZN2Ec14ret_user_vmrunEv>

c0004b24 <svm_handler>:
}

void Ec::handle_svm()
{
    current->regs.vmcb->tlb_control = 0;
c0004b24:	8b 15 08 f0 ff cf    	mov    0xcffff008,%edx
c0004b2a:	8b 42 74             	mov    0x74(%edx),%eax
c0004b2d:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)

    mword reason = static_cast<mword>(current->regs.vmcb->exitcode);
c0004b34:	8b 4a 74             	mov    0x74(%edx),%ecx
c0004b37:	8b 41 70             	mov    0x70(%ecx),%eax

    switch (reason) {
c0004b3a:	3d 00 04 00 00       	cmp    $0x400,%eax
c0004b3f:	74 0d                	je     c0004b4e <svm_handler+0x2a>
        case -1UL:              // Invalid state
            reason = NUM_VMI - 3;
c0004b41:	83 f8 ff             	cmp    $0xffffffff,%eax
c0004b44:	b9 fd 00 00 00       	mov    $0xfd,%ecx
c0004b49:	0f 44 c1             	cmove  %ecx,%eax
c0004b4c:	eb 1a                	jmp    c0004b68 <svm_handler+0x44>
            break;
        case 0x400:             // NPT
            reason = NUM_VMI - 4;
            current->regs.nst_error = static_cast<mword>(current->regs.vmcb->exitinfo1);
c0004b4e:	8b 41 78             	mov    0x78(%ecx),%eax
c0004b51:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
            current->regs.nst_fault = static_cast<mword>(current->regs.vmcb->exitinfo2);
c0004b57:	8b 81 80 00 00 00    	mov    0x80(%ecx),%eax
c0004b5d:	89 82 8c 00 00 00    	mov    %eax,0x8c(%edx)
    switch (reason) {
        case -1UL:              // Invalid state
            reason = NUM_VMI - 3;
            break;
        case 0x400:             // NPT
            reason = NUM_VMI - 4;
c0004b63:	b8 fc 00 00 00       	mov    $0xfc,%eax
            current->regs.nst_error = static_cast<mword>(current->regs.vmcb->exitinfo1);
            current->regs.nst_fault = static_cast<mword>(current->regs.vmcb->exitinfo2);
            break;
    }

    Counter::vmi[reason]++;
c0004b68:	ff 04 85 40 f0 ff cf 	incl   -0x30000fc0(,%eax,4)

    switch (reason) {
c0004b6f:	83 f8 5f             	cmp    $0x5f,%eax
c0004b72:	77 0f                	ja     c0004b83 <svm_handler+0x5f>
c0004b74:	83 f8 40             	cmp    $0x40,%eax
c0004b77:	73 19                	jae    c0004b92 <svm_handler+0x6e>
c0004b79:	83 f8 1f             	cmp    $0x1f,%eax
c0004b7c:	77 21                	ja     c0004b9f <svm_handler+0x7b>

        case 0x0 ... 0x1f:      // CR Access
            svm_cr();
c0004b7e:	e8 69 fe ff ff       	call   c00049ec <_ZN2Ec6svm_crEv>
            break;
    }

    Counter::vmi[reason]++;

    switch (reason) {
c0004b83:	83 f8 60             	cmp    $0x60,%eax
c0004b86:	74 0f                	je     c0004b97 <svm_handler+0x73>
c0004b88:	83 f8 79             	cmp    $0x79,%eax
c0004b8b:	75 12                	jne    c0004b9f <svm_handler+0x7b>
        case 0x60:              // EXTINT
            asm volatile ("sti; nop; cli" : : : "memory");
            ret_user_vmrun();

        case 0x79:              // INVLPG
            svm_invlpg();
c0004b8d:	e8 5a fd ff ff       	call   c00048ec <_ZN2Ec10svm_invlpgEv>

        case 0x0 ... 0x1f:      // CR Access
            svm_cr();

        case 0x40 ... 0x5f:     // Exception
            svm_exception (reason);
c0004b92:	e8 77 fc ff ff       	call   c000480e <_ZN2Ec13svm_exceptionEm>

        case 0x60:              // EXTINT
            asm volatile ("sti; nop; cli" : : : "memory");
c0004b97:	fb                   	sti    
c0004b98:	90                   	nop
c0004b99:	fa                   	cli    
            ret_user_vmrun();
c0004b9a:	e8 a5 ee ff ff       	call   c0003a44 <_ZN2Ec14ret_user_vmrunEv>

        case 0x79:              // INVLPG
            svm_invlpg();
    }

    current->regs.dst_portal = reason;
c0004b9f:	89 82 88 00 00 00    	mov    %eax,0x88(%edx)

    send_msg<ret_user_vmrun>();
c0004ba5:	e8 1a d0 00 00       	call   c0011bc4 <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv>

c0004baa <_ZN2Ec13vmx_exceptionEv>:
#include "vectors.hpp"
#include "vmx.hpp"
#include "vtlb.hpp"

void Ec::vmx_exception()
{
c0004baa:	56                   	push   %esi
c0004bab:	53                   	push   %ebx
c0004bac:	50                   	push   %eax
c0004bad:	b8 08 44 00 00       	mov    $0x4408,%eax
c0004bb2:	0f 78 c0             	vmread %eax,%eax
    mword vect_info = Vmcs::read (Vmcs::IDT_VECT_INFO);

    if (vect_info & 0x80000000) {
c0004bb5:	85 c0                	test   %eax,%eax
c0004bb7:	79 3d                	jns    c0004bf6 <_ZN2Ec13vmx_exceptionEv+0x4c>

        Vmcs::write (Vmcs::ENT_INTR_INFO, vect_info & ~0x1000);
c0004bb9:	89 c2                	mov    %eax,%edx
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
c0004bbb:	b9 16 40 00 00       	mov    $0x4016,%ecx
c0004bc0:	80 e6 ef             	and    $0xef,%dh
c0004bc3:	0f 79 ca             	vmwrite %edx,%ecx

        if (vect_info & 0x800)
c0004bc6:	f6 c4 08             	test   $0x8,%ah
c0004bc9:	74 0d                	je     c0004bd8 <_ZN2Ec13vmx_exceptionEv+0x2e>

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
c0004bcb:	ba 0a 44 00 00       	mov    $0x440a,%edx
c0004bd0:	0f 78 d2             	vmread %edx,%edx
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
c0004bd3:	b1 18                	mov    $0x18,%cl
c0004bd5:	0f 79 ca             	vmwrite %edx,%ecx
            Vmcs::write (Vmcs::ENT_INTR_ERROR, Vmcs::read (Vmcs::IDT_VECT_ERROR));

        if ((vect_info >> 8 & 0x7) >= 4 && (vect_info >> 8 & 0x7) <= 6)
c0004bd8:	c1 e8 08             	shr    $0x8,%eax
c0004bdb:	83 e0 07             	and    $0x7,%eax
c0004bde:	83 e8 04             	sub    $0x4,%eax
c0004be1:	83 f8 02             	cmp    $0x2,%eax
c0004be4:	77 10                	ja     c0004bf6 <_ZN2Ec13vmx_exceptionEv+0x4c>

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
c0004be6:	b8 0c 44 00 00       	mov    $0x440c,%eax
c0004beb:	0f 78 c0             	vmread %eax,%eax
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
c0004bee:	ba 1a 40 00 00       	mov    $0x401a,%edx
c0004bf3:	0f 79 d0             	vmwrite %eax,%edx

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
c0004bf6:	bb 04 44 00 00       	mov    $0x4404,%ebx
c0004bfb:	0f 78 db             	vmread %ebx,%ebx
            Vmcs::write (Vmcs::ENT_INST_LEN, Vmcs::read (Vmcs::EXI_INST_LEN));
    };

    mword intr_info = Vmcs::read (Vmcs::EXI_INTR_INFO);

    switch (intr_info & 0x7ff) {
c0004bfe:	89 d8                	mov    %ebx,%eax
c0004c00:	25 ff 07 00 00       	and    $0x7ff,%eax
c0004c05:	3d 07 03 00 00       	cmp    $0x307,%eax
c0004c0a:	74 23                	je     c0004c2f <_ZN2Ec13vmx_exceptionEv+0x85>
c0004c0c:	3d 0e 03 00 00       	cmp    $0x30e,%eax
c0004c11:	74 26                	je     c0004c39 <_ZN2Ec13vmx_exceptionEv+0x8f>
c0004c13:	3d 02 02 00 00       	cmp    $0x202,%eax
c0004c18:	74 11                	je     c0004c2b <_ZN2Ec13vmx_exceptionEv+0x81>

        default:
            current->regs.dst_portal = Vmcs::VMX_EXC_NMI;
c0004c1a:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0004c1f:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
c0004c26:	00 00 00 
c0004c29:	eb 6c                	jmp    c0004c97 <_ZN2Ec13vmx_exceptionEv+0xed>
            break;

        case 0x202:         // NMI
            asm volatile ("int $0x2" : : : "memory");
c0004c2b:	cd 02                	int    $0x2
c0004c2d:	eb 05                	jmp    c0004c34 <_ZN2Ec13vmx_exceptionEv+0x8a>
            ret_user_vmresume();

        case 0x307:         // #NM
            handle_exc_nm();
c0004c2f:	e8 46 f9 ff ff       	call   c000457a <_ZN2Ec13handle_exc_nmEv>
            ret_user_vmresume();
c0004c34:	e8 f3 f2 ff ff       	call   c0003f2c <_ZN2Ec17ret_user_vmresumeEv>

        case 0x30e:         // #PF
            mword err = Vmcs::read (Vmcs::EXI_INTR_ERROR);
c0004c39:	b8 06 44 00 00       	mov    $0x4406,%eax
c0004c3e:	0f 78 04 24          	vmread %eax,(%esp)
c0004c42:	be 00 64 00 00       	mov    $0x6400,%esi
c0004c47:	0f 78 f6             	vmread %esi,%esi
            mword cr2 = Vmcs::read (Vmcs::EXI_QUALIFICATION);

            switch (Vtlb::miss (&current->regs, cr2, err)) {
c0004c4a:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0004c4f:	89 e1                	mov    %esp,%ecx
c0004c51:	89 f2                	mov    %esi,%edx
c0004c53:	83 c0 54             	add    $0x54,%eax
c0004c56:	e8 d3 10 01 00       	call   c0015d2e <_ZN4Vtlb4missEP8Exc_regsmRm>
c0004c5b:	83 f8 01             	cmp    $0x1,%eax
c0004c5e:	74 1c                	je     c0004c7c <_ZN2Ec13vmx_exceptionEv+0xd2>
c0004c60:	83 f8 02             	cmp    $0x2,%eax
c0004c63:	74 06                	je     c0004c6b <_ZN2Ec13vmx_exceptionEv+0xc1>
c0004c65:	85 c0                	test   %eax,%eax
c0004c67:	75 2e                	jne    c0004c97 <_ZN2Ec13vmx_exceptionEv+0xed>
c0004c69:	eb c9                	jmp    c0004c34 <_ZN2Ec13vmx_exceptionEv+0x8a>

                case Vtlb::GPA_HPA:
                    current->regs.dst_portal = Vmcs::VMX_EPT_VIOLATION;
c0004c6b:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0004c70:	c7 80 88 00 00 00 30 	movl   $0x30,0x88(%eax)
c0004c77:	00 00 00 
                    break;
c0004c7a:	eb 1b                	jmp    c0004c97 <_ZN2Ec13vmx_exceptionEv+0xed>

                case Vtlb::GLA_GPA:
                    current->regs.cr2 = cr2;
c0004c7c:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
                    Vmcs::write (Vmcs::ENT_INTR_INFO,  intr_info & ~0x1000);
c0004c81:	80 e7 ef             	and    $0xef,%bh
                case Vtlb::GPA_HPA:
                    current->regs.dst_portal = Vmcs::VMX_EPT_VIOLATION;
                    break;

                case Vtlb::GLA_GPA:
                    current->regs.cr2 = cr2;
c0004c84:	89 70 60             	mov    %esi,0x60(%eax)
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
c0004c87:	b8 16 40 00 00       	mov    $0x4016,%eax
c0004c8c:	0f 79 c3             	vmwrite %ebx,%eax
c0004c8f:	b0 18                	mov    $0x18,%al
c0004c91:	0f 79 04 24          	vmwrite (%esp),%eax
c0004c95:	eb 9d                	jmp    c0004c34 <_ZN2Ec13vmx_exceptionEv+0x8a>
                case Vtlb::SUCCESS:
                    ret_user_vmresume();
            }
    }

    send_msg<ret_user_vmresume>();
c0004c97:	e8 00 cd 00 00       	call   c001199c <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv>

c0004c9c <_ZN2Ec10vmx_extintEv>:

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
c0004c9c:	b8 04 44 00 00       	mov    $0x4404,%eax
c0004ca1:	0f 78 c0             	vmread %eax,%eax
}

void Ec::vmx_extint()
{
    unsigned vector = Vmcs::read (Vmcs::EXI_INTR_INFO) & 0xff;
c0004ca4:	0f b6 c0             	movzbl %al,%eax

    if (vector >= VEC_IPI)
c0004ca7:	3d a6 00 00 00       	cmp    $0xa6,%eax
c0004cac:	76 07                	jbe    c0004cb5 <_ZN2Ec10vmx_extintEv+0x19>
        Lapic::ipi_vector (vector);
c0004cae:	e8 27 13 00 00       	call   c0005fda <ipi_vector>
c0004cb3:	eb 26                	jmp    c0004cdb <_ZN2Ec10vmx_extintEv+0x3f>
    else if (vector >= VEC_MSI)
c0004cb5:	75 0c                	jne    c0004cc3 <_ZN2Ec10vmx_extintEv+0x27>
        Dmar::vector (vector);
c0004cb7:	b8 a6 00 00 00       	mov    $0xa6,%eax
c0004cbc:	e8 99 db ff ff       	call   c000285a <msi_vector>
c0004cc1:	eb 18                	jmp    c0004cdb <_ZN2Ec10vmx_extintEv+0x3f>
    else if (vector >= VEC_LVT)
c0004cc3:	3d 9f 00 00 00       	cmp    $0x9f,%eax
c0004cc8:	76 07                	jbe    c0004cd1 <_ZN2Ec10vmx_extintEv+0x35>
        Lapic::lvt_vector (vector);
c0004cca:	e8 79 12 00 00       	call   c0005f48 <lvt_vector>
c0004ccf:	eb 0a                	jmp    c0004cdb <_ZN2Ec10vmx_extintEv+0x3f>
    else if (vector >= VEC_GSI)
c0004cd1:	83 f8 1f             	cmp    $0x1f,%eax
c0004cd4:	76 05                	jbe    c0004cdb <_ZN2Ec10vmx_extintEv+0x3f>
        Gsi::vector (vector);
c0004cd6:	e8 bb 0c 00 00       	call   c0005996 <gsi_vector>

    ret_user_vmresume();
c0004cdb:	e8 4c f2 ff ff       	call   c0003f2c <_ZN2Ec17ret_user_vmresumeEv>

c0004ce0 <_ZN2Ec10vmx_invlpgEv>:
c0004ce0:	ba 00 64 00 00       	mov    $0x6400,%edx
c0004ce5:	0f 78 d2             	vmread %edx,%edx
}

void Ec::vmx_invlpg()
{
    current->regs.tlb_flush<Vmcs>(Vmcs::read (Vmcs::EXI_QUALIFICATION));
c0004ce8:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0004ced:	83 c0 54             	add    $0x54,%eax
c0004cf0:	e8 61 98 00 00       	call   c000e556 <_ZNK8Exc_regs9tlb_flushI4VmcsEEvm>
c0004cf5:	b9 1e 68 00 00       	mov    $0x681e,%ecx
c0004cfa:	0f 78 ca             	vmread %ecx,%edx
c0004cfd:	b8 0c 44 00 00       	mov    $0x440c,%eax
c0004d02:	0f 78 c0             	vmread %eax,%eax
        }

        ALWAYS_INLINE
        static inline void adjust_rip()
        {
            write (GUEST_RIP, read (GUEST_RIP) + read (EXI_INST_LEN));
c0004d05:	01 d0                	add    %edx,%eax
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
c0004d07:	0f 79 c8             	vmwrite %eax,%ecx

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
c0004d0a:	b8 24 48 00 00       	mov    $0x4824,%eax
c0004d0f:	0f 78 c0             	vmread %eax,%eax
        static inline void adjust_rip()
        {
            write (GUEST_RIP, read (GUEST_RIP) + read (EXI_INST_LEN));

            uint32 intr = static_cast<uint32>(read (GUEST_INTR_STATE));
            if (EXPECT_FALSE (intr & 3))
c0004d12:	a8 03                	test   $0x3,%al
c0004d14:	74 0b                	je     c0004d21 <_ZN2Ec10vmx_invlpgEv+0x41>
                write (GUEST_INTR_STATE, intr & ~3);
c0004d16:	83 e0 fc             	and    $0xfffffffc,%eax
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
c0004d19:	ba 24 48 00 00       	mov    $0x4824,%edx
c0004d1e:	0f 79 d0             	vmwrite %eax,%edx
    Vmcs::adjust_rip();
    ret_user_vmresume();
c0004d21:	e8 06 f2 ff ff       	call   c0003f2c <_ZN2Ec17ret_user_vmresumeEv>

c0004d26 <_ZN2Ec6vmx_crEv>:
}

void Ec::vmx_cr()
{
c0004d26:	55                   	push   %ebp

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
c0004d27:	b8 00 64 00 00       	mov    $0x6400,%eax
c0004d2c:	57                   	push   %edi
c0004d2d:	56                   	push   %esi
c0004d2e:	53                   	push   %ebx
c0004d2f:	0f 78 c0             	vmread %eax,%eax
    mword qual = Vmcs::read (Vmcs::EXI_QUALIFICATION);

    unsigned gpr = qual >> 8 & 0xf;
    unsigned acc = qual >> 4 & 0x3;
c0004d32:	89 c2                	mov    %eax,%edx

void Ec::vmx_cr()
{
    mword qual = Vmcs::read (Vmcs::EXI_QUALIFICATION);

    unsigned gpr = qual >> 8 & 0xf;
c0004d34:	89 c6                	mov    %eax,%esi
    unsigned acc = qual >> 4 & 0x3;
c0004d36:	c1 ea 04             	shr    $0x4,%edx
    unsigned cr  = qual      & 0xf;
c0004d39:	89 c3                	mov    %eax,%ebx

void Ec::vmx_cr()
{
    mword qual = Vmcs::read (Vmcs::EXI_QUALIFICATION);

    unsigned gpr = qual >> 8 & 0xf;
c0004d3b:	c1 ee 08             	shr    $0x8,%esi
    unsigned acc = qual >> 4 & 0x3;
c0004d3e:	83 e2 03             	and    $0x3,%edx

void Ec::vmx_cr()
{
    mword qual = Vmcs::read (Vmcs::EXI_QUALIFICATION);

    unsigned gpr = qual >> 8 & 0xf;
c0004d41:	83 e6 0f             	and    $0xf,%esi
    unsigned acc = qual >> 4 & 0x3;
    unsigned cr  = qual      & 0xf;
c0004d44:	83 e3 0f             	and    $0xf,%ebx

    switch (acc) {
c0004d47:	83 fa 01             	cmp    $0x1,%edx
c0004d4a:	0f 84 eb 00 00 00    	je     c0004e3b <_ZN2Ec6vmx_crEv+0x115>
c0004d50:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0004d55:	72 23                	jb     c0004d7a <_ZN2Ec6vmx_crEv+0x54>

            assert (cr != 0 && cr != 4);
            current->regs.vmx_write_gpr (gpr, current->regs.read_cr<Vmcs> (cr));
            break;
        case 2:     // CLTS
            current->regs.write_cr<Vmcs> (cr, current->regs.read_cr<Vmcs> (cr) & ~Cpu::CR0_TS);
c0004d57:	89 da                	mov    %ebx,%edx
c0004d59:	83 c0 54             	add    $0x54,%eax
c0004d5c:	e8 95 a1 00 00       	call   c000eef6 <_ZNK8Exc_regs7read_crI4VmcsEEmj>
c0004d61:	89 da                	mov    %ebx,%edx
c0004d63:	83 e0 f7             	and    $0xfffffff7,%eax
c0004d66:	89 c1                	mov    %eax,%ecx
c0004d68:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0004d6d:	83 c0 54             	add    $0x54,%eax
c0004d70:	e8 ef a3 00 00       	call   c000f164 <_ZN8Exc_regs8write_crI4VmcsEEvjm>
            break;
c0004d75:	e9 0b 01 00 00       	jmp    c0004e85 <_ZN2Ec6vmx_crEv+0x15f>
    unsigned cr  = qual      & 0xf;

    switch (acc) {
        case 0:     // MOV to CR
        {
            if (cr == 8) {
c0004d7a:	83 fb 08             	cmp    $0x8,%ebx
c0004d7d:	0f 84 a9 00 00 00    	je     c0004e2c <_ZN2Ec6vmx_crEv+0x106>
                /* Let the VMM handle CR8 */
                current->regs.dst_portal = Vmcs::VMX_CR;
                send_msg<ret_user_vmresume>();
            }

            mword old_cr0 = current->regs.read_cr<Vmcs>(0);
c0004d83:	31 d2                	xor    %edx,%edx
c0004d85:	83 c0 54             	add    $0x54,%eax
c0004d88:	e8 69 a1 00 00       	call   c000eef6 <_ZNK8Exc_regs7read_crI4VmcsEEmj>
            mword old_cr4 = current->regs.read_cr<Vmcs>(4);
c0004d8d:	ba 04 00 00 00       	mov    $0x4,%edx
                /* Let the VMM handle CR8 */
                current->regs.dst_portal = Vmcs::VMX_CR;
                send_msg<ret_user_vmresume>();
            }

            mword old_cr0 = current->regs.read_cr<Vmcs>(0);
c0004d92:	89 c5                	mov    %eax,%ebp
            mword old_cr4 = current->regs.read_cr<Vmcs>(4);
c0004d94:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0004d99:	83 c0 54             	add    $0x54,%eax
c0004d9c:	e8 55 a1 00 00       	call   c000eef6 <_ZNK8Exc_regs7read_crI4VmcsEEmj>

            current->regs.write_cr<Vmcs> (cr, current->regs.vmx_read_gpr (gpr));
c0004da1:	89 f2                	mov    %esi,%edx
                current->regs.dst_portal = Vmcs::VMX_CR;
                send_msg<ret_user_vmresume>();
            }

            mword old_cr0 = current->regs.read_cr<Vmcs>(0);
            mword old_cr4 = current->regs.read_cr<Vmcs>(4);
c0004da3:	89 c7                	mov    %eax,%edi

            current->regs.write_cr<Vmcs> (cr, current->regs.vmx_read_gpr (gpr));
c0004da5:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0004daa:	83 c0 54             	add    $0x54,%eax
c0004dad:	e8 74 a0 00 00       	call   c000ee26 <_ZN8Exc_regs12vmx_read_gprEj>
c0004db2:	8b 0d 08 f0 ff cf    	mov    0xcffff008,%ecx
c0004db8:	89 da                	mov    %ebx,%edx
c0004dba:	8d 71 54             	lea    0x54(%ecx),%esi
c0004dbd:	89 c1                	mov    %eax,%ecx
c0004dbf:	89 f0                	mov    %esi,%eax
c0004dc1:	e8 9e a3 00 00       	call   c000f164 <_ZN8Exc_regs8write_crI4VmcsEEvjm>
             * Intel manual sections 4.4.1 of Vol. 3A and 26.3.2.4 of Vol. 3C
             * indicate the conditions when this is the case.
             */

            /* no update needed if nested paging is not enabled */
            if (!current->regs.nst_on)
c0004dc6:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0004dcb:	80 b8 94 00 00 00 00 	cmpb   $0x0,0x94(%eax)
c0004dd2:	0f 84 ad 00 00 00    	je     c0004e85 <_ZN2Ec6vmx_crEv+0x15f>
                break;

            mword cr0 = current->regs.read_cr<Vmcs>(0);
c0004dd8:	31 d2                	xor    %edx,%edx
c0004dda:	83 c0 54             	add    $0x54,%eax
c0004ddd:	e8 14 a1 00 00       	call   c000eef6 <_ZNK8Exc_regs7read_crI4VmcsEEmj>
            mword cr4 = current->regs.read_cr<Vmcs>(4);
c0004de2:	ba 04 00 00 00       	mov    $0x4,%edx

            /* no update needed if nested paging is not enabled */
            if (!current->regs.nst_on)
                break;

            mword cr0 = current->regs.read_cr<Vmcs>(0);
c0004de7:	89 c6                	mov    %eax,%esi
            mword cr4 = current->regs.read_cr<Vmcs>(4);
c0004de9:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0004dee:	83 c0 54             	add    $0x54,%eax
c0004df1:	e8 00 a1 00 00       	call   c000eef6 <_ZNK8Exc_regs7read_crI4VmcsEEmj>

            /* no update needed if not in protected mode with paging and PAE enabled */
            if (!((cr0 & Cpu::CR0_PE) &&
c0004df6:	f7 c6 01 00 00 00    	test   $0x1,%esi
c0004dfc:	0f 84 83 00 00 00    	je     c0004e85 <_ZN2Ec6vmx_crEv+0x15f>
c0004e02:	85 f6                	test   %esi,%esi
c0004e04:	79 7f                	jns    c0004e85 <_ZN2Ec6vmx_crEv+0x15f>
                  (cr0 & Cpu::CR0_PG) &&
                  (cr4 & Cpu::CR4_PAE)))
c0004e06:	a8 20                	test   $0x20,%al
c0004e08:	74 7b                	je     c0004e85 <_ZN2Ec6vmx_crEv+0x15f>
                break;

            /* no update needed if no relevant bits of CR0 or CR4 have changed */
            if ((cr != 3) &&
c0004e0a:	83 fb 03             	cmp    $0x3,%ebx
c0004e0d:	74 18                	je     c0004e27 <_ZN2Ec6vmx_crEv+0x101>
                ((cr0 & Cpu::CR0_CD) == (old_cr0 & Cpu::CR0_CD)) &&
c0004e0f:	31 ee                	xor    %ebp,%esi
c0004e11:	f7 c6 00 00 00 60    	test   $0x60000000,%esi
c0004e17:	75 0e                	jne    c0004e27 <_ZN2Ec6vmx_crEv+0x101>
                ((cr0 & Cpu::CR0_NW) == (old_cr0 & Cpu::CR0_NW)) &&
c0004e19:	85 f6                	test   %esi,%esi
c0004e1b:	78 0a                	js     c0004e27 <_ZN2Ec6vmx_crEv+0x101>
                ((cr0 & Cpu::CR0_PG) == (old_cr0 & Cpu::CR0_PG)) &&
                ((cr4 & Cpu::CR4_PAE) == (old_cr4 & Cpu::CR4_PAE)) &&
                ((cr4 & Cpu::CR4_PGE) == (old_cr4 & Cpu::CR4_PGE)) &&
                ((cr4 & Cpu::CR4_PSE) == (old_cr4 & Cpu::CR4_PSE)) &&
c0004e1d:	31 c7                	xor    %eax,%edi
c0004e1f:	81 e7 b0 00 10 00    	and    $0x1000b0,%edi
c0004e25:	74 5e                	je     c0004e85 <_ZN2Ec6vmx_crEv+0x15f>
                ((cr4 & Cpu::CR4_SMEP) == (old_cr4 & Cpu::CR4_SMEP)))
               break;

            /* PDPTE register update necessary */
            current->regs.dst_portal = Vmcs::VMX_CR;
c0004e27:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0004e2c:	c7 80 88 00 00 00 1c 	movl   $0x1c,0x88(%eax)
c0004e33:	00 00 00 
            send_msg<ret_user_vmresume>();
c0004e36:	e8 61 cb 00 00       	call   c001199c <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv>

            break;
        }
        case 1:     // MOV from CR

            if (cr == 8) {
c0004e3b:	83 fb 08             	cmp    $0x8,%ebx
c0004e3e:	74 e7                	je     c0004e27 <_ZN2Ec6vmx_crEv+0x101>
                /* Let the VMM handle CR8 */
                current->regs.dst_portal = Vmcs::VMX_CR;
                send_msg<ret_user_vmresume>();
            }

            assert (cr != 0 && cr != 4);
c0004e40:	a8 0b                	test   $0xb,%al
c0004e42:	75 1e                	jne    c0004e62 <_ZN2Ec6vmx_crEv+0x13c>
c0004e44:	68 30 70 01 c0       	push   $0xc0017030
c0004e49:	68 ad 00 00 00       	push   $0xad
c0004e4e:	68 ad 6f 01 c0       	push   $0xc0016fad
c0004e53:	68 1c 70 01 c0       	push   $0xc001701c
c0004e58:	68 69 60 01 c0       	push   $0xc0016069
c0004e5d:	e8 e4 ca ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>
            current->regs.vmx_write_gpr (gpr, current->regs.read_cr<Vmcs> (cr));
c0004e62:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0004e67:	89 da                	mov    %ebx,%edx
c0004e69:	83 c0 54             	add    $0x54,%eax
c0004e6c:	e8 85 a0 00 00       	call   c000eef6 <_ZNK8Exc_regs7read_crI4VmcsEEmj>
c0004e71:	8b 3d 08 f0 ff cf    	mov    0xcffff008,%edi
c0004e77:	89 f2                	mov    %esi,%edx
c0004e79:	8d 5f 54             	lea    0x54(%edi),%ebx
c0004e7c:	89 c1                	mov    %eax,%ecx
c0004e7e:	89 d8                	mov    %ebx,%eax
c0004e80:	e8 bb 9f 00 00       	call   c000ee40 <_ZN8Exc_regs13vmx_write_gprEjm>
c0004e85:	b9 1e 68 00 00       	mov    $0x681e,%ecx
c0004e8a:	0f 78 ca             	vmread %ecx,%edx
c0004e8d:	b8 0c 44 00 00       	mov    $0x440c,%eax
c0004e92:	0f 78 c0             	vmread %eax,%eax
        }

        ALWAYS_INLINE
        static inline void adjust_rip()
        {
            write (GUEST_RIP, read (GUEST_RIP) + read (EXI_INST_LEN));
c0004e95:	01 d0                	add    %edx,%eax
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
c0004e97:	0f 79 c8             	vmwrite %eax,%ecx

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
c0004e9a:	b8 24 48 00 00       	mov    $0x4824,%eax
c0004e9f:	0f 78 c0             	vmread %eax,%eax
        static inline void adjust_rip()
        {
            write (GUEST_RIP, read (GUEST_RIP) + read (EXI_INST_LEN));

            uint32 intr = static_cast<uint32>(read (GUEST_INTR_STATE));
            if (EXPECT_FALSE (intr & 3))
c0004ea2:	a8 03                	test   $0x3,%al
c0004ea4:	74 0b                	je     c0004eb1 <_ZN2Ec6vmx_crEv+0x18b>
                write (GUEST_INTR_STATE, intr & ~3);
c0004ea6:	83 e0 fc             	and    $0xfffffffc,%eax
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
c0004ea9:	ba 24 48 00 00       	mov    $0x4824,%edx
c0004eae:	0f 79 d0             	vmwrite %eax,%edx
        default:
            UNREACHED;
    }

    Vmcs::adjust_rip();
    ret_user_vmresume();
c0004eb1:	e8 76 f0 ff ff       	call   c0003f2c <_ZN2Ec17ret_user_vmresumeEv>

c0004eb6 <vmx_handler>:
}

void Ec::handle_vmx()
{
    Cpu::hazard = (Cpu::hazard | HZD_DS_ES | HZD_TR) & ~HZD_FPU;
c0004eb6:	a1 00 f0 ff cf       	mov    0xcffff000,%eax
c0004ebb:	83 e0 f1             	and    $0xfffffff1,%eax
c0004ebe:	83 c8 06             	or     $0x6,%eax
c0004ec1:	a3 00 f0 ff cf       	mov    %eax,0xcffff000

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
c0004ec6:	b8 02 44 00 00       	mov    $0x4402,%eax
c0004ecb:	0f 78 c0             	vmread %eax,%eax

    mword reason = Vmcs::read (Vmcs::EXI_REASON) & 0xff;
c0004ece:	0f b6 c0             	movzbl %al,%eax

    Counter::vmi[reason]++;
c0004ed1:	ff 04 85 40 f0 ff cf 	incl   -0x30000fc0(,%eax,4)

    switch (reason) {
c0004ed8:	83 f8 0e             	cmp    $0xe,%eax
c0004edb:	74 3e                	je     c0004f1b <vmx_handler+0x65>
c0004edd:	8b 15 08 f0 ff cf    	mov    0xcffff008,%edx
c0004ee3:	77 0e                	ja     c0004ef3 <vmx_handler+0x3d>
c0004ee5:	85 c0                	test   %eax,%eax
c0004ee7:	74 2d                	je     c0004f16 <vmx_handler+0x60>
c0004ee9:	83 f8 01             	cmp    $0x1,%eax
c0004eec:	75 37                	jne    c0004f25 <vmx_handler+0x6f>
        case Vmcs::VMX_EXC_NMI:     vmx_exception();
        case Vmcs::VMX_EXTINT:      vmx_extint();
c0004eee:	e8 a9 fd ff ff       	call   c0004c9c <_ZN2Ec10vmx_extintEv>

    mword reason = Vmcs::read (Vmcs::EXI_REASON) & 0xff;

    Counter::vmi[reason]++;

    switch (reason) {
c0004ef3:	83 f8 1c             	cmp    $0x1c,%eax
c0004ef6:	74 28                	je     c0004f20 <vmx_handler+0x6a>
c0004ef8:	83 f8 30             	cmp    $0x30,%eax
c0004efb:	75 28                	jne    c0004f25 <vmx_handler+0x6f>
        case Vmcs::VMX_EXC_NMI:     vmx_exception();
        case Vmcs::VMX_EXTINT:      vmx_extint();
        case Vmcs::VMX_INVLPG:      vmx_invlpg();
        case Vmcs::VMX_CR:          vmx_cr();
        case Vmcs::VMX_EPT_VIOLATION:
            current->regs.nst_error = Vmcs::read (Vmcs::EXI_QUALIFICATION);
c0004efd:	b9 00 64 00 00       	mov    $0x6400,%ecx
c0004f02:	0f 78 8a 90 00 00 00 	vmread %ecx,0x90(%edx)
            current->regs.nst_fault = Vmcs::read (Vmcs::INFO_PHYS_ADDR);
c0004f09:	66 b9 00 24          	mov    $0x2400,%cx
c0004f0d:	0f 78 8a 8c 00 00 00 	vmread %ecx,0x8c(%edx)
            break;
c0004f14:	eb 0f                	jmp    c0004f25 <vmx_handler+0x6f>
    mword reason = Vmcs::read (Vmcs::EXI_REASON) & 0xff;

    Counter::vmi[reason]++;

    switch (reason) {
        case Vmcs::VMX_EXC_NMI:     vmx_exception();
c0004f16:	e8 8f fc ff ff       	call   c0004baa <_ZN2Ec13vmx_exceptionEv>
        case Vmcs::VMX_EXTINT:      vmx_extint();
        case Vmcs::VMX_INVLPG:      vmx_invlpg();
c0004f1b:	e8 c0 fd ff ff       	call   c0004ce0 <_ZN2Ec10vmx_invlpgEv>
        case Vmcs::VMX_CR:          vmx_cr();
c0004f20:	e8 01 fe ff ff       	call   c0004d26 <_ZN2Ec6vmx_crEv>
            current->regs.nst_error = Vmcs::read (Vmcs::EXI_QUALIFICATION);
            current->regs.nst_fault = Vmcs::read (Vmcs::INFO_PHYS_ADDR);
            break;
    }

    current->regs.dst_portal = reason;
c0004f25:	89 82 88 00 00 00    	mov    %eax,0x88(%edx)

    send_msg<ret_user_vmresume>();
c0004f2b:	e8 6c ca 00 00       	call   c001199c <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv>

c0004f30 <entry_exc>:
.endm

/*
 * Exception Entries
 */
entry_exc:              push    $0
c0004f30:	6a 00                	push   $0x0

c0004f32 <entry_exc_error>:
entry_exc_error:        SAVE_STATE
c0004f32:	1e                   	push   %ds
c0004f33:	06                   	push   %es
c0004f34:	0f a0                	push   %fs
c0004f36:	0f a8                	push   %gs
c0004f38:	60                   	pusha  
c0004f39:	89 e3                	mov    %esp,%ebx
c0004f3b:	81 fc 00 d0 ff cf    	cmp    $0xcfffd000,%esp
c0004f41:	73 0f                	jae    c0004f52 <entry_exc_error+0x20>
c0004f43:	fc                   	cld    
c0004f44:	bc 00 e0 ff cf       	mov    $0xcfffe000,%esp
c0004f49:	b8 23 00 00 00       	mov    $0x23,%eax
c0004f4e:	8e d8                	mov    %eax,%ds
c0004f50:	8e c0                	mov    %eax,%es
                        mov     %cr2, %REG(ax)
c0004f52:	0f 20 d0             	mov    %cr2,%eax
                        mov     %REG(ax), OFS_CR2 (%REG(bx))
c0004f55:	89 43 0c             	mov    %eax,0xc(%ebx)
                        mov     %REG(bx), %ARG_1
c0004f58:	89 d8                	mov    %ebx,%eax
                        call    exc_handler
c0004f5a:	e8 e5 f7 ff ff       	call   c0004744 <exc_handler>
                        jmp     ret_from_interrupt
c0004f5f:	e9 e3 05 00 00       	jmp    c0005547 <ret_from_interrupt>

EXCEPTION               0x0,    0
c0004f64:	6a 00                	push   $0x0
c0004f66:	eb c8                	jmp    c0004f30 <entry_exc>
EXCEPTION               0x1,    0
c0004f68:	f6 44 24 04 03       	testb  $0x3,0x4(%esp)
c0004f6d:	0f 84 e8 05 00 00    	je     c000555b <entry_sysenter_db>
c0004f73:	6a 01                	push   $0x1
c0004f75:	eb b9                	jmp    c0004f30 <entry_exc>
c0004f77:	90                   	nop
TASKGATE
EXCEPTION               0x3,    3
c0004f78:	6a 03                	push   $0x3
c0004f7a:	eb b4                	jmp    c0004f30 <entry_exc>
EXCEPTION               0x4,    3
c0004f7c:	6a 04                	push   $0x4
c0004f7e:	eb b0                	jmp    c0004f30 <entry_exc>
EXCEPTION               0x5,    0
c0004f80:	6a 05                	push   $0x5
c0004f82:	eb ac                	jmp    c0004f30 <entry_exc>
EXCEPTION               0x6,    0
c0004f84:	6a 06                	push   $0x6
c0004f86:	eb a8                	jmp    c0004f30 <entry_exc>
EXCEPTION               0x7,    0
c0004f88:	6a 07                	push   $0x7
c0004f8a:	eb a4                	jmp    c0004f30 <entry_exc>
TASKGATE
TASKGATE
EXCEPTION_ERROR         0xa,    0
c0004f8c:	ff 34 24             	pushl  (%esp)
c0004f8f:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
c0004f96:	00 
c0004f97:	eb 99                	jmp    c0004f32 <entry_exc_error>
c0004f99:	8d 76 00             	lea    0x0(%esi),%esi
EXCEPTION_ERROR         0xb,    0
c0004f9c:	ff 34 24             	pushl  (%esp)
c0004f9f:	c7 44 24 04 0b 00 00 	movl   $0xb,0x4(%esp)
c0004fa6:	00 
c0004fa7:	eb 89                	jmp    c0004f32 <entry_exc_error>
c0004fa9:	8d 76 00             	lea    0x0(%esi),%esi
EXCEPTION_ERROR         0xc,    0
c0004fac:	ff 34 24             	pushl  (%esp)
c0004faf:	c7 44 24 04 0c 00 00 	movl   $0xc,0x4(%esp)
c0004fb6:	00 
c0004fb7:	e9 76 ff ff ff       	jmp    c0004f32 <entry_exc_error>
EXCEPTION_ERROR         0xd,    0
c0004fbc:	ff 34 24             	pushl  (%esp)
c0004fbf:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp)
c0004fc6:	00 
c0004fc7:	e9 66 ff ff ff       	jmp    c0004f32 <entry_exc_error>
EXCEPTION_ERROR         0xe,    0
c0004fcc:	ff 34 24             	pushl  (%esp)
c0004fcf:	c7 44 24 04 0e 00 00 	movl   $0xe,0x4(%esp)
c0004fd6:	00 
c0004fd7:	e9 56 ff ff ff       	jmp    c0004f32 <entry_exc_error>
TASKGATE
EXCEPTION               0x10,   0
c0004fdc:	6a 10                	push   $0x10
c0004fde:	e9 4d ff ff ff       	jmp    c0004f30 <entry_exc>
c0004fe3:	90                   	nop
EXCEPTION_ERROR         0x11,   0
c0004fe4:	ff 34 24             	pushl  (%esp)
c0004fe7:	c7 44 24 04 11 00 00 	movl   $0x11,0x4(%esp)
c0004fee:	00 
c0004fef:	e9 3e ff ff ff       	jmp    c0004f32 <entry_exc_error>
EXCEPTION               0x12,   0
c0004ff4:	6a 12                	push   $0x12
c0004ff6:	e9 35 ff ff ff       	jmp    c0004f30 <entry_exc>
c0004ffb:	90                   	nop
EXCEPTION               0x13,   0
c0004ffc:	6a 13                	push   $0x13
c0004ffe:	e9 2d ff ff ff       	jmp    c0004f30 <entry_exc>
c0005003:	90                   	nop
.rept                   NUM_GSI
INTRGATE                0
                        push    $VEC
                        jmp     entry_gsi
.set                    VEC, VEC + 1
.endr
c0005004:	6a 20                	push   $0x20
c0005006:	e9 38 04 00 00       	jmp    c0005443 <entry_gsi>
c000500b:	90                   	nop
c000500c:	6a 21                	push   $0x21
c000500e:	e9 30 04 00 00       	jmp    c0005443 <entry_gsi>
c0005013:	90                   	nop
c0005014:	6a 22                	push   $0x22
c0005016:	e9 28 04 00 00       	jmp    c0005443 <entry_gsi>
c000501b:	90                   	nop
c000501c:	6a 23                	push   $0x23
c000501e:	e9 20 04 00 00       	jmp    c0005443 <entry_gsi>
c0005023:	90                   	nop
c0005024:	6a 24                	push   $0x24
c0005026:	e9 18 04 00 00       	jmp    c0005443 <entry_gsi>
c000502b:	90                   	nop
c000502c:	6a 25                	push   $0x25
c000502e:	e9 10 04 00 00       	jmp    c0005443 <entry_gsi>
c0005033:	90                   	nop
c0005034:	6a 26                	push   $0x26
c0005036:	e9 08 04 00 00       	jmp    c0005443 <entry_gsi>
c000503b:	90                   	nop
c000503c:	6a 27                	push   $0x27
c000503e:	e9 00 04 00 00       	jmp    c0005443 <entry_gsi>
c0005043:	90                   	nop
c0005044:	6a 28                	push   $0x28
c0005046:	e9 f8 03 00 00       	jmp    c0005443 <entry_gsi>
c000504b:	90                   	nop
c000504c:	6a 29                	push   $0x29
c000504e:	e9 f0 03 00 00       	jmp    c0005443 <entry_gsi>
c0005053:	90                   	nop
c0005054:	6a 2a                	push   $0x2a
c0005056:	e9 e8 03 00 00       	jmp    c0005443 <entry_gsi>
c000505b:	90                   	nop
c000505c:	6a 2b                	push   $0x2b
c000505e:	e9 e0 03 00 00       	jmp    c0005443 <entry_gsi>
c0005063:	90                   	nop
c0005064:	6a 2c                	push   $0x2c
c0005066:	e9 d8 03 00 00       	jmp    c0005443 <entry_gsi>
c000506b:	90                   	nop
c000506c:	6a 2d                	push   $0x2d
c000506e:	e9 d0 03 00 00       	jmp    c0005443 <entry_gsi>
c0005073:	90                   	nop
c0005074:	6a 2e                	push   $0x2e
c0005076:	e9 c8 03 00 00       	jmp    c0005443 <entry_gsi>
c000507b:	90                   	nop
c000507c:	6a 2f                	push   $0x2f
c000507e:	e9 c0 03 00 00       	jmp    c0005443 <entry_gsi>
c0005083:	90                   	nop
c0005084:	6a 30                	push   $0x30
c0005086:	e9 b8 03 00 00       	jmp    c0005443 <entry_gsi>
c000508b:	90                   	nop
c000508c:	6a 31                	push   $0x31
c000508e:	e9 b0 03 00 00       	jmp    c0005443 <entry_gsi>
c0005093:	90                   	nop
c0005094:	6a 32                	push   $0x32
c0005096:	e9 a8 03 00 00       	jmp    c0005443 <entry_gsi>
c000509b:	90                   	nop
c000509c:	6a 33                	push   $0x33
c000509e:	e9 a0 03 00 00       	jmp    c0005443 <entry_gsi>
c00050a3:	90                   	nop
c00050a4:	6a 34                	push   $0x34
c00050a6:	e9 98 03 00 00       	jmp    c0005443 <entry_gsi>
c00050ab:	90                   	nop
c00050ac:	6a 35                	push   $0x35
c00050ae:	e9 90 03 00 00       	jmp    c0005443 <entry_gsi>
c00050b3:	90                   	nop
c00050b4:	6a 36                	push   $0x36
c00050b6:	e9 88 03 00 00       	jmp    c0005443 <entry_gsi>
c00050bb:	90                   	nop
c00050bc:	6a 37                	push   $0x37
c00050be:	e9 80 03 00 00       	jmp    c0005443 <entry_gsi>
c00050c3:	90                   	nop
c00050c4:	6a 38                	push   $0x38
c00050c6:	e9 78 03 00 00       	jmp    c0005443 <entry_gsi>
c00050cb:	90                   	nop
c00050cc:	6a 39                	push   $0x39
c00050ce:	e9 70 03 00 00       	jmp    c0005443 <entry_gsi>
c00050d3:	90                   	nop
c00050d4:	6a 3a                	push   $0x3a
c00050d6:	e9 68 03 00 00       	jmp    c0005443 <entry_gsi>
c00050db:	90                   	nop
c00050dc:	6a 3b                	push   $0x3b
c00050de:	e9 60 03 00 00       	jmp    c0005443 <entry_gsi>
c00050e3:	90                   	nop
c00050e4:	6a 3c                	push   $0x3c
c00050e6:	e9 58 03 00 00       	jmp    c0005443 <entry_gsi>
c00050eb:	90                   	nop
c00050ec:	6a 3d                	push   $0x3d
c00050ee:	e9 50 03 00 00       	jmp    c0005443 <entry_gsi>
c00050f3:	90                   	nop
c00050f4:	6a 3e                	push   $0x3e
c00050f6:	e9 48 03 00 00       	jmp    c0005443 <entry_gsi>
c00050fb:	90                   	nop
c00050fc:	6a 3f                	push   $0x3f
c00050fe:	e9 40 03 00 00       	jmp    c0005443 <entry_gsi>
c0005103:	90                   	nop
c0005104:	6a 40                	push   $0x40
c0005106:	e9 38 03 00 00       	jmp    c0005443 <entry_gsi>
c000510b:	90                   	nop
c000510c:	6a 41                	push   $0x41
c000510e:	e9 30 03 00 00       	jmp    c0005443 <entry_gsi>
c0005113:	90                   	nop
c0005114:	6a 42                	push   $0x42
c0005116:	e9 28 03 00 00       	jmp    c0005443 <entry_gsi>
c000511b:	90                   	nop
c000511c:	6a 43                	push   $0x43
c000511e:	e9 20 03 00 00       	jmp    c0005443 <entry_gsi>
c0005123:	90                   	nop
c0005124:	6a 44                	push   $0x44
c0005126:	e9 18 03 00 00       	jmp    c0005443 <entry_gsi>
c000512b:	90                   	nop
c000512c:	6a 45                	push   $0x45
c000512e:	e9 10 03 00 00       	jmp    c0005443 <entry_gsi>
c0005133:	90                   	nop
c0005134:	6a 46                	push   $0x46
c0005136:	e9 08 03 00 00       	jmp    c0005443 <entry_gsi>
c000513b:	90                   	nop
c000513c:	6a 47                	push   $0x47
c000513e:	e9 00 03 00 00       	jmp    c0005443 <entry_gsi>
c0005143:	90                   	nop
c0005144:	6a 48                	push   $0x48
c0005146:	e9 f8 02 00 00       	jmp    c0005443 <entry_gsi>
c000514b:	90                   	nop
c000514c:	6a 49                	push   $0x49
c000514e:	e9 f0 02 00 00       	jmp    c0005443 <entry_gsi>
c0005153:	90                   	nop
c0005154:	6a 4a                	push   $0x4a
c0005156:	e9 e8 02 00 00       	jmp    c0005443 <entry_gsi>
c000515b:	90                   	nop
c000515c:	6a 4b                	push   $0x4b
c000515e:	e9 e0 02 00 00       	jmp    c0005443 <entry_gsi>
c0005163:	90                   	nop
c0005164:	6a 4c                	push   $0x4c
c0005166:	e9 d8 02 00 00       	jmp    c0005443 <entry_gsi>
c000516b:	90                   	nop
c000516c:	6a 4d                	push   $0x4d
c000516e:	e9 d0 02 00 00       	jmp    c0005443 <entry_gsi>
c0005173:	90                   	nop
c0005174:	6a 4e                	push   $0x4e
c0005176:	e9 c8 02 00 00       	jmp    c0005443 <entry_gsi>
c000517b:	90                   	nop
c000517c:	6a 4f                	push   $0x4f
c000517e:	e9 c0 02 00 00       	jmp    c0005443 <entry_gsi>
c0005183:	90                   	nop
c0005184:	6a 50                	push   $0x50
c0005186:	e9 b8 02 00 00       	jmp    c0005443 <entry_gsi>
c000518b:	90                   	nop
c000518c:	6a 51                	push   $0x51
c000518e:	e9 b0 02 00 00       	jmp    c0005443 <entry_gsi>
c0005193:	90                   	nop
c0005194:	6a 52                	push   $0x52
c0005196:	e9 a8 02 00 00       	jmp    c0005443 <entry_gsi>
c000519b:	90                   	nop
c000519c:	6a 53                	push   $0x53
c000519e:	e9 a0 02 00 00       	jmp    c0005443 <entry_gsi>
c00051a3:	90                   	nop
c00051a4:	6a 54                	push   $0x54
c00051a6:	e9 98 02 00 00       	jmp    c0005443 <entry_gsi>
c00051ab:	90                   	nop
c00051ac:	6a 55                	push   $0x55
c00051ae:	e9 90 02 00 00       	jmp    c0005443 <entry_gsi>
c00051b3:	90                   	nop
c00051b4:	6a 56                	push   $0x56
c00051b6:	e9 88 02 00 00       	jmp    c0005443 <entry_gsi>
c00051bb:	90                   	nop
c00051bc:	6a 57                	push   $0x57
c00051be:	e9 80 02 00 00       	jmp    c0005443 <entry_gsi>
c00051c3:	90                   	nop
c00051c4:	6a 58                	push   $0x58
c00051c6:	e9 78 02 00 00       	jmp    c0005443 <entry_gsi>
c00051cb:	90                   	nop
c00051cc:	6a 59                	push   $0x59
c00051ce:	e9 70 02 00 00       	jmp    c0005443 <entry_gsi>
c00051d3:	90                   	nop
c00051d4:	6a 5a                	push   $0x5a
c00051d6:	e9 68 02 00 00       	jmp    c0005443 <entry_gsi>
c00051db:	90                   	nop
c00051dc:	6a 5b                	push   $0x5b
c00051de:	e9 60 02 00 00       	jmp    c0005443 <entry_gsi>
c00051e3:	90                   	nop
c00051e4:	6a 5c                	push   $0x5c
c00051e6:	e9 58 02 00 00       	jmp    c0005443 <entry_gsi>
c00051eb:	90                   	nop
c00051ec:	6a 5d                	push   $0x5d
c00051ee:	e9 50 02 00 00       	jmp    c0005443 <entry_gsi>
c00051f3:	90                   	nop
c00051f4:	6a 5e                	push   $0x5e
c00051f6:	e9 48 02 00 00       	jmp    c0005443 <entry_gsi>
c00051fb:	90                   	nop
c00051fc:	6a 5f                	push   $0x5f
c00051fe:	e9 40 02 00 00       	jmp    c0005443 <entry_gsi>
c0005203:	90                   	nop
c0005204:	6a 60                	push   $0x60
c0005206:	e9 38 02 00 00       	jmp    c0005443 <entry_gsi>
c000520b:	90                   	nop
c000520c:	6a 61                	push   $0x61
c000520e:	e9 30 02 00 00       	jmp    c0005443 <entry_gsi>
c0005213:	90                   	nop
c0005214:	6a 62                	push   $0x62
c0005216:	e9 28 02 00 00       	jmp    c0005443 <entry_gsi>
c000521b:	90                   	nop
c000521c:	6a 63                	push   $0x63
c000521e:	e9 20 02 00 00       	jmp    c0005443 <entry_gsi>
c0005223:	90                   	nop
c0005224:	6a 64                	push   $0x64
c0005226:	e9 18 02 00 00       	jmp    c0005443 <entry_gsi>
c000522b:	90                   	nop
c000522c:	6a 65                	push   $0x65
c000522e:	e9 10 02 00 00       	jmp    c0005443 <entry_gsi>
c0005233:	90                   	nop
c0005234:	6a 66                	push   $0x66
c0005236:	e9 08 02 00 00       	jmp    c0005443 <entry_gsi>
c000523b:	90                   	nop
c000523c:	6a 67                	push   $0x67
c000523e:	e9 00 02 00 00       	jmp    c0005443 <entry_gsi>
c0005243:	90                   	nop
c0005244:	6a 68                	push   $0x68
c0005246:	e9 f8 01 00 00       	jmp    c0005443 <entry_gsi>
c000524b:	90                   	nop
c000524c:	6a 69                	push   $0x69
c000524e:	e9 f0 01 00 00       	jmp    c0005443 <entry_gsi>
c0005253:	90                   	nop
c0005254:	6a 6a                	push   $0x6a
c0005256:	e9 e8 01 00 00       	jmp    c0005443 <entry_gsi>
c000525b:	90                   	nop
c000525c:	6a 6b                	push   $0x6b
c000525e:	e9 e0 01 00 00       	jmp    c0005443 <entry_gsi>
c0005263:	90                   	nop
c0005264:	6a 6c                	push   $0x6c
c0005266:	e9 d8 01 00 00       	jmp    c0005443 <entry_gsi>
c000526b:	90                   	nop
c000526c:	6a 6d                	push   $0x6d
c000526e:	e9 d0 01 00 00       	jmp    c0005443 <entry_gsi>
c0005273:	90                   	nop
c0005274:	6a 6e                	push   $0x6e
c0005276:	e9 c8 01 00 00       	jmp    c0005443 <entry_gsi>
c000527b:	90                   	nop
c000527c:	6a 6f                	push   $0x6f
c000527e:	e9 c0 01 00 00       	jmp    c0005443 <entry_gsi>
c0005283:	90                   	nop
c0005284:	6a 70                	push   $0x70
c0005286:	e9 b8 01 00 00       	jmp    c0005443 <entry_gsi>
c000528b:	90                   	nop
c000528c:	6a 71                	push   $0x71
c000528e:	e9 b0 01 00 00       	jmp    c0005443 <entry_gsi>
c0005293:	90                   	nop
c0005294:	6a 72                	push   $0x72
c0005296:	e9 a8 01 00 00       	jmp    c0005443 <entry_gsi>
c000529b:	90                   	nop
c000529c:	6a 73                	push   $0x73
c000529e:	e9 a0 01 00 00       	jmp    c0005443 <entry_gsi>
c00052a3:	90                   	nop
c00052a4:	6a 74                	push   $0x74
c00052a6:	e9 98 01 00 00       	jmp    c0005443 <entry_gsi>
c00052ab:	90                   	nop
c00052ac:	6a 75                	push   $0x75
c00052ae:	e9 90 01 00 00       	jmp    c0005443 <entry_gsi>
c00052b3:	90                   	nop
c00052b4:	6a 76                	push   $0x76
c00052b6:	e9 88 01 00 00       	jmp    c0005443 <entry_gsi>
c00052bb:	90                   	nop
c00052bc:	6a 77                	push   $0x77
c00052be:	e9 80 01 00 00       	jmp    c0005443 <entry_gsi>
c00052c3:	90                   	nop
c00052c4:	6a 78                	push   $0x78
c00052c6:	e9 78 01 00 00       	jmp    c0005443 <entry_gsi>
c00052cb:	90                   	nop
c00052cc:	6a 79                	push   $0x79
c00052ce:	e9 70 01 00 00       	jmp    c0005443 <entry_gsi>
c00052d3:	90                   	nop
c00052d4:	6a 7a                	push   $0x7a
c00052d6:	e9 68 01 00 00       	jmp    c0005443 <entry_gsi>
c00052db:	90                   	nop
c00052dc:	6a 7b                	push   $0x7b
c00052de:	e9 60 01 00 00       	jmp    c0005443 <entry_gsi>
c00052e3:	90                   	nop
c00052e4:	6a 7c                	push   $0x7c
c00052e6:	e9 58 01 00 00       	jmp    c0005443 <entry_gsi>
c00052eb:	90                   	nop
c00052ec:	6a 7d                	push   $0x7d
c00052ee:	e9 50 01 00 00       	jmp    c0005443 <entry_gsi>
c00052f3:	90                   	nop
c00052f4:	6a 7e                	push   $0x7e
c00052f6:	e9 48 01 00 00       	jmp    c0005443 <entry_gsi>
c00052fb:	90                   	nop
c00052fc:	6a 7f                	push   $0x7f
c00052fe:	e9 40 01 00 00       	jmp    c0005443 <entry_gsi>
c0005303:	90                   	nop
c0005304:	68 80 00 00 00       	push   $0x80
c0005309:	e9 35 01 00 00       	jmp    c0005443 <entry_gsi>
c000530e:	66 90                	xchg   %ax,%ax
c0005310:	68 81 00 00 00       	push   $0x81
c0005315:	e9 29 01 00 00       	jmp    c0005443 <entry_gsi>
c000531a:	66 90                	xchg   %ax,%ax
c000531c:	68 82 00 00 00       	push   $0x82
c0005321:	e9 1d 01 00 00       	jmp    c0005443 <entry_gsi>
c0005326:	66 90                	xchg   %ax,%ax
c0005328:	68 83 00 00 00       	push   $0x83
c000532d:	e9 11 01 00 00       	jmp    c0005443 <entry_gsi>
c0005332:	66 90                	xchg   %ax,%ax
c0005334:	68 84 00 00 00       	push   $0x84
c0005339:	e9 05 01 00 00       	jmp    c0005443 <entry_gsi>
c000533e:	66 90                	xchg   %ax,%ax
c0005340:	68 85 00 00 00       	push   $0x85
c0005345:	e9 f9 00 00 00       	jmp    c0005443 <entry_gsi>
c000534a:	66 90                	xchg   %ax,%ax
c000534c:	68 86 00 00 00       	push   $0x86
c0005351:	e9 ed 00 00 00       	jmp    c0005443 <entry_gsi>
c0005356:	66 90                	xchg   %ax,%ax
c0005358:	68 87 00 00 00       	push   $0x87
c000535d:	e9 e1 00 00 00       	jmp    c0005443 <entry_gsi>
c0005362:	66 90                	xchg   %ax,%ax
c0005364:	68 88 00 00 00       	push   $0x88
c0005369:	e9 d5 00 00 00       	jmp    c0005443 <entry_gsi>
c000536e:	66 90                	xchg   %ax,%ax
c0005370:	68 89 00 00 00       	push   $0x89
c0005375:	e9 c9 00 00 00       	jmp    c0005443 <entry_gsi>
c000537a:	66 90                	xchg   %ax,%ax
c000537c:	68 8a 00 00 00       	push   $0x8a
c0005381:	e9 bd 00 00 00       	jmp    c0005443 <entry_gsi>
c0005386:	66 90                	xchg   %ax,%ax
c0005388:	68 8b 00 00 00       	push   $0x8b
c000538d:	e9 b1 00 00 00       	jmp    c0005443 <entry_gsi>
c0005392:	66 90                	xchg   %ax,%ax
c0005394:	68 8c 00 00 00       	push   $0x8c
c0005399:	e9 a5 00 00 00       	jmp    c0005443 <entry_gsi>
c000539e:	66 90                	xchg   %ax,%ax
c00053a0:	68 8d 00 00 00       	push   $0x8d
c00053a5:	e9 99 00 00 00       	jmp    c0005443 <entry_gsi>
c00053aa:	66 90                	xchg   %ax,%ax
c00053ac:	68 8e 00 00 00       	push   $0x8e
c00053b1:	e9 8d 00 00 00       	jmp    c0005443 <entry_gsi>
c00053b6:	66 90                	xchg   %ax,%ax
c00053b8:	68 8f 00 00 00       	push   $0x8f
c00053bd:	e9 81 00 00 00       	jmp    c0005443 <entry_gsi>
c00053c2:	66 90                	xchg   %ax,%ax
c00053c4:	68 90 00 00 00       	push   $0x90
c00053c9:	eb 78                	jmp    c0005443 <entry_gsi>
c00053cb:	90                   	nop
c00053cc:	68 91 00 00 00       	push   $0x91
c00053d1:	eb 70                	jmp    c0005443 <entry_gsi>
c00053d3:	90                   	nop
c00053d4:	68 92 00 00 00       	push   $0x92
c00053d9:	eb 68                	jmp    c0005443 <entry_gsi>
c00053db:	90                   	nop
c00053dc:	68 93 00 00 00       	push   $0x93
c00053e1:	eb 60                	jmp    c0005443 <entry_gsi>
c00053e3:	90                   	nop
c00053e4:	68 94 00 00 00       	push   $0x94
c00053e9:	eb 58                	jmp    c0005443 <entry_gsi>
c00053eb:	90                   	nop
c00053ec:	68 95 00 00 00       	push   $0x95
c00053f1:	eb 50                	jmp    c0005443 <entry_gsi>
c00053f3:	90                   	nop
c00053f4:	68 96 00 00 00       	push   $0x96
c00053f9:	eb 48                	jmp    c0005443 <entry_gsi>
c00053fb:	90                   	nop
c00053fc:	68 97 00 00 00       	push   $0x97
c0005401:	eb 40                	jmp    c0005443 <entry_gsi>
c0005403:	90                   	nop
c0005404:	68 98 00 00 00       	push   $0x98
c0005409:	eb 38                	jmp    c0005443 <entry_gsi>
c000540b:	90                   	nop
c000540c:	68 99 00 00 00       	push   $0x99
c0005411:	eb 30                	jmp    c0005443 <entry_gsi>
c0005413:	90                   	nop
c0005414:	68 9a 00 00 00       	push   $0x9a
c0005419:	eb 28                	jmp    c0005443 <entry_gsi>
c000541b:	90                   	nop
c000541c:	68 9b 00 00 00       	push   $0x9b
c0005421:	eb 20                	jmp    c0005443 <entry_gsi>
c0005423:	90                   	nop
c0005424:	68 9c 00 00 00       	push   $0x9c
c0005429:	eb 18                	jmp    c0005443 <entry_gsi>
c000542b:	90                   	nop
c000542c:	68 9d 00 00 00       	push   $0x9d
c0005431:	eb 10                	jmp    c0005443 <entry_gsi>
c0005433:	90                   	nop
c0005434:	68 9e 00 00 00       	push   $0x9e
c0005439:	eb 08                	jmp    c0005443 <entry_gsi>
c000543b:	90                   	nop
c000543c:	68 9f 00 00 00       	push   $0x9f
c0005441:	eb 00                	jmp    c0005443 <entry_gsi>

c0005443 <entry_gsi>:

entry_gsi:              push    $0
c0005443:	6a 00                	push   $0x0
                        SAVE_STATE
c0005445:	1e                   	push   %ds
c0005446:	06                   	push   %es
c0005447:	0f a0                	push   %fs
c0005449:	0f a8                	push   %gs
c000544b:	60                   	pusha  
c000544c:	89 e3                	mov    %esp,%ebx
c000544e:	81 fc 00 d0 ff cf    	cmp    $0xcfffd000,%esp
c0005454:	73 0f                	jae    c0005465 <entry_gsi+0x22>
c0005456:	fc                   	cld    
c0005457:	bc 00 e0 ff cf       	mov    $0xcfffe000,%esp
c000545c:	b8 23 00 00 00       	mov    $0x23,%eax
c0005461:	8e d8                	mov    %eax,%ds
c0005463:	8e c0                	mov    %eax,%es
                        mov     OFS_VEC (%REG(bx)), %ARG_1
c0005465:	8b 43 34             	mov    0x34(%ebx),%eax
                        call    gsi_vector
c0005468:	e8 29 05 00 00       	call   c0005996 <gsi_vector>
                        jmp     ret_from_interrupt
c000546d:	e9 d5 00 00 00       	jmp    c0005547 <ret_from_interrupt>
c0005472:	66 90                	xchg   %ax,%ax
.rept                   NUM_LVT
INTRGATE                0
                        push    $VEC
                        jmp     entry_lvt
.set                    VEC, VEC + 1
.endr
c0005474:	68 a0 00 00 00       	push   $0xa0
c0005479:	eb 28                	jmp    c00054a3 <entry_lvt>
c000547b:	90                   	nop
c000547c:	68 a1 00 00 00       	push   $0xa1
c0005481:	eb 20                	jmp    c00054a3 <entry_lvt>
c0005483:	90                   	nop
c0005484:	68 a2 00 00 00       	push   $0xa2
c0005489:	eb 18                	jmp    c00054a3 <entry_lvt>
c000548b:	90                   	nop
c000548c:	68 a3 00 00 00       	push   $0xa3
c0005491:	eb 10                	jmp    c00054a3 <entry_lvt>
c0005493:	90                   	nop
c0005494:	68 a4 00 00 00       	push   $0xa4
c0005499:	eb 08                	jmp    c00054a3 <entry_lvt>
c000549b:	90                   	nop
c000549c:	68 a5 00 00 00       	push   $0xa5
c00054a1:	eb 00                	jmp    c00054a3 <entry_lvt>

c00054a3 <entry_lvt>:

entry_lvt:              push    $0
c00054a3:	6a 00                	push   $0x0
                        SAVE_STATE
c00054a5:	1e                   	push   %ds
c00054a6:	06                   	push   %es
c00054a7:	0f a0                	push   %fs
c00054a9:	0f a8                	push   %gs
c00054ab:	60                   	pusha  
c00054ac:	89 e3                	mov    %esp,%ebx
c00054ae:	81 fc 00 d0 ff cf    	cmp    $0xcfffd000,%esp
c00054b4:	73 0f                	jae    c00054c5 <entry_lvt+0x22>
c00054b6:	fc                   	cld    
c00054b7:	bc 00 e0 ff cf       	mov    $0xcfffe000,%esp
c00054bc:	b8 23 00 00 00       	mov    $0x23,%eax
c00054c1:	8e d8                	mov    %eax,%ds
c00054c3:	8e c0                	mov    %eax,%es
                        mov     OFS_VEC (%REG(bx)), %ARG_1
c00054c5:	8b 43 34             	mov    0x34(%ebx),%eax
                        call    lvt_vector
c00054c8:	e8 7b 0a 00 00       	call   c0005f48 <lvt_vector>
                        jmp     ret_from_interrupt
c00054cd:	eb 78                	jmp    c0005547 <ret_from_interrupt>
c00054cf:	90                   	nop
.rept                   NUM_MSI
INTRGATE                0
                        push    $VEC
                        jmp     entry_msi
.set                    VEC, VEC + 1
.endr
c00054d0:	68 a6 00 00 00       	push   $0xa6
c00054d5:	eb 00                	jmp    c00054d7 <entry_msi>

c00054d7 <entry_msi>:

entry_msi:              push    $0
c00054d7:	6a 00                	push   $0x0
                        SAVE_STATE
c00054d9:	1e                   	push   %ds
c00054da:	06                   	push   %es
c00054db:	0f a0                	push   %fs
c00054dd:	0f a8                	push   %gs
c00054df:	60                   	pusha  
c00054e0:	89 e3                	mov    %esp,%ebx
c00054e2:	81 fc 00 d0 ff cf    	cmp    $0xcfffd000,%esp
c00054e8:	73 0f                	jae    c00054f9 <entry_msi+0x22>
c00054ea:	fc                   	cld    
c00054eb:	bc 00 e0 ff cf       	mov    $0xcfffe000,%esp
c00054f0:	b8 23 00 00 00       	mov    $0x23,%eax
c00054f5:	8e d8                	mov    %eax,%ds
c00054f7:	8e c0                	mov    %eax,%es
                        mov     OFS_VEC (%REG(bx)), %ARG_1
c00054f9:	8b 43 34             	mov    0x34(%ebx),%eax
                        call    msi_vector
c00054fc:	e8 59 d3 ff ff       	call   c000285a <msi_vector>
                        jmp     ret_from_interrupt
c0005501:	eb 44                	jmp    c0005547 <ret_from_interrupt>
c0005503:	90                   	nop
.rept                   NUM_IPI
INTRGATE                0
                        push    $VEC
                        jmp     entry_ipi
.set                    VEC, VEC + 1
.endr
c0005504:	68 a7 00 00 00       	push   $0xa7
c0005509:	eb 10                	jmp    c000551b <entry_ipi>
c000550b:	90                   	nop
c000550c:	68 a8 00 00 00       	push   $0xa8
c0005511:	eb 08                	jmp    c000551b <entry_ipi>
c0005513:	90                   	nop
c0005514:	68 a9 00 00 00       	push   $0xa9
c0005519:	eb 00                	jmp    c000551b <entry_ipi>

c000551b <entry_ipi>:

entry_ipi:              push    $0
c000551b:	6a 00                	push   $0x0
                        SAVE_STATE
c000551d:	1e                   	push   %ds
c000551e:	06                   	push   %es
c000551f:	0f a0                	push   %fs
c0005521:	0f a8                	push   %gs
c0005523:	60                   	pusha  
c0005524:	89 e3                	mov    %esp,%ebx
c0005526:	81 fc 00 d0 ff cf    	cmp    $0xcfffd000,%esp
c000552c:	73 0f                	jae    c000553d <entry_ipi+0x22>
c000552e:	fc                   	cld    
c000552f:	bc 00 e0 ff cf       	mov    $0xcfffe000,%esp
c0005534:	b8 23 00 00 00       	mov    $0x23,%eax
c0005539:	8e d8                	mov    %eax,%ds
c000553b:	8e c0                	mov    %eax,%es
                        mov     OFS_VEC (%REG(bx)), %ARG_1
c000553d:	8b 43 34             	mov    0x34(%ebx),%eax
                        call    ipi_vector
c0005540:	e8 95 0a 00 00       	call   c0005fda <ipi_vector>
                        jmp     ret_from_interrupt
c0005545:	eb 00                	jmp    c0005547 <ret_from_interrupt>

c0005547 <ret_from_interrupt>:

/*
 * Interrupt Return
 */
ret_from_interrupt:     testb   $3, OFS_CS (%REG(bx))
c0005547:	f6 43 3c 03          	testb  $0x3,0x3c(%ebx)
                        jnz     ret_user_iret
c000554b:	0f 85 dd aa ff ff    	jne    c000002e <ret_user_iret>
                        call    chk_kern_preempt
c0005551:	e8 0e ab ff ff       	call   c0000064 <chk_kern_preempt>
                        LOAD_GPR
c0005556:	61                   	popa   
                        add     $(6 * SIZE), %REG(sp)
c0005557:	83 c4 18             	add    $0x18,%esp
                        RET_USER_EXC
c000555a:	cf                   	iret   

c000555b <entry_sysenter_db>:

#ifdef __i386__
entry_sysenter_db:      mov     12(%esp), %esp
c000555b:	8b 64 24 0c          	mov    0xc(%esp),%esp
                   lock orl     $HZD_STEP, (%esp)
c000555f:	f0 81 0c 24 00 00 00 	lock orl $0x40000000,(%esp)
c0005566:	40 
                        orl     $0x100, -12(%esp)
c0005567:	81 4c 24 f4 00 01 00 	orl    $0x100,-0xc(%esp)
c000556e:	00 
                        jmp     1f
c000556f:	eb 04                	jmp    c0005575 <entry_sysenter+0x1>
c0005571:	8d 76 00             	lea    0x0(%esi),%esi

c0005574 <entry_sysenter>:
/*
 * System-Call Entry
 */
.align                  4, 0x90
.globl                  entry_sysenter
entry_sysenter:         LOAD_KSP
c0005574:	5c                   	pop    %esp
c0005575:	fc                   	cld    
                        lea     -11*SIZE(%REG(sp)), %REG(sp)
c0005576:	8d 64 24 d4          	lea    -0x2c(%esp),%esp
                        SAVE_GPR
c000557a:	60                   	pusha  
                        mov     $(CPU_LOCAL_STCK + PAGE_SIZE), %REG(sp)
c000557b:	bc 00 e0 ff cf       	mov    $0xcfffe000,%esp
                        and     $0xf, %ARG_1
c0005580:	83 e0 0f             	and    $0xf,%eax
                        jmp     *syscall(,%ARG_1,SIZE)
c0005583:	ff 24 85 00 9e 01 c0 	jmp    *-0x3ffe6200(,%eax,4)
c000558a:	66 90                	xchg   %ax,%ax

c000558c <entry_vmx>:
/*
 * VMX Entry
 */
.align                  4, 0x90
.globl                  entry_vmx
entry_vmx:              SAVE_GPR
c000558c:	60                   	pusha  
                        mov     %cr2, %REG(ax)
c000558d:	0f 20 d0             	mov    %cr2,%eax
                        mov     %REG(ax), OFS_CR2 (%REG(sp))
c0005590:	89 44 24 0c          	mov    %eax,0xc(%esp)
                        mov     $(CPU_LOCAL_STCK + PAGE_SIZE), %REG(sp)
c0005594:	bc 00 e0 ff cf       	mov    $0xcfffe000,%esp
                        jmp     vmx_handler
c0005599:	e9 18 f9 ff ff       	jmp    c0004eb6 <vmx_handler>

c000559e <_GLOBAL__sub_I.00102__ZN3Fpu5cacheE>:
 */

#include "fpu.hpp"

INIT_PRIORITY (PRIO_SLAB)
Slab_cache Fpu::cache (sizeof (Fpu), 16);
c000559e:	b9 10 00 00 00       	mov    $0x10,%ecx
c00055a3:	ba 00 02 00 00       	mov    $0x200,%edx
c00055a8:	b8 84 a4 01 c0       	mov    $0xc001a484,%eax
c00055ad:	e9 54 ac 00 00       	jmp    c0010206 <_ZN10Slab_cacheC1Emj>

c00055b2 <_ZN3Gdt5buildEv>:
    gdt[SEL_USER_CODE   >> 3].set32 (CODE_XRA, PAGES, s, l, 3, 0, ~0ul);
    gdt[SEL_USER_DATA   >> 3].set32 (DATA_RWA, PAGES, s, l, 3, 0, ~0ul);
    gdt[SEL_USER_CODE_L >> 3].set32 (CODE_XRA, PAGES, s, l, 3, 0, ~0ul);

#ifdef __i386__
    gdt[SEL_TSS_RUN >> 3].set32 (SYS_TSS, BYTES, BIT_16, false, 0, reinterpret_cast<mword>(&Tss::run), SPC_LOCAL_IOP_E - reinterpret_cast<mword>(&Tss::run));
c00055b2:	b8 c0 fa ff cf       	mov    $0xcffffac0,%eax
c00055b7:	ba 00 20 00 d0       	mov    $0xd0002000,%edx
c00055bc:	29 c2                	sub    %eax,%edx
        uint32 val[2];

        ALWAYS_INLINE
        inline void set32 (Type type, Granularity gran, Size size, bool l, unsigned dpl, mword base, mword limit)
        {
            val[0] = static_cast<uint32>(base << 16 | (limit & 0xffff));
c00055be:	89 c1                	mov    %eax,%ecx
#include "tss.hpp"

ALIGNED(8) Gdt Gdt::gdt[SEL_MAX >> 3];

void Gdt::build()
{
c00055c0:	53                   	push   %ebx
c00055c1:	0f b7 da             	movzwl %dx,%ebx
c00055c4:	c1 e1 10             	shl    $0x10,%ecx
            val[1] = static_cast<uint32>((base & 0xff000000) | gran | size | (limit & 0xf0000) | l << 21 | 1u << 15 | dpl << 13 | type | (base >> 16 & 0xff));
c00055c7:	81 e2 00 00 0f 00    	and    $0xf0000,%edx
        uint32 val[2];

        ALWAYS_INLINE
        inline void set32 (Type type, Granularity gran, Size size, bool l, unsigned dpl, mword base, mword limit)
        {
            val[0] = static_cast<uint32>(base << 16 | (limit & 0xffff));
c00055cd:	09 d9                	or     %ebx,%ecx
c00055cf:	89 0d b0 f7 ff cf    	mov    %ecx,0xcffff7b0
            val[1] = static_cast<uint32>((base & 0xff000000) | gran | size | (limit & 0xf0000) | l << 21 | 1u << 15 | dpl << 13 | type | (base >> 16 & 0xff));
c00055d5:	89 c1                	mov    %eax,%ecx
c00055d7:	81 e1 00 00 00 ff    	and    $0xff000000,%ecx
c00055dd:	80 cd 89             	or     $0x89,%ch
c00055e0:	c1 e8 10             	shr    $0x10,%eax
c00055e3:	09 ca                	or     %ecx,%edx
c00055e5:	0f b6 c0             	movzbl %al,%eax
c00055e8:	09 d0                	or     %edx,%eax
c00055ea:	a3 b4 f7 ff cf       	mov    %eax,0xcffff7b4
    gdt[SEL_USER_DATA   >> 3].set32 (DATA_RWA, PAGES, s, l, 3, 0, ~0ul);
    gdt[SEL_USER_CODE_L >> 3].set32 (CODE_XRA, PAGES, s, l, 3, 0, ~0ul);

#ifdef __i386__
    gdt[SEL_TSS_RUN >> 3].set32 (SYS_TSS, BYTES, BIT_16, false, 0, reinterpret_cast<mword>(&Tss::run), SPC_LOCAL_IOP_E - reinterpret_cast<mword>(&Tss::run));
    gdt[SEL_TSS_DBF >> 3].set32 (SYS_TSS, BYTES, BIT_16, false, 0, reinterpret_cast<mword>(&Tss::dbf), sizeof (Tss) - 1);
c00055ef:	b8 58 fa ff cf       	mov    $0xcffffa58,%eax
        uint32 val[2];

        ALWAYS_INLINE
        inline void set32 (Type type, Granularity gran, Size size, bool l, unsigned dpl, mword base, mword limit)
        {
            val[0] = static_cast<uint32>(base << 16 | (limit & 0xffff));
c00055f4:	89 c2                	mov    %eax,%edx
c00055f6:	c1 e2 10             	shl    $0x10,%edx
c00055f9:	83 ca 67             	or     $0x67,%edx
c00055fc:	89 15 c0 f7 ff cf    	mov    %edx,0xcffff7c0
            val[1] = static_cast<uint32>((base & 0xff000000) | gran | size | (limit & 0xf0000) | l << 21 | 1u << 15 | dpl << 13 | type | (base >> 16 & 0xff));
c0005602:	89 c2                	mov    %eax,%edx
c0005604:	81 e2 00 00 00 ff    	and    $0xff000000,%edx
c000560a:	c1 e8 10             	shr    $0x10,%eax
c000560d:	80 ce 89             	or     $0x89,%dh
c0005610:	0f b6 c0             	movzbl %al,%eax
c0005613:	09 d0                	or     %edx,%eax
        uint32 val[2];

        ALWAYS_INLINE
        inline void set32 (Type type, Granularity gran, Size size, bool l, unsigned dpl, mword base, mword limit)
        {
            val[0] = static_cast<uint32>(base << 16 | (limit & 0xffff));
c0005615:	c7 05 88 f7 ff cf ff 	movl   $0xffff,0xcffff788
c000561c:	ff 00 00 
            val[1] = static_cast<uint32>((base & 0xff000000) | gran | size | (limit & 0xf0000) | l << 21 | 1u << 15 | dpl << 13 | type | (base >> 16 & 0xff));
c000561f:	c7 05 8c f7 ff cf 00 	movl   $0xcf9b00,0xcffff78c
c0005626:	9b cf 00 
        uint32 val[2];

        ALWAYS_INLINE
        inline void set32 (Type type, Granularity gran, Size size, bool l, unsigned dpl, mword base, mword limit)
        {
            val[0] = static_cast<uint32>(base << 16 | (limit & 0xffff));
c0005629:	c7 05 90 f7 ff cf ff 	movl   $0xffff,0xcffff790
c0005630:	ff 00 00 
            val[1] = static_cast<uint32>((base & 0xff000000) | gran | size | (limit & 0xf0000) | l << 21 | 1u << 15 | dpl << 13 | type | (base >> 16 & 0xff));
c0005633:	c7 05 94 f7 ff cf 00 	movl   $0xcf9300,0xcffff794
c000563a:	93 cf 00 
        uint32 val[2];

        ALWAYS_INLINE
        inline void set32 (Type type, Granularity gran, Size size, bool l, unsigned dpl, mword base, mword limit)
        {
            val[0] = static_cast<uint32>(base << 16 | (limit & 0xffff));
c000563d:	c7 05 98 f7 ff cf ff 	movl   $0xffff,0xcffff798
c0005644:	ff 00 00 
            val[1] = static_cast<uint32>((base & 0xff000000) | gran | size | (limit & 0xf0000) | l << 21 | 1u << 15 | dpl << 13 | type | (base >> 16 & 0xff));
c0005647:	c7 05 9c f7 ff cf 00 	movl   $0xcffb00,0xcffff79c
c000564e:	fb cf 00 
        uint32 val[2];

        ALWAYS_INLINE
        inline void set32 (Type type, Granularity gran, Size size, bool l, unsigned dpl, mword base, mword limit)
        {
            val[0] = static_cast<uint32>(base << 16 | (limit & 0xffff));
c0005651:	c7 05 a0 f7 ff cf ff 	movl   $0xffff,0xcffff7a0
c0005658:	ff 00 00 
            val[1] = static_cast<uint32>((base & 0xff000000) | gran | size | (limit & 0xf0000) | l << 21 | 1u << 15 | dpl << 13 | type | (base >> 16 & 0xff));
c000565b:	c7 05 a4 f7 ff cf 00 	movl   $0xcff300,0xcffff7a4
c0005662:	f3 cf 00 
        uint32 val[2];

        ALWAYS_INLINE
        inline void set32 (Type type, Granularity gran, Size size, bool l, unsigned dpl, mword base, mword limit)
        {
            val[0] = static_cast<uint32>(base << 16 | (limit & 0xffff));
c0005665:	c7 05 a8 f7 ff cf ff 	movl   $0xffff,0xcffff7a8
c000566c:	ff 00 00 
            val[1] = static_cast<uint32>((base & 0xff000000) | gran | size | (limit & 0xf0000) | l << 21 | 1u << 15 | dpl << 13 | type | (base >> 16 & 0xff));
c000566f:	c7 05 ac f7 ff cf 00 	movl   $0xcffb00,0xcffff7ac
c0005676:	fb cf 00 
c0005679:	a3 c4 f7 ff cf       	mov    %eax,0xcffff7c4
#else
    gdt[SEL_TSS_RUN >> 3].set64 (SYS_TSS, BYTES, BIT_16, false, 0, reinterpret_cast<mword>(&Tss::run), SPC_LOCAL_IOP_E - reinterpret_cast<mword>(&Tss::run));
    gdt[SEL_TSS_DBF >> 3].set64 (SYS_TSS, BYTES, BIT_16, false, 0, reinterpret_cast<mword>(&Tss::dbf), sizeof (Tss) - 1);
#endif
}
c000567e:	5b                   	pop    %ebx
c000567f:	c3                   	ret    

c0005680 <_ZN3Gsi3setEjjj>:

uint64 Gsi::set (unsigned gsi, unsigned cpu, unsigned rid)
{
c0005680:	55                   	push   %ebp
c0005681:	89 e5                	mov    %esp,%ebp
c0005683:	57                   	push   %edi
c0005684:	56                   	push   %esi
c0005685:	89 c6                	mov    %eax,%esi
    uint32 msi_addr = 0, msi_data = 0, aid = Cpu::apic_id[cpu];

    Ioapic *ioapic = gsi_table[gsi].ioapic;
c0005687:	6b c6 0c             	imul   $0xc,%esi,%eax
        }
    }
}

uint64 Gsi::set (unsigned gsi, unsigned cpu, unsigned rid)
{
c000568a:	53                   	push   %ebx
c000568b:	83 ec 10             	sub    $0x10,%esp
    uint32 msi_addr = 0, msi_data = 0, aid = Cpu::apic_id[cpu];
c000568e:	0f b6 92 c0 a3 01 c0 	movzbl -0x3ffe5c40(%edx),%edx

    Ioapic *ioapic = gsi_table[gsi].ioapic;
c0005695:	05 e0 a4 01 c0       	add    $0xc001a4e0,%eax
c000569a:	8b 1d a8 9f 01 c0    	mov    0xc0019fa8,%ebx
c00056a0:	8b 78 04             	mov    0x4(%eax),%edi
    }
}

uint64 Gsi::set (unsigned gsi, unsigned cpu, unsigned rid)
{
    uint32 msi_addr = 0, msi_data = 0, aid = Cpu::apic_id[cpu];
c00056a3:	88 55 f3             	mov    %dl,-0xd(%ebp)

    Ioapic *ioapic = gsi_table[gsi].ioapic;

    if (ioapic) {
c00056a6:	85 ff                	test   %edi,%edi
c00056a8:	0f 84 27 01 00 00    	je     c00057d5 <_ZN3Gsi3setEjjj+0x155>
        ioapic->set_cpu (gsi, Dmar::ire() ? 0 : aid);
c00056ae:	81 e3 00 00 00 02    	and    $0x2000000,%ebx
c00056b4:	b8 00 00 00 00       	mov    $0x0,%eax
c00056b9:	0f 45 d0             	cmovne %eax,%edx

        ALWAYS_INLINE
        inline void set_cpu (unsigned gsi, unsigned cpu)
        {
            unsigned pin = gsi - gsi_base;
            write (Register (IOAPIC_IRT + 2 * pin + 1), cpu << 24 | gsi << 17 | 1ul << 16);
c00056bc:	89 f0                	mov    %esi,%eax
c00056be:	c1 e0 11             	shl    $0x11,%eax
c00056c1:	0d 00 00 01 00       	or     $0x10000,%eax
c00056c6:	c1 e2 18             	shl    $0x18,%edx
c00056c9:	09 d0                	or     %edx,%eax
c00056cb:	89 45 e8             	mov    %eax,-0x18(%ebp)
c00056ce:	89 f0                	mov    %esi,%eax
c00056d0:	2b 47 08             	sub    0x8(%edi),%eax
c00056d3:	8d 5c 00 11          	lea    0x11(%eax,%eax,1),%ebx
        }

        ALWAYS_INLINE
        inline void write (Register reg, uint32 val)
        {
            Lock_guard <Spinlock> guard (lock);
c00056d7:	8d 47 12             	lea    0x12(%edi),%eax
c00056da:	89 45 ec             	mov    %eax,-0x14(%ebp)

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c00056dd:	9c                   	pushf  
c00056de:	58                   	pop    %eax
            return flags & 0x200;
c00056df:	c1 e8 09             	shr    $0x9,%eax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c00056e2:	24 01                	and    $0x1,%al
c00056e4:	88 45 e4             	mov    %al,-0x1c(%ebp)
c00056e7:	74 27                	je     c0005710 <_ZN3Gsi3setEjjj+0x90>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c00056e9:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c00056f0:	75 16                	jne    c0005708 <_ZN3Gsi3setEjjj+0x88>
c00056f2:	68 a0 70 01 c0       	push   $0xc00170a0
c00056f7:	68 b7 00 00 00       	push   $0xb7
c00056fc:	68 12 61 01 c0       	push   $0xc0016112
c0005701:	68 83 61 01 c0       	push   $0xc0016183
c0005706:	eb 44                	jmp    c000574c <_ZN3Gsi3setEjjj+0xcc>

            asm volatile ("cli" : : : "memory");
c0005708:	fa                   	cli    
            preemption = false;
c0005709:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c0005710:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005713:	e8 14 b4 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
        };

        ALWAYS_INLINE
        inline void index (Register reg)
        {
            *reinterpret_cast<uint8 volatile *>(reg_base + IOAPIC_IDX) = reg;
c0005718:	8b 47 04             	mov    0x4(%edi),%eax
        ALWAYS_INLINE
        inline void write (Register reg, uint32 val)
        {
            Lock_guard <Spinlock> guard (lock);
            index (reg);
            *reinterpret_cast<uint32 volatile *>(reg_base + IOAPIC_WND) = val;
c000571b:	8b 4d e8             	mov    -0x18(%ebp),%ecx
        };

        ALWAYS_INLINE
        inline void index (Register reg)
        {
            *reinterpret_cast<uint8 volatile *>(reg_base + IOAPIC_IDX) = reg;
c000571e:	88 18                	mov    %bl,(%eax)
        ALWAYS_INLINE
        inline void write (Register reg, uint32 val)
        {
            Lock_guard <Spinlock> guard (lock);
            index (reg);
            *reinterpret_cast<uint32 volatile *>(reg_base + IOAPIC_WND) = val;
c0005720:	8b 47 04             	mov    0x4(%edi),%eax
c0005723:	89 48 10             	mov    %ecx,0x10(%eax)
c0005726:	fe 47 12             	incb   0x12(%edi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c0005729:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
c000572d:	74 2f                	je     c000575e <_ZN3Gsi3setEjjj+0xde>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000572f:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0005736:	74 1e                	je     c0005756 <_ZN3Gsi3setEjjj+0xd6>
c0005738:	68 60 70 01 c0       	push   $0xc0017060
c000573d:	68 c0 00 00 00       	push   $0xc0
c0005742:	68 12 61 01 c0       	push   $0xc0016112
c0005747:	68 82 61 01 c0       	push   $0xc0016182
c000574c:	68 69 60 01 c0       	push   $0xc0016069
c0005751:	e8 f0 c1 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

            preemption = true;
c0005756:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000575d:	fb                   	sti    
        ioapic->set_irt (gsi, gsi_table[gsi].irt);
c000575e:	6b c6 0c             	imul   $0xc,%esi,%eax
c0005761:	0f b7 90 e8 a4 01 c0 	movzwl -0x3ffe5b18(%eax),%edx
c0005768:	89 f0                	mov    %esi,%eax
c000576a:	2b 47 08             	sub    0x8(%edi),%eax

        ALWAYS_INLINE
        inline void set_irt (unsigned gsi, unsigned val)
        {
            unsigned pin = gsi - gsi_base;
            write (Register (IOAPIC_IRT + 2 * pin), val);
c000576d:	8d 4c 00 10          	lea    0x10(%eax,%eax,1),%ecx

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c0005771:	9c                   	pushf  
c0005772:	5b                   	pop    %ebx
            return flags & 0x200;
c0005773:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c0005776:	80 e3 01             	and    $0x1,%bl
c0005779:	74 15                	je     c0005790 <_ZN3Gsi3setEjjj+0x110>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c000577b:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0005782:	0f 84 6a ff ff ff    	je     c00056f2 <_ZN3Gsi3setEjjj+0x72>

            asm volatile ("cli" : : : "memory");
c0005788:	fa                   	cli    
            preemption = false;
c0005789:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c0005790:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005793:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
c0005796:	89 55 e8             	mov    %edx,-0x18(%ebp)
c0005799:	e8 8e b3 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
        };

        ALWAYS_INLINE
        inline void index (Register reg)
        {
            *reinterpret_cast<uint8 volatile *>(reg_base + IOAPIC_IDX) = reg;
c000579e:	8b 47 04             	mov    0x4(%edi),%eax
c00057a1:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
        ALWAYS_INLINE
        inline void write (Register reg, uint32 val)
        {
            Lock_guard <Spinlock> guard (lock);
            index (reg);
            *reinterpret_cast<uint32 volatile *>(reg_base + IOAPIC_WND) = val;
c00057a4:	8b 55 e8             	mov    -0x18(%ebp),%edx
        };

        ALWAYS_INLINE
        inline void index (Register reg)
        {
            *reinterpret_cast<uint8 volatile *>(reg_base + IOAPIC_IDX) = reg;
c00057a7:	88 08                	mov    %cl,(%eax)
        ALWAYS_INLINE
        inline void write (Register reg, uint32 val)
        {
            Lock_guard <Spinlock> guard (lock);
            index (reg);
            *reinterpret_cast<uint32 volatile *>(reg_base + IOAPIC_WND) = val;
c00057a9:	8b 47 04             	mov    0x4(%edi),%eax
c00057ac:	89 50 10             	mov    %edx,0x10(%eax)
c00057af:	fe 47 12             	incb   0x12(%edi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c00057b2:	84 db                	test   %bl,%bl
c00057b4:	74 15                	je     c00057cb <_ZN3Gsi3setEjjj+0x14b>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c00057b6:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c00057bd:	0f 85 75 ff ff ff    	jne    c0005738 <_ZN3Gsi3setEjjj+0xb8>

            preemption = true;
c00057c3:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c00057ca:	fb                   	sti    
        rid = ioapic->get_rid();
c00057cb:	0f b7 4f 10          	movzwl 0x10(%edi),%ecx
    }
}

uint64 Gsi::set (unsigned gsi, unsigned cpu, unsigned rid)
{
    uint32 msi_addr = 0, msi_data = 0, aid = Cpu::apic_id[cpu];
c00057cf:	31 c0                	xor    %eax,%eax
c00057d1:	31 d2                	xor    %edx,%edx
c00057d3:	eb 1e                	jmp    c00057f3 <_ZN3Gsi3setEjjj+0x173>
    if (ioapic) {
        ioapic->set_cpu (gsi, Dmar::ire() ? 0 : aid);
        ioapic->set_irt (gsi, gsi_table[gsi].irt);
        rid = ioapic->get_rid();
    } else {
        msi_addr = 0xfee00000 | (Dmar::ire() ? 3U << 3 : aid << 12);
c00057d5:	81 e3 00 00 00 02    	and    $0x2000000,%ebx
c00057db:	75 0f                	jne    c00057ec <_ZN3Gsi3setEjjj+0x16c>
c00057dd:	c1 e2 0c             	shl    $0xc,%edx
        msi_data = Dmar::ire() ? gsi : gsi_table[gsi].vec;
c00057e0:	0f b6 40 08          	movzbl 0x8(%eax),%eax
    if (ioapic) {
        ioapic->set_cpu (gsi, Dmar::ire() ? 0 : aid);
        ioapic->set_irt (gsi, gsi_table[gsi].irt);
        rid = ioapic->get_rid();
    } else {
        msi_addr = 0xfee00000 | (Dmar::ire() ? 3U << 3 : aid << 12);
c00057e4:	81 ca 00 00 e0 fe    	or     $0xfee00000,%edx
c00057ea:	eb 07                	jmp    c00057f3 <_ZN3Gsi3setEjjj+0x173>
        msi_data = Dmar::ire() ? gsi : gsi_table[gsi].vec;
c00057ec:	89 f0                	mov    %esi,%eax
    if (ioapic) {
        ioapic->set_cpu (gsi, Dmar::ire() ? 0 : aid);
        ioapic->set_irt (gsi, gsi_table[gsi].irt);
        rid = ioapic->get_rid();
    } else {
        msi_addr = 0xfee00000 | (Dmar::ire() ? 3U << 3 : aid << 12);
c00057ee:	ba 18 00 e0 fe       	mov    $0xfee00018,%edx
        msi_data = Dmar::ire() ? gsi : gsi_table[gsi].vec;
    }

    Dmar::set_irt (gsi, rid, aid, VEC_GSI + gsi, gsi_table[gsi].trg);
c00057f3:	6b de 0c             	imul   $0xc,%esi,%ebx
        }

        ALWAYS_INLINE
        static inline void set_irt (unsigned i, unsigned rid, unsigned cpu, unsigned vec, unsigned trg)
        {
            irt[i].set (1ULL << 18 | rid, static_cast<uint64>(cpu) << 40 | vec << 16 | trg << 4 | 1);
c00057f6:	81 c9 00 00 04 00    	or     $0x40000,%ecx
c00057fc:	8d 7e 20             	lea    0x20(%esi),%edi
c00057ff:	c1 e7 10             	shl    $0x10,%edi
c0005802:	c1 e6 04             	shl    $0x4,%esi
c0005805:	8a 9b e9 a4 01 c0    	mov    -0x3ffe5b17(%ebx),%bl
c000580b:	03 35 48 a4 01 c0    	add    0xc001a448,%esi
c0005811:	c0 eb 07             	shr    $0x7,%bl
c0005814:	0f b6 db             	movzbl %bl,%ebx
c0005817:	c1 e3 04             	shl    $0x4,%ebx
c000581a:	83 cb 01             	or     $0x1,%ebx
c000581d:	09 fb                	or     %edi,%ebx
c000581f:	0f b6 7d f3          	movzbl -0xd(%ebp),%edi
c0005823:	89 4e 08             	mov    %ecx,0x8(%esi)
c0005826:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
    private:
        uint64 lo, hi;

    public:
        ALWAYS_INLINE
        inline void set (uint64 h, uint64 l) { hi = h; lo = l; flush (this); }
c000582d:	89 1e                	mov    %ebx,(%esi)
        }

        ALWAYS_INLINE
        static inline void set_irt (unsigned i, unsigned rid, unsigned cpu, unsigned vec, unsigned trg)
        {
            irt[i].set (1ULL << 18 | rid, static_cast<uint64>(cpu) << 40 | vec << 16 | trg << 4 | 1);
c000582f:	c1 e7 08             	shl    $0x8,%edi
    private:
        uint64 lo, hi;

    public:
        ALWAYS_INLINE
        inline void set (uint64 h, uint64 l) { hi = h; lo = l; flush (this); }
c0005832:	89 7e 04             	mov    %edi,0x4(%esi)

template <typename T>
ALWAYS_INLINE
static inline void flush (T t)
{
    asm volatile ("clflush %0" : : "m" (*t) : "memory");
c0005835:	0f ae 3e             	clflush (%esi)

    return static_cast<uint64>(msi_addr) << 32 | msi_data;
}
c0005838:	8d 65 f4             	lea    -0xc(%ebp),%esp
c000583b:	5b                   	pop    %ebx
c000583c:	5e                   	pop    %esi
c000583d:	5f                   	pop    %edi
c000583e:	5d                   	pop    %ebp
c000583f:	c3                   	ret    

c0005840 <_ZN3Gsi4maskEj>:

void Gsi::mask (unsigned gsi)
{
    Ioapic *ioapic = gsi_table[gsi].ioapic;
c0005840:	6b d0 0c             	imul   $0xc,%eax,%edx

    return static_cast<uint64>(msi_addr) << 32 | msi_data;
}

void Gsi::mask (unsigned gsi)
{
c0005843:	55                   	push   %ebp
c0005844:	57                   	push   %edi
c0005845:	56                   	push   %esi
    Ioapic *ioapic = gsi_table[gsi].ioapic;
c0005846:	8b b2 e4 a4 01 c0    	mov    -0x3ffe5b1c(%edx),%esi
c000584c:	81 c2 e0 a4 01 c0    	add    $0xc001a4e0,%edx

    return static_cast<uint64>(msi_addr) << 32 | msi_data;
}

void Gsi::mask (unsigned gsi)
{
c0005852:	53                   	push   %ebx
    Ioapic *ioapic = gsi_table[gsi].ioapic;

    if (ioapic)
c0005853:	85 f6                	test   %esi,%esi
c0005855:	0f 84 8d 00 00 00    	je     c00058e8 <_ZN3Gsi4maskEj+0xa8>
        ioapic->set_irt (gsi, 1U << 16 | gsi_table[gsi].irt);
c000585b:	0f b7 7a 08          	movzwl 0x8(%edx),%edi
c000585f:	2b 46 08             	sub    0x8(%esi),%eax
c0005862:	81 cf 00 00 01 00    	or     $0x10000,%edi

        ALWAYS_INLINE
        inline void set_irt (unsigned gsi, unsigned val)
        {
            unsigned pin = gsi - gsi_base;
            write (Register (IOAPIC_IRT + 2 * pin), val);
c0005868:	8d 6c 00 10          	lea    0x10(%eax,%eax,1),%ebp
        }

        ALWAYS_INLINE
        inline void write (Register reg, uint32 val)
        {
            Lock_guard <Spinlock> guard (lock);
c000586c:	8d 46 12             	lea    0x12(%esi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c000586f:	9c                   	pushf  
c0005870:	5b                   	pop    %ebx
            return flags & 0x200;
c0005871:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c0005874:	80 e3 01             	and    $0x1,%bl
c0005877:	74 27                	je     c00058a0 <_ZN3Gsi4maskEj+0x60>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0005879:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0005880:	75 16                	jne    c0005898 <_ZN3Gsi4maskEj+0x58>
c0005882:	68 a0 70 01 c0       	push   $0xc00170a0
c0005887:	68 b7 00 00 00       	push   $0xb7
c000588c:	68 12 61 01 c0       	push   $0xc0016112
c0005891:	68 83 61 01 c0       	push   $0xc0016183
c0005896:	eb 3e                	jmp    c00058d6 <_ZN3Gsi4maskEj+0x96>

            asm volatile ("cli" : : : "memory");
c0005898:	fa                   	cli    
            preemption = false;
c0005899:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c00058a0:	e8 87 b2 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
        };

        ALWAYS_INLINE
        inline void index (Register reg)
        {
            *reinterpret_cast<uint8 volatile *>(reg_base + IOAPIC_IDX) = reg;
c00058a5:	8b 46 04             	mov    0x4(%esi),%eax
c00058a8:	89 e9                	mov    %ebp,%ecx
c00058aa:	88 08                	mov    %cl,(%eax)
        ALWAYS_INLINE
        inline void write (Register reg, uint32 val)
        {
            Lock_guard <Spinlock> guard (lock);
            index (reg);
            *reinterpret_cast<uint32 volatile *>(reg_base + IOAPIC_WND) = val;
c00058ac:	8b 46 04             	mov    0x4(%esi),%eax
c00058af:	89 78 10             	mov    %edi,0x10(%eax)
c00058b2:	fe 46 12             	incb   0x12(%esi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c00058b5:	84 db                	test   %bl,%bl
c00058b7:	74 2f                	je     c00058e8 <_ZN3Gsi4maskEj+0xa8>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c00058b9:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c00058c0:	74 1e                	je     c00058e0 <_ZN3Gsi4maskEj+0xa0>
c00058c2:	68 60 70 01 c0       	push   $0xc0017060
c00058c7:	68 c0 00 00 00       	push   $0xc0
c00058cc:	68 12 61 01 c0       	push   $0xc0016112
c00058d1:	68 82 61 01 c0       	push   $0xc0016182
c00058d6:	68 69 60 01 c0       	push   $0xc0016069
c00058db:	e8 66 c0 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

            preemption = true;
c00058e0:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c00058e7:	fb                   	sti    
}
c00058e8:	5b                   	pop    %ebx
c00058e9:	5e                   	pop    %esi
c00058ea:	5f                   	pop    %edi
c00058eb:	5d                   	pop    %ebp
c00058ec:	c3                   	ret    
c00058ed:	90                   	nop

c00058ee <_ZN3Gsi6unmaskEj>:

void Gsi::unmask (unsigned gsi)
{
    Ioapic *ioapic = gsi_table[gsi].ioapic;
c00058ee:	6b d0 0c             	imul   $0xc,%eax,%edx
    if (ioapic)
        ioapic->set_irt (gsi, 1U << 16 | gsi_table[gsi].irt);
}

void Gsi::unmask (unsigned gsi)
{
c00058f1:	55                   	push   %ebp
c00058f2:	57                   	push   %edi
c00058f3:	56                   	push   %esi
    Ioapic *ioapic = gsi_table[gsi].ioapic;
c00058f4:	8b b2 e4 a4 01 c0    	mov    -0x3ffe5b1c(%edx),%esi
c00058fa:	81 c2 e0 a4 01 c0    	add    $0xc001a4e0,%edx
    if (ioapic)
        ioapic->set_irt (gsi, 1U << 16 | gsi_table[gsi].irt);
}

void Gsi::unmask (unsigned gsi)
{
c0005900:	53                   	push   %ebx
    Ioapic *ioapic = gsi_table[gsi].ioapic;

    if (ioapic)
c0005901:	85 f6                	test   %esi,%esi
c0005903:	0f 84 87 00 00 00    	je     c0005990 <_ZN3Gsi6unmaskEj+0xa2>
c0005909:	2b 46 08             	sub    0x8(%esi),%eax
        ioapic->set_irt (gsi, 0U << 16 | gsi_table[gsi].irt);
c000590c:	0f b7 7a 08          	movzwl 0x8(%edx),%edi

        ALWAYS_INLINE
        inline void set_irt (unsigned gsi, unsigned val)
        {
            unsigned pin = gsi - gsi_base;
            write (Register (IOAPIC_IRT + 2 * pin), val);
c0005910:	8d 6c 00 10          	lea    0x10(%eax,%eax,1),%ebp
        }

        ALWAYS_INLINE
        inline void write (Register reg, uint32 val)
        {
            Lock_guard <Spinlock> guard (lock);
c0005914:	8d 46 12             	lea    0x12(%esi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c0005917:	9c                   	pushf  
c0005918:	5b                   	pop    %ebx
            return flags & 0x200;
c0005919:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c000591c:	80 e3 01             	and    $0x1,%bl
c000591f:	74 27                	je     c0005948 <_ZN3Gsi6unmaskEj+0x5a>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0005921:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0005928:	75 16                	jne    c0005940 <_ZN3Gsi6unmaskEj+0x52>
c000592a:	68 a0 70 01 c0       	push   $0xc00170a0
c000592f:	68 b7 00 00 00       	push   $0xb7
c0005934:	68 12 61 01 c0       	push   $0xc0016112
c0005939:	68 83 61 01 c0       	push   $0xc0016183
c000593e:	eb 3e                	jmp    c000597e <_ZN3Gsi6unmaskEj+0x90>

            asm volatile ("cli" : : : "memory");
c0005940:	fa                   	cli    
            preemption = false;
c0005941:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c0005948:	e8 df b1 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
        };

        ALWAYS_INLINE
        inline void index (Register reg)
        {
            *reinterpret_cast<uint8 volatile *>(reg_base + IOAPIC_IDX) = reg;
c000594d:	8b 46 04             	mov    0x4(%esi),%eax
c0005950:	89 e9                	mov    %ebp,%ecx
c0005952:	88 08                	mov    %cl,(%eax)
        ALWAYS_INLINE
        inline void write (Register reg, uint32 val)
        {
            Lock_guard <Spinlock> guard (lock);
            index (reg);
            *reinterpret_cast<uint32 volatile *>(reg_base + IOAPIC_WND) = val;
c0005954:	8b 46 04             	mov    0x4(%esi),%eax
c0005957:	89 78 10             	mov    %edi,0x10(%eax)
c000595a:	fe 46 12             	incb   0x12(%esi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c000595d:	84 db                	test   %bl,%bl
c000595f:	74 2f                	je     c0005990 <_ZN3Gsi6unmaskEj+0xa2>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0005961:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0005968:	74 1e                	je     c0005988 <_ZN3Gsi6unmaskEj+0x9a>
c000596a:	68 60 70 01 c0       	push   $0xc0017060
c000596f:	68 c0 00 00 00       	push   $0xc0
c0005974:	68 12 61 01 c0       	push   $0xc0016112
c0005979:	68 82 61 01 c0       	push   $0xc0016182
c000597e:	68 69 60 01 c0       	push   $0xc0016069
c0005983:	e8 be bf ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

            preemption = true;
c0005988:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000598f:	fb                   	sti    
}
c0005990:	5b                   	pop    %ebx
c0005991:	5e                   	pop    %esi
c0005992:	5f                   	pop    %edi
c0005993:	5d                   	pop    %ebp
c0005994:	c3                   	ret    
c0005995:	90                   	nop

c0005996 <gsi_vector>:

void Gsi::vector (unsigned vector)
{
c0005996:	53                   	push   %ebx
    unsigned gsi = vector - VEC_GSI;
c0005997:	8d 58 e0             	lea    -0x20(%eax),%ebx

    if (gsi == Keyb::gsi)
c000599a:	3b 1d 54 a2 01 c0    	cmp    0xc001a254,%ebx
c00059a0:	75 07                	jne    c00059a9 <gsi_vector+0x13>
        Keyb::interrupt();
c00059a2:	e8 17 03 00 00       	call   c0005cbe <_ZN4Keyb9interruptEv>
c00059a7:	eb 22                	jmp    c00059cb <gsi_vector+0x35>

    else if (gsi == Acpi::gsi)
c00059a9:	3b 1d 84 a2 01 c0    	cmp    0xc001a284,%ebx
c00059af:	75 07                	jne    c00059b8 <gsi_vector+0x22>
        Acpi::interrupt();
c00059b1:	e8 38 b1 ff ff       	call   c0000aee <_ZN4Acpi9interruptEv>
c00059b6:	eb 13                	jmp    c00059cb <gsi_vector+0x35>

    else if (gsi_table[gsi].trg)
c00059b8:	6b c3 0c             	imul   $0xc,%ebx,%eax
c00059bb:	80 b8 e9 a4 01 c0 00 	cmpb   $0x0,-0x3ffe5b17(%eax)
c00059c2:	79 07                	jns    c00059cb <gsi_vector+0x35>
        mask (gsi);
c00059c4:	89 d8                	mov    %ebx,%eax
c00059c6:	e8 75 fe ff ff       	call   c0005840 <_ZN3Gsi4maskEj>

    Lapic::eoi();

    gsi_table[gsi].sm->submit();
c00059cb:	6b c3 0c             	imul   $0xc,%ebx,%eax
c00059ce:	c7 05 b0 e0 ff cf 00 	movl   $0x0,0xcfffe0b0
c00059d5:	00 00 00 
c00059d8:	8b 80 e0 a4 01 c0    	mov    -0x3ffe5b20(%eax),%eax
c00059de:	83 c0 54             	add    $0x54,%eax
c00059e1:	e8 50 a2 00 00       	call   c000fc36 <_ZN2Si6submitEv>

    Counter::print<1,16> (++Counter::gsi[gsi], Console_vga::Color (Console_vga::COLOR_LIGHT_YELLOW - gsi / 64), SPN_GSI + gsi % 64);
c00059e6:	8b 04 9d c0 f4 ff cf 	mov    -0x30000b40(,%ebx,4),%eax
        }

        template <unsigned D, unsigned B>
        static void print (mword val, Console_vga::Color c, unsigned col)
        {
            if (EXPECT_FALSE (Cpu::row))
c00059ed:	8b 15 50 f7 ff cf    	mov    0xcffff750,%edx
c00059f3:	40                   	inc    %eax
c00059f4:	85 d2                	test   %edx,%edx
c00059f6:	89 04 9d c0 f4 ff cf 	mov    %eax,-0x30000b40(,%ebx,4)
c00059fd:	74 30                	je     c0005a2f <gsi_vector+0x99>

        ALWAYS_INLINE
        inline void put (unsigned long r, unsigned long c, Color color, int x)
        {
            *reinterpret_cast<unsigned short volatile *>(HV_GLOBAL_FBUF + r * 160 + c * 2) = static_cast<unsigned short>(color << 8 | x);
c00059ff:	6b d2 50             	imul   $0x50,%edx,%edx
c0005a02:	89 d9                	mov    %ebx,%ecx
c0005a04:	83 e1 3f             	and    $0x3f,%ecx
                for (unsigned i = 0; i < D; i++, val /= B)
                    Console_vga::con.put (Cpu::row, col - i, c, !i || val ? (val % B)["0123456789ABCDEF"] : ' ');
c0005a07:	83 e0 0f             	and    $0xf,%eax
c0005a0a:	c1 eb 06             	shr    $0x6,%ebx
c0005a0d:	8d 94 0a 10 f8 df 67 	lea    0x67dff810(%edx,%ecx,1),%edx
c0005a14:	66 0f be 88 14 66 01 	movsbw -0x3ffe99ec(%eax),%cx
c0005a1b:	c0 
c0005a1c:	b8 0e 00 00 00       	mov    $0xe,%eax
c0005a21:	29 d8                	sub    %ebx,%eax
c0005a23:	c1 e0 08             	shl    $0x8,%eax
c0005a26:	09 c8                	or     %ecx,%eax
c0005a28:	0f b7 c0             	movzwl %ax,%eax
c0005a2b:	66 89 04 12          	mov    %ax,(%edx,%edx,1)
}
c0005a2f:	5b                   	pop    %ebx
c0005a30:	c3                   	ret    
c0005a31:	90                   	nop

c0005a32 <_ZN3Hip7add_cpuEv>:
    mem++;
}

void Hip::add_cpu()
{
    Hip_cpu *cpu = hip()->cpu_desc + Cpu::id;
c0005a32:	8b 15 04 f0 ff cf    	mov    0xcffff004,%edx

    cpu->acpi_id = Cpu::acpi_id[Cpu::id];
c0005a38:	8d 42 06             	lea    0x6(%edx),%eax
c0005a3b:	8a 92 00 a4 01 c0    	mov    -0x3ffe5c00(%edx),%dl
    cpu->package = static_cast<uint8>(Cpu::package);
    cpu->core    = static_cast<uint8>(Cpu::core);
    cpu->thread  = static_cast<uint8>(Cpu::thread);
    cpu->flags   = 1;
c0005a41:	c6 04 c5 08 e0 01 c0 	movb   $0x1,-0x3ffe1ff8(,%eax,8)
c0005a48:	01 

void Hip::add_cpu()
{
    Hip_cpu *cpu = hip()->cpu_desc + Cpu::id;

    cpu->acpi_id = Cpu::acpi_id[Cpu::id];
c0005a49:	88 14 c5 0c e0 01 c0 	mov    %dl,-0x3ffe1ff4(,%eax,8)
    cpu->package = static_cast<uint8>(Cpu::package);
c0005a50:	8b 15 78 f7 ff cf    	mov    0xcffff778,%edx
c0005a56:	88 14 c5 0b e0 01 c0 	mov    %dl,-0x3ffe1ff5(,%eax,8)
    cpu->core    = static_cast<uint8>(Cpu::core);
c0005a5d:	8b 15 74 f7 ff cf    	mov    0xcffff774,%edx
c0005a63:	88 14 c5 0a e0 01 c0 	mov    %dl,-0x3ffe1ff6(,%eax,8)
    cpu->thread  = static_cast<uint8>(Cpu::thread);
c0005a6a:	8b 15 70 f7 ff cf    	mov    0xcffff770,%edx
c0005a70:	88 14 c5 09 e0 01 c0 	mov    %dl,-0x3ffe1ff7(,%eax,8)
    cpu->flags   = 1;
c0005a77:	c3                   	ret    

c0005a78 <_ZN3Hip9add_checkEv>:

void Hip::add_check()
{
    Hip *h = hip();

    h->freq_tsc = Lapic::freq_tsc;
c0005a78:	a1 78 b0 01 c0       	mov    0xc001b078,%eax

    uint16 c = 0;
    for (uint16 const *ptr = reinterpret_cast<uint16 const *>(&PAGE_H);
c0005a7d:	ba 00 e0 01 c0       	mov    $0xc001e000,%edx
                       ptr < reinterpret_cast<uint16 const *>(&PAGE_H + h->length);
c0005a82:	0f b7 0d 06 e0 01 c0 	movzwl 0xc001e006,%ecx

void Hip::add_check()
{
    Hip *h = hip();

    h->freq_tsc = Lapic::freq_tsc;
c0005a89:	a3 30 e0 01 c0       	mov    %eax,0xc001e030

    uint16 c = 0;
c0005a8e:	31 c0                	xor    %eax,%eax
    for (uint16 const *ptr = reinterpret_cast<uint16 const *>(&PAGE_H);
                       ptr < reinterpret_cast<uint16 const *>(&PAGE_H + h->length);
c0005a90:	81 c1 00 e0 01 c0    	add    $0xc001e000,%ecx
    Hip *h = hip();

    h->freq_tsc = Lapic::freq_tsc;

    uint16 c = 0;
    for (uint16 const *ptr = reinterpret_cast<uint16 const *>(&PAGE_H);
c0005a96:	39 ca                	cmp    %ecx,%edx
c0005a98:	73 0c                	jae    c0005aa6 <_ZN3Hip9add_checkEv+0x2e>
c0005a9a:	83 c2 02             	add    $0x2,%edx
c0005a9d:	66 2b 42 fe          	sub    -0x2(%edx),%ax
c0005aa1:	0f b7 c0             	movzwl %ax,%eax
c0005aa4:	eb f0                	jmp    c0005a96 <_ZN3Hip9add_checkEv+0x1e>
                       ptr < reinterpret_cast<uint16 const *>(&PAGE_H + h->length);
                       c = static_cast<uint16>(c - *ptr++)) ;

    h->checksum = c;
c0005aa6:	66 a3 04 e0 01 c0    	mov    %ax,0xc001e004
c0005aac:	c3                   	ret    

c0005aad <_GLOBAL__sub_I.00102__ZN4Hpet5cacheE>:
 */

#include "hpet.hpp"

INIT_PRIORITY (PRIO_SLAB)
Slab_cache Hpet::cache (sizeof (Hpet), 8);
c0005aad:	b9 08 00 00 00       	mov    $0x8,%ecx
c0005ab2:	ba 10 00 00 00       	mov    $0x10,%edx
c0005ab7:	b8 ec aa 01 c0       	mov    $0xc001aaec,%eax
c0005abc:	e9 45 a7 00 00       	jmp    c0010206 <_ZN10Slab_cacheC1Emj>
c0005ac1:	90                   	nop

c0005ac2 <_ZN3Hpt9sync_fromER5QuotaS_mm>:
#include "assert.hpp"
#include "bits.hpp"
#include "hpt.hpp"

bool Hpt::sync_from (Quota &quota, Hpt src, mword v, mword o)
{
c0005ac2:	55                   	push   %ebp
c0005ac3:	89 c5                	mov    %eax,%ebp
c0005ac5:	57                   	push   %edi

ALWAYS_INLINE
inline long int bit_scan_reverse (mword val)
{
    if (EXPECT_FALSE (!val))
        return -1;
c0005ac6:	83 c8 ff             	or     $0xffffffff,%eax
c0005ac9:	56                   	push   %esi
c0005aca:	89 d6                	mov    %edx,%esi
c0005acc:	53                   	push   %ebx
c0005acd:	53                   	push   %ebx
#include "util.hpp"

ALWAYS_INLINE
inline long int bit_scan_reverse (mword val)
{
    if (EXPECT_FALSE (!val))
c0005ace:	8b 54 24 18          	mov    0x18(%esp),%edx
c0005ad2:	33 54 24 1c          	xor    0x1c(%esp),%edx
c0005ad6:	89 0c 24             	mov    %ecx,(%esp)
c0005ad9:	74 03                	je     c0005ade <_ZN3Hpt9sync_fromER5QuotaS_mm+0x1c>
        return -1;

    asm volatile ("bsr %1, %0" : "=r" (val) : "rm" (val));

    return val;
c0005adb:	0f bd c2             	bsr    %edx,%eax
    mword l = (bit_scan_reverse (v ^ o) - PAGE_BITS) / bpl();
c0005ade:	83 e8 0c             	sub    $0xc,%eax
c0005ae1:	b9 0a 00 00 00       	mov    $0xa,%ecx
c0005ae6:	31 d2                	xor    %edx,%edx
c0005ae8:	f7 f1                	div    %ecx

    Hpt *s = static_cast<Hpt *>(src.walk (quota, v, l, false));
c0005aea:	89 f2                	mov    %esi,%edx
c0005aec:	6a 00                	push   $0x0
c0005aee:	50                   	push   %eax
#include "bits.hpp"
#include "hpt.hpp"

bool Hpt::sync_from (Quota &quota, Hpt src, mword v, mword o)
{
    mword l = (bit_scan_reverse (v ^ o) - PAGE_BITS) / bpl();
c0005aef:	89 c7                	mov    %eax,%edi

    Hpt *s = static_cast<Hpt *>(src.walk (quota, v, l, false));
c0005af1:	8b 4c 24 20          	mov    0x20(%esp),%ecx
c0005af5:	8d 44 24 08          	lea    0x8(%esp),%eax
c0005af9:	e8 be 83 00 00       	call   c000debc <_ZN3PteI3HptmLj2ELj10ELb0EE4walkER5Quotammb>
c0005afe:	89 c3                	mov    %eax,%ebx
    if (!s)
c0005b00:	58                   	pop    %eax
c0005b01:	85 db                	test   %ebx,%ebx
c0005b03:	5a                   	pop    %edx
c0005b04:	75 04                	jne    c0005b0a <_ZN3Hpt9sync_fromER5QuotaS_mm+0x48>
        return false;
c0005b06:	31 c0                	xor    %eax,%eax
c0005b08:	eb 3b                	jmp    c0005b45 <_ZN3Hpt9sync_fromER5QuotaS_mm+0x83>

    Hpt *d = static_cast<Hpt *>(walk (quota, v, l));
c0005b0a:	6a 01                	push   $0x1
c0005b0c:	89 f2                	mov    %esi,%edx
c0005b0e:	57                   	push   %edi
c0005b0f:	89 e8                	mov    %ebp,%eax
c0005b11:	8b 4c 24 20          	mov    0x20(%esp),%ecx
c0005b15:	e8 a2 83 00 00       	call   c000debc <_ZN3PteI3HptmLj2ELj10ELb0EE4walkER5Quotammb>
    assert (d);
c0005b1a:	59                   	pop    %ecx
c0005b1b:	5e                   	pop    %esi
c0005b1c:	85 c0                	test   %eax,%eax
c0005b1e:	75 1b                	jne    c0005b3b <_ZN3Hpt9sync_fromER5QuotaS_mm+0x79>
c0005b20:	68 80 71 01 c0       	push   $0xc0017180
c0005b25:	6a 23                	push   $0x23
c0005b27:	68 c3 70 01 c0       	push   $0xc00170c3
c0005b2c:	68 5c 5f 01 c0       	push   $0xc0015f5c
c0005b31:	68 69 60 01 c0       	push   $0xc0016069
c0005b36:	e8 0b be ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

    if (d->val == s->val)
c0005b3b:	8b 13                	mov    (%ebx),%edx
c0005b3d:	39 10                	cmp    %edx,(%eax)
c0005b3f:	74 c5                	je     c0005b06 <_ZN3Hpt9sync_fromER5QuotaS_mm+0x44>
        return false;

    d->val = s->val;
c0005b41:	89 10                	mov    %edx,(%eax)

    return true;
c0005b43:	b0 01                	mov    $0x1,%al
}
c0005b45:	5a                   	pop    %edx
c0005b46:	5b                   	pop    %ebx
c0005b47:	5e                   	pop    %esi
c0005b48:	5f                   	pop    %edi
c0005b49:	5d                   	pop    %ebp
c0005b4a:	c3                   	ret    
c0005b4b:	90                   	nop

c0005b4c <_ZN3Hpt17sync_master_rangeER5Quotamm>:

void Hpt::sync_master_range (Quota & quota, mword s, mword e)
{
c0005b4c:	55                   	push   %ebp
c0005b4d:	89 d5                	mov    %edx,%ebp
c0005b4f:	57                   	push   %edi
c0005b50:	89 c7                	mov    %eax,%edi
c0005b52:	56                   	push   %esi
c0005b53:	89 ce                	mov    %ecx,%esi
c0005b55:	53                   	push   %ebx
inline long int bit_scan_reverse (mword val)
{
    if (EXPECT_FALSE (!val))
        return -1;

    asm volatile ("bsr %1, %0" : "=r" (val) : "rm" (val));
c0005b56:	bb 00 00 c0 0f       	mov    $0xfc00000,%ebx
c0005b5b:	0f bd db             	bsr    %ebx,%ebx
    for (mword l = (bit_scan_reverse (LINK_ADDR ^ CPU_LOCAL) - PAGE_BITS) / bpl(); s < e; s += 1UL << (l * bpl() + PAGE_BITS))
c0005b5e:	b9 0a 00 00 00       	mov    $0xa,%ecx
c0005b63:	31 d2                	xor    %edx,%edx
c0005b65:	8d 43 f4             	lea    -0xc(%ebx),%eax
c0005b68:	bb 01 00 00 00       	mov    $0x1,%ebx
c0005b6d:	f7 f1                	div    %ecx
c0005b6f:	6b c0 0a             	imul   $0xa,%eax,%eax
c0005b72:	8d 48 0c             	lea    0xc(%eax),%ecx
c0005b75:	d3 e3                	shl    %cl,%ebx
c0005b77:	3b 74 24 14          	cmp    0x14(%esp),%esi
c0005b7b:	73 1a                	jae    c0005b97 <_ZN3Hpt17sync_master_rangeER5Quotamm+0x4b>
        sync_from (quota, Hptp (reinterpret_cast<mword>(&PDBR)), s, CPU_LOCAL);
c0005b7d:	68 00 00 c0 cf       	push   $0xcfc00000
c0005b82:	89 ea                	mov    %ebp,%edx
c0005b84:	56                   	push   %esi
c0005b85:	b9 00 f0 41 00       	mov    $0x41f000,%ecx
c0005b8a:	89 f8                	mov    %edi,%eax
    return true;
}

void Hpt::sync_master_range (Quota & quota, mword s, mword e)
{
    for (mword l = (bit_scan_reverse (LINK_ADDR ^ CPU_LOCAL) - PAGE_BITS) / bpl(); s < e; s += 1UL << (l * bpl() + PAGE_BITS))
c0005b8c:	01 de                	add    %ebx,%esi
        sync_from (quota, Hptp (reinterpret_cast<mword>(&PDBR)), s, CPU_LOCAL);
c0005b8e:	e8 2f ff ff ff       	call   c0005ac2 <_ZN3Hpt9sync_fromER5QuotaS_mm>
c0005b93:	58                   	pop    %eax
c0005b94:	5a                   	pop    %edx
c0005b95:	eb e0                	jmp    c0005b77 <_ZN3Hpt17sync_master_rangeER5Quotamm+0x2b>
}
c0005b97:	5b                   	pop    %ebx
c0005b98:	5e                   	pop    %esi
c0005b99:	5f                   	pop    %edi
c0005b9a:	5d                   	pop    %ebp
c0005b9b:	c3                   	ret    

c0005b9c <_ZN3Hpt7replaceER5Quotamm>:

Paddr Hpt::replace (Quota &quota, mword v, mword p)
{
c0005b9c:	56                   	push   %esi
c0005b9d:	53                   	push   %ebx
c0005b9e:	89 cb                	mov    %ecx,%ebx
c0005ba0:	8b 74 24 0c          	mov    0xc(%esp),%esi
    Hpt o, *e = walk (quota, v, 0); assert (e);
c0005ba4:	6a 01                	push   $0x1
c0005ba6:	6a 00                	push   $0x0
c0005ba8:	e8 0f 83 00 00       	call   c000debc <_ZN3PteI3HptmLj2ELj10ELb0EE4walkER5Quotammb>
c0005bad:	89 c2                	mov    %eax,%edx
c0005baf:	58                   	pop    %eax
c0005bb0:	85 d2                	test   %edx,%edx
c0005bb2:	59                   	pop    %ecx
c0005bb3:	75 25                	jne    c0005bda <_ZN3Hpt7replaceER5Quotamm+0x3e>
c0005bb5:	68 40 71 01 c0       	push   $0xc0017140
c0005bba:	6a 35                	push   $0x35
c0005bbc:	68 c3 70 01 c0       	push   $0xc00170c3
c0005bc1:	68 96 6e 01 c0       	push   $0xc0016e96
c0005bc6:	68 69 60 01 c0       	push   $0xc0016069
c0005bcb:	e8 76 bd ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

    do o = *e; while (o.val != p && !(o.attr() & HPT_W) && !e->set (o.val, p));
c0005bd0:	a8 02                	test   $0x2,%al
c0005bd2:	75 0c                	jne    c0005be0 <_ZN3Hpt7replaceER5Quotamm+0x44>
c0005bd4:	f0 0f b1 32          	lock cmpxchg %esi,(%edx)
c0005bd8:	74 06                	je     c0005be0 <_ZN3Hpt7replaceER5Quotamm+0x44>
c0005bda:	8b 02                	mov    (%edx),%eax
c0005bdc:	39 f0                	cmp    %esi,%eax
c0005bde:	75 f0                	jne    c0005bd0 <_ZN3Hpt7replaceER5Quotamm+0x34>

    public:
        ALWAYS_INLINE
        static inline void flush (mword addr)
        {
            asm volatile ("invlpg %0" : : "m" (*reinterpret_cast<mword *>(addr)));
c0005be0:	0f 01 3b             	invlpg (%ebx)
            PTE_S   = HPT_S,
            PTE_N   = HPT_A | HPT_U | HPT_W | HPT_P,
        };

        ALWAYS_INLINE
        inline Paddr addr() const { return static_cast<Paddr>(val) & ~PAGE_MASK; }
c0005be3:	8b 02                	mov    (%edx),%eax

    flush(v);
    return e->addr();
}
c0005be5:	5b                   	pop    %ebx
c0005be6:	5e                   	pop    %esi
c0005be7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0005bec:	c3                   	ret    
c0005bed:	90                   	nop

c0005bee <_ZN3Hpt5remapER5Quotam>:

void *Hpt::remap (Quota &quota, Paddr phys)
{
c0005bee:	57                   	push   %edi
c0005bef:	56                   	push   %esi
c0005bf0:	89 c6                	mov    %eax,%esi
c0005bf2:	53                   	push   %ebx
c0005bf3:	83 ec 0c             	sub    $0xc,%esp

        ALWAYS_INLINE
        static inline mword current()
        {
            mword addr;
            asm volatile ("mov %%cr3, %0" : "=r" (addr));
c0005bf6:	0f 20 d8             	mov    %cr3,%eax

class Hptp : public Hpt
{
    public:
        ALWAYS_INLINE
        inline explicit Hptp (mword v = 0) { val = v; }
c0005bf9:	89 04 24             	mov    %eax,(%esp)
    mword offset = phys & (size - 1);

    phys &= ~offset;

    Paddr old; mword attr;
    if (hpt.lookup (SPC_LOCAL_REMAP, old, attr)) {
c0005bfc:	8d 44 24 08          	lea    0x8(%esp),%eax

    size_t size = 1UL << (bpl() + PAGE_BITS);

    mword offset = phys & (size - 1);

    phys &= ~offset;
c0005c00:	89 d7                	mov    %edx,%edi

    Paddr old; mword attr;
    if (hpt.lookup (SPC_LOCAL_REMAP, old, attr)) {
c0005c02:	50                   	push   %eax

    size_t size = 1UL << (bpl() + PAGE_BITS);

    mword offset = phys & (size - 1);

    phys &= ~offset;
c0005c03:	89 d3                	mov    %edx,%ebx

    Paddr old; mword attr;
    if (hpt.lookup (SPC_LOCAL_REMAP, old, attr)) {
c0005c05:	8d 4c 24 08          	lea    0x8(%esp),%ecx
c0005c09:	ba 00 00 00 df       	mov    $0xdf000000,%edx
c0005c0e:	8d 44 24 04          	lea    0x4(%esp),%eax

    size_t size = 1UL << (bpl() + PAGE_BITS);

    mword offset = phys & (size - 1);

    phys &= ~offset;
c0005c12:	81 e7 ff ff 3f 00    	and    $0x3fffff,%edi

    Paddr old; mword attr;
    if (hpt.lookup (SPC_LOCAL_REMAP, old, attr)) {
c0005c18:	e8 0f 84 00 00       	call   c000e02c <_ZN3PteI3HptmLj2ELj10ELb0EE6lookupEmRmS2_>

    size_t size = 1UL << (bpl() + PAGE_BITS);

    mword offset = phys & (size - 1);

    phys &= ~offset;
c0005c1d:	81 e3 00 00 c0 ff    	and    $0xffc00000,%ebx

    Paddr old; mword attr;
    if (hpt.lookup (SPC_LOCAL_REMAP, old, attr)) {
c0005c23:	5a                   	pop    %edx
c0005c24:	85 c0                	test   %eax,%eax
c0005c26:	74 41                	je     c0005c69 <_ZN3Hpt5remapER5Quotam+0x7b>
        hpt.update (quota, SPC_LOCAL_REMAP,        bpl(), 0, 0, Hpt::TYPE_DN); flush (SPC_LOCAL_REMAP);
c0005c28:	6a 01                	push   $0x1
c0005c2a:	b9 00 00 00 df       	mov    $0xdf000000,%ecx
c0005c2f:	6a 00                	push   $0x0
c0005c31:	89 f2                	mov    %esi,%edx
c0005c33:	6a 00                	push   $0x0
c0005c35:	6a 0a                	push   $0xa
c0005c37:	8d 44 24 10          	lea    0x10(%esp),%eax
c0005c3b:	e8 80 84 00 00       	call   c000e0c0 <_ZN3PteI3HptmLj2ELj10ELb0EE6updateER5QuotammmmNS1_4TypeE>

    public:
        ALWAYS_INLINE
        static inline void flush (mword addr)
        {
            asm volatile ("invlpg %0" : : "m" (*reinterpret_cast<mword *>(addr)));
c0005c40:	0f 01 3d 00 00 00 df 	invlpg 0xdf000000
        hpt.update (quota, SPC_LOCAL_REMAP + size, bpl(), 0, 0, Hpt::TYPE_DN); flush (SPC_LOCAL_REMAP + size);
c0005c47:	6a 01                	push   $0x1
c0005c49:	b9 00 00 40 df       	mov    $0xdf400000,%ecx
c0005c4e:	6a 00                	push   $0x0
c0005c50:	89 f2                	mov    %esi,%edx
c0005c52:	6a 00                	push   $0x0
c0005c54:	6a 0a                	push   $0xa
c0005c56:	8d 44 24 20          	lea    0x20(%esp),%eax
c0005c5a:	e8 61 84 00 00       	call   c000e0c0 <_ZN3PteI3HptmLj2ELj10ELb0EE6updateER5QuotammmmNS1_4TypeE>
c0005c5f:	0f 01 3d 00 00 40 df 	invlpg 0xdf400000
c0005c66:	83 c4 20             	add    $0x20,%esp
    }

    hpt.update (quota, SPC_LOCAL_REMAP,        bpl(), phys,        HPT_W | HPT_P);
c0005c69:	6a 00                	push   $0x0
c0005c6b:	89 f2                	mov    %esi,%edx
c0005c6d:	6a 03                	push   $0x3
c0005c6f:	b9 00 00 00 df       	mov    $0xdf000000,%ecx
c0005c74:	53                   	push   %ebx
    hpt.update (quota, SPC_LOCAL_REMAP + size, bpl(), phys + size, HPT_W | HPT_P);
c0005c75:	81 c3 00 00 40 00    	add    $0x400000,%ebx
    if (hpt.lookup (SPC_LOCAL_REMAP, old, attr)) {
        hpt.update (quota, SPC_LOCAL_REMAP,        bpl(), 0, 0, Hpt::TYPE_DN); flush (SPC_LOCAL_REMAP);
        hpt.update (quota, SPC_LOCAL_REMAP + size, bpl(), 0, 0, Hpt::TYPE_DN); flush (SPC_LOCAL_REMAP + size);
    }

    hpt.update (quota, SPC_LOCAL_REMAP,        bpl(), phys,        HPT_W | HPT_P);
c0005c7b:	6a 0a                	push   $0xa
c0005c7d:	8d 44 24 10          	lea    0x10(%esp),%eax
c0005c81:	e8 3a 84 00 00       	call   c000e0c0 <_ZN3PteI3HptmLj2ELj10ELb0EE6updateER5QuotammmmNS1_4TypeE>
    hpt.update (quota, SPC_LOCAL_REMAP + size, bpl(), phys + size, HPT_W | HPT_P);
c0005c86:	89 f2                	mov    %esi,%edx
c0005c88:	b9 00 00 40 df       	mov    $0xdf400000,%ecx
c0005c8d:	6a 00                	push   $0x0
c0005c8f:	6a 03                	push   $0x3
c0005c91:	53                   	push   %ebx
c0005c92:	6a 0a                	push   $0xa
c0005c94:	8d 44 24 20          	lea    0x20(%esp),%eax
c0005c98:	e8 23 84 00 00       	call   c000e0c0 <_ZN3PteI3HptmLj2ELj10ELb0EE6updateER5QuotammmmNS1_4TypeE>

    return reinterpret_cast<void *>(SPC_LOCAL_REMAP + offset);
}
c0005c9d:	83 c4 2c             	add    $0x2c,%esp
c0005ca0:	5b                   	pop    %ebx
    }

    hpt.update (quota, SPC_LOCAL_REMAP,        bpl(), phys,        HPT_W | HPT_P);
    hpt.update (quota, SPC_LOCAL_REMAP + size, bpl(), phys + size, HPT_W | HPT_P);

    return reinterpret_cast<void *>(SPC_LOCAL_REMAP + offset);
c0005ca1:	8d 87 00 00 00 df    	lea    -0x21000000(%edi),%eax
}
c0005ca7:	5e                   	pop    %esi
c0005ca8:	5f                   	pop    %edi
c0005ca9:	c3                   	ret    

c0005caa <_GLOBAL__sub_I.00102__ZN6Ioapic5cacheE>:
#include "ioapic.hpp"
#include "pd.hpp"
#include "stdio.hpp"

INIT_PRIORITY (PRIO_SLAB)
Slab_cache Ioapic::cache (sizeof (Ioapic), 8);
c0005caa:	b9 08 00 00 00       	mov    $0x8,%ecx
c0005caf:	ba 14 00 00 00       	mov    $0x14,%edx
c0005cb4:	b8 5c b0 01 c0       	mov    $0xc001b05c,%eax
c0005cb9:	e9 48 a5 00 00       	jmp    c0010206 <_ZN10Slab_cacheC1Emj>

c0005cbe <_ZN4Keyb9interruptEv>:
}

void Keyb::interrupt()
{
c0005cbe:	53                   	push   %ebx
        template <typename T>
        ALWAYS_INLINE
        static inline unsigned in (unsigned port)
        {
            T val;
            asm volatile ("in %w1, %0" : "=a" (val) : "Nd" (port));
c0005cbf:	e4 64                	in     $0x64,%al
c0005cc1:	88 c1                	mov    %al,%cl
    unsigned sts;

    while ((sts = status()) & STS_OUTB) {
c0005cc3:	24 01                	and    $0x1,%al
c0005cc5:	84 c0                	test   %al,%al
c0005cc7:	74 61                	je     c0005d2a <_ZN4Keyb9interruptEv+0x6c>
c0005cc9:	e4 60                	in     $0x60,%al

        unsigned out = output();

        if (sts & STS_AUXB)
c0005ccb:	80 e1 20             	and    $0x20,%cl
c0005cce:	84 c9                	test   %cl,%cl
c0005cd0:	75 ed                	jne    c0005cbf <_ZN4Keyb9interruptEv+0x1>
            continue;

        if (out & 0x80)
c0005cd2:	84 c0                	test   %al,%al
            return val;
c0005cd4:	0f b6 c8             	movzbl %al,%ecx
c0005cd7:	78 e6                	js     c0005cbf <_ZN4Keyb9interruptEv+0x1>
            continue;

        switch (out) {
c0005cd9:	3c 2e                	cmp    $0x2e,%al
c0005cdb:	74 43                	je     c0005d20 <_ZN4Keyb9interruptEv+0x62>
c0005cdd:	77 12                	ja     c0005cf1 <_ZN4Keyb9interruptEv+0x33>
c0005cdf:	fe c8                	dec    %al
c0005ce1:	75 dc                	jne    c0005cbf <_ZN4Keyb9interruptEv+0x1>
            case 0x1:               // esc
                Acpi::reset();
c0005ce3:	e8 f4 ad ff ff       	call   c0000adc <_ZN4Acpi5resetEv>

        template <typename T>
        ALWAYS_INLINE
        static inline void out (unsigned port, T val)
        {
            asm volatile ("out %0, %w1" : : "a" (val), "Nd" (port));
c0005ce8:	ba f9 0c 00 00       	mov    $0xcf9,%edx
c0005ced:	b0 06                	mov    $0x6,%al
c0005cef:	eb 36                	jmp    c0005d27 <_ZN4Keyb9interruptEv+0x69>
            continue;

        if (out & 0x80)
            continue;

        switch (out) {
c0005cf1:	2c 3b                	sub    $0x3b,%al
c0005cf3:	3c 07                	cmp    $0x7,%al
c0005cf5:	77 c8                	ja     c0005cbf <_ZN4Keyb9interruptEv+0x1>
c0005cf7:	bb d4 03 00 00       	mov    $0x3d4,%ebx
c0005cfc:	b0 0c                	mov    $0xc,%al
c0005cfe:	89 da                	mov    %ebx,%edx
c0005d00:	ee                   	out    %al,(%dx)
        }

        ALWAYS_INLINE
        static inline void set_page (unsigned page)
        {
            page <<= 11;    // due to odd/even addressing
c0005d01:	8d 04 cd 28 fe ff 00 	lea    0xfffe28(,%ecx,8),%eax
c0005d08:	b9 d5 03 00 00       	mov    $0x3d5,%ecx
            write (START_ADDR_HI, static_cast<uint8>(page >> 8));
c0005d0d:	25 f8 ff ff 00       	and    $0xfffff8,%eax
c0005d12:	89 ca                	mov    %ecx,%edx
c0005d14:	ee                   	out    %al,(%dx)
c0005d15:	b0 0d                	mov    $0xd,%al
c0005d17:	89 da                	mov    %ebx,%edx
c0005d19:	ee                   	out    %al,(%dx)
c0005d1a:	31 c0                	xor    %eax,%eax
c0005d1c:	89 ca                	mov    %ecx,%edx
c0005d1e:	eb 07                	jmp    c0005d27 <_ZN4Keyb9interruptEv+0x69>
            case 0x1:               // esc
                Acpi::reset();
                Io::out<uint8>(0xcf9, 0x6);
                break;
            case 0x2e:              // c
                Counter::dump();
c0005d20:	e8 4b be ff ff       	call   c0001b70 <_ZN7Counter4dumpEv>
                break;
c0005d25:	eb 98                	jmp    c0005cbf <_ZN4Keyb9interruptEv+0x1>
c0005d27:	ee                   	out    %al,(%dx)
c0005d28:	eb 95                	jmp    c0005cbf <_ZN4Keyb9interruptEv+0x1>
            case 0x3b ... 0x42:     // f1-f8
                Console_vga::con.set_page (out - 0x3b);
                break;
        }
    }
}
c0005d2a:	5b                   	pop    %ebx
c0005d2b:	c3                   	ret    

c0005d2c <_ZN7Counter5printILj1ELj16EEEvmN11Console_vga5ColorEj.part.4>:
c0005d2c:	83 e0 0f             	and    $0xf,%eax
        inline unsigned spinner (unsigned id) { return id < 25 - num ? 24 - id : 0; }

        ALWAYS_INLINE
        inline void put (unsigned long r, unsigned long c, Color color, int x)
        {
            *reinterpret_cast<unsigned short volatile *>(HV_GLOBAL_FBUF + r * 160 + c * 2) = static_cast<unsigned short>(color << 8 | x);
c0005d2f:	66 0f be 80 14 66 01 	movsbw -0x3ffe99ec(%eax),%ax
c0005d36:	c0 
c0005d37:	c1 e2 08             	shl    $0x8,%edx
        {
            return *reinterpret_cast<volatile unsigned *>(reinterpret_cast<mword>(ipi + i) - CPU_LOCAL_DATA + HV_GLOBAL_CPUS + c * PAGE_SIZE);
        }

        template <unsigned D, unsigned B>
        static void print (mword val, Console_vga::Color c, unsigned col)
c0005d3a:	53                   	push   %ebx
c0005d3b:	6b 1d 50 f7 ff cf 50 	imul   $0x50,0xcffff750,%ebx
c0005d42:	09 c2                	or     %eax,%edx
c0005d44:	0f b7 d2             	movzwl %dx,%edx
c0005d47:	8d 8c 19 00 f8 df 67 	lea    0x67dff800(%ecx,%ebx,1),%ecx
c0005d4e:	66 89 14 09          	mov    %dx,(%ecx,%ecx,1)
        {
            if (EXPECT_FALSE (Cpu::row))
                for (unsigned i = 0; i < D; i++, val /= B)
                    Console_vga::con.put (Cpu::row, col - i, c, !i || val ? (val % B)["0123456789ABCDEF"] : ' ');
        }
c0005d52:	5b                   	pop    %ebx
c0005d53:	c3                   	ret    

c0005d54 <_ZN5Lapic8send_ipiEjjNS_13Delivery_modeENS_9ShorthandE>:

    trace (TRACE_APIC, "APIC:%#lx ID:%#x VER:%#x LVT:%#x (%s Mode)", apic_base & ~PAGE_MASK, id(), version(), lvt_max(), freq_bus ? "OS" : "DL");
}

void Lapic::send_ipi (unsigned cpu, unsigned vector, Delivery_mode dlv, Shorthand dsh)
{
c0005d54:	53                   	push   %ebx
        };

        ALWAYS_INLINE
        static inline uint32 read (Register reg)
        {
            return *reinterpret_cast<uint32 volatile *>(CPU_LOCAL_APIC + (reg << 4));
c0005d55:	8b 1d 00 e3 ff cf    	mov    0xcfffe300,%ebx
    while (EXPECT_FALSE (read (LAPIC_ICR_LO) & 1U << 12))
c0005d5b:	f6 c7 10             	test   $0x10,%bh
c0005d5e:	74 04                	je     c0005d64 <_ZN5Lapic8send_ipiEjjNS_13Delivery_modeENS_9ShorthandE+0x10>
}

ALWAYS_INLINE
static inline void pause()
{
    asm volatile ("pause" : : : "memory");
c0005d60:	f3 90                	pause  
c0005d62:	eb f1                	jmp    c0005d55 <_ZN5Lapic8send_ipiEjjNS_13Delivery_modeENS_9ShorthandE+0x1>
        pause();

    write (LAPIC_ICR_HI, Cpu::apic_id[cpu] << 24);
c0005d64:	0f b6 80 c0 a3 01 c0 	movzbl -0x3ffe5c40(%eax),%eax
c0005d6b:	80 ce 40             	or     $0x40,%dh
c0005d6e:	09 d1                	or     %edx,%ecx
c0005d70:	c1 e0 18             	shl    $0x18,%eax
        }

        ALWAYS_INLINE
        static inline void write (Register reg, uint32 val)
        {
            *reinterpret_cast<uint32 volatile *>(CPU_LOCAL_APIC + (reg << 4)) = val;
c0005d73:	a3 10 e3 ff cf       	mov    %eax,0xcfffe310
    write (LAPIC_ICR_LO, dsh | 1U << 14 | dlv | vector);
c0005d78:	0b 4c 24 08          	or     0x8(%esp),%ecx
c0005d7c:	89 0d 00 e3 ff cf    	mov    %ecx,0xcfffe300
}
c0005d82:	5b                   	pop    %ebx
c0005d83:	c3                   	ret    

c0005d84 <_ZN5Lapic4initEv>:

unsigned    Lapic::freq_tsc;
unsigned    Lapic::freq_bus;

void Lapic::init()
{
c0005d84:	57                   	push   %edi
c0005d85:	56                   	push   %esi
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
c0005d86:	be 1b 00 00 00       	mov    $0x1b,%esi
c0005d8b:	53                   	push   %ebx
c0005d8c:	89 f1                	mov    %esi,%ecx
c0005d8e:	52                   	push   %edx
c0005d8f:	0f 32                	rdmsr  
    Paddr apic_base = Msr::read<Paddr>(Msr::IA32_APIC_BASE);

    Pd::kern.Space_mem::delreg (Pd::kern.quota, apic_base & ~PAGE_MASK);
c0005d91:	89 c7                	mov    %eax,%edi
c0005d93:	89 c3                	mov    %eax,%ebx
c0005d95:	81 e7 00 f0 ff ff    	and    $0xfffff000,%edi
c0005d9b:	ba 50 b4 01 c0       	mov    $0xc001b450,%edx
c0005da0:	89 f9                	mov    %edi,%ecx
c0005da2:	b8 0c b3 01 c0       	mov    $0xc001b30c,%eax
c0005da7:	e8 54 c6 ff ff       	call   c0002400 <_ZN5Space6delregER5Quotam>

        ALWAYS_INLINE
        static inline mword current()
        {
            mword addr;
            asm volatile ("mov %%cr3, %0" : "=r" (addr));
c0005dac:	0f 20 d8             	mov    %cr3,%eax

class Hptp : public Hpt
{
    public:
        ALWAYS_INLINE
        inline explicit Hptp (mword v = 0) { val = v; }
c0005daf:	89 04 24             	mov    %eax,(%esp)
    Hptp (Hpt::current()).update (Pd::kern.quota, CPU_LOCAL_APIC, 0, Hpt::HPT_NX | Hpt::HPT_G | Hpt::HPT_UC | Hpt::HPT_W | Hpt::HPT_P, apic_base & ~PAGE_MASK);
c0005db2:	b9 00 e0 ff cf       	mov    $0xcfffe000,%ecx
c0005db7:	ba 50 b4 01 c0       	mov    $0xc001b450,%edx
c0005dbc:	6a 00                	push   $0x0
c0005dbe:	57                   	push   %edi
c0005dbf:	68 13 01 00 00       	push   $0x113
c0005dc4:	6a 00                	push   $0x0
c0005dc6:	8d 44 24 10          	lea    0x10(%esp),%eax
c0005dca:	e8 f1 82 00 00       	call   c000e0c0 <_ZN3PteI3HptmLj2ELj10ELb0EE6updateER5QuotammmmNS1_4TypeE>

    Msr::write (Msr::IA32_APIC_BASE, apic_base | 0x800);
c0005dcf:	89 d8                	mov    %ebx,%eax

        template <typename T>
        ALWAYS_INLINE
        static inline void write (Register msr, T val)
        {
            asm volatile ("wrmsr" : : "a" (static_cast<mword>(val)), "d" (static_cast<mword>(static_cast<uint64>(val) >> 32)), "c" (msr));
c0005dd1:	31 d2                	xor    %edx,%edx
c0005dd3:	80 cc 08             	or     $0x8,%ah
c0005dd6:	89 f1                	mov    %esi,%ecx
c0005dd8:	0f 30                	wrmsr  
        };

        ALWAYS_INLINE
        static inline uint32 read (Register reg)
        {
            return *reinterpret_cast<uint32 volatile *>(CPU_LOCAL_APIC + (reg << 4));
c0005dda:	a1 f0 e0 ff cf       	mov    0xcfffe0f0,%eax

    uint32 svr = read (LAPIC_SVR);
    if (!(svr & 0x100))
c0005ddf:	83 c4 10             	add    $0x10,%esp
c0005de2:	f6 c4 01             	test   $0x1,%ah
c0005de5:	75 08                	jne    c0005def <_ZN5Lapic4initEv+0x6b>
        write (LAPIC_SVR, svr | 0x100);
c0005de7:	80 cc 01             	or     $0x1,%ah
        }

        ALWAYS_INLINE
        static inline void write (Register reg, uint32 val)
        {
            *reinterpret_cast<uint32 volatile *>(CPU_LOCAL_APIC + (reg << 4)) = val;
c0005dea:	a3 f0 e0 ff cf       	mov    %eax,0xcfffe0f0

    bool dl = Cpu::feature (Cpu::FEAT_TSC_DEADLINE) && !Cmdline::nodl;
c0005def:	31 d2                	xor    %edx,%edx
c0005df1:	f6 05 0b f7 ff cf 01 	testb  $0x1,0xcffff70b
c0005df8:	74 09                	je     c0005e03 <_ZN5Lapic4initEv+0x7f>
c0005dfa:	8a 15 87 a3 01 c0    	mov    0xc001a387,%dl
c0005e00:	80 f2 01             	xor    $0x1,%dl
        };

        ALWAYS_INLINE
        static inline uint32 read (Register reg)
        {
            return *reinterpret_cast<uint32 volatile *>(CPU_LOCAL_APIC + (reg << 4));
c0005e03:	a1 30 e0 ff cf       	mov    0xcfffe030,%eax
        }

        ALWAYS_INLINE
        static inline unsigned lvt_max()
        {
            return read (LAPIC_LVR) >> 16 & 0xff;
c0005e08:	c1 e8 10             	shr    $0x10,%eax
c0005e0b:	0f b6 c0             	movzbl %al,%eax

    switch (lvt_max()) {
c0005e0e:	83 f8 04             	cmp    $0x4,%eax
c0005e11:	77 07                	ja     c0005e1a <_ZN5Lapic4initEv+0x96>
c0005e13:	ff 24 85 08 72 01 c0 	jmp    *-0x3ffe8df8(,%eax,4)
        }

        ALWAYS_INLINE
        static inline void write (Register reg, uint32 val)
        {
            *reinterpret_cast<uint32 volatile *>(CPU_LOCAL_APIC + (reg << 4)) = val;
c0005e1a:	c7 05 30 e3 ff cf a5 	movl   $0xa5,0xcfffe330
c0005e21:	00 00 00 
c0005e24:	c7 05 40 e3 ff cf a4 	movl   $0xa4,0xcfffe340
c0005e2b:	00 00 00 
c0005e2e:	c7 05 70 e3 ff cf a3 	movl   $0xa3,0xcfffe370
c0005e35:	00 00 00 
c0005e38:	c7 05 60 e3 ff cf 00 	movl   $0x400,0xcfffe360
c0005e3f:	04 00 00 
c0005e42:	c7 05 50 e3 ff cf 00 	movl   $0x10700,0xcfffe350
c0005e49:	07 01 00 
        case 2:
            set_lvt (LAPIC_LVT_LINT1, DLV_NMI, 0);
        case 1:
            set_lvt (LAPIC_LVT_LINT0, DLV_EXTINT, 0, 1U << 16);
        case 0:
            set_lvt (LAPIC_LVT_TIMER, DLV_FIXED, VEC_LVT_TIMER, dl ? 2U << 17 : 0);
c0005e4c:	80 fa 01             	cmp    $0x1,%dl
c0005e4f:	19 c0                	sbb    %eax,%eax
c0005e51:	f7 d0                	not    %eax
c0005e53:	25 00 00 04 00       	and    $0x40000,%eax
        }

        ALWAYS_INLINE
        static inline void set_lvt (Register reg, Delivery_mode dlv, unsigned vector, unsigned misc = 0)
        {
            write (reg, misc | dlv | vector);
c0005e58:	0c a0                	or     $0xa0,%al
        }

        ALWAYS_INLINE
        static inline void write (Register reg, uint32 val)
        {
            *reinterpret_cast<uint32 volatile *>(CPU_LOCAL_APIC + (reg << 4)) = val;
c0005e5a:	a3 20 e3 ff cf       	mov    %eax,0xcfffe320
        }

        ALWAYS_INLINE
        static unsigned find_by_apic_id (unsigned x)
        {
            for (unsigned i = 0; i < NUM_CPU; i++)
c0005e5f:	31 c0                	xor    %eax,%eax
c0005e61:	c7 05 80 e0 ff cf 10 	movl   $0x10,0xcfffe080
c0005e68:	00 00 00 
c0005e6b:	c7 05 e0 e3 ff cf 0b 	movl   $0xb,0xcfffe3e0
c0005e72:	00 00 00 
        };

        ALWAYS_INLINE
        static inline uint32 read (Register reg)
        {
            return *reinterpret_cast<uint32 volatile *>(CPU_LOCAL_APIC + (reg << 4));
c0005e75:	8b 15 20 e0 ff cf    	mov    0xcfffe020,%edx
        static unsigned freq_bus;

        ALWAYS_INLINE
        static inline unsigned id()
        {
            return read (LAPIC_IDR) >> 24 & 0xff;
c0005e7b:	c1 ea 18             	shr    $0x18,%edx
                if (apic_id[i] == x)
c0005e7e:	0f b6 88 c0 a3 01 c0 	movzbl -0x3ffe5c40(%eax),%ecx
c0005e85:	39 d1                	cmp    %edx,%ecx
c0005e87:	74 09                	je     c0005e92 <_ZN5Lapic4initEv+0x10e>
        }

        ALWAYS_INLINE
        static unsigned find_by_apic_id (unsigned x)
        {
            for (unsigned i = 0; i < NUM_CPU; i++)
c0005e89:	40                   	inc    %eax
c0005e8a:	83 f8 40             	cmp    $0x40,%eax
c0005e8d:	75 ef                	jne    c0005e7e <_ZN5Lapic4initEv+0xfa>
                if (apic_id[i] == x)
                    return i;

            return ~0U;
c0005e8f:	83 c8 ff             	or     $0xffffffff,%eax
    write (LAPIC_TPR, 0x10);
    write (LAPIC_TMR_DCR, 0xb);

    Cpu::id = Cpu::find_by_apic_id (id());

    if ((Cpu::bsp = apic_base & 0x100)) {
c0005e92:	c1 eb 08             	shr    $0x8,%ebx
c0005e95:	80 e3 01             	and    $0x1,%bl
c0005e98:	84 db                	test   %bl,%bl
    }

    write (LAPIC_TPR, 0x10);
    write (LAPIC_TMR_DCR, 0xb);

    Cpu::id = Cpu::find_by_apic_id (id());
c0005e9a:	a3 04 f0 ff cf       	mov    %eax,0xcffff004

    if ((Cpu::bsp = apic_base & 0x100)) {
c0005e9f:	88 1d 01 f7 ff cf    	mov    %bl,0xcffff701
c0005ea5:	0f 84 8e 00 00 00    	je     c0005f39 <_ZN5Lapic4initEv+0x1b5>

        send_ipi (0, 0, DLV_INIT, DSH_EXC_SELF);
c0005eab:	68 00 00 0c 00       	push   $0xc0000
c0005eb0:	b9 00 05 00 00       	mov    $0x500,%ecx
c0005eb5:	31 d2                	xor    %edx,%edx
c0005eb7:	31 c0                	xor    %eax,%eax
c0005eb9:	e8 96 fe ff ff       	call   c0005d54 <_ZN5Lapic8send_ipiEjjNS_13Delivery_modeENS_9ShorthandE>
        }

        ALWAYS_INLINE
        static inline void write (Register reg, uint32 val)
        {
            *reinterpret_cast<uint32 volatile *>(CPU_LOCAL_APIC + (reg << 4)) = val;
c0005ebe:	c7 05 80 e3 ff cf ff 	movl   $0xffffffff,0xcfffe380
c0005ec5:	ff ff ff 
        };

        ALWAYS_INLINE
        static inline uint32 read (Register reg)
        {
            return *reinterpret_cast<uint32 volatile *>(CPU_LOCAL_APIC + (reg << 4));
c0005ec8:	8b 1d 90 e3 ff cf    	mov    0xcfffe390,%ebx

ALWAYS_INLINE
static inline uint64 rdtsc()
{
    mword h, l;
    asm volatile ("rdtsc" : "=a" (l), "=d" (h));
c0005ece:	0f 31                	rdtsc  
c0005ed0:	89 c7                	mov    %eax,%edi

        write (LAPIC_TMR_ICR, ~0U);

        uint32 v1 = read (LAPIC_TMR_CCR);
        uint32 t1 = static_cast<uint32>(rdtsc());
        Acpi::delay (10);
c0005ed2:	b8 0a 00 00 00       	mov    $0xa,%eax
c0005ed7:	e8 a8 aa ff ff       	call   c0000984 <_ZN4Acpi5delayEj>
c0005edc:	8b 35 90 e3 ff cf    	mov    0xcfffe390,%esi
c0005ee2:	0f 31                	rdtsc  
        uint32 v2 = read (LAPIC_TMR_CCR);
        uint32 t2 = static_cast<uint32>(rdtsc());

        freq_tsc = (t2 - t1) / 10;
c0005ee4:	b9 0a 00 00 00       	mov    $0xa,%ecx
c0005ee9:	29 f8                	sub    %edi,%eax
c0005eeb:	31 d2                	xor    %edx,%edx
c0005eed:	f7 f1                	div    %ecx
        freq_bus = (v1 - v2) / 10;
c0005eef:	31 d2                	xor    %edx,%edx

        trace (TRACE_APIC, "TSC:%u kHz BUS:%u kHz", freq_tsc, freq_bus);

        send_ipi (0, 1, DLV_SIPI, DSH_EXC_SELF);
c0005ef1:	68 00 00 0c 00       	push   $0xc0000
        uint32 t1 = static_cast<uint32>(rdtsc());
        Acpi::delay (10);
        uint32 v2 = read (LAPIC_TMR_CCR);
        uint32 t2 = static_cast<uint32>(rdtsc());

        freq_tsc = (t2 - t1) / 10;
c0005ef6:	a3 78 b0 01 c0       	mov    %eax,0xc001b078
        freq_bus = (v1 - v2) / 10;
c0005efb:	89 d8                	mov    %ebx,%eax
c0005efd:	29 f0                	sub    %esi,%eax
c0005eff:	f7 f1                	div    %ecx

        trace (TRACE_APIC, "TSC:%u kHz BUS:%u kHz", freq_tsc, freq_bus);

        send_ipi (0, 1, DLV_SIPI, DSH_EXC_SELF);
c0005f01:	66 b9 00 06          	mov    $0x600,%cx
c0005f05:	ba 01 00 00 00       	mov    $0x1,%edx
        Acpi::delay (10);
        uint32 v2 = read (LAPIC_TMR_CCR);
        uint32 t2 = static_cast<uint32>(rdtsc());

        freq_tsc = (t2 - t1) / 10;
        freq_bus = (v1 - v2) / 10;
c0005f0a:	a3 74 b0 01 c0       	mov    %eax,0xc001b074

        trace (TRACE_APIC, "TSC:%u kHz BUS:%u kHz", freq_tsc, freq_bus);

        send_ipi (0, 1, DLV_SIPI, DSH_EXC_SELF);
c0005f0f:	31 c0                	xor    %eax,%eax
c0005f11:	e8 3e fe ff ff       	call   c0005d54 <_ZN5Lapic8send_ipiEjjNS_13Delivery_modeENS_9ShorthandE>
        Acpi::delay (1);
c0005f16:	b8 01 00 00 00       	mov    $0x1,%eax
c0005f1b:	e8 64 aa ff ff       	call   c0000984 <_ZN4Acpi5delayEj>
        send_ipi (0, 1, DLV_SIPI, DSH_EXC_SELF);
c0005f20:	b9 00 06 00 00       	mov    $0x600,%ecx
c0005f25:	ba 01 00 00 00       	mov    $0x1,%edx
c0005f2a:	68 00 00 0c 00       	push   $0xc0000
c0005f2f:	31 c0                	xor    %eax,%eax
c0005f31:	e8 1e fe ff ff       	call   c0005d54 <_ZN5Lapic8send_ipiEjjNS_13Delivery_modeENS_9ShorthandE>
c0005f36:	83 c4 0c             	add    $0xc,%esp
        }

        ALWAYS_INLINE
        static inline void write (Register reg, uint32 val)
        {
            *reinterpret_cast<uint32 volatile *>(CPU_LOCAL_APIC + (reg << 4)) = val;
c0005f39:	c7 05 80 e3 ff cf 00 	movl   $0x0,0xcfffe380
c0005f40:	00 00 00 
    }

    write (LAPIC_TMR_ICR, 0);

    trace (TRACE_APIC, "APIC:%#lx ID:%#x VER:%#x LVT:%#x (%s Mode)", apic_base & ~PAGE_MASK, id(), version(), lvt_max(), freq_bus ? "OS" : "DL");
}
c0005f43:	58                   	pop    %eax
c0005f44:	5b                   	pop    %ebx
c0005f45:	5e                   	pop    %esi
c0005f46:	5f                   	pop    %edi
c0005f47:	c3                   	ret    

c0005f48 <lvt_vector>:

    Rcu::update();
}

void Lapic::lvt_vector (unsigned vector)
{
c0005f48:	56                   	push   %esi
    unsigned lvt = vector - VEC_LVT;

    switch (vector) {
c0005f49:	3d a0 00 00 00       	cmp    $0xa0,%eax

    Rcu::update();
}

void Lapic::lvt_vector (unsigned vector)
{
c0005f4e:	53                   	push   %ebx
c0005f4f:	89 c3                	mov    %eax,%ebx
    unsigned lvt = vector - VEC_LVT;
c0005f51:	8d b0 60 ff ff ff    	lea    -0xa0(%eax),%esi

    switch (vector) {
c0005f57:	74 1d                	je     c0005f76 <lvt_vector+0x2e>
c0005f59:	3d a3 00 00 00       	cmp    $0xa3,%eax
c0005f5e:	75 42                	jne    c0005fa2 <lvt_vector+0x5a>
c0005f60:	c7 05 80 e2 ff cf 00 	movl   $0x0,0xcfffe280
c0005f67:	00 00 00 
c0005f6a:	c7 05 80 e2 ff cf 00 	movl   $0x0,0xcfffe280
c0005f71:	00 00 00 
c0005f74:	eb 2c                	jmp    c0005fa2 <lvt_vector+0x5a>
    write (LAPIC_ESR, 0);
}

void Lapic::timer_handler()
{
    bool expired = (freq_bus ? read (LAPIC_TMR_CCR) : Msr::read<uint64>(Msr::IA32_TSC_DEADLINE)) == 0;
c0005f76:	83 3d 74 b0 01 c0 00 	cmpl   $0x0,0xc001b074
c0005f7d:	74 09                	je     c0005f88 <lvt_vector+0x40>
        };

        ALWAYS_INLINE
        static inline uint32 read (Register reg)
        {
            return *reinterpret_cast<uint32 volatile *>(CPU_LOCAL_APIC + (reg << 4));
c0005f7f:	a1 90 e3 ff cf       	mov    0xcfffe390,%eax
c0005f84:	85 c0                	test   %eax,%eax
c0005f86:	eb 09                	jmp    c0005f91 <lvt_vector+0x49>
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
c0005f88:	b9 e0 06 00 00       	mov    $0x6e0,%ecx
c0005f8d:	0f 32                	rdmsr  
c0005f8f:	09 d0                	or     %edx,%eax
c0005f91:	0f 94 c0             	sete   %al
    if (expired)
c0005f94:	84 c0                	test   %al,%al
c0005f96:	74 05                	je     c0005f9d <lvt_vector+0x55>
        Timeout::check();
c0005f98:	e8 a3 e3 00 00       	call   c0014340 <_ZN7Timeout5checkEv>

    Rcu::update();
c0005f9d:	e8 fe 82 00 00       	call   c000e2a0 <_ZN3Rcu6updateEv>
        }

        ALWAYS_INLINE
        static inline void write (Register reg, uint32 val)
        {
            *reinterpret_cast<uint32 volatile *>(CPU_LOCAL_APIC + (reg << 4)) = val;
c0005fa2:	c7 05 b0 e0 ff cf 00 	movl   $0x0,0xcfffe0b0
c0005fa9:	00 00 00 
        case VEC_LVT_THERM: therm_handler(); break;
    }

    eoi();

    Counter::print<1,16> (++Counter::lvt[lvt], Console_vga::COLOR_LIGHT_BLUE, lvt + SPN_LVT);
c0005fac:	8b 04 b5 c0 f6 ff cf 	mov    -0x30000940(,%esi,4),%eax
c0005fb3:	40                   	inc    %eax
        }

        template <unsigned D, unsigned B>
        static void print (mword val, Console_vga::Color c, unsigned col)
        {
            if (EXPECT_FALSE (Cpu::row))
c0005fb4:	83 3d 50 f7 ff cf 00 	cmpl   $0x0,0xcffff750
c0005fbb:	89 04 b5 c0 f6 ff cf 	mov    %eax,-0x30000940(,%esi,4)
c0005fc2:	74 12                	je     c0005fd6 <lvt_vector+0x8e>
c0005fc4:	8d 8b 67 ff ff ff    	lea    -0x99(%ebx),%ecx
c0005fca:	ba 09 00 00 00       	mov    $0x9,%edx
}
c0005fcf:	5b                   	pop    %ebx
c0005fd0:	5e                   	pop    %esi
c0005fd1:	e9 56 fd ff ff       	jmp    c0005d2c <_ZN7Counter5printILj1ELj16EEEvmN11Console_vga5ColorEj.part.4>
c0005fd6:	5b                   	pop    %ebx
c0005fd7:	5e                   	pop    %esi
c0005fd8:	c3                   	ret    
c0005fd9:	90                   	nop

c0005fda <ipi_vector>:

void Lapic::ipi_vector (unsigned vector)
{
c0005fda:	56                   	push   %esi
    unsigned ipi = vector - VEC_IPI;

    switch (vector) {
c0005fdb:	3d a8 00 00 00       	cmp    $0xa8,%eax

    Counter::print<1,16> (++Counter::lvt[lvt], Console_vga::COLOR_LIGHT_BLUE, lvt + SPN_LVT);
}

void Lapic::ipi_vector (unsigned vector)
{
c0005fe0:	53                   	push   %ebx
c0005fe1:	89 c3                	mov    %eax,%ebx
    unsigned ipi = vector - VEC_IPI;
c0005fe3:	8d b0 59 ff ff ff    	lea    -0xa7(%eax),%esi

    switch (vector) {
c0005fe9:	74 15                	je     c0006000 <ipi_vector+0x26>
c0005feb:	3d a9 00 00 00       	cmp    $0xa9,%eax
c0005ff0:	74 15                	je     c0006007 <ipi_vector+0x2d>
c0005ff2:	3d a7 00 00 00       	cmp    $0xa7,%eax
c0005ff7:	75 13                	jne    c000600c <ipi_vector+0x32>
        case VEC_IPI_RRQ: Sc::rrq_handler(); break;
c0005ff9:	e8 60 98 00 00       	call   c000f85e <_ZN2Sc11rrq_handlerEv>
c0005ffe:	eb 0c                	jmp    c000600c <ipi_vector+0x32>
        case VEC_IPI_RKE: Sc::rke_handler(); break;
c0006000:	e8 23 99 00 00       	call   c000f928 <_ZN2Sc11rke_handlerEv>
c0006005:	eb 05                	jmp    c000600c <ipi_vector+0x32>
        case VEC_IPI_IDL: Ec::idl_handler(); break;
c0006007:	e8 1e e4 ff ff       	call   c000442a <_ZN2Ec11idl_handlerEv>
c000600c:	c7 05 b0 e0 ff cf 00 	movl   $0x0,0xcfffe0b0
c0006013:	00 00 00 
    }

    eoi();

    Counter::print<1,16> (++Counter::ipi[ipi], Console_vga::COLOR_LIGHT_GREEN, ipi + SPN_IPI);
c0006016:	8b 04 b5 d8 f6 ff cf 	mov    -0x30000928(,%esi,4),%eax
c000601d:	40                   	inc    %eax
c000601e:	83 3d 50 f7 ff cf 00 	cmpl   $0x0,0xcffff750
c0006025:	89 04 b5 d8 f6 ff cf 	mov    %eax,-0x30000928(,%esi,4)
c000602c:	74 12                	je     c0006040 <ipi_vector+0x66>
c000602e:	8d 8b 66 ff ff ff    	lea    -0x9a(%ebx),%ecx
c0006034:	ba 0a 00 00 00       	mov    $0xa,%edx
}
c0006039:	5b                   	pop    %ebx
c000603a:	5e                   	pop    %esi
c000603b:	e9 ec fc ff ff       	jmp    c0005d2c <_ZN7Counter5printILj1ELj16EEEvmN11Console_vga5ColorEj.part.4>
c0006040:	5b                   	pop    %ebx
c0006041:	5e                   	pop    %esi
c0006042:	c3                   	ret    
c0006043:	90                   	nop

c0006044 <_ZN3Mca4initEv>:
        static void init();

        ALWAYS_INLINE
        static inline bool feature (Feature f)
        {
            return features[f / 32] & 1U << f % 32;
c0006044:	8b 15 04 f7 ff cf    	mov    0xcffff704,%edx

unsigned Mca::banks;

void Mca::init()
{
    if (EXPECT_FALSE (!Cpu::feature (Cpu::FEAT_MCE)))
c000604a:	f6 c2 80             	test   $0x80,%dl
c000604d:	0f 84 97 00 00 00    	je     c00060ea <_ZN3Mca4initEv+0xa6>

ALWAYS_INLINE
static inline mword get_cr4()
{
    mword cr4;
    asm volatile ("mov %%cr4, %0" : "=r" (cr4));
c0006053:	0f 20 e0             	mov    %cr4,%eax
        return;

    set_cr4 (get_cr4() | Cpu::CR4_MCE);
c0006056:	83 c8 40             	or     $0x40,%eax
}

ALWAYS_INLINE
static inline void set_cr4 (mword cr4)
{
    asm volatile ("mov %0, %%cr4" : : "r" (cr4));
c0006059:	0f 22 e0             	mov    %eax,%cr4

    if (EXPECT_FALSE (!Cpu::feature (Cpu::FEAT_MCA)))
c000605c:	f6 c6 40             	test   $0x40,%dh
c000605f:	0f 84 85 00 00 00    	je     c00060ea <_ZN3Mca4initEv+0xa6>
#include "x86.hpp"

unsigned Mca::banks;

void Mca::init()
{
c0006065:	55                   	push   %ebp
c0006066:	b9 79 01 00 00       	mov    $0x179,%ecx
c000606b:	57                   	push   %edi
c000606c:	56                   	push   %esi
c000606d:	53                   	push   %ebx
c000606e:	52                   	push   %edx
c000606f:	0f 32                	rdmsr  
c0006071:	89 04 24             	mov    %eax,(%esp)

        template <typename T>
        ALWAYS_INLINE
        static inline void write (Register msr, T val)
        {
            asm volatile ("wrmsr" : : "a" (static_cast<mword>(val)), "d" (static_cast<mword>(static_cast<uint64>(val) >> 32)), "c" (msr));
c0006074:	31 c0                	xor    %eax,%eax
c0006076:	b1 7a                	mov    $0x7a,%cl
c0006078:	89 c2                	mov    %eax,%edx
c000607a:	0f 30                	wrmsr  

    uint32 cap = Msr::read<uint32>(Msr::IA32_MCG_CAP);

    Msr::write<uint32>(Msr::IA32_MCG_STATUS, 0);

    if (cap & 0x100)
c000607c:	f7 04 24 00 01 00 00 	testl  $0x100,(%esp)
c0006083:	74 09                	je     c000608e <_ZN3Mca4initEv+0x4a>
c0006085:	83 c8 ff             	or     $0xffffffff,%eax
c0006088:	b1 7b                	mov    $0x7b,%cl
c000608a:	89 c2                	mov    %eax,%edx
c000608c:	0f 30                	wrmsr  
        Msr::write<uint64>(Msr::IA32_MCG_CTL, ~0ULL);

    banks = cap & 0xff;
c000608e:	0f b6 3c 24          	movzbl (%esp),%edi

    for (unsigned i = (Cpu::vendor == Cpu::INTEL && Cpu::family == 6 && Cpu::model < 0x1a); i < banks; i++) {
c0006092:	31 db                	xor    %ebx,%ebx
c0006094:	83 3d 6c f7 ff cf 01 	cmpl   $0x1,0xcffff76c
    Msr::write<uint32>(Msr::IA32_MCG_STATUS, 0);

    if (cap & 0x100)
        Msr::write<uint64>(Msr::IA32_MCG_CTL, ~0ULL);

    banks = cap & 0xff;
c000609b:	89 3d d0 f7 ff cf    	mov    %edi,0xcffff7d0

    for (unsigned i = (Cpu::vendor == Cpu::INTEL && Cpu::family == 6 && Cpu::model < 0x1a); i < banks; i++) {
c00060a1:	75 13                	jne    c00060b6 <_ZN3Mca4initEv+0x72>
c00060a3:	83 3d 64 f7 ff cf 06 	cmpl   $0x6,0xcffff764
c00060aa:	75 0a                	jne    c00060b6 <_ZN3Mca4initEv+0x72>
c00060ac:	83 3d 60 f7 ff cf 19 	cmpl   $0x19,0xcffff760
c00060b3:	0f 96 c3             	setbe  %bl
c00060b6:	0f b6 db             	movzbl %bl,%ebx
c00060b9:	31 ed                	xor    %ebp,%ebp
c00060bb:	8d 34 9d 00 00 00 00 	lea    0x0(,%ebx,4),%esi
c00060c2:	81 c6 01 04 00 00    	add    $0x401,%esi
c00060c8:	39 fb                	cmp    %edi,%ebx
c00060ca:	73 19                	jae    c00060e5 <_ZN3Mca4initEv+0xa1>
        Msr::write<uint64>(Msr::Register (4 * i + Msr::IA32_MCI_CTL), ~0ULL);
c00060cc:	8d 4e ff             	lea    -0x1(%esi),%ecx
c00060cf:	83 c8 ff             	or     $0xffffffff,%eax
c00060d2:	83 ca ff             	or     $0xffffffff,%edx
c00060d5:	0f 30                	wrmsr  
c00060d7:	89 e8                	mov    %ebp,%eax
c00060d9:	89 ea                	mov    %ebp,%edx
c00060db:	89 f1                	mov    %esi,%ecx
c00060dd:	0f 30                	wrmsr  
    if (cap & 0x100)
        Msr::write<uint64>(Msr::IA32_MCG_CTL, ~0ULL);

    banks = cap & 0xff;

    for (unsigned i = (Cpu::vendor == Cpu::INTEL && Cpu::family == 6 && Cpu::model < 0x1a); i < banks; i++) {
c00060df:	43                   	inc    %ebx
c00060e0:	83 c6 04             	add    $0x4,%esi
c00060e3:	eb e3                	jmp    c00060c8 <_ZN3Mca4initEv+0x84>
        Msr::write<uint64>(Msr::Register (4 * i + Msr::IA32_MCI_CTL), ~0ULL);
        Msr::write<uint64>(Msr::Register (4 * i + Msr::IA32_MCI_STATUS), 0);
    }
}
c00060e5:	58                   	pop    %eax
c00060e6:	5b                   	pop    %ebx
c00060e7:	5e                   	pop    %esi
c00060e8:	5f                   	pop    %edi
c00060e9:	5d                   	pop    %ebp
c00060ea:	c3                   	ret    
c00060eb:	90                   	nop

c00060ec <_ZN3Mca6vectorEv>:

void Mca::vector()
{
c00060ec:	55                   	push   %ebp
c00060ed:	57                   	push   %edi
c00060ee:	56                   	push   %esi
c00060ef:	53                   	push   %ebx
    uint64 sts;

    for (unsigned i = 0; i < banks; i++)
c00060f0:	31 db                	xor    %ebx,%ebx
        Msr::write<uint64>(Msr::Register (4 * i + Msr::IA32_MCI_STATUS), 0);
    }
}

void Mca::vector()
{
c00060f2:	52                   	push   %edx
    uint64 sts;

    for (unsigned i = 0; i < banks; i++)
        if ((sts = Msr::read<uint64>(Msr::Register (4 * i + Msr::IA32_MCI_STATUS))) & 1ULL << 63)
            trace (TRACE_ERROR, "Machine Check B%u: %#018llx", i, sts);
c00060f3:	8d 6c 24 ff          	lea    -0x1(%esp),%ebp
c00060f7:	81 e5 00 f0 ff ff    	and    $0xfffff000,%ebp

void Mca::vector()
{
    uint64 sts;

    for (unsigned i = 0; i < banks; i++)
c00060fd:	3b 1d d0 f7 ff cf    	cmp    0xcffff7d0,%ebx
c0006103:	73 35                	jae    c000613a <_ZN3Mca6vectorEv+0x4e>
c0006105:	8d 0c 9d 01 04 00 00 	lea    0x401(,%ebx,4),%ecx
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
            return static_cast<T>(static_cast<uint64>(h) << 32 | l);
c000610c:	0f 32                	rdmsr  
        if ((sts = Msr::read<uint64>(Msr::Register (4 * i + Msr::IA32_MCI_STATUS))) & 1ULL << 63)
c000610e:	85 d2                	test   %edx,%edx
c0006110:	89 c6                	mov    %eax,%esi
c0006112:	79 23                	jns    c0006137 <_ZN3Mca6vectorEv+0x4b>
            trace (TRACE_ERROR, "Machine Check B%u: %#018llx", i, sts);
c0006114:	81 fd 00 d0 ff cf    	cmp    $0xcfffd000,%ebp
c000611a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000611f:	52                   	push   %edx
c0006120:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0006127:	56                   	push   %esi
c0006128:	53                   	push   %ebx
c0006129:	50                   	push   %eax
c000612a:	68 1c 72 01 c0       	push   $0xc001721c
c000612f:	e8 aa b8 ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c0006134:	83 c4 14             	add    $0x14,%esp

void Mca::vector()
{
    uint64 sts;

    for (unsigned i = 0; i < banks; i++)
c0006137:	43                   	inc    %ebx
c0006138:	eb c3                	jmp    c00060fd <_ZN3Mca6vectorEv+0x11>
        if ((sts = Msr::read<uint64>(Msr::Register (4 * i + Msr::IA32_MCI_STATUS))) & 1ULL << 63)
            trace (TRACE_ERROR, "Machine Check B%u: %#018llx", i, sts);
}
c000613a:	58                   	pop    %eax
c000613b:	5b                   	pop    %ebx
c000613c:	5e                   	pop    %esi
c000613d:	5f                   	pop    %edi
c000613e:	5d                   	pop    %ebp
c000613f:	c3                   	ret    

c0006140 <_ZN3Mdb11insert_nodeEPS_m>:
Slab_cache Mdb::cache (sizeof (Mdb), 16);

Spinlock Mdb::lock;

bool Mdb::insert_node (Mdb *p, mword a)
{
c0006140:	55                   	push   %ebp
c0006141:	89 cd                	mov    %ecx,%ebp
c0006143:	57                   	push   %edi
c0006144:	89 c7                	mov    %eax,%edi
c0006146:	56                   	push   %esi
c0006147:	89 d6                	mov    %edx,%esi
c0006149:	53                   	push   %ebx

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c000614a:	9c                   	pushf  
c000614b:	5b                   	pop    %ebx
            return flags & 0x200;
c000614c:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c000614f:	80 e3 01             	and    $0x1,%bl
c0006152:	74 27                	je     c000617b <_ZN3Mdb11insert_nodeEPS_m+0x3b>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0006154:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000615b:	75 16                	jne    c0006173 <_ZN3Mdb11insert_nodeEPS_m+0x33>
c000615d:	68 80 72 01 c0       	push   $0xc0017280
c0006162:	68 b7 00 00 00       	push   $0xb7
c0006167:	68 12 61 01 c0       	push   $0xc0016112
c000616c:	68 83 61 01 c0       	push   $0xc0016183
c0006171:	eb 79                	jmp    c00061ec <_ZN3Mdb11insert_nodeEPS_m+0xac>

            asm volatile ("cli" : : : "memory");
c0006173:	fa                   	cli    
            preemption = false;
c0006174:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c000617b:	b8 7c b0 01 c0       	mov    $0xc001b07c,%eax
c0006180:	e8 a7 a9 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
{
    private:
        static Slab_cache   cache;
        static Spinlock     lock;

        bool alive() const { return prev->next == this && next->prev == this; }
c0006185:	8b 46 1c             	mov    0x1c(%esi),%eax
c0006188:	39 70 20             	cmp    %esi,0x20(%eax)
c000618b:	74 04                	je     c0006191 <_ZN3Mdb11insert_nodeEPS_m+0x51>
    Lock_guard <Spinlock> guard (lock);

    if (!p->alive())
        return false;
c000618d:	31 c0                	xor    %eax,%eax
c000618f:	eb 34                	jmp    c00061c5 <_ZN3Mdb11insert_nodeEPS_m+0x85>
c0006191:	8b 46 20             	mov    0x20(%esi),%eax
c0006194:	39 70 1c             	cmp    %esi,0x1c(%eax)
c0006197:	75 f4                	jne    c000618d <_ZN3Mdb11insert_nodeEPS_m+0x4d>

    if (!(node_attr = p->node_attr & a))
c0006199:	8b 4e 38             	mov    0x38(%esi),%ecx
c000619c:	21 e9                	and    %ebp,%ecx
c000619e:	85 c9                	test   %ecx,%ecx
c00061a0:	89 4f 38             	mov    %ecx,0x38(%edi)
c00061a3:	74 e8                	je     c000618d <_ZN3Mdb11insert_nodeEPS_m+0x4d>
        return false;

    prev = prnt = p;
c00061a5:	89 77 24             	mov    %esi,0x24(%edi)
c00061a8:	89 77 1c             	mov    %esi,0x1c(%edi)
    next = p->next;
c00061ab:	8b 46 20             	mov    0x20(%esi),%eax
c00061ae:	89 47 20             	mov    %eax,0x20(%edi)
    dpth = static_cast<uint16>(p->dpth + 1);
c00061b1:	66 8b 46 1a          	mov    0x1a(%esi),%ax
c00061b5:	40                   	inc    %eax
c00061b6:	66 89 47 1a          	mov    %ax,0x1a(%edi)
    p->next = p->next->prev = this;
c00061ba:	8b 46 20             	mov    0x20(%esi),%eax
c00061bd:	89 78 1c             	mov    %edi,0x1c(%eax)

    return true;
c00061c0:	b0 01                	mov    $0x1,%al
        return false;

    prev = prnt = p;
    next = p->next;
    dpth = static_cast<uint16>(p->dpth + 1);
    p->next = p->next->prev = this;
c00061c2:	89 7e 20             	mov    %edi,0x20(%esi)
c00061c5:	fe 05 7c b0 01 c0    	incb   0xc001b07c
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c00061cb:	84 db                	test   %bl,%bl
c00061cd:	74 2f                	je     c00061fe <_ZN3Mdb11insert_nodeEPS_m+0xbe>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c00061cf:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c00061d6:	74 1e                	je     c00061f6 <_ZN3Mdb11insert_nodeEPS_m+0xb6>
c00061d8:	68 40 72 01 c0       	push   $0xc0017240
c00061dd:	68 c0 00 00 00       	push   $0xc0
c00061e2:	68 12 61 01 c0       	push   $0xc0016112
c00061e7:	68 82 61 01 c0       	push   $0xc0016182
c00061ec:	68 69 60 01 c0       	push   $0xc0016069
c00061f1:	e8 50 b7 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

            preemption = true;
c00061f6:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c00061fd:	fb                   	sti    

    return true;
}
c00061fe:	5b                   	pop    %ebx
c00061ff:	5e                   	pop    %esi
c0006200:	5f                   	pop    %edi
c0006201:	5d                   	pop    %ebp
c0006202:	c3                   	ret    
c0006203:	90                   	nop

c0006204 <_ZN3Mdb11demote_nodeEm>:

void Mdb::demote_node (mword a)
{
c0006204:	57                   	push   %edi
c0006205:	89 c7                	mov    %eax,%edi
c0006207:	56                   	push   %esi
c0006208:	89 d6                	mov    %edx,%esi
c000620a:	53                   	push   %ebx

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c000620b:	9c                   	pushf  
c000620c:	59                   	pop    %ecx
            return flags & 0x200;
c000620d:	c1 e9 09             	shr    $0x9,%ecx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c0006210:	88 cb                	mov    %cl,%bl
c0006212:	80 e3 01             	and    $0x1,%bl
c0006215:	74 27                	je     c000623e <_ZN3Mdb11demote_nodeEm+0x3a>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0006217:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000621e:	75 16                	jne    c0006236 <_ZN3Mdb11demote_nodeEm+0x32>
c0006220:	68 80 72 01 c0       	push   $0xc0017280
c0006225:	68 b7 00 00 00       	push   $0xb7
c000622a:	68 12 61 01 c0       	push   $0xc0016112
c000622f:	68 83 61 01 c0       	push   $0xc0016183
c0006234:	eb 3e                	jmp    c0006274 <_ZN3Mdb11demote_nodeEm+0x70>

            asm volatile ("cli" : : : "memory");
c0006236:	fa                   	cli    
            preemption = false;
c0006237:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c000623e:	b8 7c b0 01 c0       	mov    $0xc001b07c,%eax
    Lock_guard <Spinlock> guard (lock);

    node_attr &= ~a;
c0006243:	f7 d6                	not    %esi
c0006245:	e8 e2 a8 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
c000624a:	21 77 38             	and    %esi,0x38(%edi)
c000624d:	fe 05 7c b0 01 c0    	incb   0xc001b07c
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c0006253:	84 db                	test   %bl,%bl
c0006255:	74 2f                	je     c0006286 <_ZN3Mdb11demote_nodeEm+0x82>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0006257:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000625e:	74 1e                	je     c000627e <_ZN3Mdb11demote_nodeEm+0x7a>
c0006260:	68 40 72 01 c0       	push   $0xc0017240
c0006265:	68 c0 00 00 00       	push   $0xc0
c000626a:	68 12 61 01 c0       	push   $0xc0016112
c000626f:	68 82 61 01 c0       	push   $0xc0016182
c0006274:	68 69 60 01 c0       	push   $0xc0016069
c0006279:	e8 c8 b6 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

            preemption = true;
c000627e:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c0006285:	fb                   	sti    
}
c0006286:	5b                   	pop    %ebx
c0006287:	5e                   	pop    %esi
c0006288:	5f                   	pop    %edi
c0006289:	c3                   	ret    

c000628a <_ZN3Mdb11remove_nodeEv>:

bool Mdb::remove_node()
{
    if (node_attr)
c000628a:	83 78 38 00          	cmpl   $0x0,0x38(%eax)
c000628e:	0f 85 ad 00 00 00    	jne    c0006341 <_ZN3Mdb11remove_nodeEv+0xb7>

    node_attr &= ~a;
}

bool Mdb::remove_node()
{
c0006294:	57                   	push   %edi
c0006295:	56                   	push   %esi
c0006296:	89 c6                	mov    %eax,%esi
c0006298:	53                   	push   %ebx

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c0006299:	9c                   	pushf  
c000629a:	5b                   	pop    %ebx
            return flags & 0x200;
c000629b:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c000629e:	80 e3 01             	and    $0x1,%bl
c00062a1:	74 2f                	je     c00062d2 <_ZN3Mdb11remove_nodeEv+0x48>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c00062a3:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c00062aa:	75 1e                	jne    c00062ca <_ZN3Mdb11remove_nodeEv+0x40>
c00062ac:	68 80 72 01 c0       	push   $0xc0017280
c00062b1:	68 b7 00 00 00       	push   $0xb7
c00062b6:	68 12 61 01 c0       	push   $0xc0016112
c00062bb:	68 83 61 01 c0       	push   $0xc0016183
c00062c0:	68 69 60 01 c0       	push   $0xc0016069
c00062c5:	e8 7c b6 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

            asm volatile ("cli" : : : "memory");
c00062ca:	fa                   	cli    
            preemption = false;
c00062cb:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c00062d2:	b8 7c b0 01 c0       	mov    $0xc001b07c,%eax
c00062d7:	e8 50 a8 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
c00062dc:	8b 4e 1c             	mov    0x1c(%esi),%ecx
        return false;

    Lock_guard <Spinlock> guard (lock);

    if (!alive())
        return false;
c00062df:	31 c0                	xor    %eax,%eax
c00062e1:	39 71 20             	cmp    %esi,0x20(%ecx)
c00062e4:	75 20                	jne    c0006306 <_ZN3Mdb11remove_nodeEv+0x7c>
c00062e6:	8b 56 20             	mov    0x20(%esi),%edx
c00062e9:	39 72 1c             	cmp    %esi,0x1c(%edx)
c00062ec:	75 18                	jne    c0006306 <_ZN3Mdb11remove_nodeEv+0x7c>

    if (next->dpth > dpth)
c00062ee:	66 8b 7a 1a          	mov    0x1a(%edx),%di
c00062f2:	66 39 7e 1a          	cmp    %di,0x1a(%esi)
c00062f6:	72 0e                	jb     c0006306 <_ZN3Mdb11remove_nodeEv+0x7c>
        return false;

    next->prev = prev;
c00062f8:	89 4a 1c             	mov    %ecx,0x1c(%edx)
    prev->next = next;
c00062fb:	8b 46 1c             	mov    0x1c(%esi),%eax
c00062fe:	8b 56 20             	mov    0x20(%esi),%edx
c0006301:	89 50 20             	mov    %edx,0x20(%eax)

    return true;
c0006304:	b0 01                	mov    $0x1,%al
c0006306:	fe 05 7c b0 01 c0    	incb   0xc001b07c
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c000630c:	84 db                	test   %bl,%bl
c000630e:	74 34                	je     c0006344 <_ZN3Mdb11remove_nodeEv+0xba>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0006310:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0006317:	74 1e                	je     c0006337 <_ZN3Mdb11remove_nodeEv+0xad>
c0006319:	68 40 72 01 c0       	push   $0xc0017240
c000631e:	68 c0 00 00 00       	push   $0xc0
c0006323:	68 12 61 01 c0       	push   $0xc0016112
c0006328:	68 82 61 01 c0       	push   $0xc0016182
c000632d:	68 69 60 01 c0       	push   $0xc0016069
c0006332:	e8 0f b6 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

            preemption = true;
c0006337:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000633e:	fb                   	sti    
c000633f:	eb 03                	jmp    c0006344 <_ZN3Mdb11remove_nodeEv+0xba>
}

bool Mdb::remove_node()
{
    if (node_attr)
        return false;
c0006341:	31 c0                	xor    %eax,%eax

    next->prev = prev;
    prev->next = next;

    return true;
}
c0006343:	c3                   	ret    
c0006344:	5b                   	pop    %ebx
c0006345:	5e                   	pop    %esi
c0006346:	5f                   	pop    %edi
c0006347:	c3                   	ret    

c0006348 <_GLOBAL__sub_I.00102__ZN3Mdb5cacheE>:
#include "assert.hpp"
#include "lock_guard.hpp"
#include "mdb.hpp"

INIT_PRIORITY (PRIO_SLAB)
Slab_cache Mdb::cache (sizeof (Mdb), 16);
c0006348:	b9 10 00 00 00       	mov    $0x10,%ecx
c000634d:	ba 44 00 00 00       	mov    $0x44,%edx
c0006352:	b8 80 b0 01 c0       	mov    $0xc001b080,%eax
c0006357:	e9 aa 9e 00 00       	jmp    c0010206 <_ZN10Slab_cacheC1Emj>

c000635c <_GLOBAL__sub_I__ZN3Mdb5cacheE>:
    private:
        uint16 val;

    public:
        ALWAYS_INLINE
        inline Spinlock() : val (0) {}
c000635c:	66 c7 05 7c b0 01 c0 	movw   $0x0,0xc001b07c
c0006363:	00 00 
c0006365:	c3                   	ret    

c0006366 <_GLOBAL__sub_I.00102__ZN4Mtrr5countE>:
unsigned Mtrr::count;
unsigned Mtrr::dtype;
Mtrr *   Mtrr::list;

INIT_PRIORITY (PRIO_SLAB)
Slab_cache Mtrr::cache (sizeof (Mtrr), 8);
c0006366:	b9 08 00 00 00       	mov    $0x8,%ecx
c000636b:	ba 14 00 00 00       	mov    $0x14,%edx
c0006370:	b8 98 b0 01 c0       	mov    $0xc001b098,%eax
c0006375:	e9 8c 9e 00 00       	jmp    c0010206 <_ZN10Slab_cacheC1Emj>

c000637a <_ZN2ScD1Ev>:

#include "compiler.hpp"

class Ec;

class Sc : public Kobject, public Refex<~0U>
c000637a:	89 c2                	mov    %eax,%edx
        inline Refptr (T *p) : ptr (p->add_ref() ? p : nullptr) {}

        ALWAYS_INLINE
        inline ~Refptr()
        {
            if (ptr && ptr->del_ref())
c000637c:	8b 40 4c             	mov    0x4c(%eax),%eax
c000637f:	85 c0                	test   %eax,%eax
c0006381:	74 35                	je     c00063b8 <_ZN2ScD1Ev+0x3e>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c0006383:	83 c9 ff             	or     $0xffffffff,%ecx
c0006386:	f0 0f c1 48 48       	lock xadd %ecx,0x48(%eax)
c000638b:	49                   	dec    %ecx
c000638c:	74 01                	je     c000638f <_ZN2ScD1Ev+0x15>
c000638e:	c3                   	ret    
                delete ptr;
c000638f:	8b 42 4c             	mov    0x4c(%edx),%eax
c0006392:	85 c0                	test   %eax,%eax
c0006394:	74 22                	je     c00063b8 <_ZN2ScD1Ev+0x3e>
c0006396:	53                   	push   %ebx
c0006397:	89 d3                	mov    %edx,%ebx
c0006399:	e8 70 d1 ff ff       	call   c000350e <_ZN2EcD1Ev>
c000639e:	8b 53 4c             	mov    0x4c(%ebx),%edx
c00063a1:	5b                   	pop    %ebx
c00063a2:	8b 82 b8 00 00 00    	mov    0xb8(%edx),%eax
c00063a8:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c00063ae:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c00063b3:	e9 a8 9f 00 00       	jmp    c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
c00063b8:	c3                   	ret    
c00063b9:	90                   	nop

c00063ba <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv>:

    die ("XCPU OOM error");
}

template <void (*C)()>
void Ec::oom_xcpu_return()
c00063ba:	57                   	push   %edi
c00063bb:	56                   	push   %esi
c00063bc:	53                   	push   %ebx
c00063bd:	56                   	push   %esi
{
    assert (current->xcpu_sm);
c00063be:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c00063c3:	8b b8 f4 00 00 00    	mov    0xf4(%eax),%edi
c00063c9:	85 ff                	test   %edi,%edi
c00063cb:	75 16                	jne    c00063e3 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x29>
c00063cd:	68 20 86 01 c0       	push   $0xc0018620
c00063d2:	68 87 00 00 00       	push   $0x87
c00063d7:	68 a3 72 01 c0       	push   $0xc00172a3
c00063dc:	68 66 6c 01 c0       	push   $0xc0016c66
c00063e1:	eb 1d                	jmp    c0006400 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x46>
    assert (current->rcap);
c00063e3:	83 b8 b0 00 00 00 00 	cmpl   $0x0,0xb0(%eax)
c00063ea:	75 1e                	jne    c000640a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x50>
c00063ec:	68 20 86 01 c0       	push   $0xc0018620
c00063f1:	68 88 00 00 00       	push   $0x88
c00063f6:	68 a3 72 01 c0       	push   $0xc00172a3
c00063fb:	68 77 6c 01 c0       	push   $0xc0016c77
c0006400:	68 69 60 01 c0       	push   $0xc0016069
c0006405:	e8 3c b5 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>
    assert (current->utcb);
c000640a:	83 b8 b4 00 00 00 00 	cmpl   $0x0,0xb4(%eax)
c0006411:	75 16                	jne    c0006429 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x6f>
c0006413:	68 20 86 01 c0       	push   $0xc0018620
c0006418:	68 89 00 00 00       	push   $0x89
c000641d:	68 a3 72 01 c0       	push   $0xc00172a3
c0006422:	68 85 6c 01 c0       	push   $0xc0016c85
c0006427:	eb d7                	jmp    c0006400 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x46>
{
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
c0006429:	8b 15 10 f0 ff cf    	mov    0xcffff010,%edx
    assert (Sc::current->ec == current);
c000642f:	39 42 4c             	cmp    %eax,0x4c(%edx)
c0006432:	74 16                	je     c000644a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x90>
c0006434:	68 20 86 01 c0       	push   $0xc0018620
c0006439:	68 8a 00 00 00       	push   $0x8a
c000643e:	68 a3 72 01 c0       	push   $0xc00172a3
c0006443:	68 93 6c 01 c0       	push   $0xc0016c93
c0006448:	eb b6                	jmp    c0006400 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x46>
        ALWAYS_INLINE
        inline void up (void (*c)() = nullptr, Sm * si = nullptr)
        {
            Ec *ec;

            {   Lock_guard <Spinlock> guard (lock);
c000644a:	8d 47 46             	lea    0x46(%edi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c000644d:	9c                   	pushf  
c000644e:	5b                   	pop    %ebx
            return flags & 0x200;
c000644f:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c0006452:	80 e3 01             	and    $0x1,%bl
c0006455:	74 27                	je     c000647e <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0xc4>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0006457:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000645e:	75 16                	jne    c0006476 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0xbc>
c0006460:	68 80 85 01 c0       	push   $0xc0018580
c0006465:	68 b7 00 00 00       	push   $0xb7
c000646a:	68 12 61 01 c0       	push   $0xc0016112
c000646f:	68 83 61 01 c0       	push   $0xc0016183
c0006474:	eb 8a                	jmp    c0006400 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x46>

            asm volatile ("cli" : : : "memory");
c0006476:	fa                   	cli    
            preemption = false;
c0006477:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c000647e:	e8 a9 a6 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c0006483:	8b 77 4c             	mov    0x4c(%edi),%esi
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c0006486:	85 f6                	test   %esi,%esi
c0006488:	0f 84 5d 01 00 00    	je     c00065eb <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x231>
c000648e:	8b 86 c4 00 00 00    	mov    0xc4(%esi),%eax
c0006494:	85 c0                	test   %eax,%eax
c0006496:	0f 84 4f 01 00 00    	je     c00065eb <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x231>
c000649c:	8b 96 c0 00 00 00    	mov    0xc0(%esi),%edx
c00064a2:	85 d2                	test   %edx,%edx
c00064a4:	0f 84 41 01 00 00    	je     c00065eb <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x231>
                return false;

            if (t == t->next)
c00064aa:	39 c6                	cmp    %eax,%esi
c00064ac:	75 09                	jne    c00064b7 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0xfd>
                headptr = nullptr;
c00064ae:	c7 47 4c 00 00 00 00 	movl   $0x0,0x4c(%edi)
c00064b5:	eb 26                	jmp    c00064dd <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x123>

            else {
                t->next->prev = t->prev;
c00064b7:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
                t->prev->next = t->next;
c00064bd:	8b 86 c0 00 00 00    	mov    0xc0(%esi),%eax
c00064c3:	8b 96 c4 00 00 00    	mov    0xc4(%esi),%edx
c00064c9:	89 90 c4 00 00 00    	mov    %edx,0xc4(%eax)
                if (t == headptr)
c00064cf:	3b 77 4c             	cmp    0x4c(%edi),%esi
c00064d2:	75 09                	jne    c00064dd <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x123>
                    headptr = t->next;
c00064d4:	8b 86 c4 00 00 00    	mov    0xc4(%esi),%eax
c00064da:	89 47 4c             	mov    %eax,0x4c(%edi)
            }

            t->next = t->prev = nullptr;
c00064dd:	c7 86 c0 00 00 00 00 	movl   $0x0,0xc0(%esi)
c00064e4:	00 00 00 
c00064e7:	83 c8 ff             	or     $0xffffffff,%eax
c00064ea:	c7 86 c4 00 00 00 00 	movl   $0x0,0xc4(%esi)
c00064f1:	00 00 00 
c00064f4:	f0 0f c1 46 48       	lock xadd %eax,0x48(%esi)

                    counter++;
                    return;
                }

                if (EXPECT_FALSE(ec->del_ref())) {
c00064f9:	48                   	dec    %eax
c00064fa:	75 24                	jne    c0006520 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x166>
                    delete ec;
c00064fc:	89 f0                	mov    %esi,%eax
c00064fe:	e8 0b d0 ff ff       	call   c000350e <_ZN2EcD1Ev>
c0006503:	8b 86 b8 00 00 00    	mov    0xb8(%esi),%eax
c0006509:	89 f2                	mov    %esi,%edx
c000650b:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c0006511:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c0006516:	e8 45 9e 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
c000651b:	e9 63 ff ff ff       	jmp    c0006483 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0xc9>
        }

        ALWAYS_INLINE
        inline void unlock()
        {
            asm volatile ("incb %0" : "=m" (val) : : "memory");
c0006520:	fe 47 46             	incb   0x46(%edi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c0006523:	84 db                	test   %bl,%bl
c0006525:	74 2a                	je     c0006551 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x197>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0006527:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000652e:	74 19                	je     c0006549 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x18f>
c0006530:	68 40 85 01 c0       	push   $0xc0018540
c0006535:	68 c0 00 00 00       	push   $0xc0
c000653a:	68 12 61 01 c0       	push   $0xc0016112
c000653f:	68 82 61 01 c0       	push   $0xc0016182
c0006544:	e9 b7 fe ff ff       	jmp    c0006400 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x46>

            preemption = true;
c0006549:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c0006550:	fb                   	sti    
        }

        ALWAYS_INLINE
        inline void release (void (*c)())
        {
            if (c)
c0006551:	b8 1a 88 00 c0       	mov    $0xc000881a,%eax
c0006556:	85 c0                	test   %eax,%eax
c0006558:	74 03                	je     c000655d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x1a3>
                cont = c;
c000655a:	89 46 50             	mov    %eax,0x50(%esi)

            Lock_guard <Spinlock> guard (lock);
c000655d:	8d 46 46             	lea    0x46(%esi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c0006560:	9c                   	pushf  
c0006561:	5b                   	pop    %ebx
            return flags & 0x200;
c0006562:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c0006565:	80 e3 01             	and    $0x1,%bl
c0006568:	74 15                	je     c000657f <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x1c5>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c000656a:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0006571:	0f 84 e9 fe ff ff    	je     c0006460 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0xa6>

            asm volatile ("cli" : : : "memory");
c0006577:	fa                   	cli    
            preemption = false;
c0006578:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c000657f:	e8 a8 a5 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c0006584:	8b 7e 4c             	mov    0x4c(%esi),%edi
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c0006587:	85 ff                	test   %edi,%edi
c0006589:	74 71                	je     c00065fc <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x242>
c000658b:	8b 47 74             	mov    0x74(%edi),%eax
c000658e:	85 c0                	test   %eax,%eax
c0006590:	74 6a                	je     c00065fc <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x242>
c0006592:	8b 57 70             	mov    0x70(%edi),%edx
c0006595:	85 d2                	test   %edx,%edx
c0006597:	74 63                	je     c00065fc <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x242>
                return false;

            if (t == t->next)
c0006599:	39 c7                	cmp    %eax,%edi
c000659b:	75 09                	jne    c00065a6 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x1ec>
                headptr = nullptr;
c000659d:	c7 46 4c 00 00 00 00 	movl   $0x0,0x4c(%esi)
c00065a4:	eb 17                	jmp    c00065bd <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x203>

            else {
                t->next->prev = t->prev;
c00065a6:	89 50 70             	mov    %edx,0x70(%eax)
                t->prev->next = t->next;
c00065a9:	8b 47 70             	mov    0x70(%edi),%eax
c00065ac:	8b 57 74             	mov    0x74(%edi),%edx
c00065af:	89 50 74             	mov    %edx,0x74(%eax)
                if (t == headptr)
c00065b2:	3b 7e 4c             	cmp    0x4c(%esi),%edi
c00065b5:	75 06                	jne    c00065bd <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x203>
                    headptr = t->next;
c00065b7:	8b 47 74             	mov    0x74(%edi),%eax
c00065ba:	89 46 4c             	mov    %eax,0x4c(%esi)
            }

            t->next = t->prev = nullptr;
c00065bd:	c7 47 70 00 00 00 00 	movl   $0x0,0x70(%edi)
c00065c4:	83 c8 ff             	or     $0xffffffff,%eax
c00065c7:	c7 47 74 00 00 00 00 	movl   $0x0,0x74(%edi)
c00065ce:	f0 0f c1 47 48       	lock xadd %eax,0x48(%edi)

            for (Sc *s; dequeue (s = head()); ) {
                if (EXPECT_FALSE(s->del_ref()) && (this == s->ec)) {
c00065d3:	48                   	dec    %eax
c00065d4:	75 1d                	jne    c00065f3 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x239>
c00065d6:	3b 77 4c             	cmp    0x4c(%edi),%esi
c00065d9:	75 18                	jne    c00065f3 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x239>
                    delete s;
c00065db:	89 f8                	mov    %edi,%eax
c00065dd:	e8 98 fd ff ff       	call   c000637a <_ZN2ScD1Ev>
c00065e2:	89 f8                	mov    %edi,%eax
c00065e4:	e8 5c 93 00 00       	call   c000f945 <_ZN2ScdlEPv>
c00065e9:	eb 99                	jmp    c0006584 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x1ca>
                    if (si) {
                       if (si->queued()) return;
                       Queue<Si>::enqueue(si);
                    }

                    counter++;
c00065eb:	ff 47 64             	incl   0x64(%edi)
c00065ee:	fe 47 46             	incb   0x46(%edi)
c00065f1:	eb 0c                	jmp    c00065ff <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x245>
                    continue;
                }
                s->remote_enqueue();
c00065f3:	89 f8                	mov    %edi,%eax
c00065f5:	e8 42 91 00 00       	call   c000f73c <_ZN2Sc14remote_enqueueEv>
c00065fa:	eb 88                	jmp    c0006584 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x1ca>
c00065fc:	fe 46 46             	incb   0x46(%esi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c00065ff:	84 db                	test   %bl,%bl
c0006601:	74 15                	je     c0006618 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x25e>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0006603:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000660a:	0f 85 20 ff ff ff    	jne    c0006530 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x176>

            preemption = true;
c0006610:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c0006617:	fb                   	sti    

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
c0006618:	8b 1d 08 f0 ff cf    	mov    0xcffff008,%ebx
c000661e:	8b 53 14             	mov    0x14(%ebx),%edx
    current->utcb    = nullptr;
    current->fpu     = nullptr;

    Rcu::call(current);
c0006621:	8d 73 0c             	lea    0xc(%ebx),%esi
    assert (current->utcb);
    assert (Sc::current->ec == current);

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
c0006624:	c7 83 b0 00 00 00 00 	movl   $0x0,0xb0(%ebx)
c000662b:	00 00 00 
    current->utcb    = nullptr;
c000662e:	c7 83 b4 00 00 00 00 	movl   $0x0,0xb4(%ebx)
c0006635:	00 00 00 
    current->fpu     = nullptr;
c0006638:	c7 83 c8 00 00 00 00 	movl   $0x0,0xc8(%ebx)
c000663f:	00 00 00 
c0006642:	85 d2                	test   %edx,%edx
c0006644:	74 04                	je     c000664a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x290>
                e->pre_func(e);
c0006646:	89 f0                	mov    %esi,%eax
c0006648:	ff d2                	call   *%edx
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
c000664a:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
c000664e:	75 09                	jne    c0006659 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x29f>
c0006650:	a1 f0 f7 ff cf       	mov    0xcffff7f0,%eax
c0006655:	39 f0                	cmp    %esi,%eax
c0006657:	75 29                	jne    c0006682 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x2c8>
                trace (0, "warning: rcu element already enqueued");
c0006659:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c000665d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0006662:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c0006667:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000666c:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0006673:	50                   	push   %eax
c0006674:	68 ae 6c 01 c0       	push   $0xc0016cae
c0006679:	e8 60 b3 ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c000667e:	59                   	pop    %ecx
c000667f:	5b                   	pop    %ebx
c0006680:	eb 0e                	jmp    c0006690 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x2d6>
                return;
            }

            count ++;
c0006682:	ff 05 f4 f7 ff cf    	incl   0xcffff7f4

           *tail = e;
c0006688:	89 30                	mov    %esi,(%eax)
            tail = &e->next;
c000668a:	89 35 f0 f7 ff cf    	mov    %esi,0xcffff7f0

    Rcu::call(current);
    Rcu::call(Sc::current);
c0006690:	8b 35 10 f0 ff cf    	mov    0xcffff010,%esi
c0006696:	85 f6                	test   %esi,%esi
c0006698:	74 63                	je     c00066fd <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x343>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
c000669a:	8b 56 14             	mov    0x14(%esi),%edx
c000669d:	8d 5e 0c             	lea    0xc(%esi),%ebx
c00066a0:	85 d2                	test   %edx,%edx
c00066a2:	74 04                	je     c00066a8 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x2ee>
                e->pre_func(e);
c00066a4:	89 d8                	mov    %ebx,%eax
c00066a6:	ff d2                	call   *%edx
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
c00066a8:	83 7e 0c 00          	cmpl   $0x0,0xc(%esi)
c00066ac:	75 09                	jne    c00066b7 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x2fd>
c00066ae:	a1 f0 f7 ff cf       	mov    0xcffff7f0,%eax
c00066b3:	39 d8                	cmp    %ebx,%eax
c00066b5:	75 29                	jne    c00066e0 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x326>
                trace (0, "warning: rcu element already enqueued");
c00066b7:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c00066bb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c00066c0:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c00066c5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00066ca:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c00066d1:	50                   	push   %eax
c00066d2:	68 ae 6c 01 c0       	push   $0xc0016cae
c00066d7:	e8 02 b3 ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c00066dc:	58                   	pop    %eax
c00066dd:	5a                   	pop    %edx
c00066de:	eb 0e                	jmp    c00066ee <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x334>
                return;
            }

            count ++;
c00066e0:	ff 05 f4 f7 ff cf    	incl   0xcffff7f4

           *tail = e;
c00066e6:	89 18                	mov    %ebx,(%eax)
            tail = &e->next;
c00066e8:	89 1d f0 f7 ff cf    	mov    %ebx,0xcffff7f0

    Sc::schedule(true);
c00066ee:	ba 01 00 00 00       	mov    $0x1,%edx
c00066f3:	b8 01 00 00 00       	mov    $0x1,%eax
c00066f8:	e8 b5 92 00 00       	call   c000f9b2 <_ZN2Sc8scheduleEbb>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
c00066fd:	a1 08 00 00 00       	mov    0x8,%eax
c0006702:	0f 0b                	ud2    

c0006704 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv>:

    die ("XCPU OOM error");
}

template <void (*C)()>
void Ec::oom_xcpu_return()
c0006704:	57                   	push   %edi
c0006705:	56                   	push   %esi
c0006706:	53                   	push   %ebx
c0006707:	56                   	push   %esi
{
    assert (current->xcpu_sm);
c0006708:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c000670d:	8b b8 f4 00 00 00    	mov    0xf4(%eax),%edi
c0006713:	85 ff                	test   %edi,%edi
c0006715:	75 16                	jne    c000672d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x29>
c0006717:	68 80 83 01 c0       	push   $0xc0018380
c000671c:	68 87 00 00 00       	push   $0x87
c0006721:	68 a3 72 01 c0       	push   $0xc00172a3
c0006726:	68 66 6c 01 c0       	push   $0xc0016c66
c000672b:	eb 1d                	jmp    c000674a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x46>
    assert (current->rcap);
c000672d:	83 b8 b0 00 00 00 00 	cmpl   $0x0,0xb0(%eax)
c0006734:	75 1e                	jne    c0006754 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x50>
c0006736:	68 80 83 01 c0       	push   $0xc0018380
c000673b:	68 88 00 00 00       	push   $0x88
c0006740:	68 a3 72 01 c0       	push   $0xc00172a3
c0006745:	68 77 6c 01 c0       	push   $0xc0016c77
c000674a:	68 69 60 01 c0       	push   $0xc0016069
c000674f:	e8 f2 b1 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>
    assert (current->utcb);
c0006754:	83 b8 b4 00 00 00 00 	cmpl   $0x0,0xb4(%eax)
c000675b:	75 16                	jne    c0006773 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x6f>
c000675d:	68 80 83 01 c0       	push   $0xc0018380
c0006762:	68 89 00 00 00       	push   $0x89
c0006767:	68 a3 72 01 c0       	push   $0xc00172a3
c000676c:	68 85 6c 01 c0       	push   $0xc0016c85
c0006771:	eb d7                	jmp    c000674a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x46>
c0006773:	8b 15 10 f0 ff cf    	mov    0xcffff010,%edx
    assert (Sc::current->ec == current);
c0006779:	39 42 4c             	cmp    %eax,0x4c(%edx)
c000677c:	74 16                	je     c0006794 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x90>
c000677e:	68 80 83 01 c0       	push   $0xc0018380
c0006783:	68 8a 00 00 00       	push   $0x8a
c0006788:	68 a3 72 01 c0       	push   $0xc00172a3
c000678d:	68 93 6c 01 c0       	push   $0xc0016c93
c0006792:	eb b6                	jmp    c000674a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x46>
        ALWAYS_INLINE
        inline void up (void (*c)() = nullptr, Sm * si = nullptr)
        {
            Ec *ec;

            {   Lock_guard <Spinlock> guard (lock);
c0006794:	8d 47 46             	lea    0x46(%edi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c0006797:	9c                   	pushf  
c0006798:	5b                   	pop    %ebx
            return flags & 0x200;
c0006799:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c000679c:	80 e3 01             	and    $0x1,%bl
c000679f:	74 27                	je     c00067c8 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0xc4>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c00067a1:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c00067a8:	75 16                	jne    c00067c0 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0xbc>
c00067aa:	68 80 85 01 c0       	push   $0xc0018580
c00067af:	68 b7 00 00 00       	push   $0xb7
c00067b4:	68 12 61 01 c0       	push   $0xc0016112
c00067b9:	68 83 61 01 c0       	push   $0xc0016183
c00067be:	eb 8a                	jmp    c000674a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x46>

            asm volatile ("cli" : : : "memory");
c00067c0:	fa                   	cli    
            preemption = false;
c00067c1:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c00067c8:	e8 5f a3 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c00067cd:	8b 77 4c             	mov    0x4c(%edi),%esi
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c00067d0:	85 f6                	test   %esi,%esi
c00067d2:	0f 84 5d 01 00 00    	je     c0006935 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x231>
c00067d8:	8b 86 c4 00 00 00    	mov    0xc4(%esi),%eax
c00067de:	85 c0                	test   %eax,%eax
c00067e0:	0f 84 4f 01 00 00    	je     c0006935 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x231>
c00067e6:	8b 96 c0 00 00 00    	mov    0xc0(%esi),%edx
c00067ec:	85 d2                	test   %edx,%edx
c00067ee:	0f 84 41 01 00 00    	je     c0006935 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x231>
                return false;

            if (t == t->next)
c00067f4:	39 c6                	cmp    %eax,%esi
c00067f6:	75 09                	jne    c0006801 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0xfd>
                headptr = nullptr;
c00067f8:	c7 47 4c 00 00 00 00 	movl   $0x0,0x4c(%edi)
c00067ff:	eb 26                	jmp    c0006827 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x123>

            else {
                t->next->prev = t->prev;
c0006801:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
                t->prev->next = t->next;
c0006807:	8b 86 c0 00 00 00    	mov    0xc0(%esi),%eax
c000680d:	8b 96 c4 00 00 00    	mov    0xc4(%esi),%edx
c0006813:	89 90 c4 00 00 00    	mov    %edx,0xc4(%eax)
                if (t == headptr)
c0006819:	3b 77 4c             	cmp    0x4c(%edi),%esi
c000681c:	75 09                	jne    c0006827 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x123>
                    headptr = t->next;
c000681e:	8b 86 c4 00 00 00    	mov    0xc4(%esi),%eax
c0006824:	89 47 4c             	mov    %eax,0x4c(%edi)
            }

            t->next = t->prev = nullptr;
c0006827:	c7 86 c0 00 00 00 00 	movl   $0x0,0xc0(%esi)
c000682e:	00 00 00 
c0006831:	83 c8 ff             	or     $0xffffffff,%eax
c0006834:	c7 86 c4 00 00 00 00 	movl   $0x0,0xc4(%esi)
c000683b:	00 00 00 
c000683e:	f0 0f c1 46 48       	lock xadd %eax,0x48(%esi)

                    counter++;
                    return;
                }

                if (EXPECT_FALSE(ec->del_ref())) {
c0006843:	48                   	dec    %eax
c0006844:	75 24                	jne    c000686a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x166>
                    delete ec;
c0006846:	89 f0                	mov    %esi,%eax
c0006848:	e8 c1 cc ff ff       	call   c000350e <_ZN2EcD1Ev>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c000684d:	8b 86 b8 00 00 00    	mov    0xb8(%esi),%eax
c0006853:	89 f2                	mov    %esi,%edx
c0006855:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c000685b:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c0006860:	e8 fb 9a 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
c0006865:	e9 63 ff ff ff       	jmp    c00067cd <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0xc9>
c000686a:	fe 47 46             	incb   0x46(%edi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c000686d:	84 db                	test   %bl,%bl
c000686f:	74 2a                	je     c000689b <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x197>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0006871:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0006878:	74 19                	je     c0006893 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x18f>
c000687a:	68 40 85 01 c0       	push   $0xc0018540
c000687f:	68 c0 00 00 00       	push   $0xc0
c0006884:	68 12 61 01 c0       	push   $0xc0016112
c0006889:	68 82 61 01 c0       	push   $0xc0016182
c000688e:	e9 b7 fe ff ff       	jmp    c000674a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x46>

            preemption = true;
c0006893:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000689a:	fb                   	sti    
        }

        ALWAYS_INLINE
        inline void release (void (*c)())
        {
            if (c)
c000689b:	b8 ba 89 00 c0       	mov    $0xc00089ba,%eax
c00068a0:	85 c0                	test   %eax,%eax
c00068a2:	74 03                	je     c00068a7 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x1a3>
                cont = c;
c00068a4:	89 46 50             	mov    %eax,0x50(%esi)

            Lock_guard <Spinlock> guard (lock);
c00068a7:	8d 46 46             	lea    0x46(%esi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c00068aa:	9c                   	pushf  
c00068ab:	5b                   	pop    %ebx
            return flags & 0x200;
c00068ac:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c00068af:	80 e3 01             	and    $0x1,%bl
c00068b2:	74 15                	je     c00068c9 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x1c5>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c00068b4:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c00068bb:	0f 84 e9 fe ff ff    	je     c00067aa <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0xa6>

            asm volatile ("cli" : : : "memory");
c00068c1:	fa                   	cli    
            preemption = false;
c00068c2:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c00068c9:	e8 5e a2 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c00068ce:	8b 7e 4c             	mov    0x4c(%esi),%edi
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c00068d1:	85 ff                	test   %edi,%edi
c00068d3:	74 71                	je     c0006946 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x242>
c00068d5:	8b 47 74             	mov    0x74(%edi),%eax
c00068d8:	85 c0                	test   %eax,%eax
c00068da:	74 6a                	je     c0006946 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x242>
c00068dc:	8b 57 70             	mov    0x70(%edi),%edx
c00068df:	85 d2                	test   %edx,%edx
c00068e1:	74 63                	je     c0006946 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x242>
                return false;

            if (t == t->next)
c00068e3:	39 c7                	cmp    %eax,%edi
c00068e5:	75 09                	jne    c00068f0 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x1ec>
                headptr = nullptr;
c00068e7:	c7 46 4c 00 00 00 00 	movl   $0x0,0x4c(%esi)
c00068ee:	eb 17                	jmp    c0006907 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x203>

            else {
                t->next->prev = t->prev;
c00068f0:	89 50 70             	mov    %edx,0x70(%eax)
                t->prev->next = t->next;
c00068f3:	8b 47 70             	mov    0x70(%edi),%eax
c00068f6:	8b 57 74             	mov    0x74(%edi),%edx
c00068f9:	89 50 74             	mov    %edx,0x74(%eax)
                if (t == headptr)
c00068fc:	3b 7e 4c             	cmp    0x4c(%esi),%edi
c00068ff:	75 06                	jne    c0006907 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x203>
                    headptr = t->next;
c0006901:	8b 47 74             	mov    0x74(%edi),%eax
c0006904:	89 46 4c             	mov    %eax,0x4c(%esi)
            }

            t->next = t->prev = nullptr;
c0006907:	c7 47 70 00 00 00 00 	movl   $0x0,0x70(%edi)
c000690e:	83 c8 ff             	or     $0xffffffff,%eax
c0006911:	c7 47 74 00 00 00 00 	movl   $0x0,0x74(%edi)
c0006918:	f0 0f c1 47 48       	lock xadd %eax,0x48(%edi)

            for (Sc *s; dequeue (s = head()); ) {
                if (EXPECT_FALSE(s->del_ref()) && (this == s->ec)) {
c000691d:	48                   	dec    %eax
c000691e:	75 1d                	jne    c000693d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x239>
c0006920:	3b 77 4c             	cmp    0x4c(%edi),%esi
c0006923:	75 18                	jne    c000693d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x239>
                    delete s;
c0006925:	89 f8                	mov    %edi,%eax
c0006927:	e8 4e fa ff ff       	call   c000637a <_ZN2ScD1Ev>
c000692c:	89 f8                	mov    %edi,%eax
c000692e:	e8 12 90 00 00       	call   c000f945 <_ZN2ScdlEPv>
c0006933:	eb 99                	jmp    c00068ce <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x1ca>
                    if (si) {
                       if (si->queued()) return;
                       Queue<Si>::enqueue(si);
                    }

                    counter++;
c0006935:	ff 47 64             	incl   0x64(%edi)
c0006938:	fe 47 46             	incb   0x46(%edi)
c000693b:	eb 0c                	jmp    c0006949 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x245>
                    continue;
                }
                s->remote_enqueue();
c000693d:	89 f8                	mov    %edi,%eax
c000693f:	e8 f8 8d 00 00       	call   c000f73c <_ZN2Sc14remote_enqueueEv>
c0006944:	eb 88                	jmp    c00068ce <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x1ca>
c0006946:	fe 46 46             	incb   0x46(%esi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c0006949:	84 db                	test   %bl,%bl
c000694b:	74 15                	je     c0006962 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x25e>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000694d:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0006954:	0f 85 20 ff ff ff    	jne    c000687a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x176>

            preemption = true;
c000695a:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c0006961:	fb                   	sti    

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
c0006962:	8b 1d 08 f0 ff cf    	mov    0xcffff008,%ebx
c0006968:	8b 53 14             	mov    0x14(%ebx),%edx
    current->utcb    = nullptr;
    current->fpu     = nullptr;

    Rcu::call(current);
c000696b:	8d 73 0c             	lea    0xc(%ebx),%esi
    assert (current->utcb);
    assert (Sc::current->ec == current);

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
c000696e:	c7 83 b0 00 00 00 00 	movl   $0x0,0xb0(%ebx)
c0006975:	00 00 00 
    current->utcb    = nullptr;
c0006978:	c7 83 b4 00 00 00 00 	movl   $0x0,0xb4(%ebx)
c000697f:	00 00 00 
    current->fpu     = nullptr;
c0006982:	c7 83 c8 00 00 00 00 	movl   $0x0,0xc8(%ebx)
c0006989:	00 00 00 
c000698c:	85 d2                	test   %edx,%edx
c000698e:	74 04                	je     c0006994 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x290>
                e->pre_func(e);
c0006990:	89 f0                	mov    %esi,%eax
c0006992:	ff d2                	call   *%edx
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
c0006994:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
c0006998:	75 09                	jne    c00069a3 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x29f>
c000699a:	a1 f0 f7 ff cf       	mov    0xcffff7f0,%eax
c000699f:	39 f0                	cmp    %esi,%eax
c00069a1:	75 29                	jne    c00069cc <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x2c8>
                trace (0, "warning: rcu element already enqueued");
c00069a3:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c00069a7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c00069ac:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c00069b1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00069b6:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c00069bd:	50                   	push   %eax
c00069be:	68 ae 6c 01 c0       	push   $0xc0016cae
c00069c3:	e8 16 b0 ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c00069c8:	59                   	pop    %ecx
c00069c9:	5b                   	pop    %ebx
c00069ca:	eb 0e                	jmp    c00069da <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x2d6>
                return;
            }

            count ++;
c00069cc:	ff 05 f4 f7 ff cf    	incl   0xcffff7f4

           *tail = e;
c00069d2:	89 30                	mov    %esi,(%eax)
            tail = &e->next;
c00069d4:	89 35 f0 f7 ff cf    	mov    %esi,0xcffff7f0

    Rcu::call(current);
    Rcu::call(Sc::current);
c00069da:	8b 35 10 f0 ff cf    	mov    0xcffff010,%esi
c00069e0:	85 f6                	test   %esi,%esi
c00069e2:	74 63                	je     c0006a47 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x343>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
c00069e4:	8b 56 14             	mov    0x14(%esi),%edx
c00069e7:	8d 5e 0c             	lea    0xc(%esi),%ebx
c00069ea:	85 d2                	test   %edx,%edx
c00069ec:	74 04                	je     c00069f2 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x2ee>
                e->pre_func(e);
c00069ee:	89 d8                	mov    %ebx,%eax
c00069f0:	ff d2                	call   *%edx
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
c00069f2:	83 7e 0c 00          	cmpl   $0x0,0xc(%esi)
c00069f6:	75 09                	jne    c0006a01 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x2fd>
c00069f8:	a1 f0 f7 ff cf       	mov    0xcffff7f0,%eax
c00069fd:	39 d8                	cmp    %ebx,%eax
c00069ff:	75 29                	jne    c0006a2a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x326>
                trace (0, "warning: rcu element already enqueued");
c0006a01:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c0006a05:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0006a0a:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c0006a0f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0006a14:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0006a1b:	50                   	push   %eax
c0006a1c:	68 ae 6c 01 c0       	push   $0xc0016cae
c0006a21:	e8 b8 af ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c0006a26:	58                   	pop    %eax
c0006a27:	5a                   	pop    %edx
c0006a28:	eb 0e                	jmp    c0006a38 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x334>
                return;
            }

            count ++;
c0006a2a:	ff 05 f4 f7 ff cf    	incl   0xcffff7f4

           *tail = e;
c0006a30:	89 18                	mov    %ebx,(%eax)
            tail = &e->next;
c0006a32:	89 1d f0 f7 ff cf    	mov    %ebx,0xcffff7f0

    Sc::schedule(true);
c0006a38:	ba 01 00 00 00       	mov    $0x1,%edx
c0006a3d:	b8 01 00 00 00       	mov    $0x1,%eax
c0006a42:	e8 6b 8f 00 00       	call   c000f9b2 <_ZN2Sc8scheduleEbb>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
c0006a47:	a1 08 00 00 00       	mov    0x8,%eax
c0006a4c:	0f 0b                	ud2    

c0006a4e <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv>:

    die ("XCPU OOM error");
}

template <void (*C)()>
void Ec::oom_xcpu_return()
c0006a4e:	57                   	push   %edi
c0006a4f:	56                   	push   %esi
c0006a50:	53                   	push   %ebx
c0006a51:	56                   	push   %esi
{
    assert (current->xcpu_sm);
c0006a52:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0006a57:	8b b8 f4 00 00 00    	mov    0xf4(%eax),%edi
c0006a5d:	85 ff                	test   %edi,%edi
c0006a5f:	75 16                	jne    c0006a77 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x29>
c0006a61:	68 c0 81 01 c0       	push   $0xc00181c0
c0006a66:	68 87 00 00 00       	push   $0x87
c0006a6b:	68 a3 72 01 c0       	push   $0xc00172a3
c0006a70:	68 66 6c 01 c0       	push   $0xc0016c66
c0006a75:	eb 1d                	jmp    c0006a94 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x46>
    assert (current->rcap);
c0006a77:	83 b8 b0 00 00 00 00 	cmpl   $0x0,0xb0(%eax)
c0006a7e:	75 1e                	jne    c0006a9e <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x50>
c0006a80:	68 c0 81 01 c0       	push   $0xc00181c0
c0006a85:	68 88 00 00 00       	push   $0x88
c0006a8a:	68 a3 72 01 c0       	push   $0xc00172a3
c0006a8f:	68 77 6c 01 c0       	push   $0xc0016c77
c0006a94:	68 69 60 01 c0       	push   $0xc0016069
c0006a99:	e8 a8 ae ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>
    assert (current->utcb);
c0006a9e:	83 b8 b4 00 00 00 00 	cmpl   $0x0,0xb4(%eax)
c0006aa5:	75 16                	jne    c0006abd <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x6f>
c0006aa7:	68 c0 81 01 c0       	push   $0xc00181c0
c0006aac:	68 89 00 00 00       	push   $0x89
c0006ab1:	68 a3 72 01 c0       	push   $0xc00172a3
c0006ab6:	68 85 6c 01 c0       	push   $0xc0016c85
c0006abb:	eb d7                	jmp    c0006a94 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x46>
c0006abd:	8b 15 10 f0 ff cf    	mov    0xcffff010,%edx
    assert (Sc::current->ec == current);
c0006ac3:	39 42 4c             	cmp    %eax,0x4c(%edx)
c0006ac6:	74 16                	je     c0006ade <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x90>
c0006ac8:	68 c0 81 01 c0       	push   $0xc00181c0
c0006acd:	68 8a 00 00 00       	push   $0x8a
c0006ad2:	68 a3 72 01 c0       	push   $0xc00172a3
c0006ad7:	68 93 6c 01 c0       	push   $0xc0016c93
c0006adc:	eb b6                	jmp    c0006a94 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x46>
        ALWAYS_INLINE
        inline void up (void (*c)() = nullptr, Sm * si = nullptr)
        {
            Ec *ec;

            {   Lock_guard <Spinlock> guard (lock);
c0006ade:	8d 47 46             	lea    0x46(%edi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c0006ae1:	9c                   	pushf  
c0006ae2:	5b                   	pop    %ebx
            return flags & 0x200;
c0006ae3:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c0006ae6:	80 e3 01             	and    $0x1,%bl
c0006ae9:	74 27                	je     c0006b12 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0xc4>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0006aeb:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0006af2:	75 16                	jne    c0006b0a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0xbc>
c0006af4:	68 80 85 01 c0       	push   $0xc0018580
c0006af9:	68 b7 00 00 00       	push   $0xb7
c0006afe:	68 12 61 01 c0       	push   $0xc0016112
c0006b03:	68 83 61 01 c0       	push   $0xc0016183
c0006b08:	eb 8a                	jmp    c0006a94 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x46>

            asm volatile ("cli" : : : "memory");
c0006b0a:	fa                   	cli    
            preemption = false;
c0006b0b:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c0006b12:	e8 15 a0 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c0006b17:	8b 77 4c             	mov    0x4c(%edi),%esi
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c0006b1a:	85 f6                	test   %esi,%esi
c0006b1c:	0f 84 5d 01 00 00    	je     c0006c7f <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x231>
c0006b22:	8b 86 c4 00 00 00    	mov    0xc4(%esi),%eax
c0006b28:	85 c0                	test   %eax,%eax
c0006b2a:	0f 84 4f 01 00 00    	je     c0006c7f <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x231>
c0006b30:	8b 96 c0 00 00 00    	mov    0xc0(%esi),%edx
c0006b36:	85 d2                	test   %edx,%edx
c0006b38:	0f 84 41 01 00 00    	je     c0006c7f <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x231>
                return false;

            if (t == t->next)
c0006b3e:	39 c6                	cmp    %eax,%esi
c0006b40:	75 09                	jne    c0006b4b <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0xfd>
                headptr = nullptr;
c0006b42:	c7 47 4c 00 00 00 00 	movl   $0x0,0x4c(%edi)
c0006b49:	eb 26                	jmp    c0006b71 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x123>

            else {
                t->next->prev = t->prev;
c0006b4b:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
                t->prev->next = t->next;
c0006b51:	8b 86 c0 00 00 00    	mov    0xc0(%esi),%eax
c0006b57:	8b 96 c4 00 00 00    	mov    0xc4(%esi),%edx
c0006b5d:	89 90 c4 00 00 00    	mov    %edx,0xc4(%eax)
                if (t == headptr)
c0006b63:	3b 77 4c             	cmp    0x4c(%edi),%esi
c0006b66:	75 09                	jne    c0006b71 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x123>
                    headptr = t->next;
c0006b68:	8b 86 c4 00 00 00    	mov    0xc4(%esi),%eax
c0006b6e:	89 47 4c             	mov    %eax,0x4c(%edi)
            }

            t->next = t->prev = nullptr;
c0006b71:	c7 86 c0 00 00 00 00 	movl   $0x0,0xc0(%esi)
c0006b78:	00 00 00 
c0006b7b:	83 c8 ff             	or     $0xffffffff,%eax
c0006b7e:	c7 86 c4 00 00 00 00 	movl   $0x0,0xc4(%esi)
c0006b85:	00 00 00 
c0006b88:	f0 0f c1 46 48       	lock xadd %eax,0x48(%esi)

                    counter++;
                    return;
                }

                if (EXPECT_FALSE(ec->del_ref())) {
c0006b8d:	48                   	dec    %eax
c0006b8e:	75 24                	jne    c0006bb4 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x166>
                    delete ec;
c0006b90:	89 f0                	mov    %esi,%eax
c0006b92:	e8 77 c9 ff ff       	call   c000350e <_ZN2EcD1Ev>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c0006b97:	8b 86 b8 00 00 00    	mov    0xb8(%esi),%eax
c0006b9d:	89 f2                	mov    %esi,%edx
c0006b9f:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c0006ba5:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c0006baa:	e8 b1 97 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
c0006baf:	e9 63 ff ff ff       	jmp    c0006b17 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0xc9>
c0006bb4:	fe 47 46             	incb   0x46(%edi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c0006bb7:	84 db                	test   %bl,%bl
c0006bb9:	74 2a                	je     c0006be5 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x197>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0006bbb:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0006bc2:	74 19                	je     c0006bdd <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x18f>
c0006bc4:	68 40 85 01 c0       	push   $0xc0018540
c0006bc9:	68 c0 00 00 00       	push   $0xc0
c0006bce:	68 12 61 01 c0       	push   $0xc0016112
c0006bd3:	68 82 61 01 c0       	push   $0xc0016182
c0006bd8:	e9 b7 fe ff ff       	jmp    c0006a94 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x46>

            preemption = true;
c0006bdd:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c0006be4:	fb                   	sti    
        }

        ALWAYS_INLINE
        inline void release (void (*c)())
        {
            if (c)
c0006be5:	b8 5a 8b 00 c0       	mov    $0xc0008b5a,%eax
c0006bea:	85 c0                	test   %eax,%eax
c0006bec:	74 03                	je     c0006bf1 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x1a3>
                cont = c;
c0006bee:	89 46 50             	mov    %eax,0x50(%esi)

            Lock_guard <Spinlock> guard (lock);
c0006bf1:	8d 46 46             	lea    0x46(%esi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c0006bf4:	9c                   	pushf  
c0006bf5:	5b                   	pop    %ebx
            return flags & 0x200;
c0006bf6:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c0006bf9:	80 e3 01             	and    $0x1,%bl
c0006bfc:	74 15                	je     c0006c13 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x1c5>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0006bfe:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0006c05:	0f 84 e9 fe ff ff    	je     c0006af4 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0xa6>

            asm volatile ("cli" : : : "memory");
c0006c0b:	fa                   	cli    
            preemption = false;
c0006c0c:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c0006c13:	e8 14 9f ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c0006c18:	8b 7e 4c             	mov    0x4c(%esi),%edi
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c0006c1b:	85 ff                	test   %edi,%edi
c0006c1d:	74 71                	je     c0006c90 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x242>
c0006c1f:	8b 47 74             	mov    0x74(%edi),%eax
c0006c22:	85 c0                	test   %eax,%eax
c0006c24:	74 6a                	je     c0006c90 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x242>
c0006c26:	8b 57 70             	mov    0x70(%edi),%edx
c0006c29:	85 d2                	test   %edx,%edx
c0006c2b:	74 63                	je     c0006c90 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x242>
                return false;

            if (t == t->next)
c0006c2d:	39 c7                	cmp    %eax,%edi
c0006c2f:	75 09                	jne    c0006c3a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x1ec>
                headptr = nullptr;
c0006c31:	c7 46 4c 00 00 00 00 	movl   $0x0,0x4c(%esi)
c0006c38:	eb 17                	jmp    c0006c51 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x203>

            else {
                t->next->prev = t->prev;
c0006c3a:	89 50 70             	mov    %edx,0x70(%eax)
                t->prev->next = t->next;
c0006c3d:	8b 47 70             	mov    0x70(%edi),%eax
c0006c40:	8b 57 74             	mov    0x74(%edi),%edx
c0006c43:	89 50 74             	mov    %edx,0x74(%eax)
                if (t == headptr)
c0006c46:	3b 7e 4c             	cmp    0x4c(%esi),%edi
c0006c49:	75 06                	jne    c0006c51 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x203>
                    headptr = t->next;
c0006c4b:	8b 47 74             	mov    0x74(%edi),%eax
c0006c4e:	89 46 4c             	mov    %eax,0x4c(%esi)
            }

            t->next = t->prev = nullptr;
c0006c51:	c7 47 70 00 00 00 00 	movl   $0x0,0x70(%edi)
c0006c58:	83 c8 ff             	or     $0xffffffff,%eax
c0006c5b:	c7 47 74 00 00 00 00 	movl   $0x0,0x74(%edi)
c0006c62:	f0 0f c1 47 48       	lock xadd %eax,0x48(%edi)

            for (Sc *s; dequeue (s = head()); ) {
                if (EXPECT_FALSE(s->del_ref()) && (this == s->ec)) {
c0006c67:	48                   	dec    %eax
c0006c68:	75 1d                	jne    c0006c87 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x239>
c0006c6a:	3b 77 4c             	cmp    0x4c(%edi),%esi
c0006c6d:	75 18                	jne    c0006c87 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x239>
                    delete s;
c0006c6f:	89 f8                	mov    %edi,%eax
c0006c71:	e8 04 f7 ff ff       	call   c000637a <_ZN2ScD1Ev>
c0006c76:	89 f8                	mov    %edi,%eax
c0006c78:	e8 c8 8c 00 00       	call   c000f945 <_ZN2ScdlEPv>
c0006c7d:	eb 99                	jmp    c0006c18 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x1ca>
                    if (si) {
                       if (si->queued()) return;
                       Queue<Si>::enqueue(si);
                    }

                    counter++;
c0006c7f:	ff 47 64             	incl   0x64(%edi)
c0006c82:	fe 47 46             	incb   0x46(%edi)
c0006c85:	eb 0c                	jmp    c0006c93 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x245>
                    continue;
                }
                s->remote_enqueue();
c0006c87:	89 f8                	mov    %edi,%eax
c0006c89:	e8 ae 8a 00 00       	call   c000f73c <_ZN2Sc14remote_enqueueEv>
c0006c8e:	eb 88                	jmp    c0006c18 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x1ca>
c0006c90:	fe 46 46             	incb   0x46(%esi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c0006c93:	84 db                	test   %bl,%bl
c0006c95:	74 15                	je     c0006cac <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x25e>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0006c97:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0006c9e:	0f 85 20 ff ff ff    	jne    c0006bc4 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x176>

            preemption = true;
c0006ca4:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c0006cab:	fb                   	sti    

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
c0006cac:	8b 1d 08 f0 ff cf    	mov    0xcffff008,%ebx
c0006cb2:	8b 53 14             	mov    0x14(%ebx),%edx
    current->utcb    = nullptr;
    current->fpu     = nullptr;

    Rcu::call(current);
c0006cb5:	8d 73 0c             	lea    0xc(%ebx),%esi
    assert (current->utcb);
    assert (Sc::current->ec == current);

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
c0006cb8:	c7 83 b0 00 00 00 00 	movl   $0x0,0xb0(%ebx)
c0006cbf:	00 00 00 
    current->utcb    = nullptr;
c0006cc2:	c7 83 b4 00 00 00 00 	movl   $0x0,0xb4(%ebx)
c0006cc9:	00 00 00 
    current->fpu     = nullptr;
c0006ccc:	c7 83 c8 00 00 00 00 	movl   $0x0,0xc8(%ebx)
c0006cd3:	00 00 00 
c0006cd6:	85 d2                	test   %edx,%edx
c0006cd8:	74 04                	je     c0006cde <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x290>
                e->pre_func(e);
c0006cda:	89 f0                	mov    %esi,%eax
c0006cdc:	ff d2                	call   *%edx
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
c0006cde:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
c0006ce2:	75 09                	jne    c0006ced <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x29f>
c0006ce4:	a1 f0 f7 ff cf       	mov    0xcffff7f0,%eax
c0006ce9:	39 f0                	cmp    %esi,%eax
c0006ceb:	75 29                	jne    c0006d16 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x2c8>
                trace (0, "warning: rcu element already enqueued");
c0006ced:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c0006cf1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0006cf6:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c0006cfb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0006d00:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0006d07:	50                   	push   %eax
c0006d08:	68 ae 6c 01 c0       	push   $0xc0016cae
c0006d0d:	e8 cc ac ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c0006d12:	59                   	pop    %ecx
c0006d13:	5b                   	pop    %ebx
c0006d14:	eb 0e                	jmp    c0006d24 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x2d6>
                return;
            }

            count ++;
c0006d16:	ff 05 f4 f7 ff cf    	incl   0xcffff7f4

           *tail = e;
c0006d1c:	89 30                	mov    %esi,(%eax)
            tail = &e->next;
c0006d1e:	89 35 f0 f7 ff cf    	mov    %esi,0xcffff7f0

    Rcu::call(current);
    Rcu::call(Sc::current);
c0006d24:	8b 35 10 f0 ff cf    	mov    0xcffff010,%esi
c0006d2a:	85 f6                	test   %esi,%esi
c0006d2c:	74 63                	je     c0006d91 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x343>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
c0006d2e:	8b 56 14             	mov    0x14(%esi),%edx
c0006d31:	8d 5e 0c             	lea    0xc(%esi),%ebx
c0006d34:	85 d2                	test   %edx,%edx
c0006d36:	74 04                	je     c0006d3c <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x2ee>
                e->pre_func(e);
c0006d38:	89 d8                	mov    %ebx,%eax
c0006d3a:	ff d2                	call   *%edx
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
c0006d3c:	83 7e 0c 00          	cmpl   $0x0,0xc(%esi)
c0006d40:	75 09                	jne    c0006d4b <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x2fd>
c0006d42:	a1 f0 f7 ff cf       	mov    0xcffff7f0,%eax
c0006d47:	39 d8                	cmp    %ebx,%eax
c0006d49:	75 29                	jne    c0006d74 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x326>
                trace (0, "warning: rcu element already enqueued");
c0006d4b:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c0006d4f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0006d54:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c0006d59:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0006d5e:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0006d65:	50                   	push   %eax
c0006d66:	68 ae 6c 01 c0       	push   $0xc0016cae
c0006d6b:	e8 6e ac ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c0006d70:	58                   	pop    %eax
c0006d71:	5a                   	pop    %edx
c0006d72:	eb 0e                	jmp    c0006d82 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x334>
                return;
            }

            count ++;
c0006d74:	ff 05 f4 f7 ff cf    	incl   0xcffff7f4

           *tail = e;
c0006d7a:	89 18                	mov    %ebx,(%eax)
            tail = &e->next;
c0006d7c:	89 1d f0 f7 ff cf    	mov    %ebx,0xcffff7f0

    Sc::schedule(true);
c0006d82:	ba 01 00 00 00       	mov    $0x1,%edx
c0006d87:	b8 01 00 00 00       	mov    $0x1,%eax
c0006d8c:	e8 21 8c 00 00       	call   c000f9b2 <_ZN2Sc8scheduleEbb>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
c0006d91:	a1 08 00 00 00       	mov    0x8,%eax
c0006d96:	0f 0b                	ud2    

c0006d98 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv>:

    die ("XCPU OOM error");
}

template <void (*C)()>
void Ec::oom_xcpu_return()
c0006d98:	57                   	push   %edi
c0006d99:	56                   	push   %esi
c0006d9a:	53                   	push   %ebx
c0006d9b:	56                   	push   %esi
{
    assert (current->xcpu_sm);
c0006d9c:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0006da1:	8b b8 f4 00 00 00    	mov    0xf4(%eax),%edi
c0006da7:	85 ff                	test   %edi,%edi
c0006da9:	75 16                	jne    c0006dc1 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x29>
c0006dab:	68 00 80 01 c0       	push   $0xc0018000
c0006db0:	68 87 00 00 00       	push   $0x87
c0006db5:	68 a3 72 01 c0       	push   $0xc00172a3
c0006dba:	68 66 6c 01 c0       	push   $0xc0016c66
c0006dbf:	eb 1d                	jmp    c0006dde <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x46>
    assert (current->rcap);
c0006dc1:	83 b8 b0 00 00 00 00 	cmpl   $0x0,0xb0(%eax)
c0006dc8:	75 1e                	jne    c0006de8 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x50>
c0006dca:	68 00 80 01 c0       	push   $0xc0018000
c0006dcf:	68 88 00 00 00       	push   $0x88
c0006dd4:	68 a3 72 01 c0       	push   $0xc00172a3
c0006dd9:	68 77 6c 01 c0       	push   $0xc0016c77
c0006dde:	68 69 60 01 c0       	push   $0xc0016069
c0006de3:	e8 5e ab ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>
    assert (current->utcb);
c0006de8:	83 b8 b4 00 00 00 00 	cmpl   $0x0,0xb4(%eax)
c0006def:	75 16                	jne    c0006e07 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x6f>
c0006df1:	68 00 80 01 c0       	push   $0xc0018000
c0006df6:	68 89 00 00 00       	push   $0x89
c0006dfb:	68 a3 72 01 c0       	push   $0xc00172a3
c0006e00:	68 85 6c 01 c0       	push   $0xc0016c85
c0006e05:	eb d7                	jmp    c0006dde <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x46>
c0006e07:	8b 15 10 f0 ff cf    	mov    0xcffff010,%edx
    assert (Sc::current->ec == current);
c0006e0d:	39 42 4c             	cmp    %eax,0x4c(%edx)
c0006e10:	74 16                	je     c0006e28 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x90>
c0006e12:	68 00 80 01 c0       	push   $0xc0018000
c0006e17:	68 8a 00 00 00       	push   $0x8a
c0006e1c:	68 a3 72 01 c0       	push   $0xc00172a3
c0006e21:	68 93 6c 01 c0       	push   $0xc0016c93
c0006e26:	eb b6                	jmp    c0006dde <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x46>
        ALWAYS_INLINE
        inline void up (void (*c)() = nullptr, Sm * si = nullptr)
        {
            Ec *ec;

            {   Lock_guard <Spinlock> guard (lock);
c0006e28:	8d 47 46             	lea    0x46(%edi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c0006e2b:	9c                   	pushf  
c0006e2c:	5b                   	pop    %ebx
            return flags & 0x200;
c0006e2d:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c0006e30:	80 e3 01             	and    $0x1,%bl
c0006e33:	74 27                	je     c0006e5c <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0xc4>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0006e35:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0006e3c:	75 16                	jne    c0006e54 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0xbc>
c0006e3e:	68 80 85 01 c0       	push   $0xc0018580
c0006e43:	68 b7 00 00 00       	push   $0xb7
c0006e48:	68 12 61 01 c0       	push   $0xc0016112
c0006e4d:	68 83 61 01 c0       	push   $0xc0016183
c0006e52:	eb 8a                	jmp    c0006dde <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x46>

            asm volatile ("cli" : : : "memory");
c0006e54:	fa                   	cli    
            preemption = false;
c0006e55:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c0006e5c:	e8 cb 9c ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c0006e61:	8b 77 4c             	mov    0x4c(%edi),%esi
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c0006e64:	85 f6                	test   %esi,%esi
c0006e66:	0f 84 5d 01 00 00    	je     c0006fc9 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x231>
c0006e6c:	8b 86 c4 00 00 00    	mov    0xc4(%esi),%eax
c0006e72:	85 c0                	test   %eax,%eax
c0006e74:	0f 84 4f 01 00 00    	je     c0006fc9 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x231>
c0006e7a:	8b 96 c0 00 00 00    	mov    0xc0(%esi),%edx
c0006e80:	85 d2                	test   %edx,%edx
c0006e82:	0f 84 41 01 00 00    	je     c0006fc9 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x231>
                return false;

            if (t == t->next)
c0006e88:	39 c6                	cmp    %eax,%esi
c0006e8a:	75 09                	jne    c0006e95 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0xfd>
                headptr = nullptr;
c0006e8c:	c7 47 4c 00 00 00 00 	movl   $0x0,0x4c(%edi)
c0006e93:	eb 26                	jmp    c0006ebb <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x123>

            else {
                t->next->prev = t->prev;
c0006e95:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
                t->prev->next = t->next;
c0006e9b:	8b 86 c0 00 00 00    	mov    0xc0(%esi),%eax
c0006ea1:	8b 96 c4 00 00 00    	mov    0xc4(%esi),%edx
c0006ea7:	89 90 c4 00 00 00    	mov    %edx,0xc4(%eax)
                if (t == headptr)
c0006ead:	3b 77 4c             	cmp    0x4c(%edi),%esi
c0006eb0:	75 09                	jne    c0006ebb <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x123>
                    headptr = t->next;
c0006eb2:	8b 86 c4 00 00 00    	mov    0xc4(%esi),%eax
c0006eb8:	89 47 4c             	mov    %eax,0x4c(%edi)
            }

            t->next = t->prev = nullptr;
c0006ebb:	c7 86 c0 00 00 00 00 	movl   $0x0,0xc0(%esi)
c0006ec2:	00 00 00 
c0006ec5:	83 c8 ff             	or     $0xffffffff,%eax
c0006ec8:	c7 86 c4 00 00 00 00 	movl   $0x0,0xc4(%esi)
c0006ecf:	00 00 00 
c0006ed2:	f0 0f c1 46 48       	lock xadd %eax,0x48(%esi)

                    counter++;
                    return;
                }

                if (EXPECT_FALSE(ec->del_ref())) {
c0006ed7:	48                   	dec    %eax
c0006ed8:	75 24                	jne    c0006efe <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x166>
                    delete ec;
c0006eda:	89 f0                	mov    %esi,%eax
c0006edc:	e8 2d c6 ff ff       	call   c000350e <_ZN2EcD1Ev>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c0006ee1:	8b 86 b8 00 00 00    	mov    0xb8(%esi),%eax
c0006ee7:	89 f2                	mov    %esi,%edx
c0006ee9:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c0006eef:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c0006ef4:	e8 67 94 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
c0006ef9:	e9 63 ff ff ff       	jmp    c0006e61 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0xc9>
c0006efe:	fe 47 46             	incb   0x46(%edi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c0006f01:	84 db                	test   %bl,%bl
c0006f03:	74 2a                	je     c0006f2f <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x197>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0006f05:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0006f0c:	74 19                	je     c0006f27 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x18f>
c0006f0e:	68 40 85 01 c0       	push   $0xc0018540
c0006f13:	68 c0 00 00 00       	push   $0xc0
c0006f18:	68 12 61 01 c0       	push   $0xc0016112
c0006f1d:	68 82 61 01 c0       	push   $0xc0016182
c0006f22:	e9 b7 fe ff ff       	jmp    c0006dde <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x46>

            preemption = true;
c0006f27:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c0006f2e:	fb                   	sti    
        }

        ALWAYS_INLINE
        inline void release (void (*c)())
        {
            if (c)
c0006f2f:	b8 fa 8c 00 c0       	mov    $0xc0008cfa,%eax
c0006f34:	85 c0                	test   %eax,%eax
c0006f36:	74 03                	je     c0006f3b <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x1a3>
                cont = c;
c0006f38:	89 46 50             	mov    %eax,0x50(%esi)

            Lock_guard <Spinlock> guard (lock);
c0006f3b:	8d 46 46             	lea    0x46(%esi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c0006f3e:	9c                   	pushf  
c0006f3f:	5b                   	pop    %ebx
            return flags & 0x200;
c0006f40:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c0006f43:	80 e3 01             	and    $0x1,%bl
c0006f46:	74 15                	je     c0006f5d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x1c5>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0006f48:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0006f4f:	0f 84 e9 fe ff ff    	je     c0006e3e <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0xa6>

            asm volatile ("cli" : : : "memory");
c0006f55:	fa                   	cli    
            preemption = false;
c0006f56:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c0006f5d:	e8 ca 9b ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c0006f62:	8b 7e 4c             	mov    0x4c(%esi),%edi
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c0006f65:	85 ff                	test   %edi,%edi
c0006f67:	74 71                	je     c0006fda <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x242>
c0006f69:	8b 47 74             	mov    0x74(%edi),%eax
c0006f6c:	85 c0                	test   %eax,%eax
c0006f6e:	74 6a                	je     c0006fda <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x242>
c0006f70:	8b 57 70             	mov    0x70(%edi),%edx
c0006f73:	85 d2                	test   %edx,%edx
c0006f75:	74 63                	je     c0006fda <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x242>
                return false;

            if (t == t->next)
c0006f77:	39 c7                	cmp    %eax,%edi
c0006f79:	75 09                	jne    c0006f84 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x1ec>
                headptr = nullptr;
c0006f7b:	c7 46 4c 00 00 00 00 	movl   $0x0,0x4c(%esi)
c0006f82:	eb 17                	jmp    c0006f9b <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x203>

            else {
                t->next->prev = t->prev;
c0006f84:	89 50 70             	mov    %edx,0x70(%eax)
                t->prev->next = t->next;
c0006f87:	8b 47 70             	mov    0x70(%edi),%eax
c0006f8a:	8b 57 74             	mov    0x74(%edi),%edx
c0006f8d:	89 50 74             	mov    %edx,0x74(%eax)
                if (t == headptr)
c0006f90:	3b 7e 4c             	cmp    0x4c(%esi),%edi
c0006f93:	75 06                	jne    c0006f9b <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x203>
                    headptr = t->next;
c0006f95:	8b 47 74             	mov    0x74(%edi),%eax
c0006f98:	89 46 4c             	mov    %eax,0x4c(%esi)
            }

            t->next = t->prev = nullptr;
c0006f9b:	c7 47 70 00 00 00 00 	movl   $0x0,0x70(%edi)
c0006fa2:	83 c8 ff             	or     $0xffffffff,%eax
c0006fa5:	c7 47 74 00 00 00 00 	movl   $0x0,0x74(%edi)
c0006fac:	f0 0f c1 47 48       	lock xadd %eax,0x48(%edi)

            for (Sc *s; dequeue (s = head()); ) {
                if (EXPECT_FALSE(s->del_ref()) && (this == s->ec)) {
c0006fb1:	48                   	dec    %eax
c0006fb2:	75 1d                	jne    c0006fd1 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x239>
c0006fb4:	3b 77 4c             	cmp    0x4c(%edi),%esi
c0006fb7:	75 18                	jne    c0006fd1 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x239>
                    delete s;
c0006fb9:	89 f8                	mov    %edi,%eax
c0006fbb:	e8 ba f3 ff ff       	call   c000637a <_ZN2ScD1Ev>
c0006fc0:	89 f8                	mov    %edi,%eax
c0006fc2:	e8 7e 89 00 00       	call   c000f945 <_ZN2ScdlEPv>
c0006fc7:	eb 99                	jmp    c0006f62 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x1ca>
                    if (si) {
                       if (si->queued()) return;
                       Queue<Si>::enqueue(si);
                    }

                    counter++;
c0006fc9:	ff 47 64             	incl   0x64(%edi)
c0006fcc:	fe 47 46             	incb   0x46(%edi)
c0006fcf:	eb 0c                	jmp    c0006fdd <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x245>
                    continue;
                }
                s->remote_enqueue();
c0006fd1:	89 f8                	mov    %edi,%eax
c0006fd3:	e8 64 87 00 00       	call   c000f73c <_ZN2Sc14remote_enqueueEv>
c0006fd8:	eb 88                	jmp    c0006f62 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x1ca>
c0006fda:	fe 46 46             	incb   0x46(%esi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c0006fdd:	84 db                	test   %bl,%bl
c0006fdf:	74 15                	je     c0006ff6 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x25e>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0006fe1:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0006fe8:	0f 85 20 ff ff ff    	jne    c0006f0e <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x176>

            preemption = true;
c0006fee:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c0006ff5:	fb                   	sti    

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
c0006ff6:	8b 1d 08 f0 ff cf    	mov    0xcffff008,%ebx
c0006ffc:	8b 53 14             	mov    0x14(%ebx),%edx
    current->utcb    = nullptr;
    current->fpu     = nullptr;

    Rcu::call(current);
c0006fff:	8d 73 0c             	lea    0xc(%ebx),%esi
    assert (current->utcb);
    assert (Sc::current->ec == current);

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
c0007002:	c7 83 b0 00 00 00 00 	movl   $0x0,0xb0(%ebx)
c0007009:	00 00 00 
    current->utcb    = nullptr;
c000700c:	c7 83 b4 00 00 00 00 	movl   $0x0,0xb4(%ebx)
c0007013:	00 00 00 
    current->fpu     = nullptr;
c0007016:	c7 83 c8 00 00 00 00 	movl   $0x0,0xc8(%ebx)
c000701d:	00 00 00 
c0007020:	85 d2                	test   %edx,%edx
c0007022:	74 04                	je     c0007028 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x290>
                e->pre_func(e);
c0007024:	89 f0                	mov    %esi,%eax
c0007026:	ff d2                	call   *%edx
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
c0007028:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
c000702c:	75 09                	jne    c0007037 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x29f>
c000702e:	a1 f0 f7 ff cf       	mov    0xcffff7f0,%eax
c0007033:	39 f0                	cmp    %esi,%eax
c0007035:	75 29                	jne    c0007060 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x2c8>
                trace (0, "warning: rcu element already enqueued");
c0007037:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c000703b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0007040:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c0007045:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000704a:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0007051:	50                   	push   %eax
c0007052:	68 ae 6c 01 c0       	push   $0xc0016cae
c0007057:	e8 82 a9 ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c000705c:	59                   	pop    %ecx
c000705d:	5b                   	pop    %ebx
c000705e:	eb 0e                	jmp    c000706e <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x2d6>
                return;
            }

            count ++;
c0007060:	ff 05 f4 f7 ff cf    	incl   0xcffff7f4

           *tail = e;
c0007066:	89 30                	mov    %esi,(%eax)
            tail = &e->next;
c0007068:	89 35 f0 f7 ff cf    	mov    %esi,0xcffff7f0

    Rcu::call(current);
    Rcu::call(Sc::current);
c000706e:	8b 35 10 f0 ff cf    	mov    0xcffff010,%esi
c0007074:	85 f6                	test   %esi,%esi
c0007076:	74 63                	je     c00070db <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x343>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
c0007078:	8b 56 14             	mov    0x14(%esi),%edx
c000707b:	8d 5e 0c             	lea    0xc(%esi),%ebx
c000707e:	85 d2                	test   %edx,%edx
c0007080:	74 04                	je     c0007086 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x2ee>
                e->pre_func(e);
c0007082:	89 d8                	mov    %ebx,%eax
c0007084:	ff d2                	call   *%edx
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
c0007086:	83 7e 0c 00          	cmpl   $0x0,0xc(%esi)
c000708a:	75 09                	jne    c0007095 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x2fd>
c000708c:	a1 f0 f7 ff cf       	mov    0xcffff7f0,%eax
c0007091:	39 d8                	cmp    %ebx,%eax
c0007093:	75 29                	jne    c00070be <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x326>
                trace (0, "warning: rcu element already enqueued");
c0007095:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c0007099:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c000709e:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c00070a3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00070a8:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c00070af:	50                   	push   %eax
c00070b0:	68 ae 6c 01 c0       	push   $0xc0016cae
c00070b5:	e8 24 a9 ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c00070ba:	58                   	pop    %eax
c00070bb:	5a                   	pop    %edx
c00070bc:	eb 0e                	jmp    c00070cc <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x334>
                return;
            }

            count ++;
c00070be:	ff 05 f4 f7 ff cf    	incl   0xcffff7f4

           *tail = e;
c00070c4:	89 18                	mov    %ebx,(%eax)
            tail = &e->next;
c00070c6:	89 1d f0 f7 ff cf    	mov    %ebx,0xcffff7f0

    Sc::schedule(true);
c00070cc:	ba 01 00 00 00       	mov    $0x1,%edx
c00070d1:	b8 01 00 00 00       	mov    $0x1,%eax
c00070d6:	e8 d7 88 00 00       	call   c000f9b2 <_ZN2Sc8scheduleEbb>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
c00070db:	a1 08 00 00 00       	mov    0x8,%eax
c00070e0:	0f 0b                	ud2    

c00070e2 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv>:

    die ("XCPU OOM error");
}

template <void (*C)()>
void Ec::oom_xcpu_return()
c00070e2:	57                   	push   %edi
c00070e3:	56                   	push   %esi
c00070e4:	53                   	push   %ebx
c00070e5:	56                   	push   %esi
{
    assert (current->xcpu_sm);
c00070e6:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c00070eb:	8b b8 f4 00 00 00    	mov    0xf4(%eax),%edi
c00070f1:	85 ff                	test   %edi,%edi
c00070f3:	75 16                	jne    c000710b <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x29>
c00070f5:	68 40 7e 01 c0       	push   $0xc0017e40
c00070fa:	68 87 00 00 00       	push   $0x87
c00070ff:	68 a3 72 01 c0       	push   $0xc00172a3
c0007104:	68 66 6c 01 c0       	push   $0xc0016c66
c0007109:	eb 1d                	jmp    c0007128 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x46>
    assert (current->rcap);
c000710b:	83 b8 b0 00 00 00 00 	cmpl   $0x0,0xb0(%eax)
c0007112:	75 1e                	jne    c0007132 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x50>
c0007114:	68 40 7e 01 c0       	push   $0xc0017e40
c0007119:	68 88 00 00 00       	push   $0x88
c000711e:	68 a3 72 01 c0       	push   $0xc00172a3
c0007123:	68 77 6c 01 c0       	push   $0xc0016c77
c0007128:	68 69 60 01 c0       	push   $0xc0016069
c000712d:	e8 14 a8 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>
    assert (current->utcb);
c0007132:	83 b8 b4 00 00 00 00 	cmpl   $0x0,0xb4(%eax)
c0007139:	75 16                	jne    c0007151 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x6f>
c000713b:	68 40 7e 01 c0       	push   $0xc0017e40
c0007140:	68 89 00 00 00       	push   $0x89
c0007145:	68 a3 72 01 c0       	push   $0xc00172a3
c000714a:	68 85 6c 01 c0       	push   $0xc0016c85
c000714f:	eb d7                	jmp    c0007128 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x46>
c0007151:	8b 15 10 f0 ff cf    	mov    0xcffff010,%edx
    assert (Sc::current->ec == current);
c0007157:	39 42 4c             	cmp    %eax,0x4c(%edx)
c000715a:	74 16                	je     c0007172 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x90>
c000715c:	68 40 7e 01 c0       	push   $0xc0017e40
c0007161:	68 8a 00 00 00       	push   $0x8a
c0007166:	68 a3 72 01 c0       	push   $0xc00172a3
c000716b:	68 93 6c 01 c0       	push   $0xc0016c93
c0007170:	eb b6                	jmp    c0007128 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x46>
        ALWAYS_INLINE
        inline void up (void (*c)() = nullptr, Sm * si = nullptr)
        {
            Ec *ec;

            {   Lock_guard <Spinlock> guard (lock);
c0007172:	8d 47 46             	lea    0x46(%edi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c0007175:	9c                   	pushf  
c0007176:	5b                   	pop    %ebx
            return flags & 0x200;
c0007177:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c000717a:	80 e3 01             	and    $0x1,%bl
c000717d:	74 27                	je     c00071a6 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0xc4>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c000717f:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0007186:	75 16                	jne    c000719e <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0xbc>
c0007188:	68 80 85 01 c0       	push   $0xc0018580
c000718d:	68 b7 00 00 00       	push   $0xb7
c0007192:	68 12 61 01 c0       	push   $0xc0016112
c0007197:	68 83 61 01 c0       	push   $0xc0016183
c000719c:	eb 8a                	jmp    c0007128 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x46>

            asm volatile ("cli" : : : "memory");
c000719e:	fa                   	cli    
            preemption = false;
c000719f:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c00071a6:	e8 81 99 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c00071ab:	8b 77 4c             	mov    0x4c(%edi),%esi
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c00071ae:	85 f6                	test   %esi,%esi
c00071b0:	0f 84 5d 01 00 00    	je     c0007313 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x231>
c00071b6:	8b 86 c4 00 00 00    	mov    0xc4(%esi),%eax
c00071bc:	85 c0                	test   %eax,%eax
c00071be:	0f 84 4f 01 00 00    	je     c0007313 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x231>
c00071c4:	8b 96 c0 00 00 00    	mov    0xc0(%esi),%edx
c00071ca:	85 d2                	test   %edx,%edx
c00071cc:	0f 84 41 01 00 00    	je     c0007313 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x231>
                return false;

            if (t == t->next)
c00071d2:	39 c6                	cmp    %eax,%esi
c00071d4:	75 09                	jne    c00071df <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0xfd>
                headptr = nullptr;
c00071d6:	c7 47 4c 00 00 00 00 	movl   $0x0,0x4c(%edi)
c00071dd:	eb 26                	jmp    c0007205 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x123>

            else {
                t->next->prev = t->prev;
c00071df:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
                t->prev->next = t->next;
c00071e5:	8b 86 c0 00 00 00    	mov    0xc0(%esi),%eax
c00071eb:	8b 96 c4 00 00 00    	mov    0xc4(%esi),%edx
c00071f1:	89 90 c4 00 00 00    	mov    %edx,0xc4(%eax)
                if (t == headptr)
c00071f7:	3b 77 4c             	cmp    0x4c(%edi),%esi
c00071fa:	75 09                	jne    c0007205 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x123>
                    headptr = t->next;
c00071fc:	8b 86 c4 00 00 00    	mov    0xc4(%esi),%eax
c0007202:	89 47 4c             	mov    %eax,0x4c(%edi)
            }

            t->next = t->prev = nullptr;
c0007205:	c7 86 c0 00 00 00 00 	movl   $0x0,0xc0(%esi)
c000720c:	00 00 00 
c000720f:	83 c8 ff             	or     $0xffffffff,%eax
c0007212:	c7 86 c4 00 00 00 00 	movl   $0x0,0xc4(%esi)
c0007219:	00 00 00 
c000721c:	f0 0f c1 46 48       	lock xadd %eax,0x48(%esi)

                    counter++;
                    return;
                }

                if (EXPECT_FALSE(ec->del_ref())) {
c0007221:	48                   	dec    %eax
c0007222:	75 24                	jne    c0007248 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x166>
                    delete ec;
c0007224:	89 f0                	mov    %esi,%eax
c0007226:	e8 e3 c2 ff ff       	call   c000350e <_ZN2EcD1Ev>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c000722b:	8b 86 b8 00 00 00    	mov    0xb8(%esi),%eax
c0007231:	89 f2                	mov    %esi,%edx
c0007233:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c0007239:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c000723e:	e8 1d 91 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
c0007243:	e9 63 ff ff ff       	jmp    c00071ab <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0xc9>
c0007248:	fe 47 46             	incb   0x46(%edi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c000724b:	84 db                	test   %bl,%bl
c000724d:	74 2a                	je     c0007279 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x197>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000724f:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0007256:	74 19                	je     c0007271 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x18f>
c0007258:	68 40 85 01 c0       	push   $0xc0018540
c000725d:	68 c0 00 00 00       	push   $0xc0
c0007262:	68 12 61 01 c0       	push   $0xc0016112
c0007267:	68 82 61 01 c0       	push   $0xc0016182
c000726c:	e9 b7 fe ff ff       	jmp    c0007128 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x46>

            preemption = true;
c0007271:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c0007278:	fb                   	sti    
        }

        ALWAYS_INLINE
        inline void release (void (*c)())
        {
            if (c)
c0007279:	b8 9a 8e 00 c0       	mov    $0xc0008e9a,%eax
c000727e:	85 c0                	test   %eax,%eax
c0007280:	74 03                	je     c0007285 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x1a3>
                cont = c;
c0007282:	89 46 50             	mov    %eax,0x50(%esi)

            Lock_guard <Spinlock> guard (lock);
c0007285:	8d 46 46             	lea    0x46(%esi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c0007288:	9c                   	pushf  
c0007289:	5b                   	pop    %ebx
            return flags & 0x200;
c000728a:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c000728d:	80 e3 01             	and    $0x1,%bl
c0007290:	74 15                	je     c00072a7 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x1c5>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0007292:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0007299:	0f 84 e9 fe ff ff    	je     c0007188 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0xa6>

            asm volatile ("cli" : : : "memory");
c000729f:	fa                   	cli    
            preemption = false;
c00072a0:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c00072a7:	e8 80 98 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c00072ac:	8b 7e 4c             	mov    0x4c(%esi),%edi
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c00072af:	85 ff                	test   %edi,%edi
c00072b1:	74 71                	je     c0007324 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x242>
c00072b3:	8b 47 74             	mov    0x74(%edi),%eax
c00072b6:	85 c0                	test   %eax,%eax
c00072b8:	74 6a                	je     c0007324 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x242>
c00072ba:	8b 57 70             	mov    0x70(%edi),%edx
c00072bd:	85 d2                	test   %edx,%edx
c00072bf:	74 63                	je     c0007324 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x242>
                return false;

            if (t == t->next)
c00072c1:	39 c7                	cmp    %eax,%edi
c00072c3:	75 09                	jne    c00072ce <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x1ec>
                headptr = nullptr;
c00072c5:	c7 46 4c 00 00 00 00 	movl   $0x0,0x4c(%esi)
c00072cc:	eb 17                	jmp    c00072e5 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x203>

            else {
                t->next->prev = t->prev;
c00072ce:	89 50 70             	mov    %edx,0x70(%eax)
                t->prev->next = t->next;
c00072d1:	8b 47 70             	mov    0x70(%edi),%eax
c00072d4:	8b 57 74             	mov    0x74(%edi),%edx
c00072d7:	89 50 74             	mov    %edx,0x74(%eax)
                if (t == headptr)
c00072da:	3b 7e 4c             	cmp    0x4c(%esi),%edi
c00072dd:	75 06                	jne    c00072e5 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x203>
                    headptr = t->next;
c00072df:	8b 47 74             	mov    0x74(%edi),%eax
c00072e2:	89 46 4c             	mov    %eax,0x4c(%esi)
            }

            t->next = t->prev = nullptr;
c00072e5:	c7 47 70 00 00 00 00 	movl   $0x0,0x70(%edi)
c00072ec:	83 c8 ff             	or     $0xffffffff,%eax
c00072ef:	c7 47 74 00 00 00 00 	movl   $0x0,0x74(%edi)
c00072f6:	f0 0f c1 47 48       	lock xadd %eax,0x48(%edi)

            for (Sc *s; dequeue (s = head()); ) {
                if (EXPECT_FALSE(s->del_ref()) && (this == s->ec)) {
c00072fb:	48                   	dec    %eax
c00072fc:	75 1d                	jne    c000731b <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x239>
c00072fe:	3b 77 4c             	cmp    0x4c(%edi),%esi
c0007301:	75 18                	jne    c000731b <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x239>
                    delete s;
c0007303:	89 f8                	mov    %edi,%eax
c0007305:	e8 70 f0 ff ff       	call   c000637a <_ZN2ScD1Ev>
c000730a:	89 f8                	mov    %edi,%eax
c000730c:	e8 34 86 00 00       	call   c000f945 <_ZN2ScdlEPv>
c0007311:	eb 99                	jmp    c00072ac <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x1ca>
                    if (si) {
                       if (si->queued()) return;
                       Queue<Si>::enqueue(si);
                    }

                    counter++;
c0007313:	ff 47 64             	incl   0x64(%edi)
c0007316:	fe 47 46             	incb   0x46(%edi)
c0007319:	eb 0c                	jmp    c0007327 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x245>
                    continue;
                }
                s->remote_enqueue();
c000731b:	89 f8                	mov    %edi,%eax
c000731d:	e8 1a 84 00 00       	call   c000f73c <_ZN2Sc14remote_enqueueEv>
c0007322:	eb 88                	jmp    c00072ac <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x1ca>
c0007324:	fe 46 46             	incb   0x46(%esi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c0007327:	84 db                	test   %bl,%bl
c0007329:	74 15                	je     c0007340 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x25e>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000732b:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0007332:	0f 85 20 ff ff ff    	jne    c0007258 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x176>

            preemption = true;
c0007338:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000733f:	fb                   	sti    

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
c0007340:	8b 1d 08 f0 ff cf    	mov    0xcffff008,%ebx
c0007346:	8b 53 14             	mov    0x14(%ebx),%edx
    current->utcb    = nullptr;
    current->fpu     = nullptr;

    Rcu::call(current);
c0007349:	8d 73 0c             	lea    0xc(%ebx),%esi
    assert (current->utcb);
    assert (Sc::current->ec == current);

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
c000734c:	c7 83 b0 00 00 00 00 	movl   $0x0,0xb0(%ebx)
c0007353:	00 00 00 
    current->utcb    = nullptr;
c0007356:	c7 83 b4 00 00 00 00 	movl   $0x0,0xb4(%ebx)
c000735d:	00 00 00 
    current->fpu     = nullptr;
c0007360:	c7 83 c8 00 00 00 00 	movl   $0x0,0xc8(%ebx)
c0007367:	00 00 00 
c000736a:	85 d2                	test   %edx,%edx
c000736c:	74 04                	je     c0007372 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x290>
                e->pre_func(e);
c000736e:	89 f0                	mov    %esi,%eax
c0007370:	ff d2                	call   *%edx
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
c0007372:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
c0007376:	75 09                	jne    c0007381 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x29f>
c0007378:	a1 f0 f7 ff cf       	mov    0xcffff7f0,%eax
c000737d:	39 f0                	cmp    %esi,%eax
c000737f:	75 29                	jne    c00073aa <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x2c8>
                trace (0, "warning: rcu element already enqueued");
c0007381:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c0007385:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c000738a:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c000738f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0007394:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c000739b:	50                   	push   %eax
c000739c:	68 ae 6c 01 c0       	push   $0xc0016cae
c00073a1:	e8 38 a6 ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c00073a6:	59                   	pop    %ecx
c00073a7:	5b                   	pop    %ebx
c00073a8:	eb 0e                	jmp    c00073b8 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x2d6>
                return;
            }

            count ++;
c00073aa:	ff 05 f4 f7 ff cf    	incl   0xcffff7f4

           *tail = e;
c00073b0:	89 30                	mov    %esi,(%eax)
            tail = &e->next;
c00073b2:	89 35 f0 f7 ff cf    	mov    %esi,0xcffff7f0

    Rcu::call(current);
    Rcu::call(Sc::current);
c00073b8:	8b 35 10 f0 ff cf    	mov    0xcffff010,%esi
c00073be:	85 f6                	test   %esi,%esi
c00073c0:	74 63                	je     c0007425 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x343>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
c00073c2:	8b 56 14             	mov    0x14(%esi),%edx
c00073c5:	8d 5e 0c             	lea    0xc(%esi),%ebx
c00073c8:	85 d2                	test   %edx,%edx
c00073ca:	74 04                	je     c00073d0 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x2ee>
                e->pre_func(e);
c00073cc:	89 d8                	mov    %ebx,%eax
c00073ce:	ff d2                	call   *%edx
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
c00073d0:	83 7e 0c 00          	cmpl   $0x0,0xc(%esi)
c00073d4:	75 09                	jne    c00073df <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x2fd>
c00073d6:	a1 f0 f7 ff cf       	mov    0xcffff7f0,%eax
c00073db:	39 d8                	cmp    %ebx,%eax
c00073dd:	75 29                	jne    c0007408 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x326>
                trace (0, "warning: rcu element already enqueued");
c00073df:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c00073e3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c00073e8:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c00073ed:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00073f2:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c00073f9:	50                   	push   %eax
c00073fa:	68 ae 6c 01 c0       	push   $0xc0016cae
c00073ff:	e8 da a5 ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c0007404:	58                   	pop    %eax
c0007405:	5a                   	pop    %edx
c0007406:	eb 0e                	jmp    c0007416 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x334>
                return;
            }

            count ++;
c0007408:	ff 05 f4 f7 ff cf    	incl   0xcffff7f4

           *tail = e;
c000740e:	89 18                	mov    %ebx,(%eax)
            tail = &e->next;
c0007410:	89 1d f0 f7 ff cf    	mov    %ebx,0xcffff7f0

    Sc::schedule(true);
c0007416:	ba 01 00 00 00       	mov    $0x1,%edx
c000741b:	b8 01 00 00 00       	mov    $0x1,%eax
c0007420:	e8 8d 85 00 00       	call   c000f9b2 <_ZN2Sc8scheduleEbb>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
c0007425:	a1 08 00 00 00       	mov    0x8,%eax
c000742a:	0f 0b                	ud2    

c000742c <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv>:

    die ("XCPU OOM error");
}

template <void (*C)()>
void Ec::oom_xcpu_return()
c000742c:	57                   	push   %edi
c000742d:	56                   	push   %esi
c000742e:	53                   	push   %ebx
c000742f:	56                   	push   %esi
{
    assert (current->xcpu_sm);
c0007430:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0007435:	8b b8 f4 00 00 00    	mov    0xf4(%eax),%edi
c000743b:	85 ff                	test   %edi,%edi
c000743d:	75 16                	jne    c0007455 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x29>
c000743f:	68 80 7c 01 c0       	push   $0xc0017c80
c0007444:	68 87 00 00 00       	push   $0x87
c0007449:	68 a3 72 01 c0       	push   $0xc00172a3
c000744e:	68 66 6c 01 c0       	push   $0xc0016c66
c0007453:	eb 1d                	jmp    c0007472 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x46>
    assert (current->rcap);
c0007455:	83 b8 b0 00 00 00 00 	cmpl   $0x0,0xb0(%eax)
c000745c:	75 1e                	jne    c000747c <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x50>
c000745e:	68 80 7c 01 c0       	push   $0xc0017c80
c0007463:	68 88 00 00 00       	push   $0x88
c0007468:	68 a3 72 01 c0       	push   $0xc00172a3
c000746d:	68 77 6c 01 c0       	push   $0xc0016c77
c0007472:	68 69 60 01 c0       	push   $0xc0016069
c0007477:	e8 ca a4 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>
    assert (current->utcb);
c000747c:	83 b8 b4 00 00 00 00 	cmpl   $0x0,0xb4(%eax)
c0007483:	75 16                	jne    c000749b <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x6f>
c0007485:	68 80 7c 01 c0       	push   $0xc0017c80
c000748a:	68 89 00 00 00       	push   $0x89
c000748f:	68 a3 72 01 c0       	push   $0xc00172a3
c0007494:	68 85 6c 01 c0       	push   $0xc0016c85
c0007499:	eb d7                	jmp    c0007472 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x46>
c000749b:	8b 15 10 f0 ff cf    	mov    0xcffff010,%edx
    assert (Sc::current->ec == current);
c00074a1:	39 42 4c             	cmp    %eax,0x4c(%edx)
c00074a4:	74 16                	je     c00074bc <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x90>
c00074a6:	68 80 7c 01 c0       	push   $0xc0017c80
c00074ab:	68 8a 00 00 00       	push   $0x8a
c00074b0:	68 a3 72 01 c0       	push   $0xc00172a3
c00074b5:	68 93 6c 01 c0       	push   $0xc0016c93
c00074ba:	eb b6                	jmp    c0007472 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x46>
        ALWAYS_INLINE
        inline void up (void (*c)() = nullptr, Sm * si = nullptr)
        {
            Ec *ec;

            {   Lock_guard <Spinlock> guard (lock);
c00074bc:	8d 47 46             	lea    0x46(%edi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c00074bf:	9c                   	pushf  
c00074c0:	5b                   	pop    %ebx
            return flags & 0x200;
c00074c1:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c00074c4:	80 e3 01             	and    $0x1,%bl
c00074c7:	74 27                	je     c00074f0 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0xc4>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c00074c9:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c00074d0:	75 16                	jne    c00074e8 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0xbc>
c00074d2:	68 80 85 01 c0       	push   $0xc0018580
c00074d7:	68 b7 00 00 00       	push   $0xb7
c00074dc:	68 12 61 01 c0       	push   $0xc0016112
c00074e1:	68 83 61 01 c0       	push   $0xc0016183
c00074e6:	eb 8a                	jmp    c0007472 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x46>

            asm volatile ("cli" : : : "memory");
c00074e8:	fa                   	cli    
            preemption = false;
c00074e9:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c00074f0:	e8 37 96 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c00074f5:	8b 77 4c             	mov    0x4c(%edi),%esi
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c00074f8:	85 f6                	test   %esi,%esi
c00074fa:	0f 84 5d 01 00 00    	je     c000765d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x231>
c0007500:	8b 86 c4 00 00 00    	mov    0xc4(%esi),%eax
c0007506:	85 c0                	test   %eax,%eax
c0007508:	0f 84 4f 01 00 00    	je     c000765d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x231>
c000750e:	8b 96 c0 00 00 00    	mov    0xc0(%esi),%edx
c0007514:	85 d2                	test   %edx,%edx
c0007516:	0f 84 41 01 00 00    	je     c000765d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x231>
                return false;

            if (t == t->next)
c000751c:	39 c6                	cmp    %eax,%esi
c000751e:	75 09                	jne    c0007529 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0xfd>
                headptr = nullptr;
c0007520:	c7 47 4c 00 00 00 00 	movl   $0x0,0x4c(%edi)
c0007527:	eb 26                	jmp    c000754f <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x123>

            else {
                t->next->prev = t->prev;
c0007529:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
                t->prev->next = t->next;
c000752f:	8b 86 c0 00 00 00    	mov    0xc0(%esi),%eax
c0007535:	8b 96 c4 00 00 00    	mov    0xc4(%esi),%edx
c000753b:	89 90 c4 00 00 00    	mov    %edx,0xc4(%eax)
                if (t == headptr)
c0007541:	3b 77 4c             	cmp    0x4c(%edi),%esi
c0007544:	75 09                	jne    c000754f <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x123>
                    headptr = t->next;
c0007546:	8b 86 c4 00 00 00    	mov    0xc4(%esi),%eax
c000754c:	89 47 4c             	mov    %eax,0x4c(%edi)
            }

            t->next = t->prev = nullptr;
c000754f:	c7 86 c0 00 00 00 00 	movl   $0x0,0xc0(%esi)
c0007556:	00 00 00 
c0007559:	83 c8 ff             	or     $0xffffffff,%eax
c000755c:	c7 86 c4 00 00 00 00 	movl   $0x0,0xc4(%esi)
c0007563:	00 00 00 
c0007566:	f0 0f c1 46 48       	lock xadd %eax,0x48(%esi)

                    counter++;
                    return;
                }

                if (EXPECT_FALSE(ec->del_ref())) {
c000756b:	48                   	dec    %eax
c000756c:	75 24                	jne    c0007592 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x166>
                    delete ec;
c000756e:	89 f0                	mov    %esi,%eax
c0007570:	e8 99 bf ff ff       	call   c000350e <_ZN2EcD1Ev>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c0007575:	8b 86 b8 00 00 00    	mov    0xb8(%esi),%eax
c000757b:	89 f2                	mov    %esi,%edx
c000757d:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c0007583:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c0007588:	e8 d3 8d 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
c000758d:	e9 63 ff ff ff       	jmp    c00074f5 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0xc9>
c0007592:	fe 47 46             	incb   0x46(%edi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c0007595:	84 db                	test   %bl,%bl
c0007597:	74 2a                	je     c00075c3 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x197>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0007599:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c00075a0:	74 19                	je     c00075bb <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x18f>
c00075a2:	68 40 85 01 c0       	push   $0xc0018540
c00075a7:	68 c0 00 00 00       	push   $0xc0
c00075ac:	68 12 61 01 c0       	push   $0xc0016112
c00075b1:	68 82 61 01 c0       	push   $0xc0016182
c00075b6:	e9 b7 fe ff ff       	jmp    c0007472 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x46>

            preemption = true;
c00075bb:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c00075c2:	fb                   	sti    
        }

        ALWAYS_INLINE
        inline void release (void (*c)())
        {
            if (c)
c00075c3:	b8 3a 90 00 c0       	mov    $0xc000903a,%eax
c00075c8:	85 c0                	test   %eax,%eax
c00075ca:	74 03                	je     c00075cf <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x1a3>
                cont = c;
c00075cc:	89 46 50             	mov    %eax,0x50(%esi)

            Lock_guard <Spinlock> guard (lock);
c00075cf:	8d 46 46             	lea    0x46(%esi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c00075d2:	9c                   	pushf  
c00075d3:	5b                   	pop    %ebx
            return flags & 0x200;
c00075d4:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c00075d7:	80 e3 01             	and    $0x1,%bl
c00075da:	74 15                	je     c00075f1 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x1c5>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c00075dc:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c00075e3:	0f 84 e9 fe ff ff    	je     c00074d2 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0xa6>

            asm volatile ("cli" : : : "memory");
c00075e9:	fa                   	cli    
            preemption = false;
c00075ea:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c00075f1:	e8 36 95 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c00075f6:	8b 7e 4c             	mov    0x4c(%esi),%edi
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c00075f9:	85 ff                	test   %edi,%edi
c00075fb:	74 71                	je     c000766e <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x242>
c00075fd:	8b 47 74             	mov    0x74(%edi),%eax
c0007600:	85 c0                	test   %eax,%eax
c0007602:	74 6a                	je     c000766e <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x242>
c0007604:	8b 57 70             	mov    0x70(%edi),%edx
c0007607:	85 d2                	test   %edx,%edx
c0007609:	74 63                	je     c000766e <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x242>
                return false;

            if (t == t->next)
c000760b:	39 c7                	cmp    %eax,%edi
c000760d:	75 09                	jne    c0007618 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x1ec>
                headptr = nullptr;
c000760f:	c7 46 4c 00 00 00 00 	movl   $0x0,0x4c(%esi)
c0007616:	eb 17                	jmp    c000762f <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x203>

            else {
                t->next->prev = t->prev;
c0007618:	89 50 70             	mov    %edx,0x70(%eax)
                t->prev->next = t->next;
c000761b:	8b 47 70             	mov    0x70(%edi),%eax
c000761e:	8b 57 74             	mov    0x74(%edi),%edx
c0007621:	89 50 74             	mov    %edx,0x74(%eax)
                if (t == headptr)
c0007624:	3b 7e 4c             	cmp    0x4c(%esi),%edi
c0007627:	75 06                	jne    c000762f <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x203>
                    headptr = t->next;
c0007629:	8b 47 74             	mov    0x74(%edi),%eax
c000762c:	89 46 4c             	mov    %eax,0x4c(%esi)
            }

            t->next = t->prev = nullptr;
c000762f:	c7 47 70 00 00 00 00 	movl   $0x0,0x70(%edi)
c0007636:	83 c8 ff             	or     $0xffffffff,%eax
c0007639:	c7 47 74 00 00 00 00 	movl   $0x0,0x74(%edi)
c0007640:	f0 0f c1 47 48       	lock xadd %eax,0x48(%edi)

            for (Sc *s; dequeue (s = head()); ) {
                if (EXPECT_FALSE(s->del_ref()) && (this == s->ec)) {
c0007645:	48                   	dec    %eax
c0007646:	75 1d                	jne    c0007665 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x239>
c0007648:	3b 77 4c             	cmp    0x4c(%edi),%esi
c000764b:	75 18                	jne    c0007665 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x239>
                    delete s;
c000764d:	89 f8                	mov    %edi,%eax
c000764f:	e8 26 ed ff ff       	call   c000637a <_ZN2ScD1Ev>
c0007654:	89 f8                	mov    %edi,%eax
c0007656:	e8 ea 82 00 00       	call   c000f945 <_ZN2ScdlEPv>
c000765b:	eb 99                	jmp    c00075f6 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x1ca>
                    if (si) {
                       if (si->queued()) return;
                       Queue<Si>::enqueue(si);
                    }

                    counter++;
c000765d:	ff 47 64             	incl   0x64(%edi)
c0007660:	fe 47 46             	incb   0x46(%edi)
c0007663:	eb 0c                	jmp    c0007671 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x245>
                    continue;
                }
                s->remote_enqueue();
c0007665:	89 f8                	mov    %edi,%eax
c0007667:	e8 d0 80 00 00       	call   c000f73c <_ZN2Sc14remote_enqueueEv>
c000766c:	eb 88                	jmp    c00075f6 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x1ca>
c000766e:	fe 46 46             	incb   0x46(%esi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c0007671:	84 db                	test   %bl,%bl
c0007673:	74 15                	je     c000768a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x25e>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0007675:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000767c:	0f 85 20 ff ff ff    	jne    c00075a2 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x176>

            preemption = true;
c0007682:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c0007689:	fb                   	sti    

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
c000768a:	8b 1d 08 f0 ff cf    	mov    0xcffff008,%ebx
c0007690:	8b 53 14             	mov    0x14(%ebx),%edx
    current->utcb    = nullptr;
    current->fpu     = nullptr;

    Rcu::call(current);
c0007693:	8d 73 0c             	lea    0xc(%ebx),%esi
    assert (current->utcb);
    assert (Sc::current->ec == current);

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
c0007696:	c7 83 b0 00 00 00 00 	movl   $0x0,0xb0(%ebx)
c000769d:	00 00 00 
    current->utcb    = nullptr;
c00076a0:	c7 83 b4 00 00 00 00 	movl   $0x0,0xb4(%ebx)
c00076a7:	00 00 00 
    current->fpu     = nullptr;
c00076aa:	c7 83 c8 00 00 00 00 	movl   $0x0,0xc8(%ebx)
c00076b1:	00 00 00 
c00076b4:	85 d2                	test   %edx,%edx
c00076b6:	74 04                	je     c00076bc <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x290>
                e->pre_func(e);
c00076b8:	89 f0                	mov    %esi,%eax
c00076ba:	ff d2                	call   *%edx
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
c00076bc:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
c00076c0:	75 09                	jne    c00076cb <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x29f>
c00076c2:	a1 f0 f7 ff cf       	mov    0xcffff7f0,%eax
c00076c7:	39 f0                	cmp    %esi,%eax
c00076c9:	75 29                	jne    c00076f4 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x2c8>
                trace (0, "warning: rcu element already enqueued");
c00076cb:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c00076cf:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c00076d4:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c00076d9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00076de:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c00076e5:	50                   	push   %eax
c00076e6:	68 ae 6c 01 c0       	push   $0xc0016cae
c00076eb:	e8 ee a2 ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c00076f0:	59                   	pop    %ecx
c00076f1:	5b                   	pop    %ebx
c00076f2:	eb 0e                	jmp    c0007702 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x2d6>
                return;
            }

            count ++;
c00076f4:	ff 05 f4 f7 ff cf    	incl   0xcffff7f4

           *tail = e;
c00076fa:	89 30                	mov    %esi,(%eax)
            tail = &e->next;
c00076fc:	89 35 f0 f7 ff cf    	mov    %esi,0xcffff7f0

    Rcu::call(current);
    Rcu::call(Sc::current);
c0007702:	8b 35 10 f0 ff cf    	mov    0xcffff010,%esi
c0007708:	85 f6                	test   %esi,%esi
c000770a:	74 63                	je     c000776f <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x343>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
c000770c:	8b 56 14             	mov    0x14(%esi),%edx
c000770f:	8d 5e 0c             	lea    0xc(%esi),%ebx
c0007712:	85 d2                	test   %edx,%edx
c0007714:	74 04                	je     c000771a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x2ee>
                e->pre_func(e);
c0007716:	89 d8                	mov    %ebx,%eax
c0007718:	ff d2                	call   *%edx
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
c000771a:	83 7e 0c 00          	cmpl   $0x0,0xc(%esi)
c000771e:	75 09                	jne    c0007729 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x2fd>
c0007720:	a1 f0 f7 ff cf       	mov    0xcffff7f0,%eax
c0007725:	39 d8                	cmp    %ebx,%eax
c0007727:	75 29                	jne    c0007752 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x326>
                trace (0, "warning: rcu element already enqueued");
c0007729:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c000772d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0007732:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c0007737:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000773c:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0007743:	50                   	push   %eax
c0007744:	68 ae 6c 01 c0       	push   $0xc0016cae
c0007749:	e8 90 a2 ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c000774e:	58                   	pop    %eax
c000774f:	5a                   	pop    %edx
c0007750:	eb 0e                	jmp    c0007760 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x334>
                return;
            }

            count ++;
c0007752:	ff 05 f4 f7 ff cf    	incl   0xcffff7f4

           *tail = e;
c0007758:	89 18                	mov    %ebx,(%eax)
            tail = &e->next;
c000775a:	89 1d f0 f7 ff cf    	mov    %ebx,0xcffff7f0

    Sc::schedule(true);
c0007760:	ba 01 00 00 00       	mov    $0x1,%edx
c0007765:	b8 01 00 00 00       	mov    $0x1,%eax
c000776a:	e8 43 82 00 00       	call   c000f9b2 <_ZN2Sc8scheduleEbb>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
c000776f:	a1 08 00 00 00       	mov    0x8,%eax
c0007774:	0f 0b                	ud2    

c0007776 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv>:

    die ("XCPU OOM error");
}

template <void (*C)()>
void Ec::oom_xcpu_return()
c0007776:	57                   	push   %edi
c0007777:	56                   	push   %esi
c0007778:	53                   	push   %ebx
c0007779:	56                   	push   %esi
{
    assert (current->xcpu_sm);
c000777a:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c000777f:	8b b8 f4 00 00 00    	mov    0xf4(%eax),%edi
c0007785:	85 ff                	test   %edi,%edi
c0007787:	75 16                	jne    c000779f <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x29>
c0007789:	68 c0 7a 01 c0       	push   $0xc0017ac0
c000778e:	68 87 00 00 00       	push   $0x87
c0007793:	68 a3 72 01 c0       	push   $0xc00172a3
c0007798:	68 66 6c 01 c0       	push   $0xc0016c66
c000779d:	eb 1d                	jmp    c00077bc <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x46>
    assert (current->rcap);
c000779f:	83 b8 b0 00 00 00 00 	cmpl   $0x0,0xb0(%eax)
c00077a6:	75 1e                	jne    c00077c6 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x50>
c00077a8:	68 c0 7a 01 c0       	push   $0xc0017ac0
c00077ad:	68 88 00 00 00       	push   $0x88
c00077b2:	68 a3 72 01 c0       	push   $0xc00172a3
c00077b7:	68 77 6c 01 c0       	push   $0xc0016c77
c00077bc:	68 69 60 01 c0       	push   $0xc0016069
c00077c1:	e8 80 a1 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>
    assert (current->utcb);
c00077c6:	83 b8 b4 00 00 00 00 	cmpl   $0x0,0xb4(%eax)
c00077cd:	75 16                	jne    c00077e5 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x6f>
c00077cf:	68 c0 7a 01 c0       	push   $0xc0017ac0
c00077d4:	68 89 00 00 00       	push   $0x89
c00077d9:	68 a3 72 01 c0       	push   $0xc00172a3
c00077de:	68 85 6c 01 c0       	push   $0xc0016c85
c00077e3:	eb d7                	jmp    c00077bc <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x46>
c00077e5:	8b 15 10 f0 ff cf    	mov    0xcffff010,%edx
    assert (Sc::current->ec == current);
c00077eb:	39 42 4c             	cmp    %eax,0x4c(%edx)
c00077ee:	74 16                	je     c0007806 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x90>
c00077f0:	68 c0 7a 01 c0       	push   $0xc0017ac0
c00077f5:	68 8a 00 00 00       	push   $0x8a
c00077fa:	68 a3 72 01 c0       	push   $0xc00172a3
c00077ff:	68 93 6c 01 c0       	push   $0xc0016c93
c0007804:	eb b6                	jmp    c00077bc <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x46>
        ALWAYS_INLINE
        inline void up (void (*c)() = nullptr, Sm * si = nullptr)
        {
            Ec *ec;

            {   Lock_guard <Spinlock> guard (lock);
c0007806:	8d 47 46             	lea    0x46(%edi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c0007809:	9c                   	pushf  
c000780a:	5b                   	pop    %ebx
            return flags & 0x200;
c000780b:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c000780e:	80 e3 01             	and    $0x1,%bl
c0007811:	74 27                	je     c000783a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0xc4>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0007813:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000781a:	75 16                	jne    c0007832 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0xbc>
c000781c:	68 80 85 01 c0       	push   $0xc0018580
c0007821:	68 b7 00 00 00       	push   $0xb7
c0007826:	68 12 61 01 c0       	push   $0xc0016112
c000782b:	68 83 61 01 c0       	push   $0xc0016183
c0007830:	eb 8a                	jmp    c00077bc <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x46>

            asm volatile ("cli" : : : "memory");
c0007832:	fa                   	cli    
            preemption = false;
c0007833:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c000783a:	e8 ed 92 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c000783f:	8b 77 4c             	mov    0x4c(%edi),%esi
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c0007842:	85 f6                	test   %esi,%esi
c0007844:	0f 84 5d 01 00 00    	je     c00079a7 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x231>
c000784a:	8b 86 c4 00 00 00    	mov    0xc4(%esi),%eax
c0007850:	85 c0                	test   %eax,%eax
c0007852:	0f 84 4f 01 00 00    	je     c00079a7 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x231>
c0007858:	8b 96 c0 00 00 00    	mov    0xc0(%esi),%edx
c000785e:	85 d2                	test   %edx,%edx
c0007860:	0f 84 41 01 00 00    	je     c00079a7 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x231>
                return false;

            if (t == t->next)
c0007866:	39 c6                	cmp    %eax,%esi
c0007868:	75 09                	jne    c0007873 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0xfd>
                headptr = nullptr;
c000786a:	c7 47 4c 00 00 00 00 	movl   $0x0,0x4c(%edi)
c0007871:	eb 26                	jmp    c0007899 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x123>

            else {
                t->next->prev = t->prev;
c0007873:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
                t->prev->next = t->next;
c0007879:	8b 86 c0 00 00 00    	mov    0xc0(%esi),%eax
c000787f:	8b 96 c4 00 00 00    	mov    0xc4(%esi),%edx
c0007885:	89 90 c4 00 00 00    	mov    %edx,0xc4(%eax)
                if (t == headptr)
c000788b:	3b 77 4c             	cmp    0x4c(%edi),%esi
c000788e:	75 09                	jne    c0007899 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x123>
                    headptr = t->next;
c0007890:	8b 86 c4 00 00 00    	mov    0xc4(%esi),%eax
c0007896:	89 47 4c             	mov    %eax,0x4c(%edi)
            }

            t->next = t->prev = nullptr;
c0007899:	c7 86 c0 00 00 00 00 	movl   $0x0,0xc0(%esi)
c00078a0:	00 00 00 
c00078a3:	83 c8 ff             	or     $0xffffffff,%eax
c00078a6:	c7 86 c4 00 00 00 00 	movl   $0x0,0xc4(%esi)
c00078ad:	00 00 00 
c00078b0:	f0 0f c1 46 48       	lock xadd %eax,0x48(%esi)

                    counter++;
                    return;
                }

                if (EXPECT_FALSE(ec->del_ref())) {
c00078b5:	48                   	dec    %eax
c00078b6:	75 24                	jne    c00078dc <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x166>
                    delete ec;
c00078b8:	89 f0                	mov    %esi,%eax
c00078ba:	e8 4f bc ff ff       	call   c000350e <_ZN2EcD1Ev>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c00078bf:	8b 86 b8 00 00 00    	mov    0xb8(%esi),%eax
c00078c5:	89 f2                	mov    %esi,%edx
c00078c7:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c00078cd:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c00078d2:	e8 89 8a 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
c00078d7:	e9 63 ff ff ff       	jmp    c000783f <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0xc9>
c00078dc:	fe 47 46             	incb   0x46(%edi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c00078df:	84 db                	test   %bl,%bl
c00078e1:	74 2a                	je     c000790d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x197>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c00078e3:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c00078ea:	74 19                	je     c0007905 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x18f>
c00078ec:	68 40 85 01 c0       	push   $0xc0018540
c00078f1:	68 c0 00 00 00       	push   $0xc0
c00078f6:	68 12 61 01 c0       	push   $0xc0016112
c00078fb:	68 82 61 01 c0       	push   $0xc0016182
c0007900:	e9 b7 fe ff ff       	jmp    c00077bc <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x46>

            preemption = true;
c0007905:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000790c:	fb                   	sti    
        }

        ALWAYS_INLINE
        inline void release (void (*c)())
        {
            if (c)
c000790d:	b8 da 91 00 c0       	mov    $0xc00091da,%eax
c0007912:	85 c0                	test   %eax,%eax
c0007914:	74 03                	je     c0007919 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x1a3>
                cont = c;
c0007916:	89 46 50             	mov    %eax,0x50(%esi)

            Lock_guard <Spinlock> guard (lock);
c0007919:	8d 46 46             	lea    0x46(%esi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c000791c:	9c                   	pushf  
c000791d:	5b                   	pop    %ebx
            return flags & 0x200;
c000791e:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c0007921:	80 e3 01             	and    $0x1,%bl
c0007924:	74 15                	je     c000793b <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x1c5>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0007926:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000792d:	0f 84 e9 fe ff ff    	je     c000781c <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0xa6>

            asm volatile ("cli" : : : "memory");
c0007933:	fa                   	cli    
            preemption = false;
c0007934:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c000793b:	e8 ec 91 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c0007940:	8b 7e 4c             	mov    0x4c(%esi),%edi
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c0007943:	85 ff                	test   %edi,%edi
c0007945:	74 71                	je     c00079b8 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x242>
c0007947:	8b 47 74             	mov    0x74(%edi),%eax
c000794a:	85 c0                	test   %eax,%eax
c000794c:	74 6a                	je     c00079b8 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x242>
c000794e:	8b 57 70             	mov    0x70(%edi),%edx
c0007951:	85 d2                	test   %edx,%edx
c0007953:	74 63                	je     c00079b8 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x242>
                return false;

            if (t == t->next)
c0007955:	39 c7                	cmp    %eax,%edi
c0007957:	75 09                	jne    c0007962 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x1ec>
                headptr = nullptr;
c0007959:	c7 46 4c 00 00 00 00 	movl   $0x0,0x4c(%esi)
c0007960:	eb 17                	jmp    c0007979 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x203>

            else {
                t->next->prev = t->prev;
c0007962:	89 50 70             	mov    %edx,0x70(%eax)
                t->prev->next = t->next;
c0007965:	8b 47 70             	mov    0x70(%edi),%eax
c0007968:	8b 57 74             	mov    0x74(%edi),%edx
c000796b:	89 50 74             	mov    %edx,0x74(%eax)
                if (t == headptr)
c000796e:	3b 7e 4c             	cmp    0x4c(%esi),%edi
c0007971:	75 06                	jne    c0007979 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x203>
                    headptr = t->next;
c0007973:	8b 47 74             	mov    0x74(%edi),%eax
c0007976:	89 46 4c             	mov    %eax,0x4c(%esi)
            }

            t->next = t->prev = nullptr;
c0007979:	c7 47 70 00 00 00 00 	movl   $0x0,0x70(%edi)
c0007980:	83 c8 ff             	or     $0xffffffff,%eax
c0007983:	c7 47 74 00 00 00 00 	movl   $0x0,0x74(%edi)
c000798a:	f0 0f c1 47 48       	lock xadd %eax,0x48(%edi)

            for (Sc *s; dequeue (s = head()); ) {
                if (EXPECT_FALSE(s->del_ref()) && (this == s->ec)) {
c000798f:	48                   	dec    %eax
c0007990:	75 1d                	jne    c00079af <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x239>
c0007992:	3b 77 4c             	cmp    0x4c(%edi),%esi
c0007995:	75 18                	jne    c00079af <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x239>
                    delete s;
c0007997:	89 f8                	mov    %edi,%eax
c0007999:	e8 dc e9 ff ff       	call   c000637a <_ZN2ScD1Ev>
c000799e:	89 f8                	mov    %edi,%eax
c00079a0:	e8 a0 7f 00 00       	call   c000f945 <_ZN2ScdlEPv>
c00079a5:	eb 99                	jmp    c0007940 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x1ca>
                    if (si) {
                       if (si->queued()) return;
                       Queue<Si>::enqueue(si);
                    }

                    counter++;
c00079a7:	ff 47 64             	incl   0x64(%edi)
c00079aa:	fe 47 46             	incb   0x46(%edi)
c00079ad:	eb 0c                	jmp    c00079bb <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x245>
                    continue;
                }
                s->remote_enqueue();
c00079af:	89 f8                	mov    %edi,%eax
c00079b1:	e8 86 7d 00 00       	call   c000f73c <_ZN2Sc14remote_enqueueEv>
c00079b6:	eb 88                	jmp    c0007940 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x1ca>
c00079b8:	fe 46 46             	incb   0x46(%esi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c00079bb:	84 db                	test   %bl,%bl
c00079bd:	74 15                	je     c00079d4 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x25e>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c00079bf:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c00079c6:	0f 85 20 ff ff ff    	jne    c00078ec <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x176>

            preemption = true;
c00079cc:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c00079d3:	fb                   	sti    

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
c00079d4:	8b 1d 08 f0 ff cf    	mov    0xcffff008,%ebx
c00079da:	8b 53 14             	mov    0x14(%ebx),%edx
    current->utcb    = nullptr;
    current->fpu     = nullptr;

    Rcu::call(current);
c00079dd:	8d 73 0c             	lea    0xc(%ebx),%esi
    assert (current->utcb);
    assert (Sc::current->ec == current);

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
c00079e0:	c7 83 b0 00 00 00 00 	movl   $0x0,0xb0(%ebx)
c00079e7:	00 00 00 
    current->utcb    = nullptr;
c00079ea:	c7 83 b4 00 00 00 00 	movl   $0x0,0xb4(%ebx)
c00079f1:	00 00 00 
    current->fpu     = nullptr;
c00079f4:	c7 83 c8 00 00 00 00 	movl   $0x0,0xc8(%ebx)
c00079fb:	00 00 00 
c00079fe:	85 d2                	test   %edx,%edx
c0007a00:	74 04                	je     c0007a06 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x290>
                e->pre_func(e);
c0007a02:	89 f0                	mov    %esi,%eax
c0007a04:	ff d2                	call   *%edx
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
c0007a06:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
c0007a0a:	75 09                	jne    c0007a15 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x29f>
c0007a0c:	a1 f0 f7 ff cf       	mov    0xcffff7f0,%eax
c0007a11:	39 f0                	cmp    %esi,%eax
c0007a13:	75 29                	jne    c0007a3e <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x2c8>
                trace (0, "warning: rcu element already enqueued");
c0007a15:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c0007a19:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0007a1e:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c0007a23:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0007a28:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0007a2f:	50                   	push   %eax
c0007a30:	68 ae 6c 01 c0       	push   $0xc0016cae
c0007a35:	e8 a4 9f ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c0007a3a:	59                   	pop    %ecx
c0007a3b:	5b                   	pop    %ebx
c0007a3c:	eb 0e                	jmp    c0007a4c <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x2d6>
                return;
            }

            count ++;
c0007a3e:	ff 05 f4 f7 ff cf    	incl   0xcffff7f4

           *tail = e;
c0007a44:	89 30                	mov    %esi,(%eax)
            tail = &e->next;
c0007a46:	89 35 f0 f7 ff cf    	mov    %esi,0xcffff7f0

    Rcu::call(current);
    Rcu::call(Sc::current);
c0007a4c:	8b 35 10 f0 ff cf    	mov    0xcffff010,%esi
c0007a52:	85 f6                	test   %esi,%esi
c0007a54:	74 63                	je     c0007ab9 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x343>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
c0007a56:	8b 56 14             	mov    0x14(%esi),%edx
c0007a59:	8d 5e 0c             	lea    0xc(%esi),%ebx
c0007a5c:	85 d2                	test   %edx,%edx
c0007a5e:	74 04                	je     c0007a64 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x2ee>
                e->pre_func(e);
c0007a60:	89 d8                	mov    %ebx,%eax
c0007a62:	ff d2                	call   *%edx
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
c0007a64:	83 7e 0c 00          	cmpl   $0x0,0xc(%esi)
c0007a68:	75 09                	jne    c0007a73 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x2fd>
c0007a6a:	a1 f0 f7 ff cf       	mov    0xcffff7f0,%eax
c0007a6f:	39 d8                	cmp    %ebx,%eax
c0007a71:	75 29                	jne    c0007a9c <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x326>
                trace (0, "warning: rcu element already enqueued");
c0007a73:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c0007a77:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0007a7c:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c0007a81:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0007a86:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0007a8d:	50                   	push   %eax
c0007a8e:	68 ae 6c 01 c0       	push   $0xc0016cae
c0007a93:	e8 46 9f ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c0007a98:	58                   	pop    %eax
c0007a99:	5a                   	pop    %edx
c0007a9a:	eb 0e                	jmp    c0007aaa <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x334>
                return;
            }

            count ++;
c0007a9c:	ff 05 f4 f7 ff cf    	incl   0xcffff7f4

           *tail = e;
c0007aa2:	89 18                	mov    %ebx,(%eax)
            tail = &e->next;
c0007aa4:	89 1d f0 f7 ff cf    	mov    %ebx,0xcffff7f0

    Sc::schedule(true);
c0007aaa:	ba 01 00 00 00       	mov    $0x1,%edx
c0007aaf:	b8 01 00 00 00       	mov    $0x1,%eax
c0007ab4:	e8 f9 7e 00 00       	call   c000f9b2 <_ZN2Sc8scheduleEbb>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
c0007ab9:	a1 08 00 00 00       	mov    0x8,%eax
c0007abe:	0f 0b                	ud2    

c0007ac0 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv>:

    die ("XCPU OOM error");
}

template <void (*C)()>
void Ec::oom_xcpu_return()
c0007ac0:	57                   	push   %edi
c0007ac1:	56                   	push   %esi
c0007ac2:	53                   	push   %ebx
c0007ac3:	56                   	push   %esi
{
    assert (current->xcpu_sm);
c0007ac4:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0007ac9:	8b b8 f4 00 00 00    	mov    0xf4(%eax),%edi
c0007acf:	85 ff                	test   %edi,%edi
c0007ad1:	75 16                	jne    c0007ae9 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x29>
c0007ad3:	68 00 79 01 c0       	push   $0xc0017900
c0007ad8:	68 87 00 00 00       	push   $0x87
c0007add:	68 a3 72 01 c0       	push   $0xc00172a3
c0007ae2:	68 66 6c 01 c0       	push   $0xc0016c66
c0007ae7:	eb 1d                	jmp    c0007b06 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x46>
    assert (current->rcap);
c0007ae9:	83 b8 b0 00 00 00 00 	cmpl   $0x0,0xb0(%eax)
c0007af0:	75 1e                	jne    c0007b10 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x50>
c0007af2:	68 00 79 01 c0       	push   $0xc0017900
c0007af7:	68 88 00 00 00       	push   $0x88
c0007afc:	68 a3 72 01 c0       	push   $0xc00172a3
c0007b01:	68 77 6c 01 c0       	push   $0xc0016c77
c0007b06:	68 69 60 01 c0       	push   $0xc0016069
c0007b0b:	e8 36 9e ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>
    assert (current->utcb);
c0007b10:	83 b8 b4 00 00 00 00 	cmpl   $0x0,0xb4(%eax)
c0007b17:	75 16                	jne    c0007b2f <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x6f>
c0007b19:	68 00 79 01 c0       	push   $0xc0017900
c0007b1e:	68 89 00 00 00       	push   $0x89
c0007b23:	68 a3 72 01 c0       	push   $0xc00172a3
c0007b28:	68 85 6c 01 c0       	push   $0xc0016c85
c0007b2d:	eb d7                	jmp    c0007b06 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x46>
c0007b2f:	8b 15 10 f0 ff cf    	mov    0xcffff010,%edx
    assert (Sc::current->ec == current);
c0007b35:	39 42 4c             	cmp    %eax,0x4c(%edx)
c0007b38:	74 16                	je     c0007b50 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x90>
c0007b3a:	68 00 79 01 c0       	push   $0xc0017900
c0007b3f:	68 8a 00 00 00       	push   $0x8a
c0007b44:	68 a3 72 01 c0       	push   $0xc00172a3
c0007b49:	68 93 6c 01 c0       	push   $0xc0016c93
c0007b4e:	eb b6                	jmp    c0007b06 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x46>
        ALWAYS_INLINE
        inline void up (void (*c)() = nullptr, Sm * si = nullptr)
        {
            Ec *ec;

            {   Lock_guard <Spinlock> guard (lock);
c0007b50:	8d 47 46             	lea    0x46(%edi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c0007b53:	9c                   	pushf  
c0007b54:	5b                   	pop    %ebx
            return flags & 0x200;
c0007b55:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c0007b58:	80 e3 01             	and    $0x1,%bl
c0007b5b:	74 27                	je     c0007b84 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0xc4>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0007b5d:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0007b64:	75 16                	jne    c0007b7c <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0xbc>
c0007b66:	68 80 85 01 c0       	push   $0xc0018580
c0007b6b:	68 b7 00 00 00       	push   $0xb7
c0007b70:	68 12 61 01 c0       	push   $0xc0016112
c0007b75:	68 83 61 01 c0       	push   $0xc0016183
c0007b7a:	eb 8a                	jmp    c0007b06 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x46>

            asm volatile ("cli" : : : "memory");
c0007b7c:	fa                   	cli    
            preemption = false;
c0007b7d:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c0007b84:	e8 a3 8f ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c0007b89:	8b 77 4c             	mov    0x4c(%edi),%esi
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c0007b8c:	85 f6                	test   %esi,%esi
c0007b8e:	0f 84 5d 01 00 00    	je     c0007cf1 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x231>
c0007b94:	8b 86 c4 00 00 00    	mov    0xc4(%esi),%eax
c0007b9a:	85 c0                	test   %eax,%eax
c0007b9c:	0f 84 4f 01 00 00    	je     c0007cf1 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x231>
c0007ba2:	8b 96 c0 00 00 00    	mov    0xc0(%esi),%edx
c0007ba8:	85 d2                	test   %edx,%edx
c0007baa:	0f 84 41 01 00 00    	je     c0007cf1 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x231>
                return false;

            if (t == t->next)
c0007bb0:	39 c6                	cmp    %eax,%esi
c0007bb2:	75 09                	jne    c0007bbd <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0xfd>
                headptr = nullptr;
c0007bb4:	c7 47 4c 00 00 00 00 	movl   $0x0,0x4c(%edi)
c0007bbb:	eb 26                	jmp    c0007be3 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x123>

            else {
                t->next->prev = t->prev;
c0007bbd:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
                t->prev->next = t->next;
c0007bc3:	8b 86 c0 00 00 00    	mov    0xc0(%esi),%eax
c0007bc9:	8b 96 c4 00 00 00    	mov    0xc4(%esi),%edx
c0007bcf:	89 90 c4 00 00 00    	mov    %edx,0xc4(%eax)
                if (t == headptr)
c0007bd5:	3b 77 4c             	cmp    0x4c(%edi),%esi
c0007bd8:	75 09                	jne    c0007be3 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x123>
                    headptr = t->next;
c0007bda:	8b 86 c4 00 00 00    	mov    0xc4(%esi),%eax
c0007be0:	89 47 4c             	mov    %eax,0x4c(%edi)
            }

            t->next = t->prev = nullptr;
c0007be3:	c7 86 c0 00 00 00 00 	movl   $0x0,0xc0(%esi)
c0007bea:	00 00 00 
c0007bed:	83 c8 ff             	or     $0xffffffff,%eax
c0007bf0:	c7 86 c4 00 00 00 00 	movl   $0x0,0xc4(%esi)
c0007bf7:	00 00 00 
c0007bfa:	f0 0f c1 46 48       	lock xadd %eax,0x48(%esi)

                    counter++;
                    return;
                }

                if (EXPECT_FALSE(ec->del_ref())) {
c0007bff:	48                   	dec    %eax
c0007c00:	75 24                	jne    c0007c26 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x166>
                    delete ec;
c0007c02:	89 f0                	mov    %esi,%eax
c0007c04:	e8 05 b9 ff ff       	call   c000350e <_ZN2EcD1Ev>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c0007c09:	8b 86 b8 00 00 00    	mov    0xb8(%esi),%eax
c0007c0f:	89 f2                	mov    %esi,%edx
c0007c11:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c0007c17:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c0007c1c:	e8 3f 87 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
c0007c21:	e9 63 ff ff ff       	jmp    c0007b89 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0xc9>
c0007c26:	fe 47 46             	incb   0x46(%edi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c0007c29:	84 db                	test   %bl,%bl
c0007c2b:	74 2a                	je     c0007c57 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x197>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0007c2d:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0007c34:	74 19                	je     c0007c4f <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x18f>
c0007c36:	68 40 85 01 c0       	push   $0xc0018540
c0007c3b:	68 c0 00 00 00       	push   $0xc0
c0007c40:	68 12 61 01 c0       	push   $0xc0016112
c0007c45:	68 82 61 01 c0       	push   $0xc0016182
c0007c4a:	e9 b7 fe ff ff       	jmp    c0007b06 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x46>

            preemption = true;
c0007c4f:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c0007c56:	fb                   	sti    
        }

        ALWAYS_INLINE
        inline void release (void (*c)())
        {
            if (c)
c0007c57:	b8 7a 93 00 c0       	mov    $0xc000937a,%eax
c0007c5c:	85 c0                	test   %eax,%eax
c0007c5e:	74 03                	je     c0007c63 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x1a3>
                cont = c;
c0007c60:	89 46 50             	mov    %eax,0x50(%esi)

            Lock_guard <Spinlock> guard (lock);
c0007c63:	8d 46 46             	lea    0x46(%esi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c0007c66:	9c                   	pushf  
c0007c67:	5b                   	pop    %ebx
            return flags & 0x200;
c0007c68:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c0007c6b:	80 e3 01             	and    $0x1,%bl
c0007c6e:	74 15                	je     c0007c85 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x1c5>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0007c70:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0007c77:	0f 84 e9 fe ff ff    	je     c0007b66 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0xa6>

            asm volatile ("cli" : : : "memory");
c0007c7d:	fa                   	cli    
            preemption = false;
c0007c7e:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c0007c85:	e8 a2 8e ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c0007c8a:	8b 7e 4c             	mov    0x4c(%esi),%edi
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c0007c8d:	85 ff                	test   %edi,%edi
c0007c8f:	74 71                	je     c0007d02 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x242>
c0007c91:	8b 47 74             	mov    0x74(%edi),%eax
c0007c94:	85 c0                	test   %eax,%eax
c0007c96:	74 6a                	je     c0007d02 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x242>
c0007c98:	8b 57 70             	mov    0x70(%edi),%edx
c0007c9b:	85 d2                	test   %edx,%edx
c0007c9d:	74 63                	je     c0007d02 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x242>
                return false;

            if (t == t->next)
c0007c9f:	39 c7                	cmp    %eax,%edi
c0007ca1:	75 09                	jne    c0007cac <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x1ec>
                headptr = nullptr;
c0007ca3:	c7 46 4c 00 00 00 00 	movl   $0x0,0x4c(%esi)
c0007caa:	eb 17                	jmp    c0007cc3 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x203>

            else {
                t->next->prev = t->prev;
c0007cac:	89 50 70             	mov    %edx,0x70(%eax)
                t->prev->next = t->next;
c0007caf:	8b 47 70             	mov    0x70(%edi),%eax
c0007cb2:	8b 57 74             	mov    0x74(%edi),%edx
c0007cb5:	89 50 74             	mov    %edx,0x74(%eax)
                if (t == headptr)
c0007cb8:	3b 7e 4c             	cmp    0x4c(%esi),%edi
c0007cbb:	75 06                	jne    c0007cc3 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x203>
                    headptr = t->next;
c0007cbd:	8b 47 74             	mov    0x74(%edi),%eax
c0007cc0:	89 46 4c             	mov    %eax,0x4c(%esi)
            }

            t->next = t->prev = nullptr;
c0007cc3:	c7 47 70 00 00 00 00 	movl   $0x0,0x70(%edi)
c0007cca:	83 c8 ff             	or     $0xffffffff,%eax
c0007ccd:	c7 47 74 00 00 00 00 	movl   $0x0,0x74(%edi)
c0007cd4:	f0 0f c1 47 48       	lock xadd %eax,0x48(%edi)

            for (Sc *s; dequeue (s = head()); ) {
                if (EXPECT_FALSE(s->del_ref()) && (this == s->ec)) {
c0007cd9:	48                   	dec    %eax
c0007cda:	75 1d                	jne    c0007cf9 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x239>
c0007cdc:	3b 77 4c             	cmp    0x4c(%edi),%esi
c0007cdf:	75 18                	jne    c0007cf9 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x239>
                    delete s;
c0007ce1:	89 f8                	mov    %edi,%eax
c0007ce3:	e8 92 e6 ff ff       	call   c000637a <_ZN2ScD1Ev>
c0007ce8:	89 f8                	mov    %edi,%eax
c0007cea:	e8 56 7c 00 00       	call   c000f945 <_ZN2ScdlEPv>
c0007cef:	eb 99                	jmp    c0007c8a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x1ca>
                    if (si) {
                       if (si->queued()) return;
                       Queue<Si>::enqueue(si);
                    }

                    counter++;
c0007cf1:	ff 47 64             	incl   0x64(%edi)
c0007cf4:	fe 47 46             	incb   0x46(%edi)
c0007cf7:	eb 0c                	jmp    c0007d05 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x245>
                    continue;
                }
                s->remote_enqueue();
c0007cf9:	89 f8                	mov    %edi,%eax
c0007cfb:	e8 3c 7a 00 00       	call   c000f73c <_ZN2Sc14remote_enqueueEv>
c0007d00:	eb 88                	jmp    c0007c8a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x1ca>
c0007d02:	fe 46 46             	incb   0x46(%esi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c0007d05:	84 db                	test   %bl,%bl
c0007d07:	74 15                	je     c0007d1e <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x25e>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0007d09:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0007d10:	0f 85 20 ff ff ff    	jne    c0007c36 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x176>

            preemption = true;
c0007d16:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c0007d1d:	fb                   	sti    

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
c0007d1e:	8b 1d 08 f0 ff cf    	mov    0xcffff008,%ebx
c0007d24:	8b 53 14             	mov    0x14(%ebx),%edx
    current->utcb    = nullptr;
    current->fpu     = nullptr;

    Rcu::call(current);
c0007d27:	8d 73 0c             	lea    0xc(%ebx),%esi
    assert (current->utcb);
    assert (Sc::current->ec == current);

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
c0007d2a:	c7 83 b0 00 00 00 00 	movl   $0x0,0xb0(%ebx)
c0007d31:	00 00 00 
    current->utcb    = nullptr;
c0007d34:	c7 83 b4 00 00 00 00 	movl   $0x0,0xb4(%ebx)
c0007d3b:	00 00 00 
    current->fpu     = nullptr;
c0007d3e:	c7 83 c8 00 00 00 00 	movl   $0x0,0xc8(%ebx)
c0007d45:	00 00 00 
c0007d48:	85 d2                	test   %edx,%edx
c0007d4a:	74 04                	je     c0007d50 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x290>
                e->pre_func(e);
c0007d4c:	89 f0                	mov    %esi,%eax
c0007d4e:	ff d2                	call   *%edx
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
c0007d50:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
c0007d54:	75 09                	jne    c0007d5f <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x29f>
c0007d56:	a1 f0 f7 ff cf       	mov    0xcffff7f0,%eax
c0007d5b:	39 f0                	cmp    %esi,%eax
c0007d5d:	75 29                	jne    c0007d88 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x2c8>
                trace (0, "warning: rcu element already enqueued");
c0007d5f:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c0007d63:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0007d68:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c0007d6d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0007d72:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0007d79:	50                   	push   %eax
c0007d7a:	68 ae 6c 01 c0       	push   $0xc0016cae
c0007d7f:	e8 5a 9c ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c0007d84:	59                   	pop    %ecx
c0007d85:	5b                   	pop    %ebx
c0007d86:	eb 0e                	jmp    c0007d96 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x2d6>
                return;
            }

            count ++;
c0007d88:	ff 05 f4 f7 ff cf    	incl   0xcffff7f4

           *tail = e;
c0007d8e:	89 30                	mov    %esi,(%eax)
            tail = &e->next;
c0007d90:	89 35 f0 f7 ff cf    	mov    %esi,0xcffff7f0

    Rcu::call(current);
    Rcu::call(Sc::current);
c0007d96:	8b 35 10 f0 ff cf    	mov    0xcffff010,%esi
c0007d9c:	85 f6                	test   %esi,%esi
c0007d9e:	74 63                	je     c0007e03 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x343>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
c0007da0:	8b 56 14             	mov    0x14(%esi),%edx
c0007da3:	8d 5e 0c             	lea    0xc(%esi),%ebx
c0007da6:	85 d2                	test   %edx,%edx
c0007da8:	74 04                	je     c0007dae <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x2ee>
                e->pre_func(e);
c0007daa:	89 d8                	mov    %ebx,%eax
c0007dac:	ff d2                	call   *%edx
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
c0007dae:	83 7e 0c 00          	cmpl   $0x0,0xc(%esi)
c0007db2:	75 09                	jne    c0007dbd <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x2fd>
c0007db4:	a1 f0 f7 ff cf       	mov    0xcffff7f0,%eax
c0007db9:	39 d8                	cmp    %ebx,%eax
c0007dbb:	75 29                	jne    c0007de6 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x326>
                trace (0, "warning: rcu element already enqueued");
c0007dbd:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c0007dc1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0007dc6:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c0007dcb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0007dd0:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0007dd7:	50                   	push   %eax
c0007dd8:	68 ae 6c 01 c0       	push   $0xc0016cae
c0007ddd:	e8 fc 9b ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c0007de2:	58                   	pop    %eax
c0007de3:	5a                   	pop    %edx
c0007de4:	eb 0e                	jmp    c0007df4 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x334>
                return;
            }

            count ++;
c0007de6:	ff 05 f4 f7 ff cf    	incl   0xcffff7f4

           *tail = e;
c0007dec:	89 18                	mov    %ebx,(%eax)
            tail = &e->next;
c0007dee:	89 1d f0 f7 ff cf    	mov    %ebx,0xcffff7f0

    Sc::schedule(true);
c0007df4:	ba 01 00 00 00       	mov    $0x1,%edx
c0007df9:	b8 01 00 00 00       	mov    $0x1,%eax
c0007dfe:	e8 af 7b 00 00       	call   c000f9b2 <_ZN2Sc8scheduleEbb>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
c0007e03:	a1 08 00 00 00       	mov    0x8,%eax
c0007e08:	0f 0b                	ud2    

c0007e0a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv>:

    die ("XCPU OOM error");
}

template <void (*C)()>
void Ec::oom_xcpu_return()
c0007e0a:	57                   	push   %edi
c0007e0b:	56                   	push   %esi
c0007e0c:	53                   	push   %ebx
c0007e0d:	56                   	push   %esi
{
    assert (current->xcpu_sm);
c0007e0e:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0007e13:	8b b8 f4 00 00 00    	mov    0xf4(%eax),%edi
c0007e19:	85 ff                	test   %edi,%edi
c0007e1b:	75 16                	jne    c0007e33 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x29>
c0007e1d:	68 40 77 01 c0       	push   $0xc0017740
c0007e22:	68 87 00 00 00       	push   $0x87
c0007e27:	68 a3 72 01 c0       	push   $0xc00172a3
c0007e2c:	68 66 6c 01 c0       	push   $0xc0016c66
c0007e31:	eb 1d                	jmp    c0007e50 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x46>
    assert (current->rcap);
c0007e33:	83 b8 b0 00 00 00 00 	cmpl   $0x0,0xb0(%eax)
c0007e3a:	75 1e                	jne    c0007e5a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x50>
c0007e3c:	68 40 77 01 c0       	push   $0xc0017740
c0007e41:	68 88 00 00 00       	push   $0x88
c0007e46:	68 a3 72 01 c0       	push   $0xc00172a3
c0007e4b:	68 77 6c 01 c0       	push   $0xc0016c77
c0007e50:	68 69 60 01 c0       	push   $0xc0016069
c0007e55:	e8 ec 9a ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>
    assert (current->utcb);
c0007e5a:	83 b8 b4 00 00 00 00 	cmpl   $0x0,0xb4(%eax)
c0007e61:	75 16                	jne    c0007e79 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x6f>
c0007e63:	68 40 77 01 c0       	push   $0xc0017740
c0007e68:	68 89 00 00 00       	push   $0x89
c0007e6d:	68 a3 72 01 c0       	push   $0xc00172a3
c0007e72:	68 85 6c 01 c0       	push   $0xc0016c85
c0007e77:	eb d7                	jmp    c0007e50 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x46>
c0007e79:	8b 15 10 f0 ff cf    	mov    0xcffff010,%edx
    assert (Sc::current->ec == current);
c0007e7f:	39 42 4c             	cmp    %eax,0x4c(%edx)
c0007e82:	74 16                	je     c0007e9a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x90>
c0007e84:	68 40 77 01 c0       	push   $0xc0017740
c0007e89:	68 8a 00 00 00       	push   $0x8a
c0007e8e:	68 a3 72 01 c0       	push   $0xc00172a3
c0007e93:	68 93 6c 01 c0       	push   $0xc0016c93
c0007e98:	eb b6                	jmp    c0007e50 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x46>
        ALWAYS_INLINE
        inline void up (void (*c)() = nullptr, Sm * si = nullptr)
        {
            Ec *ec;

            {   Lock_guard <Spinlock> guard (lock);
c0007e9a:	8d 47 46             	lea    0x46(%edi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c0007e9d:	9c                   	pushf  
c0007e9e:	5b                   	pop    %ebx
            return flags & 0x200;
c0007e9f:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c0007ea2:	80 e3 01             	and    $0x1,%bl
c0007ea5:	74 27                	je     c0007ece <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0xc4>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0007ea7:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0007eae:	75 16                	jne    c0007ec6 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0xbc>
c0007eb0:	68 80 85 01 c0       	push   $0xc0018580
c0007eb5:	68 b7 00 00 00       	push   $0xb7
c0007eba:	68 12 61 01 c0       	push   $0xc0016112
c0007ebf:	68 83 61 01 c0       	push   $0xc0016183
c0007ec4:	eb 8a                	jmp    c0007e50 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x46>

            asm volatile ("cli" : : : "memory");
c0007ec6:	fa                   	cli    
            preemption = false;
c0007ec7:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c0007ece:	e8 59 8c ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c0007ed3:	8b 77 4c             	mov    0x4c(%edi),%esi
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c0007ed6:	85 f6                	test   %esi,%esi
c0007ed8:	0f 84 5d 01 00 00    	je     c000803b <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x231>
c0007ede:	8b 86 c4 00 00 00    	mov    0xc4(%esi),%eax
c0007ee4:	85 c0                	test   %eax,%eax
c0007ee6:	0f 84 4f 01 00 00    	je     c000803b <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x231>
c0007eec:	8b 96 c0 00 00 00    	mov    0xc0(%esi),%edx
c0007ef2:	85 d2                	test   %edx,%edx
c0007ef4:	0f 84 41 01 00 00    	je     c000803b <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x231>
                return false;

            if (t == t->next)
c0007efa:	39 c6                	cmp    %eax,%esi
c0007efc:	75 09                	jne    c0007f07 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0xfd>
                headptr = nullptr;
c0007efe:	c7 47 4c 00 00 00 00 	movl   $0x0,0x4c(%edi)
c0007f05:	eb 26                	jmp    c0007f2d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x123>

            else {
                t->next->prev = t->prev;
c0007f07:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
                t->prev->next = t->next;
c0007f0d:	8b 86 c0 00 00 00    	mov    0xc0(%esi),%eax
c0007f13:	8b 96 c4 00 00 00    	mov    0xc4(%esi),%edx
c0007f19:	89 90 c4 00 00 00    	mov    %edx,0xc4(%eax)
                if (t == headptr)
c0007f1f:	3b 77 4c             	cmp    0x4c(%edi),%esi
c0007f22:	75 09                	jne    c0007f2d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x123>
                    headptr = t->next;
c0007f24:	8b 86 c4 00 00 00    	mov    0xc4(%esi),%eax
c0007f2a:	89 47 4c             	mov    %eax,0x4c(%edi)
            }

            t->next = t->prev = nullptr;
c0007f2d:	c7 86 c0 00 00 00 00 	movl   $0x0,0xc0(%esi)
c0007f34:	00 00 00 
c0007f37:	83 c8 ff             	or     $0xffffffff,%eax
c0007f3a:	c7 86 c4 00 00 00 00 	movl   $0x0,0xc4(%esi)
c0007f41:	00 00 00 
c0007f44:	f0 0f c1 46 48       	lock xadd %eax,0x48(%esi)

                    counter++;
                    return;
                }

                if (EXPECT_FALSE(ec->del_ref())) {
c0007f49:	48                   	dec    %eax
c0007f4a:	75 24                	jne    c0007f70 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x166>
                    delete ec;
c0007f4c:	89 f0                	mov    %esi,%eax
c0007f4e:	e8 bb b5 ff ff       	call   c000350e <_ZN2EcD1Ev>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c0007f53:	8b 86 b8 00 00 00    	mov    0xb8(%esi),%eax
c0007f59:	89 f2                	mov    %esi,%edx
c0007f5b:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c0007f61:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c0007f66:	e8 f5 83 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
c0007f6b:	e9 63 ff ff ff       	jmp    c0007ed3 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0xc9>
c0007f70:	fe 47 46             	incb   0x46(%edi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c0007f73:	84 db                	test   %bl,%bl
c0007f75:	74 2a                	je     c0007fa1 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x197>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0007f77:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0007f7e:	74 19                	je     c0007f99 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x18f>
c0007f80:	68 40 85 01 c0       	push   $0xc0018540
c0007f85:	68 c0 00 00 00       	push   $0xc0
c0007f8a:	68 12 61 01 c0       	push   $0xc0016112
c0007f8f:	68 82 61 01 c0       	push   $0xc0016182
c0007f94:	e9 b7 fe ff ff       	jmp    c0007e50 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x46>

            preemption = true;
c0007f99:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c0007fa0:	fb                   	sti    
        }

        ALWAYS_INLINE
        inline void release (void (*c)())
        {
            if (c)
c0007fa1:	b8 1a 95 00 c0       	mov    $0xc000951a,%eax
c0007fa6:	85 c0                	test   %eax,%eax
c0007fa8:	74 03                	je     c0007fad <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x1a3>
                cont = c;
c0007faa:	89 46 50             	mov    %eax,0x50(%esi)

            Lock_guard <Spinlock> guard (lock);
c0007fad:	8d 46 46             	lea    0x46(%esi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c0007fb0:	9c                   	pushf  
c0007fb1:	5b                   	pop    %ebx
            return flags & 0x200;
c0007fb2:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c0007fb5:	80 e3 01             	and    $0x1,%bl
c0007fb8:	74 15                	je     c0007fcf <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x1c5>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0007fba:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0007fc1:	0f 84 e9 fe ff ff    	je     c0007eb0 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0xa6>

            asm volatile ("cli" : : : "memory");
c0007fc7:	fa                   	cli    
            preemption = false;
c0007fc8:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c0007fcf:	e8 58 8b ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c0007fd4:	8b 7e 4c             	mov    0x4c(%esi),%edi
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c0007fd7:	85 ff                	test   %edi,%edi
c0007fd9:	74 71                	je     c000804c <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x242>
c0007fdb:	8b 47 74             	mov    0x74(%edi),%eax
c0007fde:	85 c0                	test   %eax,%eax
c0007fe0:	74 6a                	je     c000804c <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x242>
c0007fe2:	8b 57 70             	mov    0x70(%edi),%edx
c0007fe5:	85 d2                	test   %edx,%edx
c0007fe7:	74 63                	je     c000804c <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x242>
                return false;

            if (t == t->next)
c0007fe9:	39 c7                	cmp    %eax,%edi
c0007feb:	75 09                	jne    c0007ff6 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x1ec>
                headptr = nullptr;
c0007fed:	c7 46 4c 00 00 00 00 	movl   $0x0,0x4c(%esi)
c0007ff4:	eb 17                	jmp    c000800d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x203>

            else {
                t->next->prev = t->prev;
c0007ff6:	89 50 70             	mov    %edx,0x70(%eax)
                t->prev->next = t->next;
c0007ff9:	8b 47 70             	mov    0x70(%edi),%eax
c0007ffc:	8b 57 74             	mov    0x74(%edi),%edx
c0007fff:	89 50 74             	mov    %edx,0x74(%eax)
                if (t == headptr)
c0008002:	3b 7e 4c             	cmp    0x4c(%esi),%edi
c0008005:	75 06                	jne    c000800d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x203>
                    headptr = t->next;
c0008007:	8b 47 74             	mov    0x74(%edi),%eax
c000800a:	89 46 4c             	mov    %eax,0x4c(%esi)
            }

            t->next = t->prev = nullptr;
c000800d:	c7 47 70 00 00 00 00 	movl   $0x0,0x70(%edi)
c0008014:	83 c8 ff             	or     $0xffffffff,%eax
c0008017:	c7 47 74 00 00 00 00 	movl   $0x0,0x74(%edi)
c000801e:	f0 0f c1 47 48       	lock xadd %eax,0x48(%edi)

            for (Sc *s; dequeue (s = head()); ) {
                if (EXPECT_FALSE(s->del_ref()) && (this == s->ec)) {
c0008023:	48                   	dec    %eax
c0008024:	75 1d                	jne    c0008043 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x239>
c0008026:	3b 77 4c             	cmp    0x4c(%edi),%esi
c0008029:	75 18                	jne    c0008043 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x239>
                    delete s;
c000802b:	89 f8                	mov    %edi,%eax
c000802d:	e8 48 e3 ff ff       	call   c000637a <_ZN2ScD1Ev>
c0008032:	89 f8                	mov    %edi,%eax
c0008034:	e8 0c 79 00 00       	call   c000f945 <_ZN2ScdlEPv>
c0008039:	eb 99                	jmp    c0007fd4 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x1ca>
                    if (si) {
                       if (si->queued()) return;
                       Queue<Si>::enqueue(si);
                    }

                    counter++;
c000803b:	ff 47 64             	incl   0x64(%edi)
c000803e:	fe 47 46             	incb   0x46(%edi)
c0008041:	eb 0c                	jmp    c000804f <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x245>
                    continue;
                }
                s->remote_enqueue();
c0008043:	89 f8                	mov    %edi,%eax
c0008045:	e8 f2 76 00 00       	call   c000f73c <_ZN2Sc14remote_enqueueEv>
c000804a:	eb 88                	jmp    c0007fd4 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x1ca>
c000804c:	fe 46 46             	incb   0x46(%esi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c000804f:	84 db                	test   %bl,%bl
c0008051:	74 15                	je     c0008068 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x25e>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0008053:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000805a:	0f 85 20 ff ff ff    	jne    c0007f80 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x176>

            preemption = true;
c0008060:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c0008067:	fb                   	sti    

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
c0008068:	8b 1d 08 f0 ff cf    	mov    0xcffff008,%ebx
c000806e:	8b 53 14             	mov    0x14(%ebx),%edx
    current->utcb    = nullptr;
    current->fpu     = nullptr;

    Rcu::call(current);
c0008071:	8d 73 0c             	lea    0xc(%ebx),%esi
    assert (current->utcb);
    assert (Sc::current->ec == current);

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
c0008074:	c7 83 b0 00 00 00 00 	movl   $0x0,0xb0(%ebx)
c000807b:	00 00 00 
    current->utcb    = nullptr;
c000807e:	c7 83 b4 00 00 00 00 	movl   $0x0,0xb4(%ebx)
c0008085:	00 00 00 
    current->fpu     = nullptr;
c0008088:	c7 83 c8 00 00 00 00 	movl   $0x0,0xc8(%ebx)
c000808f:	00 00 00 
c0008092:	85 d2                	test   %edx,%edx
c0008094:	74 04                	je     c000809a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x290>
                e->pre_func(e);
c0008096:	89 f0                	mov    %esi,%eax
c0008098:	ff d2                	call   *%edx
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
c000809a:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
c000809e:	75 09                	jne    c00080a9 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x29f>
c00080a0:	a1 f0 f7 ff cf       	mov    0xcffff7f0,%eax
c00080a5:	39 f0                	cmp    %esi,%eax
c00080a7:	75 29                	jne    c00080d2 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x2c8>
                trace (0, "warning: rcu element already enqueued");
c00080a9:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c00080ad:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c00080b2:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c00080b7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00080bc:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c00080c3:	50                   	push   %eax
c00080c4:	68 ae 6c 01 c0       	push   $0xc0016cae
c00080c9:	e8 10 99 ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c00080ce:	59                   	pop    %ecx
c00080cf:	5b                   	pop    %ebx
c00080d0:	eb 0e                	jmp    c00080e0 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x2d6>
                return;
            }

            count ++;
c00080d2:	ff 05 f4 f7 ff cf    	incl   0xcffff7f4

           *tail = e;
c00080d8:	89 30                	mov    %esi,(%eax)
            tail = &e->next;
c00080da:	89 35 f0 f7 ff cf    	mov    %esi,0xcffff7f0

    Rcu::call(current);
    Rcu::call(Sc::current);
c00080e0:	8b 35 10 f0 ff cf    	mov    0xcffff010,%esi
c00080e6:	85 f6                	test   %esi,%esi
c00080e8:	74 63                	je     c000814d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x343>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
c00080ea:	8b 56 14             	mov    0x14(%esi),%edx
c00080ed:	8d 5e 0c             	lea    0xc(%esi),%ebx
c00080f0:	85 d2                	test   %edx,%edx
c00080f2:	74 04                	je     c00080f8 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x2ee>
                e->pre_func(e);
c00080f4:	89 d8                	mov    %ebx,%eax
c00080f6:	ff d2                	call   *%edx
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
c00080f8:	83 7e 0c 00          	cmpl   $0x0,0xc(%esi)
c00080fc:	75 09                	jne    c0008107 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x2fd>
c00080fe:	a1 f0 f7 ff cf       	mov    0xcffff7f0,%eax
c0008103:	39 d8                	cmp    %ebx,%eax
c0008105:	75 29                	jne    c0008130 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x326>
                trace (0, "warning: rcu element already enqueued");
c0008107:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c000810b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0008110:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c0008115:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000811a:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0008121:	50                   	push   %eax
c0008122:	68 ae 6c 01 c0       	push   $0xc0016cae
c0008127:	e8 b2 98 ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c000812c:	58                   	pop    %eax
c000812d:	5a                   	pop    %edx
c000812e:	eb 0e                	jmp    c000813e <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x334>
                return;
            }

            count ++;
c0008130:	ff 05 f4 f7 ff cf    	incl   0xcffff7f4

           *tail = e;
c0008136:	89 18                	mov    %ebx,(%eax)
            tail = &e->next;
c0008138:	89 1d f0 f7 ff cf    	mov    %ebx,0xcffff7f0

    Sc::schedule(true);
c000813e:	ba 01 00 00 00       	mov    $0x1,%edx
c0008143:	b8 01 00 00 00       	mov    $0x1,%eax
c0008148:	e8 65 78 00 00       	call   c000f9b2 <_ZN2Sc8scheduleEbb>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
c000814d:	a1 08 00 00 00       	mov    0x8,%eax
c0008152:	0f 0b                	ud2    

c0008154 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv>:

    die ("XCPU OOM error");
}

template <void (*C)()>
void Ec::oom_xcpu_return()
c0008154:	57                   	push   %edi
c0008155:	56                   	push   %esi
c0008156:	53                   	push   %ebx
c0008157:	56                   	push   %esi
{
    assert (current->xcpu_sm);
c0008158:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c000815d:	8b b8 f4 00 00 00    	mov    0xf4(%eax),%edi
c0008163:	85 ff                	test   %edi,%edi
c0008165:	75 16                	jne    c000817d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x29>
c0008167:	68 80 75 01 c0       	push   $0xc0017580
c000816c:	68 87 00 00 00       	push   $0x87
c0008171:	68 a3 72 01 c0       	push   $0xc00172a3
c0008176:	68 66 6c 01 c0       	push   $0xc0016c66
c000817b:	eb 1d                	jmp    c000819a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x46>
    assert (current->rcap);
c000817d:	83 b8 b0 00 00 00 00 	cmpl   $0x0,0xb0(%eax)
c0008184:	75 1e                	jne    c00081a4 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x50>
c0008186:	68 80 75 01 c0       	push   $0xc0017580
c000818b:	68 88 00 00 00       	push   $0x88
c0008190:	68 a3 72 01 c0       	push   $0xc00172a3
c0008195:	68 77 6c 01 c0       	push   $0xc0016c77
c000819a:	68 69 60 01 c0       	push   $0xc0016069
c000819f:	e8 a2 97 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>
    assert (current->utcb);
c00081a4:	83 b8 b4 00 00 00 00 	cmpl   $0x0,0xb4(%eax)
c00081ab:	75 16                	jne    c00081c3 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x6f>
c00081ad:	68 80 75 01 c0       	push   $0xc0017580
c00081b2:	68 89 00 00 00       	push   $0x89
c00081b7:	68 a3 72 01 c0       	push   $0xc00172a3
c00081bc:	68 85 6c 01 c0       	push   $0xc0016c85
c00081c1:	eb d7                	jmp    c000819a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x46>
c00081c3:	8b 15 10 f0 ff cf    	mov    0xcffff010,%edx
    assert (Sc::current->ec == current);
c00081c9:	39 42 4c             	cmp    %eax,0x4c(%edx)
c00081cc:	74 16                	je     c00081e4 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x90>
c00081ce:	68 80 75 01 c0       	push   $0xc0017580
c00081d3:	68 8a 00 00 00       	push   $0x8a
c00081d8:	68 a3 72 01 c0       	push   $0xc00172a3
c00081dd:	68 93 6c 01 c0       	push   $0xc0016c93
c00081e2:	eb b6                	jmp    c000819a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x46>
        ALWAYS_INLINE
        inline void up (void (*c)() = nullptr, Sm * si = nullptr)
        {
            Ec *ec;

            {   Lock_guard <Spinlock> guard (lock);
c00081e4:	8d 47 46             	lea    0x46(%edi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c00081e7:	9c                   	pushf  
c00081e8:	5b                   	pop    %ebx
            return flags & 0x200;
c00081e9:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c00081ec:	80 e3 01             	and    $0x1,%bl
c00081ef:	74 27                	je     c0008218 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0xc4>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c00081f1:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c00081f8:	75 16                	jne    c0008210 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0xbc>
c00081fa:	68 80 85 01 c0       	push   $0xc0018580
c00081ff:	68 b7 00 00 00       	push   $0xb7
c0008204:	68 12 61 01 c0       	push   $0xc0016112
c0008209:	68 83 61 01 c0       	push   $0xc0016183
c000820e:	eb 8a                	jmp    c000819a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x46>

            asm volatile ("cli" : : : "memory");
c0008210:	fa                   	cli    
            preemption = false;
c0008211:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c0008218:	e8 0f 89 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c000821d:	8b 77 4c             	mov    0x4c(%edi),%esi
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c0008220:	85 f6                	test   %esi,%esi
c0008222:	0f 84 5d 01 00 00    	je     c0008385 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x231>
c0008228:	8b 86 c4 00 00 00    	mov    0xc4(%esi),%eax
c000822e:	85 c0                	test   %eax,%eax
c0008230:	0f 84 4f 01 00 00    	je     c0008385 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x231>
c0008236:	8b 96 c0 00 00 00    	mov    0xc0(%esi),%edx
c000823c:	85 d2                	test   %edx,%edx
c000823e:	0f 84 41 01 00 00    	je     c0008385 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x231>
                return false;

            if (t == t->next)
c0008244:	39 c6                	cmp    %eax,%esi
c0008246:	75 09                	jne    c0008251 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0xfd>
                headptr = nullptr;
c0008248:	c7 47 4c 00 00 00 00 	movl   $0x0,0x4c(%edi)
c000824f:	eb 26                	jmp    c0008277 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x123>

            else {
                t->next->prev = t->prev;
c0008251:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
                t->prev->next = t->next;
c0008257:	8b 86 c0 00 00 00    	mov    0xc0(%esi),%eax
c000825d:	8b 96 c4 00 00 00    	mov    0xc4(%esi),%edx
c0008263:	89 90 c4 00 00 00    	mov    %edx,0xc4(%eax)
                if (t == headptr)
c0008269:	3b 77 4c             	cmp    0x4c(%edi),%esi
c000826c:	75 09                	jne    c0008277 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x123>
                    headptr = t->next;
c000826e:	8b 86 c4 00 00 00    	mov    0xc4(%esi),%eax
c0008274:	89 47 4c             	mov    %eax,0x4c(%edi)
            }

            t->next = t->prev = nullptr;
c0008277:	c7 86 c0 00 00 00 00 	movl   $0x0,0xc0(%esi)
c000827e:	00 00 00 
c0008281:	83 c8 ff             	or     $0xffffffff,%eax
c0008284:	c7 86 c4 00 00 00 00 	movl   $0x0,0xc4(%esi)
c000828b:	00 00 00 
c000828e:	f0 0f c1 46 48       	lock xadd %eax,0x48(%esi)

                    counter++;
                    return;
                }

                if (EXPECT_FALSE(ec->del_ref())) {
c0008293:	48                   	dec    %eax
c0008294:	75 24                	jne    c00082ba <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x166>
                    delete ec;
c0008296:	89 f0                	mov    %esi,%eax
c0008298:	e8 71 b2 ff ff       	call   c000350e <_ZN2EcD1Ev>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c000829d:	8b 86 b8 00 00 00    	mov    0xb8(%esi),%eax
c00082a3:	89 f2                	mov    %esi,%edx
c00082a5:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c00082ab:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c00082b0:	e8 ab 80 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
c00082b5:	e9 63 ff ff ff       	jmp    c000821d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0xc9>
c00082ba:	fe 47 46             	incb   0x46(%edi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c00082bd:	84 db                	test   %bl,%bl
c00082bf:	74 2a                	je     c00082eb <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x197>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c00082c1:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c00082c8:	74 19                	je     c00082e3 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x18f>
c00082ca:	68 40 85 01 c0       	push   $0xc0018540
c00082cf:	68 c0 00 00 00       	push   $0xc0
c00082d4:	68 12 61 01 c0       	push   $0xc0016112
c00082d9:	68 82 61 01 c0       	push   $0xc0016182
c00082de:	e9 b7 fe ff ff       	jmp    c000819a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x46>

            preemption = true;
c00082e3:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c00082ea:	fb                   	sti    
        }

        ALWAYS_INLINE
        inline void release (void (*c)())
        {
            if (c)
c00082eb:	b8 ba 96 00 c0       	mov    $0xc00096ba,%eax
c00082f0:	85 c0                	test   %eax,%eax
c00082f2:	74 03                	je     c00082f7 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x1a3>
                cont = c;
c00082f4:	89 46 50             	mov    %eax,0x50(%esi)

            Lock_guard <Spinlock> guard (lock);
c00082f7:	8d 46 46             	lea    0x46(%esi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c00082fa:	9c                   	pushf  
c00082fb:	5b                   	pop    %ebx
            return flags & 0x200;
c00082fc:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c00082ff:	80 e3 01             	and    $0x1,%bl
c0008302:	74 15                	je     c0008319 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x1c5>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0008304:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000830b:	0f 84 e9 fe ff ff    	je     c00081fa <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0xa6>

            asm volatile ("cli" : : : "memory");
c0008311:	fa                   	cli    
            preemption = false;
c0008312:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c0008319:	e8 0e 88 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c000831e:	8b 7e 4c             	mov    0x4c(%esi),%edi
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c0008321:	85 ff                	test   %edi,%edi
c0008323:	74 71                	je     c0008396 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x242>
c0008325:	8b 47 74             	mov    0x74(%edi),%eax
c0008328:	85 c0                	test   %eax,%eax
c000832a:	74 6a                	je     c0008396 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x242>
c000832c:	8b 57 70             	mov    0x70(%edi),%edx
c000832f:	85 d2                	test   %edx,%edx
c0008331:	74 63                	je     c0008396 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x242>
                return false;

            if (t == t->next)
c0008333:	39 c7                	cmp    %eax,%edi
c0008335:	75 09                	jne    c0008340 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x1ec>
                headptr = nullptr;
c0008337:	c7 46 4c 00 00 00 00 	movl   $0x0,0x4c(%esi)
c000833e:	eb 17                	jmp    c0008357 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x203>

            else {
                t->next->prev = t->prev;
c0008340:	89 50 70             	mov    %edx,0x70(%eax)
                t->prev->next = t->next;
c0008343:	8b 47 70             	mov    0x70(%edi),%eax
c0008346:	8b 57 74             	mov    0x74(%edi),%edx
c0008349:	89 50 74             	mov    %edx,0x74(%eax)
                if (t == headptr)
c000834c:	3b 7e 4c             	cmp    0x4c(%esi),%edi
c000834f:	75 06                	jne    c0008357 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x203>
                    headptr = t->next;
c0008351:	8b 47 74             	mov    0x74(%edi),%eax
c0008354:	89 46 4c             	mov    %eax,0x4c(%esi)
            }

            t->next = t->prev = nullptr;
c0008357:	c7 47 70 00 00 00 00 	movl   $0x0,0x70(%edi)
c000835e:	83 c8 ff             	or     $0xffffffff,%eax
c0008361:	c7 47 74 00 00 00 00 	movl   $0x0,0x74(%edi)
c0008368:	f0 0f c1 47 48       	lock xadd %eax,0x48(%edi)

            for (Sc *s; dequeue (s = head()); ) {
                if (EXPECT_FALSE(s->del_ref()) && (this == s->ec)) {
c000836d:	48                   	dec    %eax
c000836e:	75 1d                	jne    c000838d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x239>
c0008370:	3b 77 4c             	cmp    0x4c(%edi),%esi
c0008373:	75 18                	jne    c000838d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x239>
                    delete s;
c0008375:	89 f8                	mov    %edi,%eax
c0008377:	e8 fe df ff ff       	call   c000637a <_ZN2ScD1Ev>
c000837c:	89 f8                	mov    %edi,%eax
c000837e:	e8 c2 75 00 00       	call   c000f945 <_ZN2ScdlEPv>
c0008383:	eb 99                	jmp    c000831e <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x1ca>
                    if (si) {
                       if (si->queued()) return;
                       Queue<Si>::enqueue(si);
                    }

                    counter++;
c0008385:	ff 47 64             	incl   0x64(%edi)
c0008388:	fe 47 46             	incb   0x46(%edi)
c000838b:	eb 0c                	jmp    c0008399 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x245>
                    continue;
                }
                s->remote_enqueue();
c000838d:	89 f8                	mov    %edi,%eax
c000838f:	e8 a8 73 00 00       	call   c000f73c <_ZN2Sc14remote_enqueueEv>
c0008394:	eb 88                	jmp    c000831e <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x1ca>
c0008396:	fe 46 46             	incb   0x46(%esi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c0008399:	84 db                	test   %bl,%bl
c000839b:	74 15                	je     c00083b2 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x25e>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000839d:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c00083a4:	0f 85 20 ff ff ff    	jne    c00082ca <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x176>

            preemption = true;
c00083aa:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c00083b1:	fb                   	sti    

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
c00083b2:	8b 1d 08 f0 ff cf    	mov    0xcffff008,%ebx
c00083b8:	8b 53 14             	mov    0x14(%ebx),%edx
    current->utcb    = nullptr;
    current->fpu     = nullptr;

    Rcu::call(current);
c00083bb:	8d 73 0c             	lea    0xc(%ebx),%esi
    assert (current->utcb);
    assert (Sc::current->ec == current);

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
c00083be:	c7 83 b0 00 00 00 00 	movl   $0x0,0xb0(%ebx)
c00083c5:	00 00 00 
    current->utcb    = nullptr;
c00083c8:	c7 83 b4 00 00 00 00 	movl   $0x0,0xb4(%ebx)
c00083cf:	00 00 00 
    current->fpu     = nullptr;
c00083d2:	c7 83 c8 00 00 00 00 	movl   $0x0,0xc8(%ebx)
c00083d9:	00 00 00 
c00083dc:	85 d2                	test   %edx,%edx
c00083de:	74 04                	je     c00083e4 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x290>
                e->pre_func(e);
c00083e0:	89 f0                	mov    %esi,%eax
c00083e2:	ff d2                	call   *%edx
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
c00083e4:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
c00083e8:	75 09                	jne    c00083f3 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x29f>
c00083ea:	a1 f0 f7 ff cf       	mov    0xcffff7f0,%eax
c00083ef:	39 f0                	cmp    %esi,%eax
c00083f1:	75 29                	jne    c000841c <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x2c8>
                trace (0, "warning: rcu element already enqueued");
c00083f3:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c00083f7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c00083fc:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c0008401:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0008406:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c000840d:	50                   	push   %eax
c000840e:	68 ae 6c 01 c0       	push   $0xc0016cae
c0008413:	e8 c6 95 ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c0008418:	59                   	pop    %ecx
c0008419:	5b                   	pop    %ebx
c000841a:	eb 0e                	jmp    c000842a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x2d6>
                return;
            }

            count ++;
c000841c:	ff 05 f4 f7 ff cf    	incl   0xcffff7f4

           *tail = e;
c0008422:	89 30                	mov    %esi,(%eax)
            tail = &e->next;
c0008424:	89 35 f0 f7 ff cf    	mov    %esi,0xcffff7f0

    Rcu::call(current);
    Rcu::call(Sc::current);
c000842a:	8b 35 10 f0 ff cf    	mov    0xcffff010,%esi
c0008430:	85 f6                	test   %esi,%esi
c0008432:	74 63                	je     c0008497 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x343>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
c0008434:	8b 56 14             	mov    0x14(%esi),%edx
c0008437:	8d 5e 0c             	lea    0xc(%esi),%ebx
c000843a:	85 d2                	test   %edx,%edx
c000843c:	74 04                	je     c0008442 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x2ee>
                e->pre_func(e);
c000843e:	89 d8                	mov    %ebx,%eax
c0008440:	ff d2                	call   *%edx
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
c0008442:	83 7e 0c 00          	cmpl   $0x0,0xc(%esi)
c0008446:	75 09                	jne    c0008451 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x2fd>
c0008448:	a1 f0 f7 ff cf       	mov    0xcffff7f0,%eax
c000844d:	39 d8                	cmp    %ebx,%eax
c000844f:	75 29                	jne    c000847a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x326>
                trace (0, "warning: rcu element already enqueued");
c0008451:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c0008455:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c000845a:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c000845f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0008464:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c000846b:	50                   	push   %eax
c000846c:	68 ae 6c 01 c0       	push   $0xc0016cae
c0008471:	e8 68 95 ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c0008476:	58                   	pop    %eax
c0008477:	5a                   	pop    %edx
c0008478:	eb 0e                	jmp    c0008488 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x334>
                return;
            }

            count ++;
c000847a:	ff 05 f4 f7 ff cf    	incl   0xcffff7f4

           *tail = e;
c0008480:	89 18                	mov    %ebx,(%eax)
            tail = &e->next;
c0008482:	89 1d f0 f7 ff cf    	mov    %ebx,0xcffff7f0

    Sc::schedule(true);
c0008488:	ba 01 00 00 00       	mov    $0x1,%edx
c000848d:	b8 01 00 00 00       	mov    $0x1,%eax
c0008492:	e8 1b 75 00 00       	call   c000f9b2 <_ZN2Sc8scheduleEbb>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
c0008497:	a1 08 00 00 00       	mov    0x8,%eax
c000849c:	0f 0b                	ud2    

c000849e <_ZN2Ec4helpEPFvvE>:
        }

        NOINLINE
        void help (void (*c)())
        {
            if (EXPECT_TRUE (cont != dead)) {
c000849e:	81 78 50 1a 3f 00 c0 	cmpl   $0xc0003f1a,0x50(%eax)
c00084a5:	74 67                	je     c000850e <_ZN2Ec4helpEPFvvE+0x70>

                Counter::print<1,16> (++Counter::helping, Console_vga::COLOR_LIGHT_WHITE, SPN_HLP);
c00084a7:	8b 0d 28 f0 ff cf    	mov    0xcffff028,%ecx
        {
            return *reinterpret_cast<volatile typeof current *>(reinterpret_cast<mword>(&current) - CPU_LOCAL_DATA + HV_GLOBAL_CPUS + c * PAGE_SIZE);
        }

        NOINLINE
        void help (void (*c)())
c00084ad:	53                   	push   %ebx
        {
            if (EXPECT_TRUE (cont != dead)) {

                Counter::print<1,16> (++Counter::helping, Console_vga::COLOR_LIGHT_WHITE, SPN_HLP);
c00084ae:	8d 59 01             	lea    0x1(%ecx),%ebx
c00084b1:	8b 0d 50 f7 ff cf    	mov    0xcffff750,%ecx
c00084b7:	89 1d 28 f0 ff cf    	mov    %ebx,0xcffff028
c00084bd:	85 c9                	test   %ecx,%ecx
c00084bf:	75 2d                	jne    c00084ee <_ZN2Ec4helpEPFvvE+0x50>
                current->cont = c;
c00084c1:	8b 0d 08 f0 ff cf    	mov    0xcffff008,%ecx
c00084c7:	89 51 50             	mov    %edx,0x50(%ecx)

                if (EXPECT_TRUE (++Sc::ctr_loop < 100))
c00084ca:	8b 15 20 fa ff cf    	mov    0xcffffa20,%edx
c00084d0:	42                   	inc    %edx
c00084d1:	83 fa 63             	cmp    $0x63,%edx
c00084d4:	89 15 20 fa ff cf    	mov    %edx,0xcffffa20
c00084da:	77 05                	ja     c00084e1 <_ZN2Ec4helpEPFvvE+0x43>
                    activate();
c00084dc:	e8 37 93 00 00       	call   c0011818 <_ZN2Ec8activateEv>

                die ("Livelock");
c00084e1:	8d 51 54             	lea    0x54(%ecx),%edx
c00084e4:	b8 0f 73 01 c0       	mov    $0xc001730f,%eax
c00084e9:	e8 1e b6 ff ff       	call   c0003b0c <_ZN2Ec3dieEPKcP8Exc_regs>
                for (unsigned i = 0; i < D; i++, val /= B)
                    Console_vga::con.put (Cpu::row, col - i, c, !i || val ? (val % B)["0123456789ABCDEF"] : ' ');
c00084ee:	83 e3 0f             	and    $0xf,%ebx
c00084f1:	66 0f be 9b 14 66 01 	movsbw -0x3ffe99ec(%ebx),%bx
c00084f8:	c0 
c00084f9:	6b c9 50             	imul   $0x50,%ecx,%ecx
c00084fc:	80 cf 0f             	or     $0xf,%bh
c00084ff:	81 c1 01 f8 df 67    	add    $0x67dff801,%ecx
c0008505:	0f b7 db             	movzwl %bx,%ebx
c0008508:	66 89 1c 09          	mov    %bx,(%ecx,%ecx,1)
c000850c:	eb b3                	jmp    c00084c1 <_ZN2Ec4helpEPFvvE+0x23>
c000850e:	c3                   	ret    
c000850f:	90                   	nop

c0008510 <_ZN2Ec8block_scEv>:
            }
        }

        NOINLINE
        void block_sc()
c0008510:	56                   	push   %esi
c0008511:	53                   	push   %ebx
c0008512:	89 c3                	mov    %eax,%ebx
c0008514:	52                   	push   %edx
        {
            {   Lock_guard <Spinlock> guard (lock);
c0008515:	8d 40 46             	lea    0x46(%eax),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c0008518:	9c                   	pushf  
c0008519:	59                   	pop    %ecx
            return flags & 0x200;
c000851a:	c1 e9 09             	shr    $0x9,%ecx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c000851d:	80 e1 01             	and    $0x1,%cl
c0008520:	74 27                	je     c0008549 <_ZN2Ec8block_scEv+0x39>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0008522:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0008529:	75 16                	jne    c0008541 <_ZN2Ec8block_scEv+0x31>
c000852b:	68 80 85 01 c0       	push   $0xc0018580
c0008530:	68 b7 00 00 00       	push   $0xb7
c0008535:	68 12 61 01 c0       	push   $0xc0016112
c000853a:	68 83 61 01 c0       	push   $0xc0016183
c000853f:	eb 4c                	jmp    c000858d <_ZN2Ec8block_scEv+0x7d>

            asm volatile ("cli" : : : "memory");
c0008541:	fa                   	cli    
            preemption = false;
c0008542:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
c0008549:	88 4c 24 03          	mov    %cl,0x3(%esp)
                Cpu::preempt_disable();

            _lock.lock();
c000854d:	e8 da 85 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
        {
            regs.add_tsc_offset (tsc);
        }

        ALWAYS_INLINE
        inline bool blocked() const { return next || !cont; }
c0008552:	8a 4c 24 03          	mov    0x3(%esp),%cl
c0008556:	83 bb c4 00 00 00 00 	cmpl   $0x0,0xc4(%ebx)
c000855d:	75 42                	jne    c00085a1 <_ZN2Ec8block_scEv+0x91>
c000855f:	83 7b 50 00          	cmpl   $0x0,0x50(%ebx)
c0008563:	74 3c                	je     c00085a1 <_ZN2Ec8block_scEv+0x91>
c0008565:	fe 43 46             	incb   0x46(%ebx)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c0008568:	84 c9                	test   %cl,%cl
c000856a:	0f 84 9a 00 00 00    	je     c000860a <_ZN2Ec8block_scEv+0xfa>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0008570:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0008577:	74 1e                	je     c0008597 <_ZN2Ec8block_scEv+0x87>
c0008579:	68 40 85 01 c0       	push   $0xc0018540
c000857e:	68 c0 00 00 00       	push   $0xc0
c0008583:	68 12 61 01 c0       	push   $0xc0016112
c0008588:	68 82 61 01 c0       	push   $0xc0016182
c000858d:	68 69 60 01 c0       	push   $0xc0016069
c0008592:	e8 af 93 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

            preemption = true;
c0008597:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000859e:	fb                   	sti    
c000859f:	eb 69                	jmp    c000860a <_ZN2Ec8block_scEv+0xfa>
            {   Lock_guard <Spinlock> guard (lock);

                if (!blocked())
                    return;

                Sc::current->add_ref();
c00085a1:	8b 15 10 f0 ff cf    	mov    0xcffff010,%edx
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c00085a7:	8b 42 48             	mov    0x48(%edx),%eax
c00085aa:	83 f8 ff             	cmp    $0xffffffff,%eax
c00085ad:	74 0a                	je     c00085b9 <_ZN2Ec8block_scEv+0xa9>
                if (Atomic::cmp_swap (ref, r, r + 1))
c00085af:	8d 70 01             	lea    0x1(%eax),%esi
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c00085b2:	f0 0f b1 72 48       	lock cmpxchg %esi,0x48(%edx)
c00085b7:	75 ee                	jne    c00085a7 <_ZN2Ec8block_scEv+0x97>
        inline T *head() const { return headptr; }

        ALWAYS_INLINE
        inline void enqueue (T *t)
        {
            if (!headptr)
c00085b9:	8b 43 4c             	mov    0x4c(%ebx),%eax
                enqueue (Sc::current);
c00085bc:	8b 15 10 f0 ff cf    	mov    0xcffff010,%edx
c00085c2:	85 c0                	test   %eax,%eax
c00085c4:	75 0b                	jne    c00085d1 <_ZN2Ec8block_scEv+0xc1>
                headptr = t->prev = t->next = t;
c00085c6:	89 52 74             	mov    %edx,0x74(%edx)
c00085c9:	89 52 70             	mov    %edx,0x70(%edx)
c00085cc:	89 53 4c             	mov    %edx,0x4c(%ebx)
c00085cf:	eb 12                	jmp    c00085e3 <_ZN2Ec8block_scEv+0xd3>
            else {
                t->next = headptr;
c00085d1:	89 42 74             	mov    %eax,0x74(%edx)
                t->prev = headptr->prev;
c00085d4:	8b 73 4c             	mov    0x4c(%ebx),%esi
c00085d7:	8b 76 70             	mov    0x70(%esi),%esi
c00085da:	89 72 70             	mov    %esi,0x70(%edx)
                t->next->prev = t->prev->next = t;
c00085dd:	89 56 74             	mov    %edx,0x74(%esi)
c00085e0:	89 50 70             	mov    %edx,0x70(%eax)
c00085e3:	fe 43 46             	incb   0x46(%ebx)
c00085e6:	84 c9                	test   %cl,%cl
c00085e8:	74 11                	je     c00085fb <_ZN2Ec8block_scEv+0xeb>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c00085ea:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c00085f1:	75 86                	jne    c0008579 <_ZN2Ec8block_scEv+0x69>

            preemption = true;
c00085f3:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c00085fa:	fb                   	sti    
            }

            Sc::schedule (true);
c00085fb:	ba 01 00 00 00       	mov    $0x1,%edx
c0008600:	b8 01 00 00 00       	mov    $0x1,%eax
c0008605:	e8 a8 73 00 00       	call   c000f9b2 <_ZN2Sc8scheduleEbb>
        }
c000860a:	58                   	pop    %eax
c000860b:	5b                   	pop    %ebx
c000860c:	5e                   	pop    %esi
c000860d:	c3                   	ret    

c000860e <_ZN2SmD1Ev>:
            if (l) lock.unlock();
            return c;
        }

        Sm (Pd *, mword, mword = 0, Sm * = nullptr, mword = 0);
        ~Sm ()
c000860e:	55                   	push   %ebp
c000860f:	57                   	push   %edi
c0008610:	89 c7                	mov    %eax,%edi
c0008612:	56                   	push   %esi
c0008613:	53                   	push   %ebx
c0008614:	51                   	push   %ecx
        ALWAYS_INLINE
        inline void up (void (*c)() = nullptr, Sm * si = nullptr)
        {
            Ec *ec;

            {   Lock_guard <Spinlock> guard (lock);
c0008615:	8d 68 46             	lea    0x46(%eax),%ebp
        }

        Sm (Pd *, mword, mword = 0, Sm * = nullptr, mword = 0);
        ~Sm ()
        {
            while (!counter)
c0008618:	83 7f 64 00          	cmpl   $0x0,0x64(%edi)
c000861c:	0f 85 ad 01 00 00    	jne    c00087cf <_ZN2SmD1Ev+0x1c1>

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c0008622:	9c                   	pushf  
c0008623:	5b                   	pop    %ebx
            return flags & 0x200;
c0008624:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c0008627:	80 e3 01             	and    $0x1,%bl
c000862a:	74 2a                	je     c0008656 <_ZN2SmD1Ev+0x48>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c000862c:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0008633:	75 19                	jne    c000864e <_ZN2SmD1Ev+0x40>
c0008635:	68 80 85 01 c0       	push   $0xc0018580
c000863a:	68 b7 00 00 00       	push   $0xb7
c000863f:	68 12 61 01 c0       	push   $0xc0016112
c0008644:	68 83 61 01 c0       	push   $0xc0016183
c0008649:	e9 d0 00 00 00       	jmp    c000871e <_ZN2SmD1Ev+0x110>

            asm volatile ("cli" : : : "memory");
c000864e:	fa                   	cli    
            preemption = false;
c000864f:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c0008656:	89 e8                	mov    %ebp,%eax
c0008658:	e8 cf 84 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c000865d:	8b 77 4c             	mov    0x4c(%edi),%esi
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c0008660:	85 f6                	test   %esi,%esi
c0008662:	0f 84 74 01 00 00    	je     c00087dc <_ZN2SmD1Ev+0x1ce>
c0008668:	8b 86 c4 00 00 00    	mov    0xc4(%esi),%eax
c000866e:	85 c0                	test   %eax,%eax
c0008670:	0f 84 66 01 00 00    	je     c00087dc <_ZN2SmD1Ev+0x1ce>
c0008676:	8b 96 c0 00 00 00    	mov    0xc0(%esi),%edx
c000867c:	85 d2                	test   %edx,%edx
c000867e:	0f 84 58 01 00 00    	je     c00087dc <_ZN2SmD1Ev+0x1ce>
                return false;

            if (t == t->next)
c0008684:	39 c6                	cmp    %eax,%esi
c0008686:	75 09                	jne    c0008691 <_ZN2SmD1Ev+0x83>
                headptr = nullptr;
c0008688:	c7 47 4c 00 00 00 00 	movl   $0x0,0x4c(%edi)
c000868f:	eb 26                	jmp    c00086b7 <_ZN2SmD1Ev+0xa9>

            else {
                t->next->prev = t->prev;
c0008691:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
                t->prev->next = t->next;
c0008697:	8b 86 c0 00 00 00    	mov    0xc0(%esi),%eax
c000869d:	8b 96 c4 00 00 00    	mov    0xc4(%esi),%edx
c00086a3:	89 90 c4 00 00 00    	mov    %edx,0xc4(%eax)
                if (t == headptr)
c00086a9:	3b 77 4c             	cmp    0x4c(%edi),%esi
c00086ac:	75 09                	jne    c00086b7 <_ZN2SmD1Ev+0xa9>
                    headptr = t->next;
c00086ae:	8b 86 c4 00 00 00    	mov    0xc4(%esi),%eax
c00086b4:	89 47 4c             	mov    %eax,0x4c(%edi)
            }

            t->next = t->prev = nullptr;
c00086b7:	c7 86 c0 00 00 00 00 	movl   $0x0,0xc0(%esi)
c00086be:	00 00 00 
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c00086c1:	83 c8 ff             	or     $0xffffffff,%eax
c00086c4:	c7 86 c4 00 00 00 00 	movl   $0x0,0xc4(%esi)
c00086cb:	00 00 00 
c00086ce:	f0 0f c1 46 48       	lock xadd %eax,0x48(%esi)

                    counter++;
                    return;
                }

                if (EXPECT_FALSE(ec->del_ref())) {
c00086d3:	48                   	dec    %eax
c00086d4:	75 24                	jne    c00086fa <_ZN2SmD1Ev+0xec>
                    delete ec;
c00086d6:	89 f0                	mov    %esi,%eax
c00086d8:	e8 31 ae ff ff       	call   c000350e <_ZN2EcD1Ev>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c00086dd:	8b 86 b8 00 00 00    	mov    0xb8(%esi),%eax
c00086e3:	89 f2                	mov    %esi,%edx
c00086e5:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c00086eb:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c00086f0:	e8 6b 7c 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
c00086f5:	e9 63 ff ff ff       	jmp    c000865d <_ZN2SmD1Ev+0x4f>
c00086fa:	fe 45 00             	incb   0x0(%ebp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c00086fd:	84 db                	test   %bl,%bl
c00086ff:	74 2f                	je     c0008730 <_ZN2SmD1Ev+0x122>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0008701:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0008708:	74 1e                	je     c0008728 <_ZN2SmD1Ev+0x11a>
c000870a:	68 40 85 01 c0       	push   $0xc0018540
c000870f:	68 c0 00 00 00       	push   $0xc0
c0008714:	68 12 61 01 c0       	push   $0xc0016112
c0008719:	68 82 61 01 c0       	push   $0xc0016182
c000871e:	68 69 60 01 c0       	push   $0xc0016069
c0008723:	e8 1e 92 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

            preemption = true;
c0008728:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000872f:	fb                   	sti    

        ALWAYS_INLINE
        inline void release (void (*c)())
        {
            if (c)
                cont = c;
c0008730:	c7 46 50 40 15 01 c0 	movl   $0xc0011540,0x50(%esi)

            Lock_guard <Spinlock> guard (lock);
c0008737:	8d 46 46             	lea    0x46(%esi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c000873a:	9c                   	pushf  
c000873b:	5b                   	pop    %ebx
            return flags & 0x200;
c000873c:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c000873f:	88 da                	mov    %bl,%dl
c0008741:	80 e2 01             	and    $0x1,%dl
c0008744:	88 54 24 03          	mov    %dl,0x3(%esp)
c0008748:	74 15                	je     c000875f <_ZN2SmD1Ev+0x151>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c000874a:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0008751:	0f 84 de fe ff ff    	je     c0008635 <_ZN2SmD1Ev+0x27>

            asm volatile ("cli" : : : "memory");
c0008757:	fa                   	cli    
            preemption = false;
c0008758:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c000875f:	e8 c8 83 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c0008764:	8b 5e 4c             	mov    0x4c(%esi),%ebx
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c0008767:	85 db                	test   %ebx,%ebx
c0008769:	0f 84 83 00 00 00    	je     c00087f2 <_ZN2SmD1Ev+0x1e4>
c000876f:	8b 43 74             	mov    0x74(%ebx),%eax
c0008772:	85 c0                	test   %eax,%eax
c0008774:	74 7c                	je     c00087f2 <_ZN2SmD1Ev+0x1e4>
c0008776:	8b 4b 70             	mov    0x70(%ebx),%ecx
c0008779:	85 c9                	test   %ecx,%ecx
c000877b:	74 75                	je     c00087f2 <_ZN2SmD1Ev+0x1e4>
                return false;

            if (t == t->next)
c000877d:	39 c3                	cmp    %eax,%ebx
c000877f:	75 09                	jne    c000878a <_ZN2SmD1Ev+0x17c>
                headptr = nullptr;
c0008781:	c7 46 4c 00 00 00 00 	movl   $0x0,0x4c(%esi)
c0008788:	eb 17                	jmp    c00087a1 <_ZN2SmD1Ev+0x193>

            else {
                t->next->prev = t->prev;
c000878a:	89 48 70             	mov    %ecx,0x70(%eax)
                t->prev->next = t->next;
c000878d:	8b 43 70             	mov    0x70(%ebx),%eax
c0008790:	8b 4b 74             	mov    0x74(%ebx),%ecx
c0008793:	89 48 74             	mov    %ecx,0x74(%eax)
                if (t == headptr)
c0008796:	3b 5e 4c             	cmp    0x4c(%esi),%ebx
c0008799:	75 06                	jne    c00087a1 <_ZN2SmD1Ev+0x193>
                    headptr = t->next;
c000879b:	8b 43 74             	mov    0x74(%ebx),%eax
c000879e:	89 46 4c             	mov    %eax,0x4c(%esi)
            }

            t->next = t->prev = nullptr;
c00087a1:	c7 43 70 00 00 00 00 	movl   $0x0,0x70(%ebx)
c00087a8:	83 c8 ff             	or     $0xffffffff,%eax
c00087ab:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
c00087b2:	f0 0f c1 43 48       	lock xadd %eax,0x48(%ebx)

            for (Sc *s; dequeue (s = head()); ) {
                if (EXPECT_FALSE(s->del_ref()) && (this == s->ec)) {
c00087b7:	48                   	dec    %eax
c00087b8:	75 2c                	jne    c00087e6 <_ZN2SmD1Ev+0x1d8>
c00087ba:	3b 73 4c             	cmp    0x4c(%ebx),%esi
c00087bd:	75 27                	jne    c00087e6 <_ZN2SmD1Ev+0x1d8>
                    delete s;
c00087bf:	89 d8                	mov    %ebx,%eax
c00087c1:	e8 b4 db ff ff       	call   c000637a <_ZN2ScD1Ev>
c00087c6:	89 d8                	mov    %ebx,%eax
c00087c8:	e8 78 71 00 00       	call   c000f945 <_ZN2ScdlEPv>
c00087cd:	eb 95                	jmp    c0008764 <_ZN2SmD1Ev+0x156>
        Sm (Pd *, mword, mword = 0, Sm * = nullptr, mword = 0);
        ~Sm ()
        {
            while (!counter)
                up (Ec::sys_finish<Sys_regs::BAD_CAP, true>);
        }
c00087cf:	5a                   	pop    %edx
            return c;
        }

        Sm (Pd *, mword, mword = 0, Sm * = nullptr, mword = 0);
        ~Sm ()
        {
c00087d0:	8d 47 54             	lea    0x54(%edi),%eax
            while (!counter)
                up (Ec::sys_finish<Sys_regs::BAD_CAP, true>);
        }
c00087d3:	5b                   	pop    %ebx
c00087d4:	5e                   	pop    %esi
c00087d5:	5f                   	pop    %edi
c00087d6:	5d                   	pop    %ebp
            return c;
        }

        Sm (Pd *, mword, mword = 0, Sm * = nullptr, mword = 0);
        ~Sm ()
        {
c00087d7:	e9 b8 73 00 00       	jmp    c000fb94 <_ZN2SiD1Ev>
                    if (si) {
                       if (si->queued()) return;
                       Queue<Si>::enqueue(si);
                    }

                    counter++;
c00087dc:	ff 47 64             	incl   0x64(%edi)
c00087df:	fe 45 00             	incb   0x0(%ebp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c00087e2:	84 db                	test   %bl,%bl
c00087e4:	eb 14                	jmp    c00087fa <_ZN2SmD1Ev+0x1ec>
                    continue;
                }
                s->remote_enqueue();
c00087e6:	89 d8                	mov    %ebx,%eax
c00087e8:	e8 4f 6f 00 00       	call   c000f73c <_ZN2Sc14remote_enqueueEv>
c00087ed:	e9 72 ff ff ff       	jmp    c0008764 <_ZN2SmD1Ev+0x156>
c00087f2:	fe 46 46             	incb   0x46(%esi)
c00087f5:	80 7c 24 03 00       	cmpb   $0x0,0x3(%esp)
c00087fa:	0f 84 18 fe ff ff    	je     c0008618 <_ZN2SmD1Ev+0xa>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0008800:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0008807:	0f 85 fd fe ff ff    	jne    c000870a <_ZN2SmD1Ev+0xfc>

            preemption = true;
c000880d:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c0008814:	fb                   	sti    
c0008815:	e9 fe fd ff ff       	jmp    c0008618 <_ZN2SmD1Ev+0xa>

c000881a <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvv>:
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
c000881a:	55                   	push   %ebp
{
    assert (current->xcpu_sm);
c000881b:	a1 08 f0 ff cf       	mov    0xcffff008,%eax

    Sc::schedule(true);
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
c0008820:	57                   	push   %edi
c0008821:	56                   	push   %esi
c0008822:	53                   	push   %ebx
{
    assert (current->xcpu_sm);
c0008823:	8b 98 f4 00 00 00    	mov    0xf4(%eax),%ebx
c0008829:	85 db                	test   %ebx,%ebx
c000882b:	75 19                	jne    c0008846 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvv+0x2c>
c000882d:	68 c0 85 01 c0       	push   $0xc00185c0
c0008832:	68 9b 00 00 00       	push   $0x9b
c0008837:	68 a3 72 01 c0       	push   $0xc00172a3
c000883c:	68 66 6c 01 c0       	push   $0xc0016c66
c0008841:	e9 f2 00 00 00       	jmp    c0008938 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvv+0x11e>

    Sm::destroy(current->xcpu_sm, Pd::current->quota);
c0008846:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c000884b:	8d b0 90 01 00 00    	lea    0x190(%eax),%esi

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void destroy(Sm *obj, Quota &quota) { obj->~Sm(); cache.free (obj, quota); }
c0008851:	89 d8                	mov    %ebx,%eax
c0008853:	e8 b6 fd ff ff       	call   c000860e <_ZN2SmD1Ev>
c0008858:	89 f1                	mov    %esi,%ecx
c000885a:	89 da                	mov    %ebx,%edx
c000885c:	b8 b4 b4 01 c0       	mov    $0xc001b4b4,%eax
c0008861:	e8 fa 7a 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
    current->xcpu_sm = nullptr;
c0008866:	8b 35 08 f0 ff cf    	mov    0xcffff008,%esi
c000886c:	83 c8 ff             	or     $0xffffffff,%eax
c000886f:	c7 86 f4 00 00 00 00 	movl   $0x0,0xf4(%esi)
c0008876:	00 00 00 
        }

        ALWAYS_INLINE
        inline bool del_ref()
        {
            return Atomic::sub (ref, 1U) == 0;
c0008879:	8d 5e 48             	lea    0x48(%esi),%ebx

    current->cont = C;
c000887c:	c7 46 50 ae 04 00 c0 	movl   $0xc00004ae,0x50(%esi)
c0008883:	f0 0f c1 03          	lock xadd %eax,(%ebx)
        }

        ALWAYS_INLINE NORETURN
        inline void make_current()
        {
            if (EXPECT_FALSE(current->del_ref())) {
c0008887:	48                   	dec    %eax
c0008888:	75 29                	jne    c00088b3 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvv+0x99>
                delete current;
c000888a:	8b 3d 08 f0 ff cf    	mov    0xcffff008,%edi
c0008890:	85 ff                	test   %edi,%edi
c0008892:	74 1f                	je     c00088b3 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvv+0x99>
c0008894:	89 f8                	mov    %edi,%eax
c0008896:	e8 73 ac ff ff       	call   c000350e <_ZN2EcD1Ev>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c000889b:	8b 87 b8 00 00 00    	mov    0xb8(%edi),%eax
c00088a1:	89 fa                	mov    %edi,%edx
c00088a3:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c00088a9:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c00088ae:	e8 ad 7a 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
        {
            if (EXPECT_FALSE(current->del_ref())) {
                delete current;
            }

            current = this;
c00088b3:	89 35 08 f0 ff cf    	mov    %esi,0xcffff008
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c00088b9:	8b 46 48             	mov    0x48(%esi),%eax
c00088bc:	85 c0                	test   %eax,%eax
c00088be:	74 09                	je     c00088c9 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvv+0xaf>
                if (Atomic::cmp_swap (ref, r, r + 1))
c00088c0:	8d 50 01             	lea    0x1(%eax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c00088c3:	f0 0f b1 13          	lock cmpxchg %edx,(%ebx)
c00088c7:	75 f0                	jne    c00088b9 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvv+0x9f>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
c00088c9:	8b 9e b8 00 00 00    	mov    0xb8(%esi),%ebx

            current->add_ref();

            Tss::run.sp0 = reinterpret_cast<mword>(exc_regs() + 1);
c00088cf:	8d 86 a0 00 00 00    	lea    0xa0(%esi),%eax
c00088d5:	a3 c4 fa ff cf       	mov    %eax,0xcffffac4
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
c00088da:	8b 0d 04 f0 ff cf    	mov    0xcffff004,%ecx
c00088e0:	8b 83 70 01 00 00    	mov    0x170(%ebx),%eax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
c00088e6:	8b 93 68 01 00 00    	mov    0x168(%ebx),%edx

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
c00088ec:	0f a3 c8             	bt     %ecx,%eax
c00088ef:	73 10                	jae    c0008901 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvv+0xe7>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
c00088f1:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
c00088f6:	d3 c0                	rol    %cl,%eax
c00088f8:	f0 21 83 70 01 00 00 	lock and %eax,0x170(%ebx)
c00088ff:	eb 0c                	jmp    c000890d <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvv+0xf3>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
c0008901:	39 1d 0c f0 ff cf    	cmp    %ebx,0xcffff00c
c0008907:	0f 84 a2 00 00 00    	je     c00089af <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvv+0x195>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c000890d:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c0008912:	83 c9 ff             	or     $0xffffffff,%ecx
c0008915:	f0 0f c1 48 48       	lock xadd %ecx,0x48(%eax)
                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
c000891a:	49                   	dec    %ecx
c000891b:	75 25                	jne    c0008942 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvv+0x128>
                assert (current != this);
c000891d:	8b 3d 0c f0 ff cf    	mov    0xcffff00c,%edi
c0008923:	39 df                	cmp    %ebx,%edi
c0008925:	75 1d                	jne    c0008944 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvv+0x12a>
c0008927:	68 a4 85 01 c0       	push   $0xc00185a4
c000892c:	6a 5e                	push   $0x5e
c000892e:	68 18 73 01 c0       	push   $0xc0017318
c0008933:	68 87 73 01 c0       	push   $0xc0017387
c0008938:	68 69 60 01 c0       	push   $0xc0016069
c000893d:	e8 04 90 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
c0008942:	31 ff                	xor    %edi,%edi
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
c0008944:	89 1d 0c f0 ff cf    	mov    %ebx,0xcffff00c
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c000894a:	8b 43 48             	mov    0x48(%ebx),%eax
c000894d:	85 c0                	test   %eax,%eax
c000894f:	74 0a                	je     c000895b <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvv+0x141>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0008951:	8d 48 01             	lea    0x1(%eax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c0008954:	f0 0f b1 4b 48       	lock cmpxchg %ecx,0x48(%ebx)
c0008959:	75 ef                	jne    c000894a <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvv+0x130>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
c000895b:	31 ed                	xor    %ebp,%ebp
        }

        ALWAYS_INLINE
        inline void make_current (mword pcid)
        {
            asm volatile ("mov %0, %%cr3" : : "r" (val | pcid) : "memory");
c000895d:	a1 04 f0 ff cf       	mov    0xcffff004,%eax
c0008962:	f6 05 0a f7 ff cf 02 	testb  $0x2,0xcffff70a
c0008969:	0f 44 d5             	cmove  %ebp,%edx
c000896c:	0b 54 83 54          	or     0x54(%ebx,%eax,4),%edx
c0008970:	0f 22 da             	mov    %edx,%cr3

            if (del_pd)
c0008973:	85 ff                	test   %edi,%edi
c0008975:	74 38                	je     c00089af <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvv+0x195>
                delete del_pd;
c0008977:	89 f8                	mov    %edi,%eax

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c0008979:	89 eb                	mov    %ebp,%ebx
            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);

            if (del_pd)
                delete del_pd;
c000897b:	e8 68 40 00 00       	call   c000c9e8 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c0008980:	8b 57 28             	mov    0x28(%edi),%edx
c0008983:	85 d2                	test   %edx,%edx
c0008985:	8d 82 78 fe ff ff    	lea    -0x188(%edx),%eax
c000898b:	0f 45 d8             	cmovne %eax,%ebx

            pd_del->quota.free_up(pd_to->quota);
c000898e:	81 c3 90 01 00 00    	add    $0x190,%ebx
c0008994:	8d 87 90 01 00 00    	lea    0x190(%edi),%eax
c000899a:	89 da                	mov    %ebx,%edx
c000899c:	e8 2b a0 ff ff       	call   c00029cc <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
c00089a1:	89 d9                	mov    %ebx,%ecx
c00089a3:	89 fa                	mov    %edi,%edx
c00089a5:	b8 64 b4 01 c0       	mov    $0xc001b464,%eax
c00089aa:	e8 b1 79 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>

            pd->make_current();

            asm volatile ("mov %0," EXPAND (PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory"); UNREACHED;
c00089af:	8b 46 50             	mov    0x50(%esi),%eax
c00089b2:	bc 00 e0 ff cf       	mov    $0xcfffe000,%esp
c00089b7:	ff e0                	jmp    *%eax
c00089b9:	90                   	nop

c00089ba <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvv>:

    Sc::schedule(true);
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
c00089ba:	55                   	push   %ebp
{
    assert (current->xcpu_sm);
c00089bb:	a1 08 f0 ff cf       	mov    0xcffff008,%eax

    Sc::schedule(true);
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
c00089c0:	57                   	push   %edi
c00089c1:	56                   	push   %esi
c00089c2:	53                   	push   %ebx
{
    assert (current->xcpu_sm);
c00089c3:	8b 98 f4 00 00 00    	mov    0xf4(%eax),%ebx
c00089c9:	85 db                	test   %ebx,%ebx
c00089cb:	75 19                	jne    c00089e6 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvv+0x2c>
c00089cd:	68 20 83 01 c0       	push   $0xc0018320
c00089d2:	68 9b 00 00 00       	push   $0x9b
c00089d7:	68 a3 72 01 c0       	push   $0xc00172a3
c00089dc:	68 66 6c 01 c0       	push   $0xc0016c66
c00089e1:	e9 f2 00 00 00       	jmp    c0008ad8 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvv+0x11e>

    Sm::destroy(current->xcpu_sm, Pd::current->quota);
c00089e6:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c00089eb:	8d b0 90 01 00 00    	lea    0x190(%eax),%esi
c00089f1:	89 d8                	mov    %ebx,%eax
c00089f3:	e8 16 fc ff ff       	call   c000860e <_ZN2SmD1Ev>
c00089f8:	89 f1                	mov    %esi,%ecx
c00089fa:	89 da                	mov    %ebx,%edx
c00089fc:	b8 b4 b4 01 c0       	mov    $0xc001b4b4,%eax
c0008a01:	e8 5a 79 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
    current->xcpu_sm = nullptr;
c0008a06:	8b 35 08 f0 ff cf    	mov    0xcffff008,%esi
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c0008a0c:	83 c8 ff             	or     $0xffffffff,%eax
c0008a0f:	c7 86 f4 00 00 00 00 	movl   $0x0,0xf4(%esi)
c0008a16:	00 00 00 
        }

        ALWAYS_INLINE
        inline bool del_ref()
        {
            return Atomic::sub (ref, 1U) == 0;
c0008a19:	8d 5e 48             	lea    0x48(%esi),%ebx

    current->cont = C;
c0008a1c:	c7 46 50 70 06 00 c0 	movl   $0xc0000670,0x50(%esi)
c0008a23:	f0 0f c1 03          	lock xadd %eax,(%ebx)
        }

        ALWAYS_INLINE NORETURN
        inline void make_current()
        {
            if (EXPECT_FALSE(current->del_ref())) {
c0008a27:	48                   	dec    %eax
c0008a28:	75 29                	jne    c0008a53 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvv+0x99>
                delete current;
c0008a2a:	8b 3d 08 f0 ff cf    	mov    0xcffff008,%edi
c0008a30:	85 ff                	test   %edi,%edi
c0008a32:	74 1f                	je     c0008a53 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvv+0x99>
c0008a34:	89 f8                	mov    %edi,%eax
c0008a36:	e8 d3 aa ff ff       	call   c000350e <_ZN2EcD1Ev>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c0008a3b:	8b 87 b8 00 00 00    	mov    0xb8(%edi),%eax
c0008a41:	89 fa                	mov    %edi,%edx
c0008a43:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c0008a49:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c0008a4e:	e8 0d 79 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
        {
            if (EXPECT_FALSE(current->del_ref())) {
                delete current;
            }

            current = this;
c0008a53:	89 35 08 f0 ff cf    	mov    %esi,0xcffff008
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0008a59:	8b 46 48             	mov    0x48(%esi),%eax
c0008a5c:	85 c0                	test   %eax,%eax
c0008a5e:	74 09                	je     c0008a69 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvv+0xaf>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0008a60:	8d 50 01             	lea    0x1(%eax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c0008a63:	f0 0f b1 13          	lock cmpxchg %edx,(%ebx)
c0008a67:	75 f0                	jne    c0008a59 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvv+0x9f>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
c0008a69:	8b 9e b8 00 00 00    	mov    0xb8(%esi),%ebx

            current->add_ref();

            Tss::run.sp0 = reinterpret_cast<mword>(exc_regs() + 1);
c0008a6f:	8d 86 a0 00 00 00    	lea    0xa0(%esi),%eax
c0008a75:	a3 c4 fa ff cf       	mov    %eax,0xcffffac4
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
c0008a7a:	8b 0d 04 f0 ff cf    	mov    0xcffff004,%ecx
c0008a80:	8b 83 70 01 00 00    	mov    0x170(%ebx),%eax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
c0008a86:	8b 93 68 01 00 00    	mov    0x168(%ebx),%edx

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
c0008a8c:	0f a3 c8             	bt     %ecx,%eax
c0008a8f:	73 10                	jae    c0008aa1 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvv+0xe7>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
c0008a91:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
c0008a96:	d3 c0                	rol    %cl,%eax
c0008a98:	f0 21 83 70 01 00 00 	lock and %eax,0x170(%ebx)
c0008a9f:	eb 0c                	jmp    c0008aad <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvv+0xf3>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
c0008aa1:	39 1d 0c f0 ff cf    	cmp    %ebx,0xcffff00c
c0008aa7:	0f 84 a2 00 00 00    	je     c0008b4f <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvv+0x195>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c0008aad:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c0008ab2:	83 c9 ff             	or     $0xffffffff,%ecx
c0008ab5:	f0 0f c1 48 48       	lock xadd %ecx,0x48(%eax)
                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
c0008aba:	49                   	dec    %ecx
c0008abb:	75 25                	jne    c0008ae2 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvv+0x128>
                assert (current != this);
c0008abd:	8b 3d 0c f0 ff cf    	mov    0xcffff00c,%edi
c0008ac3:	39 df                	cmp    %ebx,%edi
c0008ac5:	75 1d                	jne    c0008ae4 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvv+0x12a>
c0008ac7:	68 a4 85 01 c0       	push   $0xc00185a4
c0008acc:	6a 5e                	push   $0x5e
c0008ace:	68 18 73 01 c0       	push   $0xc0017318
c0008ad3:	68 87 73 01 c0       	push   $0xc0017387
c0008ad8:	68 69 60 01 c0       	push   $0xc0016069
c0008add:	e8 64 8e ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
c0008ae2:	31 ff                	xor    %edi,%edi
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
c0008ae4:	89 1d 0c f0 ff cf    	mov    %ebx,0xcffff00c
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0008aea:	8b 43 48             	mov    0x48(%ebx),%eax
c0008aed:	85 c0                	test   %eax,%eax
c0008aef:	74 0a                	je     c0008afb <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvv+0x141>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0008af1:	8d 48 01             	lea    0x1(%eax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c0008af4:	f0 0f b1 4b 48       	lock cmpxchg %ecx,0x48(%ebx)
c0008af9:	75 ef                	jne    c0008aea <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvv+0x130>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
c0008afb:	31 ed                	xor    %ebp,%ebp
c0008afd:	a1 04 f0 ff cf       	mov    0xcffff004,%eax
c0008b02:	f6 05 0a f7 ff cf 02 	testb  $0x2,0xcffff70a
c0008b09:	0f 44 d5             	cmove  %ebp,%edx
c0008b0c:	0b 54 83 54          	or     0x54(%ebx,%eax,4),%edx
c0008b10:	0f 22 da             	mov    %edx,%cr3

            if (del_pd)
c0008b13:	85 ff                	test   %edi,%edi
c0008b15:	74 38                	je     c0008b4f <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvv+0x195>
                delete del_pd;
c0008b17:	89 f8                	mov    %edi,%eax

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c0008b19:	89 eb                	mov    %ebp,%ebx
            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);

            if (del_pd)
                delete del_pd;
c0008b1b:	e8 c8 3e 00 00       	call   c000c9e8 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c0008b20:	8b 57 28             	mov    0x28(%edi),%edx
c0008b23:	85 d2                	test   %edx,%edx
c0008b25:	8d 82 78 fe ff ff    	lea    -0x188(%edx),%eax
c0008b2b:	0f 45 d8             	cmovne %eax,%ebx

            pd_del->quota.free_up(pd_to->quota);
c0008b2e:	81 c3 90 01 00 00    	add    $0x190,%ebx
c0008b34:	8d 87 90 01 00 00    	lea    0x190(%edi),%eax
c0008b3a:	89 da                	mov    %ebx,%edx
c0008b3c:	e8 8b 9e ff ff       	call   c00029cc <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
c0008b41:	89 d9                	mov    %ebx,%ecx
c0008b43:	89 fa                	mov    %edi,%edx
c0008b45:	b8 64 b4 01 c0       	mov    $0xc001b464,%eax
c0008b4a:	e8 11 78 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>

            pd->make_current();

            asm volatile ("mov %0," EXPAND (PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory"); UNREACHED;
c0008b4f:	8b 46 50             	mov    0x50(%esi),%eax
c0008b52:	bc 00 e0 ff cf       	mov    $0xcfffe000,%esp
c0008b57:	ff e0                	jmp    *%eax
c0008b59:	90                   	nop

c0008b5a <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvv>:

    Sc::schedule(true);
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
c0008b5a:	55                   	push   %ebp
{
    assert (current->xcpu_sm);
c0008b5b:	a1 08 f0 ff cf       	mov    0xcffff008,%eax

    Sc::schedule(true);
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
c0008b60:	57                   	push   %edi
c0008b61:	56                   	push   %esi
c0008b62:	53                   	push   %ebx
{
    assert (current->xcpu_sm);
c0008b63:	8b 98 f4 00 00 00    	mov    0xf4(%eax),%ebx
c0008b69:	85 db                	test   %ebx,%ebx
c0008b6b:	75 19                	jne    c0008b86 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvv+0x2c>
c0008b6d:	68 60 81 01 c0       	push   $0xc0018160
c0008b72:	68 9b 00 00 00       	push   $0x9b
c0008b77:	68 a3 72 01 c0       	push   $0xc00172a3
c0008b7c:	68 66 6c 01 c0       	push   $0xc0016c66
c0008b81:	e9 f2 00 00 00       	jmp    c0008c78 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvv+0x11e>

    Sm::destroy(current->xcpu_sm, Pd::current->quota);
c0008b86:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c0008b8b:	8d b0 90 01 00 00    	lea    0x190(%eax),%esi
c0008b91:	89 d8                	mov    %ebx,%eax
c0008b93:	e8 76 fa ff ff       	call   c000860e <_ZN2SmD1Ev>
c0008b98:	89 f1                	mov    %esi,%ecx
c0008b9a:	89 da                	mov    %ebx,%edx
c0008b9c:	b8 b4 b4 01 c0       	mov    $0xc001b4b4,%eax
c0008ba1:	e8 ba 77 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
    current->xcpu_sm = nullptr;
c0008ba6:	8b 35 08 f0 ff cf    	mov    0xcffff008,%esi
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c0008bac:	83 c8 ff             	or     $0xffffffff,%eax
c0008baf:	c7 86 f4 00 00 00 00 	movl   $0x0,0xf4(%esi)
c0008bb6:	00 00 00 
        }

        ALWAYS_INLINE
        inline bool del_ref()
        {
            return Atomic::sub (ref, 1U) == 0;
c0008bb9:	8d 5e 48             	lea    0x48(%esi),%ebx

    current->cont = C;
c0008bbc:	c7 46 50 7c 27 01 c0 	movl   $0xc001277c,0x50(%esi)
c0008bc3:	f0 0f c1 03          	lock xadd %eax,(%ebx)
        }

        ALWAYS_INLINE NORETURN
        inline void make_current()
        {
            if (EXPECT_FALSE(current->del_ref())) {
c0008bc7:	48                   	dec    %eax
c0008bc8:	75 29                	jne    c0008bf3 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvv+0x99>
                delete current;
c0008bca:	8b 3d 08 f0 ff cf    	mov    0xcffff008,%edi
c0008bd0:	85 ff                	test   %edi,%edi
c0008bd2:	74 1f                	je     c0008bf3 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvv+0x99>
c0008bd4:	89 f8                	mov    %edi,%eax
c0008bd6:	e8 33 a9 ff ff       	call   c000350e <_ZN2EcD1Ev>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c0008bdb:	8b 87 b8 00 00 00    	mov    0xb8(%edi),%eax
c0008be1:	89 fa                	mov    %edi,%edx
c0008be3:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c0008be9:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c0008bee:	e8 6d 77 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
        {
            if (EXPECT_FALSE(current->del_ref())) {
                delete current;
            }

            current = this;
c0008bf3:	89 35 08 f0 ff cf    	mov    %esi,0xcffff008
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0008bf9:	8b 46 48             	mov    0x48(%esi),%eax
c0008bfc:	85 c0                	test   %eax,%eax
c0008bfe:	74 09                	je     c0008c09 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvv+0xaf>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0008c00:	8d 50 01             	lea    0x1(%eax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c0008c03:	f0 0f b1 13          	lock cmpxchg %edx,(%ebx)
c0008c07:	75 f0                	jne    c0008bf9 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvv+0x9f>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
c0008c09:	8b 9e b8 00 00 00    	mov    0xb8(%esi),%ebx

            current->add_ref();

            Tss::run.sp0 = reinterpret_cast<mword>(exc_regs() + 1);
c0008c0f:	8d 86 a0 00 00 00    	lea    0xa0(%esi),%eax
c0008c15:	a3 c4 fa ff cf       	mov    %eax,0xcffffac4
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
c0008c1a:	8b 0d 04 f0 ff cf    	mov    0xcffff004,%ecx
c0008c20:	8b 83 70 01 00 00    	mov    0x170(%ebx),%eax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
c0008c26:	8b 93 68 01 00 00    	mov    0x168(%ebx),%edx

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
c0008c2c:	0f a3 c8             	bt     %ecx,%eax
c0008c2f:	73 10                	jae    c0008c41 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvv+0xe7>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
c0008c31:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
c0008c36:	d3 c0                	rol    %cl,%eax
c0008c38:	f0 21 83 70 01 00 00 	lock and %eax,0x170(%ebx)
c0008c3f:	eb 0c                	jmp    c0008c4d <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvv+0xf3>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
c0008c41:	39 1d 0c f0 ff cf    	cmp    %ebx,0xcffff00c
c0008c47:	0f 84 a2 00 00 00    	je     c0008cef <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvv+0x195>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c0008c4d:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c0008c52:	83 c9 ff             	or     $0xffffffff,%ecx
c0008c55:	f0 0f c1 48 48       	lock xadd %ecx,0x48(%eax)
                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
c0008c5a:	49                   	dec    %ecx
c0008c5b:	75 25                	jne    c0008c82 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvv+0x128>
                assert (current != this);
c0008c5d:	8b 3d 0c f0 ff cf    	mov    0xcffff00c,%edi
c0008c63:	39 df                	cmp    %ebx,%edi
c0008c65:	75 1d                	jne    c0008c84 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvv+0x12a>
c0008c67:	68 a4 85 01 c0       	push   $0xc00185a4
c0008c6c:	6a 5e                	push   $0x5e
c0008c6e:	68 18 73 01 c0       	push   $0xc0017318
c0008c73:	68 87 73 01 c0       	push   $0xc0017387
c0008c78:	68 69 60 01 c0       	push   $0xc0016069
c0008c7d:	e8 c4 8c ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
c0008c82:	31 ff                	xor    %edi,%edi
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
c0008c84:	89 1d 0c f0 ff cf    	mov    %ebx,0xcffff00c
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0008c8a:	8b 43 48             	mov    0x48(%ebx),%eax
c0008c8d:	85 c0                	test   %eax,%eax
c0008c8f:	74 0a                	je     c0008c9b <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvv+0x141>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0008c91:	8d 48 01             	lea    0x1(%eax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c0008c94:	f0 0f b1 4b 48       	lock cmpxchg %ecx,0x48(%ebx)
c0008c99:	75 ef                	jne    c0008c8a <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvv+0x130>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
c0008c9b:	31 ed                	xor    %ebp,%ebp
c0008c9d:	a1 04 f0 ff cf       	mov    0xcffff004,%eax
c0008ca2:	f6 05 0a f7 ff cf 02 	testb  $0x2,0xcffff70a
c0008ca9:	0f 44 d5             	cmove  %ebp,%edx
c0008cac:	0b 54 83 54          	or     0x54(%ebx,%eax,4),%edx
c0008cb0:	0f 22 da             	mov    %edx,%cr3

            if (del_pd)
c0008cb3:	85 ff                	test   %edi,%edi
c0008cb5:	74 38                	je     c0008cef <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvv+0x195>
                delete del_pd;
c0008cb7:	89 f8                	mov    %edi,%eax

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c0008cb9:	89 eb                	mov    %ebp,%ebx
            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);

            if (del_pd)
                delete del_pd;
c0008cbb:	e8 28 3d 00 00       	call   c000c9e8 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c0008cc0:	8b 57 28             	mov    0x28(%edi),%edx
c0008cc3:	85 d2                	test   %edx,%edx
c0008cc5:	8d 82 78 fe ff ff    	lea    -0x188(%edx),%eax
c0008ccb:	0f 45 d8             	cmovne %eax,%ebx

            pd_del->quota.free_up(pd_to->quota);
c0008cce:	81 c3 90 01 00 00    	add    $0x190,%ebx
c0008cd4:	8d 87 90 01 00 00    	lea    0x190(%edi),%eax
c0008cda:	89 da                	mov    %ebx,%edx
c0008cdc:	e8 eb 9c ff ff       	call   c00029cc <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
c0008ce1:	89 d9                	mov    %ebx,%ecx
c0008ce3:	89 fa                	mov    %edi,%edx
c0008ce5:	b8 64 b4 01 c0       	mov    $0xc001b464,%eax
c0008cea:	e8 71 76 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>

            pd->make_current();

            asm volatile ("mov %0," EXPAND (PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory"); UNREACHED;
c0008cef:	8b 46 50             	mov    0x50(%esi),%eax
c0008cf2:	bc 00 e0 ff cf       	mov    $0xcfffe000,%esp
c0008cf7:	ff e0                	jmp    *%eax
c0008cf9:	90                   	nop

c0008cfa <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvv>:

    Sc::schedule(true);
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
c0008cfa:	55                   	push   %ebp
{
    assert (current->xcpu_sm);
c0008cfb:	a1 08 f0 ff cf       	mov    0xcffff008,%eax

    Sc::schedule(true);
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
c0008d00:	57                   	push   %edi
c0008d01:	56                   	push   %esi
c0008d02:	53                   	push   %ebx
{
    assert (current->xcpu_sm);
c0008d03:	8b 98 f4 00 00 00    	mov    0xf4(%eax),%ebx
c0008d09:	85 db                	test   %ebx,%ebx
c0008d0b:	75 19                	jne    c0008d26 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvv+0x2c>
c0008d0d:	68 a0 7f 01 c0       	push   $0xc0017fa0
c0008d12:	68 9b 00 00 00       	push   $0x9b
c0008d17:	68 a3 72 01 c0       	push   $0xc00172a3
c0008d1c:	68 66 6c 01 c0       	push   $0xc0016c66
c0008d21:	e9 f2 00 00 00       	jmp    c0008e18 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvv+0x11e>

    Sm::destroy(current->xcpu_sm, Pd::current->quota);
c0008d26:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c0008d2b:	8d b0 90 01 00 00    	lea    0x190(%eax),%esi
c0008d31:	89 d8                	mov    %ebx,%eax
c0008d33:	e8 d6 f8 ff ff       	call   c000860e <_ZN2SmD1Ev>
c0008d38:	89 f1                	mov    %esi,%ecx
c0008d3a:	89 da                	mov    %ebx,%edx
c0008d3c:	b8 b4 b4 01 c0       	mov    $0xc001b4b4,%eax
c0008d41:	e8 1a 76 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
    current->xcpu_sm = nullptr;
c0008d46:	8b 35 08 f0 ff cf    	mov    0xcffff008,%esi
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c0008d4c:	83 c8 ff             	or     $0xffffffff,%eax
c0008d4f:	c7 86 f4 00 00 00 00 	movl   $0x0,0xf4(%esi)
c0008d56:	00 00 00 
        }

        ALWAYS_INLINE
        inline bool del_ref()
        {
            return Atomic::sub (ref, 1U) == 0;
c0008d59:	8d 5e 48             	lea    0x48(%esi),%ebx

    current->cont = C;
c0008d5c:	c7 46 50 98 29 01 c0 	movl   $0xc0012998,0x50(%esi)
c0008d63:	f0 0f c1 03          	lock xadd %eax,(%ebx)
        }

        ALWAYS_INLINE NORETURN
        inline void make_current()
        {
            if (EXPECT_FALSE(current->del_ref())) {
c0008d67:	48                   	dec    %eax
c0008d68:	75 29                	jne    c0008d93 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvv+0x99>
                delete current;
c0008d6a:	8b 3d 08 f0 ff cf    	mov    0xcffff008,%edi
c0008d70:	85 ff                	test   %edi,%edi
c0008d72:	74 1f                	je     c0008d93 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvv+0x99>
c0008d74:	89 f8                	mov    %edi,%eax
c0008d76:	e8 93 a7 ff ff       	call   c000350e <_ZN2EcD1Ev>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c0008d7b:	8b 87 b8 00 00 00    	mov    0xb8(%edi),%eax
c0008d81:	89 fa                	mov    %edi,%edx
c0008d83:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c0008d89:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c0008d8e:	e8 cd 75 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
        {
            if (EXPECT_FALSE(current->del_ref())) {
                delete current;
            }

            current = this;
c0008d93:	89 35 08 f0 ff cf    	mov    %esi,0xcffff008
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0008d99:	8b 46 48             	mov    0x48(%esi),%eax
c0008d9c:	85 c0                	test   %eax,%eax
c0008d9e:	74 09                	je     c0008da9 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvv+0xaf>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0008da0:	8d 50 01             	lea    0x1(%eax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c0008da3:	f0 0f b1 13          	lock cmpxchg %edx,(%ebx)
c0008da7:	75 f0                	jne    c0008d99 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvv+0x9f>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
c0008da9:	8b 9e b8 00 00 00    	mov    0xb8(%esi),%ebx

            current->add_ref();

            Tss::run.sp0 = reinterpret_cast<mword>(exc_regs() + 1);
c0008daf:	8d 86 a0 00 00 00    	lea    0xa0(%esi),%eax
c0008db5:	a3 c4 fa ff cf       	mov    %eax,0xcffffac4
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
c0008dba:	8b 0d 04 f0 ff cf    	mov    0xcffff004,%ecx
c0008dc0:	8b 83 70 01 00 00    	mov    0x170(%ebx),%eax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
c0008dc6:	8b 93 68 01 00 00    	mov    0x168(%ebx),%edx

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
c0008dcc:	0f a3 c8             	bt     %ecx,%eax
c0008dcf:	73 10                	jae    c0008de1 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvv+0xe7>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
c0008dd1:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
c0008dd6:	d3 c0                	rol    %cl,%eax
c0008dd8:	f0 21 83 70 01 00 00 	lock and %eax,0x170(%ebx)
c0008ddf:	eb 0c                	jmp    c0008ded <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvv+0xf3>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
c0008de1:	39 1d 0c f0 ff cf    	cmp    %ebx,0xcffff00c
c0008de7:	0f 84 a2 00 00 00    	je     c0008e8f <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvv+0x195>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c0008ded:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c0008df2:	83 c9 ff             	or     $0xffffffff,%ecx
c0008df5:	f0 0f c1 48 48       	lock xadd %ecx,0x48(%eax)
                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
c0008dfa:	49                   	dec    %ecx
c0008dfb:	75 25                	jne    c0008e22 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvv+0x128>
                assert (current != this);
c0008dfd:	8b 3d 0c f0 ff cf    	mov    0xcffff00c,%edi
c0008e03:	39 df                	cmp    %ebx,%edi
c0008e05:	75 1d                	jne    c0008e24 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvv+0x12a>
c0008e07:	68 a4 85 01 c0       	push   $0xc00185a4
c0008e0c:	6a 5e                	push   $0x5e
c0008e0e:	68 18 73 01 c0       	push   $0xc0017318
c0008e13:	68 87 73 01 c0       	push   $0xc0017387
c0008e18:	68 69 60 01 c0       	push   $0xc0016069
c0008e1d:	e8 24 8b ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
c0008e22:	31 ff                	xor    %edi,%edi
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
c0008e24:	89 1d 0c f0 ff cf    	mov    %ebx,0xcffff00c
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0008e2a:	8b 43 48             	mov    0x48(%ebx),%eax
c0008e2d:	85 c0                	test   %eax,%eax
c0008e2f:	74 0a                	je     c0008e3b <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvv+0x141>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0008e31:	8d 48 01             	lea    0x1(%eax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c0008e34:	f0 0f b1 4b 48       	lock cmpxchg %ecx,0x48(%ebx)
c0008e39:	75 ef                	jne    c0008e2a <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvv+0x130>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
c0008e3b:	31 ed                	xor    %ebp,%ebp
c0008e3d:	a1 04 f0 ff cf       	mov    0xcffff004,%eax
c0008e42:	f6 05 0a f7 ff cf 02 	testb  $0x2,0xcffff70a
c0008e49:	0f 44 d5             	cmove  %ebp,%edx
c0008e4c:	0b 54 83 54          	or     0x54(%ebx,%eax,4),%edx
c0008e50:	0f 22 da             	mov    %edx,%cr3

            if (del_pd)
c0008e53:	85 ff                	test   %edi,%edi
c0008e55:	74 38                	je     c0008e8f <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvv+0x195>
                delete del_pd;
c0008e57:	89 f8                	mov    %edi,%eax

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c0008e59:	89 eb                	mov    %ebp,%ebx
            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);

            if (del_pd)
                delete del_pd;
c0008e5b:	e8 88 3b 00 00       	call   c000c9e8 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c0008e60:	8b 57 28             	mov    0x28(%edi),%edx
c0008e63:	85 d2                	test   %edx,%edx
c0008e65:	8d 82 78 fe ff ff    	lea    -0x188(%edx),%eax
c0008e6b:	0f 45 d8             	cmovne %eax,%ebx

            pd_del->quota.free_up(pd_to->quota);
c0008e6e:	81 c3 90 01 00 00    	add    $0x190,%ebx
c0008e74:	8d 87 90 01 00 00    	lea    0x190(%edi),%eax
c0008e7a:	89 da                	mov    %ebx,%edx
c0008e7c:	e8 4b 9b ff ff       	call   c00029cc <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
c0008e81:	89 d9                	mov    %ebx,%ecx
c0008e83:	89 fa                	mov    %edi,%edx
c0008e85:	b8 64 b4 01 c0       	mov    $0xc001b464,%eax
c0008e8a:	e8 d1 74 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>

            pd->make_current();

            asm volatile ("mov %0," EXPAND (PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory"); UNREACHED;
c0008e8f:	8b 46 50             	mov    0x50(%esi),%eax
c0008e92:	bc 00 e0 ff cf       	mov    $0xcfffe000,%esp
c0008e97:	ff e0                	jmp    *%eax
c0008e99:	90                   	nop

c0008e9a <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvv>:

    Sc::schedule(true);
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
c0008e9a:	55                   	push   %ebp
{
    assert (current->xcpu_sm);
c0008e9b:	a1 08 f0 ff cf       	mov    0xcffff008,%eax

    Sc::schedule(true);
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
c0008ea0:	57                   	push   %edi
c0008ea1:	56                   	push   %esi
c0008ea2:	53                   	push   %ebx
{
    assert (current->xcpu_sm);
c0008ea3:	8b 98 f4 00 00 00    	mov    0xf4(%eax),%ebx
c0008ea9:	85 db                	test   %ebx,%ebx
c0008eab:	75 19                	jne    c0008ec6 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvv+0x2c>
c0008ead:	68 e0 7d 01 c0       	push   $0xc0017de0
c0008eb2:	68 9b 00 00 00       	push   $0x9b
c0008eb7:	68 a3 72 01 c0       	push   $0xc00172a3
c0008ebc:	68 66 6c 01 c0       	push   $0xc0016c66
c0008ec1:	e9 f2 00 00 00       	jmp    c0008fb8 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvv+0x11e>

    Sm::destroy(current->xcpu_sm, Pd::current->quota);
c0008ec6:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c0008ecb:	8d b0 90 01 00 00    	lea    0x190(%eax),%esi
c0008ed1:	89 d8                	mov    %ebx,%eax
c0008ed3:	e8 36 f7 ff ff       	call   c000860e <_ZN2SmD1Ev>
c0008ed8:	89 f1                	mov    %esi,%ecx
c0008eda:	89 da                	mov    %ebx,%edx
c0008edc:	b8 b4 b4 01 c0       	mov    $0xc001b4b4,%eax
c0008ee1:	e8 7a 74 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
    current->xcpu_sm = nullptr;
c0008ee6:	8b 35 08 f0 ff cf    	mov    0xcffff008,%esi
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c0008eec:	83 c8 ff             	or     $0xffffffff,%eax
c0008eef:	c7 86 f4 00 00 00 00 	movl   $0x0,0xf4(%esi)
c0008ef6:	00 00 00 
        }

        ALWAYS_INLINE
        inline bool del_ref()
        {
            return Atomic::sub (ref, 1U) == 0;
c0008ef9:	8d 5e 48             	lea    0x48(%esi),%ebx

    current->cont = C;
c0008efc:	c7 46 50 72 34 01 c0 	movl   $0xc0013472,0x50(%esi)
c0008f03:	f0 0f c1 03          	lock xadd %eax,(%ebx)
        }

        ALWAYS_INLINE NORETURN
        inline void make_current()
        {
            if (EXPECT_FALSE(current->del_ref())) {
c0008f07:	48                   	dec    %eax
c0008f08:	75 29                	jne    c0008f33 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvv+0x99>
                delete current;
c0008f0a:	8b 3d 08 f0 ff cf    	mov    0xcffff008,%edi
c0008f10:	85 ff                	test   %edi,%edi
c0008f12:	74 1f                	je     c0008f33 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvv+0x99>
c0008f14:	89 f8                	mov    %edi,%eax
c0008f16:	e8 f3 a5 ff ff       	call   c000350e <_ZN2EcD1Ev>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c0008f1b:	8b 87 b8 00 00 00    	mov    0xb8(%edi),%eax
c0008f21:	89 fa                	mov    %edi,%edx
c0008f23:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c0008f29:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c0008f2e:	e8 2d 74 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
        {
            if (EXPECT_FALSE(current->del_ref())) {
                delete current;
            }

            current = this;
c0008f33:	89 35 08 f0 ff cf    	mov    %esi,0xcffff008
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0008f39:	8b 46 48             	mov    0x48(%esi),%eax
c0008f3c:	85 c0                	test   %eax,%eax
c0008f3e:	74 09                	je     c0008f49 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvv+0xaf>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0008f40:	8d 50 01             	lea    0x1(%eax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c0008f43:	f0 0f b1 13          	lock cmpxchg %edx,(%ebx)
c0008f47:	75 f0                	jne    c0008f39 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvv+0x9f>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
c0008f49:	8b 9e b8 00 00 00    	mov    0xb8(%esi),%ebx

            current->add_ref();

            Tss::run.sp0 = reinterpret_cast<mword>(exc_regs() + 1);
c0008f4f:	8d 86 a0 00 00 00    	lea    0xa0(%esi),%eax
c0008f55:	a3 c4 fa ff cf       	mov    %eax,0xcffffac4
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
c0008f5a:	8b 0d 04 f0 ff cf    	mov    0xcffff004,%ecx
c0008f60:	8b 83 70 01 00 00    	mov    0x170(%ebx),%eax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
c0008f66:	8b 93 68 01 00 00    	mov    0x168(%ebx),%edx

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
c0008f6c:	0f a3 c8             	bt     %ecx,%eax
c0008f6f:	73 10                	jae    c0008f81 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvv+0xe7>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
c0008f71:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
c0008f76:	d3 c0                	rol    %cl,%eax
c0008f78:	f0 21 83 70 01 00 00 	lock and %eax,0x170(%ebx)
c0008f7f:	eb 0c                	jmp    c0008f8d <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvv+0xf3>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
c0008f81:	39 1d 0c f0 ff cf    	cmp    %ebx,0xcffff00c
c0008f87:	0f 84 a2 00 00 00    	je     c000902f <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvv+0x195>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c0008f8d:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c0008f92:	83 c9 ff             	or     $0xffffffff,%ecx
c0008f95:	f0 0f c1 48 48       	lock xadd %ecx,0x48(%eax)
                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
c0008f9a:	49                   	dec    %ecx
c0008f9b:	75 25                	jne    c0008fc2 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvv+0x128>
                assert (current != this);
c0008f9d:	8b 3d 0c f0 ff cf    	mov    0xcffff00c,%edi
c0008fa3:	39 df                	cmp    %ebx,%edi
c0008fa5:	75 1d                	jne    c0008fc4 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvv+0x12a>
c0008fa7:	68 a4 85 01 c0       	push   $0xc00185a4
c0008fac:	6a 5e                	push   $0x5e
c0008fae:	68 18 73 01 c0       	push   $0xc0017318
c0008fb3:	68 87 73 01 c0       	push   $0xc0017387
c0008fb8:	68 69 60 01 c0       	push   $0xc0016069
c0008fbd:	e8 84 89 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
c0008fc2:	31 ff                	xor    %edi,%edi
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
c0008fc4:	89 1d 0c f0 ff cf    	mov    %ebx,0xcffff00c
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0008fca:	8b 43 48             	mov    0x48(%ebx),%eax
c0008fcd:	85 c0                	test   %eax,%eax
c0008fcf:	74 0a                	je     c0008fdb <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvv+0x141>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0008fd1:	8d 48 01             	lea    0x1(%eax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c0008fd4:	f0 0f b1 4b 48       	lock cmpxchg %ecx,0x48(%ebx)
c0008fd9:	75 ef                	jne    c0008fca <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvv+0x130>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
c0008fdb:	31 ed                	xor    %ebp,%ebp
c0008fdd:	a1 04 f0 ff cf       	mov    0xcffff004,%eax
c0008fe2:	f6 05 0a f7 ff cf 02 	testb  $0x2,0xcffff70a
c0008fe9:	0f 44 d5             	cmove  %ebp,%edx
c0008fec:	0b 54 83 54          	or     0x54(%ebx,%eax,4),%edx
c0008ff0:	0f 22 da             	mov    %edx,%cr3

            if (del_pd)
c0008ff3:	85 ff                	test   %edi,%edi
c0008ff5:	74 38                	je     c000902f <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvv+0x195>
                delete del_pd;
c0008ff7:	89 f8                	mov    %edi,%eax

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c0008ff9:	89 eb                	mov    %ebp,%ebx
            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);

            if (del_pd)
                delete del_pd;
c0008ffb:	e8 e8 39 00 00       	call   c000c9e8 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c0009000:	8b 57 28             	mov    0x28(%edi),%edx
c0009003:	85 d2                	test   %edx,%edx
c0009005:	8d 82 78 fe ff ff    	lea    -0x188(%edx),%eax
c000900b:	0f 45 d8             	cmovne %eax,%ebx

            pd_del->quota.free_up(pd_to->quota);
c000900e:	81 c3 90 01 00 00    	add    $0x190,%ebx
c0009014:	8d 87 90 01 00 00    	lea    0x190(%edi),%eax
c000901a:	89 da                	mov    %ebx,%edx
c000901c:	e8 ab 99 ff ff       	call   c00029cc <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
c0009021:	89 d9                	mov    %ebx,%ecx
c0009023:	89 fa                	mov    %edi,%edx
c0009025:	b8 64 b4 01 c0       	mov    $0xc001b464,%eax
c000902a:	e8 31 73 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>

            pd->make_current();

            asm volatile ("mov %0," EXPAND (PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory"); UNREACHED;
c000902f:	8b 46 50             	mov    0x50(%esi),%eax
c0009032:	bc 00 e0 ff cf       	mov    $0xcfffe000,%esp
c0009037:	ff e0                	jmp    *%eax
c0009039:	90                   	nop

c000903a <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvv>:

    Sc::schedule(true);
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
c000903a:	55                   	push   %ebp
{
    assert (current->xcpu_sm);
c000903b:	a1 08 f0 ff cf       	mov    0xcffff008,%eax

    Sc::schedule(true);
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
c0009040:	57                   	push   %edi
c0009041:	56                   	push   %esi
c0009042:	53                   	push   %ebx
{
    assert (current->xcpu_sm);
c0009043:	8b 98 f4 00 00 00    	mov    0xf4(%eax),%ebx
c0009049:	85 db                	test   %ebx,%ebx
c000904b:	75 19                	jne    c0009066 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvv+0x2c>
c000904d:	68 20 7c 01 c0       	push   $0xc0017c20
c0009052:	68 9b 00 00 00       	push   $0x9b
c0009057:	68 a3 72 01 c0       	push   $0xc00172a3
c000905c:	68 66 6c 01 c0       	push   $0xc0016c66
c0009061:	e9 f2 00 00 00       	jmp    c0009158 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvv+0x11e>

    Sm::destroy(current->xcpu_sm, Pd::current->quota);
c0009066:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c000906b:	8d b0 90 01 00 00    	lea    0x190(%eax),%esi
c0009071:	89 d8                	mov    %ebx,%eax
c0009073:	e8 96 f5 ff ff       	call   c000860e <_ZN2SmD1Ev>
c0009078:	89 f1                	mov    %esi,%ecx
c000907a:	89 da                	mov    %ebx,%edx
c000907c:	b8 b4 b4 01 c0       	mov    $0xc001b4b4,%eax
c0009081:	e8 da 72 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
    current->xcpu_sm = nullptr;
c0009086:	8b 35 08 f0 ff cf    	mov    0xcffff008,%esi
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c000908c:	83 c8 ff             	or     $0xffffffff,%eax
c000908f:	c7 86 f4 00 00 00 00 	movl   $0x0,0xf4(%esi)
c0009096:	00 00 00 
        }

        ALWAYS_INLINE
        inline bool del_ref()
        {
            return Atomic::sub (ref, 1U) == 0;
c0009099:	8d 5e 48             	lea    0x48(%esi),%ebx

    current->cont = C;
c000909c:	c7 46 50 2c 28 01 c0 	movl   $0xc001282c,0x50(%esi)
c00090a3:	f0 0f c1 03          	lock xadd %eax,(%ebx)
        }

        ALWAYS_INLINE NORETURN
        inline void make_current()
        {
            if (EXPECT_FALSE(current->del_ref())) {
c00090a7:	48                   	dec    %eax
c00090a8:	75 29                	jne    c00090d3 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvv+0x99>
                delete current;
c00090aa:	8b 3d 08 f0 ff cf    	mov    0xcffff008,%edi
c00090b0:	85 ff                	test   %edi,%edi
c00090b2:	74 1f                	je     c00090d3 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvv+0x99>
c00090b4:	89 f8                	mov    %edi,%eax
c00090b6:	e8 53 a4 ff ff       	call   c000350e <_ZN2EcD1Ev>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c00090bb:	8b 87 b8 00 00 00    	mov    0xb8(%edi),%eax
c00090c1:	89 fa                	mov    %edi,%edx
c00090c3:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c00090c9:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c00090ce:	e8 8d 72 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
        {
            if (EXPECT_FALSE(current->del_ref())) {
                delete current;
            }

            current = this;
c00090d3:	89 35 08 f0 ff cf    	mov    %esi,0xcffff008
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c00090d9:	8b 46 48             	mov    0x48(%esi),%eax
c00090dc:	85 c0                	test   %eax,%eax
c00090de:	74 09                	je     c00090e9 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvv+0xaf>
                if (Atomic::cmp_swap (ref, r, r + 1))
c00090e0:	8d 50 01             	lea    0x1(%eax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c00090e3:	f0 0f b1 13          	lock cmpxchg %edx,(%ebx)
c00090e7:	75 f0                	jne    c00090d9 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvv+0x9f>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
c00090e9:	8b 9e b8 00 00 00    	mov    0xb8(%esi),%ebx

            current->add_ref();

            Tss::run.sp0 = reinterpret_cast<mword>(exc_regs() + 1);
c00090ef:	8d 86 a0 00 00 00    	lea    0xa0(%esi),%eax
c00090f5:	a3 c4 fa ff cf       	mov    %eax,0xcffffac4
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
c00090fa:	8b 0d 04 f0 ff cf    	mov    0xcffff004,%ecx
c0009100:	8b 83 70 01 00 00    	mov    0x170(%ebx),%eax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
c0009106:	8b 93 68 01 00 00    	mov    0x168(%ebx),%edx

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
c000910c:	0f a3 c8             	bt     %ecx,%eax
c000910f:	73 10                	jae    c0009121 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvv+0xe7>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
c0009111:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
c0009116:	d3 c0                	rol    %cl,%eax
c0009118:	f0 21 83 70 01 00 00 	lock and %eax,0x170(%ebx)
c000911f:	eb 0c                	jmp    c000912d <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvv+0xf3>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
c0009121:	39 1d 0c f0 ff cf    	cmp    %ebx,0xcffff00c
c0009127:	0f 84 a2 00 00 00    	je     c00091cf <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvv+0x195>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c000912d:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c0009132:	83 c9 ff             	or     $0xffffffff,%ecx
c0009135:	f0 0f c1 48 48       	lock xadd %ecx,0x48(%eax)
                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
c000913a:	49                   	dec    %ecx
c000913b:	75 25                	jne    c0009162 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvv+0x128>
                assert (current != this);
c000913d:	8b 3d 0c f0 ff cf    	mov    0xcffff00c,%edi
c0009143:	39 df                	cmp    %ebx,%edi
c0009145:	75 1d                	jne    c0009164 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvv+0x12a>
c0009147:	68 a4 85 01 c0       	push   $0xc00185a4
c000914c:	6a 5e                	push   $0x5e
c000914e:	68 18 73 01 c0       	push   $0xc0017318
c0009153:	68 87 73 01 c0       	push   $0xc0017387
c0009158:	68 69 60 01 c0       	push   $0xc0016069
c000915d:	e8 e4 87 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
c0009162:	31 ff                	xor    %edi,%edi
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
c0009164:	89 1d 0c f0 ff cf    	mov    %ebx,0xcffff00c
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c000916a:	8b 43 48             	mov    0x48(%ebx),%eax
c000916d:	85 c0                	test   %eax,%eax
c000916f:	74 0a                	je     c000917b <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvv+0x141>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0009171:	8d 48 01             	lea    0x1(%eax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c0009174:	f0 0f b1 4b 48       	lock cmpxchg %ecx,0x48(%ebx)
c0009179:	75 ef                	jne    c000916a <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvv+0x130>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
c000917b:	31 ed                	xor    %ebp,%ebp
c000917d:	a1 04 f0 ff cf       	mov    0xcffff004,%eax
c0009182:	f6 05 0a f7 ff cf 02 	testb  $0x2,0xcffff70a
c0009189:	0f 44 d5             	cmove  %ebp,%edx
c000918c:	0b 54 83 54          	or     0x54(%ebx,%eax,4),%edx
c0009190:	0f 22 da             	mov    %edx,%cr3

            if (del_pd)
c0009193:	85 ff                	test   %edi,%edi
c0009195:	74 38                	je     c00091cf <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvv+0x195>
                delete del_pd;
c0009197:	89 f8                	mov    %edi,%eax

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c0009199:	89 eb                	mov    %ebp,%ebx
            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);

            if (del_pd)
                delete del_pd;
c000919b:	e8 48 38 00 00       	call   c000c9e8 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c00091a0:	8b 57 28             	mov    0x28(%edi),%edx
c00091a3:	85 d2                	test   %edx,%edx
c00091a5:	8d 82 78 fe ff ff    	lea    -0x188(%edx),%eax
c00091ab:	0f 45 d8             	cmovne %eax,%ebx

            pd_del->quota.free_up(pd_to->quota);
c00091ae:	81 c3 90 01 00 00    	add    $0x190,%ebx
c00091b4:	8d 87 90 01 00 00    	lea    0x190(%edi),%eax
c00091ba:	89 da                	mov    %ebx,%edx
c00091bc:	e8 0b 98 ff ff       	call   c00029cc <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
c00091c1:	89 d9                	mov    %ebx,%ecx
c00091c3:	89 fa                	mov    %edi,%edx
c00091c5:	b8 64 b4 01 c0       	mov    $0xc001b464,%eax
c00091ca:	e8 91 71 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>

            pd->make_current();

            asm volatile ("mov %0," EXPAND (PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory"); UNREACHED;
c00091cf:	8b 46 50             	mov    0x50(%esi),%eax
c00091d2:	bc 00 e0 ff cf       	mov    $0xcfffe000,%esp
c00091d7:	ff e0                	jmp    *%eax
c00091d9:	90                   	nop

c00091da <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvv>:

    Sc::schedule(true);
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
c00091da:	55                   	push   %ebp
{
    assert (current->xcpu_sm);
c00091db:	a1 08 f0 ff cf       	mov    0xcffff008,%eax

    Sc::schedule(true);
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
c00091e0:	57                   	push   %edi
c00091e1:	56                   	push   %esi
c00091e2:	53                   	push   %ebx
{
    assert (current->xcpu_sm);
c00091e3:	8b 98 f4 00 00 00    	mov    0xf4(%eax),%ebx
c00091e9:	85 db                	test   %ebx,%ebx
c00091eb:	75 19                	jne    c0009206 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvv+0x2c>
c00091ed:	68 60 7a 01 c0       	push   $0xc0017a60
c00091f2:	68 9b 00 00 00       	push   $0x9b
c00091f7:	68 a3 72 01 c0       	push   $0xc00172a3
c00091fc:	68 66 6c 01 c0       	push   $0xc0016c66
c0009201:	e9 f2 00 00 00       	jmp    c00092f8 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvv+0x11e>

    Sm::destroy(current->xcpu_sm, Pd::current->quota);
c0009206:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c000920b:	8d b0 90 01 00 00    	lea    0x190(%eax),%esi
c0009211:	89 d8                	mov    %ebx,%eax
c0009213:	e8 f6 f3 ff ff       	call   c000860e <_ZN2SmD1Ev>
c0009218:	89 f1                	mov    %esi,%ecx
c000921a:	89 da                	mov    %ebx,%edx
c000921c:	b8 b4 b4 01 c0       	mov    $0xc001b4b4,%eax
c0009221:	e8 3a 71 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
    current->xcpu_sm = nullptr;
c0009226:	8b 35 08 f0 ff cf    	mov    0xcffff008,%esi
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c000922c:	83 c8 ff             	or     $0xffffffff,%eax
c000922f:	c7 86 f4 00 00 00 00 	movl   $0x0,0xf4(%esi)
c0009236:	00 00 00 
        }

        ALWAYS_INLINE
        inline bool del_ref()
        {
            return Atomic::sub (ref, 1U) == 0;
c0009239:	8d 5e 48             	lea    0x48(%esi),%ebx

    current->cont = C;
c000923c:	c7 46 50 fe 28 01 c0 	movl   $0xc00128fe,0x50(%esi)
c0009243:	f0 0f c1 03          	lock xadd %eax,(%ebx)
        }

        ALWAYS_INLINE NORETURN
        inline void make_current()
        {
            if (EXPECT_FALSE(current->del_ref())) {
c0009247:	48                   	dec    %eax
c0009248:	75 29                	jne    c0009273 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvv+0x99>
                delete current;
c000924a:	8b 3d 08 f0 ff cf    	mov    0xcffff008,%edi
c0009250:	85 ff                	test   %edi,%edi
c0009252:	74 1f                	je     c0009273 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvv+0x99>
c0009254:	89 f8                	mov    %edi,%eax
c0009256:	e8 b3 a2 ff ff       	call   c000350e <_ZN2EcD1Ev>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c000925b:	8b 87 b8 00 00 00    	mov    0xb8(%edi),%eax
c0009261:	89 fa                	mov    %edi,%edx
c0009263:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c0009269:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c000926e:	e8 ed 70 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
        {
            if (EXPECT_FALSE(current->del_ref())) {
                delete current;
            }

            current = this;
c0009273:	89 35 08 f0 ff cf    	mov    %esi,0xcffff008
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0009279:	8b 46 48             	mov    0x48(%esi),%eax
c000927c:	85 c0                	test   %eax,%eax
c000927e:	74 09                	je     c0009289 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvv+0xaf>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0009280:	8d 50 01             	lea    0x1(%eax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c0009283:	f0 0f b1 13          	lock cmpxchg %edx,(%ebx)
c0009287:	75 f0                	jne    c0009279 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvv+0x9f>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
c0009289:	8b 9e b8 00 00 00    	mov    0xb8(%esi),%ebx

            current->add_ref();

            Tss::run.sp0 = reinterpret_cast<mword>(exc_regs() + 1);
c000928f:	8d 86 a0 00 00 00    	lea    0xa0(%esi),%eax
c0009295:	a3 c4 fa ff cf       	mov    %eax,0xcffffac4
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
c000929a:	8b 0d 04 f0 ff cf    	mov    0xcffff004,%ecx
c00092a0:	8b 83 70 01 00 00    	mov    0x170(%ebx),%eax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
c00092a6:	8b 93 68 01 00 00    	mov    0x168(%ebx),%edx

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
c00092ac:	0f a3 c8             	bt     %ecx,%eax
c00092af:	73 10                	jae    c00092c1 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvv+0xe7>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
c00092b1:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
c00092b6:	d3 c0                	rol    %cl,%eax
c00092b8:	f0 21 83 70 01 00 00 	lock and %eax,0x170(%ebx)
c00092bf:	eb 0c                	jmp    c00092cd <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvv+0xf3>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
c00092c1:	39 1d 0c f0 ff cf    	cmp    %ebx,0xcffff00c
c00092c7:	0f 84 a2 00 00 00    	je     c000936f <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvv+0x195>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c00092cd:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c00092d2:	83 c9 ff             	or     $0xffffffff,%ecx
c00092d5:	f0 0f c1 48 48       	lock xadd %ecx,0x48(%eax)
                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
c00092da:	49                   	dec    %ecx
c00092db:	75 25                	jne    c0009302 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvv+0x128>
                assert (current != this);
c00092dd:	8b 3d 0c f0 ff cf    	mov    0xcffff00c,%edi
c00092e3:	39 df                	cmp    %ebx,%edi
c00092e5:	75 1d                	jne    c0009304 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvv+0x12a>
c00092e7:	68 a4 85 01 c0       	push   $0xc00185a4
c00092ec:	6a 5e                	push   $0x5e
c00092ee:	68 18 73 01 c0       	push   $0xc0017318
c00092f3:	68 87 73 01 c0       	push   $0xc0017387
c00092f8:	68 69 60 01 c0       	push   $0xc0016069
c00092fd:	e8 44 86 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
c0009302:	31 ff                	xor    %edi,%edi
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
c0009304:	89 1d 0c f0 ff cf    	mov    %ebx,0xcffff00c
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c000930a:	8b 43 48             	mov    0x48(%ebx),%eax
c000930d:	85 c0                	test   %eax,%eax
c000930f:	74 0a                	je     c000931b <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvv+0x141>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0009311:	8d 48 01             	lea    0x1(%eax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c0009314:	f0 0f b1 4b 48       	lock cmpxchg %ecx,0x48(%ebx)
c0009319:	75 ef                	jne    c000930a <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvv+0x130>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
c000931b:	31 ed                	xor    %ebp,%ebp
c000931d:	a1 04 f0 ff cf       	mov    0xcffff004,%eax
c0009322:	f6 05 0a f7 ff cf 02 	testb  $0x2,0xcffff70a
c0009329:	0f 44 d5             	cmove  %ebp,%edx
c000932c:	0b 54 83 54          	or     0x54(%ebx,%eax,4),%edx
c0009330:	0f 22 da             	mov    %edx,%cr3

            if (del_pd)
c0009333:	85 ff                	test   %edi,%edi
c0009335:	74 38                	je     c000936f <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvv+0x195>
                delete del_pd;
c0009337:	89 f8                	mov    %edi,%eax

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c0009339:	89 eb                	mov    %ebp,%ebx
            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);

            if (del_pd)
                delete del_pd;
c000933b:	e8 a8 36 00 00       	call   c000c9e8 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c0009340:	8b 57 28             	mov    0x28(%edi),%edx
c0009343:	85 d2                	test   %edx,%edx
c0009345:	8d 82 78 fe ff ff    	lea    -0x188(%edx),%eax
c000934b:	0f 45 d8             	cmovne %eax,%ebx

            pd_del->quota.free_up(pd_to->quota);
c000934e:	81 c3 90 01 00 00    	add    $0x190,%ebx
c0009354:	8d 87 90 01 00 00    	lea    0x190(%edi),%eax
c000935a:	89 da                	mov    %ebx,%edx
c000935c:	e8 6b 96 ff ff       	call   c00029cc <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
c0009361:	89 d9                	mov    %ebx,%ecx
c0009363:	89 fa                	mov    %edi,%edx
c0009365:	b8 64 b4 01 c0       	mov    $0xc001b464,%eax
c000936a:	e8 f1 6f 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>

            pd->make_current();

            asm volatile ("mov %0," EXPAND (PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory"); UNREACHED;
c000936f:	8b 46 50             	mov    0x50(%esi),%eax
c0009372:	bc 00 e0 ff cf       	mov    $0xcfffe000,%esp
c0009377:	ff e0                	jmp    *%eax
c0009379:	90                   	nop

c000937a <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvv>:

    Sc::schedule(true);
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
c000937a:	55                   	push   %ebp
{
    assert (current->xcpu_sm);
c000937b:	a1 08 f0 ff cf       	mov    0xcffff008,%eax

    Sc::schedule(true);
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
c0009380:	57                   	push   %edi
c0009381:	56                   	push   %esi
c0009382:	53                   	push   %ebx
{
    assert (current->xcpu_sm);
c0009383:	8b 98 f4 00 00 00    	mov    0xf4(%eax),%ebx
c0009389:	85 db                	test   %ebx,%ebx
c000938b:	75 19                	jne    c00093a6 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvv+0x2c>
c000938d:	68 a0 78 01 c0       	push   $0xc00178a0
c0009392:	68 9b 00 00 00       	push   $0x9b
c0009397:	68 a3 72 01 c0       	push   $0xc00172a3
c000939c:	68 66 6c 01 c0       	push   $0xc0016c66
c00093a1:	e9 f2 00 00 00       	jmp    c0009498 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvv+0x11e>

    Sm::destroy(current->xcpu_sm, Pd::current->quota);
c00093a6:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c00093ab:	8d b0 90 01 00 00    	lea    0x190(%eax),%esi
c00093b1:	89 d8                	mov    %ebx,%eax
c00093b3:	e8 56 f2 ff ff       	call   c000860e <_ZN2SmD1Ev>
c00093b8:	89 f1                	mov    %esi,%ecx
c00093ba:	89 da                	mov    %ebx,%edx
c00093bc:	b8 b4 b4 01 c0       	mov    $0xc001b4b4,%eax
c00093c1:	e8 9a 6f 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
    current->xcpu_sm = nullptr;
c00093c6:	8b 35 08 f0 ff cf    	mov    0xcffff008,%esi
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c00093cc:	83 c8 ff             	or     $0xffffffff,%eax
c00093cf:	c7 86 f4 00 00 00 00 	movl   $0x0,0xf4(%esi)
c00093d6:	00 00 00 
        }

        ALWAYS_INLINE
        inline bool del_ref()
        {
            return Atomic::sub (ref, 1U) == 0;
c00093d9:	8d 5e 48             	lea    0x48(%esi),%ebx

    current->cont = C;
c00093dc:	c7 46 50 c0 30 01 c0 	movl   $0xc00130c0,0x50(%esi)
c00093e3:	f0 0f c1 03          	lock xadd %eax,(%ebx)
        }

        ALWAYS_INLINE NORETURN
        inline void make_current()
        {
            if (EXPECT_FALSE(current->del_ref())) {
c00093e7:	48                   	dec    %eax
c00093e8:	75 29                	jne    c0009413 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvv+0x99>
                delete current;
c00093ea:	8b 3d 08 f0 ff cf    	mov    0xcffff008,%edi
c00093f0:	85 ff                	test   %edi,%edi
c00093f2:	74 1f                	je     c0009413 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvv+0x99>
c00093f4:	89 f8                	mov    %edi,%eax
c00093f6:	e8 13 a1 ff ff       	call   c000350e <_ZN2EcD1Ev>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c00093fb:	8b 87 b8 00 00 00    	mov    0xb8(%edi),%eax
c0009401:	89 fa                	mov    %edi,%edx
c0009403:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c0009409:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c000940e:	e8 4d 6f 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
        {
            if (EXPECT_FALSE(current->del_ref())) {
                delete current;
            }

            current = this;
c0009413:	89 35 08 f0 ff cf    	mov    %esi,0xcffff008
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0009419:	8b 46 48             	mov    0x48(%esi),%eax
c000941c:	85 c0                	test   %eax,%eax
c000941e:	74 09                	je     c0009429 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvv+0xaf>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0009420:	8d 50 01             	lea    0x1(%eax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c0009423:	f0 0f b1 13          	lock cmpxchg %edx,(%ebx)
c0009427:	75 f0                	jne    c0009419 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvv+0x9f>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
c0009429:	8b 9e b8 00 00 00    	mov    0xb8(%esi),%ebx

            current->add_ref();

            Tss::run.sp0 = reinterpret_cast<mword>(exc_regs() + 1);
c000942f:	8d 86 a0 00 00 00    	lea    0xa0(%esi),%eax
c0009435:	a3 c4 fa ff cf       	mov    %eax,0xcffffac4
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
c000943a:	8b 0d 04 f0 ff cf    	mov    0xcffff004,%ecx
c0009440:	8b 83 70 01 00 00    	mov    0x170(%ebx),%eax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
c0009446:	8b 93 68 01 00 00    	mov    0x168(%ebx),%edx

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
c000944c:	0f a3 c8             	bt     %ecx,%eax
c000944f:	73 10                	jae    c0009461 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvv+0xe7>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
c0009451:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
c0009456:	d3 c0                	rol    %cl,%eax
c0009458:	f0 21 83 70 01 00 00 	lock and %eax,0x170(%ebx)
c000945f:	eb 0c                	jmp    c000946d <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvv+0xf3>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
c0009461:	39 1d 0c f0 ff cf    	cmp    %ebx,0xcffff00c
c0009467:	0f 84 a2 00 00 00    	je     c000950f <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvv+0x195>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c000946d:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c0009472:	83 c9 ff             	or     $0xffffffff,%ecx
c0009475:	f0 0f c1 48 48       	lock xadd %ecx,0x48(%eax)
                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
c000947a:	49                   	dec    %ecx
c000947b:	75 25                	jne    c00094a2 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvv+0x128>
                assert (current != this);
c000947d:	8b 3d 0c f0 ff cf    	mov    0xcffff00c,%edi
c0009483:	39 df                	cmp    %ebx,%edi
c0009485:	75 1d                	jne    c00094a4 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvv+0x12a>
c0009487:	68 a4 85 01 c0       	push   $0xc00185a4
c000948c:	6a 5e                	push   $0x5e
c000948e:	68 18 73 01 c0       	push   $0xc0017318
c0009493:	68 87 73 01 c0       	push   $0xc0017387
c0009498:	68 69 60 01 c0       	push   $0xc0016069
c000949d:	e8 a4 84 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
c00094a2:	31 ff                	xor    %edi,%edi
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
c00094a4:	89 1d 0c f0 ff cf    	mov    %ebx,0xcffff00c
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c00094aa:	8b 43 48             	mov    0x48(%ebx),%eax
c00094ad:	85 c0                	test   %eax,%eax
c00094af:	74 0a                	je     c00094bb <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvv+0x141>
                if (Atomic::cmp_swap (ref, r, r + 1))
c00094b1:	8d 48 01             	lea    0x1(%eax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c00094b4:	f0 0f b1 4b 48       	lock cmpxchg %ecx,0x48(%ebx)
c00094b9:	75 ef                	jne    c00094aa <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvv+0x130>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
c00094bb:	31 ed                	xor    %ebp,%ebp
c00094bd:	a1 04 f0 ff cf       	mov    0xcffff004,%eax
c00094c2:	f6 05 0a f7 ff cf 02 	testb  $0x2,0xcffff70a
c00094c9:	0f 44 d5             	cmove  %ebp,%edx
c00094cc:	0b 54 83 54          	or     0x54(%ebx,%eax,4),%edx
c00094d0:	0f 22 da             	mov    %edx,%cr3

            if (del_pd)
c00094d3:	85 ff                	test   %edi,%edi
c00094d5:	74 38                	je     c000950f <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvv+0x195>
                delete del_pd;
c00094d7:	89 f8                	mov    %edi,%eax

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c00094d9:	89 eb                	mov    %ebp,%ebx
            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);

            if (del_pd)
                delete del_pd;
c00094db:	e8 08 35 00 00       	call   c000c9e8 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c00094e0:	8b 57 28             	mov    0x28(%edi),%edx
c00094e3:	85 d2                	test   %edx,%edx
c00094e5:	8d 82 78 fe ff ff    	lea    -0x188(%edx),%eax
c00094eb:	0f 45 d8             	cmovne %eax,%ebx

            pd_del->quota.free_up(pd_to->quota);
c00094ee:	81 c3 90 01 00 00    	add    $0x190,%ebx
c00094f4:	8d 87 90 01 00 00    	lea    0x190(%edi),%eax
c00094fa:	89 da                	mov    %ebx,%edx
c00094fc:	e8 cb 94 ff ff       	call   c00029cc <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
c0009501:	89 d9                	mov    %ebx,%ecx
c0009503:	89 fa                	mov    %edi,%edx
c0009505:	b8 64 b4 01 c0       	mov    $0xc001b464,%eax
c000950a:	e8 51 6e 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>

            pd->make_current();

            asm volatile ("mov %0," EXPAND (PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory"); UNREACHED;
c000950f:	8b 46 50             	mov    0x50(%esi),%eax
c0009512:	bc 00 e0 ff cf       	mov    $0xcfffe000,%esp
c0009517:	ff e0                	jmp    *%eax
c0009519:	90                   	nop

c000951a <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvv>:

    Sc::schedule(true);
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
c000951a:	55                   	push   %ebp
{
    assert (current->xcpu_sm);
c000951b:	a1 08 f0 ff cf       	mov    0xcffff008,%eax

    Sc::schedule(true);
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
c0009520:	57                   	push   %edi
c0009521:	56                   	push   %esi
c0009522:	53                   	push   %ebx
{
    assert (current->xcpu_sm);
c0009523:	8b 98 f4 00 00 00    	mov    0xf4(%eax),%ebx
c0009529:	85 db                	test   %ebx,%ebx
c000952b:	75 19                	jne    c0009546 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvv+0x2c>
c000952d:	68 e0 76 01 c0       	push   $0xc00176e0
c0009532:	68 9b 00 00 00       	push   $0x9b
c0009537:	68 a3 72 01 c0       	push   $0xc00172a3
c000953c:	68 66 6c 01 c0       	push   $0xc0016c66
c0009541:	e9 f2 00 00 00       	jmp    c0009638 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvv+0x11e>

    Sm::destroy(current->xcpu_sm, Pd::current->quota);
c0009546:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c000954b:	8d b0 90 01 00 00    	lea    0x190(%eax),%esi
c0009551:	89 d8                	mov    %ebx,%eax
c0009553:	e8 b6 f0 ff ff       	call   c000860e <_ZN2SmD1Ev>
c0009558:	89 f1                	mov    %esi,%ecx
c000955a:	89 da                	mov    %ebx,%edx
c000955c:	b8 b4 b4 01 c0       	mov    $0xc001b4b4,%eax
c0009561:	e8 fa 6d 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
    current->xcpu_sm = nullptr;
c0009566:	8b 35 08 f0 ff cf    	mov    0xcffff008,%esi
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c000956c:	83 c8 ff             	or     $0xffffffff,%eax
c000956f:	c7 86 f4 00 00 00 00 	movl   $0x0,0xf4(%esi)
c0009576:	00 00 00 
        }

        ALWAYS_INLINE
        inline bool del_ref()
        {
            return Atomic::sub (ref, 1U) == 0;
c0009579:	8d 5e 48             	lea    0x48(%esi),%ebx

    current->cont = C;
c000957c:	c7 46 50 8a 3f 01 c0 	movl   $0xc0013f8a,0x50(%esi)
c0009583:	f0 0f c1 03          	lock xadd %eax,(%ebx)
        }

        ALWAYS_INLINE NORETURN
        inline void make_current()
        {
            if (EXPECT_FALSE(current->del_ref())) {
c0009587:	48                   	dec    %eax
c0009588:	75 29                	jne    c00095b3 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvv+0x99>
                delete current;
c000958a:	8b 3d 08 f0 ff cf    	mov    0xcffff008,%edi
c0009590:	85 ff                	test   %edi,%edi
c0009592:	74 1f                	je     c00095b3 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvv+0x99>
c0009594:	89 f8                	mov    %edi,%eax
c0009596:	e8 73 9f ff ff       	call   c000350e <_ZN2EcD1Ev>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c000959b:	8b 87 b8 00 00 00    	mov    0xb8(%edi),%eax
c00095a1:	89 fa                	mov    %edi,%edx
c00095a3:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c00095a9:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c00095ae:	e8 ad 6d 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
        {
            if (EXPECT_FALSE(current->del_ref())) {
                delete current;
            }

            current = this;
c00095b3:	89 35 08 f0 ff cf    	mov    %esi,0xcffff008
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c00095b9:	8b 46 48             	mov    0x48(%esi),%eax
c00095bc:	85 c0                	test   %eax,%eax
c00095be:	74 09                	je     c00095c9 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvv+0xaf>
                if (Atomic::cmp_swap (ref, r, r + 1))
c00095c0:	8d 50 01             	lea    0x1(%eax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c00095c3:	f0 0f b1 13          	lock cmpxchg %edx,(%ebx)
c00095c7:	75 f0                	jne    c00095b9 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvv+0x9f>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
c00095c9:	8b 9e b8 00 00 00    	mov    0xb8(%esi),%ebx

            current->add_ref();

            Tss::run.sp0 = reinterpret_cast<mword>(exc_regs() + 1);
c00095cf:	8d 86 a0 00 00 00    	lea    0xa0(%esi),%eax
c00095d5:	a3 c4 fa ff cf       	mov    %eax,0xcffffac4
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
c00095da:	8b 0d 04 f0 ff cf    	mov    0xcffff004,%ecx
c00095e0:	8b 83 70 01 00 00    	mov    0x170(%ebx),%eax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
c00095e6:	8b 93 68 01 00 00    	mov    0x168(%ebx),%edx

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
c00095ec:	0f a3 c8             	bt     %ecx,%eax
c00095ef:	73 10                	jae    c0009601 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvv+0xe7>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
c00095f1:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
c00095f6:	d3 c0                	rol    %cl,%eax
c00095f8:	f0 21 83 70 01 00 00 	lock and %eax,0x170(%ebx)
c00095ff:	eb 0c                	jmp    c000960d <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvv+0xf3>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
c0009601:	39 1d 0c f0 ff cf    	cmp    %ebx,0xcffff00c
c0009607:	0f 84 a2 00 00 00    	je     c00096af <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvv+0x195>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c000960d:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c0009612:	83 c9 ff             	or     $0xffffffff,%ecx
c0009615:	f0 0f c1 48 48       	lock xadd %ecx,0x48(%eax)
                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
c000961a:	49                   	dec    %ecx
c000961b:	75 25                	jne    c0009642 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvv+0x128>
                assert (current != this);
c000961d:	8b 3d 0c f0 ff cf    	mov    0xcffff00c,%edi
c0009623:	39 df                	cmp    %ebx,%edi
c0009625:	75 1d                	jne    c0009644 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvv+0x12a>
c0009627:	68 a4 85 01 c0       	push   $0xc00185a4
c000962c:	6a 5e                	push   $0x5e
c000962e:	68 18 73 01 c0       	push   $0xc0017318
c0009633:	68 87 73 01 c0       	push   $0xc0017387
c0009638:	68 69 60 01 c0       	push   $0xc0016069
c000963d:	e8 04 83 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
c0009642:	31 ff                	xor    %edi,%edi
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
c0009644:	89 1d 0c f0 ff cf    	mov    %ebx,0xcffff00c
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c000964a:	8b 43 48             	mov    0x48(%ebx),%eax
c000964d:	85 c0                	test   %eax,%eax
c000964f:	74 0a                	je     c000965b <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvv+0x141>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0009651:	8d 48 01             	lea    0x1(%eax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c0009654:	f0 0f b1 4b 48       	lock cmpxchg %ecx,0x48(%ebx)
c0009659:	75 ef                	jne    c000964a <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvv+0x130>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
c000965b:	31 ed                	xor    %ebp,%ebp
c000965d:	a1 04 f0 ff cf       	mov    0xcffff004,%eax
c0009662:	f6 05 0a f7 ff cf 02 	testb  $0x2,0xcffff70a
c0009669:	0f 44 d5             	cmove  %ebp,%edx
c000966c:	0b 54 83 54          	or     0x54(%ebx,%eax,4),%edx
c0009670:	0f 22 da             	mov    %edx,%cr3

            if (del_pd)
c0009673:	85 ff                	test   %edi,%edi
c0009675:	74 38                	je     c00096af <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvv+0x195>
                delete del_pd;
c0009677:	89 f8                	mov    %edi,%eax

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c0009679:	89 eb                	mov    %ebp,%ebx
            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);

            if (del_pd)
                delete del_pd;
c000967b:	e8 68 33 00 00       	call   c000c9e8 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c0009680:	8b 57 28             	mov    0x28(%edi),%edx
c0009683:	85 d2                	test   %edx,%edx
c0009685:	8d 82 78 fe ff ff    	lea    -0x188(%edx),%eax
c000968b:	0f 45 d8             	cmovne %eax,%ebx

            pd_del->quota.free_up(pd_to->quota);
c000968e:	81 c3 90 01 00 00    	add    $0x190,%ebx
c0009694:	8d 87 90 01 00 00    	lea    0x190(%edi),%eax
c000969a:	89 da                	mov    %ebx,%edx
c000969c:	e8 2b 93 ff ff       	call   c00029cc <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
c00096a1:	89 d9                	mov    %ebx,%ecx
c00096a3:	89 fa                	mov    %edi,%edx
c00096a5:	b8 64 b4 01 c0       	mov    $0xc001b464,%eax
c00096aa:	e8 b1 6c 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>

            pd->make_current();

            asm volatile ("mov %0," EXPAND (PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory"); UNREACHED;
c00096af:	8b 46 50             	mov    0x50(%esi),%eax
c00096b2:	bc 00 e0 ff cf       	mov    $0xcfffe000,%esp
c00096b7:	ff e0                	jmp    *%eax
c00096b9:	90                   	nop

c00096ba <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvv>:

    Sc::schedule(true);
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
c00096ba:	55                   	push   %ebp
{
    assert (current->xcpu_sm);
c00096bb:	a1 08 f0 ff cf       	mov    0xcffff008,%eax

    Sc::schedule(true);
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
c00096c0:	57                   	push   %edi
c00096c1:	56                   	push   %esi
c00096c2:	53                   	push   %ebx
{
    assert (current->xcpu_sm);
c00096c3:	8b 98 f4 00 00 00    	mov    0xf4(%eax),%ebx
c00096c9:	85 db                	test   %ebx,%ebx
c00096cb:	75 19                	jne    c00096e6 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvv+0x2c>
c00096cd:	68 20 75 01 c0       	push   $0xc0017520
c00096d2:	68 9b 00 00 00       	push   $0x9b
c00096d7:	68 a3 72 01 c0       	push   $0xc00172a3
c00096dc:	68 66 6c 01 c0       	push   $0xc0016c66
c00096e1:	e9 f2 00 00 00       	jmp    c00097d8 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvv+0x11e>

    Sm::destroy(current->xcpu_sm, Pd::current->quota);
c00096e6:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c00096eb:	8d b0 90 01 00 00    	lea    0x190(%eax),%esi
c00096f1:	89 d8                	mov    %ebx,%eax
c00096f3:	e8 16 ef ff ff       	call   c000860e <_ZN2SmD1Ev>
c00096f8:	89 f1                	mov    %esi,%ecx
c00096fa:	89 da                	mov    %ebx,%edx
c00096fc:	b8 b4 b4 01 c0       	mov    $0xc001b4b4,%eax
c0009701:	e8 5a 6c 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
    current->xcpu_sm = nullptr;
c0009706:	8b 35 08 f0 ff cf    	mov    0xcffff008,%esi
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c000970c:	83 c8 ff             	or     $0xffffffff,%eax
c000970f:	c7 86 f4 00 00 00 00 	movl   $0x0,0xf4(%esi)
c0009716:	00 00 00 
        }

        ALWAYS_INLINE
        inline bool del_ref()
        {
            return Atomic::sub (ref, 1U) == 0;
c0009719:	8d 5e 48             	lea    0x48(%esi),%ebx

    current->cont = C;
c000971c:	c7 46 50 20 3e 01 c0 	movl   $0xc0013e20,0x50(%esi)
c0009723:	f0 0f c1 03          	lock xadd %eax,(%ebx)
        }

        ALWAYS_INLINE NORETURN
        inline void make_current()
        {
            if (EXPECT_FALSE(current->del_ref())) {
c0009727:	48                   	dec    %eax
c0009728:	75 29                	jne    c0009753 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvv+0x99>
                delete current;
c000972a:	8b 3d 08 f0 ff cf    	mov    0xcffff008,%edi
c0009730:	85 ff                	test   %edi,%edi
c0009732:	74 1f                	je     c0009753 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvv+0x99>
c0009734:	89 f8                	mov    %edi,%eax
c0009736:	e8 d3 9d ff ff       	call   c000350e <_ZN2EcD1Ev>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c000973b:	8b 87 b8 00 00 00    	mov    0xb8(%edi),%eax
c0009741:	89 fa                	mov    %edi,%edx
c0009743:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c0009749:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c000974e:	e8 0d 6c 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
        {
            if (EXPECT_FALSE(current->del_ref())) {
                delete current;
            }

            current = this;
c0009753:	89 35 08 f0 ff cf    	mov    %esi,0xcffff008
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0009759:	8b 46 48             	mov    0x48(%esi),%eax
c000975c:	85 c0                	test   %eax,%eax
c000975e:	74 09                	je     c0009769 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvv+0xaf>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0009760:	8d 50 01             	lea    0x1(%eax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c0009763:	f0 0f b1 13          	lock cmpxchg %edx,(%ebx)
c0009767:	75 f0                	jne    c0009759 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvv+0x9f>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
c0009769:	8b 9e b8 00 00 00    	mov    0xb8(%esi),%ebx

            current->add_ref();

            Tss::run.sp0 = reinterpret_cast<mword>(exc_regs() + 1);
c000976f:	8d 86 a0 00 00 00    	lea    0xa0(%esi),%eax
c0009775:	a3 c4 fa ff cf       	mov    %eax,0xcffffac4
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
c000977a:	8b 0d 04 f0 ff cf    	mov    0xcffff004,%ecx
c0009780:	8b 83 70 01 00 00    	mov    0x170(%ebx),%eax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
c0009786:	8b 93 68 01 00 00    	mov    0x168(%ebx),%edx

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
c000978c:	0f a3 c8             	bt     %ecx,%eax
c000978f:	73 10                	jae    c00097a1 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvv+0xe7>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
c0009791:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
c0009796:	d3 c0                	rol    %cl,%eax
c0009798:	f0 21 83 70 01 00 00 	lock and %eax,0x170(%ebx)
c000979f:	eb 0c                	jmp    c00097ad <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvv+0xf3>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
c00097a1:	39 1d 0c f0 ff cf    	cmp    %ebx,0xcffff00c
c00097a7:	0f 84 a2 00 00 00    	je     c000984f <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvv+0x195>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c00097ad:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c00097b2:	83 c9 ff             	or     $0xffffffff,%ecx
c00097b5:	f0 0f c1 48 48       	lock xadd %ecx,0x48(%eax)
                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
c00097ba:	49                   	dec    %ecx
c00097bb:	75 25                	jne    c00097e2 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvv+0x128>
                assert (current != this);
c00097bd:	8b 3d 0c f0 ff cf    	mov    0xcffff00c,%edi
c00097c3:	39 df                	cmp    %ebx,%edi
c00097c5:	75 1d                	jne    c00097e4 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvv+0x12a>
c00097c7:	68 a4 85 01 c0       	push   $0xc00185a4
c00097cc:	6a 5e                	push   $0x5e
c00097ce:	68 18 73 01 c0       	push   $0xc0017318
c00097d3:	68 87 73 01 c0       	push   $0xc0017387
c00097d8:	68 69 60 01 c0       	push   $0xc0016069
c00097dd:	e8 64 81 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
c00097e2:	31 ff                	xor    %edi,%edi
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
c00097e4:	89 1d 0c f0 ff cf    	mov    %ebx,0xcffff00c
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c00097ea:	8b 43 48             	mov    0x48(%ebx),%eax
c00097ed:	85 c0                	test   %eax,%eax
c00097ef:	74 0a                	je     c00097fb <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvv+0x141>
                if (Atomic::cmp_swap (ref, r, r + 1))
c00097f1:	8d 48 01             	lea    0x1(%eax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c00097f4:	f0 0f b1 4b 48       	lock cmpxchg %ecx,0x48(%ebx)
c00097f9:	75 ef                	jne    c00097ea <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvv+0x130>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
c00097fb:	31 ed                	xor    %ebp,%ebp
c00097fd:	a1 04 f0 ff cf       	mov    0xcffff004,%eax
c0009802:	f6 05 0a f7 ff cf 02 	testb  $0x2,0xcffff70a
c0009809:	0f 44 d5             	cmove  %ebp,%edx
c000980c:	0b 54 83 54          	or     0x54(%ebx,%eax,4),%edx
c0009810:	0f 22 da             	mov    %edx,%cr3

            if (del_pd)
c0009813:	85 ff                	test   %edi,%edi
c0009815:	74 38                	je     c000984f <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvv+0x195>
                delete del_pd;
c0009817:	89 f8                	mov    %edi,%eax

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c0009819:	89 eb                	mov    %ebp,%ebx
            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);

            if (del_pd)
                delete del_pd;
c000981b:	e8 c8 31 00 00       	call   c000c9e8 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c0009820:	8b 57 28             	mov    0x28(%edi),%edx
c0009823:	85 d2                	test   %edx,%edx
c0009825:	8d 82 78 fe ff ff    	lea    -0x188(%edx),%eax
c000982b:	0f 45 d8             	cmovne %eax,%ebx

            pd_del->quota.free_up(pd_to->quota);
c000982e:	81 c3 90 01 00 00    	add    $0x190,%ebx
c0009834:	8d 87 90 01 00 00    	lea    0x190(%edi),%eax
c000983a:	89 da                	mov    %ebx,%edx
c000983c:	e8 8b 91 ff ff       	call   c00029cc <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
c0009841:	89 d9                	mov    %ebx,%ecx
c0009843:	89 fa                	mov    %edi,%edx
c0009845:	b8 64 b4 01 c0       	mov    $0xc001b464,%eax
c000984a:	e8 11 6b 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>

            pd->make_current();

            asm volatile ("mov %0," EXPAND (PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory"); UNREACHED;
c000984f:	8b 46 50             	mov    0x50(%esi),%eax
c0009852:	bc 00 e0 ff cf       	mov    $0xcfffe000,%esp
c0009857:	ff e0                	jmp    *%eax
c0009859:	90                   	nop

c000985a <_ZN2Ec8oom_callEP2PtmmPFvvES3_>:

    chg->oom_call(dst_pt, src_pd_id, oom_state, c, c);
}

void Ec::oom_call(Pt * pt, mword src, mword state, void (*CC)(), void (*HELP)())
{
c000985a:	55                   	push   %ebp
c000985b:	57                   	push   %edi
c000985c:	89 d7                	mov    %edx,%edi
c000985e:	56                   	push   %esi
c000985f:	89 c6                	mov    %eax,%esi
c0009861:	53                   	push   %ebx
    Ec *ec = pt->ec;

    assert (!this->partner);
c0009862:	83 b8 bc 00 00 00 00 	cmpl   $0x0,0xbc(%eax)
{
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
c0009869:	8b 5a 4c             	mov    0x4c(%edx),%ebx
c000986c:	74 13                	je     c0009881 <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x27>
c000986e:	68 e0 84 01 c0       	push   $0xc00184e0
c0009873:	6a 5e                	push   $0x5e
c0009875:	68 a3 72 01 c0       	push   $0xc00172a3
c000987a:	68 97 73 01 c0       	push   $0xc0017397
c000987f:	eb 20                	jmp    c00098a1 <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x47>
    assert (this->cpu == ec->xcpu);
c0009881:	0f b7 80 cc 00 00 00 	movzwl 0xcc(%eax),%eax
c0009888:	3b 83 cc 00 00 00    	cmp    0xcc(%ebx),%eax
c000988e:	74 1b                	je     c00098ab <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x51>
c0009890:	68 e0 84 01 c0       	push   $0xc00184e0
c0009895:	6a 5f                	push   $0x5f
c0009897:	68 a3 72 01 c0       	push   $0xc00172a3
c000989c:	68 a6 73 01 c0       	push   $0xc00173a6
c00098a1:	68 69 60 01 c0       	push   $0xc0016069
c00098a6:	e8 9b 80 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

    if (this != ec) {
c00098ab:	39 de                	cmp    %ebx,%esi
c00098ad:	89 cd                	mov    %ecx,%ebp
c00098af:	74 5e                	je     c000990f <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0xb5>
        if (ec->cont)
c00098b1:	83 7b 50 00          	cmpl   $0x0,0x50(%ebx)
c00098b5:	74 0b                	je     c00098c2 <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x68>
            ec->help (HELP);
c00098b7:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c00098bb:	89 d8                	mov    %ebx,%eax
c00098bd:	e8 dc eb ff ff       	call   c000849e <_ZN2Ec4helpEPFvvE>
        inline Exc_regs *exc_regs() { return &regs; }

        ALWAYS_INLINE
        inline void set_partner (Ec *p)
        {
            partner = p;
c00098c2:	89 9e bc 00 00 00    	mov    %ebx,0xbc(%esi)
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c00098c8:	8b 43 48             	mov    0x48(%ebx),%eax
c00098cb:	85 c0                	test   %eax,%eax
c00098cd:	74 0a                	je     c00098d9 <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x7f>
                if (Atomic::cmp_swap (ref, r, r + 1))
c00098cf:	8d 50 01             	lea    0x1(%eax),%edx
c00098d2:	f0 0f b1 53 48       	lock cmpxchg %edx,0x48(%ebx)
c00098d7:	75 ef                	jne    c00098c8 <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x6e>
            partner->add_ref();
            partner->rcap = this;
c00098d9:	8b 86 bc 00 00 00    	mov    0xbc(%esi),%eax
c00098df:	89 b0 b0 00 00 00    	mov    %esi,0xb0(%eax)
            partner->rcap->add_ref();
c00098e5:	8b 86 bc 00 00 00    	mov    0xbc(%esi),%eax
c00098eb:	8b 90 b0 00 00 00    	mov    0xb0(%eax),%edx
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c00098f1:	8b 42 48             	mov    0x48(%edx),%eax
c00098f4:	85 c0                	test   %eax,%eax
c00098f6:	74 0a                	je     c0009902 <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0xa8>
                if (Atomic::cmp_swap (ref, r, r + 1))
c00098f8:	8d 48 01             	lea    0x1(%eax),%ecx
c00098fb:	f0 0f b1 4a 48       	lock cmpxchg %ecx,0x48(%edx)
c0009900:	75 ef                	jne    c00098f1 <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x97>

        this->set_partner (ec);
        this->cont = CC;
c0009902:	8b 44 24 18          	mov    0x18(%esp),%eax
            Sc::ctr_link++;
c0009906:	ff 05 24 fa ff cf    	incl   0xcffffa24
c000990c:	89 46 50             	mov    %eax,0x50(%esi)
    }

    ec->cont = ret_user_sysexit;
c000990f:	c7 43 50 00 00 00 c0 	movl   $0xc0000000,0x50(%ebx)
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c0009916:	83 ca ff             	or     $0xffffffff,%edx
    ec->regs.set_pt (pt->id, src, state);
c0009919:	8b 47 58             	mov    0x58(%edi),%eax

        ALWAYS_INLINE
        inline void set_pt (mword pt) { ARG_1 = pt; }

        ALWAYS_INLINE
        inline void set_pt (mword pt, mword pt2, mword s) { ARG_1 = pt; ARG_2 = pt2; ARG_3 = s; }
c000991c:	89 6b 54             	mov    %ebp,0x54(%ebx)
c000991f:	89 43 70             	mov    %eax,0x70(%ebx)
c0009922:	8b 44 24 14          	mov    0x14(%esp),%eax
c0009926:	89 43 58             	mov    %eax,0x58(%ebx)
    ec->regs.set_ip (pt->ip);
c0009929:	8b 47 54             	mov    0x54(%edi),%eax

        ALWAYS_INLINE
        inline void set_ip (mword ip) { ARG_IP = ip; }
c000992c:	89 43 68             	mov    %eax,0x68(%ebx)
c000992f:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0009934:	f0 0f c1 50 48       	lock xadd %edx,0x48(%eax)
        }

        ALWAYS_INLINE NORETURN
        inline void make_current()
        {
            if (EXPECT_FALSE(current->del_ref())) {
c0009939:	4a                   	dec    %edx
c000993a:	75 29                	jne    c0009965 <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x10b>
                delete current;
c000993c:	8b 35 08 f0 ff cf    	mov    0xcffff008,%esi
c0009942:	85 f6                	test   %esi,%esi
c0009944:	74 1f                	je     c0009965 <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x10b>
c0009946:	89 f0                	mov    %esi,%eax
c0009948:	e8 c1 9b ff ff       	call   c000350e <_ZN2EcD1Ev>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c000994d:	8b 86 b8 00 00 00    	mov    0xb8(%esi),%eax
c0009953:	89 f2                	mov    %esi,%edx
c0009955:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c000995b:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c0009960:	e8 fb 69 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
        {
            if (EXPECT_FALSE(current->del_ref())) {
                delete current;
            }

            current = this;
c0009965:	89 1d 08 f0 ff cf    	mov    %ebx,0xcffff008
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c000996b:	8b 43 48             	mov    0x48(%ebx),%eax
c000996e:	85 c0                	test   %eax,%eax
c0009970:	74 0a                	je     c000997c <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x122>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0009972:	8d 50 01             	lea    0x1(%eax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c0009975:	f0 0f b1 53 48       	lock cmpxchg %edx,0x48(%ebx)
c000997a:	75 ef                	jne    c000996b <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x111>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
c000997c:	8b b3 b8 00 00 00    	mov    0xb8(%ebx),%esi

            current->add_ref();

            Tss::run.sp0 = reinterpret_cast<mword>(exc_regs() + 1);
c0009982:	8d 83 a0 00 00 00    	lea    0xa0(%ebx),%eax
c0009988:	a3 c4 fa ff cf       	mov    %eax,0xcffffac4
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
c000998d:	8b 0d 04 f0 ff cf    	mov    0xcffff004,%ecx
c0009993:	8b 86 70 01 00 00    	mov    0x170(%esi),%eax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
c0009999:	8b 96 68 01 00 00    	mov    0x168(%esi),%edx

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
c000999f:	0f a3 c8             	bt     %ecx,%eax
c00099a2:	73 10                	jae    c00099b4 <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x15a>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
c00099a4:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
c00099a9:	d3 c0                	rol    %cl,%eax
c00099ab:	f0 21 86 70 01 00 00 	lock and %eax,0x170(%esi)
c00099b2:	eb 0c                	jmp    c00099c0 <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x166>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
c00099b4:	39 35 0c f0 ff cf    	cmp    %esi,0xcffff00c
c00099ba:	0f 84 9d 00 00 00    	je     c0009a5d <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x203>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c00099c0:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c00099c5:	83 c9 ff             	or     $0xffffffff,%ecx
c00099c8:	f0 0f c1 48 48       	lock xadd %ecx,0x48(%eax)
                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
c00099cd:	49                   	dec    %ecx
c00099ce:	75 20                	jne    c00099f0 <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x196>
                assert (current != this);
c00099d0:	8b 3d 0c f0 ff cf    	mov    0xcffff00c,%edi
c00099d6:	39 f7                	cmp    %esi,%edi
c00099d8:	75 18                	jne    c00099f2 <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x198>
c00099da:	68 a4 85 01 c0       	push   $0xc00185a4
c00099df:	6a 5e                	push   $0x5e
c00099e1:	68 18 73 01 c0       	push   $0xc0017318
c00099e6:	68 87 73 01 c0       	push   $0xc0017387
c00099eb:	e9 b1 fe ff ff       	jmp    c00098a1 <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x47>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
c00099f0:	31 ff                	xor    %edi,%edi
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
c00099f2:	89 35 0c f0 ff cf    	mov    %esi,0xcffff00c
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c00099f8:	8b 46 48             	mov    0x48(%esi),%eax
c00099fb:	85 c0                	test   %eax,%eax
c00099fd:	74 0a                	je     c0009a09 <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x1af>
                if (Atomic::cmp_swap (ref, r, r + 1))
c00099ff:	8d 48 01             	lea    0x1(%eax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c0009a02:	f0 0f b1 4e 48       	lock cmpxchg %ecx,0x48(%esi)
c0009a07:	75 ef                	jne    c00099f8 <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x19e>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
c0009a09:	31 ed                	xor    %ebp,%ebp
c0009a0b:	a1 04 f0 ff cf       	mov    0xcffff004,%eax
c0009a10:	f6 05 0a f7 ff cf 02 	testb  $0x2,0xcffff70a
c0009a17:	0f 44 d5             	cmove  %ebp,%edx
c0009a1a:	0b 54 86 54          	or     0x54(%esi,%eax,4),%edx
c0009a1e:	0f 22 da             	mov    %edx,%cr3

            if (del_pd)
c0009a21:	85 ff                	test   %edi,%edi
c0009a23:	74 38                	je     c0009a5d <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x203>
                delete del_pd;
c0009a25:	89 f8                	mov    %edi,%eax

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c0009a27:	89 ee                	mov    %ebp,%esi
            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);

            if (del_pd)
                delete del_pd;
c0009a29:	e8 ba 2f 00 00       	call   c000c9e8 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c0009a2e:	8b 57 28             	mov    0x28(%edi),%edx
c0009a31:	85 d2                	test   %edx,%edx
c0009a33:	8d 82 78 fe ff ff    	lea    -0x188(%edx),%eax
c0009a39:	0f 45 f0             	cmovne %eax,%esi

            pd_del->quota.free_up(pd_to->quota);
c0009a3c:	81 c6 90 01 00 00    	add    $0x190,%esi
c0009a42:	8d 87 90 01 00 00    	lea    0x190(%edi),%eax
c0009a48:	89 f2                	mov    %esi,%edx
c0009a4a:	e8 7d 8f ff ff       	call   c00029cc <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
c0009a4f:	89 f1                	mov    %esi,%ecx
c0009a51:	89 fa                	mov    %edi,%edx
c0009a53:	b8 64 b4 01 c0       	mov    $0xc001b464,%eax
c0009a58:	e8 03 69 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>

            pd->make_current();

            asm volatile ("mov %0," EXPAND (PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory"); UNREACHED;
c0009a5d:	8b 43 50             	mov    0x50(%ebx),%eax
c0009a60:	bc 00 e0 ff cf       	mov    $0xcfffe000,%esp
c0009a65:	ff e0                	jmp    *%eax
c0009a67:	90                   	nop

c0009a68 <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_9sys_replyEvEEEEvv>:
}

template <void (*C)()>
void Ec::sys_xcpu_call_oom()
{
    assert (current->xcpu_sm);
c0009a68:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0009a6d:	83 b8 f4 00 00 00 00 	cmpl   $0x0,0xf4(%eax)
c0009a74:	75 1e                	jne    c0009a94 <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_9sys_replyEvEEEEvv+0x2c>
c0009a76:	68 a0 86 01 c0       	push   $0xc00186a0
c0009a7b:	68 a7 00 00 00       	push   $0xa7
c0009a80:	68 a3 72 01 c0       	push   $0xc00172a3
c0009a85:	68 66 6c 01 c0       	push   $0xc0016c66
c0009a8a:	68 69 60 01 c0       	push   $0xc0016069
c0009a8f:	e8 b2 7e ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

    Sys_regs *s  = current->sys_regs();
    Pt       *pt = reinterpret_cast<Pt *>(s->ARG_1);
    current->oom_call(pt, s->ARG_2, s->ARG_3, oom_xcpu_return<ret_xcpu_reply_oom<C>>, sys_xcpu_call_oom<C>);
c0009a94:	8b 48 54             	mov    0x54(%eax),%ecx
c0009a97:	8b 50 70             	mov    0x70(%eax),%edx
c0009a9a:	68 68 9a 00 c0       	push   $0xc0009a68
c0009a9f:	68 ba 63 00 c0       	push   $0xc00063ba
c0009aa4:	ff 70 58             	pushl  0x58(%eax)
c0009aa7:	e8 ae fd ff ff       	call   c000985a <_ZN2Ec8oom_callEP2PtmmPFvvES3_>

c0009aac <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_8sys_callEvEEEEvv>:
}

template <void (*C)()>
void Ec::sys_xcpu_call_oom()
{
    assert (current->xcpu_sm);
c0009aac:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0009ab1:	83 b8 f4 00 00 00 00 	cmpl   $0x0,0xf4(%eax)
c0009ab8:	75 1e                	jne    c0009ad8 <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_8sys_callEvEEEEvv+0x2c>
c0009aba:	68 00 84 01 c0       	push   $0xc0018400
c0009abf:	68 a7 00 00 00       	push   $0xa7
c0009ac4:	68 a3 72 01 c0       	push   $0xc00172a3
c0009ac9:	68 66 6c 01 c0       	push   $0xc0016c66
c0009ace:	68 69 60 01 c0       	push   $0xc0016069
c0009ad3:	e8 6e 7e ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

    Sys_regs *s  = current->sys_regs();
    Pt       *pt = reinterpret_cast<Pt *>(s->ARG_1);
    current->oom_call(pt, s->ARG_2, s->ARG_3, oom_xcpu_return<ret_xcpu_reply_oom<C>>, sys_xcpu_call_oom<C>);
c0009ad8:	8b 48 54             	mov    0x54(%eax),%ecx
c0009adb:	8b 50 70             	mov    0x70(%eax),%edx
c0009ade:	68 ac 9a 00 c0       	push   $0xc0009aac
c0009ae3:	68 04 67 00 c0       	push   $0xc0006704
c0009ae8:	ff 70 58             	pushl  0x58(%eax)
c0009aeb:	e8 6a fd ff ff       	call   c000985a <_ZN2Ec8oom_callEP2PtmmPFvvES3_>

c0009af0 <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_10sys_lookupEvEEEEvv>:
}

template <void (*C)()>
void Ec::sys_xcpu_call_oom()
{
    assert (current->xcpu_sm);
c0009af0:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0009af5:	83 b8 f4 00 00 00 00 	cmpl   $0x0,0xf4(%eax)
c0009afc:	75 1e                	jne    c0009b1c <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_10sys_lookupEvEEEEvv+0x2c>
c0009afe:	68 40 82 01 c0       	push   $0xc0018240
c0009b03:	68 a7 00 00 00       	push   $0xa7
c0009b08:	68 a3 72 01 c0       	push   $0xc00172a3
c0009b0d:	68 66 6c 01 c0       	push   $0xc0016c66
c0009b12:	68 69 60 01 c0       	push   $0xc0016069
c0009b17:	e8 2a 7e ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

    Sys_regs *s  = current->sys_regs();
    Pt       *pt = reinterpret_cast<Pt *>(s->ARG_1);
    current->oom_call(pt, s->ARG_2, s->ARG_3, oom_xcpu_return<ret_xcpu_reply_oom<C>>, sys_xcpu_call_oom<C>);
c0009b1c:	8b 48 54             	mov    0x54(%eax),%ecx
c0009b1f:	8b 50 70             	mov    0x70(%eax),%edx
c0009b22:	68 f0 9a 00 c0       	push   $0xc0009af0
c0009b27:	68 4e 6a 00 c0       	push   $0xc0006a4e
c0009b2c:	ff 70 58             	pushl  0x58(%eax)
c0009b2f:	e8 26 fd ff ff       	call   c000985a <_ZN2Ec8oom_callEP2PtmmPFvvES3_>

c0009b34 <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvv>:
}

template <void (*C)()>
void Ec::sys_xcpu_call_oom()
{
    assert (current->xcpu_sm);
c0009b34:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0009b39:	83 b8 f4 00 00 00 00 	cmpl   $0x0,0xf4(%eax)
c0009b40:	75 1e                	jne    c0009b60 <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvv+0x2c>
c0009b42:	68 80 80 01 c0       	push   $0xc0018080
c0009b47:	68 a7 00 00 00       	push   $0xa7
c0009b4c:	68 a3 72 01 c0       	push   $0xc00172a3
c0009b51:	68 66 6c 01 c0       	push   $0xc0016c66
c0009b56:	68 69 60 01 c0       	push   $0xc0016069
c0009b5b:	e8 e6 7d ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

    Sys_regs *s  = current->sys_regs();
    Pt       *pt = reinterpret_cast<Pt *>(s->ARG_1);
    current->oom_call(pt, s->ARG_2, s->ARG_3, oom_xcpu_return<ret_xcpu_reply_oom<C>>, sys_xcpu_call_oom<C>);
c0009b60:	8b 48 54             	mov    0x54(%eax),%ecx
c0009b63:	8b 50 70             	mov    0x70(%eax),%edx
c0009b66:	68 34 9b 00 c0       	push   $0xc0009b34
c0009b6b:	68 98 6d 00 c0       	push   $0xc0006d98
c0009b70:	ff 70 58             	pushl  0x58(%eax)
c0009b73:	e8 e2 fc ff ff       	call   c000985a <_ZN2Ec8oom_callEP2PtmmPFvvES3_>

c0009b78 <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvv>:
}

template <void (*C)()>
void Ec::sys_xcpu_call_oom()
{
    assert (current->xcpu_sm);
c0009b78:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0009b7d:	83 b8 f4 00 00 00 00 	cmpl   $0x0,0xf4(%eax)
c0009b84:	75 1e                	jne    c0009ba4 <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvv+0x2c>
c0009b86:	68 c0 7e 01 c0       	push   $0xc0017ec0
c0009b8b:	68 a7 00 00 00       	push   $0xa7
c0009b90:	68 a3 72 01 c0       	push   $0xc00172a3
c0009b95:	68 66 6c 01 c0       	push   $0xc0016c66
c0009b9a:	68 69 60 01 c0       	push   $0xc0016069
c0009b9f:	e8 a2 7d ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

    Sys_regs *s  = current->sys_regs();
    Pt       *pt = reinterpret_cast<Pt *>(s->ARG_1);
    current->oom_call(pt, s->ARG_2, s->ARG_3, oom_xcpu_return<ret_xcpu_reply_oom<C>>, sys_xcpu_call_oom<C>);
c0009ba4:	8b 48 54             	mov    0x54(%eax),%ecx
c0009ba7:	8b 50 70             	mov    0x70(%eax),%edx
c0009baa:	68 78 9b 00 c0       	push   $0xc0009b78
c0009baf:	68 e2 70 00 c0       	push   $0xc00070e2
c0009bb4:	ff 70 58             	pushl  0x58(%eax)
c0009bb7:	e8 9e fc ff ff       	call   c000985a <_ZN2Ec8oom_callEP2PtmmPFvvES3_>

c0009bbc <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvv>:
}

template <void (*C)()>
void Ec::sys_xcpu_call_oom()
{
    assert (current->xcpu_sm);
c0009bbc:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0009bc1:	83 b8 f4 00 00 00 00 	cmpl   $0x0,0xf4(%eax)
c0009bc8:	75 1e                	jne    c0009be8 <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvv+0x2c>
c0009bca:	68 00 7d 01 c0       	push   $0xc0017d00
c0009bcf:	68 a7 00 00 00       	push   $0xa7
c0009bd4:	68 a3 72 01 c0       	push   $0xc00172a3
c0009bd9:	68 66 6c 01 c0       	push   $0xc0016c66
c0009bde:	68 69 60 01 c0       	push   $0xc0016069
c0009be3:	e8 5e 7d ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

    Sys_regs *s  = current->sys_regs();
    Pt       *pt = reinterpret_cast<Pt *>(s->ARG_1);
    current->oom_call(pt, s->ARG_2, s->ARG_3, oom_xcpu_return<ret_xcpu_reply_oom<C>>, sys_xcpu_call_oom<C>);
c0009be8:	8b 48 54             	mov    0x54(%eax),%ecx
c0009beb:	8b 50 70             	mov    0x70(%eax),%edx
c0009bee:	68 bc 9b 00 c0       	push   $0xc0009bbc
c0009bf3:	68 2c 74 00 c0       	push   $0xc000742c
c0009bf8:	ff 70 58             	pushl  0x58(%eax)
c0009bfb:	e8 5a fc ff ff       	call   c000985a <_ZN2Ec8oom_callEP2PtmmPFvvES3_>

c0009c00 <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvv>:
}

template <void (*C)()>
void Ec::sys_xcpu_call_oom()
{
    assert (current->xcpu_sm);
c0009c00:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0009c05:	83 b8 f4 00 00 00 00 	cmpl   $0x0,0xf4(%eax)
c0009c0c:	75 1e                	jne    c0009c2c <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvv+0x2c>
c0009c0e:	68 40 7b 01 c0       	push   $0xc0017b40
c0009c13:	68 a7 00 00 00       	push   $0xa7
c0009c18:	68 a3 72 01 c0       	push   $0xc00172a3
c0009c1d:	68 66 6c 01 c0       	push   $0xc0016c66
c0009c22:	68 69 60 01 c0       	push   $0xc0016069
c0009c27:	e8 1a 7d ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

    Sys_regs *s  = current->sys_regs();
    Pt       *pt = reinterpret_cast<Pt *>(s->ARG_1);
    current->oom_call(pt, s->ARG_2, s->ARG_3, oom_xcpu_return<ret_xcpu_reply_oom<C>>, sys_xcpu_call_oom<C>);
c0009c2c:	8b 48 54             	mov    0x54(%eax),%ecx
c0009c2f:	8b 50 70             	mov    0x70(%eax),%edx
c0009c32:	68 00 9c 00 c0       	push   $0xc0009c00
c0009c37:	68 76 77 00 c0       	push   $0xc0007776
c0009c3c:	ff 70 58             	pushl  0x58(%eax)
c0009c3f:	e8 16 fc ff ff       	call   c000985a <_ZN2Ec8oom_callEP2PtmmPFvvES3_>

c0009c44 <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvv>:
}

template <void (*C)()>
void Ec::sys_xcpu_call_oom()
{
    assert (current->xcpu_sm);
c0009c44:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0009c49:	83 b8 f4 00 00 00 00 	cmpl   $0x0,0xf4(%eax)
c0009c50:	75 1e                	jne    c0009c70 <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvv+0x2c>
c0009c52:	68 80 79 01 c0       	push   $0xc0017980
c0009c57:	68 a7 00 00 00       	push   $0xa7
c0009c5c:	68 a3 72 01 c0       	push   $0xc00172a3
c0009c61:	68 66 6c 01 c0       	push   $0xc0016c66
c0009c66:	68 69 60 01 c0       	push   $0xc0016069
c0009c6b:	e8 d6 7c ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

    Sys_regs *s  = current->sys_regs();
    Pt       *pt = reinterpret_cast<Pt *>(s->ARG_1);
    current->oom_call(pt, s->ARG_2, s->ARG_3, oom_xcpu_return<ret_xcpu_reply_oom<C>>, sys_xcpu_call_oom<C>);
c0009c70:	8b 48 54             	mov    0x54(%eax),%ecx
c0009c73:	8b 50 70             	mov    0x70(%eax),%edx
c0009c76:	68 44 9c 00 c0       	push   $0xc0009c44
c0009c7b:	68 c0 7a 00 c0       	push   $0xc0007ac0
c0009c80:	ff 70 58             	pushl  0x58(%eax)
c0009c83:	e8 d2 fb ff ff       	call   c000985a <_ZN2Ec8oom_callEP2PtmmPFvvES3_>

c0009c88 <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvv>:
}

template <void (*C)()>
void Ec::sys_xcpu_call_oom()
{
    assert (current->xcpu_sm);
c0009c88:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0009c8d:	83 b8 f4 00 00 00 00 	cmpl   $0x0,0xf4(%eax)
c0009c94:	75 1e                	jne    c0009cb4 <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvv+0x2c>
c0009c96:	68 c0 77 01 c0       	push   $0xc00177c0
c0009c9b:	68 a7 00 00 00       	push   $0xa7
c0009ca0:	68 a3 72 01 c0       	push   $0xc00172a3
c0009ca5:	68 66 6c 01 c0       	push   $0xc0016c66
c0009caa:	68 69 60 01 c0       	push   $0xc0016069
c0009caf:	e8 92 7c ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

    Sys_regs *s  = current->sys_regs();
    Pt       *pt = reinterpret_cast<Pt *>(s->ARG_1);
    current->oom_call(pt, s->ARG_2, s->ARG_3, oom_xcpu_return<ret_xcpu_reply_oom<C>>, sys_xcpu_call_oom<C>);
c0009cb4:	8b 48 54             	mov    0x54(%eax),%ecx
c0009cb7:	8b 50 70             	mov    0x70(%eax),%edx
c0009cba:	68 88 9c 00 c0       	push   $0xc0009c88
c0009cbf:	68 0a 7e 00 c0       	push   $0xc0007e0a
c0009cc4:	ff 70 58             	pushl  0x58(%eax)
c0009cc7:	e8 8e fb ff ff       	call   c000985a <_ZN2Ec8oom_callEP2PtmmPFvvES3_>

c0009ccc <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_14sys_assign_pciEvEEEEvv>:
}

template <void (*C)()>
void Ec::sys_xcpu_call_oom()
{
    assert (current->xcpu_sm);
c0009ccc:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0009cd1:	83 b8 f4 00 00 00 00 	cmpl   $0x0,0xf4(%eax)
c0009cd8:	75 1e                	jne    c0009cf8 <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_14sys_assign_pciEvEEEEvv+0x2c>
c0009cda:	68 00 76 01 c0       	push   $0xc0017600
c0009cdf:	68 a7 00 00 00       	push   $0xa7
c0009ce4:	68 a3 72 01 c0       	push   $0xc00172a3
c0009ce9:	68 66 6c 01 c0       	push   $0xc0016c66
c0009cee:	68 69 60 01 c0       	push   $0xc0016069
c0009cf3:	e8 4e 7c ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

    Sys_regs *s  = current->sys_regs();
    Pt       *pt = reinterpret_cast<Pt *>(s->ARG_1);
    current->oom_call(pt, s->ARG_2, s->ARG_3, oom_xcpu_return<ret_xcpu_reply_oom<C>>, sys_xcpu_call_oom<C>);
c0009cf8:	8b 48 54             	mov    0x54(%eax),%ecx
c0009cfb:	8b 50 70             	mov    0x70(%eax),%edx
c0009cfe:	68 cc 9c 00 c0       	push   $0xc0009ccc
c0009d03:	68 54 81 00 c0       	push   $0xc0008154
c0009d08:	ff 70 58             	pushl  0x58(%eax)
c0009d0b:	e8 4a fb ff ff       	call   c000985a <_ZN2Ec8oom_callEP2PtmmPFvvES3_>

c0009d10 <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm>:
    ec->regs.set_ip (pt->ip);
    ec->make_current();
}

template <void (*C)()>
void Ec::oom_xcpu(Pt * pt, mword src_pd_id, mword oom_state)
c0009d10:	55                   	push   %ebp
c0009d11:	57                   	push   %edi
c0009d12:	56                   	push   %esi
c0009d13:	53                   	push   %ebx
c0009d14:	53                   	push   %ebx
{
    assert(current == this);
c0009d15:	8b 35 08 f0 ff cf    	mov    0xcffff008,%esi
c0009d1b:	39 c6                	cmp    %eax,%esi
c0009d1d:	74 13                	je     c0009d32 <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x22>
c0009d1f:	68 00 87 01 c0       	push   $0xc0018700
c0009d24:	6a 72                	push   $0x72
c0009d26:	68 a3 72 01 c0       	push   $0xc00172a3
c0009d2b:	68 bc 73 01 c0       	push   $0xc00173bc
c0009d30:	eb 1a                	jmp    c0009d4c <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x3c>
    assert(!this->xcpu_sm);
c0009d32:	83 be f4 00 00 00 00 	cmpl   $0x0,0xf4(%esi)
c0009d39:	74 1b                	je     c0009d56 <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x46>
c0009d3b:	68 00 87 01 c0       	push   $0xc0018700
c0009d40:	6a 73                	push   $0x73
c0009d42:	68 a3 72 01 c0       	push   $0xc00172a3
c0009d47:	68 cc 73 01 c0       	push   $0xc00173cc
c0009d4c:	68 69 60 01 c0       	push   $0xc0016069
c0009d51:	e8 f0 7b ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

    enum { UNUSED = 0, CNT = 0 };

    this->xcpu_sm = new (Pd::current->quota) Sm (Pd::current, UNUSED, CNT);
c0009d56:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c0009d5b:	89 d7                	mov    %edx,%edi
c0009d5d:	89 cd                	mov    %ecx,%ebp
c0009d5f:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx

            call_rcu(true);
        }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
c0009d65:	b8 b4 b4 01 c0       	mov    $0xc001b4b4,%eax
c0009d6a:	e8 07 65 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c0009d6f:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c0009d75:	31 c9                	xor    %ecx,%ecx
c0009d77:	6a 00                	push   $0x0
c0009d79:	6a 00                	push   $0x0
c0009d7b:	6a 00                	push   $0x0
c0009d7d:	89 c3                	mov    %eax,%ebx
c0009d7f:	e8 96 69 00 00       	call   c001071a <_ZN2SmC1EP2PdmmPS_m>
c0009d84:	89 9e f4 00 00 00    	mov    %ebx,0xf4(%esi)

    Ec *xcpu_ec = new (Pd::current->quota) Ec (Pd::current, Pd::current, sys_xcpu_call_oom<C>, pt->ec->cpu, this);
c0009d8a:	8b 47 4c             	mov    0x4c(%edi),%eax
c0009d8d:	0f b7 80 cc 00 00 00 	movzwl 0xcc(%eax),%eax
c0009d94:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0009d98:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c0009d9d:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx
        static void die (char const *, Exc_regs * = &current->regs);

        static void idl_handler();

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
c0009da3:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c0009da8:	e8 c9 64 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c0009dad:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c0009db3:	56                   	push   %esi
c0009db4:	ff 74 24 10          	pushl  0x10(%esp)
c0009db8:	89 d1                	mov    %edx,%ecx
c0009dba:	68 68 9a 00 c0       	push   $0xc0009a68
c0009dbf:	89 c3                	mov    %eax,%ebx
c0009dc1:	e8 c4 95 ff ff       	call   c000338a <_ZN2EcC1EP2PdS1_PFvvEjPS_>

        ALWAYS_INLINE
        inline void set_pt (mword pt) { ARG_1 = pt; }

        ALWAYS_INLINE
        inline void set_pt (mword pt, mword pt2, mword s) { ARG_1 = pt; ARG_2 = pt2; ARG_3 = s; }
c0009dc6:	8b 44 24 30          	mov    0x30(%esp),%eax
c0009dca:	89 7b 70             	mov    %edi,0x70(%ebx)
c0009dcd:	89 6b 54             	mov    %ebp,0x54(%ebx)
c0009dd0:	89 43 58             	mov    %eax,0x58(%ebx)
    xcpu_ec->regs.set_pt (reinterpret_cast<mword>(pt), src_pd_id, oom_state);

    Sc *xcpu_sc = new (Pd::current->quota) Sc (Pd::current, xcpu_ec, xcpu_ec->cpu, Sc::current);
c0009dd3:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c0009dd8:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx

        NORETURN
        static void schedule (bool = false, bool = true);

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
c0009dde:	b8 98 b4 01 c0       	mov    $0xc001b498,%eax
c0009de3:	e8 8e 64 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c0009de8:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c0009dee:	89 d9                	mov    %ebx,%ecx
c0009df0:	ff 35 10 f0 ff cf    	pushl  0xcffff010
c0009df6:	89 c7                	mov    %eax,%edi
c0009df8:	0f b7 83 cc 00 00 00 	movzwl 0xcc(%ebx),%eax
c0009dff:	50                   	push   %eax
c0009e00:	89 f8                	mov    %edi,%eax
c0009e02:	e8 87 56 00 00       	call   c000f48e <_ZN2ScC1EP2PdP2EcjPS_>

    xcpu_sc->remote_enqueue();
c0009e07:	89 f8                	mov    %edi,%eax
c0009e09:	83 c4 20             	add    $0x20,%esp
c0009e0c:	e8 2b 59 00 00       	call   c000f73c <_ZN2Sc14remote_enqueueEv>
    this->xcpu_sm->dn (false, 0);
c0009e11:	8b b6 f4 00 00 00    	mov    0xf4(%esi),%esi
c0009e17:	8b 1d 08 f0 ff cf    	mov    0xcffff008,%ebx
        }

        ALWAYS_INLINE
        inline void dn (bool zero, uint64 t, Ec *ec = Ec::current, bool block = true)
        {
            {   Lock_guard <Spinlock> guard (lock);
c0009e1d:	8d 46 46             	lea    0x46(%esi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c0009e20:	9c                   	pushf  
c0009e21:	5a                   	pop    %edx
            return flags & 0x200;
c0009e22:	c1 ea 09             	shr    $0x9,%edx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c0009e25:	80 e2 01             	and    $0x1,%dl
c0009e28:	74 2a                	je     c0009e54 <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x144>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0009e2a:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0009e31:	75 19                	jne    c0009e4c <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x13c>
c0009e33:	68 80 85 01 c0       	push   $0xc0018580
c0009e38:	68 b7 00 00 00       	push   $0xb7
c0009e3d:	68 12 61 01 c0       	push   $0xc0016112
c0009e42:	68 83 61 01 c0       	push   $0xc0016183
c0009e47:	e9 00 ff ff ff       	jmp    c0009d4c <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x3c>

            asm volatile ("cli" : : : "memory");
c0009e4c:	fa                   	cli    
            preemption = false;
c0009e4d:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
c0009e54:	88 14 24             	mov    %dl,(%esp)
                Cpu::preempt_disable();

            _lock.lock();
c0009e57:	e8 d0 6c ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>

                if (counter) {
c0009e5c:	8b 46 64             	mov    0x64(%esi),%eax
c0009e5f:	8a 14 24             	mov    (%esp),%dl
c0009e62:	85 c0                	test   %eax,%eax
c0009e64:	74 76                	je     c0009edc <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x1cc>
                    counter = zero ? 0 : counter - 1;
c0009e66:	48                   	dec    %eax
c0009e67:	89 46 64             	mov    %eax,0x64(%esi)
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c0009e6a:	8b 46 50             	mov    0x50(%esi),%eax
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c0009e6d:	85 c0                	test   %eax,%eax
c0009e6f:	0f 84 da 00 00 00    	je     c0009f4f <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x23f>
c0009e75:	8b 48 08             	mov    0x8(%eax),%ecx
c0009e78:	85 c9                	test   %ecx,%ecx
c0009e7a:	0f 84 cf 00 00 00    	je     c0009f4f <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x23f>
c0009e80:	8b 78 04             	mov    0x4(%eax),%edi
c0009e83:	85 ff                	test   %edi,%edi
c0009e85:	0f 84 c4 00 00 00    	je     c0009f4f <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x23f>
                return false;

            if (t == t->next)
c0009e8b:	39 c8                	cmp    %ecx,%eax
c0009e8d:	75 09                	jne    c0009e98 <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x188>
                headptr = nullptr;
c0009e8f:	c7 46 50 00 00 00 00 	movl   $0x0,0x50(%esi)
c0009e96:	eb 17                	jmp    c0009eaf <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x19f>

            else {
                t->next->prev = t->prev;
c0009e98:	89 79 04             	mov    %edi,0x4(%ecx)
                t->prev->next = t->next;
c0009e9b:	8b 48 04             	mov    0x4(%eax),%ecx
c0009e9e:	8b 78 08             	mov    0x8(%eax),%edi
c0009ea1:	89 79 08             	mov    %edi,0x8(%ecx)
                if (t == headptr)
c0009ea4:	3b 46 50             	cmp    0x50(%esi),%eax
c0009ea7:	75 06                	jne    c0009eaf <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x19f>
                    headptr = t->next;
c0009ea9:	8b 48 08             	mov    0x8(%eax),%ecx
c0009eac:	89 4e 50             	mov    %ecx,0x50(%esi)

    public:

        mword reset(bool l = false) {
            if (l) lock.lock();
            mword c = counter;
c0009eaf:	8b 48 10             	mov    0x10(%eax),%ecx
            }

            t->next = t->prev = nullptr;
c0009eb2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
c0009eb9:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
            counter = 0;
c0009ec0:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
                if (counter) {
                    counter = zero ? 0 : counter - 1;

                    Si * si;
                    if (Queue<Si>::dequeue(si = Queue<Si>::head()))
                        ec->set_si_regs(si->value, static_cast <Sm *>(si)->reset());
c0009ec7:	8b 40 0c             	mov    0xc(%eax),%eax

        ALWAYS_INLINE
        inline void set_si_regs(mword sig, mword cnt)
        {
            regs.ARG_2 = sig;
            regs.ARG_3 = cnt;
c0009eca:	89 4b 58             	mov    %ecx,0x58(%ebx)
        }

        ALWAYS_INLINE
        inline void set_si_regs(mword sig, mword cnt)
        {
            regs.ARG_2 = sig;
c0009ecd:	89 43 54             	mov    %eax,0x54(%ebx)
c0009ed0:	eb 7d                	jmp    c0009f4f <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x23f>
c0009ed2:	8d 48 01             	lea    0x1(%eax),%ecx
c0009ed5:	f0 0f b1 4b 48       	lock cmpxchg %ecx,0x48(%ebx)
c0009eda:	74 07                	je     c0009ee3 <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x1d3>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0009edc:	8b 43 48             	mov    0x48(%ebx),%eax
c0009edf:	85 c0                	test   %eax,%eax
c0009ee1:	75 ef                	jne    c0009ed2 <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x1c2>
        inline T *head() const { return headptr; }

        ALWAYS_INLINE
        inline void enqueue (T *t)
        {
            if (!headptr)
c0009ee3:	8b 46 4c             	mov    0x4c(%esi),%eax
c0009ee6:	85 c0                	test   %eax,%eax
c0009ee8:	75 11                	jne    c0009efb <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x1eb>
                headptr = t->prev = t->next = t;
c0009eea:	89 9b c4 00 00 00    	mov    %ebx,0xc4(%ebx)
c0009ef0:	89 9b c0 00 00 00    	mov    %ebx,0xc0(%ebx)
c0009ef6:	89 5e 4c             	mov    %ebx,0x4c(%esi)
c0009ef9:	eb 21                	jmp    c0009f1c <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x20c>
            else {
                t->next = headptr;
c0009efb:	89 83 c4 00 00 00    	mov    %eax,0xc4(%ebx)
                t->prev = headptr->prev;
c0009f01:	8b 4e 4c             	mov    0x4c(%esi),%ecx
c0009f04:	8b 89 c0 00 00 00    	mov    0xc0(%ecx),%ecx
c0009f0a:	89 8b c0 00 00 00    	mov    %ecx,0xc0(%ebx)
                t->next->prev = t->prev->next = t;
c0009f10:	89 99 c4 00 00 00    	mov    %ebx,0xc4(%ecx)
c0009f16:	89 98 c0 00 00 00    	mov    %ebx,0xc0(%eax)
c0009f1c:	fe 46 46             	incb   0x46(%esi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c0009f1f:	84 d2                	test   %dl,%dl
c0009f21:	74 46                	je     c0009f69 <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x259>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0009f23:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0009f2a:	74 19                	je     c0009f45 <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x235>
c0009f2c:	68 40 85 01 c0       	push   $0xc0018540
c0009f31:	68 c0 00 00 00       	push   $0xc0
c0009f36:	68 12 61 01 c0       	push   $0xc0016112
c0009f3b:	68 82 61 01 c0       	push   $0xc0016182
c0009f40:	e9 07 fe ff ff       	jmp    c0009d4c <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x3c>

            preemption = true;
c0009f45:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c0009f4c:	fb                   	sti    
c0009f4d:	eb 1a                	jmp    c0009f69 <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x259>
c0009f4f:	fe 46 46             	incb   0x46(%esi)
c0009f52:	84 d2                	test   %dl,%dl
c0009f54:	74 1a                	je     c0009f70 <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x260>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0009f56:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0009f5d:	75 cd                	jne    c0009f2c <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x21c>

            preemption = true;
c0009f5f:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c0009f66:	fb                   	sti    
c0009f67:	eb 07                	jmp    c0009f70 <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x260>
            if (!block)
                Sc::schedule (false);

            ec->set_timeout (t, this);

            ec->block_sc();
c0009f69:	89 d8                	mov    %ebx,%eax
c0009f6b:	e8 a0 e5 ff ff       	call   c0008510 <_ZN2Ec8block_scEv>

    die ("XCPU OOM error");
c0009f70:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0009f75:	8d 50 54             	lea    0x54(%eax),%edx
c0009f78:	b8 db 73 01 c0       	mov    $0xc00173db,%eax
c0009f7d:	e8 8a 9b ff ff       	call   c0003b0c <_ZN2Ec3dieEPKcP8Exc_regs>

c0009f82 <_ZN2Ec12oom_delegateEPS_S0_S0_bb>:
#include "pt.hpp"
#include "utcb.hpp"
#include "sm.hpp"

void Ec::oom_delegate(Ec * dst_ec, Ec * rep_ec, Ec * src_ec, bool user, bool C)
{
c0009f82:	55                   	push   %ebp
c0009f83:	57                   	push   %edi
c0009f84:	56                   	push   %esi
c0009f85:	89 ce                	mov    %ecx,%esi
c0009f87:	53                   	push   %ebx
c0009f88:	83 ec 08             	sub    $0x8,%esp
c0009f8b:	8a 4c 24 24          	mov    0x24(%esp),%cl
    Pt * const dst_pt = dst_ec->pt_oom;
c0009f8f:	8b ba f8 00 00 00    	mov    0xf8(%edx),%edi
#include "pt.hpp"
#include "utcb.hpp"
#include "sm.hpp"

void Ec::oom_delegate(Ec * dst_ec, Ec * rep_ec, Ec * src_ec, bool user, bool C)
{
c0009f95:	8a 44 24 20          	mov    0x20(%esp),%al
c0009f99:	88 4c 24 03          	mov    %cl,0x3(%esp)
    Pt * const dst_pt = dst_ec->pt_oom;
    Pt * const src_pt = src_ec->pt_oom;
c0009f9d:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx

    if (!dst_pt) {
c0009fa1:	85 ff                	test   %edi,%edi
#include "utcb.hpp"
#include "sm.hpp"

void Ec::oom_delegate(Ec * dst_ec, Ec * rep_ec, Ec * src_ec, bool user, bool C)
{
    Pt * const dst_pt = dst_ec->pt_oom;
c0009fa3:	89 7c 24 04          	mov    %edi,0x4(%esp)
    Pt * const src_pt = src_ec->pt_oom;
c0009fa7:	8b a9 f8 00 00 00    	mov    0xf8(%ecx),%ebp

    if (!dst_pt) {
c0009fad:	75 28                	jne    c0009fd7 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x55>
{
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
c0009faf:	8b 92 b8 00 00 00    	mov    0xb8(%edx),%edx
        dst_ec->pd->quota.dump(dst_ec->pd);
c0009fb5:	b9 01 00 00 00       	mov    $0x1,%ecx
c0009fba:	8d 82 90 01 00 00    	lea    0x190(%edx),%eax
c0009fc0:	e8 43 73 ff ff       	call   c0001308 <_ZN5Quota4dumpEPvb>
        die ("PT not found - OOM");
c0009fc5:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0009fca:	8d 50 54             	lea    0x54(%eax),%edx
c0009fcd:	b8 ea 73 01 c0       	mov    $0xc00173ea,%eax
c0009fd2:	e9 a4 01 00 00       	jmp    c000a17b <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x1f9>
    }

    if (user) {
c0009fd7:	84 c0                	test   %al,%al
c0009fd9:	0f 84 8b 00 00 00    	je     c000a06a <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0xe8>
        if (C) {
c0009fdf:	80 7c 24 03 00       	cmpb   $0x0,0x3(%esp)
c0009fe4:	74 2f                	je     c000a015 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x93>
             assert (rep_ec->cont == ret_user_sysexit || rep_ec->cont == xcpu_return);
c0009fe6:	8b 46 50             	mov    0x50(%esi),%eax
c0009fe9:	3d 00 00 00 c0       	cmp    $0xc0000000,%eax
c0009fee:	0f 84 36 02 00 00    	je     c000a22a <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x2a8>
c0009ff4:	3d 8e 40 00 c0       	cmp    $0xc000408e,%eax
c0009ff9:	0f 84 2b 02 00 00    	je     c000a22a <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x2a8>
c0009fff:	68 80 87 01 c0       	push   $0xc0018780
c000a004:	6a 24                	push   $0x24
c000a006:	68 a3 72 01 c0       	push   $0xc00172a3
c000a00b:	68 70 74 01 c0       	push   $0xc0017470
c000a010:	e9 46 02 00 00       	jmp    c000a25b <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x2d9>
             assert (dst_ec->cont == recv_user);
        } else 
             assert (dst_ec->cont == ret_user_sysexit || dst_ec->cont == xcpu_return);
c000a015:	8b 42 50             	mov    0x50(%edx),%eax
c000a018:	3d 00 00 00 c0       	cmp    $0xc0000000,%eax
c000a01d:	74 0b                	je     c000a02a <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0xa8>
c000a01f:	3d 8e 40 00 c0       	cmp    $0xc000408e,%eax
c000a024:	0f 85 20 02 00 00    	jne    c000a24a <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x2c8>

        assert(dst_ec->utcb);
c000a02a:	8b 82 b4 00 00 00    	mov    0xb4(%edx),%eax
c000a030:	85 c0                	test   %eax,%eax
c000a032:	75 16                	jne    c000a04a <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0xc8>
c000a034:	68 80 87 01 c0       	push   $0xc0018780
c000a039:	6a 29                	push   $0x29
c000a03b:	68 a3 72 01 c0       	push   $0xc00172a3
c000a040:	68 17 74 01 c0       	push   $0xc0017417
c000a045:	e9 11 02 00 00       	jmp    c000a25b <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x2d9>

        dst_ec->pd->rev_crd (dst_ec->utcb->del, true, false, false);
c000a04a:	8b 58 08             	mov    0x8(%eax),%ebx
c000a04d:	b9 01 00 00 00       	mov    $0x1,%ecx
c000a052:	8b 82 b8 00 00 00    	mov    0xb8(%edx),%eax
c000a058:	6a 00                	push   $0x0
c000a05a:	6a 00                	push   $0x0
c000a05c:	89 da                	mov    %ebx,%edx
c000a05e:	e8 03 2b 00 00       	call   c000cb66 <_ZN2Pd7rev_crdE3Crdbbb>
c000a063:	59                   	pop    %ecx
c000a064:	5b                   	pop    %ebx
c000a065:	e9 84 00 00 00       	jmp    c000a0ee <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x16c>
    } else {
        assert(!C);
c000a06a:	80 7c 24 03 00       	cmpb   $0x0,0x3(%esp)
c000a06f:	74 16                	je     c000a087 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x105>
c000a071:	68 80 87 01 c0       	push   $0xc0018780
c000a076:	6a 2d                	push   $0x2d
c000a078:	68 a3 72 01 c0       	push   $0xc00172a3
c000a07d:	68 24 74 01 c0       	push   $0xc0017424
c000a082:	e9 d4 01 00 00       	jmp    c000a25b <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x2d9>
        assert(src_ec->utcb);
c000a087:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c000a08b:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
c000a091:	85 c0                	test   %eax,%eax
c000a093:	75 16                	jne    c000a0ab <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x129>
c000a095:	68 80 87 01 c0       	push   $0xc0018780
c000a09a:	6a 2e                	push   $0x2e
c000a09c:	68 a3 72 01 c0       	push   $0xc00172a3
c000a0a1:	68 27 74 01 c0       	push   $0xc0017427
c000a0a6:	e9 b0 01 00 00       	jmp    c000a25b <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x2d9>
        WARN_UNUSED_RESULT bool save_exc (Cpu_regs *);
        WARN_UNUSED_RESULT bool save_vmx (Cpu_regs *);
        WARN_UNUSED_RESULT bool save_svm (Cpu_regs *);

        inline mword ucnt() const { return static_cast<uint16>(items); }
        inline mword tcnt() const { return static_cast<uint16>(items >> 16); }
c000a0ab:	8b 18                	mov    (%eax),%ebx
                dst->mr[i] = mr[i];
#endif
        }

        ALWAYS_INLINE
        inline Xfer *xfer() { return reinterpret_cast<Xfer *>(this) + PAGE_SIZE / sizeof (Xfer) - 1; }
c000a0ad:	8d b8 f8 0f 00 00    	lea    0xff8(%eax),%edi
c000a0b3:	b8 fe 01 00 00       	mov    $0x1fe,%eax
        WARN_UNUSED_RESULT bool save_exc (Cpu_regs *);
        WARN_UNUSED_RESULT bool save_vmx (Cpu_regs *);
        WARN_UNUSED_RESULT bool save_svm (Cpu_regs *);

        inline mword ucnt() const { return static_cast<uint16>(items); }
        inline mword tcnt() const { return static_cast<uint16>(items >> 16); }
c000a0b8:	c1 eb 10             	shr    $0x10,%ebx
c000a0bb:	81 fb fe 01 00 00    	cmp    $0x1fe,%ebx
c000a0c1:	0f 47 d8             	cmova  %eax,%ebx

        Xfer *s = src_ec->utcb->xfer();
        for (unsigned long ti = src_ec->utcb->ti(); ti--; s--) {
c000a0c4:	4b                   	dec    %ebx
c000a0c5:	83 fb ff             	cmp    $0xffffffff,%ebx
c000a0c8:	74 24                	je     c000a0ee <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x16c>
            if ((s->flags() >> 8) & 1)
c000a0ca:	f6 47 05 01          	testb  $0x1,0x5(%edi)
c000a0ce:	75 19                	jne    c000a0e9 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x167>
                continue;
            src_ec->pd->rev_crd (*s, false, false, false);
c000a0d0:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c000a0d4:	31 c9                	xor    %ecx,%ecx
c000a0d6:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
c000a0dc:	6a 00                	push   $0x0
c000a0de:	6a 00                	push   $0x0
c000a0e0:	8b 17                	mov    (%edi),%edx
c000a0e2:	e8 7f 2a 00 00       	call   c000cb66 <_ZN2Pd7rev_crdE3Crdbbb>
c000a0e7:	58                   	pop    %eax
c000a0e8:	5a                   	pop    %edx
    } else {
        assert(!C);
        assert(src_ec->utcb);

        Xfer *s = src_ec->utcb->xfer();
        for (unsigned long ti = src_ec->utcb->ti(); ti--; s--) {
c000a0e9:	83 ef 08             	sub    $0x8,%edi
c000a0ec:	eb d6                	jmp    c000a0c4 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x142>
c000a0ee:	8b 44 24 04          	mov    0x4(%esp),%eax
                continue;
            src_ec->pd->rev_crd (*s, false, false, false);
        }
    }

    mword src_pd_id = !src_pt ? ~0UL : 0;
c000a0f2:	83 c9 ff             	or     $0xffffffff,%ecx
c000a0f5:	85 ed                	test   %ebp,%ebp
c000a0f7:	8b 58 4c             	mov    0x4c(%eax),%ebx
c000a0fa:	0f 85 65 01 00 00    	jne    c000a265 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x2e3>

    Ec * const ec = dst_pt->ec;

    enum { OOM_SEND = 1, OOM_REPLY = 2, OOM_SELF = 4 };

    mword oom_state = C ? OOM_SEND : OOM_REPLY;
c000a100:	80 7c 24 03 01       	cmpb   $0x1,0x3(%esp)
    if (EXPECT_FALSE (current == ec))
c000a105:	a1 08 f0 ff cf       	mov    0xcffff008,%eax

    Ec * const ec = dst_pt->ec;

    enum { OOM_SEND = 1, OOM_REPLY = 2, OOM_SELF = 4 };

    mword oom_state = C ? OOM_SEND : OOM_REPLY;
c000a10a:	19 d2                	sbb    %edx,%edx
c000a10c:	f7 d2                	not    %edx
    if (EXPECT_FALSE (current == ec))
        oom_state += OOM_SELF;
c000a10e:	8d 7a 06             	lea    0x6(%edx),%edi

    Ec * const ec = dst_pt->ec;

    enum { OOM_SEND = 1, OOM_REPLY = 2, OOM_SELF = 4 };

    mword oom_state = C ? OOM_SEND : OOM_REPLY;
c000a111:	83 c2 02             	add    $0x2,%edx
    if (EXPECT_FALSE (current == ec))
        oom_state += OOM_SELF;
c000a114:	39 d8                	cmp    %ebx,%eax
c000a116:	0f 44 d7             	cmove  %edi,%edx
c000a119:	0f b7 b8 cc 00 00 00 	movzwl 0xcc(%eax),%edi

    if (!C && current->cpu != ec->xcpu) {
c000a120:	80 7c 24 03 00       	cmpb   $0x0,0x3(%esp)
c000a125:	75 31                	jne    c000a158 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x1d6>
c000a127:	3b bb cc 00 00 00    	cmp    0xcc(%ebx),%edi
c000a12d:	74 29                	je     c000a158 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x1d6>
        assert (!current->partner);
c000a12f:	83 b8 bc 00 00 00 00 	cmpl   $0x0,0xbc(%eax)
c000a136:	74 16                	je     c000a14e <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x1cc>
c000a138:	68 80 87 01 c0       	push   $0xc0018780
c000a13d:	6a 45                	push   $0x45
c000a13f:	68 a3 72 01 c0       	push   $0xc00172a3
c000a144:	68 34 74 01 c0       	push   $0xc0017434
c000a149:	e9 0d 01 00 00       	jmp    c000a25b <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x2d9>
        current->oom_xcpu<Ec::sys_reply>(dst_pt, src_pd_id, oom_state);
c000a14e:	52                   	push   %edx
c000a14f:	8b 54 24 08          	mov    0x8(%esp),%edx
c000a153:	e8 b8 fb ff ff       	call   c0009d10 <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm>
    }

    if (EXPECT_FALSE (current->cpu != ec->xcpu) || (current->cont == xcpu_return) || (current->cont == ret_xcpu_reply))
c000a158:	3b bb cc 00 00 00    	cmp    0xcc(%ebx),%edi
c000a15e:	75 13                	jne    c000a173 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x1f1>
c000a160:	8b 78 50             	mov    0x50(%eax),%edi
c000a163:	81 ff 8e 40 00 c0    	cmp    $0xc000408e,%edi
c000a169:	74 08                	je     c000a173 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x1f1>
c000a16b:	81 ff 64 16 01 c0    	cmp    $0xc0011664,%edi
c000a171:	75 0d                	jne    c000a180 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x1fe>
        die ("PT wrong CPU - OOM");
c000a173:	8d 50 54             	lea    0x54(%eax),%edx
c000a176:	b8 46 74 01 c0       	mov    $0xc0017446,%eax
c000a17b:	e8 8c 99 ff ff       	call   c0003b0c <_ZN2Ec3dieEPKcP8Exc_regs>

    if (C && current != ec) {
c000a180:	80 7c 24 03 00       	cmpb   $0x0,0x3(%esp)
c000a185:	0f 84 8e 00 00 00    	je     c000a219 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x297>
c000a18b:	39 d8                	cmp    %ebx,%eax
c000a18d:	0f 84 f1 00 00 00    	je     c000a284 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x302>
        }

        ALWAYS_INLINE
        inline unsigned clr_partner()
        {
            assert (partner == current);
c000a193:	39 86 bc 00 00 00    	cmp    %eax,0xbc(%esi)
c000a199:	74 19                	je     c000a1b4 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x232>
c000a19b:	68 20 85 01 c0       	push   $0xc0018520
c000a1a0:	68 b2 00 00 00       	push   $0xb2
c000a1a5:	68 83 68 01 c0       	push   $0xc0016883
c000a1aa:	68 59 74 01 c0       	push   $0xc0017459
c000a1af:	e9 a7 00 00 00       	jmp    c000a25b <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x2d9>
            if (partner->rcap) {
c000a1b4:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
c000a1ba:	85 c0                	test   %eax,%eax
c000a1bc:	74 14                	je     c000a1d2 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x250>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c000a1be:	f0 ff 48 48          	lock decl 0x48(%eax)
                partner->rcap->del_ref();
                partner->rcap = nullptr;
c000a1c2:	8b 86 bc 00 00 00    	mov    0xbc(%esi),%eax
c000a1c8:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
c000a1cf:	00 00 00 
c000a1d2:	8b 86 bc 00 00 00    	mov    0xbc(%esi),%eax
c000a1d8:	f0 ff 48 48          	lock decl 0x48(%eax)
            }
            partner->del_ref();
            partner = nullptr;
            return Sc::ctr_link--;
c000a1dc:	a1 24 fa ff cf       	mov    0xcffffa24,%eax
c000a1e1:	8d 58 ff             	lea    -0x1(%eax),%ebx
        bool clr = rep_ec->clr_partner();
        assert(clr);
c000a1e4:	85 c0                	test   %eax,%eax
c000a1e6:	89 1d 24 fa ff cf    	mov    %ebx,0xcffffa24
            if (partner->rcap) {
                partner->rcap->del_ref();
                partner->rcap = nullptr;
            }
            partner->del_ref();
            partner = nullptr;
c000a1ec:	c7 86 bc 00 00 00 00 	movl   $0x0,0xbc(%esi)
c000a1f3:	00 00 00 
c000a1f6:	75 13                	jne    c000a20b <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x289>
c000a1f8:	68 80 87 01 c0       	push   $0xc0018780
c000a1fd:	6a 4e                	push   $0x4e
c000a1ff:	68 a3 72 01 c0       	push   $0xc00172a3
c000a204:	68 6c 74 01 c0       	push   $0xc001746c
c000a209:	eb 50                	jmp    c000a25b <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x2d9>

        /* current thread has no IPC relation to dst anymore */
        current->cont = nullptr;
c000a20b:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c000a210:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
c000a217:	eb 6b                	jmp    c000a284 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x302>
    }

    Ec * chg = C ? rep_ec : current;
    void (*c)() = C ? sys_call : sys_reply;
c000a219:	bb ae 04 00 c0       	mov    $0xc00004ae,%ebx

    chg->oom_call(dst_pt, src_pd_id, oom_state, c, c);
c000a21e:	53                   	push   %ebx
c000a21f:	53                   	push   %ebx
c000a220:	52                   	push   %edx
c000a221:	8b 54 24 10          	mov    0x10(%esp),%edx
c000a225:	e8 30 f6 ff ff       	call   c000985a <_ZN2Ec8oom_callEP2PtmmPFvvES3_>
    }

    if (user) {
        if (C) {
             assert (rep_ec->cont == ret_user_sysexit || rep_ec->cont == xcpu_return);
             assert (dst_ec->cont == recv_user);
c000a22a:	81 7a 50 56 04 00 c0 	cmpl   $0xc0000456,0x50(%edx)
c000a231:	0f 84 f3 fd ff ff    	je     c000a02a <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0xa8>
c000a237:	68 80 87 01 c0       	push   $0xc0018780
c000a23c:	6a 25                	push   $0x25
c000a23e:	68 a3 72 01 c0       	push   $0xc00172a3
c000a243:	68 fd 73 01 c0       	push   $0xc00173fd
c000a248:	eb 11                	jmp    c000a25b <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x2d9>
        } else 
             assert (dst_ec->cont == ret_user_sysexit || dst_ec->cont == xcpu_return);
c000a24a:	68 80 87 01 c0       	push   $0xc0018780
c000a24f:	6a 27                	push   $0x27
c000a251:	68 a3 72 01 c0       	push   $0xc00172a3
c000a256:	68 b0 74 01 c0       	push   $0xc00174b0
c000a25b:	68 69 60 01 c0       	push   $0xc0016069
c000a260:	e8 e1 76 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>
c000a265:	8b 45 4c             	mov    0x4c(%ebp),%eax
                continue;
            src_ec->pd->rev_crd (*s, false, false, false);
        }
    }

    mword src_pd_id = !src_pt ? ~0UL : 0;
c000a268:	31 c9                	xor    %ecx,%ecx
    if (src_pt && src_pt->ec->pd == dst_pt->ec->pd)
c000a26a:	8b bb b8 00 00 00    	mov    0xb8(%ebx),%edi
c000a270:	39 b8 b8 00 00 00    	cmp    %edi,0xb8(%eax)
c000a276:	0f 85 84 fe ff ff    	jne    c000a100 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x17e>
        src_pd_id = src_pt->id;
c000a27c:	8b 4d 58             	mov    0x58(%ebp),%ecx
c000a27f:	e9 7c fe ff ff       	jmp    c000a100 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x17e>
        /* current thread has no IPC relation to dst anymore */
        current->cont = nullptr;
    }

    Ec * chg = C ? rep_ec : current;
    void (*c)() = C ? sys_call : sys_reply;
c000a284:	89 f0                	mov    %esi,%eax
c000a286:	bb 70 06 00 c0       	mov    $0xc0000670,%ebx
c000a28b:	eb 91                	jmp    c000a21e <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x29c>
c000a28d:	90                   	nop

c000a28e <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm>:
    ec->regs.set_ip (pt->ip);
    ec->make_current();
}

template <void (*C)()>
void Ec::oom_xcpu(Pt * pt, mword src_pd_id, mword oom_state)
c000a28e:	55                   	push   %ebp
c000a28f:	57                   	push   %edi
c000a290:	56                   	push   %esi
c000a291:	53                   	push   %ebx
c000a292:	53                   	push   %ebx
{
    assert(current == this);
c000a293:	8b 35 08 f0 ff cf    	mov    0xcffff008,%esi
c000a299:	39 c6                	cmp    %eax,%esi
c000a29b:	74 13                	je     c000a2b0 <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x22>
c000a29d:	68 60 84 01 c0       	push   $0xc0018460
c000a2a2:	6a 72                	push   $0x72
c000a2a4:	68 a3 72 01 c0       	push   $0xc00172a3
c000a2a9:	68 bc 73 01 c0       	push   $0xc00173bc
c000a2ae:	eb 1a                	jmp    c000a2ca <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x3c>
    assert(!this->xcpu_sm);
c000a2b0:	83 be f4 00 00 00 00 	cmpl   $0x0,0xf4(%esi)
c000a2b7:	74 1b                	je     c000a2d4 <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x46>
c000a2b9:	68 60 84 01 c0       	push   $0xc0018460
c000a2be:	6a 73                	push   $0x73
c000a2c0:	68 a3 72 01 c0       	push   $0xc00172a3
c000a2c5:	68 cc 73 01 c0       	push   $0xc00173cc
c000a2ca:	68 69 60 01 c0       	push   $0xc0016069
c000a2cf:	e8 72 76 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

    enum { UNUSED = 0, CNT = 0 };

    this->xcpu_sm = new (Pd::current->quota) Sm (Pd::current, UNUSED, CNT);
c000a2d4:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c000a2d9:	89 d7                	mov    %edx,%edi
c000a2db:	89 cd                	mov    %ecx,%ebp
c000a2dd:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx

            call_rcu(true);
        }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
c000a2e3:	b8 b4 b4 01 c0       	mov    $0xc001b4b4,%eax
c000a2e8:	e8 89 5f 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c000a2ed:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c000a2f3:	31 c9                	xor    %ecx,%ecx
c000a2f5:	6a 00                	push   $0x0
c000a2f7:	6a 00                	push   $0x0
c000a2f9:	6a 00                	push   $0x0
c000a2fb:	89 c3                	mov    %eax,%ebx
c000a2fd:	e8 18 64 00 00       	call   c001071a <_ZN2SmC1EP2PdmmPS_m>
c000a302:	89 9e f4 00 00 00    	mov    %ebx,0xf4(%esi)

    Ec *xcpu_ec = new (Pd::current->quota) Ec (Pd::current, Pd::current, sys_xcpu_call_oom<C>, pt->ec->cpu, this);
c000a308:	8b 47 4c             	mov    0x4c(%edi),%eax
c000a30b:	0f b7 80 cc 00 00 00 	movzwl 0xcc(%eax),%eax
c000a312:	89 44 24 0c          	mov    %eax,0xc(%esp)
c000a316:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c000a31b:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx
        static void die (char const *, Exc_regs * = &current->regs);

        static void idl_handler();

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
c000a321:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c000a326:	e8 4b 5f 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c000a32b:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c000a331:	56                   	push   %esi
c000a332:	ff 74 24 10          	pushl  0x10(%esp)
c000a336:	89 d1                	mov    %edx,%ecx
c000a338:	68 ac 9a 00 c0       	push   $0xc0009aac
c000a33d:	89 c3                	mov    %eax,%ebx
c000a33f:	e8 46 90 ff ff       	call   c000338a <_ZN2EcC1EP2PdS1_PFvvEjPS_>
c000a344:	8b 44 24 30          	mov    0x30(%esp),%eax
c000a348:	89 7b 70             	mov    %edi,0x70(%ebx)
c000a34b:	89 6b 54             	mov    %ebp,0x54(%ebx)
c000a34e:	89 43 58             	mov    %eax,0x58(%ebx)
    xcpu_ec->regs.set_pt (reinterpret_cast<mword>(pt), src_pd_id, oom_state);

    Sc *xcpu_sc = new (Pd::current->quota) Sc (Pd::current, xcpu_ec, xcpu_ec->cpu, Sc::current);
c000a351:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c000a356:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx
c000a35c:	b8 98 b4 01 c0       	mov    $0xc001b498,%eax
c000a361:	e8 10 5f 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c000a366:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c000a36c:	89 d9                	mov    %ebx,%ecx
c000a36e:	ff 35 10 f0 ff cf    	pushl  0xcffff010
c000a374:	89 c7                	mov    %eax,%edi
c000a376:	0f b7 83 cc 00 00 00 	movzwl 0xcc(%ebx),%eax
c000a37d:	50                   	push   %eax
c000a37e:	89 f8                	mov    %edi,%eax
c000a380:	e8 09 51 00 00       	call   c000f48e <_ZN2ScC1EP2PdP2EcjPS_>

    xcpu_sc->remote_enqueue();
c000a385:	89 f8                	mov    %edi,%eax
c000a387:	83 c4 20             	add    $0x20,%esp
c000a38a:	e8 ad 53 00 00       	call   c000f73c <_ZN2Sc14remote_enqueueEv>
    this->xcpu_sm->dn (false, 0);
c000a38f:	8b b6 f4 00 00 00    	mov    0xf4(%esi),%esi
c000a395:	8b 1d 08 f0 ff cf    	mov    0xcffff008,%ebx
        }

        ALWAYS_INLINE
        inline void dn (bool zero, uint64 t, Ec *ec = Ec::current, bool block = true)
        {
            {   Lock_guard <Spinlock> guard (lock);
c000a39b:	8d 46 46             	lea    0x46(%esi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c000a39e:	9c                   	pushf  
c000a39f:	5a                   	pop    %edx
            return flags & 0x200;
c000a3a0:	c1 ea 09             	shr    $0x9,%edx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c000a3a3:	80 e2 01             	and    $0x1,%dl
c000a3a6:	74 2a                	je     c000a3d2 <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x144>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c000a3a8:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000a3af:	75 19                	jne    c000a3ca <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x13c>
c000a3b1:	68 80 85 01 c0       	push   $0xc0018580
c000a3b6:	68 b7 00 00 00       	push   $0xb7
c000a3bb:	68 12 61 01 c0       	push   $0xc0016112
c000a3c0:	68 83 61 01 c0       	push   $0xc0016183
c000a3c5:	e9 00 ff ff ff       	jmp    c000a2ca <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x3c>

            asm volatile ("cli" : : : "memory");
c000a3ca:	fa                   	cli    
            preemption = false;
c000a3cb:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
c000a3d2:	88 14 24             	mov    %dl,(%esp)
                Cpu::preempt_disable();

            _lock.lock();
c000a3d5:	e8 52 67 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>

                if (counter) {
c000a3da:	8b 46 64             	mov    0x64(%esi),%eax
c000a3dd:	8a 14 24             	mov    (%esp),%dl
c000a3e0:	85 c0                	test   %eax,%eax
c000a3e2:	74 76                	je     c000a45a <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x1cc>
                    counter = zero ? 0 : counter - 1;
c000a3e4:	48                   	dec    %eax
c000a3e5:	89 46 64             	mov    %eax,0x64(%esi)
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c000a3e8:	8b 46 50             	mov    0x50(%esi),%eax
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c000a3eb:	85 c0                	test   %eax,%eax
c000a3ed:	0f 84 da 00 00 00    	je     c000a4cd <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x23f>
c000a3f3:	8b 48 08             	mov    0x8(%eax),%ecx
c000a3f6:	85 c9                	test   %ecx,%ecx
c000a3f8:	0f 84 cf 00 00 00    	je     c000a4cd <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x23f>
c000a3fe:	8b 78 04             	mov    0x4(%eax),%edi
c000a401:	85 ff                	test   %edi,%edi
c000a403:	0f 84 c4 00 00 00    	je     c000a4cd <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x23f>
                return false;

            if (t == t->next)
c000a409:	39 c8                	cmp    %ecx,%eax
c000a40b:	75 09                	jne    c000a416 <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x188>
                headptr = nullptr;
c000a40d:	c7 46 50 00 00 00 00 	movl   $0x0,0x50(%esi)
c000a414:	eb 17                	jmp    c000a42d <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x19f>

            else {
                t->next->prev = t->prev;
c000a416:	89 79 04             	mov    %edi,0x4(%ecx)
                t->prev->next = t->next;
c000a419:	8b 48 04             	mov    0x4(%eax),%ecx
c000a41c:	8b 78 08             	mov    0x8(%eax),%edi
c000a41f:	89 79 08             	mov    %edi,0x8(%ecx)
                if (t == headptr)
c000a422:	3b 46 50             	cmp    0x50(%esi),%eax
c000a425:	75 06                	jne    c000a42d <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x19f>
                    headptr = t->next;
c000a427:	8b 48 08             	mov    0x8(%eax),%ecx
c000a42a:	89 4e 50             	mov    %ecx,0x50(%esi)

    public:

        mword reset(bool l = false) {
            if (l) lock.lock();
            mword c = counter;
c000a42d:	8b 48 10             	mov    0x10(%eax),%ecx
            }

            t->next = t->prev = nullptr;
c000a430:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
c000a437:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
            counter = 0;
c000a43e:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
                if (counter) {
                    counter = zero ? 0 : counter - 1;

                    Si * si;
                    if (Queue<Si>::dequeue(si = Queue<Si>::head()))
                        ec->set_si_regs(si->value, static_cast <Sm *>(si)->reset());
c000a445:	8b 40 0c             	mov    0xc(%eax),%eax

        ALWAYS_INLINE
        inline void set_si_regs(mword sig, mword cnt)
        {
            regs.ARG_2 = sig;
            regs.ARG_3 = cnt;
c000a448:	89 4b 58             	mov    %ecx,0x58(%ebx)
        }

        ALWAYS_INLINE
        inline void set_si_regs(mword sig, mword cnt)
        {
            regs.ARG_2 = sig;
c000a44b:	89 43 54             	mov    %eax,0x54(%ebx)
c000a44e:	eb 7d                	jmp    c000a4cd <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x23f>

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
                if (Atomic::cmp_swap (ref, r, r + 1))
c000a450:	8d 48 01             	lea    0x1(%eax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c000a453:	f0 0f b1 4b 48       	lock cmpxchg %ecx,0x48(%ebx)
c000a458:	74 07                	je     c000a461 <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x1d3>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c000a45a:	8b 43 48             	mov    0x48(%ebx),%eax
c000a45d:	85 c0                	test   %eax,%eax
c000a45f:	75 ef                	jne    c000a450 <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x1c2>
        inline T *head() const { return headptr; }

        ALWAYS_INLINE
        inline void enqueue (T *t)
        {
            if (!headptr)
c000a461:	8b 46 4c             	mov    0x4c(%esi),%eax
c000a464:	85 c0                	test   %eax,%eax
c000a466:	75 11                	jne    c000a479 <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x1eb>
                headptr = t->prev = t->next = t;
c000a468:	89 9b c4 00 00 00    	mov    %ebx,0xc4(%ebx)
c000a46e:	89 9b c0 00 00 00    	mov    %ebx,0xc0(%ebx)
c000a474:	89 5e 4c             	mov    %ebx,0x4c(%esi)
c000a477:	eb 21                	jmp    c000a49a <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x20c>
            else {
                t->next = headptr;
c000a479:	89 83 c4 00 00 00    	mov    %eax,0xc4(%ebx)
                t->prev = headptr->prev;
c000a47f:	8b 4e 4c             	mov    0x4c(%esi),%ecx
c000a482:	8b 89 c0 00 00 00    	mov    0xc0(%ecx),%ecx
c000a488:	89 8b c0 00 00 00    	mov    %ecx,0xc0(%ebx)
                t->next->prev = t->prev->next = t;
c000a48e:	89 99 c4 00 00 00    	mov    %ebx,0xc4(%ecx)
c000a494:	89 98 c0 00 00 00    	mov    %ebx,0xc0(%eax)
c000a49a:	fe 46 46             	incb   0x46(%esi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c000a49d:	84 d2                	test   %dl,%dl
c000a49f:	74 46                	je     c000a4e7 <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x259>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000a4a1:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000a4a8:	74 19                	je     c000a4c3 <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x235>
c000a4aa:	68 40 85 01 c0       	push   $0xc0018540
c000a4af:	68 c0 00 00 00       	push   $0xc0
c000a4b4:	68 12 61 01 c0       	push   $0xc0016112
c000a4b9:	68 82 61 01 c0       	push   $0xc0016182
c000a4be:	e9 07 fe ff ff       	jmp    c000a2ca <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x3c>

            preemption = true;
c000a4c3:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000a4ca:	fb                   	sti    
c000a4cb:	eb 1a                	jmp    c000a4e7 <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x259>
c000a4cd:	fe 46 46             	incb   0x46(%esi)
c000a4d0:	84 d2                	test   %dl,%dl
c000a4d2:	74 1a                	je     c000a4ee <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x260>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000a4d4:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000a4db:	75 cd                	jne    c000a4aa <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x21c>

            preemption = true;
c000a4dd:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000a4e4:	fb                   	sti    
c000a4e5:	eb 07                	jmp    c000a4ee <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x260>
            if (!block)
                Sc::schedule (false);

            ec->set_timeout (t, this);

            ec->block_sc();
c000a4e7:	89 d8                	mov    %ebx,%eax
c000a4e9:	e8 22 e0 ff ff       	call   c0008510 <_ZN2Ec8block_scEv>

    die ("XCPU OOM error");
c000a4ee:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c000a4f3:	8d 50 54             	lea    0x54(%eax),%edx
c000a4f6:	b8 db 73 01 c0       	mov    $0xc00173db,%eax
c000a4fb:	e8 0c 96 ff ff       	call   c0003b0c <_ZN2Ec3dieEPKcP8Exc_regs>

c000a500 <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm>:
    ec->regs.set_ip (pt->ip);
    ec->make_current();
}

template <void (*C)()>
void Ec::oom_xcpu(Pt * pt, mword src_pd_id, mword oom_state)
c000a500:	55                   	push   %ebp
c000a501:	57                   	push   %edi
c000a502:	56                   	push   %esi
c000a503:	53                   	push   %ebx
c000a504:	53                   	push   %ebx
{
    assert(current == this);
c000a505:	8b 35 08 f0 ff cf    	mov    0xcffff008,%esi
c000a50b:	39 c6                	cmp    %eax,%esi
c000a50d:	74 13                	je     c000a522 <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x22>
c000a50f:	68 a0 82 01 c0       	push   $0xc00182a0
c000a514:	6a 72                	push   $0x72
c000a516:	68 a3 72 01 c0       	push   $0xc00172a3
c000a51b:	68 bc 73 01 c0       	push   $0xc00173bc
c000a520:	eb 1a                	jmp    c000a53c <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x3c>
    assert(!this->xcpu_sm);
c000a522:	83 be f4 00 00 00 00 	cmpl   $0x0,0xf4(%esi)
c000a529:	74 1b                	je     c000a546 <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x46>
c000a52b:	68 a0 82 01 c0       	push   $0xc00182a0
c000a530:	6a 73                	push   $0x73
c000a532:	68 a3 72 01 c0       	push   $0xc00172a3
c000a537:	68 cc 73 01 c0       	push   $0xc00173cc
c000a53c:	68 69 60 01 c0       	push   $0xc0016069
c000a541:	e8 00 74 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

    enum { UNUSED = 0, CNT = 0 };

    this->xcpu_sm = new (Pd::current->quota) Sm (Pd::current, UNUSED, CNT);
c000a546:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c000a54b:	89 d7                	mov    %edx,%edi
c000a54d:	89 cd                	mov    %ecx,%ebp
c000a54f:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx

            call_rcu(true);
        }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
c000a555:	b8 b4 b4 01 c0       	mov    $0xc001b4b4,%eax
c000a55a:	e8 17 5d 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c000a55f:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c000a565:	31 c9                	xor    %ecx,%ecx
c000a567:	6a 00                	push   $0x0
c000a569:	6a 00                	push   $0x0
c000a56b:	6a 00                	push   $0x0
c000a56d:	89 c3                	mov    %eax,%ebx
c000a56f:	e8 a6 61 00 00       	call   c001071a <_ZN2SmC1EP2PdmmPS_m>
c000a574:	89 9e f4 00 00 00    	mov    %ebx,0xf4(%esi)

    Ec *xcpu_ec = new (Pd::current->quota) Ec (Pd::current, Pd::current, sys_xcpu_call_oom<C>, pt->ec->cpu, this);
c000a57a:	8b 47 4c             	mov    0x4c(%edi),%eax
c000a57d:	0f b7 80 cc 00 00 00 	movzwl 0xcc(%eax),%eax
c000a584:	89 44 24 0c          	mov    %eax,0xc(%esp)
c000a588:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c000a58d:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx
        static void die (char const *, Exc_regs * = &current->regs);

        static void idl_handler();

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
c000a593:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c000a598:	e8 d9 5c 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c000a59d:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c000a5a3:	56                   	push   %esi
c000a5a4:	ff 74 24 10          	pushl  0x10(%esp)
c000a5a8:	89 d1                	mov    %edx,%ecx
c000a5aa:	68 f0 9a 00 c0       	push   $0xc0009af0
c000a5af:	89 c3                	mov    %eax,%ebx
c000a5b1:	e8 d4 8d ff ff       	call   c000338a <_ZN2EcC1EP2PdS1_PFvvEjPS_>
c000a5b6:	8b 44 24 30          	mov    0x30(%esp),%eax
c000a5ba:	89 7b 70             	mov    %edi,0x70(%ebx)
c000a5bd:	89 6b 54             	mov    %ebp,0x54(%ebx)
c000a5c0:	89 43 58             	mov    %eax,0x58(%ebx)
    xcpu_ec->regs.set_pt (reinterpret_cast<mword>(pt), src_pd_id, oom_state);

    Sc *xcpu_sc = new (Pd::current->quota) Sc (Pd::current, xcpu_ec, xcpu_ec->cpu, Sc::current);
c000a5c3:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c000a5c8:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx
c000a5ce:	b8 98 b4 01 c0       	mov    $0xc001b498,%eax
c000a5d3:	e8 9e 5c 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c000a5d8:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c000a5de:	89 d9                	mov    %ebx,%ecx
c000a5e0:	ff 35 10 f0 ff cf    	pushl  0xcffff010
c000a5e6:	89 c7                	mov    %eax,%edi
c000a5e8:	0f b7 83 cc 00 00 00 	movzwl 0xcc(%ebx),%eax
c000a5ef:	50                   	push   %eax
c000a5f0:	89 f8                	mov    %edi,%eax
c000a5f2:	e8 97 4e 00 00       	call   c000f48e <_ZN2ScC1EP2PdP2EcjPS_>

    xcpu_sc->remote_enqueue();
c000a5f7:	89 f8                	mov    %edi,%eax
c000a5f9:	83 c4 20             	add    $0x20,%esp
c000a5fc:	e8 3b 51 00 00       	call   c000f73c <_ZN2Sc14remote_enqueueEv>
    this->xcpu_sm->dn (false, 0);
c000a601:	8b b6 f4 00 00 00    	mov    0xf4(%esi),%esi
c000a607:	8b 1d 08 f0 ff cf    	mov    0xcffff008,%ebx
        }

        ALWAYS_INLINE
        inline void dn (bool zero, uint64 t, Ec *ec = Ec::current, bool block = true)
        {
            {   Lock_guard <Spinlock> guard (lock);
c000a60d:	8d 46 46             	lea    0x46(%esi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c000a610:	9c                   	pushf  
c000a611:	5a                   	pop    %edx
            return flags & 0x200;
c000a612:	c1 ea 09             	shr    $0x9,%edx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c000a615:	80 e2 01             	and    $0x1,%dl
c000a618:	74 2a                	je     c000a644 <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x144>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c000a61a:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000a621:	75 19                	jne    c000a63c <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x13c>
c000a623:	68 80 85 01 c0       	push   $0xc0018580
c000a628:	68 b7 00 00 00       	push   $0xb7
c000a62d:	68 12 61 01 c0       	push   $0xc0016112
c000a632:	68 83 61 01 c0       	push   $0xc0016183
c000a637:	e9 00 ff ff ff       	jmp    c000a53c <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x3c>

            asm volatile ("cli" : : : "memory");
c000a63c:	fa                   	cli    
            preemption = false;
c000a63d:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
c000a644:	88 14 24             	mov    %dl,(%esp)
                Cpu::preempt_disable();

            _lock.lock();
c000a647:	e8 e0 64 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>

                if (counter) {
c000a64c:	8b 46 64             	mov    0x64(%esi),%eax
c000a64f:	8a 14 24             	mov    (%esp),%dl
c000a652:	85 c0                	test   %eax,%eax
c000a654:	74 76                	je     c000a6cc <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x1cc>
                    counter = zero ? 0 : counter - 1;
c000a656:	48                   	dec    %eax
c000a657:	89 46 64             	mov    %eax,0x64(%esi)
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c000a65a:	8b 46 50             	mov    0x50(%esi),%eax
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c000a65d:	85 c0                	test   %eax,%eax
c000a65f:	0f 84 da 00 00 00    	je     c000a73f <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x23f>
c000a665:	8b 48 08             	mov    0x8(%eax),%ecx
c000a668:	85 c9                	test   %ecx,%ecx
c000a66a:	0f 84 cf 00 00 00    	je     c000a73f <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x23f>
c000a670:	8b 78 04             	mov    0x4(%eax),%edi
c000a673:	85 ff                	test   %edi,%edi
c000a675:	0f 84 c4 00 00 00    	je     c000a73f <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x23f>
                return false;

            if (t == t->next)
c000a67b:	39 c8                	cmp    %ecx,%eax
c000a67d:	75 09                	jne    c000a688 <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x188>
                headptr = nullptr;
c000a67f:	c7 46 50 00 00 00 00 	movl   $0x0,0x50(%esi)
c000a686:	eb 17                	jmp    c000a69f <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x19f>

            else {
                t->next->prev = t->prev;
c000a688:	89 79 04             	mov    %edi,0x4(%ecx)
                t->prev->next = t->next;
c000a68b:	8b 48 04             	mov    0x4(%eax),%ecx
c000a68e:	8b 78 08             	mov    0x8(%eax),%edi
c000a691:	89 79 08             	mov    %edi,0x8(%ecx)
                if (t == headptr)
c000a694:	3b 46 50             	cmp    0x50(%esi),%eax
c000a697:	75 06                	jne    c000a69f <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x19f>
                    headptr = t->next;
c000a699:	8b 48 08             	mov    0x8(%eax),%ecx
c000a69c:	89 4e 50             	mov    %ecx,0x50(%esi)

    public:

        mword reset(bool l = false) {
            if (l) lock.lock();
            mword c = counter;
c000a69f:	8b 48 10             	mov    0x10(%eax),%ecx
            }

            t->next = t->prev = nullptr;
c000a6a2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
c000a6a9:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
            counter = 0;
c000a6b0:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
                if (counter) {
                    counter = zero ? 0 : counter - 1;

                    Si * si;
                    if (Queue<Si>::dequeue(si = Queue<Si>::head()))
                        ec->set_si_regs(si->value, static_cast <Sm *>(si)->reset());
c000a6b7:	8b 40 0c             	mov    0xc(%eax),%eax

        ALWAYS_INLINE
        inline void set_si_regs(mword sig, mword cnt)
        {
            regs.ARG_2 = sig;
            regs.ARG_3 = cnt;
c000a6ba:	89 4b 58             	mov    %ecx,0x58(%ebx)
        }

        ALWAYS_INLINE
        inline void set_si_regs(mword sig, mword cnt)
        {
            regs.ARG_2 = sig;
c000a6bd:	89 43 54             	mov    %eax,0x54(%ebx)
c000a6c0:	eb 7d                	jmp    c000a73f <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x23f>
                if (Atomic::cmp_swap (ref, r, r + 1))
c000a6c2:	8d 48 01             	lea    0x1(%eax),%ecx
c000a6c5:	f0 0f b1 4b 48       	lock cmpxchg %ecx,0x48(%ebx)
c000a6ca:	74 07                	je     c000a6d3 <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x1d3>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c000a6cc:	8b 43 48             	mov    0x48(%ebx),%eax
c000a6cf:	85 c0                	test   %eax,%eax
c000a6d1:	75 ef                	jne    c000a6c2 <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x1c2>
        inline T *head() const { return headptr; }

        ALWAYS_INLINE
        inline void enqueue (T *t)
        {
            if (!headptr)
c000a6d3:	8b 46 4c             	mov    0x4c(%esi),%eax
c000a6d6:	85 c0                	test   %eax,%eax
c000a6d8:	75 11                	jne    c000a6eb <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x1eb>
                headptr = t->prev = t->next = t;
c000a6da:	89 9b c4 00 00 00    	mov    %ebx,0xc4(%ebx)
c000a6e0:	89 9b c0 00 00 00    	mov    %ebx,0xc0(%ebx)
c000a6e6:	89 5e 4c             	mov    %ebx,0x4c(%esi)
c000a6e9:	eb 21                	jmp    c000a70c <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x20c>
            else {
                t->next = headptr;
c000a6eb:	89 83 c4 00 00 00    	mov    %eax,0xc4(%ebx)
                t->prev = headptr->prev;
c000a6f1:	8b 4e 4c             	mov    0x4c(%esi),%ecx
c000a6f4:	8b 89 c0 00 00 00    	mov    0xc0(%ecx),%ecx
c000a6fa:	89 8b c0 00 00 00    	mov    %ecx,0xc0(%ebx)
                t->next->prev = t->prev->next = t;
c000a700:	89 99 c4 00 00 00    	mov    %ebx,0xc4(%ecx)
c000a706:	89 98 c0 00 00 00    	mov    %ebx,0xc0(%eax)
c000a70c:	fe 46 46             	incb   0x46(%esi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c000a70f:	84 d2                	test   %dl,%dl
c000a711:	74 46                	je     c000a759 <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x259>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000a713:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000a71a:	74 19                	je     c000a735 <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x235>
c000a71c:	68 40 85 01 c0       	push   $0xc0018540
c000a721:	68 c0 00 00 00       	push   $0xc0
c000a726:	68 12 61 01 c0       	push   $0xc0016112
c000a72b:	68 82 61 01 c0       	push   $0xc0016182
c000a730:	e9 07 fe ff ff       	jmp    c000a53c <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x3c>

            preemption = true;
c000a735:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000a73c:	fb                   	sti    
c000a73d:	eb 1a                	jmp    c000a759 <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x259>
c000a73f:	fe 46 46             	incb   0x46(%esi)
c000a742:	84 d2                	test   %dl,%dl
c000a744:	74 1a                	je     c000a760 <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x260>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000a746:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000a74d:	75 cd                	jne    c000a71c <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x21c>

            preemption = true;
c000a74f:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000a756:	fb                   	sti    
c000a757:	eb 07                	jmp    c000a760 <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x260>
            if (!block)
                Sc::schedule (false);

            ec->set_timeout (t, this);

            ec->block_sc();
c000a759:	89 d8                	mov    %ebx,%eax
c000a75b:	e8 b0 dd ff ff       	call   c0008510 <_ZN2Ec8block_scEv>

    die ("XCPU OOM error");
c000a760:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c000a765:	8d 50 54             	lea    0x54(%eax),%edx
c000a768:	b8 db 73 01 c0       	mov    $0xc00173db,%eax
c000a76d:	e8 9a 93 ff ff       	call   c0003b0c <_ZN2Ec3dieEPKcP8Exc_regs>

c000a772 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm>:
    ec->regs.set_ip (pt->ip);
    ec->make_current();
}

template <void (*C)()>
void Ec::oom_xcpu(Pt * pt, mword src_pd_id, mword oom_state)
c000a772:	55                   	push   %ebp
c000a773:	57                   	push   %edi
c000a774:	56                   	push   %esi
c000a775:	53                   	push   %ebx
c000a776:	53                   	push   %ebx
{
    assert(current == this);
c000a777:	8b 35 08 f0 ff cf    	mov    0xcffff008,%esi
c000a77d:	39 c6                	cmp    %eax,%esi
c000a77f:	74 13                	je     c000a794 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x22>
c000a781:	68 e0 80 01 c0       	push   $0xc00180e0
c000a786:	6a 72                	push   $0x72
c000a788:	68 a3 72 01 c0       	push   $0xc00172a3
c000a78d:	68 bc 73 01 c0       	push   $0xc00173bc
c000a792:	eb 1a                	jmp    c000a7ae <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x3c>
    assert(!this->xcpu_sm);
c000a794:	83 be f4 00 00 00 00 	cmpl   $0x0,0xf4(%esi)
c000a79b:	74 1b                	je     c000a7b8 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x46>
c000a79d:	68 e0 80 01 c0       	push   $0xc00180e0
c000a7a2:	6a 73                	push   $0x73
c000a7a4:	68 a3 72 01 c0       	push   $0xc00172a3
c000a7a9:	68 cc 73 01 c0       	push   $0xc00173cc
c000a7ae:	68 69 60 01 c0       	push   $0xc0016069
c000a7b3:	e8 8e 71 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

    enum { UNUSED = 0, CNT = 0 };

    this->xcpu_sm = new (Pd::current->quota) Sm (Pd::current, UNUSED, CNT);
c000a7b8:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c000a7bd:	89 d7                	mov    %edx,%edi
c000a7bf:	89 cd                	mov    %ecx,%ebp
c000a7c1:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx

            call_rcu(true);
        }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
c000a7c7:	b8 b4 b4 01 c0       	mov    $0xc001b4b4,%eax
c000a7cc:	e8 a5 5a 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c000a7d1:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c000a7d7:	31 c9                	xor    %ecx,%ecx
c000a7d9:	6a 00                	push   $0x0
c000a7db:	6a 00                	push   $0x0
c000a7dd:	6a 00                	push   $0x0
c000a7df:	89 c3                	mov    %eax,%ebx
c000a7e1:	e8 34 5f 00 00       	call   c001071a <_ZN2SmC1EP2PdmmPS_m>
c000a7e6:	89 9e f4 00 00 00    	mov    %ebx,0xf4(%esi)

    Ec *xcpu_ec = new (Pd::current->quota) Ec (Pd::current, Pd::current, sys_xcpu_call_oom<C>, pt->ec->cpu, this);
c000a7ec:	8b 47 4c             	mov    0x4c(%edi),%eax
c000a7ef:	0f b7 80 cc 00 00 00 	movzwl 0xcc(%eax),%eax
c000a7f6:	89 44 24 0c          	mov    %eax,0xc(%esp)
c000a7fa:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c000a7ff:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx
        static void die (char const *, Exc_regs * = &current->regs);

        static void idl_handler();

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
c000a805:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c000a80a:	e8 67 5a 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c000a80f:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c000a815:	56                   	push   %esi
c000a816:	ff 74 24 10          	pushl  0x10(%esp)
c000a81a:	89 d1                	mov    %edx,%ecx
c000a81c:	68 34 9b 00 c0       	push   $0xc0009b34
c000a821:	89 c3                	mov    %eax,%ebx
c000a823:	e8 62 8b ff ff       	call   c000338a <_ZN2EcC1EP2PdS1_PFvvEjPS_>
c000a828:	8b 44 24 30          	mov    0x30(%esp),%eax
c000a82c:	89 7b 70             	mov    %edi,0x70(%ebx)
c000a82f:	89 6b 54             	mov    %ebp,0x54(%ebx)
c000a832:	89 43 58             	mov    %eax,0x58(%ebx)
    xcpu_ec->regs.set_pt (reinterpret_cast<mword>(pt), src_pd_id, oom_state);

    Sc *xcpu_sc = new (Pd::current->quota) Sc (Pd::current, xcpu_ec, xcpu_ec->cpu, Sc::current);
c000a835:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c000a83a:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx
c000a840:	b8 98 b4 01 c0       	mov    $0xc001b498,%eax
c000a845:	e8 2c 5a 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c000a84a:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c000a850:	89 d9                	mov    %ebx,%ecx
c000a852:	ff 35 10 f0 ff cf    	pushl  0xcffff010
c000a858:	89 c7                	mov    %eax,%edi
c000a85a:	0f b7 83 cc 00 00 00 	movzwl 0xcc(%ebx),%eax
c000a861:	50                   	push   %eax
c000a862:	89 f8                	mov    %edi,%eax
c000a864:	e8 25 4c 00 00       	call   c000f48e <_ZN2ScC1EP2PdP2EcjPS_>

    xcpu_sc->remote_enqueue();
c000a869:	89 f8                	mov    %edi,%eax
c000a86b:	83 c4 20             	add    $0x20,%esp
c000a86e:	e8 c9 4e 00 00       	call   c000f73c <_ZN2Sc14remote_enqueueEv>
    this->xcpu_sm->dn (false, 0);
c000a873:	8b b6 f4 00 00 00    	mov    0xf4(%esi),%esi
c000a879:	8b 1d 08 f0 ff cf    	mov    0xcffff008,%ebx
        }

        ALWAYS_INLINE
        inline void dn (bool zero, uint64 t, Ec *ec = Ec::current, bool block = true)
        {
            {   Lock_guard <Spinlock> guard (lock);
c000a87f:	8d 46 46             	lea    0x46(%esi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c000a882:	9c                   	pushf  
c000a883:	5a                   	pop    %edx
            return flags & 0x200;
c000a884:	c1 ea 09             	shr    $0x9,%edx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c000a887:	80 e2 01             	and    $0x1,%dl
c000a88a:	74 2a                	je     c000a8b6 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x144>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c000a88c:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000a893:	75 19                	jne    c000a8ae <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x13c>
c000a895:	68 80 85 01 c0       	push   $0xc0018580
c000a89a:	68 b7 00 00 00       	push   $0xb7
c000a89f:	68 12 61 01 c0       	push   $0xc0016112
c000a8a4:	68 83 61 01 c0       	push   $0xc0016183
c000a8a9:	e9 00 ff ff ff       	jmp    c000a7ae <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x3c>

            asm volatile ("cli" : : : "memory");
c000a8ae:	fa                   	cli    
            preemption = false;
c000a8af:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
c000a8b6:	88 14 24             	mov    %dl,(%esp)
                Cpu::preempt_disable();

            _lock.lock();
c000a8b9:	e8 6e 62 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>

                if (counter) {
c000a8be:	8b 46 64             	mov    0x64(%esi),%eax
c000a8c1:	8a 14 24             	mov    (%esp),%dl
c000a8c4:	85 c0                	test   %eax,%eax
c000a8c6:	74 76                	je     c000a93e <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x1cc>
                    counter = zero ? 0 : counter - 1;
c000a8c8:	48                   	dec    %eax
c000a8c9:	89 46 64             	mov    %eax,0x64(%esi)
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c000a8cc:	8b 46 50             	mov    0x50(%esi),%eax
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c000a8cf:	85 c0                	test   %eax,%eax
c000a8d1:	0f 84 da 00 00 00    	je     c000a9b1 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x23f>
c000a8d7:	8b 48 08             	mov    0x8(%eax),%ecx
c000a8da:	85 c9                	test   %ecx,%ecx
c000a8dc:	0f 84 cf 00 00 00    	je     c000a9b1 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x23f>
c000a8e2:	8b 78 04             	mov    0x4(%eax),%edi
c000a8e5:	85 ff                	test   %edi,%edi
c000a8e7:	0f 84 c4 00 00 00    	je     c000a9b1 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x23f>
                return false;

            if (t == t->next)
c000a8ed:	39 c8                	cmp    %ecx,%eax
c000a8ef:	75 09                	jne    c000a8fa <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x188>
                headptr = nullptr;
c000a8f1:	c7 46 50 00 00 00 00 	movl   $0x0,0x50(%esi)
c000a8f8:	eb 17                	jmp    c000a911 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x19f>

            else {
                t->next->prev = t->prev;
c000a8fa:	89 79 04             	mov    %edi,0x4(%ecx)
                t->prev->next = t->next;
c000a8fd:	8b 48 04             	mov    0x4(%eax),%ecx
c000a900:	8b 78 08             	mov    0x8(%eax),%edi
c000a903:	89 79 08             	mov    %edi,0x8(%ecx)
                if (t == headptr)
c000a906:	3b 46 50             	cmp    0x50(%esi),%eax
c000a909:	75 06                	jne    c000a911 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x19f>
                    headptr = t->next;
c000a90b:	8b 48 08             	mov    0x8(%eax),%ecx
c000a90e:	89 4e 50             	mov    %ecx,0x50(%esi)

    public:

        mword reset(bool l = false) {
            if (l) lock.lock();
            mword c = counter;
c000a911:	8b 48 10             	mov    0x10(%eax),%ecx
            }

            t->next = t->prev = nullptr;
c000a914:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
c000a91b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
            counter = 0;
c000a922:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
                if (counter) {
                    counter = zero ? 0 : counter - 1;

                    Si * si;
                    if (Queue<Si>::dequeue(si = Queue<Si>::head()))
                        ec->set_si_regs(si->value, static_cast <Sm *>(si)->reset());
c000a929:	8b 40 0c             	mov    0xc(%eax),%eax

        ALWAYS_INLINE
        inline void set_si_regs(mword sig, mword cnt)
        {
            regs.ARG_2 = sig;
            regs.ARG_3 = cnt;
c000a92c:	89 4b 58             	mov    %ecx,0x58(%ebx)
        }

        ALWAYS_INLINE
        inline void set_si_regs(mword sig, mword cnt)
        {
            regs.ARG_2 = sig;
c000a92f:	89 43 54             	mov    %eax,0x54(%ebx)
c000a932:	eb 7d                	jmp    c000a9b1 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x23f>
                if (Atomic::cmp_swap (ref, r, r + 1))
c000a934:	8d 48 01             	lea    0x1(%eax),%ecx
c000a937:	f0 0f b1 4b 48       	lock cmpxchg %ecx,0x48(%ebx)
c000a93c:	74 07                	je     c000a945 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x1d3>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c000a93e:	8b 43 48             	mov    0x48(%ebx),%eax
c000a941:	85 c0                	test   %eax,%eax
c000a943:	75 ef                	jne    c000a934 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x1c2>
        inline T *head() const { return headptr; }

        ALWAYS_INLINE
        inline void enqueue (T *t)
        {
            if (!headptr)
c000a945:	8b 46 4c             	mov    0x4c(%esi),%eax
c000a948:	85 c0                	test   %eax,%eax
c000a94a:	75 11                	jne    c000a95d <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x1eb>
                headptr = t->prev = t->next = t;
c000a94c:	89 9b c4 00 00 00    	mov    %ebx,0xc4(%ebx)
c000a952:	89 9b c0 00 00 00    	mov    %ebx,0xc0(%ebx)
c000a958:	89 5e 4c             	mov    %ebx,0x4c(%esi)
c000a95b:	eb 21                	jmp    c000a97e <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x20c>
            else {
                t->next = headptr;
c000a95d:	89 83 c4 00 00 00    	mov    %eax,0xc4(%ebx)
                t->prev = headptr->prev;
c000a963:	8b 4e 4c             	mov    0x4c(%esi),%ecx
c000a966:	8b 89 c0 00 00 00    	mov    0xc0(%ecx),%ecx
c000a96c:	89 8b c0 00 00 00    	mov    %ecx,0xc0(%ebx)
                t->next->prev = t->prev->next = t;
c000a972:	89 99 c4 00 00 00    	mov    %ebx,0xc4(%ecx)
c000a978:	89 98 c0 00 00 00    	mov    %ebx,0xc0(%eax)
c000a97e:	fe 46 46             	incb   0x46(%esi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c000a981:	84 d2                	test   %dl,%dl
c000a983:	74 46                	je     c000a9cb <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x259>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000a985:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000a98c:	74 19                	je     c000a9a7 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x235>
c000a98e:	68 40 85 01 c0       	push   $0xc0018540
c000a993:	68 c0 00 00 00       	push   $0xc0
c000a998:	68 12 61 01 c0       	push   $0xc0016112
c000a99d:	68 82 61 01 c0       	push   $0xc0016182
c000a9a2:	e9 07 fe ff ff       	jmp    c000a7ae <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x3c>

            preemption = true;
c000a9a7:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000a9ae:	fb                   	sti    
c000a9af:	eb 1a                	jmp    c000a9cb <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x259>
c000a9b1:	fe 46 46             	incb   0x46(%esi)
c000a9b4:	84 d2                	test   %dl,%dl
c000a9b6:	74 1a                	je     c000a9d2 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x260>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000a9b8:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000a9bf:	75 cd                	jne    c000a98e <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x21c>

            preemption = true;
c000a9c1:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000a9c8:	fb                   	sti    
c000a9c9:	eb 07                	jmp    c000a9d2 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x260>
            if (!block)
                Sc::schedule (false);

            ec->set_timeout (t, this);

            ec->block_sc();
c000a9cb:	89 d8                	mov    %ebx,%eax
c000a9cd:	e8 3e db ff ff       	call   c0008510 <_ZN2Ec8block_scEv>

    die ("XCPU OOM error");
c000a9d2:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c000a9d7:	8d 50 54             	lea    0x54(%eax),%edx
c000a9da:	b8 db 73 01 c0       	mov    $0xc00173db,%eax
c000a9df:	e8 28 91 ff ff       	call   c0003b0c <_ZN2Ec3dieEPKcP8Exc_regs>

c000a9e4 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm>:
    ec->regs.set_ip (pt->ip);
    ec->make_current();
}

template <void (*C)()>
void Ec::oom_xcpu(Pt * pt, mword src_pd_id, mword oom_state)
c000a9e4:	55                   	push   %ebp
c000a9e5:	57                   	push   %edi
c000a9e6:	56                   	push   %esi
c000a9e7:	53                   	push   %ebx
c000a9e8:	53                   	push   %ebx
{
    assert(current == this);
c000a9e9:	8b 35 08 f0 ff cf    	mov    0xcffff008,%esi
c000a9ef:	39 c6                	cmp    %eax,%esi
c000a9f1:	74 13                	je     c000aa06 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x22>
c000a9f3:	68 20 7f 01 c0       	push   $0xc0017f20
c000a9f8:	6a 72                	push   $0x72
c000a9fa:	68 a3 72 01 c0       	push   $0xc00172a3
c000a9ff:	68 bc 73 01 c0       	push   $0xc00173bc
c000aa04:	eb 1a                	jmp    c000aa20 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x3c>
    assert(!this->xcpu_sm);
c000aa06:	83 be f4 00 00 00 00 	cmpl   $0x0,0xf4(%esi)
c000aa0d:	74 1b                	je     c000aa2a <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x46>
c000aa0f:	68 20 7f 01 c0       	push   $0xc0017f20
c000aa14:	6a 73                	push   $0x73
c000aa16:	68 a3 72 01 c0       	push   $0xc00172a3
c000aa1b:	68 cc 73 01 c0       	push   $0xc00173cc
c000aa20:	68 69 60 01 c0       	push   $0xc0016069
c000aa25:	e8 1c 6f ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

    enum { UNUSED = 0, CNT = 0 };

    this->xcpu_sm = new (Pd::current->quota) Sm (Pd::current, UNUSED, CNT);
c000aa2a:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c000aa2f:	89 d7                	mov    %edx,%edi
c000aa31:	89 cd                	mov    %ecx,%ebp
c000aa33:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx

            call_rcu(true);
        }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
c000aa39:	b8 b4 b4 01 c0       	mov    $0xc001b4b4,%eax
c000aa3e:	e8 33 58 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c000aa43:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c000aa49:	31 c9                	xor    %ecx,%ecx
c000aa4b:	6a 00                	push   $0x0
c000aa4d:	6a 00                	push   $0x0
c000aa4f:	6a 00                	push   $0x0
c000aa51:	89 c3                	mov    %eax,%ebx
c000aa53:	e8 c2 5c 00 00       	call   c001071a <_ZN2SmC1EP2PdmmPS_m>
c000aa58:	89 9e f4 00 00 00    	mov    %ebx,0xf4(%esi)

    Ec *xcpu_ec = new (Pd::current->quota) Ec (Pd::current, Pd::current, sys_xcpu_call_oom<C>, pt->ec->cpu, this);
c000aa5e:	8b 47 4c             	mov    0x4c(%edi),%eax
c000aa61:	0f b7 80 cc 00 00 00 	movzwl 0xcc(%eax),%eax
c000aa68:	89 44 24 0c          	mov    %eax,0xc(%esp)
c000aa6c:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c000aa71:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx
        static void die (char const *, Exc_regs * = &current->regs);

        static void idl_handler();

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
c000aa77:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c000aa7c:	e8 f5 57 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c000aa81:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c000aa87:	56                   	push   %esi
c000aa88:	ff 74 24 10          	pushl  0x10(%esp)
c000aa8c:	89 d1                	mov    %edx,%ecx
c000aa8e:	68 78 9b 00 c0       	push   $0xc0009b78
c000aa93:	89 c3                	mov    %eax,%ebx
c000aa95:	e8 f0 88 ff ff       	call   c000338a <_ZN2EcC1EP2PdS1_PFvvEjPS_>
c000aa9a:	8b 44 24 30          	mov    0x30(%esp),%eax
c000aa9e:	89 7b 70             	mov    %edi,0x70(%ebx)
c000aaa1:	89 6b 54             	mov    %ebp,0x54(%ebx)
c000aaa4:	89 43 58             	mov    %eax,0x58(%ebx)
    xcpu_ec->regs.set_pt (reinterpret_cast<mword>(pt), src_pd_id, oom_state);

    Sc *xcpu_sc = new (Pd::current->quota) Sc (Pd::current, xcpu_ec, xcpu_ec->cpu, Sc::current);
c000aaa7:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c000aaac:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx
c000aab2:	b8 98 b4 01 c0       	mov    $0xc001b498,%eax
c000aab7:	e8 ba 57 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c000aabc:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c000aac2:	89 d9                	mov    %ebx,%ecx
c000aac4:	ff 35 10 f0 ff cf    	pushl  0xcffff010
c000aaca:	89 c7                	mov    %eax,%edi
c000aacc:	0f b7 83 cc 00 00 00 	movzwl 0xcc(%ebx),%eax
c000aad3:	50                   	push   %eax
c000aad4:	89 f8                	mov    %edi,%eax
c000aad6:	e8 b3 49 00 00       	call   c000f48e <_ZN2ScC1EP2PdP2EcjPS_>

    xcpu_sc->remote_enqueue();
c000aadb:	89 f8                	mov    %edi,%eax
c000aadd:	83 c4 20             	add    $0x20,%esp
c000aae0:	e8 57 4c 00 00       	call   c000f73c <_ZN2Sc14remote_enqueueEv>
    this->xcpu_sm->dn (false, 0);
c000aae5:	8b b6 f4 00 00 00    	mov    0xf4(%esi),%esi
c000aaeb:	8b 1d 08 f0 ff cf    	mov    0xcffff008,%ebx
        }

        ALWAYS_INLINE
        inline void dn (bool zero, uint64 t, Ec *ec = Ec::current, bool block = true)
        {
            {   Lock_guard <Spinlock> guard (lock);
c000aaf1:	8d 46 46             	lea    0x46(%esi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c000aaf4:	9c                   	pushf  
c000aaf5:	5a                   	pop    %edx
            return flags & 0x200;
c000aaf6:	c1 ea 09             	shr    $0x9,%edx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c000aaf9:	80 e2 01             	and    $0x1,%dl
c000aafc:	74 2a                	je     c000ab28 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x144>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c000aafe:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000ab05:	75 19                	jne    c000ab20 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x13c>
c000ab07:	68 80 85 01 c0       	push   $0xc0018580
c000ab0c:	68 b7 00 00 00       	push   $0xb7
c000ab11:	68 12 61 01 c0       	push   $0xc0016112
c000ab16:	68 83 61 01 c0       	push   $0xc0016183
c000ab1b:	e9 00 ff ff ff       	jmp    c000aa20 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x3c>

            asm volatile ("cli" : : : "memory");
c000ab20:	fa                   	cli    
            preemption = false;
c000ab21:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
c000ab28:	88 14 24             	mov    %dl,(%esp)
                Cpu::preempt_disable();

            _lock.lock();
c000ab2b:	e8 fc 5f ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>

                if (counter) {
c000ab30:	8b 46 64             	mov    0x64(%esi),%eax
c000ab33:	8a 14 24             	mov    (%esp),%dl
c000ab36:	85 c0                	test   %eax,%eax
c000ab38:	74 76                	je     c000abb0 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x1cc>
                    counter = zero ? 0 : counter - 1;
c000ab3a:	48                   	dec    %eax
c000ab3b:	89 46 64             	mov    %eax,0x64(%esi)
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c000ab3e:	8b 46 50             	mov    0x50(%esi),%eax
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c000ab41:	85 c0                	test   %eax,%eax
c000ab43:	0f 84 da 00 00 00    	je     c000ac23 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x23f>
c000ab49:	8b 48 08             	mov    0x8(%eax),%ecx
c000ab4c:	85 c9                	test   %ecx,%ecx
c000ab4e:	0f 84 cf 00 00 00    	je     c000ac23 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x23f>
c000ab54:	8b 78 04             	mov    0x4(%eax),%edi
c000ab57:	85 ff                	test   %edi,%edi
c000ab59:	0f 84 c4 00 00 00    	je     c000ac23 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x23f>
                return false;

            if (t == t->next)
c000ab5f:	39 c8                	cmp    %ecx,%eax
c000ab61:	75 09                	jne    c000ab6c <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x188>
                headptr = nullptr;
c000ab63:	c7 46 50 00 00 00 00 	movl   $0x0,0x50(%esi)
c000ab6a:	eb 17                	jmp    c000ab83 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x19f>

            else {
                t->next->prev = t->prev;
c000ab6c:	89 79 04             	mov    %edi,0x4(%ecx)
                t->prev->next = t->next;
c000ab6f:	8b 48 04             	mov    0x4(%eax),%ecx
c000ab72:	8b 78 08             	mov    0x8(%eax),%edi
c000ab75:	89 79 08             	mov    %edi,0x8(%ecx)
                if (t == headptr)
c000ab78:	3b 46 50             	cmp    0x50(%esi),%eax
c000ab7b:	75 06                	jne    c000ab83 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x19f>
                    headptr = t->next;
c000ab7d:	8b 48 08             	mov    0x8(%eax),%ecx
c000ab80:	89 4e 50             	mov    %ecx,0x50(%esi)

    public:

        mword reset(bool l = false) {
            if (l) lock.lock();
            mword c = counter;
c000ab83:	8b 48 10             	mov    0x10(%eax),%ecx
            }

            t->next = t->prev = nullptr;
c000ab86:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
c000ab8d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
            counter = 0;
c000ab94:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
                if (counter) {
                    counter = zero ? 0 : counter - 1;

                    Si * si;
                    if (Queue<Si>::dequeue(si = Queue<Si>::head()))
                        ec->set_si_regs(si->value, static_cast <Sm *>(si)->reset());
c000ab9b:	8b 40 0c             	mov    0xc(%eax),%eax

        ALWAYS_INLINE
        inline void set_si_regs(mword sig, mword cnt)
        {
            regs.ARG_2 = sig;
            regs.ARG_3 = cnt;
c000ab9e:	89 4b 58             	mov    %ecx,0x58(%ebx)
        }

        ALWAYS_INLINE
        inline void set_si_regs(mword sig, mword cnt)
        {
            regs.ARG_2 = sig;
c000aba1:	89 43 54             	mov    %eax,0x54(%ebx)
c000aba4:	eb 7d                	jmp    c000ac23 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x23f>
                if (Atomic::cmp_swap (ref, r, r + 1))
c000aba6:	8d 48 01             	lea    0x1(%eax),%ecx
c000aba9:	f0 0f b1 4b 48       	lock cmpxchg %ecx,0x48(%ebx)
c000abae:	74 07                	je     c000abb7 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x1d3>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c000abb0:	8b 43 48             	mov    0x48(%ebx),%eax
c000abb3:	85 c0                	test   %eax,%eax
c000abb5:	75 ef                	jne    c000aba6 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x1c2>
        inline T *head() const { return headptr; }

        ALWAYS_INLINE
        inline void enqueue (T *t)
        {
            if (!headptr)
c000abb7:	8b 46 4c             	mov    0x4c(%esi),%eax
c000abba:	85 c0                	test   %eax,%eax
c000abbc:	75 11                	jne    c000abcf <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x1eb>
                headptr = t->prev = t->next = t;
c000abbe:	89 9b c4 00 00 00    	mov    %ebx,0xc4(%ebx)
c000abc4:	89 9b c0 00 00 00    	mov    %ebx,0xc0(%ebx)
c000abca:	89 5e 4c             	mov    %ebx,0x4c(%esi)
c000abcd:	eb 21                	jmp    c000abf0 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x20c>
            else {
                t->next = headptr;
c000abcf:	89 83 c4 00 00 00    	mov    %eax,0xc4(%ebx)
                t->prev = headptr->prev;
c000abd5:	8b 4e 4c             	mov    0x4c(%esi),%ecx
c000abd8:	8b 89 c0 00 00 00    	mov    0xc0(%ecx),%ecx
c000abde:	89 8b c0 00 00 00    	mov    %ecx,0xc0(%ebx)
                t->next->prev = t->prev->next = t;
c000abe4:	89 99 c4 00 00 00    	mov    %ebx,0xc4(%ecx)
c000abea:	89 98 c0 00 00 00    	mov    %ebx,0xc0(%eax)
c000abf0:	fe 46 46             	incb   0x46(%esi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c000abf3:	84 d2                	test   %dl,%dl
c000abf5:	74 46                	je     c000ac3d <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x259>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000abf7:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000abfe:	74 19                	je     c000ac19 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x235>
c000ac00:	68 40 85 01 c0       	push   $0xc0018540
c000ac05:	68 c0 00 00 00       	push   $0xc0
c000ac0a:	68 12 61 01 c0       	push   $0xc0016112
c000ac0f:	68 82 61 01 c0       	push   $0xc0016182
c000ac14:	e9 07 fe ff ff       	jmp    c000aa20 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x3c>

            preemption = true;
c000ac19:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000ac20:	fb                   	sti    
c000ac21:	eb 1a                	jmp    c000ac3d <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x259>
c000ac23:	fe 46 46             	incb   0x46(%esi)
c000ac26:	84 d2                	test   %dl,%dl
c000ac28:	74 1a                	je     c000ac44 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x260>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000ac2a:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000ac31:	75 cd                	jne    c000ac00 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x21c>

            preemption = true;
c000ac33:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000ac3a:	fb                   	sti    
c000ac3b:	eb 07                	jmp    c000ac44 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x260>
            if (!block)
                Sc::schedule (false);

            ec->set_timeout (t, this);

            ec->block_sc();
c000ac3d:	89 d8                	mov    %ebx,%eax
c000ac3f:	e8 cc d8 ff ff       	call   c0008510 <_ZN2Ec8block_scEv>

    die ("XCPU OOM error");
c000ac44:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c000ac49:	8d 50 54             	lea    0x54(%eax),%edx
c000ac4c:	b8 db 73 01 c0       	mov    $0xc00173db,%eax
c000ac51:	e8 b6 8e ff ff       	call   c0003b0c <_ZN2Ec3dieEPKcP8Exc_regs>

c000ac56 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm>:
    ec->regs.set_ip (pt->ip);
    ec->make_current();
}

template <void (*C)()>
void Ec::oom_xcpu(Pt * pt, mword src_pd_id, mword oom_state)
c000ac56:	55                   	push   %ebp
c000ac57:	57                   	push   %edi
c000ac58:	56                   	push   %esi
c000ac59:	53                   	push   %ebx
c000ac5a:	53                   	push   %ebx
{
    assert(current == this);
c000ac5b:	8b 35 08 f0 ff cf    	mov    0xcffff008,%esi
c000ac61:	39 c6                	cmp    %eax,%esi
c000ac63:	74 13                	je     c000ac78 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x22>
c000ac65:	68 60 7d 01 c0       	push   $0xc0017d60
c000ac6a:	6a 72                	push   $0x72
c000ac6c:	68 a3 72 01 c0       	push   $0xc00172a3
c000ac71:	68 bc 73 01 c0       	push   $0xc00173bc
c000ac76:	eb 1a                	jmp    c000ac92 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x3c>
    assert(!this->xcpu_sm);
c000ac78:	83 be f4 00 00 00 00 	cmpl   $0x0,0xf4(%esi)
c000ac7f:	74 1b                	je     c000ac9c <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x46>
c000ac81:	68 60 7d 01 c0       	push   $0xc0017d60
c000ac86:	6a 73                	push   $0x73
c000ac88:	68 a3 72 01 c0       	push   $0xc00172a3
c000ac8d:	68 cc 73 01 c0       	push   $0xc00173cc
c000ac92:	68 69 60 01 c0       	push   $0xc0016069
c000ac97:	e8 aa 6c ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

    enum { UNUSED = 0, CNT = 0 };

    this->xcpu_sm = new (Pd::current->quota) Sm (Pd::current, UNUSED, CNT);
c000ac9c:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c000aca1:	89 d7                	mov    %edx,%edi
c000aca3:	89 cd                	mov    %ecx,%ebp
c000aca5:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx

            call_rcu(true);
        }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
c000acab:	b8 b4 b4 01 c0       	mov    $0xc001b4b4,%eax
c000acb0:	e8 c1 55 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c000acb5:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c000acbb:	31 c9                	xor    %ecx,%ecx
c000acbd:	6a 00                	push   $0x0
c000acbf:	6a 00                	push   $0x0
c000acc1:	6a 00                	push   $0x0
c000acc3:	89 c3                	mov    %eax,%ebx
c000acc5:	e8 50 5a 00 00       	call   c001071a <_ZN2SmC1EP2PdmmPS_m>
c000acca:	89 9e f4 00 00 00    	mov    %ebx,0xf4(%esi)

    Ec *xcpu_ec = new (Pd::current->quota) Ec (Pd::current, Pd::current, sys_xcpu_call_oom<C>, pt->ec->cpu, this);
c000acd0:	8b 47 4c             	mov    0x4c(%edi),%eax
c000acd3:	0f b7 80 cc 00 00 00 	movzwl 0xcc(%eax),%eax
c000acda:	89 44 24 0c          	mov    %eax,0xc(%esp)
c000acde:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c000ace3:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx
        static void die (char const *, Exc_regs * = &current->regs);

        static void idl_handler();

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
c000ace9:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c000acee:	e8 83 55 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c000acf3:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c000acf9:	56                   	push   %esi
c000acfa:	ff 74 24 10          	pushl  0x10(%esp)
c000acfe:	89 d1                	mov    %edx,%ecx
c000ad00:	68 bc 9b 00 c0       	push   $0xc0009bbc
c000ad05:	89 c3                	mov    %eax,%ebx
c000ad07:	e8 7e 86 ff ff       	call   c000338a <_ZN2EcC1EP2PdS1_PFvvEjPS_>
c000ad0c:	8b 44 24 30          	mov    0x30(%esp),%eax
c000ad10:	89 7b 70             	mov    %edi,0x70(%ebx)
c000ad13:	89 6b 54             	mov    %ebp,0x54(%ebx)
c000ad16:	89 43 58             	mov    %eax,0x58(%ebx)
    xcpu_ec->regs.set_pt (reinterpret_cast<mword>(pt), src_pd_id, oom_state);

    Sc *xcpu_sc = new (Pd::current->quota) Sc (Pd::current, xcpu_ec, xcpu_ec->cpu, Sc::current);
c000ad19:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c000ad1e:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx
c000ad24:	b8 98 b4 01 c0       	mov    $0xc001b498,%eax
c000ad29:	e8 48 55 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c000ad2e:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c000ad34:	89 d9                	mov    %ebx,%ecx
c000ad36:	ff 35 10 f0 ff cf    	pushl  0xcffff010
c000ad3c:	89 c7                	mov    %eax,%edi
c000ad3e:	0f b7 83 cc 00 00 00 	movzwl 0xcc(%ebx),%eax
c000ad45:	50                   	push   %eax
c000ad46:	89 f8                	mov    %edi,%eax
c000ad48:	e8 41 47 00 00       	call   c000f48e <_ZN2ScC1EP2PdP2EcjPS_>

    xcpu_sc->remote_enqueue();
c000ad4d:	89 f8                	mov    %edi,%eax
c000ad4f:	83 c4 20             	add    $0x20,%esp
c000ad52:	e8 e5 49 00 00       	call   c000f73c <_ZN2Sc14remote_enqueueEv>
    this->xcpu_sm->dn (false, 0);
c000ad57:	8b b6 f4 00 00 00    	mov    0xf4(%esi),%esi
c000ad5d:	8b 1d 08 f0 ff cf    	mov    0xcffff008,%ebx
        }

        ALWAYS_INLINE
        inline void dn (bool zero, uint64 t, Ec *ec = Ec::current, bool block = true)
        {
            {   Lock_guard <Spinlock> guard (lock);
c000ad63:	8d 46 46             	lea    0x46(%esi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c000ad66:	9c                   	pushf  
c000ad67:	5a                   	pop    %edx
            return flags & 0x200;
c000ad68:	c1 ea 09             	shr    $0x9,%edx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c000ad6b:	80 e2 01             	and    $0x1,%dl
c000ad6e:	74 2a                	je     c000ad9a <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x144>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c000ad70:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000ad77:	75 19                	jne    c000ad92 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x13c>
c000ad79:	68 80 85 01 c0       	push   $0xc0018580
c000ad7e:	68 b7 00 00 00       	push   $0xb7
c000ad83:	68 12 61 01 c0       	push   $0xc0016112
c000ad88:	68 83 61 01 c0       	push   $0xc0016183
c000ad8d:	e9 00 ff ff ff       	jmp    c000ac92 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x3c>

            asm volatile ("cli" : : : "memory");
c000ad92:	fa                   	cli    
            preemption = false;
c000ad93:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
c000ad9a:	88 14 24             	mov    %dl,(%esp)
                Cpu::preempt_disable();

            _lock.lock();
c000ad9d:	e8 8a 5d ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>

                if (counter) {
c000ada2:	8b 46 64             	mov    0x64(%esi),%eax
c000ada5:	8a 14 24             	mov    (%esp),%dl
c000ada8:	85 c0                	test   %eax,%eax
c000adaa:	74 76                	je     c000ae22 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x1cc>
                    counter = zero ? 0 : counter - 1;
c000adac:	48                   	dec    %eax
c000adad:	89 46 64             	mov    %eax,0x64(%esi)
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c000adb0:	8b 46 50             	mov    0x50(%esi),%eax
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c000adb3:	85 c0                	test   %eax,%eax
c000adb5:	0f 84 da 00 00 00    	je     c000ae95 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x23f>
c000adbb:	8b 48 08             	mov    0x8(%eax),%ecx
c000adbe:	85 c9                	test   %ecx,%ecx
c000adc0:	0f 84 cf 00 00 00    	je     c000ae95 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x23f>
c000adc6:	8b 78 04             	mov    0x4(%eax),%edi
c000adc9:	85 ff                	test   %edi,%edi
c000adcb:	0f 84 c4 00 00 00    	je     c000ae95 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x23f>
                return false;

            if (t == t->next)
c000add1:	39 c8                	cmp    %ecx,%eax
c000add3:	75 09                	jne    c000adde <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x188>
                headptr = nullptr;
c000add5:	c7 46 50 00 00 00 00 	movl   $0x0,0x50(%esi)
c000addc:	eb 17                	jmp    c000adf5 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x19f>

            else {
                t->next->prev = t->prev;
c000adde:	89 79 04             	mov    %edi,0x4(%ecx)
                t->prev->next = t->next;
c000ade1:	8b 48 04             	mov    0x4(%eax),%ecx
c000ade4:	8b 78 08             	mov    0x8(%eax),%edi
c000ade7:	89 79 08             	mov    %edi,0x8(%ecx)
                if (t == headptr)
c000adea:	3b 46 50             	cmp    0x50(%esi),%eax
c000aded:	75 06                	jne    c000adf5 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x19f>
                    headptr = t->next;
c000adef:	8b 48 08             	mov    0x8(%eax),%ecx
c000adf2:	89 4e 50             	mov    %ecx,0x50(%esi)

    public:

        mword reset(bool l = false) {
            if (l) lock.lock();
            mword c = counter;
c000adf5:	8b 48 10             	mov    0x10(%eax),%ecx
            }

            t->next = t->prev = nullptr;
c000adf8:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
c000adff:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
            counter = 0;
c000ae06:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
                if (counter) {
                    counter = zero ? 0 : counter - 1;

                    Si * si;
                    if (Queue<Si>::dequeue(si = Queue<Si>::head()))
                        ec->set_si_regs(si->value, static_cast <Sm *>(si)->reset());
c000ae0d:	8b 40 0c             	mov    0xc(%eax),%eax

        ALWAYS_INLINE
        inline void set_si_regs(mword sig, mword cnt)
        {
            regs.ARG_2 = sig;
            regs.ARG_3 = cnt;
c000ae10:	89 4b 58             	mov    %ecx,0x58(%ebx)
        }

        ALWAYS_INLINE
        inline void set_si_regs(mword sig, mword cnt)
        {
            regs.ARG_2 = sig;
c000ae13:	89 43 54             	mov    %eax,0x54(%ebx)
c000ae16:	eb 7d                	jmp    c000ae95 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x23f>
                if (Atomic::cmp_swap (ref, r, r + 1))
c000ae18:	8d 48 01             	lea    0x1(%eax),%ecx
c000ae1b:	f0 0f b1 4b 48       	lock cmpxchg %ecx,0x48(%ebx)
c000ae20:	74 07                	je     c000ae29 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x1d3>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c000ae22:	8b 43 48             	mov    0x48(%ebx),%eax
c000ae25:	85 c0                	test   %eax,%eax
c000ae27:	75 ef                	jne    c000ae18 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x1c2>
        inline T *head() const { return headptr; }

        ALWAYS_INLINE
        inline void enqueue (T *t)
        {
            if (!headptr)
c000ae29:	8b 46 4c             	mov    0x4c(%esi),%eax
c000ae2c:	85 c0                	test   %eax,%eax
c000ae2e:	75 11                	jne    c000ae41 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x1eb>
                headptr = t->prev = t->next = t;
c000ae30:	89 9b c4 00 00 00    	mov    %ebx,0xc4(%ebx)
c000ae36:	89 9b c0 00 00 00    	mov    %ebx,0xc0(%ebx)
c000ae3c:	89 5e 4c             	mov    %ebx,0x4c(%esi)
c000ae3f:	eb 21                	jmp    c000ae62 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x20c>
            else {
                t->next = headptr;
c000ae41:	89 83 c4 00 00 00    	mov    %eax,0xc4(%ebx)
                t->prev = headptr->prev;
c000ae47:	8b 4e 4c             	mov    0x4c(%esi),%ecx
c000ae4a:	8b 89 c0 00 00 00    	mov    0xc0(%ecx),%ecx
c000ae50:	89 8b c0 00 00 00    	mov    %ecx,0xc0(%ebx)
                t->next->prev = t->prev->next = t;
c000ae56:	89 99 c4 00 00 00    	mov    %ebx,0xc4(%ecx)
c000ae5c:	89 98 c0 00 00 00    	mov    %ebx,0xc0(%eax)
c000ae62:	fe 46 46             	incb   0x46(%esi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c000ae65:	84 d2                	test   %dl,%dl
c000ae67:	74 46                	je     c000aeaf <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x259>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000ae69:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000ae70:	74 19                	je     c000ae8b <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x235>
c000ae72:	68 40 85 01 c0       	push   $0xc0018540
c000ae77:	68 c0 00 00 00       	push   $0xc0
c000ae7c:	68 12 61 01 c0       	push   $0xc0016112
c000ae81:	68 82 61 01 c0       	push   $0xc0016182
c000ae86:	e9 07 fe ff ff       	jmp    c000ac92 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x3c>

            preemption = true;
c000ae8b:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000ae92:	fb                   	sti    
c000ae93:	eb 1a                	jmp    c000aeaf <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x259>
c000ae95:	fe 46 46             	incb   0x46(%esi)
c000ae98:	84 d2                	test   %dl,%dl
c000ae9a:	74 1a                	je     c000aeb6 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x260>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000ae9c:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000aea3:	75 cd                	jne    c000ae72 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x21c>

            preemption = true;
c000aea5:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000aeac:	fb                   	sti    
c000aead:	eb 07                	jmp    c000aeb6 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x260>
            if (!block)
                Sc::schedule (false);

            ec->set_timeout (t, this);

            ec->block_sc();
c000aeaf:	89 d8                	mov    %ebx,%eax
c000aeb1:	e8 5a d6 ff ff       	call   c0008510 <_ZN2Ec8block_scEv>

    die ("XCPU OOM error");
c000aeb6:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c000aebb:	8d 50 54             	lea    0x54(%eax),%edx
c000aebe:	b8 db 73 01 c0       	mov    $0xc00173db,%eax
c000aec3:	e8 44 8c ff ff       	call   c0003b0c <_ZN2Ec3dieEPKcP8Exc_regs>

c000aec8 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm>:
    ec->regs.set_ip (pt->ip);
    ec->make_current();
}

template <void (*C)()>
void Ec::oom_xcpu(Pt * pt, mword src_pd_id, mword oom_state)
c000aec8:	55                   	push   %ebp
c000aec9:	57                   	push   %edi
c000aeca:	56                   	push   %esi
c000aecb:	53                   	push   %ebx
c000aecc:	53                   	push   %ebx
{
    assert(current == this);
c000aecd:	8b 35 08 f0 ff cf    	mov    0xcffff008,%esi
c000aed3:	39 c6                	cmp    %eax,%esi
c000aed5:	74 13                	je     c000aeea <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x22>
c000aed7:	68 a0 7b 01 c0       	push   $0xc0017ba0
c000aedc:	6a 72                	push   $0x72
c000aede:	68 a3 72 01 c0       	push   $0xc00172a3
c000aee3:	68 bc 73 01 c0       	push   $0xc00173bc
c000aee8:	eb 1a                	jmp    c000af04 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x3c>
    assert(!this->xcpu_sm);
c000aeea:	83 be f4 00 00 00 00 	cmpl   $0x0,0xf4(%esi)
c000aef1:	74 1b                	je     c000af0e <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x46>
c000aef3:	68 a0 7b 01 c0       	push   $0xc0017ba0
c000aef8:	6a 73                	push   $0x73
c000aefa:	68 a3 72 01 c0       	push   $0xc00172a3
c000aeff:	68 cc 73 01 c0       	push   $0xc00173cc
c000af04:	68 69 60 01 c0       	push   $0xc0016069
c000af09:	e8 38 6a ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

    enum { UNUSED = 0, CNT = 0 };

    this->xcpu_sm = new (Pd::current->quota) Sm (Pd::current, UNUSED, CNT);
c000af0e:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c000af13:	89 d7                	mov    %edx,%edi
c000af15:	89 cd                	mov    %ecx,%ebp
c000af17:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx

            call_rcu(true);
        }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
c000af1d:	b8 b4 b4 01 c0       	mov    $0xc001b4b4,%eax
c000af22:	e8 4f 53 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c000af27:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c000af2d:	31 c9                	xor    %ecx,%ecx
c000af2f:	6a 00                	push   $0x0
c000af31:	6a 00                	push   $0x0
c000af33:	6a 00                	push   $0x0
c000af35:	89 c3                	mov    %eax,%ebx
c000af37:	e8 de 57 00 00       	call   c001071a <_ZN2SmC1EP2PdmmPS_m>
c000af3c:	89 9e f4 00 00 00    	mov    %ebx,0xf4(%esi)

    Ec *xcpu_ec = new (Pd::current->quota) Ec (Pd::current, Pd::current, sys_xcpu_call_oom<C>, pt->ec->cpu, this);
c000af42:	8b 47 4c             	mov    0x4c(%edi),%eax
c000af45:	0f b7 80 cc 00 00 00 	movzwl 0xcc(%eax),%eax
c000af4c:	89 44 24 0c          	mov    %eax,0xc(%esp)
c000af50:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c000af55:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx
        static void die (char const *, Exc_regs * = &current->regs);

        static void idl_handler();

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
c000af5b:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c000af60:	e8 11 53 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c000af65:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c000af6b:	56                   	push   %esi
c000af6c:	ff 74 24 10          	pushl  0x10(%esp)
c000af70:	89 d1                	mov    %edx,%ecx
c000af72:	68 00 9c 00 c0       	push   $0xc0009c00
c000af77:	89 c3                	mov    %eax,%ebx
c000af79:	e8 0c 84 ff ff       	call   c000338a <_ZN2EcC1EP2PdS1_PFvvEjPS_>
c000af7e:	8b 44 24 30          	mov    0x30(%esp),%eax
c000af82:	89 7b 70             	mov    %edi,0x70(%ebx)
c000af85:	89 6b 54             	mov    %ebp,0x54(%ebx)
c000af88:	89 43 58             	mov    %eax,0x58(%ebx)
    xcpu_ec->regs.set_pt (reinterpret_cast<mword>(pt), src_pd_id, oom_state);

    Sc *xcpu_sc = new (Pd::current->quota) Sc (Pd::current, xcpu_ec, xcpu_ec->cpu, Sc::current);
c000af8b:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c000af90:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx
c000af96:	b8 98 b4 01 c0       	mov    $0xc001b498,%eax
c000af9b:	e8 d6 52 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c000afa0:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c000afa6:	89 d9                	mov    %ebx,%ecx
c000afa8:	ff 35 10 f0 ff cf    	pushl  0xcffff010
c000afae:	89 c7                	mov    %eax,%edi
c000afb0:	0f b7 83 cc 00 00 00 	movzwl 0xcc(%ebx),%eax
c000afb7:	50                   	push   %eax
c000afb8:	89 f8                	mov    %edi,%eax
c000afba:	e8 cf 44 00 00       	call   c000f48e <_ZN2ScC1EP2PdP2EcjPS_>

    xcpu_sc->remote_enqueue();
c000afbf:	89 f8                	mov    %edi,%eax
c000afc1:	83 c4 20             	add    $0x20,%esp
c000afc4:	e8 73 47 00 00       	call   c000f73c <_ZN2Sc14remote_enqueueEv>
    this->xcpu_sm->dn (false, 0);
c000afc9:	8b b6 f4 00 00 00    	mov    0xf4(%esi),%esi
c000afcf:	8b 1d 08 f0 ff cf    	mov    0xcffff008,%ebx
        }

        ALWAYS_INLINE
        inline void dn (bool zero, uint64 t, Ec *ec = Ec::current, bool block = true)
        {
            {   Lock_guard <Spinlock> guard (lock);
c000afd5:	8d 46 46             	lea    0x46(%esi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c000afd8:	9c                   	pushf  
c000afd9:	5a                   	pop    %edx
            return flags & 0x200;
c000afda:	c1 ea 09             	shr    $0x9,%edx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c000afdd:	80 e2 01             	and    $0x1,%dl
c000afe0:	74 2a                	je     c000b00c <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x144>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c000afe2:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000afe9:	75 19                	jne    c000b004 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x13c>
c000afeb:	68 80 85 01 c0       	push   $0xc0018580
c000aff0:	68 b7 00 00 00       	push   $0xb7
c000aff5:	68 12 61 01 c0       	push   $0xc0016112
c000affa:	68 83 61 01 c0       	push   $0xc0016183
c000afff:	e9 00 ff ff ff       	jmp    c000af04 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x3c>

            asm volatile ("cli" : : : "memory");
c000b004:	fa                   	cli    
            preemption = false;
c000b005:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
c000b00c:	88 14 24             	mov    %dl,(%esp)
                Cpu::preempt_disable();

            _lock.lock();
c000b00f:	e8 18 5b ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>

                if (counter) {
c000b014:	8b 46 64             	mov    0x64(%esi),%eax
c000b017:	8a 14 24             	mov    (%esp),%dl
c000b01a:	85 c0                	test   %eax,%eax
c000b01c:	74 76                	je     c000b094 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x1cc>
                    counter = zero ? 0 : counter - 1;
c000b01e:	48                   	dec    %eax
c000b01f:	89 46 64             	mov    %eax,0x64(%esi)
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c000b022:	8b 46 50             	mov    0x50(%esi),%eax
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c000b025:	85 c0                	test   %eax,%eax
c000b027:	0f 84 da 00 00 00    	je     c000b107 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x23f>
c000b02d:	8b 48 08             	mov    0x8(%eax),%ecx
c000b030:	85 c9                	test   %ecx,%ecx
c000b032:	0f 84 cf 00 00 00    	je     c000b107 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x23f>
c000b038:	8b 78 04             	mov    0x4(%eax),%edi
c000b03b:	85 ff                	test   %edi,%edi
c000b03d:	0f 84 c4 00 00 00    	je     c000b107 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x23f>
                return false;

            if (t == t->next)
c000b043:	39 c8                	cmp    %ecx,%eax
c000b045:	75 09                	jne    c000b050 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x188>
                headptr = nullptr;
c000b047:	c7 46 50 00 00 00 00 	movl   $0x0,0x50(%esi)
c000b04e:	eb 17                	jmp    c000b067 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x19f>

            else {
                t->next->prev = t->prev;
c000b050:	89 79 04             	mov    %edi,0x4(%ecx)
                t->prev->next = t->next;
c000b053:	8b 48 04             	mov    0x4(%eax),%ecx
c000b056:	8b 78 08             	mov    0x8(%eax),%edi
c000b059:	89 79 08             	mov    %edi,0x8(%ecx)
                if (t == headptr)
c000b05c:	3b 46 50             	cmp    0x50(%esi),%eax
c000b05f:	75 06                	jne    c000b067 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x19f>
                    headptr = t->next;
c000b061:	8b 48 08             	mov    0x8(%eax),%ecx
c000b064:	89 4e 50             	mov    %ecx,0x50(%esi)

    public:

        mword reset(bool l = false) {
            if (l) lock.lock();
            mword c = counter;
c000b067:	8b 48 10             	mov    0x10(%eax),%ecx
            }

            t->next = t->prev = nullptr;
c000b06a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
c000b071:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
            counter = 0;
c000b078:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
                if (counter) {
                    counter = zero ? 0 : counter - 1;

                    Si * si;
                    if (Queue<Si>::dequeue(si = Queue<Si>::head()))
                        ec->set_si_regs(si->value, static_cast <Sm *>(si)->reset());
c000b07f:	8b 40 0c             	mov    0xc(%eax),%eax

        ALWAYS_INLINE
        inline void set_si_regs(mword sig, mword cnt)
        {
            regs.ARG_2 = sig;
            regs.ARG_3 = cnt;
c000b082:	89 4b 58             	mov    %ecx,0x58(%ebx)
        }

        ALWAYS_INLINE
        inline void set_si_regs(mword sig, mword cnt)
        {
            regs.ARG_2 = sig;
c000b085:	89 43 54             	mov    %eax,0x54(%ebx)
c000b088:	eb 7d                	jmp    c000b107 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x23f>
                if (Atomic::cmp_swap (ref, r, r + 1))
c000b08a:	8d 48 01             	lea    0x1(%eax),%ecx
c000b08d:	f0 0f b1 4b 48       	lock cmpxchg %ecx,0x48(%ebx)
c000b092:	74 07                	je     c000b09b <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x1d3>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c000b094:	8b 43 48             	mov    0x48(%ebx),%eax
c000b097:	85 c0                	test   %eax,%eax
c000b099:	75 ef                	jne    c000b08a <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x1c2>
        inline T *head() const { return headptr; }

        ALWAYS_INLINE
        inline void enqueue (T *t)
        {
            if (!headptr)
c000b09b:	8b 46 4c             	mov    0x4c(%esi),%eax
c000b09e:	85 c0                	test   %eax,%eax
c000b0a0:	75 11                	jne    c000b0b3 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x1eb>
                headptr = t->prev = t->next = t;
c000b0a2:	89 9b c4 00 00 00    	mov    %ebx,0xc4(%ebx)
c000b0a8:	89 9b c0 00 00 00    	mov    %ebx,0xc0(%ebx)
c000b0ae:	89 5e 4c             	mov    %ebx,0x4c(%esi)
c000b0b1:	eb 21                	jmp    c000b0d4 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x20c>
            else {
                t->next = headptr;
c000b0b3:	89 83 c4 00 00 00    	mov    %eax,0xc4(%ebx)
                t->prev = headptr->prev;
c000b0b9:	8b 4e 4c             	mov    0x4c(%esi),%ecx
c000b0bc:	8b 89 c0 00 00 00    	mov    0xc0(%ecx),%ecx
c000b0c2:	89 8b c0 00 00 00    	mov    %ecx,0xc0(%ebx)
                t->next->prev = t->prev->next = t;
c000b0c8:	89 99 c4 00 00 00    	mov    %ebx,0xc4(%ecx)
c000b0ce:	89 98 c0 00 00 00    	mov    %ebx,0xc0(%eax)
c000b0d4:	fe 46 46             	incb   0x46(%esi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c000b0d7:	84 d2                	test   %dl,%dl
c000b0d9:	74 46                	je     c000b121 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x259>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000b0db:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000b0e2:	74 19                	je     c000b0fd <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x235>
c000b0e4:	68 40 85 01 c0       	push   $0xc0018540
c000b0e9:	68 c0 00 00 00       	push   $0xc0
c000b0ee:	68 12 61 01 c0       	push   $0xc0016112
c000b0f3:	68 82 61 01 c0       	push   $0xc0016182
c000b0f8:	e9 07 fe ff ff       	jmp    c000af04 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x3c>

            preemption = true;
c000b0fd:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000b104:	fb                   	sti    
c000b105:	eb 1a                	jmp    c000b121 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x259>
c000b107:	fe 46 46             	incb   0x46(%esi)
c000b10a:	84 d2                	test   %dl,%dl
c000b10c:	74 1a                	je     c000b128 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x260>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000b10e:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000b115:	75 cd                	jne    c000b0e4 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x21c>

            preemption = true;
c000b117:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000b11e:	fb                   	sti    
c000b11f:	eb 07                	jmp    c000b128 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x260>
            if (!block)
                Sc::schedule (false);

            ec->set_timeout (t, this);

            ec->block_sc();
c000b121:	89 d8                	mov    %ebx,%eax
c000b123:	e8 e8 d3 ff ff       	call   c0008510 <_ZN2Ec8block_scEv>

    die ("XCPU OOM error");
c000b128:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c000b12d:	8d 50 54             	lea    0x54(%eax),%edx
c000b130:	b8 db 73 01 c0       	mov    $0xc00173db,%eax
c000b135:	e8 d2 89 ff ff       	call   c0003b0c <_ZN2Ec3dieEPKcP8Exc_regs>

c000b13a <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm>:
    ec->regs.set_ip (pt->ip);
    ec->make_current();
}

template <void (*C)()>
void Ec::oom_xcpu(Pt * pt, mword src_pd_id, mword oom_state)
c000b13a:	55                   	push   %ebp
c000b13b:	57                   	push   %edi
c000b13c:	56                   	push   %esi
c000b13d:	53                   	push   %ebx
c000b13e:	53                   	push   %ebx
{
    assert(current == this);
c000b13f:	8b 35 08 f0 ff cf    	mov    0xcffff008,%esi
c000b145:	39 c6                	cmp    %eax,%esi
c000b147:	74 13                	je     c000b15c <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x22>
c000b149:	68 e0 79 01 c0       	push   $0xc00179e0
c000b14e:	6a 72                	push   $0x72
c000b150:	68 a3 72 01 c0       	push   $0xc00172a3
c000b155:	68 bc 73 01 c0       	push   $0xc00173bc
c000b15a:	eb 1a                	jmp    c000b176 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x3c>
    assert(!this->xcpu_sm);
c000b15c:	83 be f4 00 00 00 00 	cmpl   $0x0,0xf4(%esi)
c000b163:	74 1b                	je     c000b180 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x46>
c000b165:	68 e0 79 01 c0       	push   $0xc00179e0
c000b16a:	6a 73                	push   $0x73
c000b16c:	68 a3 72 01 c0       	push   $0xc00172a3
c000b171:	68 cc 73 01 c0       	push   $0xc00173cc
c000b176:	68 69 60 01 c0       	push   $0xc0016069
c000b17b:	e8 c6 67 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

    enum { UNUSED = 0, CNT = 0 };

    this->xcpu_sm = new (Pd::current->quota) Sm (Pd::current, UNUSED, CNT);
c000b180:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c000b185:	89 d7                	mov    %edx,%edi
c000b187:	89 cd                	mov    %ecx,%ebp
c000b189:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx

            call_rcu(true);
        }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
c000b18f:	b8 b4 b4 01 c0       	mov    $0xc001b4b4,%eax
c000b194:	e8 dd 50 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c000b199:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c000b19f:	31 c9                	xor    %ecx,%ecx
c000b1a1:	6a 00                	push   $0x0
c000b1a3:	6a 00                	push   $0x0
c000b1a5:	6a 00                	push   $0x0
c000b1a7:	89 c3                	mov    %eax,%ebx
c000b1a9:	e8 6c 55 00 00       	call   c001071a <_ZN2SmC1EP2PdmmPS_m>
c000b1ae:	89 9e f4 00 00 00    	mov    %ebx,0xf4(%esi)

    Ec *xcpu_ec = new (Pd::current->quota) Ec (Pd::current, Pd::current, sys_xcpu_call_oom<C>, pt->ec->cpu, this);
c000b1b4:	8b 47 4c             	mov    0x4c(%edi),%eax
c000b1b7:	0f b7 80 cc 00 00 00 	movzwl 0xcc(%eax),%eax
c000b1be:	89 44 24 0c          	mov    %eax,0xc(%esp)
c000b1c2:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c000b1c7:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx
        static void die (char const *, Exc_regs * = &current->regs);

        static void idl_handler();

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
c000b1cd:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c000b1d2:	e8 9f 50 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c000b1d7:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c000b1dd:	56                   	push   %esi
c000b1de:	ff 74 24 10          	pushl  0x10(%esp)
c000b1e2:	89 d1                	mov    %edx,%ecx
c000b1e4:	68 44 9c 00 c0       	push   $0xc0009c44
c000b1e9:	89 c3                	mov    %eax,%ebx
c000b1eb:	e8 9a 81 ff ff       	call   c000338a <_ZN2EcC1EP2PdS1_PFvvEjPS_>
c000b1f0:	8b 44 24 30          	mov    0x30(%esp),%eax
c000b1f4:	89 7b 70             	mov    %edi,0x70(%ebx)
c000b1f7:	89 6b 54             	mov    %ebp,0x54(%ebx)
c000b1fa:	89 43 58             	mov    %eax,0x58(%ebx)
    xcpu_ec->regs.set_pt (reinterpret_cast<mword>(pt), src_pd_id, oom_state);

    Sc *xcpu_sc = new (Pd::current->quota) Sc (Pd::current, xcpu_ec, xcpu_ec->cpu, Sc::current);
c000b1fd:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c000b202:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx
c000b208:	b8 98 b4 01 c0       	mov    $0xc001b498,%eax
c000b20d:	e8 64 50 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c000b212:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c000b218:	89 d9                	mov    %ebx,%ecx
c000b21a:	ff 35 10 f0 ff cf    	pushl  0xcffff010
c000b220:	89 c7                	mov    %eax,%edi
c000b222:	0f b7 83 cc 00 00 00 	movzwl 0xcc(%ebx),%eax
c000b229:	50                   	push   %eax
c000b22a:	89 f8                	mov    %edi,%eax
c000b22c:	e8 5d 42 00 00       	call   c000f48e <_ZN2ScC1EP2PdP2EcjPS_>

    xcpu_sc->remote_enqueue();
c000b231:	89 f8                	mov    %edi,%eax
c000b233:	83 c4 20             	add    $0x20,%esp
c000b236:	e8 01 45 00 00       	call   c000f73c <_ZN2Sc14remote_enqueueEv>
    this->xcpu_sm->dn (false, 0);
c000b23b:	8b b6 f4 00 00 00    	mov    0xf4(%esi),%esi
c000b241:	8b 1d 08 f0 ff cf    	mov    0xcffff008,%ebx
        }

        ALWAYS_INLINE
        inline void dn (bool zero, uint64 t, Ec *ec = Ec::current, bool block = true)
        {
            {   Lock_guard <Spinlock> guard (lock);
c000b247:	8d 46 46             	lea    0x46(%esi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c000b24a:	9c                   	pushf  
c000b24b:	5a                   	pop    %edx
            return flags & 0x200;
c000b24c:	c1 ea 09             	shr    $0x9,%edx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c000b24f:	80 e2 01             	and    $0x1,%dl
c000b252:	74 2a                	je     c000b27e <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x144>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c000b254:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000b25b:	75 19                	jne    c000b276 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x13c>
c000b25d:	68 80 85 01 c0       	push   $0xc0018580
c000b262:	68 b7 00 00 00       	push   $0xb7
c000b267:	68 12 61 01 c0       	push   $0xc0016112
c000b26c:	68 83 61 01 c0       	push   $0xc0016183
c000b271:	e9 00 ff ff ff       	jmp    c000b176 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x3c>

            asm volatile ("cli" : : : "memory");
c000b276:	fa                   	cli    
            preemption = false;
c000b277:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
c000b27e:	88 14 24             	mov    %dl,(%esp)
                Cpu::preempt_disable();

            _lock.lock();
c000b281:	e8 a6 58 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>

                if (counter) {
c000b286:	8b 46 64             	mov    0x64(%esi),%eax
c000b289:	8a 14 24             	mov    (%esp),%dl
c000b28c:	85 c0                	test   %eax,%eax
c000b28e:	74 76                	je     c000b306 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x1cc>
                    counter = zero ? 0 : counter - 1;
c000b290:	48                   	dec    %eax
c000b291:	89 46 64             	mov    %eax,0x64(%esi)
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c000b294:	8b 46 50             	mov    0x50(%esi),%eax
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c000b297:	85 c0                	test   %eax,%eax
c000b299:	0f 84 da 00 00 00    	je     c000b379 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x23f>
c000b29f:	8b 48 08             	mov    0x8(%eax),%ecx
c000b2a2:	85 c9                	test   %ecx,%ecx
c000b2a4:	0f 84 cf 00 00 00    	je     c000b379 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x23f>
c000b2aa:	8b 78 04             	mov    0x4(%eax),%edi
c000b2ad:	85 ff                	test   %edi,%edi
c000b2af:	0f 84 c4 00 00 00    	je     c000b379 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x23f>
                return false;

            if (t == t->next)
c000b2b5:	39 c8                	cmp    %ecx,%eax
c000b2b7:	75 09                	jne    c000b2c2 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x188>
                headptr = nullptr;
c000b2b9:	c7 46 50 00 00 00 00 	movl   $0x0,0x50(%esi)
c000b2c0:	eb 17                	jmp    c000b2d9 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x19f>

            else {
                t->next->prev = t->prev;
c000b2c2:	89 79 04             	mov    %edi,0x4(%ecx)
                t->prev->next = t->next;
c000b2c5:	8b 48 04             	mov    0x4(%eax),%ecx
c000b2c8:	8b 78 08             	mov    0x8(%eax),%edi
c000b2cb:	89 79 08             	mov    %edi,0x8(%ecx)
                if (t == headptr)
c000b2ce:	3b 46 50             	cmp    0x50(%esi),%eax
c000b2d1:	75 06                	jne    c000b2d9 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x19f>
                    headptr = t->next;
c000b2d3:	8b 48 08             	mov    0x8(%eax),%ecx
c000b2d6:	89 4e 50             	mov    %ecx,0x50(%esi)

    public:

        mword reset(bool l = false) {
            if (l) lock.lock();
            mword c = counter;
c000b2d9:	8b 48 10             	mov    0x10(%eax),%ecx
            }

            t->next = t->prev = nullptr;
c000b2dc:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
c000b2e3:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
            counter = 0;
c000b2ea:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
                if (counter) {
                    counter = zero ? 0 : counter - 1;

                    Si * si;
                    if (Queue<Si>::dequeue(si = Queue<Si>::head()))
                        ec->set_si_regs(si->value, static_cast <Sm *>(si)->reset());
c000b2f1:	8b 40 0c             	mov    0xc(%eax),%eax

        ALWAYS_INLINE
        inline void set_si_regs(mword sig, mword cnt)
        {
            regs.ARG_2 = sig;
            regs.ARG_3 = cnt;
c000b2f4:	89 4b 58             	mov    %ecx,0x58(%ebx)
        }

        ALWAYS_INLINE
        inline void set_si_regs(mword sig, mword cnt)
        {
            regs.ARG_2 = sig;
c000b2f7:	89 43 54             	mov    %eax,0x54(%ebx)
c000b2fa:	eb 7d                	jmp    c000b379 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x23f>
                if (Atomic::cmp_swap (ref, r, r + 1))
c000b2fc:	8d 48 01             	lea    0x1(%eax),%ecx
c000b2ff:	f0 0f b1 4b 48       	lock cmpxchg %ecx,0x48(%ebx)
c000b304:	74 07                	je     c000b30d <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x1d3>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c000b306:	8b 43 48             	mov    0x48(%ebx),%eax
c000b309:	85 c0                	test   %eax,%eax
c000b30b:	75 ef                	jne    c000b2fc <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x1c2>
        inline T *head() const { return headptr; }

        ALWAYS_INLINE
        inline void enqueue (T *t)
        {
            if (!headptr)
c000b30d:	8b 46 4c             	mov    0x4c(%esi),%eax
c000b310:	85 c0                	test   %eax,%eax
c000b312:	75 11                	jne    c000b325 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x1eb>
                headptr = t->prev = t->next = t;
c000b314:	89 9b c4 00 00 00    	mov    %ebx,0xc4(%ebx)
c000b31a:	89 9b c0 00 00 00    	mov    %ebx,0xc0(%ebx)
c000b320:	89 5e 4c             	mov    %ebx,0x4c(%esi)
c000b323:	eb 21                	jmp    c000b346 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x20c>
            else {
                t->next = headptr;
c000b325:	89 83 c4 00 00 00    	mov    %eax,0xc4(%ebx)
                t->prev = headptr->prev;
c000b32b:	8b 4e 4c             	mov    0x4c(%esi),%ecx
c000b32e:	8b 89 c0 00 00 00    	mov    0xc0(%ecx),%ecx
c000b334:	89 8b c0 00 00 00    	mov    %ecx,0xc0(%ebx)
                t->next->prev = t->prev->next = t;
c000b33a:	89 99 c4 00 00 00    	mov    %ebx,0xc4(%ecx)
c000b340:	89 98 c0 00 00 00    	mov    %ebx,0xc0(%eax)
c000b346:	fe 46 46             	incb   0x46(%esi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c000b349:	84 d2                	test   %dl,%dl
c000b34b:	74 46                	je     c000b393 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x259>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000b34d:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000b354:	74 19                	je     c000b36f <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x235>
c000b356:	68 40 85 01 c0       	push   $0xc0018540
c000b35b:	68 c0 00 00 00       	push   $0xc0
c000b360:	68 12 61 01 c0       	push   $0xc0016112
c000b365:	68 82 61 01 c0       	push   $0xc0016182
c000b36a:	e9 07 fe ff ff       	jmp    c000b176 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x3c>

            preemption = true;
c000b36f:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000b376:	fb                   	sti    
c000b377:	eb 1a                	jmp    c000b393 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x259>
c000b379:	fe 46 46             	incb   0x46(%esi)
c000b37c:	84 d2                	test   %dl,%dl
c000b37e:	74 1a                	je     c000b39a <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x260>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000b380:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000b387:	75 cd                	jne    c000b356 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x21c>

            preemption = true;
c000b389:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000b390:	fb                   	sti    
c000b391:	eb 07                	jmp    c000b39a <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x260>
            if (!block)
                Sc::schedule (false);

            ec->set_timeout (t, this);

            ec->block_sc();
c000b393:	89 d8                	mov    %ebx,%eax
c000b395:	e8 76 d1 ff ff       	call   c0008510 <_ZN2Ec8block_scEv>

    die ("XCPU OOM error");
c000b39a:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c000b39f:	8d 50 54             	lea    0x54(%eax),%edx
c000b3a2:	b8 db 73 01 c0       	mov    $0xc00173db,%eax
c000b3a7:	e8 60 87 ff ff       	call   c0003b0c <_ZN2Ec3dieEPKcP8Exc_regs>

c000b3ac <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm>:
    ec->regs.set_ip (pt->ip);
    ec->make_current();
}

template <void (*C)()>
void Ec::oom_xcpu(Pt * pt, mword src_pd_id, mword oom_state)
c000b3ac:	55                   	push   %ebp
c000b3ad:	57                   	push   %edi
c000b3ae:	56                   	push   %esi
c000b3af:	53                   	push   %ebx
c000b3b0:	53                   	push   %ebx
{
    assert(current == this);
c000b3b1:	8b 35 08 f0 ff cf    	mov    0xcffff008,%esi
c000b3b7:	39 c6                	cmp    %eax,%esi
c000b3b9:	74 13                	je     c000b3ce <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x22>
c000b3bb:	68 20 78 01 c0       	push   $0xc0017820
c000b3c0:	6a 72                	push   $0x72
c000b3c2:	68 a3 72 01 c0       	push   $0xc00172a3
c000b3c7:	68 bc 73 01 c0       	push   $0xc00173bc
c000b3cc:	eb 1a                	jmp    c000b3e8 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x3c>
    assert(!this->xcpu_sm);
c000b3ce:	83 be f4 00 00 00 00 	cmpl   $0x0,0xf4(%esi)
c000b3d5:	74 1b                	je     c000b3f2 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x46>
c000b3d7:	68 20 78 01 c0       	push   $0xc0017820
c000b3dc:	6a 73                	push   $0x73
c000b3de:	68 a3 72 01 c0       	push   $0xc00172a3
c000b3e3:	68 cc 73 01 c0       	push   $0xc00173cc
c000b3e8:	68 69 60 01 c0       	push   $0xc0016069
c000b3ed:	e8 54 65 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

    enum { UNUSED = 0, CNT = 0 };

    this->xcpu_sm = new (Pd::current->quota) Sm (Pd::current, UNUSED, CNT);
c000b3f2:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c000b3f7:	89 d7                	mov    %edx,%edi
c000b3f9:	89 cd                	mov    %ecx,%ebp
c000b3fb:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx

            call_rcu(true);
        }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
c000b401:	b8 b4 b4 01 c0       	mov    $0xc001b4b4,%eax
c000b406:	e8 6b 4e 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c000b40b:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c000b411:	31 c9                	xor    %ecx,%ecx
c000b413:	6a 00                	push   $0x0
c000b415:	6a 00                	push   $0x0
c000b417:	6a 00                	push   $0x0
c000b419:	89 c3                	mov    %eax,%ebx
c000b41b:	e8 fa 52 00 00       	call   c001071a <_ZN2SmC1EP2PdmmPS_m>
c000b420:	89 9e f4 00 00 00    	mov    %ebx,0xf4(%esi)

    Ec *xcpu_ec = new (Pd::current->quota) Ec (Pd::current, Pd::current, sys_xcpu_call_oom<C>, pt->ec->cpu, this);
c000b426:	8b 47 4c             	mov    0x4c(%edi),%eax
c000b429:	0f b7 80 cc 00 00 00 	movzwl 0xcc(%eax),%eax
c000b430:	89 44 24 0c          	mov    %eax,0xc(%esp)
c000b434:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c000b439:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx
        static void die (char const *, Exc_regs * = &current->regs);

        static void idl_handler();

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
c000b43f:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c000b444:	e8 2d 4e 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c000b449:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c000b44f:	56                   	push   %esi
c000b450:	ff 74 24 10          	pushl  0x10(%esp)
c000b454:	89 d1                	mov    %edx,%ecx
c000b456:	68 88 9c 00 c0       	push   $0xc0009c88
c000b45b:	89 c3                	mov    %eax,%ebx
c000b45d:	e8 28 7f ff ff       	call   c000338a <_ZN2EcC1EP2PdS1_PFvvEjPS_>
c000b462:	8b 44 24 30          	mov    0x30(%esp),%eax
c000b466:	89 7b 70             	mov    %edi,0x70(%ebx)
c000b469:	89 6b 54             	mov    %ebp,0x54(%ebx)
c000b46c:	89 43 58             	mov    %eax,0x58(%ebx)
    xcpu_ec->regs.set_pt (reinterpret_cast<mword>(pt), src_pd_id, oom_state);

    Sc *xcpu_sc = new (Pd::current->quota) Sc (Pd::current, xcpu_ec, xcpu_ec->cpu, Sc::current);
c000b46f:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c000b474:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx
c000b47a:	b8 98 b4 01 c0       	mov    $0xc001b498,%eax
c000b47f:	e8 f2 4d 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c000b484:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c000b48a:	89 d9                	mov    %ebx,%ecx
c000b48c:	ff 35 10 f0 ff cf    	pushl  0xcffff010
c000b492:	89 c7                	mov    %eax,%edi
c000b494:	0f b7 83 cc 00 00 00 	movzwl 0xcc(%ebx),%eax
c000b49b:	50                   	push   %eax
c000b49c:	89 f8                	mov    %edi,%eax
c000b49e:	e8 eb 3f 00 00       	call   c000f48e <_ZN2ScC1EP2PdP2EcjPS_>

    xcpu_sc->remote_enqueue();
c000b4a3:	89 f8                	mov    %edi,%eax
c000b4a5:	83 c4 20             	add    $0x20,%esp
c000b4a8:	e8 8f 42 00 00       	call   c000f73c <_ZN2Sc14remote_enqueueEv>
    this->xcpu_sm->dn (false, 0);
c000b4ad:	8b b6 f4 00 00 00    	mov    0xf4(%esi),%esi
c000b4b3:	8b 1d 08 f0 ff cf    	mov    0xcffff008,%ebx
        }

        ALWAYS_INLINE
        inline void dn (bool zero, uint64 t, Ec *ec = Ec::current, bool block = true)
        {
            {   Lock_guard <Spinlock> guard (lock);
c000b4b9:	8d 46 46             	lea    0x46(%esi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c000b4bc:	9c                   	pushf  
c000b4bd:	5a                   	pop    %edx
            return flags & 0x200;
c000b4be:	c1 ea 09             	shr    $0x9,%edx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c000b4c1:	80 e2 01             	and    $0x1,%dl
c000b4c4:	74 2a                	je     c000b4f0 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x144>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c000b4c6:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000b4cd:	75 19                	jne    c000b4e8 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x13c>
c000b4cf:	68 80 85 01 c0       	push   $0xc0018580
c000b4d4:	68 b7 00 00 00       	push   $0xb7
c000b4d9:	68 12 61 01 c0       	push   $0xc0016112
c000b4de:	68 83 61 01 c0       	push   $0xc0016183
c000b4e3:	e9 00 ff ff ff       	jmp    c000b3e8 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x3c>

            asm volatile ("cli" : : : "memory");
c000b4e8:	fa                   	cli    
            preemption = false;
c000b4e9:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
c000b4f0:	88 14 24             	mov    %dl,(%esp)
                Cpu::preempt_disable();

            _lock.lock();
c000b4f3:	e8 34 56 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>

                if (counter) {
c000b4f8:	8b 46 64             	mov    0x64(%esi),%eax
c000b4fb:	8a 14 24             	mov    (%esp),%dl
c000b4fe:	85 c0                	test   %eax,%eax
c000b500:	74 76                	je     c000b578 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x1cc>
                    counter = zero ? 0 : counter - 1;
c000b502:	48                   	dec    %eax
c000b503:	89 46 64             	mov    %eax,0x64(%esi)
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c000b506:	8b 46 50             	mov    0x50(%esi),%eax
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c000b509:	85 c0                	test   %eax,%eax
c000b50b:	0f 84 da 00 00 00    	je     c000b5eb <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x23f>
c000b511:	8b 48 08             	mov    0x8(%eax),%ecx
c000b514:	85 c9                	test   %ecx,%ecx
c000b516:	0f 84 cf 00 00 00    	je     c000b5eb <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x23f>
c000b51c:	8b 78 04             	mov    0x4(%eax),%edi
c000b51f:	85 ff                	test   %edi,%edi
c000b521:	0f 84 c4 00 00 00    	je     c000b5eb <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x23f>
                return false;

            if (t == t->next)
c000b527:	39 c8                	cmp    %ecx,%eax
c000b529:	75 09                	jne    c000b534 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x188>
                headptr = nullptr;
c000b52b:	c7 46 50 00 00 00 00 	movl   $0x0,0x50(%esi)
c000b532:	eb 17                	jmp    c000b54b <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x19f>

            else {
                t->next->prev = t->prev;
c000b534:	89 79 04             	mov    %edi,0x4(%ecx)
                t->prev->next = t->next;
c000b537:	8b 48 04             	mov    0x4(%eax),%ecx
c000b53a:	8b 78 08             	mov    0x8(%eax),%edi
c000b53d:	89 79 08             	mov    %edi,0x8(%ecx)
                if (t == headptr)
c000b540:	3b 46 50             	cmp    0x50(%esi),%eax
c000b543:	75 06                	jne    c000b54b <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x19f>
                    headptr = t->next;
c000b545:	8b 48 08             	mov    0x8(%eax),%ecx
c000b548:	89 4e 50             	mov    %ecx,0x50(%esi)

    public:

        mword reset(bool l = false) {
            if (l) lock.lock();
            mword c = counter;
c000b54b:	8b 48 10             	mov    0x10(%eax),%ecx
            }

            t->next = t->prev = nullptr;
c000b54e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
c000b555:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
            counter = 0;
c000b55c:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
                if (counter) {
                    counter = zero ? 0 : counter - 1;

                    Si * si;
                    if (Queue<Si>::dequeue(si = Queue<Si>::head()))
                        ec->set_si_regs(si->value, static_cast <Sm *>(si)->reset());
c000b563:	8b 40 0c             	mov    0xc(%eax),%eax

        ALWAYS_INLINE
        inline void set_si_regs(mword sig, mword cnt)
        {
            regs.ARG_2 = sig;
            regs.ARG_3 = cnt;
c000b566:	89 4b 58             	mov    %ecx,0x58(%ebx)
        }

        ALWAYS_INLINE
        inline void set_si_regs(mword sig, mword cnt)
        {
            regs.ARG_2 = sig;
c000b569:	89 43 54             	mov    %eax,0x54(%ebx)
c000b56c:	eb 7d                	jmp    c000b5eb <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x23f>
                if (Atomic::cmp_swap (ref, r, r + 1))
c000b56e:	8d 48 01             	lea    0x1(%eax),%ecx
c000b571:	f0 0f b1 4b 48       	lock cmpxchg %ecx,0x48(%ebx)
c000b576:	74 07                	je     c000b57f <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x1d3>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c000b578:	8b 43 48             	mov    0x48(%ebx),%eax
c000b57b:	85 c0                	test   %eax,%eax
c000b57d:	75 ef                	jne    c000b56e <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x1c2>
        inline T *head() const { return headptr; }

        ALWAYS_INLINE
        inline void enqueue (T *t)
        {
            if (!headptr)
c000b57f:	8b 46 4c             	mov    0x4c(%esi),%eax
c000b582:	85 c0                	test   %eax,%eax
c000b584:	75 11                	jne    c000b597 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x1eb>
                headptr = t->prev = t->next = t;
c000b586:	89 9b c4 00 00 00    	mov    %ebx,0xc4(%ebx)
c000b58c:	89 9b c0 00 00 00    	mov    %ebx,0xc0(%ebx)
c000b592:	89 5e 4c             	mov    %ebx,0x4c(%esi)
c000b595:	eb 21                	jmp    c000b5b8 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x20c>
            else {
                t->next = headptr;
c000b597:	89 83 c4 00 00 00    	mov    %eax,0xc4(%ebx)
                t->prev = headptr->prev;
c000b59d:	8b 4e 4c             	mov    0x4c(%esi),%ecx
c000b5a0:	8b 89 c0 00 00 00    	mov    0xc0(%ecx),%ecx
c000b5a6:	89 8b c0 00 00 00    	mov    %ecx,0xc0(%ebx)
                t->next->prev = t->prev->next = t;
c000b5ac:	89 99 c4 00 00 00    	mov    %ebx,0xc4(%ecx)
c000b5b2:	89 98 c0 00 00 00    	mov    %ebx,0xc0(%eax)
c000b5b8:	fe 46 46             	incb   0x46(%esi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c000b5bb:	84 d2                	test   %dl,%dl
c000b5bd:	74 46                	je     c000b605 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x259>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000b5bf:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000b5c6:	74 19                	je     c000b5e1 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x235>
c000b5c8:	68 40 85 01 c0       	push   $0xc0018540
c000b5cd:	68 c0 00 00 00       	push   $0xc0
c000b5d2:	68 12 61 01 c0       	push   $0xc0016112
c000b5d7:	68 82 61 01 c0       	push   $0xc0016182
c000b5dc:	e9 07 fe ff ff       	jmp    c000b3e8 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x3c>

            preemption = true;
c000b5e1:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000b5e8:	fb                   	sti    
c000b5e9:	eb 1a                	jmp    c000b605 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x259>
c000b5eb:	fe 46 46             	incb   0x46(%esi)
c000b5ee:	84 d2                	test   %dl,%dl
c000b5f0:	74 1a                	je     c000b60c <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x260>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000b5f2:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000b5f9:	75 cd                	jne    c000b5c8 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x21c>

            preemption = true;
c000b5fb:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000b602:	fb                   	sti    
c000b603:	eb 07                	jmp    c000b60c <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x260>
            if (!block)
                Sc::schedule (false);

            ec->set_timeout (t, this);

            ec->block_sc();
c000b605:	89 d8                	mov    %ebx,%eax
c000b607:	e8 04 cf ff ff       	call   c0008510 <_ZN2Ec8block_scEv>

    die ("XCPU OOM error");
c000b60c:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c000b611:	8d 50 54             	lea    0x54(%eax),%edx
c000b614:	b8 db 73 01 c0       	mov    $0xc00173db,%eax
c000b619:	e8 ee 84 ff ff       	call   c0003b0c <_ZN2Ec3dieEPKcP8Exc_regs>

c000b61e <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm>:
    ec->regs.set_ip (pt->ip);
    ec->make_current();
}

template <void (*C)()>
void Ec::oom_xcpu(Pt * pt, mword src_pd_id, mword oom_state)
c000b61e:	55                   	push   %ebp
c000b61f:	57                   	push   %edi
c000b620:	56                   	push   %esi
c000b621:	53                   	push   %ebx
c000b622:	53                   	push   %ebx
{
    assert(current == this);
c000b623:	8b 35 08 f0 ff cf    	mov    0xcffff008,%esi
c000b629:	39 c6                	cmp    %eax,%esi
c000b62b:	74 13                	je     c000b640 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x22>
c000b62d:	68 60 76 01 c0       	push   $0xc0017660
c000b632:	6a 72                	push   $0x72
c000b634:	68 a3 72 01 c0       	push   $0xc00172a3
c000b639:	68 bc 73 01 c0       	push   $0xc00173bc
c000b63e:	eb 1a                	jmp    c000b65a <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x3c>
    assert(!this->xcpu_sm);
c000b640:	83 be f4 00 00 00 00 	cmpl   $0x0,0xf4(%esi)
c000b647:	74 1b                	je     c000b664 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x46>
c000b649:	68 60 76 01 c0       	push   $0xc0017660
c000b64e:	6a 73                	push   $0x73
c000b650:	68 a3 72 01 c0       	push   $0xc00172a3
c000b655:	68 cc 73 01 c0       	push   $0xc00173cc
c000b65a:	68 69 60 01 c0       	push   $0xc0016069
c000b65f:	e8 e2 62 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

    enum { UNUSED = 0, CNT = 0 };

    this->xcpu_sm = new (Pd::current->quota) Sm (Pd::current, UNUSED, CNT);
c000b664:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c000b669:	89 d7                	mov    %edx,%edi
c000b66b:	89 cd                	mov    %ecx,%ebp
c000b66d:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx

            call_rcu(true);
        }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
c000b673:	b8 b4 b4 01 c0       	mov    $0xc001b4b4,%eax
c000b678:	e8 f9 4b 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c000b67d:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c000b683:	31 c9                	xor    %ecx,%ecx
c000b685:	6a 00                	push   $0x0
c000b687:	6a 00                	push   $0x0
c000b689:	6a 00                	push   $0x0
c000b68b:	89 c3                	mov    %eax,%ebx
c000b68d:	e8 88 50 00 00       	call   c001071a <_ZN2SmC1EP2PdmmPS_m>
c000b692:	89 9e f4 00 00 00    	mov    %ebx,0xf4(%esi)

    Ec *xcpu_ec = new (Pd::current->quota) Ec (Pd::current, Pd::current, sys_xcpu_call_oom<C>, pt->ec->cpu, this);
c000b698:	8b 47 4c             	mov    0x4c(%edi),%eax
c000b69b:	0f b7 80 cc 00 00 00 	movzwl 0xcc(%eax),%eax
c000b6a2:	89 44 24 0c          	mov    %eax,0xc(%esp)
c000b6a6:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c000b6ab:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx
        static void die (char const *, Exc_regs * = &current->regs);

        static void idl_handler();

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
c000b6b1:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c000b6b6:	e8 bb 4b 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c000b6bb:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c000b6c1:	56                   	push   %esi
c000b6c2:	ff 74 24 10          	pushl  0x10(%esp)
c000b6c6:	89 d1                	mov    %edx,%ecx
c000b6c8:	68 cc 9c 00 c0       	push   $0xc0009ccc
c000b6cd:	89 c3                	mov    %eax,%ebx
c000b6cf:	e8 b6 7c ff ff       	call   c000338a <_ZN2EcC1EP2PdS1_PFvvEjPS_>
c000b6d4:	8b 44 24 30          	mov    0x30(%esp),%eax
c000b6d8:	89 7b 70             	mov    %edi,0x70(%ebx)
c000b6db:	89 6b 54             	mov    %ebp,0x54(%ebx)
c000b6de:	89 43 58             	mov    %eax,0x58(%ebx)
    xcpu_ec->regs.set_pt (reinterpret_cast<mword>(pt), src_pd_id, oom_state);

    Sc *xcpu_sc = new (Pd::current->quota) Sc (Pd::current, xcpu_ec, xcpu_ec->cpu, Sc::current);
c000b6e1:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c000b6e6:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx
c000b6ec:	b8 98 b4 01 c0       	mov    $0xc001b498,%eax
c000b6f1:	e8 80 4b 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c000b6f6:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c000b6fc:	89 d9                	mov    %ebx,%ecx
c000b6fe:	ff 35 10 f0 ff cf    	pushl  0xcffff010
c000b704:	89 c7                	mov    %eax,%edi
c000b706:	0f b7 83 cc 00 00 00 	movzwl 0xcc(%ebx),%eax
c000b70d:	50                   	push   %eax
c000b70e:	89 f8                	mov    %edi,%eax
c000b710:	e8 79 3d 00 00       	call   c000f48e <_ZN2ScC1EP2PdP2EcjPS_>

    xcpu_sc->remote_enqueue();
c000b715:	89 f8                	mov    %edi,%eax
c000b717:	83 c4 20             	add    $0x20,%esp
c000b71a:	e8 1d 40 00 00       	call   c000f73c <_ZN2Sc14remote_enqueueEv>
    this->xcpu_sm->dn (false, 0);
c000b71f:	8b b6 f4 00 00 00    	mov    0xf4(%esi),%esi
c000b725:	8b 1d 08 f0 ff cf    	mov    0xcffff008,%ebx
        }

        ALWAYS_INLINE
        inline void dn (bool zero, uint64 t, Ec *ec = Ec::current, bool block = true)
        {
            {   Lock_guard <Spinlock> guard (lock);
c000b72b:	8d 46 46             	lea    0x46(%esi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c000b72e:	9c                   	pushf  
c000b72f:	5a                   	pop    %edx
            return flags & 0x200;
c000b730:	c1 ea 09             	shr    $0x9,%edx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c000b733:	80 e2 01             	and    $0x1,%dl
c000b736:	74 2a                	je     c000b762 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x144>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c000b738:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000b73f:	75 19                	jne    c000b75a <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x13c>
c000b741:	68 80 85 01 c0       	push   $0xc0018580
c000b746:	68 b7 00 00 00       	push   $0xb7
c000b74b:	68 12 61 01 c0       	push   $0xc0016112
c000b750:	68 83 61 01 c0       	push   $0xc0016183
c000b755:	e9 00 ff ff ff       	jmp    c000b65a <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x3c>

            asm volatile ("cli" : : : "memory");
c000b75a:	fa                   	cli    
            preemption = false;
c000b75b:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
c000b762:	88 14 24             	mov    %dl,(%esp)
                Cpu::preempt_disable();

            _lock.lock();
c000b765:	e8 c2 53 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>

                if (counter) {
c000b76a:	8b 46 64             	mov    0x64(%esi),%eax
c000b76d:	8a 14 24             	mov    (%esp),%dl
c000b770:	85 c0                	test   %eax,%eax
c000b772:	74 76                	je     c000b7ea <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x1cc>
                    counter = zero ? 0 : counter - 1;
c000b774:	48                   	dec    %eax
c000b775:	89 46 64             	mov    %eax,0x64(%esi)
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c000b778:	8b 46 50             	mov    0x50(%esi),%eax
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c000b77b:	85 c0                	test   %eax,%eax
c000b77d:	0f 84 da 00 00 00    	je     c000b85d <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x23f>
c000b783:	8b 48 08             	mov    0x8(%eax),%ecx
c000b786:	85 c9                	test   %ecx,%ecx
c000b788:	0f 84 cf 00 00 00    	je     c000b85d <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x23f>
c000b78e:	8b 78 04             	mov    0x4(%eax),%edi
c000b791:	85 ff                	test   %edi,%edi
c000b793:	0f 84 c4 00 00 00    	je     c000b85d <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x23f>
                return false;

            if (t == t->next)
c000b799:	39 c8                	cmp    %ecx,%eax
c000b79b:	75 09                	jne    c000b7a6 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x188>
                headptr = nullptr;
c000b79d:	c7 46 50 00 00 00 00 	movl   $0x0,0x50(%esi)
c000b7a4:	eb 17                	jmp    c000b7bd <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x19f>

            else {
                t->next->prev = t->prev;
c000b7a6:	89 79 04             	mov    %edi,0x4(%ecx)
                t->prev->next = t->next;
c000b7a9:	8b 48 04             	mov    0x4(%eax),%ecx
c000b7ac:	8b 78 08             	mov    0x8(%eax),%edi
c000b7af:	89 79 08             	mov    %edi,0x8(%ecx)
                if (t == headptr)
c000b7b2:	3b 46 50             	cmp    0x50(%esi),%eax
c000b7b5:	75 06                	jne    c000b7bd <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x19f>
                    headptr = t->next;
c000b7b7:	8b 48 08             	mov    0x8(%eax),%ecx
c000b7ba:	89 4e 50             	mov    %ecx,0x50(%esi)

    public:

        mword reset(bool l = false) {
            if (l) lock.lock();
            mword c = counter;
c000b7bd:	8b 48 10             	mov    0x10(%eax),%ecx
            }

            t->next = t->prev = nullptr;
c000b7c0:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
c000b7c7:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
            counter = 0;
c000b7ce:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
                if (counter) {
                    counter = zero ? 0 : counter - 1;

                    Si * si;
                    if (Queue<Si>::dequeue(si = Queue<Si>::head()))
                        ec->set_si_regs(si->value, static_cast <Sm *>(si)->reset());
c000b7d5:	8b 40 0c             	mov    0xc(%eax),%eax

        ALWAYS_INLINE
        inline void set_si_regs(mword sig, mword cnt)
        {
            regs.ARG_2 = sig;
            regs.ARG_3 = cnt;
c000b7d8:	89 4b 58             	mov    %ecx,0x58(%ebx)
        }

        ALWAYS_INLINE
        inline void set_si_regs(mword sig, mword cnt)
        {
            regs.ARG_2 = sig;
c000b7db:	89 43 54             	mov    %eax,0x54(%ebx)
c000b7de:	eb 7d                	jmp    c000b85d <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x23f>
                if (Atomic::cmp_swap (ref, r, r + 1))
c000b7e0:	8d 48 01             	lea    0x1(%eax),%ecx
c000b7e3:	f0 0f b1 4b 48       	lock cmpxchg %ecx,0x48(%ebx)
c000b7e8:	74 07                	je     c000b7f1 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x1d3>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c000b7ea:	8b 43 48             	mov    0x48(%ebx),%eax
c000b7ed:	85 c0                	test   %eax,%eax
c000b7ef:	75 ef                	jne    c000b7e0 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x1c2>
        inline T *head() const { return headptr; }

        ALWAYS_INLINE
        inline void enqueue (T *t)
        {
            if (!headptr)
c000b7f1:	8b 46 4c             	mov    0x4c(%esi),%eax
c000b7f4:	85 c0                	test   %eax,%eax
c000b7f6:	75 11                	jne    c000b809 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x1eb>
                headptr = t->prev = t->next = t;
c000b7f8:	89 9b c4 00 00 00    	mov    %ebx,0xc4(%ebx)
c000b7fe:	89 9b c0 00 00 00    	mov    %ebx,0xc0(%ebx)
c000b804:	89 5e 4c             	mov    %ebx,0x4c(%esi)
c000b807:	eb 21                	jmp    c000b82a <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x20c>
            else {
                t->next = headptr;
c000b809:	89 83 c4 00 00 00    	mov    %eax,0xc4(%ebx)
                t->prev = headptr->prev;
c000b80f:	8b 4e 4c             	mov    0x4c(%esi),%ecx
c000b812:	8b 89 c0 00 00 00    	mov    0xc0(%ecx),%ecx
c000b818:	89 8b c0 00 00 00    	mov    %ecx,0xc0(%ebx)
                t->next->prev = t->prev->next = t;
c000b81e:	89 99 c4 00 00 00    	mov    %ebx,0xc4(%ecx)
c000b824:	89 98 c0 00 00 00    	mov    %ebx,0xc0(%eax)
c000b82a:	fe 46 46             	incb   0x46(%esi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c000b82d:	84 d2                	test   %dl,%dl
c000b82f:	74 46                	je     c000b877 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x259>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000b831:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000b838:	74 19                	je     c000b853 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x235>
c000b83a:	68 40 85 01 c0       	push   $0xc0018540
c000b83f:	68 c0 00 00 00       	push   $0xc0
c000b844:	68 12 61 01 c0       	push   $0xc0016112
c000b849:	68 82 61 01 c0       	push   $0xc0016182
c000b84e:	e9 07 fe ff ff       	jmp    c000b65a <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x3c>

            preemption = true;
c000b853:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000b85a:	fb                   	sti    
c000b85b:	eb 1a                	jmp    c000b877 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x259>
c000b85d:	fe 46 46             	incb   0x46(%esi)
c000b860:	84 d2                	test   %dl,%dl
c000b862:	74 1a                	je     c000b87e <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x260>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000b864:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000b86b:	75 cd                	jne    c000b83a <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x21c>

            preemption = true;
c000b86d:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000b874:	fb                   	sti    
c000b875:	eb 07                	jmp    c000b87e <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x260>
            if (!block)
                Sc::schedule (false);

            ec->set_timeout (t, this);

            ec->block_sc();
c000b877:	89 d8                	mov    %ebx,%eax
c000b879:	e8 92 cc ff ff       	call   c0008510 <_ZN2Ec8block_scEv>

    die ("XCPU OOM error");
c000b87e:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c000b883:	8d 50 54             	lea    0x54(%eax),%edx
c000b886:	b8 db 73 01 c0       	mov    $0xc00173db,%eax
c000b88b:	e8 7c 82 ff ff       	call   c0003b0c <_ZN2Ec3dieEPKcP8Exc_regs>

c000b890 <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_>:
    Pt       *pt = reinterpret_cast<Pt *>(s->ARG_1);
    current->oom_call(pt, s->ARG_2, s->ARG_3, oom_xcpu_return<ret_xcpu_reply_oom<C>>, sys_xcpu_call_oom<C>);
}

void Ec::oom_call_cpu(Pt * pt, mword src, void (*CC)(), void (*HELP)())
{
c000b890:	57                   	push   %edi
c000b891:	56                   	push   %esi
c000b892:	53                   	push   %ebx
    enum { OOM_SEND = 1, OOM_REPLY = 2, OOM_SELF = 4 };
    mword s = OOM_SEND | (this == pt->ec) ? OOM_SELF : 0;

    if (this->cpu != pt->ec->xcpu) {
c000b893:	8b 7a 4c             	mov    0x4c(%edx),%edi
c000b896:	0f b7 b0 cc 00 00 00 	movzwl 0xcc(%eax),%esi
    Pt       *pt = reinterpret_cast<Pt *>(s->ARG_1);
    current->oom_call(pt, s->ARG_2, s->ARG_3, oom_xcpu_return<ret_xcpu_reply_oom<C>>, sys_xcpu_call_oom<C>);
}

void Ec::oom_call_cpu(Pt * pt, mword src, void (*CC)(), void (*HELP)())
{
c000b89d:	8b 5c 24 10          	mov    0x10(%esp),%ebx
    enum { OOM_SEND = 1, OOM_REPLY = 2, OOM_SELF = 4 };
    mword s = OOM_SEND | (this == pt->ec) ? OOM_SELF : 0;

    if (this->cpu != pt->ec->xcpu) {
c000b8a1:	3b b7 cc 00 00 00    	cmp    0xcc(%edi),%esi
c000b8a7:	0f 84 99 00 00 00    	je     c000b946 <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_+0xb6>
        if (CC == sys_call) this->oom_xcpu<sys_call>(pt, src, s); else
c000b8ad:	81 fb 70 06 00 c0    	cmp    $0xc0000670,%ebx
c000b8b3:	75 07                	jne    c000b8bc <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_+0x2c>
c000b8b5:	6a 04                	push   $0x4
c000b8b7:	e8 d2 e9 ff ff       	call   c000a28e <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm>
        if (CC == sys_lookup) this->oom_xcpu<sys_lookup>(pt, src, s); else
c000b8bc:	81 fb 7c 27 01 c0    	cmp    $0xc001277c,%ebx
c000b8c2:	75 07                	jne    c000b8cb <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_+0x3b>
c000b8c4:	6a 04                	push   $0x4
c000b8c6:	e8 35 ec ff ff       	call   c000a500 <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm>
        if (CC == sys_sm_ctrl) this->oom_xcpu<sys_sm_ctrl>(pt, src, s); else
c000b8cb:	81 fb 98 29 01 c0    	cmp    $0xc0012998,%ebx
c000b8d1:	75 07                	jne    c000b8da <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_+0x4a>
c000b8d3:	6a 04                	push   $0x4
c000b8d5:	e8 98 ee ff ff       	call   c000a772 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm>
        if (CC == sys_ec_ctrl) this->oom_xcpu<sys_ec_ctrl>(pt, src, s); else
c000b8da:	81 fb 72 34 01 c0    	cmp    $0xc0013472,%ebx
c000b8e0:	75 07                	jne    c000b8e9 <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_+0x59>
c000b8e2:	6a 04                	push   $0x4
c000b8e4:	e8 fb f0 ff ff       	call   c000a9e4 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm>
        if (CC == sys_sc_ctrl) this->oom_xcpu<sys_sc_ctrl>(pt, src, s); else
c000b8e9:	81 fb 2c 28 01 c0    	cmp    $0xc001282c,%ebx
c000b8ef:	75 07                	jne    c000b8f8 <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_+0x68>
c000b8f1:	6a 04                	push   $0x4
c000b8f3:	e8 5e f3 ff ff       	call   c000ac56 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm>
        if (CC == sys_pt_ctrl) this->oom_xcpu<sys_pt_ctrl>(pt, src, s); else
c000b8f8:	81 fb fe 28 01 c0    	cmp    $0xc00128fe,%ebx
c000b8fe:	75 07                	jne    c000b907 <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_+0x77>
c000b900:	6a 04                	push   $0x4
c000b902:	e8 c1 f5 ff ff       	call   c000aec8 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm>
        if (CC == sys_pd_ctrl) this->oom_xcpu<sys_pd_ctrl>(pt, src, s); else
c000b907:	81 fb c0 30 01 c0    	cmp    $0xc00130c0,%ebx
c000b90d:	75 07                	jne    c000b916 <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_+0x86>
c000b90f:	6a 04                	push   $0x4
c000b911:	e8 24 f8 ff ff       	call   c000b13a <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm>
        if (CC == sys_assign_gsi) this->oom_xcpu<sys_assign_gsi>(pt, src, s); else
c000b916:	81 fb 8a 3f 01 c0    	cmp    $0xc0013f8a,%ebx
c000b91c:	75 07                	jne    c000b925 <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_+0x95>
c000b91e:	6a 04                	push   $0x4
c000b920:	e8 87 fa ff ff       	call   c000b3ac <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm>
        if (CC == sys_assign_pci) this->oom_xcpu<sys_assign_pci>(pt, src, s); else
c000b925:	81 fb 20 3e 01 c0    	cmp    $0xc0013e20,%ebx
c000b92b:	75 07                	jne    c000b934 <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_+0xa4>
c000b92d:	6a 04                	push   $0x4
c000b92f:	e8 ea fc ff ff       	call   c000b61e <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm>
        die ("Unknown oom call");
c000b934:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c000b939:	8d 50 54             	lea    0x54(%eax),%edx
c000b93c:	b8 f0 74 01 c0       	mov    $0xc00174f0,%eax
c000b941:	e8 c6 81 ff ff       	call   c0003b0c <_ZN2Ec3dieEPKcP8Exc_regs>
    }

    oom_call(pt, src, s, CC, HELP);
c000b946:	ff 74 24 14          	pushl  0x14(%esp)
c000b94a:	53                   	push   %ebx
c000b94b:	6a 04                	push   $0x4
c000b94d:	e8 08 df ff ff       	call   c000985a <_ZN2Ec8oom_callEP2PtmmPFvvES3_>

c000b952 <_GLOBAL__sub_I.00102__ZN3Pci5cacheE>:
#include "pci.hpp"
#include "pd.hpp"
#include "stdio.hpp"

INIT_PRIORITY (PRIO_SLAB)
Slab_cache Pci::cache (sizeof (Pci), 8);
c000b952:	b9 08 00 00 00       	mov    $0x8,%ecx
c000b957:	ba 10 00 00 00       	mov    $0x10,%edx
c000b95c:	b8 cc b0 01 c0       	mov    $0xc001b0cc,%eax
c000b961:	e9 a0 48 00 00       	jmp    c0010206 <_ZN10Slab_cacheC1Emj>

c000b966 <_ZN3Hpt8dest_hptEmmj>:

        Paddr replace (Quota &quota, mword, mword);

        static void *remap (Quota &quota, Paddr);

        static bool dest_hpt (Paddr p, mword, unsigned) { return (p != reinterpret_cast<Paddr>(&FRAME_0) && p != reinterpret_cast<Paddr>(&FRAME_1)); }
c000b966:	3d 00 c0 41 00       	cmp    $0x41c000,%eax
c000b96b:	74 09                	je     c000b976 <_ZN3Hpt8dest_hptEmmj+0x10>
c000b96d:	3d 00 d0 41 00       	cmp    $0x41d000,%eax
c000b972:	0f 95 c0             	setne  %al
c000b975:	c3                   	ret    
c000b976:	31 c0                	xor    %eax,%eax
c000b978:	c3                   	ret    

c000b979 <_ZN3Hpt8dest_locEmmj>:
#endif

            return l >= 2 || (l == 1 && v >= SPC_LOCAL_OBJ);
        }

        static bool dest_loc (Paddr, mword v, unsigned l) { return v >= USER_ADDR && l >= 3; }
c000b979:	81 fa ff ff ff bf    	cmp    $0xbfffffff,%edx
c000b97f:	0f 97 c2             	seta   %dl
c000b982:	83 f9 02             	cmp    $0x2,%ecx
c000b985:	0f 97 c0             	seta   %al
c000b988:	20 d0                	and    %dl,%al
c000b98a:	c3                   	ret    

c000b98b <_ZN3Hpt12iter_loc_levEjm>:
        static bool iter_loc_lev(unsigned l, mword) { return l > 3; }
c000b98b:	83 f8 03             	cmp    $0x3,%eax
c000b98e:	0f 97 c0             	seta   %al
c000b991:	c3                   	ret    

c000b992 <_ZN3Hpt12iter_hpt_levEjm>:
#ifdef __x86_64__
            if (sizeof(v) > 4 && (v & (1ULL << 47)))
                v |= ~((1ULL << 48) - 1);
#endif

            return l >= 2 || (l == 1 && v >= SPC_LOCAL_OBJ);
c000b992:	83 f8 01             	cmp    $0x1,%eax
c000b995:	77 0c                	ja     c000b9a3 <_ZN3Hpt12iter_hpt_levEjm+0x11>
c000b997:	81 fa ff ff ff df    	cmp    $0xdfffffff,%edx
c000b99d:	0f 97 c2             	seta   %dl
c000b9a0:	20 d0                	and    %dl,%al
c000b9a2:	c3                   	ret    
c000b9a3:	b0 01                	mov    $0x1,%al
        }
c000b9a5:	c3                   	ret    

c000b9a6 <_Z8free_mdbI9Space_memEvP8Rcu_elem>:
}

template <typename S>
static void free_mdb(Rcu_elem * e)
{
    Mdb *mdb = static_cast<Mdb *>(e);
c000b9a6:	85 c0                	test   %eax,%eax
c000b9a8:	74 37                	je     c000b9e1 <_Z8free_mdbI9Space_memEvP8Rcu_elem+0x3b>
        assert(res);
    }
}

template <typename S>
static void free_mdb(Rcu_elem * e)
c000b9aa:	53                   	push   %ebx
{
    Mdb *mdb = static_cast<Mdb *>(e);
    Pd  *pd  = &Pd::root;
c000b9ab:	b9 00 b1 01 c0       	mov    $0xc001b100,%ecx

        bool removed() const { return sta == REMOVED; }
        bool invalid() const { return sta == STALE || sta == KIM; }
c000b9b0:	66 8b 58 fe          	mov    -0x2(%eax),%bx
}

template <typename S>
static void free_mdb(Rcu_elem * e)
{
    Mdb *mdb = static_cast<Mdb *>(e);
c000b9b4:	8d 50 f4             	lea    -0xc(%eax),%edx
c000b9b7:	83 eb 02             	sub    $0x2,%ebx
    Pd  *pd  = &Pd::root;

    if (!mdb->invalid()) {
c000b9ba:	66 83 fb 01          	cmp    $0x1,%bx
c000b9be:	76 10                	jbe    c000b9d0 <_Z8free_mdbI9Space_memEvP8Rcu_elem+0x2a>
        S *space = static_cast<S *>(mdb->space);
c000b9c0:	8b 48 1c             	mov    0x1c(%eax),%ecx
        pd = static_cast<Pd *>(space);
c000b9c3:	8d 41 b4             	lea    -0x4c(%ecx),%eax
c000b9c6:	85 c9                	test   %ecx,%ecx
c000b9c8:	b9 00 00 00 00       	mov    $0x0,%ecx
c000b9cd:	0f 45 c8             	cmovne %eax,%ecx
    }

    Mdb::destroy (mdb, pd->quota);
}
c000b9d0:	5b                   	pop    %ebx
    if (!mdb->invalid()) {
        S *space = static_cast<S *>(mdb->space);
        pd = static_cast<Pd *>(space);
    }

    Mdb::destroy (mdb, pd->quota);
c000b9d1:	81 c1 90 01 00 00    	add    $0x190,%ecx

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void destroy (Mdb *obj, Quota &quota) { obj->~Mdb(); cache.free (obj, quota); }
c000b9d7:	b8 80 b0 01 c0       	mov    $0xc001b080,%eax
c000b9dc:	e9 7f 49 00 00       	jmp    c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
c000b9e1:	66 a1 0a 00 00 00    	mov    0xa,%ax
c000b9e7:	0f 0b                	ud2    

c000b9e9 <_Z8free_mdbI9Space_pioEvP8Rcu_elem>:
}

template <typename S>
static void free_mdb(Rcu_elem * e)
{
    Mdb *mdb = static_cast<Mdb *>(e);
c000b9e9:	85 c0                	test   %eax,%eax
c000b9eb:	74 3a                	je     c000ba27 <_Z8free_mdbI9Space_pioEvP8Rcu_elem+0x3e>
        assert(res);
    }
}

template <typename S>
static void free_mdb(Rcu_elem * e)
c000b9ed:	53                   	push   %ebx
{
    Mdb *mdb = static_cast<Mdb *>(e);
    Pd  *pd  = &Pd::root;
c000b9ee:	b9 00 b1 01 c0       	mov    $0xc001b100,%ecx
c000b9f3:	66 8b 58 fe          	mov    -0x2(%eax),%bx
}

template <typename S>
static void free_mdb(Rcu_elem * e)
{
    Mdb *mdb = static_cast<Mdb *>(e);
c000b9f7:	8d 50 f4             	lea    -0xc(%eax),%edx
c000b9fa:	83 eb 02             	sub    $0x2,%ebx
    Pd  *pd  = &Pd::root;

    if (!mdb->invalid()) {
c000b9fd:	66 83 fb 01          	cmp    $0x1,%bx
c000ba01:	76 13                	jbe    c000ba16 <_Z8free_mdbI9Space_pioEvP8Rcu_elem+0x2d>
        S *space = static_cast<S *>(mdb->space);
c000ba03:	8b 48 1c             	mov    0x1c(%eax),%ecx
        pd = static_cast<Pd *>(space);
c000ba06:	8d 81 88 fe ff ff    	lea    -0x178(%ecx),%eax
c000ba0c:	85 c9                	test   %ecx,%ecx
c000ba0e:	b9 00 00 00 00       	mov    $0x0,%ecx
c000ba13:	0f 45 c8             	cmovne %eax,%ecx
    }

    Mdb::destroy (mdb, pd->quota);
}
c000ba16:	5b                   	pop    %ebx
    if (!mdb->invalid()) {
        S *space = static_cast<S *>(mdb->space);
        pd = static_cast<Pd *>(space);
    }

    Mdb::destroy (mdb, pd->quota);
c000ba17:	81 c1 90 01 00 00    	add    $0x190,%ecx
c000ba1d:	b8 80 b0 01 c0       	mov    $0xc001b080,%eax
c000ba22:	e9 39 49 00 00       	jmp    c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
c000ba27:	66 a1 0a 00 00 00    	mov    0xa,%ax
c000ba2d:	0f 0b                	ud2    

c000ba2f <_Z8free_mdbI9Space_objEvP8Rcu_elem>:
}

template <typename S>
static void free_mdb(Rcu_elem * e)
{
    Mdb *mdb = static_cast<Mdb *>(e);
c000ba2f:	85 c0                	test   %eax,%eax
c000ba31:	74 3a                	je     c000ba6d <_Z8free_mdbI9Space_objEvP8Rcu_elem+0x3e>
        assert(res);
    }
}

template <typename S>
static void free_mdb(Rcu_elem * e)
c000ba33:	53                   	push   %ebx
{
    Mdb *mdb = static_cast<Mdb *>(e);
    Pd  *pd  = &Pd::root;
c000ba34:	b9 00 b1 01 c0       	mov    $0xc001b100,%ecx
c000ba39:	66 8b 58 fe          	mov    -0x2(%eax),%bx
}

template <typename S>
static void free_mdb(Rcu_elem * e)
{
    Mdb *mdb = static_cast<Mdb *>(e);
c000ba3d:	8d 50 f4             	lea    -0xc(%eax),%edx
c000ba40:	83 eb 02             	sub    $0x2,%ebx
    Pd  *pd  = &Pd::root;

    if (!mdb->invalid()) {
c000ba43:	66 83 fb 01          	cmp    $0x1,%bx
c000ba47:	76 13                	jbe    c000ba5c <_Z8free_mdbI9Space_objEvP8Rcu_elem+0x2d>
        S *space = static_cast<S *>(mdb->space);
c000ba49:	8b 48 1c             	mov    0x1c(%eax),%ecx
        pd = static_cast<Pd *>(space);
c000ba4c:	8d 81 78 fe ff ff    	lea    -0x188(%ecx),%eax
c000ba52:	85 c9                	test   %ecx,%ecx
c000ba54:	b9 00 00 00 00       	mov    $0x0,%ecx
c000ba59:	0f 45 c8             	cmovne %eax,%ecx
    }

    Mdb::destroy (mdb, pd->quota);
}
c000ba5c:	5b                   	pop    %ebx
    if (!mdb->invalid()) {
        S *space = static_cast<S *>(mdb->space);
        pd = static_cast<Pd *>(space);
    }

    Mdb::destroy (mdb, pd->quota);
c000ba5d:	81 c1 90 01 00 00    	add    $0x190,%ecx
c000ba63:	b8 80 b0 01 c0       	mov    $0xc001b080,%eax
c000ba68:	e9 f3 48 00 00       	jmp    c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
c000ba6d:	66 a1 0a 00 00 00    	mov    0xa,%ax
c000ba73:	0f 0b                	ud2    
c000ba75:	90                   	nop

c000ba76 <_ZN5QuotaC1Ev>:
    private:
        uint16 val;

    public:
        ALWAYS_INLINE
        inline Spinlock() : val (0) {}
c000ba76:	66 c7 00 00 00       	movw   $0x0,(%eax)

    public:

        static Quota init;

        Quota () : used(0), over(0), upli(0), notr(0) { }
c000ba7b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
c000ba82:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
c000ba89:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
c000ba90:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
c000ba97:	c3                   	ret    

c000ba98 <_ZN11Quota_guard5checkEm>:

    public:

        Quota_guard(Quota &ref) : q(), r(ref) { }

        bool check(mword req)
c000ba98:	56                   	push   %esi
c000ba99:	53                   	push   %ebx
c000ba9a:	89 c3                	mov    %eax,%ebx
            }
        }

        bool hit_limit(mword free_space = 0)
        {
             if (free_space > upli)
c000ba9c:	8b 70 0c             	mov    0xc(%eax),%esi
c000ba9f:	39 f2                	cmp    %esi,%edx
c000baa1:	77 0b                	ja     c000baae <_ZN11Quota_guard5checkEm+0x16>
                 return true;

             return usage() > upli - free_space;
c000baa3:	89 f1                	mov    %esi,%ecx
        Quota_guard(Quota &ref) : q(), r(ref) { }

        bool check(mword req)
        {
            if (!q.hit_limit(req))
                return true;
c000baa5:	b0 01                	mov    $0x1,%al
        bool hit_limit(mword free_space = 0)
        {
             if (free_space > upli)
                 return true;

             return usage() > upli - free_space;
c000baa7:	29 d1                	sub    %edx,%ecx

        Quota_guard(Quota &ref) : q(), r(ref) { }

        bool check(mword req)
        {
            if (!q.hit_limit(req))
c000baa9:	39 4b 04             	cmp    %ecx,0x4(%ebx)
c000baac:	76 20                	jbe    c000bace <_ZN11Quota_guard5checkEm+0x36>
c000baae:	8b 4b 04             	mov    0x4(%ebx),%ecx
                return true;

            if (q.limit() <= q.usage())
c000bab1:	39 ce                	cmp    %ecx,%esi
c000bab3:	77 06                	ja     c000babb <_ZN11Quota_guard5checkEm+0x23>
c000bab5:	29 f2                	sub    %esi,%edx
                req += q.usage() - q.limit();
c000bab7:	01 d1                	add    %edx,%ecx
c000bab9:	eb 06                	jmp    c000bac1 <_ZN11Quota_guard5checkEm+0x29>
            else
                req -= q.limit() - q.usage();
c000babb:	29 ce                	sub    %ecx,%esi
c000babd:	29 f2                	sub    %esi,%edx
c000babf:	89 d1                	mov    %edx,%ecx

            return r.transfer_to(q, req, false);
c000bac1:	8b 43 14             	mov    0x14(%ebx),%eax
c000bac4:	89 da                	mov    %ebx,%edx
c000bac6:	6a 00                	push   $0x0
c000bac8:	e8 1f 70 ff ff       	call   c0002aec <_ZN5Quota11transfer_toERS_mb>
c000bacd:	5a                   	pop    %edx
        }
c000bace:	5b                   	pop    %ebx
c000bacf:	5e                   	pop    %esi
c000bad0:	c3                   	ret    
c000bad1:	90                   	nop

c000bad2 <_ZN11Quota_guardD1Ev>:

        operator Quota&() { return q; }

        ~Quota_guard() { q.free_up(r); }
c000bad2:	8b 50 14             	mov    0x14(%eax),%edx
c000bad5:	e9 f2 6e ff ff       	jmp    c00029cc <_ZN5Quota7free_upERS_>

c000bada <_ZN5Space11tree_lookupEmb>:
        Avl *       tree;

    public:
        Space() : tree (nullptr) {}

        Mdb *tree_lookup (mword idx, bool next = false)
c000bada:	55                   	push   %ebp
c000badb:	89 d5                	mov    %edx,%ebp
c000badd:	57                   	push   %edi
c000bade:	89 c7                	mov    %eax,%edi
c000bae0:	56                   	push   %esi
c000bae1:	53                   	push   %ebx
c000bae2:	53                   	push   %ebx
c000bae3:	88 4c 24 03          	mov    %cl,0x3(%esp)

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c000bae7:	9c                   	pushf  
c000bae8:	58                   	pop    %eax
            return flags & 0x200;
c000bae9:	c1 e8 09             	shr    $0x9,%eax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c000baec:	24 01                	and    $0x1,%al
c000baee:	88 44 24 02          	mov    %al,0x2(%esp)
c000baf2:	74 27                	je     c000bb1b <_ZN5Space11tree_lookupEmb+0x41>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c000baf4:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000bafb:	75 16                	jne    c000bb13 <_ZN5Space11tree_lookupEmb+0x39>
c000bafd:	68 20 8c 01 c0       	push   $0xc0018c20
c000bb02:	68 b7 00 00 00       	push   $0xb7
c000bb07:	68 12 61 01 c0       	push   $0xc0016112
c000bb0c:	68 83 61 01 c0       	push   $0xc0016183
c000bb11:	eb 66                	jmp    c000bb79 <_ZN5Space11tree_lookupEmb+0x9f>

            asm volatile ("cli" : : : "memory");
c000bb13:	fa                   	cli    
            preemption = false;
c000bb14:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c000bb1b:	89 f8                	mov    %edi,%eax
c000bb1d:	e8 0a 50 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
        {
            Lock_guard <Spinlock> guard (lock);
            return Mdb::lookup (tree, idx, next);
c000bb22:	8b 77 04             	mov    0x4(%edi),%esi
        NOINLINE
        explicit Mdb (Space *s, void (*f)(Rcu_elem *), mword p, mword b, mword o = 0, mword a = 0, mword t = 0, mword sub = 0) : Rcu_elem (f), dpth (0), prev (this), next (this), prnt (nullptr), space (s), node_phys (p), node_base (b), node_order (o), node_attr (a), node_type (t), node_sub (sub) {}

        static Mdb *lookup (Avl *tree, mword base, bool next)
        {
            Mdb *n = nullptr;
c000bb25:	31 c0                	xor    %eax,%eax
            bool d;

            for (Mdb *m = static_cast<Mdb *>(tree); m; m = static_cast<Mdb *>(m->lnk[d])) {
c000bb27:	85 f6                	test   %esi,%esi
c000bb29:	74 26                	je     c000bb51 <_ZN5Space11tree_lookupEmb+0x77>

                if ((m->node_base ^ base) >> m->node_order == 0)
c000bb2b:	8b 56 30             	mov    0x30(%esi),%edx
c000bb2e:	89 e9                	mov    %ebp,%ecx
c000bb30:	31 d1                	xor    %edx,%ecx
c000bb32:	89 cb                	mov    %ecx,%ebx
c000bb34:	8b 4e 34             	mov    0x34(%esi),%ecx
c000bb37:	d3 eb                	shr    %cl,%ebx
c000bb39:	85 db                	test   %ebx,%ebx
c000bb3b:	74 16                	je     c000bb53 <_ZN5Space11tree_lookupEmb+0x79>
                    return m;

                if ((d = base > m->node_base) == 0 && next)
c000bb3d:	39 d5                	cmp    %edx,%ebp
c000bb3f:	0f 97 c2             	seta   %dl
c000bb42:	3a 54 24 03          	cmp    0x3(%esp),%dl
        static Mdb *lookup (Avl *tree, mword base, bool next)
        {
            Mdb *n = nullptr;
            bool d;

            for (Mdb *m = static_cast<Mdb *>(tree); m; m = static_cast<Mdb *>(m->lnk[d])) {
c000bb46:	0f b6 d2             	movzbl %dl,%edx

                if ((m->node_base ^ base) >> m->node_order == 0)
                    return m;

                if ((d = base > m->node_base) == 0 && next)
c000bb49:	0f 42 c6             	cmovb  %esi,%eax
        static Mdb *lookup (Avl *tree, mword base, bool next)
        {
            Mdb *n = nullptr;
            bool d;

            for (Mdb *m = static_cast<Mdb *>(tree); m; m = static_cast<Mdb *>(m->lnk[d])) {
c000bb4c:	8b 34 96             	mov    (%esi,%edx,4),%esi
c000bb4f:	eb d6                	jmp    c000bb27 <_ZN5Space11tree_lookupEmb+0x4d>

                if ((d = base > m->node_base) == 0 && next)
                    n = m;
            }

            return n;
c000bb51:	89 c6                	mov    %eax,%esi
        }

        ALWAYS_INLINE
        inline void unlock()
        {
            asm volatile ("incb %0" : "=m" (val) : : "memory");
c000bb53:	fe 07                	incb   (%edi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c000bb55:	80 7c 24 02 00       	cmpb   $0x0,0x2(%esp)
c000bb5a:	74 2f                	je     c000bb8b <_ZN5Space11tree_lookupEmb+0xb1>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000bb5c:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000bb63:	74 1e                	je     c000bb83 <_ZN5Space11tree_lookupEmb+0xa9>
c000bb65:	68 e0 8b 01 c0       	push   $0xc0018be0
c000bb6a:	68 c0 00 00 00       	push   $0xc0
c000bb6f:	68 12 61 01 c0       	push   $0xc0016112
c000bb74:	68 82 61 01 c0       	push   $0xc0016182
c000bb79:	68 69 60 01 c0       	push   $0xc0016069
c000bb7e:	e8 c3 5d ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

            preemption = true;
c000bb83:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000bb8a:	fb                   	sti    
        }
c000bb8b:	5a                   	pop    %edx
c000bb8c:	89 f0                	mov    %esi,%eax
c000bb8e:	5b                   	pop    %ebx
c000bb8f:	5e                   	pop    %esi
c000bb90:	5f                   	pop    %edi
c000bb91:	5d                   	pop    %ebp
c000bb92:	c3                   	ret    

c000bb93 <_ZN5Space11tree_insertEP3Mdb>:

        static bool tree_insert (Mdb *node)
c000bb93:	57                   	push   %edi
c000bb94:	89 c7                	mov    %eax,%edi
c000bb96:	56                   	push   %esi
c000bb97:	53                   	push   %ebx
        {
            Lock_guard <Spinlock> guard (node->space->lock);
c000bb98:	8b 70 28             	mov    0x28(%eax),%esi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c000bb9b:	9c                   	pushf  
c000bb9c:	59                   	pop    %ecx
            return flags & 0x200;
c000bb9d:	c1 e9 09             	shr    $0x9,%ecx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c000bba0:	88 cb                	mov    %cl,%bl
c000bba2:	80 e3 01             	and    $0x1,%bl
c000bba5:	74 27                	je     c000bbce <_ZN5Space11tree_insertEP3Mdb+0x3b>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c000bba7:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000bbae:	75 16                	jne    c000bbc6 <_ZN5Space11tree_insertEP3Mdb+0x33>
c000bbb0:	68 20 8c 01 c0       	push   $0xc0018c20
c000bbb5:	68 b7 00 00 00       	push   $0xb7
c000bbba:	68 12 61 01 c0       	push   $0xc0016112
c000bbbf:	68 83 61 01 c0       	push   $0xc0016183
c000bbc4:	eb 3f                	jmp    c000bc05 <_ZN5Space11tree_insertEP3Mdb+0x72>

            asm volatile ("cli" : : : "memory");
c000bbc6:	fa                   	cli    
            preemption = false;
c000bbc7:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c000bbce:	89 f0                	mov    %esi,%eax
c000bbd0:	e8 57 4f ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
            return Mdb::insert<Mdb> (&node->space->tree, node);
c000bbd5:	8b 47 28             	mov    0x28(%edi),%eax
c000bbd8:	89 fa                	mov    %edi,%edx
c000bbda:	83 c0 04             	add    $0x4,%eax
c000bbdd:	e8 38 50 ff ff       	call   c0000c1a <_ZN3Avl6insertI3MdbEEbPPS_S2_>
c000bbe2:	fe 06                	incb   (%esi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c000bbe4:	84 db                	test   %bl,%bl
c000bbe6:	74 2f                	je     c000bc17 <_ZN5Space11tree_insertEP3Mdb+0x84>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000bbe8:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000bbef:	74 1e                	je     c000bc0f <_ZN5Space11tree_insertEP3Mdb+0x7c>
c000bbf1:	68 e0 8b 01 c0       	push   $0xc0018be0
c000bbf6:	68 c0 00 00 00       	push   $0xc0
c000bbfb:	68 12 61 01 c0       	push   $0xc0016112
c000bc00:	68 82 61 01 c0       	push   $0xc0016182
c000bc05:	68 69 60 01 c0       	push   $0xc0016069
c000bc0a:	e8 37 5d ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

            preemption = true;
c000bc0f:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000bc16:	fb                   	sti    
        }
c000bc17:	5b                   	pop    %ebx
c000bc18:	5e                   	pop    %esi
c000bc19:	5f                   	pop    %edi
c000bc1a:	c3                   	ret    

c000bc1b <_ZN5Space11tree_removeEP3MdbN3Avl5StateE>:

        static bool tree_remove (Mdb *node, Avl::State state = Avl::State::REMOVED)
c000bc1b:	55                   	push   %ebp
c000bc1c:	89 d5                	mov    %edx,%ebp
c000bc1e:	57                   	push   %edi
c000bc1f:	56                   	push   %esi
c000bc20:	89 c6                	mov    %eax,%esi
c000bc22:	53                   	push   %ebx
        {
            Lock_guard <Spinlock> guard (node->space->lock);
c000bc23:	8b 78 28             	mov    0x28(%eax),%edi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c000bc26:	9c                   	pushf  
c000bc27:	5b                   	pop    %ebx
            return flags & 0x200;
c000bc28:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c000bc2b:	80 e3 01             	and    $0x1,%bl
c000bc2e:	74 27                	je     c000bc57 <_ZN5Space11tree_removeEP3MdbN3Avl5StateE+0x3c>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c000bc30:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000bc37:	75 16                	jne    c000bc4f <_ZN5Space11tree_removeEP3MdbN3Avl5StateE+0x34>
c000bc39:	68 20 8c 01 c0       	push   $0xc0018c20
c000bc3e:	68 b7 00 00 00       	push   $0xb7
c000bc43:	68 12 61 01 c0       	push   $0xc0016112
c000bc48:	68 83 61 01 c0       	push   $0xc0016183
c000bc4d:	eb 41                	jmp    c000bc90 <_ZN5Space11tree_removeEP3MdbN3Avl5StateE+0x75>

            asm volatile ("cli" : : : "memory");
c000bc4f:	fa                   	cli    
            preemption = false;
c000bc50:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c000bc57:	89 f8                	mov    %edi,%eax
c000bc59:	e8 ce 4e ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
            return Mdb::remove<Mdb> (&node->space->tree, node, state);
c000bc5e:	8b 46 28             	mov    0x28(%esi),%eax
c000bc61:	89 e9                	mov    %ebp,%ecx
c000bc63:	89 f2                	mov    %esi,%edx
c000bc65:	83 c0 04             	add    $0x4,%eax
c000bc68:	e8 a5 50 ff ff       	call   c0000d12 <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE>
c000bc6d:	fe 07                	incb   (%edi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c000bc6f:	84 db                	test   %bl,%bl
c000bc71:	74 2f                	je     c000bca2 <_ZN5Space11tree_removeEP3MdbN3Avl5StateE+0x87>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000bc73:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000bc7a:	74 1e                	je     c000bc9a <_ZN5Space11tree_removeEP3MdbN3Avl5StateE+0x7f>
c000bc7c:	68 e0 8b 01 c0       	push   $0xc0018be0
c000bc81:	68 c0 00 00 00       	push   $0xc0
c000bc86:	68 12 61 01 c0       	push   $0xc0016112
c000bc8b:	68 82 61 01 c0       	push   $0xc0016182
c000bc90:	68 69 60 01 c0       	push   $0xc0016069
c000bc95:	e8 ac 5c ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

            preemption = true;
c000bc9a:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000bca1:	fb                   	sti    
        }
c000bca2:	5b                   	pop    %ebx
c000bca3:	5e                   	pop    %esi
c000bca4:	5f                   	pop    %edi
c000bca5:	5d                   	pop    %ebp
c000bca6:	c3                   	ret    
c000bca7:	90                   	nop

c000bca8 <_ZN2PdC1EPS_mm>:

    // I/O Ports
    Space_pio::addreg (own->quota, 0, 1UL << 16, 7);
}

Pd::Pd (Pd *own, mword sel, mword a) : Kobject (PD, static_cast<Space_obj *>(own), sel, a, free, pre_free)
c000bca8:	56                   	push   %esi
c000bca9:	85 d2                	test   %edx,%edx
c000bcab:	53                   	push   %ebx
c000bcac:	89 c3                	mov    %eax,%ebx
c000bcae:	68 99 c9 00 c0       	push   $0xc000c999
c000bcb3:	68 e9 ca 00 c0       	push   $0xc000cae9
c000bcb8:	ff 74 24 14          	pushl  0x14(%esp)
c000bcbc:	8d 82 88 01 00 00    	lea    0x188(%edx),%eax
c000bcc2:	ba 00 00 00 00       	mov    $0x0,%edx
c000bcc7:	0f 45 d0             	cmovne %eax,%edx
c000bcca:	89 d8                	mov    %ebx,%eax
c000bccc:	51                   	push   %ecx
c000bccd:	89 d9                	mov    %ebx,%ecx
c000bccf:	e8 72 6f ff ff       	call   c0002c46 <_ZN3MdbC1EP5SpacemmmPFvP8Rcu_elemES5_>
        }

        ALWAYS_INLINE
        inline Space_mem() : cpus(0), htlb(~0UL), gtlb(~0UL)
c000bcd4:	8d 53 54             	lea    0x54(%ebx),%edx
c000bcd7:	83 c4 10             	add    $0x10,%esp
c000bcda:	c6 43 44 00          	movb   $0x0,0x44(%ebx)
c000bcde:	31 c0                	xor    %eax,%eax
    private:
        uint16 val;

    public:
        ALWAYS_INLINE
        inline Spinlock() : val (0) {}
c000bce0:	66 c7 43 46 00 00    	movw   $0x0,0x46(%ebx)
    private:
        uint32 ref;

    public:
        ALWAYS_INLINE
        inline Refex() : ref (1) {}
c000bce6:	c7 43 48 01 00 00 00 	movl   $0x1,0x48(%ebx)
c000bced:	66 c7 43 4c 00 00    	movw   $0x0,0x4c(%ebx)
    private:
        Spinlock    lock;
        Avl *       tree;

    public:
        Space() : tree (nullptr) {}
c000bcf3:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)

        void free_up (Quota &quota, unsigned l, P *, mword, bool (*) (Paddr, mword, unsigned), bool (*) (unsigned, mword));

    public:

        Pte() : val(0) {}
c000bcfa:	c7 04 02 00 00 00 00 	movl   $0x0,(%edx,%eax,1)
c000bd01:	83 c0 04             	add    $0x4,%eax
c000bd04:	3d 00 01 00 00       	cmp    $0x100,%eax
c000bd09:	75 ef                	jne    c000bcfa <_ZN2PdC1EPS_mm+0x52>
        {
            for (mword i = ACCESS_ONCE(did_f), j = 0; j <= LAST_PCID; i++, j++)
c000bd0b:	a1 cc b4 01 c0       	mov    0xc001b4cc,%eax
c000bd10:	31 f6                	xor    %esi,%esi
c000bd12:	c7 83 54 01 00 00 00 	movl   $0x0,0x154(%ebx)
c000bd19:	00 00 00 
c000bd1c:	c7 83 58 01 00 00 00 	movl   $0x0,0x158(%ebx)
c000bd23:	00 00 00 
c000bd26:	c7 83 5c 01 00 00 00 	movl   $0x0,0x15c(%ebx)
c000bd2d:	00 00 00 
    private:
        mword val;

    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}
c000bd30:	c7 83 6c 01 00 00 00 	movl   $0x0,0x16c(%ebx)
c000bd37:	00 00 00 
c000bd3a:	c7 83 70 01 00 00 ff 	movl   $0xffffffff,0x170(%ebx)
c000bd41:	ff ff ff 
c000bd44:	c7 83 74 01 00 00 ff 	movl   $0xffffffff,0x174(%ebx)
c000bd4b:	ff ff ff 
            {
                i %= (LAST_PCID + 1);
c000bd4e:	83 e0 7f             	and    $0x7f,%eax

                if (ACCESS_ONCE(did_c[i]) == ~0UL)
c000bd51:	8b 14 85 e0 b4 01 c0 	mov    -0x3ffe4b20(,%eax,4),%edx
c000bd58:	42                   	inc    %edx
c000bd59:	74 51                	je     c000bdac <_ZN2PdC1EPS_mm+0x104>
}

ALWAYS_INLINE
inline long int bit_scan_forward (mword val)
{
    if (EXPECT_FALSE (!val))
c000bd5b:	8b 0c 85 e0 b4 01 c0 	mov    -0x3ffe4b20(,%eax,4),%ecx
                    continue;

                long b = bit_scan_forward (~did_c[i]);
                if (b == -1) b = 0;
c000bd62:	31 d2                	xor    %edx,%edx
c000bd64:	83 f1 ff             	xor    $0xffffffff,%ecx
c000bd67:	74 09                	je     c000bd72 <_ZN2PdC1EPS_mm+0xca>
        return -1;

    asm volatile ("bsf %1, %0" : "=r" (val) : "rm" (val));
c000bd69:	0f bc c9             	bsf    %ecx,%ecx
c000bd6c:	83 f9 ff             	cmp    $0xffffffff,%ecx
c000bd6f:	0f 45 d1             	cmovne %ecx,%edx
        template <typename T>
        ALWAYS_INLINE
        static inline bool test_set_bit (T &val, unsigned long bit)
        {
            bool ret;
            asm volatile ("lock; bts%z1 %2, %1; setc %0" : "=q" (ret), "+m" (val) : "ir" (bit) : "cc");
c000bd72:	f0 0f ab 14 85 e0 b4 	lock bts %edx,-0x3ffe4b20(,%eax,4)
c000bd79:	01 c0 
c000bd7b:	0f 92 c1             	setb   %cl

                if (Atomic::test_set_bit (did_c[i], b)) {
c000bd7e:	84 c9                	test   %cl,%cl
c000bd80:	74 04                	je     c000bd86 <_ZN2PdC1EPS_mm+0xde>
                    j--;
c000bd82:	4e                   	dec    %esi
                    i--;
c000bd83:	48                   	dec    %eax
c000bd84:	eb 26                	jmp    c000bdac <_ZN2PdC1EPS_mm+0x104>
                    continue;
                }

                did = i * sizeof(did_c[0]) * 8 + b;
c000bd86:	89 c1                	mov    %eax,%ecx
c000bd88:	c1 e1 05             	shl    $0x5,%ecx
c000bd8b:	01 ca                	add    %ecx,%edx
c000bd8d:	89 93 68 01 00 00    	mov    %edx,0x168(%ebx)

                if (did_c[i] != ~0UL && did_f != i)
c000bd93:	83 3c 85 e0 b4 01 c0 	cmpl   $0xffffffff,-0x3ffe4b20(,%eax,4)
c000bd9a:	ff 
c000bd9b:	74 20                	je     c000bdbd <_ZN2PdC1EPS_mm+0x115>
c000bd9d:	39 05 cc b4 01 c0    	cmp    %eax,0xc001b4cc
c000bda3:	74 18                	je     c000bdbd <_ZN2PdC1EPS_mm+0x115>
                    did_f = i;
c000bda5:	a3 cc b4 01 c0       	mov    %eax,0xc001b4cc
c000bdaa:	eb 11                	jmp    c000bdbd <_ZN2PdC1EPS_mm+0x115>
        }

        ALWAYS_INLINE
        inline Space_mem() : cpus(0), htlb(~0UL), gtlb(~0UL)
        {
            for (mword i = ACCESS_ONCE(did_f), j = 0; j <= LAST_PCID; i++, j++)
c000bdac:	46                   	inc    %esi
c000bdad:	40                   	inc    %eax
c000bdae:	83 fe 7f             	cmp    $0x7f,%esi
c000bdb1:	76 9b                	jbe    c000bd4e <_ZN2PdC1EPS_mm+0xa6>
                    did_f = i;

                return;
            }

            did = NO_PCID;
c000bdb3:	c7 83 68 01 00 00 02 	movl   $0x2,0x168(%ebx)
c000bdba:	00 00 00 
c000bdbd:	8d b3 90 01 00 00    	lea    0x190(%ebx),%esi
c000bdc3:	66 c7 83 78 01 00 00 	movw   $0x0,0x178(%ebx)
c000bdca:	00 00 
c000bdcc:	89 f0                	mov    %esi,%eax
c000bdce:	c7 83 7c 01 00 00 00 	movl   $0x0,0x17c(%ebx)
c000bdd5:	00 00 00 
c000bdd8:	c7 83 80 01 00 00 00 	movl   $0x0,0x180(%ebx)
c000bddf:	00 00 00 
c000bde2:	c7 83 84 01 00 00 00 	movl   $0x0,0x184(%ebx)
c000bde9:	00 00 00 
c000bdec:	66 c7 83 88 01 00 00 	movw   $0x0,0x188(%ebx)
c000bdf3:	00 00 
c000bdf5:	c7 83 8c 01 00 00 00 	movl   $0x0,0x18c(%ebx)
c000bdfc:	00 00 00 
c000bdff:	e8 72 fc ff ff       	call   c000ba76 <_ZN5QuotaC1Ev>
{
    if (this == &Pd::root) {
c000be04:	81 fb 00 b1 01 c0    	cmp    $0xc001b100,%ebx
c000be0a:	75 34                	jne    c000be40 <_ZN2PdC1EPS_mm+0x198>
        bool res = Quota::init.transfer_to(quota, Quota::init.limit());
c000be0c:	8b 0d 7c a3 01 c0    	mov    0xc001a37c,%ecx
c000be12:	89 f2                	mov    %esi,%edx
c000be14:	b8 70 a3 01 c0       	mov    $0xc001a370,%eax
c000be19:	6a 01                	push   $0x1
c000be1b:	e8 cc 6c ff ff       	call   c0002aec <_ZN5Quota11transfer_toERS_mb>
        assert(res);
c000be20:	5a                   	pop    %edx
c000be21:	84 c0                	test   %al,%al
c000be23:	75 1b                	jne    c000be40 <_ZN2PdC1EPS_mm+0x198>
c000be25:	68 b8 8b 01 c0       	push   $0xc0018bb8
c000be2a:	6a 39                	push   $0x39
c000be2c:	68 b1 87 01 c0       	push   $0xc00187b1
c000be31:	68 6f 6b 01 c0       	push   $0xc0016b6f
c000be36:	68 69 60 01 c0       	push   $0xc0016069
c000be3b:	e8 06 5b ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>
    }
}
c000be40:	5b                   	pop    %ebx
c000be41:	5e                   	pop    %esi
c000be42:	c3                   	ret    
c000be43:	90                   	nop

c000be44 <_ZN2Pd5clampEmRmmm>:
        assert (node == mdb);
    }
}

mword Pd::clamp (mword snd_base, mword &rcv_base, mword snd_ord, mword rcv_ord)
{
c000be44:	55                   	push   %ebp
c000be45:	57                   	push   %edi
c000be46:	89 cf                	mov    %ecx,%edi
c000be48:	56                   	push   %esi
c000be49:	53                   	push   %ebx
    if ((snd_base ^ rcv_base) >> max (snd_ord, rcv_ord))
c000be4a:	8b 29                	mov    (%ecx),%ebp
        assert (node == mdb);
    }
}

mword Pd::clamp (mword snd_base, mword &rcv_base, mword snd_ord, mword rcv_ord)
{
c000be4c:	8b 74 24 14          	mov    0x14(%esp),%esi
c000be50:	8b 5c 24 18          	mov    0x18(%esp),%ebx
    if ((snd_base ^ rcv_base) >> max (snd_ord, rcv_ord))
c000be54:	89 e8                	mov    %ebp,%eax
c000be56:	31 d0                	xor    %edx,%eax
c000be58:	89 d9                	mov    %ebx,%ecx
c000be5a:	39 de                	cmp    %ebx,%esi
c000be5c:	0f 43 ce             	cmovae %esi,%ecx
c000be5f:	d3 e8                	shr    %cl,%eax
c000be61:	89 c1                	mov    %eax,%ecx
        return ~0UL;
c000be63:	83 c8 ff             	or     $0xffffffff,%eax
    }
}

mword Pd::clamp (mword snd_base, mword &rcv_base, mword snd_ord, mword rcv_ord)
{
    if ((snd_base ^ rcv_base) >> max (snd_ord, rcv_ord))
c000be66:	85 c9                	test   %ecx,%ecx
c000be68:	75 0b                	jne    c000be75 <_ZN2Pd5clampEmRmmm+0x31>
        return ~0UL;

    rcv_base |= snd_base;
c000be6a:	09 ea                	or     %ebp,%edx
c000be6c:	89 d8                	mov    %ebx,%eax
c000be6e:	39 de                	cmp    %ebx,%esi
c000be70:	89 17                	mov    %edx,(%edi)
c000be72:	0f 46 c6             	cmovbe %esi,%eax

    return min (snd_ord, rcv_ord);
}
c000be75:	5b                   	pop    %ebx
c000be76:	5e                   	pop    %esi
c000be77:	5f                   	pop    %edi
c000be78:	5d                   	pop    %ebp
c000be79:	c3                   	ret    

c000be7a <_ZN2Pd5clampERmS0_mmm>:

mword Pd::clamp (mword &snd_base, mword &rcv_base, mword snd_ord, mword rcv_ord, mword h)
{
c000be7a:	55                   	push   %ebp
c000be7b:	57                   	push   %edi
c000be7c:	56                   	push   %esi
c000be7d:	53                   	push   %ebx
    assert (snd_ord < sizeof (mword) * 8);
c000be7e:	83 7c 24 14 1f       	cmpl   $0x1f,0x14(%esp)
c000be83:	76 16                	jbe    c000be9b <_ZN2Pd5clampERmS0_mmm+0x21>
c000be85:	68 e0 89 01 c0       	push   $0xc00189e0
c000be8a:	68 d2 00 00 00       	push   $0xd2
c000be8f:	68 b1 87 01 c0       	push   $0xc00187b1
c000be94:	68 1c 88 01 c0       	push   $0xc001881c
c000be99:	eb 1b                	jmp    c000beb6 <_ZN2Pd5clampERmS0_mmm+0x3c>
    assert (rcv_ord < sizeof (mword) * 8);
c000be9b:	83 7c 24 18 1f       	cmpl   $0x1f,0x18(%esp)
c000bea0:	76 1e                	jbe    c000bec0 <_ZN2Pd5clampERmS0_mmm+0x46>
c000bea2:	68 e0 89 01 c0       	push   $0xc00189e0
c000bea7:	68 d3 00 00 00       	push   $0xd3
c000beac:	68 b1 87 01 c0       	push   $0xc00187b1
c000beb1:	68 39 88 01 c0       	push   $0xc0018839
c000beb6:	68 69 60 01 c0       	push   $0xc0016069
c000bebb:	e8 86 5a ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>
c000bec0:	89 cf                	mov    %ecx,%edi

    mword s = (1ul << snd_ord) - 1;
c000bec2:	8a 4c 24 14          	mov    0x14(%esp),%cl
c000bec6:	bb 01 00 00 00       	mov    $0x1,%ebx
c000becb:	89 de                	mov    %ebx,%esi
c000becd:	d3 e6                	shl    %cl,%esi
    mword r = (1ul << rcv_ord) - 1;
c000becf:	8a 4c 24 18          	mov    0x18(%esp),%cl
mword Pd::clamp (mword &snd_base, mword &rcv_base, mword snd_ord, mword rcv_ord, mword h)
{
    assert (snd_ord < sizeof (mword) * 8);
    assert (rcv_ord < sizeof (mword) * 8);

    mword s = (1ul << snd_ord) - 1;
c000bed3:	8d 46 ff             	lea    -0x1(%esi),%eax
    mword r = (1ul << rcv_ord) - 1;

    snd_base &= ~s;
c000bed6:	89 c5                	mov    %eax,%ebp
c000bed8:	f7 d5                	not    %ebp
c000beda:	21 2a                	and    %ebp,(%edx)
{
    assert (snd_ord < sizeof (mword) * 8);
    assert (rcv_ord < sizeof (mword) * 8);

    mword s = (1ul << snd_ord) - 1;
    mword r = (1ul << rcv_ord) - 1;
c000bedc:	d3 e3                	shl    %cl,%ebx
c000bede:	4b                   	dec    %ebx

    snd_base &= ~s;
    rcv_base &= ~r;
c000bedf:	8b 0f                	mov    (%edi),%ecx
c000bee1:	89 de                	mov    %ebx,%esi
c000bee3:	f7 d6                	not    %esi
c000bee5:	21 f1                	and    %esi,%ecx

    if (EXPECT_TRUE (s < r)) {
c000bee7:	39 d8                	cmp    %ebx,%eax

    mword s = (1ul << snd_ord) - 1;
    mword r = (1ul << rcv_ord) - 1;

    snd_base &= ~s;
    rcv_base &= ~r;
c000bee9:	89 0f                	mov    %ecx,(%edi)

    if (EXPECT_TRUE (s < r)) {
c000beeb:	73 10                	jae    c000befd <_ZN2Pd5clampERmS0_mmm+0x83>
        rcv_base |= h & r & ~s;
c000beed:	23 5c 24 1c          	and    0x1c(%esp),%ebx
        return snd_ord;
c000bef1:	8b 44 24 14          	mov    0x14(%esp),%eax

    snd_base &= ~s;
    rcv_base &= ~r;

    if (EXPECT_TRUE (s < r)) {
        rcv_base |= h & r & ~s;
c000bef5:	21 eb                	and    %ebp,%ebx
c000bef7:	09 d9                	or     %ebx,%ecx
c000bef9:	89 0f                	mov    %ecx,(%edi)
        return snd_ord;
c000befb:	eb 0c                	jmp    c000bf09 <_ZN2Pd5clampERmS0_mmm+0x8f>
c000befd:	21 c6                	and    %eax,%esi
    } else {
        snd_base |= h & s & ~r;
        return rcv_ord;
c000beff:	8b 44 24 18          	mov    0x18(%esp),%eax

    if (EXPECT_TRUE (s < r)) {
        rcv_base |= h & r & ~s;
        return snd_ord;
    } else {
        snd_base |= h & s & ~r;
c000bf03:	23 74 24 1c          	and    0x1c(%esp),%esi
c000bf07:	09 32                	or     %esi,(%edx)
        return rcv_ord;
    }
}
c000bf09:	5b                   	pop    %ebx
c000bf0a:	5e                   	pop    %esi
c000bf0b:	5f                   	pop    %edi
c000bf0c:	5d                   	pop    %ebp
c000bf0d:	c3                   	ret    

c000bf0e <_ZN2Pd7xlt_crdEPS_3CrdRS1_>:

void Pd::xlt_crd (Pd *pd, Crd xlt, Crd &crd)
{
c000bf0e:	55                   	push   %ebp
c000bf0f:	57                   	push   %edi
c000bf10:	56                   	push   %esi
    Crd::Type t = xlt.type();

    if (t && t == crd.type()) {
c000bf11:	89 ce                	mov    %ecx,%esi
        return rcv_ord;
    }
}

void Pd::xlt_crd (Pd *pd, Crd xlt, Crd &crd)
{
c000bf13:	53                   	push   %ebx
c000bf14:	83 ec 20             	sub    $0x20,%esp
    Crd::Type t = xlt.type();

    if (t && t == crd.type()) {
c000bf17:	83 e6 03             	and    $0x3,%esi
        return rcv_ord;
    }
}

void Pd::xlt_crd (Pd *pd, Crd xlt, Crd &crd)
{
c000bf1a:	8b 6c 24 34          	mov    0x34(%esp),%ebp
    Crd::Type t = xlt.type();

    if (t && t == crd.type()) {
c000bf1e:	0f 84 85 00 00 00    	je     c000bfa9 <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0x9b>

        ALWAYS_INLINE
        inline explicit Crd (Type t, mword b = 0, mword o = 0x1f, mword a = 0x1f) : val (b << 12 | o << 7 | a << 2 | t) {}

        ALWAYS_INLINE
        inline Type type() const { return static_cast<Type>(val & 0x3); }
c000bf24:	8b 5d 00             	mov    0x0(%ebp),%ebx
c000bf27:	89 df                	mov    %ebx,%edi
c000bf29:	83 e7 03             	and    $0x3,%edi
c000bf2c:	39 fe                	cmp    %edi,%esi
c000bf2e:	75 79                	jne    c000bfa9 <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0x9b>
c000bf30:	e9 80 00 00 00       	jmp    c000bfb5 <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0xa7>
        }

        ALWAYS_INLINE
        inline Space *subspace (Crd::Type t)
        {
            switch (t) {
c000bf35:	83 fe 03             	cmp    $0x3,%esi
c000bf38:	0f 84 b1 00 00 00    	je     c000bfef <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0xe1>
                case Crd::MEM:  return static_cast<Space_mem *>(this);
c000bf3e:	8d 7a 4c             	lea    0x4c(%edx),%edi
c000bf41:	89 3c 24             	mov    %edi,(%esp)
c000bf44:	8d 78 4c             	lea    0x4c(%eax),%edi
c000bf47:	89 44 24 08          	mov    %eax,0x8(%esp)

        ALWAYS_INLINE
        inline unsigned order() const { return val >> 7 & 0x1f; }

        ALWAYS_INLINE
        inline mword base() const { return val >> 12; }
c000bf4b:	89 c8                	mov    %ecx,%eax
c000bf4d:	89 da                	mov    %ebx,%edx
c000bf4f:	c1 e8 0c             	shr    $0xc,%eax
c000bf52:	89 44 24 0c          	mov    %eax,0xc(%esp)

        ALWAYS_INLINE
        inline unsigned attr() const { return val >> 2 & 0x1f; }

        ALWAYS_INLINE
        inline unsigned order() const { return val >> 7 & 0x1f; }
c000bf56:	c1 e9 07             	shr    $0x7,%ecx

        Space *snd = pd->subspace (t), *rcv = subspace (t);
        mword sb = crd.base(), so = crd.order(), rb = xlt.base(), ro = xlt.order();
c000bf59:	89 44 24 1c          	mov    %eax,0x1c(%esp)
        Mdb *mdb, *node;

        for (node = mdb = snd->tree_lookup (sb); node; node = node->prnt)
c000bf5d:	8b 04 24             	mov    (%esp),%eax
c000bf60:	83 e1 1f             	and    $0x1f,%ecx
c000bf63:	c1 eb 07             	shr    $0x7,%ebx

        ALWAYS_INLINE
        inline mword base() const { return val >> 12; }
c000bf66:	c1 ea 0c             	shr    $0xc,%edx

        ALWAYS_INLINE
        inline unsigned attr() const { return val >> 2 & 0x1f; }

        ALWAYS_INLINE
        inline unsigned order() const { return val >> 7 & 0x1f; }
c000bf69:	83 e3 1f             	and    $0x1f,%ebx
c000bf6c:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c000bf70:	31 c9                	xor    %ecx,%ecx
                case Crd::PIO:  return static_cast<Space_pio *>(this);
                case Crd::OBJ:  return static_cast<Space_obj *>(this);
c000bf72:	89 7c 24 04          	mov    %edi,0x4(%esp)
c000bf76:	89 5c 24 14          	mov    %ebx,0x14(%esp)
    Crd::Type t = xlt.type();

    if (t && t == crd.type()) {

        Space *snd = pd->subspace (t), *rcv = subspace (t);
        mword sb = crd.base(), so = crd.order(), rb = xlt.base(), ro = xlt.order();
c000bf7a:	89 54 24 18          	mov    %edx,0x18(%esp)
        Mdb *mdb, *node;

        for (node = mdb = snd->tree_lookup (sb); node; node = node->prnt)
c000bf7e:	e8 57 fb ff ff       	call   c000bada <_ZN5Space11tree_lookupEmb>
    Crd::Type t = xlt.type();

    if (t && t == crd.type()) {

        Space *snd = pd->subspace (t), *rcv = subspace (t);
        mword sb = crd.base(), so = crd.order(), rb = xlt.base(), ro = xlt.order();
c000bf83:	8b 7c 24 10          	mov    0x10(%esp),%edi
        Mdb *mdb, *node;

        for (node = mdb = snd->tree_lookup (sb); node; node = node->prnt)
c000bf87:	89 c6                	mov    %eax,%esi
c000bf89:	89 c3                	mov    %eax,%ebx
c000bf8b:	85 db                	test   %ebx,%ebx
c000bf8d:	75 43                	jne    c000bfd2 <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0xc4>

        ALWAYS_INLINE
        inline mword base() const { return val >> 12; }
c000bf8f:	8b 55 00             	mov    0x0(%ebp),%edx
        if (!node) {
            /* Special handling on Genode:
             * If a translate of an item inside the same PD (receiver/sender in same PD)
             * are of no success, then return the very same item.
             */
            Mdb *first = snd->tree_lookup (crd.base());
c000bf92:	31 c9                	xor    %ecx,%ecx
c000bf94:	8b 04 24             	mov    (%esp),%eax
c000bf97:	c1 ea 0c             	shr    $0xc,%edx
c000bf9a:	e8 3b fb ff ff       	call   c000bada <_ZN5Space11tree_lookupEmb>
            if (first && first->space == rcv && first == mdb) {
c000bf9f:	85 c0                	test   %eax,%eax
        if (!node) {
            /* Special handling on Genode:
             * If a translate of an item inside the same PD (receiver/sender in same PD)
             * are of no success, then return the very same item.
             */
            Mdb *first = snd->tree_lookup (crd.base());
c000bfa1:	89 c3                	mov    %eax,%ebx
            if (first && first->space == rcv && first == mdb) {
c000bfa3:	74 04                	je     c000bfa9 <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0x9b>
c000bfa5:	39 f3                	cmp    %esi,%ebx
c000bfa7:	74 5a                	je     c000c003 <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0xf5>
                return;
            }
        }
    }

    crd = Crd (0);
c000bfa9:	c7 45 00 00 00 00 00 	movl   $0x0,0x0(%ebp)
c000bfb0:	e9 06 01 00 00       	jmp    c000c0bb <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0x1ad>
        }

        ALWAYS_INLINE
        inline Space *subspace (Crd::Type t)
        {
            switch (t) {
c000bfb5:	83 fe 02             	cmp    $0x2,%esi
c000bfb8:	0f 85 77 ff ff ff    	jne    c000bf35 <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0x27>
                case Crd::MEM:  return static_cast<Space_mem *>(this);
                case Crd::PIO:  return static_cast<Space_pio *>(this);
c000bfbe:	8d b2 78 01 00 00    	lea    0x178(%edx),%esi
c000bfc4:	89 34 24             	mov    %esi,(%esp)
c000bfc7:	8d b8 78 01 00 00    	lea    0x178(%eax),%edi
c000bfcd:	e9 75 ff ff ff       	jmp    c000bf47 <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0x39>
        Space *snd = pd->subspace (t), *rcv = subspace (t);
        mword sb = crd.base(), so = crd.order(), rb = xlt.base(), ro = xlt.order();
        Mdb *mdb, *node;

        for (node = mdb = snd->tree_lookup (sb); node; node = node->prnt)
            if (node->space == rcv && node != mdb && node->accessible())
c000bfd2:	39 f3                	cmp    %esi,%ebx
c000bfd4:	74 14                	je     c000bfea <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0xdc>
c000bfd6:	8b 44 24 04          	mov    0x4(%esp),%eax
c000bfda:	39 43 28             	cmp    %eax,0x28(%ebx)
c000bfdd:	75 0b                	jne    c000bfea <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0xdc>
        static inline void destroy (Mdb *obj, Quota &quota) { obj->~Mdb(); cache.free (obj, quota); }

        template <typename T> void destroy (T *, Quota &);

        ALWAYS_INLINE
        inline bool accessible() const { return !Avl::removed() && !Avl::invalid(); }
c000bfdf:	66 8b 43 0a          	mov    0xa(%ebx),%ax
c000bfe3:	48                   	dec    %eax
c000bfe4:	66 83 f8 02          	cmp    $0x2,%ax
c000bfe8:	77 4f                	ja     c000c039 <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0x12b>

        Space *snd = pd->subspace (t), *rcv = subspace (t);
        mword sb = crd.base(), so = crd.order(), rb = xlt.base(), ro = xlt.order();
        Mdb *mdb, *node;

        for (node = mdb = snd->tree_lookup (sb); node; node = node->prnt)
c000bfea:	8b 5b 24             	mov    0x24(%ebx),%ebx
c000bfed:	eb 9c                	jmp    c000bf8b <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0x7d>
                case Crd::OBJ:  return static_cast<Space_obj *>(this);
c000bfef:	8d b2 88 01 00 00    	lea    0x188(%edx),%esi
c000bff5:	89 34 24             	mov    %esi,(%esp)
c000bff8:	8d b8 88 01 00 00    	lea    0x188(%eax),%edi
c000bffe:	e9 44 ff ff ff       	jmp    c000bf47 <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0x39>
            /* Special handling on Genode:
             * If a translate of an item inside the same PD (receiver/sender in same PD)
             * are of no success, then return the very same item.
             */
            Mdb *first = snd->tree_lookup (crd.base());
            if (first && first->space == rcv && first == mdb) {
c000c003:	8b 44 24 04          	mov    0x4(%esp),%eax
c000c007:	39 43 28             	cmp    %eax,0x28(%ebx)
c000c00a:	75 9d                	jne    c000bfa9 <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0x9b>
                rb = xlt.base();
c000c00c:	8b 44 24 0c          	mov    0xc(%esp),%eax
                ro = xlt.order();
                if ((ro = clamp (first->node_base, rb, first->node_order, ro)) != ~0UL)
c000c010:	8b 53 30             	mov    0x30(%ebx),%edx
             * If a translate of an item inside the same PD (receiver/sender in same PD)
             * are of no success, then return the very same item.
             */
            Mdb *first = snd->tree_lookup (crd.base());
            if (first && first->space == rcv && first == mdb) {
                rb = xlt.base();
c000c013:	89 44 24 1c          	mov    %eax,0x1c(%esp)
                ro = xlt.order();
                if ((ro = clamp (first->node_base, rb, first->node_order, ro)) != ~0UL)
c000c017:	ff 74 24 10          	pushl  0x10(%esp)
c000c01b:	ff 73 34             	pushl  0x34(%ebx)
c000c01e:	8b 44 24 10          	mov    0x10(%esp),%eax
c000c022:	8d 4c 24 24          	lea    0x24(%esp),%ecx
c000c026:	e8 19 fe ff ff       	call   c000be44 <_ZN2Pd5clampEmRmmm>
c000c02b:	59                   	pop    %ecx
c000c02c:	89 c7                	mov    %eax,%edi
c000c02e:	83 ff ff             	cmp    $0xffffffff,%edi
c000c031:	58                   	pop    %eax
c000c032:	75 22                	jne    c000c056 <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0x148>
c000c034:	e9 70 ff ff ff       	jmp    c000bfa9 <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0x9b>
        mword sb = crd.base(), so = crd.order(), rb = xlt.base(), ro = xlt.order();
        Mdb *mdb, *node;

        for (node = mdb = snd->tree_lookup (sb); node; node = node->prnt)
            if (node->space == rcv && node != mdb && node->accessible())
                if ((ro = clamp (node->node_base, rb, node->node_order, ro)) != ~0UL)
c000c039:	8b 53 30             	mov    0x30(%ebx),%edx
c000c03c:	57                   	push   %edi
c000c03d:	ff 73 34             	pushl  0x34(%ebx)
c000c040:	8b 44 24 10          	mov    0x10(%esp),%eax
c000c044:	8d 4c 24 24          	lea    0x24(%esp),%ecx
c000c048:	e8 f7 fd ff ff       	call   c000be44 <_ZN2Pd5clampEmRmmm>
c000c04d:	89 c7                	mov    %eax,%edi
c000c04f:	58                   	pop    %eax
c000c050:	83 ff ff             	cmp    $0xffffffff,%edi
c000c053:	5a                   	pop    %edx
c000c054:	74 94                	je     c000bfea <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0xdc>
           }
        }

        if (node) {

            so = clamp (mdb->node_base, sb, mdb->node_order, so);
c000c056:	8b 56 30             	mov    0x30(%esi),%edx
c000c059:	ff 74 24 14          	pushl  0x14(%esp)
c000c05d:	ff 76 34             	pushl  0x34(%esi)
c000c060:	8b 44 24 10          	mov    0x10(%esp),%eax
c000c064:	8d 4c 24 20          	lea    0x20(%esp),%ecx
c000c068:	e8 d7 fd ff ff       	call   c000be44 <_ZN2Pd5clampEmRmmm>
c000c06d:	8b 54 24 20          	mov    0x20(%esp),%edx
c000c071:	03 56 2c             	add    0x2c(%esi),%edx
c000c074:	03 53 30             	add    0x30(%ebx),%edx
c000c077:	2b 56 30             	sub    0x30(%esi),%edx
            sb = (sb - mdb->node_base) + (mdb->node_phys - node->node_phys) + node->node_base;
c000c07a:	2b 53 2c             	sub    0x2c(%ebx),%edx
c000c07d:	89 54 24 20          	mov    %edx,0x20(%esp)

            if ((ro = clamp (sb, rb, so, ro)) != ~0UL) {
c000c081:	57                   	push   %edi
c000c082:	50                   	push   %eax
c000c083:	8b 44 24 18          	mov    0x18(%esp),%eax
c000c087:	8d 4c 24 2c          	lea    0x2c(%esp),%ecx
c000c08b:	e8 b4 fd ff ff       	call   c000be44 <_ZN2Pd5clampEmRmmm>
c000c090:	83 c4 10             	add    $0x10,%esp
c000c093:	83 f8 ff             	cmp    $0xffffffff,%eax
c000c096:	0f 84 0d ff ff ff    	je     c000bfa9 <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0x9b>

        ALWAYS_INLINE
        inline explicit Crd (Type t, mword b = 0, mword o = 0x1f, mword a = 0x1f) : val (b << 12 | o << 7 | a << 2 | t) {}

        ALWAYS_INLINE
        inline Type type() const { return static_cast<Type>(val & 0x3); }
c000c09c:	8b 55 00             	mov    0x0(%ebp),%edx

        ALWAYS_INLINE
        inline explicit Crd (mword v) : val (v) {}

        ALWAYS_INLINE
        inline explicit Crd (Type t, mword b = 0, mword o = 0x1f, mword a = 0x1f) : val (b << 12 | o << 7 | a << 2 | t) {}
c000c09f:	c1 e0 07             	shl    $0x7,%eax
c000c0a2:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx

        ALWAYS_INLINE
        inline Type type() const { return static_cast<Type>(val & 0x3); }
c000c0a6:	83 e2 03             	and    $0x3,%edx

        ALWAYS_INLINE
        inline explicit Crd (mword v) : val (v) {}

        ALWAYS_INLINE
        inline explicit Crd (Type t, mword b = 0, mword o = 0x1f, mword a = 0x1f) : val (b << 12 | o << 7 | a << 2 | t) {}
c000c0a9:	c1 e1 0c             	shl    $0xc,%ecx
c000c0ac:	09 ca                	or     %ecx,%edx
c000c0ae:	8b 4e 38             	mov    0x38(%esi),%ecx
c000c0b1:	c1 e1 02             	shl    $0x2,%ecx
c000c0b4:	09 ca                	or     %ecx,%edx
c000c0b6:	09 c2                	or     %eax,%edx
c000c0b8:	89 55 00             	mov    %edx,0x0(%ebp)
            }
        }
    }

    crd = Crd (0);
}
c000c0bb:	83 c4 20             	add    $0x20,%esp
c000c0be:	5b                   	pop    %ebx
c000c0bf:	5e                   	pop    %esi
c000c0c0:	5f                   	pop    %edi
c000c0c1:	5d                   	pop    %ebp
c000c0c2:	c3                   	ret    

c000c0c3 <__cxa_atexit>:
    for (unsigned cpu = 0; cpu < NUM_CPU; cpu++)
        if (Hip::cpu_online (cpu))
            Space_mem::loc[cpu].clear(quota, Space_mem::hpt.dest_loc, Space_mem::hpt.iter_loc_lev);
}

extern "C" int __cxa_atexit(void (*)(void *), void *, void *) { return 0; }
c000c0c3:	31 c0                	xor    %eax,%eax
c000c0c5:	c3                   	ret    

c000c0c6 <_ZN2Pd6revokeI9Space_memEEvmmmbb>:

    return s;
}

template <typename S>
void Pd::revoke (mword const base, mword const ord, mword const attr, bool self, bool kim)
c000c0c6:	55                   	push   %ebp
c000c0c7:	57                   	push   %edi
c000c0c8:	56                   	push   %esi
c000c0c9:	53                   	push   %ebx
c000c0ca:	83 ec 3c             	sub    $0x3c,%esp
c000c0cd:	89 04 24             	mov    %eax,(%esp)
c000c0d0:	8a 44 24 58          	mov    0x58(%esp),%al
c000c0d4:	89 54 24 08          	mov    %edx,0x8(%esp)
c000c0d8:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c000c0dc:	88 44 24 13          	mov    %al,0x13(%esp)

        unsigned d = node->dpth; bool demote = false;

        for (Mdb *ptr;; node = ptr) {

            if (node->dpth == d + !self)
c000c0e0:	8a 44 24 54          	mov    0x54(%esp),%al
c000c0e4:	34 01                	xor    $0x1,%al
c000c0e6:	0f b6 c0             	movzbl %al,%eax
c000c0e9:	89 44 24 18          	mov    %eax,0x18(%esp)

template <typename S>
void Pd::revoke (mword const base, mword const ord, mword const attr, bool self, bool kim)
{
    Mdb *mdb;
    for (mword addr = base; (mdb = S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {
c000c0ed:	8b 04 24             	mov    (%esp),%eax
c000c0f0:	b9 01 00 00 00       	mov    $0x1,%ecx
c000c0f5:	83 c0 4c             	add    $0x4c,%eax
c000c0f8:	e8 dd f9 ff ff       	call   c000bada <_ZN5Space11tree_lookupEmb>
c000c0fd:	85 c0                	test   %eax,%eax
c000c0ff:	89 c7                	mov    %eax,%edi
c000c101:	0f 84 a6 02 00 00    	je     c000c3ad <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x2e7>

        mword o, p, b = base;
c000c107:	8b 44 24 08          	mov    0x8(%esp),%eax
        if ((o = clamp (mdb->node_base, b, mdb->node_order, ord)) == ~0UL)
c000c10b:	8b 57 30             	mov    0x30(%edi),%edx
void Pd::revoke (mword const base, mword const ord, mword const attr, bool self, bool kim)
{
    Mdb *mdb;
    for (mword addr = base; (mdb = S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {

        mword o, p, b = base;
c000c10e:	89 44 24 20          	mov    %eax,0x20(%esp)
        if ((o = clamp (mdb->node_base, b, mdb->node_order, ord)) == ~0UL)
c000c112:	ff 74 24 0c          	pushl  0xc(%esp)
c000c116:	ff 77 34             	pushl  0x34(%edi)
c000c119:	8b 44 24 08          	mov    0x8(%esp),%eax
c000c11d:	8d 4c 24 28          	lea    0x28(%esp),%ecx
c000c121:	e8 1e fd ff ff       	call   c000be44 <_ZN2Pd5clampEmRmmm>
c000c126:	5b                   	pop    %ebx
c000c127:	5e                   	pop    %esi
c000c128:	83 f8 ff             	cmp    $0xffffffff,%eax
c000c12b:	89 c5                	mov    %eax,%ebp
c000c12d:	0f 84 7a 02 00 00    	je     c000c3ad <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x2e7>
c000c133:	0f b7 47 1a          	movzwl 0x1a(%edi),%eax
            break;

        /* keep in mapping database if requested and at least one child node exists */
        if (kim && (ACCESS_ONCE(mdb->next)->dpth > mdb->dpth)) {
c000c137:	80 7c 24 13 00       	cmpb   $0x0,0x13(%esp)
c000c13c:	89 44 24 04          	mov    %eax,0x4(%esp)
c000c140:	74 6c                	je     c000c1ae <_ZN2Pd6revokeI9Space_memEEvmmmbb+0xe8>
c000c142:	8b 47 20             	mov    0x20(%edi),%eax
c000c145:	0f b7 40 1a          	movzwl 0x1a(%eax),%eax
c000c149:	3b 44 24 04          	cmp    0x4(%esp),%eax
c000c14d:	76 5f                	jbe    c000c1ae <_ZN2Pd6revokeI9Space_memEEvmmmbb+0xe8>
        Quota q;
        Quota &r;

    public:

        Quota_guard(Quota &ref) : q(), r(ref) { }
c000c14f:	8d 44 24 24          	lea    0x24(%esp),%eax
c000c153:	e8 1e f9 ff ff       	call   c000ba76 <_ZN5QuotaC1Ev>
            Quota_guard qg(this->quota);
c000c158:	8b 04 24             	mov    (%esp),%eax
c000c15b:	05 90 01 00 00       	add    $0x190,%eax
c000c160:	89 44 24 38          	mov    %eax,0x38(%esp)
            if (mdb->node_attr & 0x1f) {
c000c164:	f6 47 38 1f          	testb  $0x1f,0x38(%edi)
c000c168:	74 1d                	je     c000c187 <_ZN2Pd6revokeI9Space_memEEvmmmbb+0xc1>
                static_cast<S *>(mdb->space)->update (qg, mdb, 0x1f);
c000c16a:	8b 47 28             	mov    0x28(%edi),%eax
c000c16d:	89 f9                	mov    %edi,%ecx
c000c16f:	6a 1f                	push   $0x1f
c000c171:	8d 54 24 28          	lea    0x28(%esp),%edx
c000c175:	e8 90 46 00 00       	call   c001080a <_ZN9Space_mem6updateER11Quota_guardP3Mdbm>
                mdb->demote_node (0x1f);
c000c17a:	ba 1f 00 00 00       	mov    $0x1f,%edx
c000c17f:	89 f8                	mov    %edi,%eax
c000c181:	e8 7e a0 ff ff       	call   c0006204 <_ZN3Mdb11demote_nodeEm>
c000c186:	59                   	pop    %ecx
            }
            static_cast<S *>(mdb->space)->tree_remove (mdb, Avl::State::KIM);
c000c187:	ba 02 00 00 00       	mov    $0x2,%edx
c000c18c:	89 f8                	mov    %edi,%eax
c000c18e:	e8 88 fa ff ff       	call   c000bc1b <_ZN5Space11tree_removeEP3MdbN3Avl5StateE>
            continue;
c000c193:	8d 44 24 24          	lea    0x24(%esp),%eax
c000c197:	e8 36 f9 ff ff       	call   c000bad2 <_ZN11Quota_guardD1Ev>

template <typename S>
void Pd::revoke (mword const base, mword const ord, mword const attr, bool self, bool kim)
{
    Mdb *mdb;
    for (mword addr = base; (mdb = S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {
c000c19c:	8b 4f 34             	mov    0x34(%edi),%ecx
c000c19f:	ba 01 00 00 00       	mov    $0x1,%edx
c000c1a4:	d3 e2                	shl    %cl,%edx
c000c1a6:	03 57 30             	add    0x30(%edi),%edx
c000c1a9:	e9 3f ff ff ff       	jmp    c000c0ed <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x27>

        unsigned d = node->dpth; bool demote = false;

        for (Mdb *ptr;; node = ptr) {

            if (node->dpth == d + !self)
c000c1ae:	8b 44 24 18          	mov    0x18(%esp),%eax
            continue;
        }

        Mdb *node = mdb;

        unsigned d = node->dpth; bool demote = false;
c000c1b2:	89 fe                	mov    %edi,%esi
c000c1b4:	31 db                	xor    %ebx,%ebx

        for (Mdb *ptr;; node = ptr) {

            if (node->dpth == d + !self)
c000c1b6:	03 44 24 04          	add    0x4(%esp),%eax
c000c1ba:	89 44 24 14          	mov    %eax,0x14(%esp)
c000c1be:	0f b7 46 1a          	movzwl 0x1a(%esi),%eax
c000c1c2:	3b 44 24 14          	cmp    0x14(%esp),%eax
c000c1c6:	75 29                	jne    c000c1f1 <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x12b>
c000c1c8:	8b 44 24 20          	mov    0x20(%esp),%eax
c000c1cc:	03 47 2c             	add    0x2c(%edi),%eax
                demote = clamp (node->node_phys, p = b - mdb->node_base + mdb->node_phys, node->node_order, o) != ~0UL;
c000c1cf:	8b 4e 34             	mov    0x34(%esi),%ecx
c000c1d2:	2b 47 30             	sub    0x30(%edi),%eax
c000c1d5:	8b 56 2c             	mov    0x2c(%esi),%edx
c000c1d8:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c000c1dc:	55                   	push   %ebp
c000c1dd:	51                   	push   %ecx
c000c1de:	8b 44 24 08          	mov    0x8(%esp),%eax
c000c1e2:	8d 4c 24 24          	lea    0x24(%esp),%ecx
c000c1e6:	e8 59 fc ff ff       	call   c000be44 <_ZN2Pd5clampEmRmmm>
c000c1eb:	5b                   	pop    %ebx
c000c1ec:	5a                   	pop    %edx
c000c1ed:	40                   	inc    %eax
c000c1ee:	0f 95 c3             	setne  %bl

            if (demote && node->node_attr & attr) {
c000c1f1:	84 db                	test   %bl,%bl
c000c1f3:	74 45                	je     c000c23a <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x174>
c000c1f5:	8b 46 38             	mov    0x38(%esi),%eax
c000c1f8:	85 44 24 50          	test   %eax,0x50(%esp)
c000c1fc:	74 3c                	je     c000c23a <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x174>
c000c1fe:	8d 44 24 24          	lea    0x24(%esp),%eax
c000c202:	e8 6f f8 ff ff       	call   c000ba76 <_ZN5QuotaC1Ev>
                Quota_guard qg(this->quota);
c000c207:	8b 04 24             	mov    (%esp),%eax
                static_cast<S *>(node->space)->update (qg, node, attr);
c000c20a:	89 f1                	mov    %esi,%ecx

            if (node->dpth == d + !self)
                demote = clamp (node->node_phys, p = b - mdb->node_base + mdb->node_phys, node->node_order, o) != ~0UL;

            if (demote && node->node_attr & attr) {
                Quota_guard qg(this->quota);
c000c20c:	05 90 01 00 00       	add    $0x190,%eax
c000c211:	89 44 24 38          	mov    %eax,0x38(%esp)
                static_cast<S *>(node->space)->update (qg, node, attr);
c000c215:	8b 46 28             	mov    0x28(%esi),%eax
c000c218:	ff 74 24 50          	pushl  0x50(%esp)
c000c21c:	8d 54 24 28          	lea    0x28(%esp),%edx
c000c220:	e8 e5 45 00 00       	call   c001080a <_ZN9Space_mem6updateER11Quota_guardP3Mdbm>
                node->demote_node (attr);
c000c225:	8b 54 24 54          	mov    0x54(%esp),%edx
c000c229:	89 f0                	mov    %esi,%eax
c000c22b:	e8 d4 9f ff ff       	call   c0006204 <_ZN3Mdb11demote_nodeEm>
c000c230:	8d 44 24 28          	lea    0x28(%esp),%eax
c000c234:	e8 99 f8 ff ff       	call   c000bad2 <_ZN11Quota_guardD1Ev>
c000c239:	59                   	pop    %ecx
            }

            ptr = ACCESS_ONCE (node->next);
c000c23a:	8b 46 20             	mov    0x20(%esi),%eax

            if (ptr->dpth <= d)
c000c23d:	0f b7 50 1a          	movzwl 0x1a(%eax),%edx
c000c241:	3b 54 24 04          	cmp    0x4(%esp),%edx
c000c245:	76 07                	jbe    c000c24e <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x188>
c000c247:	89 c6                	mov    %eax,%esi
c000c249:	e9 70 ff ff ff       	jmp    c000c1be <_ZN2Pd6revokeI9Space_memEEvmmmbb+0xf8>
                break;
        }

        Mdb *x = ACCESS_ONCE (node->next);
c000c24e:	8b 56 20             	mov    0x20(%esi),%edx
        assert (x->dpth <= d || (x->dpth == node->dpth + 1 && !(x->node_attr & attr)));
c000c251:	0f b7 4a 1a          	movzwl 0x1a(%edx),%ecx
c000c255:	3b 4c 24 04          	cmp    0x4(%esp),%ecx
c000c259:	76 30                	jbe    c000c28b <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x1c5>
c000c25b:	0f b7 46 1a          	movzwl 0x1a(%esi),%eax
c000c25f:	40                   	inc    %eax
c000c260:	39 c1                	cmp    %eax,%ecx
c000c262:	75 09                	jne    c000c26d <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x1a7>
c000c264:	8b 42 38             	mov    0x38(%edx),%eax
c000c267:	85 44 24 50          	test   %eax,0x50(%esp)
c000c26b:	74 1e                	je     c000c28b <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x1c5>
c000c26d:	68 40 8b 01 c0       	push   $0xc0018b40
c000c272:	68 ad 00 00 00       	push   $0xad
c000c277:	68 b1 87 01 c0       	push   $0xc00187b1
c000c27c:	68 62 88 01 c0       	push   $0xc0018862
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000c281:	68 69 60 01 c0       	push   $0xc0016069
c000c286:	e8 bb 56 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

        bool preempt = Cpu::preemption;
c000c28b:	8a 1d 00 f7 ff cf    	mov    0xcffff700,%bl

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
                trace (0, "warning: rcu element already enqueued");
c000c291:	8d 6c 24 23          	lea    0x23(%esp),%ebp
c000c295:	81 e5 00 f0 ff ff    	and    $0xfffff000,%ebp
c000c29b:	89 6c 24 14          	mov    %ebp,0x14(%esp)

        for (Mdb *ptr;; node = ptr) {

            if (preempt)
c000c29f:	84 db                	test   %bl,%bl
c000c2a1:	74 27                	je     c000c2ca <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x204>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c000c2a3:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000c2aa:	75 16                	jne    c000c2c2 <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x1fc>
c000c2ac:	68 20 8c 01 c0       	push   $0xc0018c20
c000c2b1:	68 b7 00 00 00       	push   $0xb7
c000c2b6:	68 12 61 01 c0       	push   $0xc0016112
c000c2bb:	68 83 61 01 c0       	push   $0xc0016183
c000c2c0:	eb bf                	jmp    c000c281 <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x1bb>

            asm volatile ("cli" : : : "memory");
c000c2c2:	fa                   	cli    
            preemption = false;
c000c2c3:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            if (node->remove_node() && static_cast<S *>(node->space)->tree_remove (node))
c000c2ca:	89 f0                	mov    %esi,%eax
c000c2cc:	e8 b9 9f ff ff       	call   c000628a <_ZN3Mdb11remove_nodeEv>
c000c2d1:	84 c0                	test   %al,%al
c000c2d3:	74 51                	je     c000c326 <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x260>
c000c2d5:	ba 01 00 00 00       	mov    $0x1,%edx
c000c2da:	89 f0                	mov    %esi,%eax
c000c2dc:	e8 3a f9 ff ff       	call   c000bc1b <_ZN5Space11tree_removeEP3MdbN3Avl5StateE>
c000c2e1:	84 c0                	test   %al,%al
c000c2e3:	74 41                	je     c000c326 <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x260>
                Rcu::call (node);
c000c2e5:	85 f6                	test   %esi,%esi
c000c2e7:	0f 84 b9 00 00 00    	je     c000c3a6 <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x2e0>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
c000c2ed:	8b 4e 14             	mov    0x14(%esi),%ecx
c000c2f0:	8d 6e 0c             	lea    0xc(%esi),%ebp
c000c2f3:	85 c9                	test   %ecx,%ecx
c000c2f5:	74 04                	je     c000c2fb <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x235>
                e->pre_func(e);
c000c2f7:	89 e8                	mov    %ebp,%eax
c000c2f9:	ff d1                	call   *%ecx
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
c000c2fb:	83 7e 0c 00          	cmpl   $0x0,0xc(%esi)
c000c2ff:	0f 84 84 00 00 00    	je     c000c389 <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x2c3>
                trace (0, "warning: rcu element already enqueued");
c000c305:	81 7c 24 14 00 d0 ff 	cmpl   $0xcfffd000,0x14(%esp)
c000c30c:	cf 
c000c30d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000c312:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c000c319:	50                   	push   %eax
c000c31a:	68 ae 6c 01 c0       	push   $0xc0016cae
c000c31f:	e8 ba 56 ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c000c324:	58                   	pop    %eax
c000c325:	5a                   	pop    %edx

            if (preempt)
c000c326:	84 db                	test   %bl,%bl
c000c328:	74 2a                	je     c000c354 <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x28e>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000c32a:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000c331:	74 19                	je     c000c34c <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x286>
c000c333:	68 e0 8b 01 c0       	push   $0xc0018be0
c000c338:	68 c0 00 00 00       	push   $0xc0
c000c33d:	68 12 61 01 c0       	push   $0xc0016112
c000c342:	68 82 61 01 c0       	push   $0xc0016182
c000c347:	e9 35 ff ff ff       	jmp    c000c281 <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x1bb>

            preemption = true;
c000c34c:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000c353:	fb                   	sti    
                Cpu::preempt_enable();

            ptr = ACCESS_ONCE (node->prev);

            if (node->dpth <= d)
c000c354:	0f b7 46 1a          	movzwl 0x1a(%esi),%eax
                Rcu::call (node);

            if (preempt)
                Cpu::preempt_enable();

            ptr = ACCESS_ONCE (node->prev);
c000c358:	8b 56 1c             	mov    0x1c(%esi),%edx

            if (node->dpth <= d)
c000c35b:	3b 44 24 04          	cmp    0x4(%esp),%eax
c000c35f:	76 07                	jbe    c000c368 <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x2a2>
        Mdb *x = ACCESS_ONCE (node->next);
        assert (x->dpth <= d || (x->dpth == node->dpth + 1 && !(x->node_attr & attr)));

        bool preempt = Cpu::preemption;

        for (Mdb *ptr;; node = ptr) {
c000c361:	89 d6                	mov    %edx,%esi
c000c363:	e9 37 ff ff ff       	jmp    c000c29f <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x1d9>

            if (node->dpth <= d)
                break;
        }

        assert (node == mdb);
c000c368:	39 fe                	cmp    %edi,%esi
c000c36a:	0f 84 2c fe ff ff    	je     c000c19c <_ZN2Pd6revokeI9Space_memEEvmmmbb+0xd6>
c000c370:	68 40 8b 01 c0       	push   $0xc0018b40
c000c375:	68 c2 00 00 00       	push   $0xc2
c000c37a:	68 b1 87 01 c0       	push   $0xc00187b1
c000c37f:	68 56 88 01 c0       	push   $0xc0018856
c000c384:	e9 f8 fe ff ff       	jmp    c000c281 <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x1bb>
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
c000c389:	a1 f0 f7 ff cf       	mov    0xcffff7f0,%eax
c000c38e:	39 e8                	cmp    %ebp,%eax
c000c390:	0f 84 6f ff ff ff    	je     c000c305 <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x23f>
                trace (0, "warning: rcu element already enqueued");
                return;
            }

            count ++;
c000c396:	ff 05 f4 f7 ff cf    	incl   0xcffff7f4

           *tail = e;
c000c39c:	89 28                	mov    %ebp,(%eax)
            tail = &e->next;
c000c39e:	89 2d f0 f7 ff cf    	mov    %ebp,0xcffff7f0
c000c3a4:	eb 80                	jmp    c000c326 <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x260>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
c000c3a6:	a1 08 00 00 00       	mov    0x8,%eax
c000c3ab:	0f 0b                	ud2    
    }
}
c000c3ad:	83 c4 3c             	add    $0x3c,%esp
c000c3b0:	5b                   	pop    %ebx
c000c3b1:	5e                   	pop    %esi
c000c3b2:	5f                   	pop    %edi
c000c3b3:	5d                   	pop    %ebp
c000c3b4:	c3                   	ret    
c000c3b5:	90                   	nop

c000c3b6 <_ZN2Pd6revokeI9Space_pioEEvmmmbb>:

    return s;
}

template <typename S>
void Pd::revoke (mword const base, mword const ord, mword const attr, bool self, bool kim)
c000c3b6:	55                   	push   %ebp
c000c3b7:	57                   	push   %edi
c000c3b8:	56                   	push   %esi
c000c3b9:	53                   	push   %ebx
c000c3ba:	83 ec 3c             	sub    $0x3c,%esp
c000c3bd:	89 04 24             	mov    %eax,(%esp)
c000c3c0:	8a 44 24 58          	mov    0x58(%esp),%al
c000c3c4:	89 54 24 08          	mov    %edx,0x8(%esp)
c000c3c8:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c000c3cc:	88 44 24 13          	mov    %al,0x13(%esp)

        unsigned d = node->dpth; bool demote = false;

        for (Mdb *ptr;; node = ptr) {

            if (node->dpth == d + !self)
c000c3d0:	8a 44 24 54          	mov    0x54(%esp),%al
c000c3d4:	34 01                	xor    $0x1,%al
c000c3d6:	0f b6 c0             	movzbl %al,%eax
c000c3d9:	89 44 24 18          	mov    %eax,0x18(%esp)

template <typename S>
void Pd::revoke (mword const base, mword const ord, mword const attr, bool self, bool kim)
{
    Mdb *mdb;
    for (mword addr = base; (mdb = S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {
c000c3dd:	8b 04 24             	mov    (%esp),%eax
c000c3e0:	b9 01 00 00 00       	mov    $0x1,%ecx
c000c3e5:	05 78 01 00 00       	add    $0x178,%eax
c000c3ea:	e8 eb f6 ff ff       	call   c000bada <_ZN5Space11tree_lookupEmb>
c000c3ef:	85 c0                	test   %eax,%eax
c000c3f1:	89 c7                	mov    %eax,%edi
c000c3f3:	0f 84 a6 02 00 00    	je     c000c69f <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x2e9>

        mword o, p, b = base;
c000c3f9:	8b 44 24 08          	mov    0x8(%esp),%eax
        if ((o = clamp (mdb->node_base, b, mdb->node_order, ord)) == ~0UL)
c000c3fd:	8b 57 30             	mov    0x30(%edi),%edx
void Pd::revoke (mword const base, mword const ord, mword const attr, bool self, bool kim)
{
    Mdb *mdb;
    for (mword addr = base; (mdb = S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {

        mword o, p, b = base;
c000c400:	89 44 24 20          	mov    %eax,0x20(%esp)
        if ((o = clamp (mdb->node_base, b, mdb->node_order, ord)) == ~0UL)
c000c404:	ff 74 24 0c          	pushl  0xc(%esp)
c000c408:	ff 77 34             	pushl  0x34(%edi)
c000c40b:	8b 44 24 08          	mov    0x8(%esp),%eax
c000c40f:	8d 4c 24 28          	lea    0x28(%esp),%ecx
c000c413:	e8 2c fa ff ff       	call   c000be44 <_ZN2Pd5clampEmRmmm>
c000c418:	5b                   	pop    %ebx
c000c419:	5e                   	pop    %esi
c000c41a:	83 f8 ff             	cmp    $0xffffffff,%eax
c000c41d:	89 c5                	mov    %eax,%ebp
c000c41f:	0f 84 7a 02 00 00    	je     c000c69f <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x2e9>
c000c425:	0f b7 47 1a          	movzwl 0x1a(%edi),%eax
            break;

        /* keep in mapping database if requested and at least one child node exists */
        if (kim && (ACCESS_ONCE(mdb->next)->dpth > mdb->dpth)) {
c000c429:	80 7c 24 13 00       	cmpb   $0x0,0x13(%esp)
c000c42e:	89 44 24 04          	mov    %eax,0x4(%esp)
c000c432:	74 6c                	je     c000c4a0 <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0xea>
c000c434:	8b 47 20             	mov    0x20(%edi),%eax
c000c437:	0f b7 40 1a          	movzwl 0x1a(%eax),%eax
c000c43b:	3b 44 24 04          	cmp    0x4(%esp),%eax
c000c43f:	76 5f                	jbe    c000c4a0 <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0xea>
c000c441:	8d 44 24 24          	lea    0x24(%esp),%eax
c000c445:	e8 2c f6 ff ff       	call   c000ba76 <_ZN5QuotaC1Ev>
            Quota_guard qg(this->quota);
c000c44a:	8b 04 24             	mov    (%esp),%eax
c000c44d:	05 90 01 00 00       	add    $0x190,%eax
c000c452:	89 44 24 38          	mov    %eax,0x38(%esp)
            if (mdb->node_attr & 0x1f) {
c000c456:	f6 47 38 1f          	testb  $0x1f,0x38(%edi)
c000c45a:	74 1d                	je     c000c479 <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0xc3>
                static_cast<S *>(mdb->space)->update (qg, mdb, 0x1f);
c000c45c:	8b 47 28             	mov    0x28(%edi),%eax
c000c45f:	89 f9                	mov    %edi,%ecx
c000c461:	6a 1f                	push   $0x1f
c000c463:	8d 54 24 28          	lea    0x28(%esp),%edx
c000c467:	e8 be 4d 00 00       	call   c001122a <_ZN9Space_pio6updateER5QuotaP3Mdbm>
                mdb->demote_node (0x1f);
c000c46c:	ba 1f 00 00 00       	mov    $0x1f,%edx
c000c471:	89 f8                	mov    %edi,%eax
c000c473:	e8 8c 9d ff ff       	call   c0006204 <_ZN3Mdb11demote_nodeEm>
c000c478:	59                   	pop    %ecx
            }
            static_cast<S *>(mdb->space)->tree_remove (mdb, Avl::State::KIM);
c000c479:	ba 02 00 00 00       	mov    $0x2,%edx
c000c47e:	89 f8                	mov    %edi,%eax
c000c480:	e8 96 f7 ff ff       	call   c000bc1b <_ZN5Space11tree_removeEP3MdbN3Avl5StateE>
            continue;
c000c485:	8d 44 24 24          	lea    0x24(%esp),%eax
c000c489:	e8 44 f6 ff ff       	call   c000bad2 <_ZN11Quota_guardD1Ev>

template <typename S>
void Pd::revoke (mword const base, mword const ord, mword const attr, bool self, bool kim)
{
    Mdb *mdb;
    for (mword addr = base; (mdb = S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {
c000c48e:	8b 4f 34             	mov    0x34(%edi),%ecx
c000c491:	ba 01 00 00 00       	mov    $0x1,%edx
c000c496:	d3 e2                	shl    %cl,%edx
c000c498:	03 57 30             	add    0x30(%edi),%edx
c000c49b:	e9 3d ff ff ff       	jmp    c000c3dd <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x27>

        unsigned d = node->dpth; bool demote = false;

        for (Mdb *ptr;; node = ptr) {

            if (node->dpth == d + !self)
c000c4a0:	8b 44 24 18          	mov    0x18(%esp),%eax
            continue;
        }

        Mdb *node = mdb;

        unsigned d = node->dpth; bool demote = false;
c000c4a4:	89 fe                	mov    %edi,%esi
c000c4a6:	31 db                	xor    %ebx,%ebx

        for (Mdb *ptr;; node = ptr) {

            if (node->dpth == d + !self)
c000c4a8:	03 44 24 04          	add    0x4(%esp),%eax
c000c4ac:	89 44 24 14          	mov    %eax,0x14(%esp)
c000c4b0:	0f b7 46 1a          	movzwl 0x1a(%esi),%eax
c000c4b4:	3b 44 24 14          	cmp    0x14(%esp),%eax
c000c4b8:	75 29                	jne    c000c4e3 <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x12d>
c000c4ba:	8b 44 24 20          	mov    0x20(%esp),%eax
c000c4be:	03 47 2c             	add    0x2c(%edi),%eax
                demote = clamp (node->node_phys, p = b - mdb->node_base + mdb->node_phys, node->node_order, o) != ~0UL;
c000c4c1:	8b 4e 34             	mov    0x34(%esi),%ecx
c000c4c4:	2b 47 30             	sub    0x30(%edi),%eax
c000c4c7:	8b 56 2c             	mov    0x2c(%esi),%edx
c000c4ca:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c000c4ce:	55                   	push   %ebp
c000c4cf:	51                   	push   %ecx
c000c4d0:	8b 44 24 08          	mov    0x8(%esp),%eax
c000c4d4:	8d 4c 24 24          	lea    0x24(%esp),%ecx
c000c4d8:	e8 67 f9 ff ff       	call   c000be44 <_ZN2Pd5clampEmRmmm>
c000c4dd:	5b                   	pop    %ebx
c000c4de:	5a                   	pop    %edx
c000c4df:	40                   	inc    %eax
c000c4e0:	0f 95 c3             	setne  %bl

            if (demote && node->node_attr & attr) {
c000c4e3:	84 db                	test   %bl,%bl
c000c4e5:	74 45                	je     c000c52c <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x176>
c000c4e7:	8b 46 38             	mov    0x38(%esi),%eax
c000c4ea:	85 44 24 50          	test   %eax,0x50(%esp)
c000c4ee:	74 3c                	je     c000c52c <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x176>
c000c4f0:	8d 44 24 24          	lea    0x24(%esp),%eax
c000c4f4:	e8 7d f5 ff ff       	call   c000ba76 <_ZN5QuotaC1Ev>
                Quota_guard qg(this->quota);
c000c4f9:	8b 04 24             	mov    (%esp),%eax
                static_cast<S *>(node->space)->update (qg, node, attr);
c000c4fc:	89 f1                	mov    %esi,%ecx

            if (node->dpth == d + !self)
                demote = clamp (node->node_phys, p = b - mdb->node_base + mdb->node_phys, node->node_order, o) != ~0UL;

            if (demote && node->node_attr & attr) {
                Quota_guard qg(this->quota);
c000c4fe:	05 90 01 00 00       	add    $0x190,%eax
c000c503:	89 44 24 38          	mov    %eax,0x38(%esp)
                static_cast<S *>(node->space)->update (qg, node, attr);
c000c507:	8b 46 28             	mov    0x28(%esi),%eax
c000c50a:	ff 74 24 50          	pushl  0x50(%esp)
c000c50e:	8d 54 24 28          	lea    0x28(%esp),%edx
c000c512:	e8 13 4d 00 00       	call   c001122a <_ZN9Space_pio6updateER5QuotaP3Mdbm>
                node->demote_node (attr);
c000c517:	8b 54 24 54          	mov    0x54(%esp),%edx
c000c51b:	89 f0                	mov    %esi,%eax
c000c51d:	e8 e2 9c ff ff       	call   c0006204 <_ZN3Mdb11demote_nodeEm>
c000c522:	8d 44 24 28          	lea    0x28(%esp),%eax
c000c526:	e8 a7 f5 ff ff       	call   c000bad2 <_ZN11Quota_guardD1Ev>
c000c52b:	59                   	pop    %ecx
            }

            ptr = ACCESS_ONCE (node->next);
c000c52c:	8b 46 20             	mov    0x20(%esi),%eax

            if (ptr->dpth <= d)
c000c52f:	0f b7 50 1a          	movzwl 0x1a(%eax),%edx
c000c533:	3b 54 24 04          	cmp    0x4(%esp),%edx
c000c537:	76 07                	jbe    c000c540 <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x18a>
c000c539:	89 c6                	mov    %eax,%esi
c000c53b:	e9 70 ff ff ff       	jmp    c000c4b0 <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0xfa>
                break;
        }

        Mdb *x = ACCESS_ONCE (node->next);
c000c540:	8b 56 20             	mov    0x20(%esi),%edx
        assert (x->dpth <= d || (x->dpth == node->dpth + 1 && !(x->node_attr & attr)));
c000c543:	0f b7 4a 1a          	movzwl 0x1a(%edx),%ecx
c000c547:	3b 4c 24 04          	cmp    0x4(%esp),%ecx
c000c54b:	76 30                	jbe    c000c57d <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x1c7>
c000c54d:	0f b7 46 1a          	movzwl 0x1a(%esi),%eax
c000c551:	40                   	inc    %eax
c000c552:	39 c1                	cmp    %eax,%ecx
c000c554:	75 09                	jne    c000c55f <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x1a9>
c000c556:	8b 42 38             	mov    0x38(%edx),%eax
c000c559:	85 44 24 50          	test   %eax,0x50(%esp)
c000c55d:	74 1e                	je     c000c57d <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x1c7>
c000c55f:	68 c0 8a 01 c0       	push   $0xc0018ac0
c000c564:	68 ad 00 00 00       	push   $0xad
c000c569:	68 b1 87 01 c0       	push   $0xc00187b1
c000c56e:	68 62 88 01 c0       	push   $0xc0018862
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000c573:	68 69 60 01 c0       	push   $0xc0016069
c000c578:	e8 c9 53 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

        bool preempt = Cpu::preemption;
c000c57d:	8a 1d 00 f7 ff cf    	mov    0xcffff700,%bl

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
                trace (0, "warning: rcu element already enqueued");
c000c583:	8d 6c 24 23          	lea    0x23(%esp),%ebp
c000c587:	81 e5 00 f0 ff ff    	and    $0xfffff000,%ebp
c000c58d:	89 6c 24 14          	mov    %ebp,0x14(%esp)

        for (Mdb *ptr;; node = ptr) {

            if (preempt)
c000c591:	84 db                	test   %bl,%bl
c000c593:	74 27                	je     c000c5bc <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x206>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c000c595:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000c59c:	75 16                	jne    c000c5b4 <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x1fe>
c000c59e:	68 20 8c 01 c0       	push   $0xc0018c20
c000c5a3:	68 b7 00 00 00       	push   $0xb7
c000c5a8:	68 12 61 01 c0       	push   $0xc0016112
c000c5ad:	68 83 61 01 c0       	push   $0xc0016183
c000c5b2:	eb bf                	jmp    c000c573 <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x1bd>

            asm volatile ("cli" : : : "memory");
c000c5b4:	fa                   	cli    
            preemption = false;
c000c5b5:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            if (node->remove_node() && static_cast<S *>(node->space)->tree_remove (node))
c000c5bc:	89 f0                	mov    %esi,%eax
c000c5be:	e8 c7 9c ff ff       	call   c000628a <_ZN3Mdb11remove_nodeEv>
c000c5c3:	84 c0                	test   %al,%al
c000c5c5:	74 51                	je     c000c618 <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x262>
c000c5c7:	ba 01 00 00 00       	mov    $0x1,%edx
c000c5cc:	89 f0                	mov    %esi,%eax
c000c5ce:	e8 48 f6 ff ff       	call   c000bc1b <_ZN5Space11tree_removeEP3MdbN3Avl5StateE>
c000c5d3:	84 c0                	test   %al,%al
c000c5d5:	74 41                	je     c000c618 <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x262>
                Rcu::call (node);
c000c5d7:	85 f6                	test   %esi,%esi
c000c5d9:	0f 84 b9 00 00 00    	je     c000c698 <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x2e2>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
c000c5df:	8b 4e 14             	mov    0x14(%esi),%ecx
c000c5e2:	8d 6e 0c             	lea    0xc(%esi),%ebp
c000c5e5:	85 c9                	test   %ecx,%ecx
c000c5e7:	74 04                	je     c000c5ed <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x237>
                e->pre_func(e);
c000c5e9:	89 e8                	mov    %ebp,%eax
c000c5eb:	ff d1                	call   *%ecx
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
c000c5ed:	83 7e 0c 00          	cmpl   $0x0,0xc(%esi)
c000c5f1:	0f 84 84 00 00 00    	je     c000c67b <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x2c5>
                trace (0, "warning: rcu element already enqueued");
c000c5f7:	81 7c 24 14 00 d0 ff 	cmpl   $0xcfffd000,0x14(%esp)
c000c5fe:	cf 
c000c5ff:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000c604:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c000c60b:	50                   	push   %eax
c000c60c:	68 ae 6c 01 c0       	push   $0xc0016cae
c000c611:	e8 c8 53 ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c000c616:	58                   	pop    %eax
c000c617:	5a                   	pop    %edx

            if (preempt)
c000c618:	84 db                	test   %bl,%bl
c000c61a:	74 2a                	je     c000c646 <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x290>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000c61c:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000c623:	74 19                	je     c000c63e <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x288>
c000c625:	68 e0 8b 01 c0       	push   $0xc0018be0
c000c62a:	68 c0 00 00 00       	push   $0xc0
c000c62f:	68 12 61 01 c0       	push   $0xc0016112
c000c634:	68 82 61 01 c0       	push   $0xc0016182
c000c639:	e9 35 ff ff ff       	jmp    c000c573 <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x1bd>

            preemption = true;
c000c63e:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000c645:	fb                   	sti    
                Cpu::preempt_enable();

            ptr = ACCESS_ONCE (node->prev);

            if (node->dpth <= d)
c000c646:	0f b7 46 1a          	movzwl 0x1a(%esi),%eax
                Rcu::call (node);

            if (preempt)
                Cpu::preempt_enable();

            ptr = ACCESS_ONCE (node->prev);
c000c64a:	8b 56 1c             	mov    0x1c(%esi),%edx

            if (node->dpth <= d)
c000c64d:	3b 44 24 04          	cmp    0x4(%esp),%eax
c000c651:	76 07                	jbe    c000c65a <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x2a4>
        Mdb *x = ACCESS_ONCE (node->next);
        assert (x->dpth <= d || (x->dpth == node->dpth + 1 && !(x->node_attr & attr)));

        bool preempt = Cpu::preemption;

        for (Mdb *ptr;; node = ptr) {
c000c653:	89 d6                	mov    %edx,%esi
c000c655:	e9 37 ff ff ff       	jmp    c000c591 <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x1db>

            if (node->dpth <= d)
                break;
        }

        assert (node == mdb);
c000c65a:	39 fe                	cmp    %edi,%esi
c000c65c:	0f 84 2c fe ff ff    	je     c000c48e <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0xd8>
c000c662:	68 c0 8a 01 c0       	push   $0xc0018ac0
c000c667:	68 c2 00 00 00       	push   $0xc2
c000c66c:	68 b1 87 01 c0       	push   $0xc00187b1
c000c671:	68 56 88 01 c0       	push   $0xc0018856
c000c676:	e9 f8 fe ff ff       	jmp    c000c573 <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x1bd>
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
c000c67b:	a1 f0 f7 ff cf       	mov    0xcffff7f0,%eax
c000c680:	39 e8                	cmp    %ebp,%eax
c000c682:	0f 84 6f ff ff ff    	je     c000c5f7 <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x241>
                trace (0, "warning: rcu element already enqueued");
                return;
            }

            count ++;
c000c688:	ff 05 f4 f7 ff cf    	incl   0xcffff7f4

           *tail = e;
c000c68e:	89 28                	mov    %ebp,(%eax)
            tail = &e->next;
c000c690:	89 2d f0 f7 ff cf    	mov    %ebp,0xcffff7f0
c000c696:	eb 80                	jmp    c000c618 <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x262>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
c000c698:	a1 08 00 00 00       	mov    0x8,%eax
c000c69d:	0f 0b                	ud2    
    }
}
c000c69f:	83 c4 3c             	add    $0x3c,%esp
c000c6a2:	5b                   	pop    %ebx
c000c6a3:	5e                   	pop    %esi
c000c6a4:	5f                   	pop    %edi
c000c6a5:	5d                   	pop    %ebp
c000c6a6:	c3                   	ret    
c000c6a7:	90                   	nop

c000c6a8 <_ZN2Pd6revokeI9Space_objEEvmmmbb>:

    return s;
}

template <typename S>
void Pd::revoke (mword const base, mword const ord, mword const attr, bool self, bool kim)
c000c6a8:	55                   	push   %ebp
c000c6a9:	57                   	push   %edi
c000c6aa:	56                   	push   %esi
c000c6ab:	53                   	push   %ebx
c000c6ac:	83 ec 3c             	sub    $0x3c,%esp
c000c6af:	89 04 24             	mov    %eax,(%esp)
c000c6b2:	8a 44 24 58          	mov    0x58(%esp),%al
c000c6b6:	89 54 24 08          	mov    %edx,0x8(%esp)
c000c6ba:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c000c6be:	88 44 24 13          	mov    %al,0x13(%esp)

        unsigned d = node->dpth; bool demote = false;

        for (Mdb *ptr;; node = ptr) {

            if (node->dpth == d + !self)
c000c6c2:	8a 44 24 54          	mov    0x54(%esp),%al
c000c6c6:	34 01                	xor    $0x1,%al
c000c6c8:	0f b6 c0             	movzbl %al,%eax
c000c6cb:	89 44 24 18          	mov    %eax,0x18(%esp)

template <typename S>
void Pd::revoke (mword const base, mword const ord, mword const attr, bool self, bool kim)
{
    Mdb *mdb;
    for (mword addr = base; (mdb = S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {
c000c6cf:	8b 04 24             	mov    (%esp),%eax
c000c6d2:	b9 01 00 00 00       	mov    $0x1,%ecx
c000c6d7:	05 88 01 00 00       	add    $0x188,%eax
c000c6dc:	e8 f9 f3 ff ff       	call   c000bada <_ZN5Space11tree_lookupEmb>
c000c6e1:	85 c0                	test   %eax,%eax
c000c6e3:	89 c7                	mov    %eax,%edi
c000c6e5:	0f 84 a6 02 00 00    	je     c000c991 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x2e9>

        mword o, p, b = base;
c000c6eb:	8b 44 24 08          	mov    0x8(%esp),%eax
        if ((o = clamp (mdb->node_base, b, mdb->node_order, ord)) == ~0UL)
c000c6ef:	8b 57 30             	mov    0x30(%edi),%edx
void Pd::revoke (mword const base, mword const ord, mword const attr, bool self, bool kim)
{
    Mdb *mdb;
    for (mword addr = base; (mdb = S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {

        mword o, p, b = base;
c000c6f2:	89 44 24 20          	mov    %eax,0x20(%esp)
        if ((o = clamp (mdb->node_base, b, mdb->node_order, ord)) == ~0UL)
c000c6f6:	ff 74 24 0c          	pushl  0xc(%esp)
c000c6fa:	ff 77 34             	pushl  0x34(%edi)
c000c6fd:	8b 44 24 08          	mov    0x8(%esp),%eax
c000c701:	8d 4c 24 28          	lea    0x28(%esp),%ecx
c000c705:	e8 3a f7 ff ff       	call   c000be44 <_ZN2Pd5clampEmRmmm>
c000c70a:	5b                   	pop    %ebx
c000c70b:	5e                   	pop    %esi
c000c70c:	83 f8 ff             	cmp    $0xffffffff,%eax
c000c70f:	89 c5                	mov    %eax,%ebp
c000c711:	0f 84 7a 02 00 00    	je     c000c991 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x2e9>
c000c717:	0f b7 47 1a          	movzwl 0x1a(%edi),%eax
            break;

        /* keep in mapping database if requested and at least one child node exists */
        if (kim && (ACCESS_ONCE(mdb->next)->dpth > mdb->dpth)) {
c000c71b:	80 7c 24 13 00       	cmpb   $0x0,0x13(%esp)
c000c720:	89 44 24 04          	mov    %eax,0x4(%esp)
c000c724:	74 6c                	je     c000c792 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0xea>
c000c726:	8b 47 20             	mov    0x20(%edi),%eax
c000c729:	0f b7 40 1a          	movzwl 0x1a(%eax),%eax
c000c72d:	3b 44 24 04          	cmp    0x4(%esp),%eax
c000c731:	76 5f                	jbe    c000c792 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0xea>
c000c733:	8d 44 24 24          	lea    0x24(%esp),%eax
c000c737:	e8 3a f3 ff ff       	call   c000ba76 <_ZN5QuotaC1Ev>
            Quota_guard qg(this->quota);
c000c73c:	8b 04 24             	mov    (%esp),%eax
c000c73f:	05 90 01 00 00       	add    $0x190,%eax
c000c744:	89 44 24 38          	mov    %eax,0x38(%esp)
            if (mdb->node_attr & 0x1f) {
c000c748:	f6 47 38 1f          	testb  $0x1f,0x38(%edi)
c000c74c:	74 1d                	je     c000c76b <_ZN2Pd6revokeI9Space_objEEvmmmbb+0xc3>
                static_cast<S *>(mdb->space)->update (qg, mdb, 0x1f);
c000c74e:	8b 47 28             	mov    0x28(%edi),%eax
c000c751:	89 f9                	mov    %edi,%ecx
c000c753:	6a 1f                	push   $0x1f
c000c755:	8d 54 24 28          	lea    0x28(%esp),%edx
c000c759:	e8 90 48 00 00       	call   c0010fee <_ZN9Space_obj6updateER5QuotaP3Mdbm>
                mdb->demote_node (0x1f);
c000c75e:	ba 1f 00 00 00       	mov    $0x1f,%edx
c000c763:	89 f8                	mov    %edi,%eax
c000c765:	e8 9a 9a ff ff       	call   c0006204 <_ZN3Mdb11demote_nodeEm>
c000c76a:	59                   	pop    %ecx
            }
            static_cast<S *>(mdb->space)->tree_remove (mdb, Avl::State::KIM);
c000c76b:	ba 02 00 00 00       	mov    $0x2,%edx
c000c770:	89 f8                	mov    %edi,%eax
c000c772:	e8 a4 f4 ff ff       	call   c000bc1b <_ZN5Space11tree_removeEP3MdbN3Avl5StateE>
            continue;
c000c777:	8d 44 24 24          	lea    0x24(%esp),%eax
c000c77b:	e8 52 f3 ff ff       	call   c000bad2 <_ZN11Quota_guardD1Ev>

template <typename S>
void Pd::revoke (mword const base, mword const ord, mword const attr, bool self, bool kim)
{
    Mdb *mdb;
    for (mword addr = base; (mdb = S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {
c000c780:	8b 4f 34             	mov    0x34(%edi),%ecx
c000c783:	ba 01 00 00 00       	mov    $0x1,%edx
c000c788:	d3 e2                	shl    %cl,%edx
c000c78a:	03 57 30             	add    0x30(%edi),%edx
c000c78d:	e9 3d ff ff ff       	jmp    c000c6cf <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x27>

        unsigned d = node->dpth; bool demote = false;

        for (Mdb *ptr;; node = ptr) {

            if (node->dpth == d + !self)
c000c792:	8b 44 24 18          	mov    0x18(%esp),%eax
            continue;
        }

        Mdb *node = mdb;

        unsigned d = node->dpth; bool demote = false;
c000c796:	89 fe                	mov    %edi,%esi
c000c798:	31 db                	xor    %ebx,%ebx

        for (Mdb *ptr;; node = ptr) {

            if (node->dpth == d + !self)
c000c79a:	03 44 24 04          	add    0x4(%esp),%eax
c000c79e:	89 44 24 14          	mov    %eax,0x14(%esp)
c000c7a2:	0f b7 46 1a          	movzwl 0x1a(%esi),%eax
c000c7a6:	3b 44 24 14          	cmp    0x14(%esp),%eax
c000c7aa:	75 29                	jne    c000c7d5 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x12d>
c000c7ac:	8b 44 24 20          	mov    0x20(%esp),%eax
c000c7b0:	03 47 2c             	add    0x2c(%edi),%eax
                demote = clamp (node->node_phys, p = b - mdb->node_base + mdb->node_phys, node->node_order, o) != ~0UL;
c000c7b3:	8b 4e 34             	mov    0x34(%esi),%ecx
c000c7b6:	2b 47 30             	sub    0x30(%edi),%eax
c000c7b9:	8b 56 2c             	mov    0x2c(%esi),%edx
c000c7bc:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c000c7c0:	55                   	push   %ebp
c000c7c1:	51                   	push   %ecx
c000c7c2:	8b 44 24 08          	mov    0x8(%esp),%eax
c000c7c6:	8d 4c 24 24          	lea    0x24(%esp),%ecx
c000c7ca:	e8 75 f6 ff ff       	call   c000be44 <_ZN2Pd5clampEmRmmm>
c000c7cf:	5b                   	pop    %ebx
c000c7d0:	5a                   	pop    %edx
c000c7d1:	40                   	inc    %eax
c000c7d2:	0f 95 c3             	setne  %bl

            if (demote && node->node_attr & attr) {
c000c7d5:	84 db                	test   %bl,%bl
c000c7d7:	74 45                	je     c000c81e <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x176>
c000c7d9:	8b 46 38             	mov    0x38(%esi),%eax
c000c7dc:	85 44 24 50          	test   %eax,0x50(%esp)
c000c7e0:	74 3c                	je     c000c81e <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x176>
c000c7e2:	8d 44 24 24          	lea    0x24(%esp),%eax
c000c7e6:	e8 8b f2 ff ff       	call   c000ba76 <_ZN5QuotaC1Ev>
                Quota_guard qg(this->quota);
c000c7eb:	8b 04 24             	mov    (%esp),%eax
                static_cast<S *>(node->space)->update (qg, node, attr);
c000c7ee:	89 f1                	mov    %esi,%ecx

            if (node->dpth == d + !self)
                demote = clamp (node->node_phys, p = b - mdb->node_base + mdb->node_phys, node->node_order, o) != ~0UL;

            if (demote && node->node_attr & attr) {
                Quota_guard qg(this->quota);
c000c7f0:	05 90 01 00 00       	add    $0x190,%eax
c000c7f5:	89 44 24 38          	mov    %eax,0x38(%esp)
                static_cast<S *>(node->space)->update (qg, node, attr);
c000c7f9:	8b 46 28             	mov    0x28(%esi),%eax
c000c7fc:	ff 74 24 50          	pushl  0x50(%esp)
c000c800:	8d 54 24 28          	lea    0x28(%esp),%edx
c000c804:	e8 e5 47 00 00       	call   c0010fee <_ZN9Space_obj6updateER5QuotaP3Mdbm>
                node->demote_node (attr);
c000c809:	8b 54 24 54          	mov    0x54(%esp),%edx
c000c80d:	89 f0                	mov    %esi,%eax
c000c80f:	e8 f0 99 ff ff       	call   c0006204 <_ZN3Mdb11demote_nodeEm>
c000c814:	8d 44 24 28          	lea    0x28(%esp),%eax
c000c818:	e8 b5 f2 ff ff       	call   c000bad2 <_ZN11Quota_guardD1Ev>
c000c81d:	59                   	pop    %ecx
            }

            ptr = ACCESS_ONCE (node->next);
c000c81e:	8b 46 20             	mov    0x20(%esi),%eax

            if (ptr->dpth <= d)
c000c821:	0f b7 50 1a          	movzwl 0x1a(%eax),%edx
c000c825:	3b 54 24 04          	cmp    0x4(%esp),%edx
c000c829:	76 07                	jbe    c000c832 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x18a>
c000c82b:	89 c6                	mov    %eax,%esi
c000c82d:	e9 70 ff ff ff       	jmp    c000c7a2 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0xfa>
                break;
        }

        Mdb *x = ACCESS_ONCE (node->next);
c000c832:	8b 56 20             	mov    0x20(%esi),%edx
        assert (x->dpth <= d || (x->dpth == node->dpth + 1 && !(x->node_attr & attr)));
c000c835:	0f b7 4a 1a          	movzwl 0x1a(%edx),%ecx
c000c839:	3b 4c 24 04          	cmp    0x4(%esp),%ecx
c000c83d:	76 30                	jbe    c000c86f <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x1c7>
c000c83f:	0f b7 46 1a          	movzwl 0x1a(%esi),%eax
c000c843:	40                   	inc    %eax
c000c844:	39 c1                	cmp    %eax,%ecx
c000c846:	75 09                	jne    c000c851 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x1a9>
c000c848:	8b 42 38             	mov    0x38(%edx),%eax
c000c84b:	85 44 24 50          	test   %eax,0x50(%esp)
c000c84f:	74 1e                	je     c000c86f <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x1c7>
c000c851:	68 40 8a 01 c0       	push   $0xc0018a40
c000c856:	68 ad 00 00 00       	push   $0xad
c000c85b:	68 b1 87 01 c0       	push   $0xc00187b1
c000c860:	68 62 88 01 c0       	push   $0xc0018862
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000c865:	68 69 60 01 c0       	push   $0xc0016069
c000c86a:	e8 d7 50 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

        bool preempt = Cpu::preemption;
c000c86f:	8a 1d 00 f7 ff cf    	mov    0xcffff700,%bl

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
                trace (0, "warning: rcu element already enqueued");
c000c875:	8d 6c 24 23          	lea    0x23(%esp),%ebp
c000c879:	81 e5 00 f0 ff ff    	and    $0xfffff000,%ebp
c000c87f:	89 6c 24 14          	mov    %ebp,0x14(%esp)

        for (Mdb *ptr;; node = ptr) {

            if (preempt)
c000c883:	84 db                	test   %bl,%bl
c000c885:	74 27                	je     c000c8ae <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x206>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c000c887:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000c88e:	75 16                	jne    c000c8a6 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x1fe>
c000c890:	68 20 8c 01 c0       	push   $0xc0018c20
c000c895:	68 b7 00 00 00       	push   $0xb7
c000c89a:	68 12 61 01 c0       	push   $0xc0016112
c000c89f:	68 83 61 01 c0       	push   $0xc0016183
c000c8a4:	eb bf                	jmp    c000c865 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x1bd>

            asm volatile ("cli" : : : "memory");
c000c8a6:	fa                   	cli    
            preemption = false;
c000c8a7:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            if (node->remove_node() && static_cast<S *>(node->space)->tree_remove (node))
c000c8ae:	89 f0                	mov    %esi,%eax
c000c8b0:	e8 d5 99 ff ff       	call   c000628a <_ZN3Mdb11remove_nodeEv>
c000c8b5:	84 c0                	test   %al,%al
c000c8b7:	74 51                	je     c000c90a <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x262>
c000c8b9:	ba 01 00 00 00       	mov    $0x1,%edx
c000c8be:	89 f0                	mov    %esi,%eax
c000c8c0:	e8 56 f3 ff ff       	call   c000bc1b <_ZN5Space11tree_removeEP3MdbN3Avl5StateE>
c000c8c5:	84 c0                	test   %al,%al
c000c8c7:	74 41                	je     c000c90a <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x262>
                Rcu::call (node);
c000c8c9:	85 f6                	test   %esi,%esi
c000c8cb:	0f 84 b9 00 00 00    	je     c000c98a <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x2e2>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
c000c8d1:	8b 4e 14             	mov    0x14(%esi),%ecx
c000c8d4:	8d 6e 0c             	lea    0xc(%esi),%ebp
c000c8d7:	85 c9                	test   %ecx,%ecx
c000c8d9:	74 04                	je     c000c8df <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x237>
                e->pre_func(e);
c000c8db:	89 e8                	mov    %ebp,%eax
c000c8dd:	ff d1                	call   *%ecx
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
c000c8df:	83 7e 0c 00          	cmpl   $0x0,0xc(%esi)
c000c8e3:	0f 84 84 00 00 00    	je     c000c96d <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x2c5>
                trace (0, "warning: rcu element already enqueued");
c000c8e9:	81 7c 24 14 00 d0 ff 	cmpl   $0xcfffd000,0x14(%esp)
c000c8f0:	cf 
c000c8f1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000c8f6:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c000c8fd:	50                   	push   %eax
c000c8fe:	68 ae 6c 01 c0       	push   $0xc0016cae
c000c903:	e8 d6 50 ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c000c908:	58                   	pop    %eax
c000c909:	5a                   	pop    %edx

            if (preempt)
c000c90a:	84 db                	test   %bl,%bl
c000c90c:	74 2a                	je     c000c938 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x290>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000c90e:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000c915:	74 19                	je     c000c930 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x288>
c000c917:	68 e0 8b 01 c0       	push   $0xc0018be0
c000c91c:	68 c0 00 00 00       	push   $0xc0
c000c921:	68 12 61 01 c0       	push   $0xc0016112
c000c926:	68 82 61 01 c0       	push   $0xc0016182
c000c92b:	e9 35 ff ff ff       	jmp    c000c865 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x1bd>

            preemption = true;
c000c930:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000c937:	fb                   	sti    
                Cpu::preempt_enable();

            ptr = ACCESS_ONCE (node->prev);

            if (node->dpth <= d)
c000c938:	0f b7 46 1a          	movzwl 0x1a(%esi),%eax
                Rcu::call (node);

            if (preempt)
                Cpu::preempt_enable();

            ptr = ACCESS_ONCE (node->prev);
c000c93c:	8b 56 1c             	mov    0x1c(%esi),%edx

            if (node->dpth <= d)
c000c93f:	3b 44 24 04          	cmp    0x4(%esp),%eax
c000c943:	76 07                	jbe    c000c94c <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x2a4>
        Mdb *x = ACCESS_ONCE (node->next);
        assert (x->dpth <= d || (x->dpth == node->dpth + 1 && !(x->node_attr & attr)));

        bool preempt = Cpu::preemption;

        for (Mdb *ptr;; node = ptr) {
c000c945:	89 d6                	mov    %edx,%esi
c000c947:	e9 37 ff ff ff       	jmp    c000c883 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x1db>

            if (node->dpth <= d)
                break;
        }

        assert (node == mdb);
c000c94c:	39 fe                	cmp    %edi,%esi
c000c94e:	0f 84 2c fe ff ff    	je     c000c780 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0xd8>
c000c954:	68 40 8a 01 c0       	push   $0xc0018a40
c000c959:	68 c2 00 00 00       	push   $0xc2
c000c95e:	68 b1 87 01 c0       	push   $0xc00187b1
c000c963:	68 56 88 01 c0       	push   $0xc0018856
c000c968:	e9 f8 fe ff ff       	jmp    c000c865 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x1bd>
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
c000c96d:	a1 f0 f7 ff cf       	mov    0xcffff7f0,%eax
c000c972:	39 e8                	cmp    %ebp,%eax
c000c974:	0f 84 6f ff ff ff    	je     c000c8e9 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x241>
                trace (0, "warning: rcu element already enqueued");
                return;
            }

            count ++;
c000c97a:	ff 05 f4 f7 ff cf    	incl   0xcffff7f4

           *tail = e;
c000c980:	89 28                	mov    %ebp,(%eax)
            tail = &e->next;
c000c982:	89 2d f0 f7 ff cf    	mov    %ebp,0xcffff7f0
c000c988:	eb 80                	jmp    c000c90a <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x262>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
c000c98a:	a1 08 00 00 00       	mov    0x8,%eax
c000c98f:	0f 0b                	ud2    
    }
}
c000c991:	83 c4 3c             	add    $0x3c,%esp
c000c994:	5b                   	pop    %ebx
c000c995:	5e                   	pop    %esi
c000c996:	5f                   	pop    %edi
c000c997:	5d                   	pop    %ebp
c000c998:	c3                   	ret    

c000c999 <_ZN2Pd8pre_freeEP8Rcu_elem>:
        mword clamp (mword,   mword &, mword, mword);

        WARN_UNUSED_RESULT
        mword clamp (mword &, mword &, mword, mword, mword);

        static void pre_free (Rcu_elem * a)
c000c999:	53                   	push   %ebx
        {
            Pd * pd = static_cast <Pd *>(a);
c000c99a:	85 c0                	test   %eax,%eax

            Crd crd(Crd::MEM);
            pd->revoke<Space_mem>(crd.base(), crd.order(), crd.attr(), true, false);
c000c99c:	6a 00                	push   $0x0
        WARN_UNUSED_RESULT
        mword clamp (mword &, mword &, mword, mword, mword);

        static void pre_free (Rcu_elem * a)
        {
            Pd * pd = static_cast <Pd *>(a);
c000c99e:	bb 00 00 00 00       	mov    $0x0,%ebx
c000c9a3:	8d 50 f4             	lea    -0xc(%eax),%edx

            Crd crd(Crd::MEM);
            pd->revoke<Space_mem>(crd.base(), crd.order(), crd.attr(), true, false);
c000c9a6:	b9 1f 00 00 00       	mov    $0x1f,%ecx
        WARN_UNUSED_RESULT
        mword clamp (mword &, mword &, mword, mword, mword);

        static void pre_free (Rcu_elem * a)
        {
            Pd * pd = static_cast <Pd *>(a);
c000c9ab:	0f 45 da             	cmovne %edx,%ebx

            Crd crd(Crd::MEM);
            pd->revoke<Space_mem>(crd.base(), crd.order(), crd.attr(), true, false);
c000c9ae:	31 d2                	xor    %edx,%edx
c000c9b0:	6a 01                	push   $0x1
c000c9b2:	89 d8                	mov    %ebx,%eax
c000c9b4:	6a 1f                	push   $0x1f
c000c9b6:	e8 0b f7 ff ff       	call   c000c0c6 <_ZN2Pd6revokeI9Space_memEEvmmmbb>

            crd = Crd(Crd::PIO);
            pd->revoke<Space_pio>(crd.base(), crd.order(), crd.attr(), true, false);
c000c9bb:	89 d8                	mov    %ebx,%eax
c000c9bd:	b9 1f 00 00 00       	mov    $0x1f,%ecx
c000c9c2:	6a 00                	push   $0x0
c000c9c4:	31 d2                	xor    %edx,%edx
c000c9c6:	6a 01                	push   $0x1
c000c9c8:	6a 1f                	push   $0x1f
c000c9ca:	e8 e7 f9 ff ff       	call   c000c3b6 <_ZN2Pd6revokeI9Space_pioEEvmmmbb>

            crd = Crd(Crd::OBJ);
            pd->revoke<Space_obj>(crd.base(), crd.order(), crd.attr(), true, false);
c000c9cf:	89 d8                	mov    %ebx,%eax
c000c9d1:	b9 1f 00 00 00       	mov    $0x1f,%ecx
c000c9d6:	6a 00                	push   $0x0
c000c9d8:	31 d2                	xor    %edx,%edx
c000c9da:	6a 01                	push   $0x1
c000c9dc:	6a 1f                	push   $0x1f
c000c9de:	e8 c5 fc ff ff       	call   c000c6a8 <_ZN2Pd6revokeI9Space_objEEvmmmbb>
c000c9e3:	83 c4 24             	add    $0x24,%esp
        }
c000c9e6:	5b                   	pop    %ebx
c000c9e7:	c3                   	ret    

c000c9e8 <_ZN2PdD1Ev>:
        if (d)
            *d-- = Xfer (crd, s->flags() | set_as_del);
    }
}

Pd::~Pd()
c000c9e8:	55                   	push   %ebp
c000c9e9:	57                   	push   %edi
    pre_free(this);

    Space_mem::hpt.clear(quota, Space_mem::hpt.dest_hpt, Space_mem::hpt.iter_hpt_lev);
    Space_mem::dpt.clear(quota);
    Space_mem::npt.clear(quota);
    for (unsigned cpu = 0; cpu < NUM_CPU; cpu++)
c000c9ea:	31 ff                	xor    %edi,%edi
        if (d)
            *d-- = Xfer (crd, s->flags() | set_as_del);
    }
}

Pd::~Pd()
c000c9ec:	56                   	push   %esi
c000c9ed:	53                   	push   %ebx
c000c9ee:	89 c3                	mov    %eax,%ebx
{
    pre_free(this);

    Space_mem::hpt.clear(quota, Space_mem::hpt.dest_hpt, Space_mem::hpt.iter_hpt_lev);
c000c9f0:	8d b3 90 01 00 00    	lea    0x190(%ebx),%esi
    }
}

Pd::~Pd()
{
    pre_free(this);
c000c9f6:	8d 40 0c             	lea    0xc(%eax),%eax
c000c9f9:	e8 9b ff ff ff       	call   c000c999 <_ZN2Pd8pre_freeEP8Rcu_elem>

    Space_mem::hpt.clear(quota, Space_mem::hpt.dest_hpt, Space_mem::hpt.iter_hpt_lev);
c000c9fe:	8d 83 54 01 00 00    	lea    0x154(%ebx),%eax
c000ca04:	b9 66 b9 00 c0       	mov    $0xc000b966,%ecx
c000ca09:	68 92 b9 00 c0       	push   $0xc000b992
c000ca0e:	89 f2                	mov    %esi,%edx
c000ca10:	e8 a1 17 00 00       	call   c000e1b6 <_ZN3PteI3HptmLj2ELj10ELb0EE5clearER5QuotaPFbmmjEPFbjmE>
    Space_mem::dpt.clear(quota);
c000ca15:	8d 83 58 01 00 00    	lea    0x158(%ebx),%eax
c000ca1b:	31 c9                	xor    %ecx,%ecx
c000ca1d:	6a 00                	push   $0x0
c000ca1f:	89 f2                	mov    %esi,%edx
c000ca21:	e8 9c 11 00 00       	call   c000dbc2 <_ZN3PteI3DptyLj4ELj9ELb1EE5clearER5QuotaPFbmmjEPFbjmE>
    Space_mem::npt.clear(quota);
c000ca26:	8d 83 60 01 00 00    	lea    0x160(%ebx),%eax
c000ca2c:	31 c9                	xor    %ecx,%ecx
c000ca2e:	6a 00                	push   $0x0
c000ca30:	89 f2                	mov    %esi,%edx
c000ca32:	e8 7f 17 00 00       	call   c000e1b6 <_ZN3PteI3HptmLj2ELj10ELb0EE5clearER5QuotaPFbmmjEPFbjmE>
c000ca37:	8d 6b 54             	lea    0x54(%ebx),%ebp
c000ca3a:	83 c4 0c             	add    $0xc,%esp
            Atomic::clr_mask (hip()->api_flg, static_cast<typeof hip()->api_flg>(f));
        }

        static bool cpu_online (unsigned long cpu)
        {
            return cpu < NUM_CPU && hip()->cpu_desc[cpu].flags & 1;
c000ca3d:	f6 04 fd 38 e0 01 c0 	testb  $0x1,-0x3ffe1fc8(,%edi,8)
c000ca44:	01 
c000ca45:	75 31                	jne    c000ca78 <_ZN2PdD1Ev+0x90>
    for (unsigned cpu = 0; cpu < NUM_CPU; cpu++)
c000ca47:	47                   	inc    %edi
c000ca48:	83 c5 04             	add    $0x4,%ebp
c000ca4b:	83 ff 40             	cmp    $0x40,%edi
c000ca4e:	75 ed                	jne    c000ca3d <_ZN2PdD1Ev+0x55>
        }

        ALWAYS_INLINE
        inline ~Space_mem()
        {
            if (did == NO_PCID)
c000ca50:	8b 83 68 01 00 00    	mov    0x168(%ebx),%eax
c000ca56:	83 f8 02             	cmp    $0x2,%eax
c000ca59:	0f 84 85 00 00 00    	je     c000cae4 <_ZN2PdD1Ev+0xfc>
               return;

            mword i = did / (sizeof(did_c[0]) * 8);
c000ca5f:	89 c2                	mov    %eax,%edx
            mword b = did % (sizeof(did_c[0]) * 8);
c000ca61:	83 e0 1f             	and    $0x1f,%eax
        inline ~Space_mem()
        {
            if (did == NO_PCID)
               return;

            mword i = did / (sizeof(did_c[0]) * 8);
c000ca64:	c1 ea 05             	shr    $0x5,%edx
            mword b = did % (sizeof(did_c[0]) * 8);

            assert (!((i == 0 && b == 0) || (i == 0 && b == 1)));
c000ca67:	89 c1                	mov    %eax,%ecx
c000ca69:	09 d1                	or     %edx,%ecx
c000ca6b:	74 21                	je     c000ca8e <_ZN2PdD1Ev+0xa6>
c000ca6d:	83 f8 01             	cmp    $0x1,%eax
c000ca70:	75 37                	jne    c000caa9 <_ZN2PdD1Ev+0xc1>
c000ca72:	85 d2                	test   %edx,%edx
c000ca74:	74 18                	je     c000ca8e <_ZN2PdD1Ev+0xa6>
c000ca76:	eb 31                	jmp    c000caa9 <_ZN2PdD1Ev+0xc1>
        if (Hip::cpu_online (cpu))
            Space_mem::loc[cpu].clear(quota, Space_mem::hpt.dest_loc, Space_mem::hpt.iter_loc_lev);
c000ca78:	68 8b b9 00 c0       	push   $0xc000b98b
c000ca7d:	89 e8                	mov    %ebp,%eax
c000ca7f:	b9 79 b9 00 c0       	mov    $0xc000b979,%ecx
c000ca84:	89 f2                	mov    %esi,%edx
c000ca86:	e8 2b 17 00 00       	call   c000e1b6 <_ZN3PteI3HptmLj2ELj10ELb0EE5clearER5QuotaPFbmmjEPFbjmE>
c000ca8b:	58                   	pop    %eax
c000ca8c:	eb b9                	jmp    c000ca47 <_ZN2PdD1Ev+0x5f>
c000ca8e:	68 b8 89 01 c0       	push   $0xc00189b8
c000ca93:	6a 64                	push   $0x64
c000ca95:	68 f9 6a 01 c0       	push   $0xc0016af9
c000ca9a:	68 b7 88 01 c0       	push   $0xc00188b7
            assert (i <= LAST_PCID);

            bool s = Atomic::test_clr_bit (did_c[i], b);
            assert(s);
c000ca9f:	68 69 60 01 c0       	push   $0xc0016069
c000caa4:	e8 9d 4e ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

            mword i = did / (sizeof(did_c[0]) * 8);
            mword b = did % (sizeof(did_c[0]) * 8);

            assert (!((i == 0 && b == 0) || (i == 0 && b == 1)));
            assert (i <= LAST_PCID);
c000caa9:	83 fa 7f             	cmp    $0x7f,%edx
c000caac:	76 13                	jbe    c000cac1 <_ZN2PdD1Ev+0xd9>
c000caae:	68 b8 89 01 c0       	push   $0xc00189b8
c000cab3:	6a 65                	push   $0x65
c000cab5:	68 f9 6a 01 c0       	push   $0xc0016af9
c000caba:	68 a8 88 01 c0       	push   $0xc00188a8
c000cabf:	eb de                	jmp    c000ca9f <_ZN2PdD1Ev+0xb7>
        template <typename T>
        ALWAYS_INLINE
        static inline bool test_clr_bit (T &val, unsigned long bit)
        {
            bool ret;
            asm volatile ("lock; btr%z1 %2, %1; setc %0" : "=q" (ret), "+m" (val) : "ir" (bit) : "cc");
c000cac1:	f0 0f b3 04 95 e0 b4 	lock btr %eax,-0x3ffe4b20(,%edx,4)
c000cac8:	01 c0 
c000caca:	0f 92 c0             	setb   %al

            bool s = Atomic::test_clr_bit (did_c[i], b);
            assert(s);
c000cacd:	84 c0                	test   %al,%al
c000cacf:	75 13                	jne    c000cae4 <_ZN2PdD1Ev+0xfc>
c000cad1:	68 b8 89 01 c0       	push   $0xc00189b8
c000cad6:	6a 68                	push   $0x68
c000cad8:	68 f9 6a 01 c0       	push   $0xc0016af9
c000cadd:	68 66 8e 01 c0       	push   $0xc0018e66
c000cae2:	eb bb                	jmp    c000ca9f <_ZN2PdD1Ev+0xb7>
}
c000cae4:	5b                   	pop    %ebx
c000cae5:	5e                   	pop    %esi
c000cae6:	5f                   	pop    %edi
c000cae7:	5d                   	pop    %ebp
c000cae8:	c3                   	ret    

c000cae9 <_ZN2Pd4freeEP8Rcu_elem>:

        static void free (Rcu_elem * a) {
c000cae9:	56                   	push   %esi
            Pd * pd = static_cast <Pd *>(a);
c000caea:	85 c0                	test   %eax,%eax

            crd = Crd(Crd::OBJ);
            pd->revoke<Space_obj>(crd.base(), crd.order(), crd.attr(), true, false);
        }

        static void free (Rcu_elem * a) {
c000caec:	53                   	push   %ebx
            Pd * pd = static_cast <Pd *>(a);
c000caed:	8d 58 f4             	lea    -0xc(%eax),%ebx
c000caf0:	b8 00 00 00 00       	mov    $0x0,%eax
c000caf5:	0f 44 d8             	cmove  %eax,%ebx
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c000caf8:	83 ce ff             	or     $0xffffffff,%esi
c000cafb:	f0 0f c1 73 48       	lock xadd %esi,0x48(%ebx)

            if (pd->del_ref()) {
c000cb00:	4e                   	dec    %esi
c000cb01:	75 5f                	jne    c000cb62 <_ZN2Pd4freeEP8Rcu_elem+0x79>
                assert (pd != Pd::current);
c000cb03:	3b 1d 0c f0 ff cf    	cmp    0xcffff00c,%ebx
c000cb09:	75 1b                	jne    c000cb26 <_ZN2Pd4freeEP8Rcu_elem+0x3d>
c000cb0b:	68 20 8a 01 c0       	push   $0xc0018a20
c000cb10:	6a 3a                	push   $0x3a
c000cb12:	68 18 73 01 c0       	push   $0xc0017318
c000cb17:	68 e3 88 01 c0       	push   $0xc00188e3
c000cb1c:	68 69 60 01 c0       	push   $0xc0016069
c000cb21:	e8 20 4e ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>
                delete pd;
c000cb26:	85 db                	test   %ebx,%ebx
c000cb28:	74 38                	je     c000cb62 <_ZN2Pd4freeEP8Rcu_elem+0x79>
c000cb2a:	89 d8                	mov    %ebx,%eax
c000cb2c:	e8 b7 fe ff ff       	call   c000c9e8 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c000cb31:	8b 53 28             	mov    0x28(%ebx),%edx
c000cb34:	85 d2                	test   %edx,%edx
c000cb36:	8d 82 78 fe ff ff    	lea    -0x188(%edx),%eax
c000cb3c:	0f 45 f0             	cmovne %eax,%esi

            pd_del->quota.free_up(pd_to->quota);
c000cb3f:	81 c6 90 01 00 00    	add    $0x190,%esi
c000cb45:	8d 83 90 01 00 00    	lea    0x190(%ebx),%eax
c000cb4b:	89 f2                	mov    %esi,%edx
c000cb4d:	e8 7a 5e ff ff       	call   c00029cc <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
c000cb52:	89 da                	mov    %ebx,%edx
c000cb54:	89 f1                	mov    %esi,%ecx

            if (pd->del_ref()) {
                assert (pd != Pd::current);
                delete pd;
            }
        }
c000cb56:	5b                   	pop    %ebx
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));

            pd_del->quota.free_up(pd_to->quota);

            cache.free (ptr, pd_to->quota);
c000cb57:	b8 64 b4 01 c0       	mov    $0xc001b464,%eax

            if (pd->del_ref()) {
                assert (pd != Pd::current);
                delete pd;
            }
        }
c000cb5c:	5e                   	pop    %esi
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));

            pd_del->quota.free_up(pd_to->quota);

            cache.free (ptr, pd_to->quota);
c000cb5d:	e9 fe 37 00 00       	jmp    c0010360 <_ZN10Slab_cache4freeEPvR5Quota>

            if (pd->del_ref()) {
                assert (pd != Pd::current);
                delete pd;
            }
        }
c000cb62:	5b                   	pop    %ebx
c000cb63:	5e                   	pop    %esi
c000cb64:	c3                   	ret    
c000cb65:	90                   	nop

c000cb66 <_ZN2Pd7rev_crdE3Crdbbb>:
    if (s)
        shootdown();
}

void Pd::rev_crd (Crd crd, bool self, bool preempt, bool kim)
{
c000cb66:	55                   	push   %ebp
c000cb67:	57                   	push   %edi
c000cb68:	56                   	push   %esi
c000cb69:	89 d6                	mov    %edx,%esi
c000cb6b:	53                   	push   %ebx
c000cb6c:	53                   	push   %ebx
c000cb6d:	8a 5c 24 18          	mov    0x18(%esp),%bl
c000cb71:	8a 54 24 1c          	mov    0x1c(%esp),%dl
c000cb75:	88 4c 24 02          	mov    %cl,0x2(%esp)
    if (preempt)
c000cb79:	84 db                	test   %bl,%bl
    if (s)
        shootdown();
}

void Pd::rev_crd (Crd crd, bool self, bool preempt, bool kim)
{
c000cb7b:	88 54 24 03          	mov    %dl,0x3(%esp)
    if (preempt)
c000cb7f:	74 2a                	je     c000cbab <_ZN2Pd7rev_crdE3Crdbbb+0x45>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000cb81:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000cb88:	74 19                	je     c000cba3 <_ZN2Pd7rev_crdE3Crdbbb+0x3d>
c000cb8a:	68 e0 8b 01 c0       	push   $0xc0018be0
c000cb8f:	68 c0 00 00 00       	push   $0xc0
c000cb94:	68 12 61 01 c0       	push   $0xc0016112
c000cb99:	68 82 61 01 c0       	push   $0xc0016182
c000cb9e:	e9 b3 00 00 00       	jmp    c000cc56 <_ZN2Pd7rev_crdE3Crdbbb+0xf0>

            preemption = true;
c000cba3:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000cbaa:	fb                   	sti    

        ALWAYS_INLINE
        inline Type type() const { return static_cast<Type>(val & 0x3); }
c000cbab:	89 f5                	mov    %esi,%ebp
c000cbad:	83 e5 03             	and    $0x3,%ebp
        Cpu::preempt_enable();

    switch (crd.type()) {
c000cbb0:	83 fd 02             	cmp    $0x2,%ebp
c000cbb3:	74 31                	je     c000cbe6 <_ZN2Pd7rev_crdE3Crdbbb+0x80>
c000cbb5:	83 fd 03             	cmp    $0x3,%ebp
c000cbb8:	74 53                	je     c000cc0d <_ZN2Pd7rev_crdE3Crdbbb+0xa7>
c000cbba:	83 fd 01             	cmp    $0x1,%ebp
c000cbbd:	75 76                	jne    c000cc35 <_ZN2Pd7rev_crdE3Crdbbb+0xcf>

        case Crd::MEM:
            trace (TRACE_REV, "REV MEM PD:%p B:%#010lx O:%#04x A:%#04x %s", this, crd.base(), crd.order(), crd.attr(), self ? "+" : "-");
            revoke<Space_mem>(crd.base(), crd.order(), crd.attr(), self, kim);
c000cbbf:	0f b6 7c 24 03       	movzbl 0x3(%esp),%edi

        ALWAYS_INLINE
        inline unsigned attr() const { return val >> 2 & 0x1f; }

        ALWAYS_INLINE
        inline unsigned order() const { return val >> 7 & 0x1f; }
c000cbc4:	89 f1                	mov    %esi,%ecx

        ALWAYS_INLINE
        inline mword base() const { return val >> 12; }
c000cbc6:	89 f2                	mov    %esi,%edx

        ALWAYS_INLINE
        inline Type type() const { return static_cast<Type>(val & 0x3); }

        ALWAYS_INLINE
        inline unsigned attr() const { return val >> 2 & 0x1f; }
c000cbc8:	c1 ee 02             	shr    $0x2,%esi

        ALWAYS_INLINE
        inline unsigned order() const { return val >> 7 & 0x1f; }
c000cbcb:	c1 e9 07             	shr    $0x7,%ecx

        ALWAYS_INLINE
        inline Type type() const { return static_cast<Type>(val & 0x3); }

        ALWAYS_INLINE
        inline unsigned attr() const { return val >> 2 & 0x1f; }
c000cbce:	83 e6 1f             	and    $0x1f,%esi

        ALWAYS_INLINE
        inline unsigned order() const { return val >> 7 & 0x1f; }
c000cbd1:	83 e1 1f             	and    $0x1f,%ecx
c000cbd4:	57                   	push   %edi
c000cbd5:	0f b6 7c 24 06       	movzbl 0x6(%esp),%edi

        ALWAYS_INLINE
        inline mword base() const { return val >> 12; }
c000cbda:	c1 ea 0c             	shr    $0xc,%edx
c000cbdd:	57                   	push   %edi
c000cbde:	56                   	push   %esi
c000cbdf:	e8 e2 f4 ff ff       	call   c000c0c6 <_ZN2Pd6revokeI9Space_memEEvmmmbb>
c000cbe4:	eb 4c                	jmp    c000cc32 <_ZN2Pd7rev_crdE3Crdbbb+0xcc>
            break;

        case Crd::PIO:
            trace (TRACE_REV, "REV I/O PD:%p B:%#010lx O:%#04x A:%#04x %s", this, crd.base(), crd.order(), crd.attr(), self ? "+" : "-");
            revoke<Space_pio>(crd.base(), crd.order(), crd.attr(), self, kim);
c000cbe6:	0f b6 7c 24 03       	movzbl 0x3(%esp),%edi

        ALWAYS_INLINE
        inline unsigned attr() const { return val >> 2 & 0x1f; }

        ALWAYS_INLINE
        inline unsigned order() const { return val >> 7 & 0x1f; }
c000cbeb:	89 f1                	mov    %esi,%ecx

        ALWAYS_INLINE
        inline mword base() const { return val >> 12; }
c000cbed:	89 f2                	mov    %esi,%edx

        ALWAYS_INLINE
        inline Type type() const { return static_cast<Type>(val & 0x3); }

        ALWAYS_INLINE
        inline unsigned attr() const { return val >> 2 & 0x1f; }
c000cbef:	c1 ee 02             	shr    $0x2,%esi

        ALWAYS_INLINE
        inline unsigned order() const { return val >> 7 & 0x1f; }
c000cbf2:	c1 e9 07             	shr    $0x7,%ecx

        ALWAYS_INLINE
        inline Type type() const { return static_cast<Type>(val & 0x3); }

        ALWAYS_INLINE
        inline unsigned attr() const { return val >> 2 & 0x1f; }
c000cbf5:	83 e6 1f             	and    $0x1f,%esi

        ALWAYS_INLINE
        inline unsigned order() const { return val >> 7 & 0x1f; }
c000cbf8:	83 e1 1f             	and    $0x1f,%ecx
c000cbfb:	57                   	push   %edi
c000cbfc:	0f b6 7c 24 06       	movzbl 0x6(%esp),%edi

        ALWAYS_INLINE
        inline mword base() const { return val >> 12; }
c000cc01:	c1 ea 0c             	shr    $0xc,%edx
c000cc04:	57                   	push   %edi
c000cc05:	56                   	push   %esi
c000cc06:	e8 ab f7 ff ff       	call   c000c3b6 <_ZN2Pd6revokeI9Space_pioEEvmmmbb>
c000cc0b:	eb 25                	jmp    c000cc32 <_ZN2Pd7rev_crdE3Crdbbb+0xcc>
            break;

        case Crd::OBJ:
            trace (TRACE_REV, "REV OBJ PD:%p B:%#010lx O:%#04x A:%#04x %s", this, crd.base(), crd.order(), crd.attr(), self ? "+" : "-");
            revoke<Space_obj>(crd.base(), crd.order(), crd.attr(), self, kim);
c000cc0d:	0f b6 7c 24 03       	movzbl 0x3(%esp),%edi

        ALWAYS_INLINE
        inline unsigned attr() const { return val >> 2 & 0x1f; }

        ALWAYS_INLINE
        inline unsigned order() const { return val >> 7 & 0x1f; }
c000cc12:	89 f1                	mov    %esi,%ecx

        ALWAYS_INLINE
        inline mword base() const { return val >> 12; }
c000cc14:	89 f2                	mov    %esi,%edx

        ALWAYS_INLINE
        inline Type type() const { return static_cast<Type>(val & 0x3); }

        ALWAYS_INLINE
        inline unsigned attr() const { return val >> 2 & 0x1f; }
c000cc16:	c1 ee 02             	shr    $0x2,%esi

        ALWAYS_INLINE
        inline unsigned order() const { return val >> 7 & 0x1f; }
c000cc19:	c1 e9 07             	shr    $0x7,%ecx

        ALWAYS_INLINE
        inline Type type() const { return static_cast<Type>(val & 0x3); }

        ALWAYS_INLINE
        inline unsigned attr() const { return val >> 2 & 0x1f; }
c000cc1c:	83 e6 1f             	and    $0x1f,%esi

        ALWAYS_INLINE
        inline unsigned order() const { return val >> 7 & 0x1f; }
c000cc1f:	83 e1 1f             	and    $0x1f,%ecx
c000cc22:	57                   	push   %edi
c000cc23:	0f b6 7c 24 06       	movzbl 0x6(%esp),%edi

        ALWAYS_INLINE
        inline mword base() const { return val >> 12; }
c000cc28:	c1 ea 0c             	shr    $0xc,%edx
c000cc2b:	57                   	push   %edi
c000cc2c:	56                   	push   %esi
c000cc2d:	e8 76 fa ff ff       	call   c000c6a8 <_ZN2Pd6revokeI9Space_objEEvmmmbb>
            break;
c000cc32:	83 c4 0c             	add    $0xc,%esp
    }

    if (preempt)
c000cc35:	84 db                	test   %bl,%bl
c000cc37:	74 2f                	je     c000cc68 <_ZN2Pd7rev_crdE3Crdbbb+0x102>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c000cc39:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000cc40:	75 1e                	jne    c000cc60 <_ZN2Pd7rev_crdE3Crdbbb+0xfa>
c000cc42:	68 20 8c 01 c0       	push   $0xc0018c20
c000cc47:	68 b7 00 00 00       	push   $0xb7
c000cc4c:	68 12 61 01 c0       	push   $0xc0016112
c000cc51:	68 83 61 01 c0       	push   $0xc0016183
c000cc56:	68 69 60 01 c0       	push   $0xc0016069
c000cc5b:	e8 e6 4c ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

            asm volatile ("cli" : : : "memory");
c000cc60:	fa                   	cli    
            preemption = false;
c000cc61:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
        Cpu::preempt_disable();

    if (crd.type() == Crd::MEM)
c000cc68:	4d                   	dec    %ebp
c000cc69:	75 0a                	jne    c000cc75 <_ZN2Pd7rev_crdE3Crdbbb+0x10f>
        shootdown();
}
c000cc6b:	5a                   	pop    %edx
c000cc6c:	5b                   	pop    %ebx
c000cc6d:	5e                   	pop    %esi
c000cc6e:	5f                   	pop    %edi
c000cc6f:	5d                   	pop    %ebp

    if (preempt)
        Cpu::preempt_disable();

    if (crd.type() == Crd::MEM)
        shootdown();
c000cc70:	e9 fd 40 00 00       	jmp    c0010d72 <_ZN9Space_mem9shootdownEv>
}
c000cc75:	58                   	pop    %eax
c000cc76:	5b                   	pop    %ebx
c000cc77:	5e                   	pop    %esi
c000cc78:	5f                   	pop    %edi
c000cc79:	5d                   	pop    %ebp
c000cc7a:	c3                   	ret    
c000cc7b:	90                   	nop

c000cc7c <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc>:

    Mdb::destroy (mdb, pd->quota);
}

template <typename S>
bool Pd::delegate (Pd *snd, mword const snd_base, mword const rcv_base, mword const ord, mword const attr, mword const sub, char const * deltype)
c000cc7c:	55                   	push   %ebp
c000cc7d:	89 c5                	mov    %eax,%ebp
c000cc7f:	57                   	push   %edi
c000cc80:	89 cf                	mov    %ecx,%edi
c000cc82:	56                   	push   %esi
c000cc83:	53                   	push   %ebx
c000cc84:	83 ec 38             	sub    $0x38,%esp
c000cc87:	8d 44 24 20          	lea    0x20(%esp),%eax
c000cc8b:	89 54 24 04          	mov    %edx,0x4(%esp)
c000cc8f:	e8 e2 ed ff ff       	call   c000ba76 <_ZN5QuotaC1Ev>
{
    bool s = false;

    Quota_guard qg(this->quota);
c000cc94:	8d 85 90 01 00 00    	lea    0x190(%ebp),%eax

    Mdb *mdb;
    for (mword addr = snd_base; (mdb = snd->S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {
c000cc9a:	89 fa                	mov    %edi,%edx
template <typename S>
bool Pd::delegate (Pd *snd, mword const snd_base, mword const rcv_base, mword const ord, mword const attr, mword const sub, char const * deltype)
{
    bool s = false;

    Quota_guard qg(this->quota);
c000cc9c:	89 44 24 34          	mov    %eax,0x34(%esp)
        }

        if (!node->insert_node (mdb, attr)) {
            S::tree_remove (node);
            Mdb::destroy (node, qg);
            trace (0, "overmap attempt %s - node - PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx SUB:%lx", deltype, snd, this, snd_base, rcv_base, ord, attr, sub);
c000cca0:	8d 44 24 1b          	lea    0x1b(%esp),%eax
c000cca4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}

template <typename S>
bool Pd::delegate (Pd *snd, mword const snd_base, mword const rcv_base, mword const ord, mword const attr, mword const sub, char const * deltype)
{
    bool s = false;
c000cca9:	c6 44 24 0b 00       	movb   $0x0,0xb(%esp)
        }

        if (!node->insert_node (mdb, attr)) {
            S::tree_remove (node);
            Mdb::destroy (node, qg);
            trace (0, "overmap attempt %s - node - PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx SUB:%lx", deltype, snd, this, snd_base, rcv_base, ord, attr, sub);
c000ccae:	89 44 24 0c          	mov    %eax,0xc(%esp)
    bool s = false;

    Quota_guard qg(this->quota);

    Mdb *mdb;
    for (mword addr = snd_base; (mdb = snd->S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {
c000ccb2:	8b 44 24 04          	mov    0x4(%esp),%eax
c000ccb6:	b9 01 00 00 00       	mov    $0x1,%ecx
c000ccbb:	83 c0 4c             	add    $0x4c,%eax
c000ccbe:	e8 17 ee ff ff       	call   c000bada <_ZN5Space11tree_lookupEmb>
c000ccc3:	85 c0                	test   %eax,%eax
c000ccc5:	89 c6                	mov    %eax,%esi
c000ccc7:	0f 84 f8 01 00 00    	je     c000cec5 <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x249>

        mword o, b = snd_base;
c000cccd:	89 7c 24 18          	mov    %edi,0x18(%esp)
        if ((o = clamp (mdb->node_base, b, mdb->node_order, ord)) == ~0UL)
c000ccd1:	8b 56 30             	mov    0x30(%esi),%edx
c000ccd4:	89 e8                	mov    %ebp,%eax
c000ccd6:	ff 74 24 50          	pushl  0x50(%esp)
c000ccda:	ff 76 34             	pushl  0x34(%esi)
c000ccdd:	8d 4c 24 20          	lea    0x20(%esp),%ecx
c000cce1:	e8 5e f1 ff ff       	call   c000be44 <_ZN2Pd5clampEmRmmm>
c000cce6:	89 c1                	mov    %eax,%ecx
c000cce8:	58                   	pop    %eax
c000cce9:	83 f9 ff             	cmp    $0xffffffff,%ecx
c000ccec:	5a                   	pop    %edx
c000cced:	0f 84 d2 01 00 00    	je     c000cec5 <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x249>
            }
        }

        bool hit_limit(mword free_space = 0)
        {
             if (free_space > upli)
c000ccf3:	8b 85 9c 01 00 00    	mov    0x19c(%ebp),%eax
c000ccf9:	85 c0                	test   %eax,%eax
c000ccfb:	0f 84 d3 01 00 00    	je     c000ced4 <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x258>
                 return true;

             return usage() > upli - free_space;
c000cd01:	48                   	dec    %eax
            break;

        if (quota.hit_limit(1)) {
c000cd02:	39 85 94 01 00 00    	cmp    %eax,0x194(%ebp)
c000cd08:	89 4c 24 14          	mov    %ecx,0x14(%esp)
c000cd0c:	0f 87 c2 01 00 00    	ja     c000ced4 <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x258>
        static void shootdown();

        void init (Quota &quota, unsigned);

        ALWAYS_INLINE
        inline mword sticky_sub(mword s) { return s & 0x4; }
c000cd12:	8b 46 40             	mov    0x40(%esi),%eax
        bool insert_node (Mdb *, mword);
        void demote_node (mword);
        bool remove_node();

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
c000cd15:	8d 54 24 20          	lea    0x20(%esp),%edx
c000cd19:	83 e0 04             	and    $0x4,%eax
            Cpu::hazard |= HZD_OOM;
            return s;
        }

        Mdb *node = new (qg) Mdb (static_cast<S *>(this), free_mdb<S>, b - mdb->node_base + mdb->node_phys, b - snd_base + rcv_base, o, 0, mdb->node_type, S::sticky_sub(mdb->node_sub) | sub);
c000cd1c:	0b 44 24 58          	or     0x58(%esp),%eax
c000cd20:	89 44 24 10          	mov    %eax,0x10(%esp)
c000cd24:	b8 80 b0 01 c0       	mov    $0xc001b080,%eax
c000cd29:	e8 48 35 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c000cd2e:	8d 4d 4c             	lea    0x4c(%ebp),%ecx
c000cd31:	89 0c 24             	mov    %ecx,(%esp)
c000cd34:	89 c3                	mov    %eax,%ebx
c000cd36:	8b 44 24 18          	mov    0x18(%esp),%eax
c000cd3a:	ff 74 24 10          	pushl  0x10(%esp)
c000cd3e:	ff 76 3c             	pushl  0x3c(%esi)
c000cd41:	6a 00                	push   $0x0
c000cd43:	8b 4c 24 20          	mov    0x20(%esp),%ecx
c000cd47:	51                   	push   %ecx
c000cd48:	b9 a6 b9 00 c0       	mov    $0xc000b9a6,%ecx
c000cd4d:	8b 54 24 5c          	mov    0x5c(%esp),%edx
c000cd51:	01 c2                	add    %eax,%edx
c000cd53:	29 fa                	sub    %edi,%edx
c000cd55:	52                   	push   %edx
c000cd56:	03 46 2c             	add    0x2c(%esi),%eax
c000cd59:	2b 46 30             	sub    0x30(%esi),%eax
c000cd5c:	50                   	push   %eax
c000cd5d:	89 d8                	mov    %ebx,%eax
c000cd5f:	8b 54 24 18          	mov    0x18(%esp),%edx
c000cd63:	e8 2e 55 ff ff       	call   c0002296 <_ZN3MdbC1EP5SpacePFvP8Rcu_elemEmmmmmm>

        if (!S::tree_insert (node)) {
c000cd68:	89 d8                	mov    %ebx,%eax
c000cd6a:	e8 24 ee ff ff       	call   c000bb93 <_ZN5Space11tree_insertEP3Mdb>
c000cd6f:	83 c4 18             	add    $0x18,%esp
c000cd72:	84 c0                	test   %al,%al
c000cd74:	75 70                	jne    c000cde6 <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x16a>

        ALWAYS_INLINE
        static inline void destroy (Mdb *obj, Quota &quota) { obj->~Mdb(); cache.free (obj, quota); }
c000cd76:	8d 4c 24 20          	lea    0x20(%esp),%ecx
c000cd7a:	89 da                	mov    %ebx,%edx
c000cd7c:	b8 80 b0 01 c0       	mov    $0xc001b080,%eax
c000cd81:	e8 da 35 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
c000cd86:	8b 54 24 4c          	mov    0x4c(%esp),%edx
            Mdb::destroy (node, qg);

            Mdb * x = S::tree_lookup(b - snd_base + rcv_base);
c000cd8a:	31 c9                	xor    %ecx,%ecx
c000cd8c:	03 54 24 18          	add    0x18(%esp),%edx
c000cd90:	8b 04 24             	mov    (%esp),%eax
c000cd93:	29 fa                	sub    %edi,%edx
c000cd95:	e8 40 ed ff ff       	call   c000bada <_ZN5Space11tree_lookupEmb>
            if (!x || x->prnt != mdb || x->node_attr != attr)
c000cd9a:	85 c0                	test   %eax,%eax
c000cd9c:	74 12                	je     c000cdb0 <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x134>
c000cd9e:	39 70 24             	cmp    %esi,0x24(%eax)
c000cda1:	75 0d                	jne    c000cdb0 <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x134>
c000cda3:	8b 5c 24 54          	mov    0x54(%esp),%ebx
c000cda7:	39 58 38             	cmp    %ebx,0x38(%eax)
c000cdaa:	0f 84 03 01 00 00    	je     c000ceb3 <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x237>
                trace (0, "overmap attempt %s - tree - PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx SUB:%lx", deltype, snd, this, snd_base, rcv_base, ord, attr, sub);
c000cdb0:	81 7c 24 0c 00 d0 ff 	cmpl   $0xcfffd000,0xc(%esp)
c000cdb7:	cf 
c000cdb8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000cdbd:	ff 74 24 58          	pushl  0x58(%esp)
c000cdc1:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c000cdc8:	ff 74 24 58          	pushl  0x58(%esp)
c000cdcc:	ff 74 24 58          	pushl  0x58(%esp)
c000cdd0:	ff 74 24 58          	pushl  0x58(%esp)
c000cdd4:	57                   	push   %edi
c000cdd5:	55                   	push   %ebp
c000cdd6:	ff 74 24 1c          	pushl  0x1c(%esp)
c000cdda:	ff 74 24 78          	pushl  0x78(%esp)
c000cdde:	50                   	push   %eax
c000cddf:	68 f5 88 01 c0       	push   $0xc00188f5
c000cde4:	eb 61                	jmp    c000ce47 <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x1cb>

            continue;
        }

        if (!node->insert_node (mdb, attr)) {
c000cde6:	8b 4c 24 54          	mov    0x54(%esp),%ecx
c000cdea:	89 f2                	mov    %esi,%edx
c000cdec:	89 d8                	mov    %ebx,%eax
c000cdee:	e8 4d 93 ff ff       	call   c0006140 <_ZN3Mdb11insert_nodeEPS_m>
c000cdf3:	84 c0                	test   %al,%al
c000cdf5:	75 5a                	jne    c000ce51 <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x1d5>
            S::tree_remove (node);
c000cdf7:	ba 01 00 00 00       	mov    $0x1,%edx
c000cdfc:	89 d8                	mov    %ebx,%eax
c000cdfe:	e8 18 ee ff ff       	call   c000bc1b <_ZN5Space11tree_removeEP3MdbN3Avl5StateE>
c000ce03:	8d 4c 24 20          	lea    0x20(%esp),%ecx
c000ce07:	b8 80 b0 01 c0       	mov    $0xc001b080,%eax
c000ce0c:	89 da                	mov    %ebx,%edx
c000ce0e:	e8 4d 35 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
            Mdb::destroy (node, qg);
            trace (0, "overmap attempt %s - node - PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx SUB:%lx", deltype, snd, this, snd_base, rcv_base, ord, attr, sub);
c000ce13:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000ce18:	81 7c 24 0c 00 d0 ff 	cmpl   $0xcfffd000,0xc(%esp)
c000ce1f:	cf 
c000ce20:	ff 74 24 58          	pushl  0x58(%esp)
c000ce24:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c000ce2b:	ff 74 24 58          	pushl  0x58(%esp)
c000ce2f:	ff 74 24 58          	pushl  0x58(%esp)
c000ce33:	ff 74 24 58          	pushl  0x58(%esp)
c000ce37:	57                   	push   %edi
c000ce38:	55                   	push   %ebp
c000ce39:	ff 74 24 1c          	pushl  0x1c(%esp)
c000ce3d:	ff 74 24 78          	pushl  0x78(%esp)
c000ce41:	50                   	push   %eax
c000ce42:	68 50 89 01 c0       	push   $0xc0018950
c000ce47:	e8 92 4b ff ff       	call   c00019de <_ZN7Console5printEPKcz>
            continue;
c000ce4c:	83 c4 28             	add    $0x28,%esp
c000ce4f:	eb 62                	jmp    c000ceb3 <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x237>
        }

        s |= S::update (qg, node);
c000ce51:	6a 00                	push   $0x0
c000ce53:	89 d9                	mov    %ebx,%ecx
c000ce55:	8b 44 24 04          	mov    0x4(%esp),%eax
c000ce59:	8d 54 24 24          	lea    0x24(%esp),%edx
c000ce5d:	e8 a8 39 00 00       	call   c001080a <_ZN9Space_mem6updateER11Quota_guardP3Mdbm>
c000ce62:	08 44 24 0f          	or     %al,0xf(%esp)

        if (Cpu::hazard & HZD_OOM) {
c000ce66:	f6 05 00 f0 ff cf 20 	testb  $0x20,0xcffff000
c000ce6d:	58                   	pop    %eax
c000ce6e:	74 43                	je     c000ceb3 <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x237>
            S::update (qg, node, attr);
c000ce70:	ff 74 24 54          	pushl  0x54(%esp)
c000ce74:	89 d9                	mov    %ebx,%ecx
c000ce76:	8b 44 24 04          	mov    0x4(%esp),%eax
c000ce7a:	8d 54 24 24          	lea    0x24(%esp),%edx
c000ce7e:	e8 87 39 00 00       	call   c001080a <_ZN9Space_mem6updateER11Quota_guardP3Mdbm>
            node->demote_node (attr);
c000ce83:	8b 54 24 58          	mov    0x58(%esp),%edx
c000ce87:	89 d8                	mov    %ebx,%eax
c000ce89:	e8 76 93 ff ff       	call   c0006204 <_ZN3Mdb11demote_nodeEm>
            if (node->remove_node() && S::tree_remove (node))
c000ce8e:	89 d8                	mov    %ebx,%eax
c000ce90:	e8 f5 93 ff ff       	call   c000628a <_ZN3Mdb11remove_nodeEv>
c000ce95:	59                   	pop    %ecx
c000ce96:	84 c0                	test   %al,%al
c000ce98:	0f 84 a0 00 00 00    	je     c000cf3e <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x2c2>
c000ce9e:	ba 01 00 00 00       	mov    $0x1,%edx
c000cea3:	89 d8                	mov    %ebx,%eax
c000cea5:	e8 71 ed ff ff       	call   c000bc1b <_ZN5Space11tree_removeEP3MdbN3Avl5StateE>
c000ceaa:	84 c0                	test   %al,%al
c000ceac:	75 2f                	jne    c000cedd <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x261>
c000ceae:	e9 8b 00 00 00       	jmp    c000cf3e <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x2c2>
    bool s = false;

    Quota_guard qg(this->quota);

    Mdb *mdb;
    for (mword addr = snd_base; (mdb = snd->S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {
c000ceb3:	8b 4e 34             	mov    0x34(%esi),%ecx
c000ceb6:	ba 01 00 00 00       	mov    $0x1,%edx
c000cebb:	d3 e2                	shl    %cl,%edx
c000cebd:	03 56 30             	add    0x30(%esi),%edx
c000cec0:	e9 ed fd ff ff       	jmp    c000ccb2 <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x36>
                Rcu::call (node);
            return s;
        }
    }

    if (!qg.check(0))
c000cec5:	31 d2                	xor    %edx,%edx
c000cec7:	8d 44 24 20          	lea    0x20(%esp),%eax
c000cecb:	e8 c8 eb ff ff       	call   c000ba98 <_ZN11Quota_guard5checkEm>
c000ced0:	84 c0                	test   %al,%al
c000ced2:	75 6a                	jne    c000cf3e <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x2c2>
        Cpu::hazard |= HZD_OOM;
c000ced4:	83 0d 00 f0 ff cf 20 	orl    $0x20,0xcffff000

    return s;
c000cedb:	eb 61                	jmp    c000cf3e <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x2c2>

        if (Cpu::hazard & HZD_OOM) {
            S::update (qg, node, attr);
            node->demote_node (attr);
            if (node->remove_node() && S::tree_remove (node))
                Rcu::call (node);
c000cedd:	85 db                	test   %ebx,%ebx
c000cedf:	74 56                	je     c000cf37 <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x2bb>
c000cee1:	8b 53 14             	mov    0x14(%ebx),%edx
c000cee4:	8d 73 0c             	lea    0xc(%ebx),%esi
c000cee7:	85 d2                	test   %edx,%edx
c000cee9:	74 04                	je     c000ceef <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x273>
                e->pre_func(e);
c000ceeb:	89 f0                	mov    %esi,%eax
c000ceed:	ff d2                	call   *%edx
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
c000ceef:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
c000cef3:	75 09                	jne    c000cefe <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x282>
c000cef5:	a1 f0 f7 ff cf       	mov    0xcffff7f0,%eax
c000cefa:	39 f0                	cmp    %esi,%eax
c000cefc:	75 29                	jne    c000cf27 <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x2ab>
                trace (0, "warning: rcu element already enqueued");
c000cefe:	8d 44 24 1b          	lea    0x1b(%esp),%eax
c000cf02:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c000cf07:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c000cf0c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000cf11:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c000cf18:	50                   	push   %eax
c000cf19:	68 ae 6c 01 c0       	push   $0xc0016cae
c000cf1e:	e8 bb 4a ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c000cf23:	58                   	pop    %eax
c000cf24:	5a                   	pop    %edx
c000cf25:	eb 17                	jmp    c000cf3e <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x2c2>
                return;
            }

            count ++;
c000cf27:	ff 05 f4 f7 ff cf    	incl   0xcffff7f4

           *tail = e;
c000cf2d:	89 30                	mov    %esi,(%eax)
            tail = &e->next;
c000cf2f:	89 35 f0 f7 ff cf    	mov    %esi,0xcffff7f0
            return s;
c000cf35:	eb 07                	jmp    c000cf3e <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x2c2>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
c000cf37:	a1 08 00 00 00       	mov    0x8,%eax
c000cf3c:	0f 0b                	ud2    
    }

    if (!qg.check(0))
        Cpu::hazard |= HZD_OOM;

    return s;
c000cf3e:	8d 44 24 20          	lea    0x20(%esp),%eax
c000cf42:	e8 8b eb ff ff       	call   c000bad2 <_ZN11Quota_guardD1Ev>
}
c000cf47:	8a 44 24 0b          	mov    0xb(%esp),%al
c000cf4b:	83 c4 38             	add    $0x38,%esp
c000cf4e:	5b                   	pop    %ebx
c000cf4f:	5e                   	pop    %esi
c000cf50:	5f                   	pop    %edi
c000cf51:	5d                   	pop    %ebp
c000cf52:	c3                   	ret    
c000cf53:	90                   	nop

c000cf54 <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc>:

    Mdb::destroy (mdb, pd->quota);
}

template <typename S>
bool Pd::delegate (Pd *snd, mword const snd_base, mword const rcv_base, mword const ord, mword const attr, mword const sub, char const * deltype)
c000cf54:	55                   	push   %ebp
c000cf55:	89 cd                	mov    %ecx,%ebp
c000cf57:	57                   	push   %edi
c000cf58:	89 c7                	mov    %eax,%edi
c000cf5a:	56                   	push   %esi
c000cf5b:	53                   	push   %ebx
c000cf5c:	83 ec 34             	sub    $0x34,%esp
        Quota q;
        Quota &r;

    public:

        Quota_guard(Quota &ref) : q(), r(ref) { }
c000cf5f:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c000cf63:	89 54 24 04          	mov    %edx,0x4(%esp)
c000cf67:	e8 0a eb ff ff       	call   c000ba76 <_ZN5QuotaC1Ev>
{
    bool s = false;

    Quota_guard qg(this->quota);
c000cf6c:	8d 87 90 01 00 00    	lea    0x190(%edi),%eax

    Mdb *mdb;
    for (mword addr = snd_base; (mdb = snd->S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {
c000cf72:	89 ea                	mov    %ebp,%edx
template <typename S>
bool Pd::delegate (Pd *snd, mword const snd_base, mword const rcv_base, mword const ord, mword const attr, mword const sub, char const * deltype)
{
    bool s = false;

    Quota_guard qg(this->quota);
c000cf74:	89 44 24 30          	mov    %eax,0x30(%esp)
        }

        if (!node->insert_node (mdb, attr)) {
            S::tree_remove (node);
            Mdb::destroy (node, qg);
            trace (0, "overmap attempt %s - node - PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx SUB:%lx", deltype, snd, this, snd_base, rcv_base, ord, attr, sub);
c000cf78:	8d 44 24 17          	lea    0x17(%esp),%eax
c000cf7c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}

template <typename S>
bool Pd::delegate (Pd *snd, mword const snd_base, mword const rcv_base, mword const ord, mword const attr, mword const sub, char const * deltype)
{
    bool s = false;
c000cf81:	c6 44 24 0b 00       	movb   $0x0,0xb(%esp)
        }

        if (!node->insert_node (mdb, attr)) {
            S::tree_remove (node);
            Mdb::destroy (node, qg);
            trace (0, "overmap attempt %s - node - PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx SUB:%lx", deltype, snd, this, snd_base, rcv_base, ord, attr, sub);
c000cf86:	89 44 24 0c          	mov    %eax,0xc(%esp)
    bool s = false;

    Quota_guard qg(this->quota);

    Mdb *mdb;
    for (mword addr = snd_base; (mdb = snd->S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {
c000cf8a:	8b 44 24 04          	mov    0x4(%esp),%eax
c000cf8e:	b9 01 00 00 00       	mov    $0x1,%ecx
c000cf93:	05 78 01 00 00       	add    $0x178,%eax
c000cf98:	e8 3d eb ff ff       	call   c000bada <_ZN5Space11tree_lookupEmb>
c000cf9d:	85 c0                	test   %eax,%eax
c000cf9f:	89 c6                	mov    %eax,%esi
c000cfa1:	0f 84 ed 01 00 00    	je     c000d194 <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x240>

        mword o, b = snd_base;
c000cfa7:	89 6c 24 14          	mov    %ebp,0x14(%esp)
        if ((o = clamp (mdb->node_base, b, mdb->node_order, ord)) == ~0UL)
c000cfab:	8b 56 30             	mov    0x30(%esi),%edx
c000cfae:	89 f8                	mov    %edi,%eax
c000cfb0:	ff 74 24 4c          	pushl  0x4c(%esp)
c000cfb4:	ff 76 34             	pushl  0x34(%esi)
c000cfb7:	8d 4c 24 1c          	lea    0x1c(%esp),%ecx
c000cfbb:	e8 84 ee ff ff       	call   c000be44 <_ZN2Pd5clampEmRmmm>
c000cfc0:	89 c1                	mov    %eax,%ecx
c000cfc2:	58                   	pop    %eax
c000cfc3:	83 f9 ff             	cmp    $0xffffffff,%ecx
c000cfc6:	5a                   	pop    %edx
c000cfc7:	0f 84 c7 01 00 00    	je     c000d194 <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x240>
            }
        }

        bool hit_limit(mword free_space = 0)
        {
             if (free_space > upli)
c000cfcd:	8b 87 9c 01 00 00    	mov    0x19c(%edi),%eax
c000cfd3:	85 c0                	test   %eax,%eax
c000cfd5:	0f 84 c8 01 00 00    	je     c000d1a3 <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x24f>
                 return true;

             return usage() > upli - free_space;
c000cfdb:	48                   	dec    %eax
            break;

        if (quota.hit_limit(1)) {
c000cfdc:	39 87 94 01 00 00    	cmp    %eax,0x194(%edi)
c000cfe2:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c000cfe6:	0f 87 b7 01 00 00    	ja     c000d1a3 <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x24f>
        bool insert_node (Mdb *, mword);
        void demote_node (mword);
        bool remove_node();

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
c000cfec:	8d 54 24 1c          	lea    0x1c(%esp),%edx
c000cff0:	b8 80 b0 01 c0       	mov    $0xc001b080,%eax
c000cff5:	e8 7c 32 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
            Cpu::hazard |= HZD_OOM;
            return s;
        }

        Mdb *node = new (qg) Mdb (static_cast<S *>(this), free_mdb<S>, b - mdb->node_base + mdb->node_phys, b - snd_base + rcv_base, o, 0, mdb->node_type, S::sticky_sub(mdb->node_sub) | sub);
c000cffa:	8d 8f 78 01 00 00    	lea    0x178(%edi),%ecx
c000d000:	89 0c 24             	mov    %ecx,(%esp)
c000d003:	89 c3                	mov    %eax,%ebx
c000d005:	8b 44 24 14          	mov    0x14(%esp),%eax
c000d009:	ff 74 24 54          	pushl  0x54(%esp)
c000d00d:	ff 76 3c             	pushl  0x3c(%esi)
c000d010:	6a 00                	push   $0x0
c000d012:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
c000d016:	51                   	push   %ecx
c000d017:	b9 e9 b9 00 c0       	mov    $0xc000b9e9,%ecx
c000d01c:	8b 54 24 58          	mov    0x58(%esp),%edx
c000d020:	01 c2                	add    %eax,%edx
c000d022:	29 ea                	sub    %ebp,%edx
c000d024:	52                   	push   %edx
c000d025:	03 46 2c             	add    0x2c(%esi),%eax
c000d028:	2b 46 30             	sub    0x30(%esi),%eax
c000d02b:	50                   	push   %eax
c000d02c:	89 d8                	mov    %ebx,%eax
c000d02e:	8b 54 24 18          	mov    0x18(%esp),%edx
c000d032:	e8 5f 52 ff ff       	call   c0002296 <_ZN3MdbC1EP5SpacePFvP8Rcu_elemEmmmmmm>

        if (!S::tree_insert (node)) {
c000d037:	89 d8                	mov    %ebx,%eax
c000d039:	e8 55 eb ff ff       	call   c000bb93 <_ZN5Space11tree_insertEP3Mdb>
c000d03e:	83 c4 18             	add    $0x18,%esp
c000d041:	84 c0                	test   %al,%al
c000d043:	75 70                	jne    c000d0b5 <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x161>

        ALWAYS_INLINE
        static inline void destroy (Mdb *obj, Quota &quota) { obj->~Mdb(); cache.free (obj, quota); }
c000d045:	8d 4c 24 1c          	lea    0x1c(%esp),%ecx
c000d049:	89 da                	mov    %ebx,%edx
c000d04b:	b8 80 b0 01 c0       	mov    $0xc001b080,%eax
c000d050:	e8 0b 33 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
c000d055:	8b 54 24 48          	mov    0x48(%esp),%edx
            Mdb::destroy (node, qg);

            Mdb * x = S::tree_lookup(b - snd_base + rcv_base);
c000d059:	31 c9                	xor    %ecx,%ecx
c000d05b:	03 54 24 14          	add    0x14(%esp),%edx
c000d05f:	8b 04 24             	mov    (%esp),%eax
c000d062:	29 ea                	sub    %ebp,%edx
c000d064:	e8 71 ea ff ff       	call   c000bada <_ZN5Space11tree_lookupEmb>
            if (!x || x->prnt != mdb || x->node_attr != attr)
c000d069:	85 c0                	test   %eax,%eax
c000d06b:	74 12                	je     c000d07f <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x12b>
c000d06d:	39 70 24             	cmp    %esi,0x24(%eax)
c000d070:	75 0d                	jne    c000d07f <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x12b>
c000d072:	8b 5c 24 50          	mov    0x50(%esp),%ebx
c000d076:	39 58 38             	cmp    %ebx,0x38(%eax)
c000d079:	0f 84 03 01 00 00    	je     c000d182 <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x22e>
                trace (0, "overmap attempt %s - tree - PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx SUB:%lx", deltype, snd, this, snd_base, rcv_base, ord, attr, sub);
c000d07f:	81 7c 24 0c 00 d0 ff 	cmpl   $0xcfffd000,0xc(%esp)
c000d086:	cf 
c000d087:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000d08c:	ff 74 24 54          	pushl  0x54(%esp)
c000d090:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c000d097:	ff 74 24 54          	pushl  0x54(%esp)
c000d09b:	ff 74 24 54          	pushl  0x54(%esp)
c000d09f:	ff 74 24 54          	pushl  0x54(%esp)
c000d0a3:	55                   	push   %ebp
c000d0a4:	57                   	push   %edi
c000d0a5:	ff 74 24 1c          	pushl  0x1c(%esp)
c000d0a9:	ff 74 24 74          	pushl  0x74(%esp)
c000d0ad:	50                   	push   %eax
c000d0ae:	68 f5 88 01 c0       	push   $0xc00188f5
c000d0b3:	eb 61                	jmp    c000d116 <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x1c2>

            continue;
        }

        if (!node->insert_node (mdb, attr)) {
c000d0b5:	8b 4c 24 50          	mov    0x50(%esp),%ecx
c000d0b9:	89 f2                	mov    %esi,%edx
c000d0bb:	89 d8                	mov    %ebx,%eax
c000d0bd:	e8 7e 90 ff ff       	call   c0006140 <_ZN3Mdb11insert_nodeEPS_m>
c000d0c2:	84 c0                	test   %al,%al
c000d0c4:	75 5a                	jne    c000d120 <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x1cc>
            S::tree_remove (node);
c000d0c6:	ba 01 00 00 00       	mov    $0x1,%edx
c000d0cb:	89 d8                	mov    %ebx,%eax
c000d0cd:	e8 49 eb ff ff       	call   c000bc1b <_ZN5Space11tree_removeEP3MdbN3Avl5StateE>
c000d0d2:	8d 4c 24 1c          	lea    0x1c(%esp),%ecx
c000d0d6:	b8 80 b0 01 c0       	mov    $0xc001b080,%eax
c000d0db:	89 da                	mov    %ebx,%edx
c000d0dd:	e8 7e 32 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
            Mdb::destroy (node, qg);
            trace (0, "overmap attempt %s - node - PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx SUB:%lx", deltype, snd, this, snd_base, rcv_base, ord, attr, sub);
c000d0e2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000d0e7:	81 7c 24 0c 00 d0 ff 	cmpl   $0xcfffd000,0xc(%esp)
c000d0ee:	cf 
c000d0ef:	ff 74 24 54          	pushl  0x54(%esp)
c000d0f3:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c000d0fa:	ff 74 24 54          	pushl  0x54(%esp)
c000d0fe:	ff 74 24 54          	pushl  0x54(%esp)
c000d102:	ff 74 24 54          	pushl  0x54(%esp)
c000d106:	55                   	push   %ebp
c000d107:	57                   	push   %edi
c000d108:	ff 74 24 1c          	pushl  0x1c(%esp)
c000d10c:	ff 74 24 74          	pushl  0x74(%esp)
c000d110:	50                   	push   %eax
c000d111:	68 50 89 01 c0       	push   $0xc0018950
c000d116:	e8 c3 48 ff ff       	call   c00019de <_ZN7Console5printEPKcz>
            continue;
c000d11b:	83 c4 28             	add    $0x28,%esp
c000d11e:	eb 62                	jmp    c000d182 <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x22e>
        }

        s |= S::update (qg, node);
c000d120:	6a 00                	push   $0x0
c000d122:	89 d9                	mov    %ebx,%ecx
c000d124:	8b 44 24 04          	mov    0x4(%esp),%eax
c000d128:	8d 54 24 20          	lea    0x20(%esp),%edx
c000d12c:	e8 f9 40 00 00       	call   c001122a <_ZN9Space_pio6updateER5QuotaP3Mdbm>
c000d131:	08 44 24 0f          	or     %al,0xf(%esp)

        if (Cpu::hazard & HZD_OOM) {
c000d135:	f6 05 00 f0 ff cf 20 	testb  $0x20,0xcffff000
c000d13c:	58                   	pop    %eax
c000d13d:	74 43                	je     c000d182 <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x22e>
            S::update (qg, node, attr);
c000d13f:	ff 74 24 50          	pushl  0x50(%esp)
c000d143:	89 d9                	mov    %ebx,%ecx
c000d145:	8b 44 24 04          	mov    0x4(%esp),%eax
c000d149:	8d 54 24 20          	lea    0x20(%esp),%edx
c000d14d:	e8 d8 40 00 00       	call   c001122a <_ZN9Space_pio6updateER5QuotaP3Mdbm>
            node->demote_node (attr);
c000d152:	8b 54 24 54          	mov    0x54(%esp),%edx
c000d156:	89 d8                	mov    %ebx,%eax
c000d158:	e8 a7 90 ff ff       	call   c0006204 <_ZN3Mdb11demote_nodeEm>
            if (node->remove_node() && S::tree_remove (node))
c000d15d:	89 d8                	mov    %ebx,%eax
c000d15f:	e8 26 91 ff ff       	call   c000628a <_ZN3Mdb11remove_nodeEv>
c000d164:	59                   	pop    %ecx
c000d165:	84 c0                	test   %al,%al
c000d167:	0f 84 a0 00 00 00    	je     c000d20d <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x2b9>
c000d16d:	ba 01 00 00 00       	mov    $0x1,%edx
c000d172:	89 d8                	mov    %ebx,%eax
c000d174:	e8 a2 ea ff ff       	call   c000bc1b <_ZN5Space11tree_removeEP3MdbN3Avl5StateE>
c000d179:	84 c0                	test   %al,%al
c000d17b:	75 2f                	jne    c000d1ac <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x258>
c000d17d:	e9 8b 00 00 00       	jmp    c000d20d <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x2b9>
    bool s = false;

    Quota_guard qg(this->quota);

    Mdb *mdb;
    for (mword addr = snd_base; (mdb = snd->S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {
c000d182:	8b 4e 34             	mov    0x34(%esi),%ecx
c000d185:	ba 01 00 00 00       	mov    $0x1,%edx
c000d18a:	d3 e2                	shl    %cl,%edx
c000d18c:	03 56 30             	add    0x30(%esi),%edx
c000d18f:	e9 f6 fd ff ff       	jmp    c000cf8a <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x36>
                Rcu::call (node);
            return s;
        }
    }

    if (!qg.check(0))
c000d194:	31 d2                	xor    %edx,%edx
c000d196:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c000d19a:	e8 f9 e8 ff ff       	call   c000ba98 <_ZN11Quota_guard5checkEm>
c000d19f:	84 c0                	test   %al,%al
c000d1a1:	75 6a                	jne    c000d20d <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x2b9>
        Cpu::hazard |= HZD_OOM;
c000d1a3:	83 0d 00 f0 ff cf 20 	orl    $0x20,0xcffff000

    return s;
c000d1aa:	eb 61                	jmp    c000d20d <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x2b9>

        if (Cpu::hazard & HZD_OOM) {
            S::update (qg, node, attr);
            node->demote_node (attr);
            if (node->remove_node() && S::tree_remove (node))
                Rcu::call (node);
c000d1ac:	85 db                	test   %ebx,%ebx
c000d1ae:	74 56                	je     c000d206 <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x2b2>
c000d1b0:	8b 53 14             	mov    0x14(%ebx),%edx
c000d1b3:	8d 73 0c             	lea    0xc(%ebx),%esi
c000d1b6:	85 d2                	test   %edx,%edx
c000d1b8:	74 04                	je     c000d1be <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x26a>
                e->pre_func(e);
c000d1ba:	89 f0                	mov    %esi,%eax
c000d1bc:	ff d2                	call   *%edx
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
c000d1be:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
c000d1c2:	75 09                	jne    c000d1cd <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x279>
c000d1c4:	a1 f0 f7 ff cf       	mov    0xcffff7f0,%eax
c000d1c9:	39 f0                	cmp    %esi,%eax
c000d1cb:	75 29                	jne    c000d1f6 <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x2a2>
                trace (0, "warning: rcu element already enqueued");
c000d1cd:	8d 44 24 17          	lea    0x17(%esp),%eax
c000d1d1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c000d1d6:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c000d1db:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000d1e0:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c000d1e7:	50                   	push   %eax
c000d1e8:	68 ae 6c 01 c0       	push   $0xc0016cae
c000d1ed:	e8 ec 47 ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c000d1f2:	58                   	pop    %eax
c000d1f3:	5a                   	pop    %edx
c000d1f4:	eb 17                	jmp    c000d20d <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x2b9>
                return;
            }

            count ++;
c000d1f6:	ff 05 f4 f7 ff cf    	incl   0xcffff7f4

           *tail = e;
c000d1fc:	89 30                	mov    %esi,(%eax)
            tail = &e->next;
c000d1fe:	89 35 f0 f7 ff cf    	mov    %esi,0xcffff7f0
            return s;
c000d204:	eb 07                	jmp    c000d20d <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x2b9>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
c000d206:	a1 08 00 00 00       	mov    0x8,%eax
c000d20b:	0f 0b                	ud2    
    }

    if (!qg.check(0))
        Cpu::hazard |= HZD_OOM;

    return s;
c000d20d:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c000d211:	e8 bc e8 ff ff       	call   c000bad2 <_ZN11Quota_guardD1Ev>
}
c000d216:	8a 44 24 0b          	mov    0xb(%esp),%al
c000d21a:	83 c4 34             	add    $0x34,%esp
c000d21d:	5b                   	pop    %ebx
c000d21e:	5e                   	pop    %esi
c000d21f:	5f                   	pop    %edi
c000d220:	5d                   	pop    %ebp
c000d221:	c3                   	ret    

c000d222 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc>:

    Mdb::destroy (mdb, pd->quota);
}

template <typename S>
bool Pd::delegate (Pd *snd, mword const snd_base, mword const rcv_base, mword const ord, mword const attr, mword const sub, char const * deltype)
c000d222:	55                   	push   %ebp
c000d223:	89 cd                	mov    %ecx,%ebp
c000d225:	57                   	push   %edi
c000d226:	89 c7                	mov    %eax,%edi
c000d228:	56                   	push   %esi
c000d229:	53                   	push   %ebx
c000d22a:	83 ec 34             	sub    $0x34,%esp
        Quota q;
        Quota &r;

    public:

        Quota_guard(Quota &ref) : q(), r(ref) { }
c000d22d:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c000d231:	89 54 24 04          	mov    %edx,0x4(%esp)
c000d235:	e8 3c e8 ff ff       	call   c000ba76 <_ZN5QuotaC1Ev>
{
    bool s = false;

    Quota_guard qg(this->quota);
c000d23a:	8d 87 90 01 00 00    	lea    0x190(%edi),%eax

    Mdb *mdb;
    for (mword addr = snd_base; (mdb = snd->S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {
c000d240:	89 ea                	mov    %ebp,%edx
template <typename S>
bool Pd::delegate (Pd *snd, mword const snd_base, mword const rcv_base, mword const ord, mword const attr, mword const sub, char const * deltype)
{
    bool s = false;

    Quota_guard qg(this->quota);
c000d242:	89 44 24 30          	mov    %eax,0x30(%esp)
        }

        if (!node->insert_node (mdb, attr)) {
            S::tree_remove (node);
            Mdb::destroy (node, qg);
            trace (0, "overmap attempt %s - node - PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx SUB:%lx", deltype, snd, this, snd_base, rcv_base, ord, attr, sub);
c000d246:	8d 44 24 17          	lea    0x17(%esp),%eax
c000d24a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}

template <typename S>
bool Pd::delegate (Pd *snd, mword const snd_base, mword const rcv_base, mword const ord, mword const attr, mword const sub, char const * deltype)
{
    bool s = false;
c000d24f:	c6 44 24 0b 00       	movb   $0x0,0xb(%esp)
        }

        if (!node->insert_node (mdb, attr)) {
            S::tree_remove (node);
            Mdb::destroy (node, qg);
            trace (0, "overmap attempt %s - node - PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx SUB:%lx", deltype, snd, this, snd_base, rcv_base, ord, attr, sub);
c000d254:	89 44 24 0c          	mov    %eax,0xc(%esp)
    bool s = false;

    Quota_guard qg(this->quota);

    Mdb *mdb;
    for (mword addr = snd_base; (mdb = snd->S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {
c000d258:	8b 44 24 04          	mov    0x4(%esp),%eax
c000d25c:	b9 01 00 00 00       	mov    $0x1,%ecx
c000d261:	05 88 01 00 00       	add    $0x188,%eax
c000d266:	e8 6f e8 ff ff       	call   c000bada <_ZN5Space11tree_lookupEmb>
c000d26b:	85 c0                	test   %eax,%eax
c000d26d:	89 c6                	mov    %eax,%esi
c000d26f:	0f 84 ed 01 00 00    	je     c000d462 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x240>

        mword o, b = snd_base;
c000d275:	89 6c 24 14          	mov    %ebp,0x14(%esp)
        if ((o = clamp (mdb->node_base, b, mdb->node_order, ord)) == ~0UL)
c000d279:	8b 56 30             	mov    0x30(%esi),%edx
c000d27c:	89 f8                	mov    %edi,%eax
c000d27e:	ff 74 24 4c          	pushl  0x4c(%esp)
c000d282:	ff 76 34             	pushl  0x34(%esi)
c000d285:	8d 4c 24 1c          	lea    0x1c(%esp),%ecx
c000d289:	e8 b6 eb ff ff       	call   c000be44 <_ZN2Pd5clampEmRmmm>
c000d28e:	89 c1                	mov    %eax,%ecx
c000d290:	58                   	pop    %eax
c000d291:	83 f9 ff             	cmp    $0xffffffff,%ecx
c000d294:	5a                   	pop    %edx
c000d295:	0f 84 c7 01 00 00    	je     c000d462 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x240>
            }
        }

        bool hit_limit(mword free_space = 0)
        {
             if (free_space > upli)
c000d29b:	8b 87 9c 01 00 00    	mov    0x19c(%edi),%eax
c000d2a1:	85 c0                	test   %eax,%eax
c000d2a3:	0f 84 c8 01 00 00    	je     c000d471 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x24f>
                 return true;

             return usage() > upli - free_space;
c000d2a9:	48                   	dec    %eax
            break;

        if (quota.hit_limit(1)) {
c000d2aa:	39 87 94 01 00 00    	cmp    %eax,0x194(%edi)
c000d2b0:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c000d2b4:	0f 87 b7 01 00 00    	ja     c000d471 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x24f>
        bool insert_node (Mdb *, mword);
        void demote_node (mword);
        bool remove_node();

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
c000d2ba:	8d 54 24 1c          	lea    0x1c(%esp),%edx
c000d2be:	b8 80 b0 01 c0       	mov    $0xc001b080,%eax
c000d2c3:	e8 ae 2f 00 00       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
            Cpu::hazard |= HZD_OOM;
            return s;
        }

        Mdb *node = new (qg) Mdb (static_cast<S *>(this), free_mdb<S>, b - mdb->node_base + mdb->node_phys, b - snd_base + rcv_base, o, 0, mdb->node_type, S::sticky_sub(mdb->node_sub) | sub);
c000d2c8:	8d 8f 88 01 00 00    	lea    0x188(%edi),%ecx
c000d2ce:	89 0c 24             	mov    %ecx,(%esp)
c000d2d1:	89 c3                	mov    %eax,%ebx
c000d2d3:	8b 44 24 14          	mov    0x14(%esp),%eax
c000d2d7:	ff 74 24 54          	pushl  0x54(%esp)
c000d2db:	ff 76 3c             	pushl  0x3c(%esi)
c000d2de:	6a 00                	push   $0x0
c000d2e0:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
c000d2e4:	51                   	push   %ecx
c000d2e5:	b9 2f ba 00 c0       	mov    $0xc000ba2f,%ecx
c000d2ea:	8b 54 24 58          	mov    0x58(%esp),%edx
c000d2ee:	01 c2                	add    %eax,%edx
c000d2f0:	29 ea                	sub    %ebp,%edx
c000d2f2:	52                   	push   %edx
c000d2f3:	03 46 2c             	add    0x2c(%esi),%eax
c000d2f6:	2b 46 30             	sub    0x30(%esi),%eax
c000d2f9:	50                   	push   %eax
c000d2fa:	89 d8                	mov    %ebx,%eax
c000d2fc:	8b 54 24 18          	mov    0x18(%esp),%edx
c000d300:	e8 91 4f ff ff       	call   c0002296 <_ZN3MdbC1EP5SpacePFvP8Rcu_elemEmmmmmm>

        if (!S::tree_insert (node)) {
c000d305:	89 d8                	mov    %ebx,%eax
c000d307:	e8 87 e8 ff ff       	call   c000bb93 <_ZN5Space11tree_insertEP3Mdb>
c000d30c:	83 c4 18             	add    $0x18,%esp
c000d30f:	84 c0                	test   %al,%al
c000d311:	75 70                	jne    c000d383 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x161>

        ALWAYS_INLINE
        static inline void destroy (Mdb *obj, Quota &quota) { obj->~Mdb(); cache.free (obj, quota); }
c000d313:	8d 4c 24 1c          	lea    0x1c(%esp),%ecx
c000d317:	89 da                	mov    %ebx,%edx
c000d319:	b8 80 b0 01 c0       	mov    $0xc001b080,%eax
c000d31e:	e8 3d 30 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
c000d323:	8b 54 24 48          	mov    0x48(%esp),%edx
            Mdb::destroy (node, qg);

            Mdb * x = S::tree_lookup(b - snd_base + rcv_base);
c000d327:	31 c9                	xor    %ecx,%ecx
c000d329:	03 54 24 14          	add    0x14(%esp),%edx
c000d32d:	8b 04 24             	mov    (%esp),%eax
c000d330:	29 ea                	sub    %ebp,%edx
c000d332:	e8 a3 e7 ff ff       	call   c000bada <_ZN5Space11tree_lookupEmb>
            if (!x || x->prnt != mdb || x->node_attr != attr)
c000d337:	85 c0                	test   %eax,%eax
c000d339:	74 12                	je     c000d34d <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x12b>
c000d33b:	39 70 24             	cmp    %esi,0x24(%eax)
c000d33e:	75 0d                	jne    c000d34d <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x12b>
c000d340:	8b 5c 24 50          	mov    0x50(%esp),%ebx
c000d344:	39 58 38             	cmp    %ebx,0x38(%eax)
c000d347:	0f 84 03 01 00 00    	je     c000d450 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x22e>
                trace (0, "overmap attempt %s - tree - PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx SUB:%lx", deltype, snd, this, snd_base, rcv_base, ord, attr, sub);
c000d34d:	81 7c 24 0c 00 d0 ff 	cmpl   $0xcfffd000,0xc(%esp)
c000d354:	cf 
c000d355:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000d35a:	ff 74 24 54          	pushl  0x54(%esp)
c000d35e:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c000d365:	ff 74 24 54          	pushl  0x54(%esp)
c000d369:	ff 74 24 54          	pushl  0x54(%esp)
c000d36d:	ff 74 24 54          	pushl  0x54(%esp)
c000d371:	55                   	push   %ebp
c000d372:	57                   	push   %edi
c000d373:	ff 74 24 1c          	pushl  0x1c(%esp)
c000d377:	ff 74 24 74          	pushl  0x74(%esp)
c000d37b:	50                   	push   %eax
c000d37c:	68 f5 88 01 c0       	push   $0xc00188f5
c000d381:	eb 61                	jmp    c000d3e4 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x1c2>

            continue;
        }

        if (!node->insert_node (mdb, attr)) {
c000d383:	8b 4c 24 50          	mov    0x50(%esp),%ecx
c000d387:	89 f2                	mov    %esi,%edx
c000d389:	89 d8                	mov    %ebx,%eax
c000d38b:	e8 b0 8d ff ff       	call   c0006140 <_ZN3Mdb11insert_nodeEPS_m>
c000d390:	84 c0                	test   %al,%al
c000d392:	75 5a                	jne    c000d3ee <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x1cc>
            S::tree_remove (node);
c000d394:	ba 01 00 00 00       	mov    $0x1,%edx
c000d399:	89 d8                	mov    %ebx,%eax
c000d39b:	e8 7b e8 ff ff       	call   c000bc1b <_ZN5Space11tree_removeEP3MdbN3Avl5StateE>
c000d3a0:	8d 4c 24 1c          	lea    0x1c(%esp),%ecx
c000d3a4:	b8 80 b0 01 c0       	mov    $0xc001b080,%eax
c000d3a9:	89 da                	mov    %ebx,%edx
c000d3ab:	e8 b0 2f 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
            Mdb::destroy (node, qg);
            trace (0, "overmap attempt %s - node - PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx SUB:%lx", deltype, snd, this, snd_base, rcv_base, ord, attr, sub);
c000d3b0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000d3b5:	81 7c 24 0c 00 d0 ff 	cmpl   $0xcfffd000,0xc(%esp)
c000d3bc:	cf 
c000d3bd:	ff 74 24 54          	pushl  0x54(%esp)
c000d3c1:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c000d3c8:	ff 74 24 54          	pushl  0x54(%esp)
c000d3cc:	ff 74 24 54          	pushl  0x54(%esp)
c000d3d0:	ff 74 24 54          	pushl  0x54(%esp)
c000d3d4:	55                   	push   %ebp
c000d3d5:	57                   	push   %edi
c000d3d6:	ff 74 24 1c          	pushl  0x1c(%esp)
c000d3da:	ff 74 24 74          	pushl  0x74(%esp)
c000d3de:	50                   	push   %eax
c000d3df:	68 50 89 01 c0       	push   $0xc0018950
c000d3e4:	e8 f5 45 ff ff       	call   c00019de <_ZN7Console5printEPKcz>
            continue;
c000d3e9:	83 c4 28             	add    $0x28,%esp
c000d3ec:	eb 62                	jmp    c000d450 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x22e>
        }

        s |= S::update (qg, node);
c000d3ee:	6a 00                	push   $0x0
c000d3f0:	89 d9                	mov    %ebx,%ecx
c000d3f2:	8b 44 24 04          	mov    0x4(%esp),%eax
c000d3f6:	8d 54 24 20          	lea    0x20(%esp),%edx
c000d3fa:	e8 ef 3b 00 00       	call   c0010fee <_ZN9Space_obj6updateER5QuotaP3Mdbm>
c000d3ff:	08 44 24 0f          	or     %al,0xf(%esp)

        if (Cpu::hazard & HZD_OOM) {
c000d403:	f6 05 00 f0 ff cf 20 	testb  $0x20,0xcffff000
c000d40a:	58                   	pop    %eax
c000d40b:	74 43                	je     c000d450 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x22e>
            S::update (qg, node, attr);
c000d40d:	ff 74 24 50          	pushl  0x50(%esp)
c000d411:	89 d9                	mov    %ebx,%ecx
c000d413:	8b 44 24 04          	mov    0x4(%esp),%eax
c000d417:	8d 54 24 20          	lea    0x20(%esp),%edx
c000d41b:	e8 ce 3b 00 00       	call   c0010fee <_ZN9Space_obj6updateER5QuotaP3Mdbm>
            node->demote_node (attr);
c000d420:	8b 54 24 54          	mov    0x54(%esp),%edx
c000d424:	89 d8                	mov    %ebx,%eax
c000d426:	e8 d9 8d ff ff       	call   c0006204 <_ZN3Mdb11demote_nodeEm>
            if (node->remove_node() && S::tree_remove (node))
c000d42b:	89 d8                	mov    %ebx,%eax
c000d42d:	e8 58 8e ff ff       	call   c000628a <_ZN3Mdb11remove_nodeEv>
c000d432:	59                   	pop    %ecx
c000d433:	84 c0                	test   %al,%al
c000d435:	0f 84 a0 00 00 00    	je     c000d4db <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x2b9>
c000d43b:	ba 01 00 00 00       	mov    $0x1,%edx
c000d440:	89 d8                	mov    %ebx,%eax
c000d442:	e8 d4 e7 ff ff       	call   c000bc1b <_ZN5Space11tree_removeEP3MdbN3Avl5StateE>
c000d447:	84 c0                	test   %al,%al
c000d449:	75 2f                	jne    c000d47a <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x258>
c000d44b:	e9 8b 00 00 00       	jmp    c000d4db <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x2b9>
    bool s = false;

    Quota_guard qg(this->quota);

    Mdb *mdb;
    for (mword addr = snd_base; (mdb = snd->S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {
c000d450:	8b 4e 34             	mov    0x34(%esi),%ecx
c000d453:	ba 01 00 00 00       	mov    $0x1,%edx
c000d458:	d3 e2                	shl    %cl,%edx
c000d45a:	03 56 30             	add    0x30(%esi),%edx
c000d45d:	e9 f6 fd ff ff       	jmp    c000d258 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x36>
                Rcu::call (node);
            return s;
        }
    }

    if (!qg.check(0))
c000d462:	31 d2                	xor    %edx,%edx
c000d464:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c000d468:	e8 2b e6 ff ff       	call   c000ba98 <_ZN11Quota_guard5checkEm>
c000d46d:	84 c0                	test   %al,%al
c000d46f:	75 6a                	jne    c000d4db <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x2b9>
        Cpu::hazard |= HZD_OOM;
c000d471:	83 0d 00 f0 ff cf 20 	orl    $0x20,0xcffff000

    return s;
c000d478:	eb 61                	jmp    c000d4db <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x2b9>

        if (Cpu::hazard & HZD_OOM) {
            S::update (qg, node, attr);
            node->demote_node (attr);
            if (node->remove_node() && S::tree_remove (node))
                Rcu::call (node);
c000d47a:	85 db                	test   %ebx,%ebx
c000d47c:	74 56                	je     c000d4d4 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x2b2>
c000d47e:	8b 53 14             	mov    0x14(%ebx),%edx
c000d481:	8d 73 0c             	lea    0xc(%ebx),%esi
c000d484:	85 d2                	test   %edx,%edx
c000d486:	74 04                	je     c000d48c <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x26a>
                e->pre_func(e);
c000d488:	89 f0                	mov    %esi,%eax
c000d48a:	ff d2                	call   *%edx
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
c000d48c:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
c000d490:	75 09                	jne    c000d49b <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x279>
c000d492:	a1 f0 f7 ff cf       	mov    0xcffff7f0,%eax
c000d497:	39 f0                	cmp    %esi,%eax
c000d499:	75 29                	jne    c000d4c4 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x2a2>
                trace (0, "warning: rcu element already enqueued");
c000d49b:	8d 44 24 17          	lea    0x17(%esp),%eax
c000d49f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c000d4a4:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c000d4a9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000d4ae:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c000d4b5:	50                   	push   %eax
c000d4b6:	68 ae 6c 01 c0       	push   $0xc0016cae
c000d4bb:	e8 1e 45 ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c000d4c0:	58                   	pop    %eax
c000d4c1:	5a                   	pop    %edx
c000d4c2:	eb 17                	jmp    c000d4db <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x2b9>
                return;
            }

            count ++;
c000d4c4:	ff 05 f4 f7 ff cf    	incl   0xcffff7f4

           *tail = e;
c000d4ca:	89 30                	mov    %esi,(%eax)
            tail = &e->next;
c000d4cc:	89 35 f0 f7 ff cf    	mov    %esi,0xcffff7f0
            return s;
c000d4d2:	eb 07                	jmp    c000d4db <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x2b9>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
c000d4d4:	a1 08 00 00 00       	mov    0x8,%eax
c000d4d9:	0f 0b                	ud2    
    }

    if (!qg.check(0))
        Cpu::hazard |= HZD_OOM;

    return s;
c000d4db:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c000d4df:	e8 ee e5 ff ff       	call   c000bad2 <_ZN11Quota_guardD1Ev>
}
c000d4e4:	8a 44 24 0b          	mov    0xb(%esp),%al
c000d4e8:	83 c4 34             	add    $0x34,%esp
c000d4eb:	5b                   	pop    %ebx
c000d4ec:	5e                   	pop    %esi
c000d4ed:	5f                   	pop    %edi
c000d4ee:	5d                   	pop    %ebp
c000d4ef:	c3                   	ret    

c000d4f0 <_ZN2Pd7del_crdEPS_3CrdRS1_mm>:

    crd = Crd (0);
}

void Pd::del_crd (Pd *pd, Crd del, Crd &crd, mword sub, mword hot)
{
c000d4f0:	55                   	push   %ebp

        ALWAYS_INLINE
        inline explicit Crd (Type t, mword b = 0, mword o = 0x1f, mword a = 0x1f) : val (b << 12 | o << 7 | a << 2 | t) {}

        ALWAYS_INLINE
        inline Type type() const { return static_cast<Type>(val & 0x3); }
c000d4f1:	89 cd                	mov    %ecx,%ebp
c000d4f3:	57                   	push   %edi
c000d4f4:	83 e5 03             	and    $0x3,%ebp
c000d4f7:	56                   	push   %esi
c000d4f8:	53                   	push   %ebx

        ALWAYS_INLINE
        inline unsigned attr() const { return val >> 2 & 0x1f; }
c000d4f9:	89 cb                	mov    %ecx,%ebx
c000d4fb:	83 ec 10             	sub    $0x10,%esp

        ALWAYS_INLINE
        inline explicit Crd (Type t, mword b = 0, mword o = 0x1f, mword a = 0x1f) : val (b << 12 | o << 7 | a << 2 | t) {}

        ALWAYS_INLINE
        inline Type type() const { return static_cast<Type>(val & 0x3); }
c000d4fe:	8b 74 24 24          	mov    0x24(%esp),%esi
c000d502:	89 14 24             	mov    %edx,(%esp)
c000d505:	8b 36                	mov    (%esi),%esi

        ALWAYS_INLINE
        inline unsigned attr() const { return val >> 2 & 0x1f; }
c000d507:	21 f3                	and    %esi,%ebx

        ALWAYS_INLINE
        inline unsigned order() const { return val >> 7 & 0x1f; }
c000d509:	89 f7                	mov    %esi,%edi
    Crd::Type st = crd.type(), rt = del.type();
    bool s = false;

    mword a = crd.attr() & del.attr(), sb = crd.base(), so = crd.order(), rb = del.base(), ro = del.order(), o = 0;
c000d50b:	c1 eb 02             	shr    $0x2,%ebx

        ALWAYS_INLINE
        inline mword base() const { return val >> 12; }
c000d50e:	89 f2                	mov    %esi,%edx
c000d510:	89 5c 24 04          	mov    %ebx,0x4(%esp)
c000d514:	89 cb                	mov    %ecx,%ebx
c000d516:	c1 eb 0c             	shr    $0xc,%ebx
c000d519:	89 5c 24 0c          	mov    %ebx,0xc(%esp)

    if (EXPECT_FALSE (st != rt || !a)) {
c000d51d:	8b 5c 24 04          	mov    0x4(%esp),%ebx

        ALWAYS_INLINE
        inline unsigned attr() const { return val >> 2 & 0x1f; }

        ALWAYS_INLINE
        inline unsigned order() const { return val >> 7 & 0x1f; }
c000d521:	c1 ef 07             	shr    $0x7,%edi
c000d524:	c1 e9 07             	shr    $0x7,%ecx
c000d527:	83 e7 1f             	and    $0x1f,%edi

        ALWAYS_INLINE
        inline mword base() const { return val >> 12; }
c000d52a:	c1 ea 0c             	shr    $0xc,%edx

        ALWAYS_INLINE
        inline unsigned attr() const { return val >> 2 & 0x1f; }

        ALWAYS_INLINE
        inline unsigned order() const { return val >> 7 & 0x1f; }
c000d52d:	83 e1 1f             	and    $0x1f,%ecx
void Pd::del_crd (Pd *pd, Crd del, Crd &crd, mword sub, mword hot)
{
    Crd::Type st = crd.type(), rt = del.type();
    bool s = false;

    mword a = crd.attr() & del.attr(), sb = crd.base(), so = crd.order(), rb = del.base(), ro = del.order(), o = 0;
c000d530:	89 54 24 08          	mov    %edx,0x8(%esp)

    if (EXPECT_FALSE (st != rt || !a)) {
c000d534:	83 e3 1f             	and    $0x1f,%ebx
c000d537:	74 07                	je     c000d540 <_ZN2Pd7del_crdEPS_3CrdRS1_mm+0x50>

        ALWAYS_INLINE
        inline explicit Crd (Type t, mword b = 0, mword o = 0x1f, mword a = 0x1f) : val (b << 12 | o << 7 | a << 2 | t) {}

        ALWAYS_INLINE
        inline Type type() const { return static_cast<Type>(val & 0x3); }
c000d539:	83 e6 03             	and    $0x3,%esi
c000d53c:	39 ee                	cmp    %ebp,%esi
c000d53e:	74 0f                	je     c000d54f <_ZN2Pd7del_crdEPS_3CrdRS1_mm+0x5f>
        crd = Crd (0);
c000d540:	8b 44 24 24          	mov    0x24(%esp),%eax
c000d544:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c000d54a:	e9 d6 00 00 00       	jmp    c000d625 <_ZN2Pd7del_crdEPS_3CrdRS1_mm+0x135>
        return;
    }

    switch (rt) {
c000d54f:	83 fd 02             	cmp    $0x2,%ebp
c000d552:	89 c6                	mov    %eax,%esi
c000d554:	74 46                	je     c000d59c <_ZN2Pd7del_crdEPS_3CrdRS1_mm+0xac>
c000d556:	83 fd 03             	cmp    $0x3,%ebp
c000d559:	74 6e                	je     c000d5c9 <_ZN2Pd7del_crdEPS_3CrdRS1_mm+0xd9>
c000d55b:	83 fd 01             	cmp    $0x1,%ebp
c000d55e:	0f 85 9b 00 00 00    	jne    c000d5ff <_ZN2Pd7del_crdEPS_3CrdRS1_mm+0x10f>

        case Crd::MEM:
            o = clamp (sb, rb, so, ro, hot);
c000d564:	ff 74 24 2c          	pushl  0x2c(%esp)
c000d568:	51                   	push   %ecx
c000d569:	57                   	push   %edi
c000d56a:	8d 4c 24 18          	lea    0x18(%esp),%ecx
c000d56e:	8d 54 24 14          	lea    0x14(%esp),%edx
c000d572:	e8 03 e9 ff ff       	call   c000be7a <_ZN2Pd5clampERmS0_mmm>
            trace (TRACE_DEL, "DEL MEM PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx", pd, this, sb, rb, o, a);
            s = delegate<Space_mem>(pd, sb, rb, o, a, sub, "MEM");
c000d577:	68 ab 89 01 c0       	push   $0xc00189ab
c000d57c:	ff 74 24 38          	pushl  0x38(%esp)
c000d580:	53                   	push   %ebx
    }

    switch (rt) {

        case Crd::MEM:
            o = clamp (sb, rb, so, ro, hot);
c000d581:	89 c7                	mov    %eax,%edi
            trace (TRACE_DEL, "DEL MEM PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx", pd, this, sb, rb, o, a);
            s = delegate<Space_mem>(pd, sb, rb, o, a, sub, "MEM");
c000d583:	50                   	push   %eax
c000d584:	89 f0                	mov    %esi,%eax
c000d586:	ff 74 24 28          	pushl  0x28(%esp)
c000d58a:	8b 4c 24 28          	mov    0x28(%esp),%ecx
c000d58e:	8b 54 24 20          	mov    0x20(%esp),%edx
c000d592:	e8 e5 f6 ff ff       	call   c000cc7c <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc>
            break;
c000d597:	83 c4 20             	add    $0x20,%esp
c000d59a:	eb 67                	jmp    c000d603 <_ZN2Pd7del_crdEPS_3CrdRS1_mm+0x113>

        case Crd::PIO:
            o = clamp (sb, rb, so, ro);
c000d59c:	51                   	push   %ecx
c000d59d:	57                   	push   %edi
c000d59e:	8d 4c 24 14          	lea    0x14(%esp),%ecx
c000d5a2:	e8 9d e8 ff ff       	call   c000be44 <_ZN2Pd5clampEmRmmm>
            trace (TRACE_DEL, "DEL I/O PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx", pd, this, rb, rb, o, a);
            delegate<Space_pio>(pd, rb, rb, o, a, sub, "PIO");
c000d5a7:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c000d5ab:	68 af 89 01 c0       	push   $0xc00189af
c000d5b0:	ff 74 24 34          	pushl  0x34(%esp)
c000d5b4:	53                   	push   %ebx
            trace (TRACE_DEL, "DEL MEM PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx", pd, this, sb, rb, o, a);
            s = delegate<Space_mem>(pd, sb, rb, o, a, sub, "MEM");
            break;

        case Crd::PIO:
            o = clamp (sb, rb, so, ro);
c000d5b5:	89 c7                	mov    %eax,%edi
            trace (TRACE_DEL, "DEL I/O PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx", pd, this, rb, rb, o, a);
            delegate<Space_pio>(pd, rb, rb, o, a, sub, "PIO");
c000d5b7:	50                   	push   %eax
c000d5b8:	89 f0                	mov    %esi,%eax
c000d5ba:	51                   	push   %ecx
c000d5bb:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c000d5bf:	e8 90 f9 ff ff       	call   c000cf54 <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc>
            break;
c000d5c4:	83 c4 1c             	add    $0x1c,%esp
c000d5c7:	eb 38                	jmp    c000d601 <_ZN2Pd7del_crdEPS_3CrdRS1_mm+0x111>

        case Crd::OBJ:
            o = clamp (sb, rb, so, ro, hot);
c000d5c9:	ff 74 24 2c          	pushl  0x2c(%esp)
c000d5cd:	51                   	push   %ecx
c000d5ce:	57                   	push   %edi
c000d5cf:	8d 4c 24 18          	lea    0x18(%esp),%ecx
c000d5d3:	8d 54 24 14          	lea    0x14(%esp),%edx
c000d5d7:	e8 9e e8 ff ff       	call   c000be7a <_ZN2Pd5clampERmS0_mmm>
            trace (TRACE_DEL, "DEL OBJ PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx", pd, this, sb, rb, o, a);
            delegate<Space_obj>(pd, sb, rb, o, a, 0, "OBJ");
c000d5dc:	68 b3 89 01 c0       	push   $0xc00189b3
c000d5e1:	6a 00                	push   $0x0
c000d5e3:	53                   	push   %ebx
c000d5e4:	50                   	push   %eax
            trace (TRACE_DEL, "DEL I/O PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx", pd, this, rb, rb, o, a);
            delegate<Space_pio>(pd, rb, rb, o, a, sub, "PIO");
            break;

        case Crd::OBJ:
            o = clamp (sb, rb, so, ro, hot);
c000d5e5:	89 c7                	mov    %eax,%edi
            trace (TRACE_DEL, "DEL OBJ PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx", pd, this, sb, rb, o, a);
            delegate<Space_obj>(pd, sb, rb, o, a, 0, "OBJ");
c000d5e7:	ff 74 24 28          	pushl  0x28(%esp)
c000d5eb:	89 f0                	mov    %esi,%eax
c000d5ed:	8b 4c 24 28          	mov    0x28(%esp),%ecx
c000d5f1:	8b 54 24 20          	mov    0x20(%esp),%edx
c000d5f5:	e8 28 fc ff ff       	call   c000d222 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc>
            break;
c000d5fa:	83 c4 20             	add    $0x20,%esp
c000d5fd:	eb 02                	jmp    c000d601 <_ZN2Pd7del_crdEPS_3CrdRS1_mm+0x111>
void Pd::del_crd (Pd *pd, Crd del, Crd &crd, mword sub, mword hot)
{
    Crd::Type st = crd.type(), rt = del.type();
    bool s = false;

    mword a = crd.attr() & del.attr(), sb = crd.base(), so = crd.order(), rb = del.base(), ro = del.order(), o = 0;
c000d5ff:	31 ff                	xor    %edi,%edi
}

void Pd::del_crd (Pd *pd, Crd del, Crd &crd, mword sub, mword hot)
{
    Crd::Type st = crd.type(), rt = del.type();
    bool s = false;
c000d601:	31 c0                	xor    %eax,%eax

        ALWAYS_INLINE
        inline explicit Crd (mword v) : val (v) {}

        ALWAYS_INLINE
        inline explicit Crd (Type t, mword b = 0, mword o = 0x1f, mword a = 0x1f) : val (b << 12 | o << 7 | a << 2 | t) {}
c000d603:	8b 54 24 0c          	mov    0xc(%esp),%edx
c000d607:	c1 e3 02             	shl    $0x2,%ebx
c000d60a:	8b 74 24 24          	mov    0x24(%esp),%esi
c000d60e:	c1 e7 07             	shl    $0x7,%edi
c000d611:	c1 e2 0c             	shl    $0xc,%edx
c000d614:	09 ea                	or     %ebp,%edx
c000d616:	09 d3                	or     %edx,%ebx
c000d618:	09 df                	or     %ebx,%edi
            break;
    }

    crd = Crd (rt, rb, o, a);

    if (s)
c000d61a:	84 c0                	test   %al,%al
c000d61c:	89 3e                	mov    %edi,(%esi)
c000d61e:	74 05                	je     c000d625 <_ZN2Pd7del_crdEPS_3CrdRS1_mm+0x135>
        shootdown();
c000d620:	e8 4d 37 00 00       	call   c0010d72 <_ZN9Space_mem9shootdownEv>
}
c000d625:	83 c4 10             	add    $0x10,%esp
c000d628:	5b                   	pop    %ebx
c000d629:	5e                   	pop    %esi
c000d62a:	5f                   	pop    %edi
c000d62b:	5d                   	pop    %ebp
c000d62c:	c3                   	ret    
c000d62d:	90                   	nop

c000d62e <_ZN2Pd10xfer_itemsEPS_3CrdS1_P4XferS3_m>:
    if (crd.type() == Crd::MEM)
        shootdown();
}

void Pd::xfer_items (Pd *src, Crd xlt, Crd del, Xfer *s, Xfer *d, unsigned long ti)
{
c000d62e:	55                   	push   %ebp
c000d62f:	57                   	push   %edi
c000d630:	56                   	push   %esi
c000d631:	53                   	push   %ebx
c000d632:	83 ec 18             	sub    $0x18,%esp
c000d635:	89 44 24 04          	mov    %eax,0x4(%esp)
            PIO = 2,
            OBJ = 3,
        };

        ALWAYS_INLINE
        inline explicit Crd() : val (0) {}
c000d639:	8b 44 24 38          	mov    0x38(%esp),%eax
                crd = *s;
                set_as_del = 1;

            case 1: {
                bool r = src == &root && s->flags() & 0x800;
                del_crd (r? &kern : src, del, crd, (s->flags() >> 8) & (r ? 7 : 3), s->hotspot());
c000d63d:	8d 7c 24 14          	lea    0x14(%esp),%edi
    if (crd.type() == Crd::MEM)
        shootdown();
}

void Pd::xfer_items (Pd *src, Crd xlt, Crd del, Xfer *s, Xfer *d, unsigned long ti)
{
c000d641:	8b 5c 24 30          	mov    0x30(%esp),%ebx
c000d645:	8b 6c 24 34          	mov    0x34(%esp),%ebp
c000d649:	89 14 24             	mov    %edx,(%esp)
c000d64c:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c000d650:	89 44 24 08          	mov    %eax,0x8(%esp)
    mword set_as_del;

    for (Crd crd; ti--; s--) {
c000d654:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c000d659:	0f 84 ee 00 00 00    	je     c000d74d <_ZN2Pd10xfer_itemsEPS_3CrdS1_P4XferS3_m+0x11f>

        crd = *s;
c000d65f:	8b 03                	mov    (%ebx),%eax
c000d661:	89 44 24 14          	mov    %eax,0x14(%esp)
        set_as_del = 0;

        switch (s->flags() & 3) {
c000d665:	8b 43 04             	mov    0x4(%ebx),%eax
c000d668:	83 e0 03             	and    $0x3,%eax
c000d66b:	83 f8 01             	cmp    $0x1,%eax
c000d66e:	74 4b                	je     c000d6bb <_ZN2Pd10xfer_itemsEPS_3CrdS1_P4XferS3_m+0x8d>
c000d670:	72 0a                	jb     c000d67c <_ZN2Pd10xfer_itemsEPS_3CrdS1_P4XferS3_m+0x4e>
c000d672:	83 f8 02             	cmp    $0x2,%eax
c000d675:	74 1d                	je     c000d694 <_ZN2Pd10xfer_itemsEPS_3CrdS1_P4XferS3_m+0x66>
c000d677:	e9 a0 00 00 00       	jmp    c000d71c <_ZN2Pd10xfer_itemsEPS_3CrdS1_P4XferS3_m+0xee>

            case 0:
                xlt_crd (src, xlt, crd);
c000d67c:	57                   	push   %edi
c000d67d:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c000d681:	8b 54 24 04          	mov    0x4(%esp),%edx
c000d685:	8b 44 24 08          	mov    0x8(%esp),%eax
c000d689:	e8 80 e8 ff ff       	call   c000bf0e <_ZN2Pd7xlt_crdEPS_3CrdRS1_>
                break;
c000d68e:	5a                   	pop    %edx
c000d68f:	e9 90 00 00 00       	jmp    c000d724 <_ZN2Pd10xfer_itemsEPS_3CrdS1_P4XferS3_m+0xf6>

            case 2:
                xlt_crd (src, xlt, crd);
c000d694:	57                   	push   %edi
c000d695:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c000d699:	8b 54 24 04          	mov    0x4(%esp),%edx
c000d69d:	8b 44 24 08          	mov    0x8(%esp),%eax
c000d6a1:	e8 68 e8 ff ff       	call   c000bf0e <_ZN2Pd7xlt_crdEPS_3CrdRS1_>
                if (crd.type()) break;
c000d6a6:	58                   	pop    %eax
c000d6a7:	f6 44 24 14 03       	testb  $0x3,0x14(%esp)
c000d6ac:	75 76                	jne    c000d724 <_ZN2Pd10xfer_itemsEPS_3CrdS1_P4XferS3_m+0xf6>

                crd = *s;
c000d6ae:	8b 03                	mov    (%ebx),%eax
                set_as_del = 1;
c000d6b0:	be 01 00 00 00       	mov    $0x1,%esi

            case 2:
                xlt_crd (src, xlt, crd);
                if (crd.type()) break;

                crd = *s;
c000d6b5:	89 44 24 14          	mov    %eax,0x14(%esp)
c000d6b9:	eb 02                	jmp    c000d6bd <_ZN2Pd10xfer_itemsEPS_3CrdS1_P4XferS3_m+0x8f>
    mword set_as_del;

    for (Crd crd; ti--; s--) {

        crd = *s;
        set_as_del = 0;
c000d6bb:	31 f6                	xor    %esi,%esi

                crd = *s;
                set_as_del = 1;

            case 1: {
                bool r = src == &root && s->flags() & 0x800;
c000d6bd:	31 d2                	xor    %edx,%edx
c000d6bf:	8b 43 04             	mov    0x4(%ebx),%eax
c000d6c2:	81 3c 24 00 b1 01 c0 	cmpl   $0xc001b100,(%esp)
c000d6c9:	75 08                	jne    c000d6d3 <_ZN2Pd10xfer_itemsEPS_3CrdS1_P4XferS3_m+0xa5>
c000d6cb:	89 c2                	mov    %eax,%edx
c000d6cd:	c1 ea 0b             	shr    $0xb,%edx
c000d6d0:	80 e2 01             	and    $0x1,%dl

        ALWAYS_INLINE
        inline mword flags() const { return val & 0xfff; }

        ALWAYS_INLINE
        inline mword hotspot() const { return val >> 12; }
c000d6d3:	89 c1                	mov    %eax,%ecx
    public:
        ALWAYS_INLINE
        inline explicit Xfer (Crd c, mword v) : Crd (c), val (v) {}

        ALWAYS_INLINE
        inline mword flags() const { return val & 0xfff; }
c000d6d5:	25 ff 0f 00 00       	and    $0xfff,%eax

        ALWAYS_INLINE
        inline mword hotspot() const { return val >> 12; }
c000d6da:	c1 e9 0c             	shr    $0xc,%ecx
                del_crd (r? &kern : src, del, crd, (s->flags() >> 8) & (r ? 7 : 3), s->hotspot());
c000d6dd:	c1 e8 08             	shr    $0x8,%eax
c000d6e0:	80 fa 01             	cmp    $0x1,%dl
c000d6e3:	89 44 24 10          	mov    %eax,0x10(%esp)
c000d6e7:	19 c0                	sbb    %eax,%eax
c000d6e9:	83 e0 fc             	and    $0xfffffffc,%eax
c000d6ec:	83 c0 07             	add    $0x7,%eax
c000d6ef:	23 44 24 10          	and    0x10(%esp),%eax
c000d6f3:	84 d2                	test   %dl,%dl
c000d6f5:	ba c0 b2 01 c0       	mov    $0xc001b2c0,%edx
c000d6fa:	0f 44 14 24          	cmove  (%esp),%edx
c000d6fe:	51                   	push   %ecx
c000d6ff:	50                   	push   %eax
c000d700:	57                   	push   %edi
c000d701:	8b 4c 24 38          	mov    0x38(%esp),%ecx
c000d705:	8b 44 24 10          	mov    0x10(%esp),%eax
c000d709:	e8 e2 fd ff ff       	call   c000d4f0 <_ZN2Pd7del_crdEPS_3CrdRS1_mm>
                if (Cpu::hazard & HZD_OOM)
c000d70e:	83 c4 0c             	add    $0xc,%esp
c000d711:	f6 05 00 f0 ff cf 20 	testb  $0x20,0xcffff000
c000d718:	74 0c                	je     c000d726 <_ZN2Pd10xfer_itemsEPS_3CrdS1_P4XferS3_m+0xf8>
c000d71a:	eb 31                	jmp    c000d74d <_ZN2Pd10xfer_itemsEPS_3CrdS1_P4XferS3_m+0x11f>
                    return;
                break;
            }
            default:
                crd = Crd(0);
c000d71c:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c000d723:	00 
    mword set_as_del;

    for (Crd crd; ti--; s--) {

        crd = *s;
        set_as_del = 0;
c000d724:	31 f6                	xor    %esi,%esi
            default:
                crd = Crd(0);

        };

        if (d)
c000d726:	85 ed                	test   %ebp,%ebp
c000d728:	74 17                	je     c000d741 <_ZN2Pd10xfer_itemsEPS_3CrdS1_P4XferS3_m+0x113>
    public:
        ALWAYS_INLINE
        inline explicit Xfer (Crd c, mword v) : Crd (c), val (v) {}

        ALWAYS_INLINE
        inline mword flags() const { return val & 0xfff; }
c000d72a:	8b 43 04             	mov    0x4(%ebx),%eax
            *d-- = Xfer (crd, s->flags() | set_as_del);
c000d72d:	83 ed 08             	sub    $0x8,%ebp
c000d730:	25 ff 0f 00 00       	and    $0xfff,%eax
c000d735:	09 c6                	or     %eax,%esi
c000d737:	8b 44 24 14          	mov    0x14(%esp),%eax
c000d73b:	89 75 0c             	mov    %esi,0xc(%ebp)
c000d73e:	89 45 08             	mov    %eax,0x8(%ebp)

void Pd::xfer_items (Pd *src, Crd xlt, Crd del, Xfer *s, Xfer *d, unsigned long ti)
{
    mword set_as_del;

    for (Crd crd; ti--; s--) {
c000d741:	83 eb 08             	sub    $0x8,%ebx
c000d744:	ff 4c 24 08          	decl   0x8(%esp)
c000d748:	e9 07 ff ff ff       	jmp    c000d654 <_ZN2Pd10xfer_itemsEPS_3CrdS1_P4XferS3_m+0x26>
        };

        if (d)
            *d-- = Xfer (crd, s->flags() | set_as_del);
    }
}
c000d74d:	83 c4 18             	add    $0x18,%esp
c000d750:	5b                   	pop    %ebx
c000d751:	5e                   	pop    %esi
c000d752:	5f                   	pop    %edi
c000d753:	5d                   	pop    %ebp
c000d754:	c3                   	ret    

c000d755 <_GLOBAL__sub_I.00101__ZN2Pd5cacheE>:
Slab_cache Pd::cache (sizeof (Pd), 32);

Pd *Pd::current;

INIT_PRIORITY (PRIO_BUDDY)
ALIGNED(32) Pd Pd::kern (&Pd::kern);
c000d755:	ba c0 b2 01 c0       	mov    $0xc001b2c0,%edx
c000d75a:	89 d0                	mov    %edx,%eax
c000d75c:	e8 0f 40 1f 40       	call   201770 <_ZN2PdC1EPS_>
c000d761:	b9 e4 b0 01 c0       	mov    $0xc001b0e4,%ecx
c000d766:	ba c0 b2 01 c0       	mov    $0xc001b2c0,%edx
c000d76b:	b8 e8 c9 00 c0       	mov    $0xc000c9e8,%eax
c000d770:	e9 4e e9 ff ff       	jmp    c000c0c3 <__cxa_atexit>

c000d775 <_GLOBAL__sub_I.00102__ZN2Pd5cacheE>:
#include "stdio.hpp"
#include "hip.hpp"
#include "ec.hpp"

INIT_PRIORITY (PRIO_SLAB)
Slab_cache Pd::cache (sizeof (Pd), 32);
c000d775:	b9 20 00 00 00       	mov    $0x20,%ecx
c000d77a:	ba a4 01 00 00       	mov    $0x1a4,%edx
c000d77f:	b8 64 b4 01 c0       	mov    $0xc001b464,%eax
c000d784:	e9 7d 2a 00 00       	jmp    c0010206 <_ZN10Slab_cacheC1Emj>

c000d789 <_GLOBAL__sub_I__ZN2Pd5cacheE>:

Pd *Pd::current;

INIT_PRIORITY (PRIO_BUDDY)
ALIGNED(32) Pd Pd::kern (&Pd::kern);
ALIGNED(32) Pd Pd::root (&Pd::root, NUM_EXC, 0x1f);
c000d789:	ba 00 b1 01 c0       	mov    $0xc001b100,%edx
c000d78e:	b9 20 00 00 00       	mov    $0x20,%ecx
c000d793:	89 d0                	mov    %edx,%eax
c000d795:	6a 1f                	push   $0x1f
c000d797:	e8 0c e5 ff ff       	call   c000bca8 <_ZN2PdC1EPS_mm>
c000d79c:	b9 e4 b0 01 c0       	mov    $0xc001b0e4,%ecx
c000d7a1:	ba 00 b1 01 c0       	mov    $0xc001b100,%edx
c000d7a6:	58                   	pop    %eax
c000d7a7:	b8 e8 c9 00 c0       	mov    $0xc000c9e8,%eax
c000d7ac:	e9 12 e9 ff ff       	jmp    c000c0c3 <__cxa_atexit>
c000d7b1:	90                   	nop

c000d7b2 <_ZN2Pt4freeEP8Rcu_elem>:
{
    trace (TRACE_SYSCALL, "PT:%p created (EC:%p IP:%#lx)", this, e, ip);
}

void Pt::free (Rcu_elem * p)
{
c000d7b2:	56                   	push   %esi
    Pt *pt = static_cast<Pt *>(p);
c000d7b3:	85 c0                	test   %eax,%eax
{
    trace (TRACE_SYSCALL, "PT:%p created (EC:%p IP:%#lx)", this, e, ip);
}

void Pt::free (Rcu_elem * p)
{
c000d7b5:	53                   	push   %ebx
    Pt *pt = static_cast<Pt *>(p);
c000d7b6:	8d 58 f4             	lea    -0xc(%eax),%ebx
c000d7b9:	b8 00 00 00 00       	mov    $0x0,%eax
c000d7be:	0f 44 d8             	cmove  %eax,%ebx
c000d7c1:	83 c8 ff             	or     $0xffffffff,%eax
c000d7c4:	f0 0f c1 43 48       	lock xadd %eax,0x48(%ebx)

    if (!pt->del_ref())
c000d7c9:	48                   	dec    %eax
c000d7ca:	75 5b                	jne    c000d827 <_ZN2Pt4freeEP8Rcu_elem+0x75>
        return;

    Pd *pd = static_cast<Pd *>(static_cast<Space_obj *>(pt->space));
c000d7cc:	8b 53 28             	mov    0x28(%ebx),%edx
c000d7cf:	85 d2                	test   %edx,%edx
c000d7d1:	8d b2 78 fe ff ff    	lea    -0x188(%edx),%esi
c000d7d7:	0f 44 f0             	cmove  %eax,%esi
        inline Refptr (T *p) : ptr (p->add_ref() ? p : nullptr) {}

        ALWAYS_INLINE
        inline ~Refptr()
        {
            if (ptr && ptr->del_ref())
c000d7da:	8b 43 4c             	mov    0x4c(%ebx),%eax
    destroy(pt, pd->quota);
c000d7dd:	81 c6 90 01 00 00    	add    $0x190,%esi
c000d7e3:	85 c0                	test   %eax,%eax
c000d7e5:	74 30                	je     c000d817 <_ZN2Pt4freeEP8Rcu_elem+0x65>
c000d7e7:	83 ca ff             	or     $0xffffffff,%edx
c000d7ea:	f0 0f c1 50 48       	lock xadd %edx,0x48(%eax)
c000d7ef:	4a                   	dec    %edx
c000d7f0:	75 25                	jne    c000d817 <_ZN2Pt4freeEP8Rcu_elem+0x65>
                delete ptr;
c000d7f2:	8b 43 4c             	mov    0x4c(%ebx),%eax
c000d7f5:	85 c0                	test   %eax,%eax
c000d7f7:	74 1e                	je     c000d817 <_ZN2Pt4freeEP8Rcu_elem+0x65>
c000d7f9:	e8 10 5d ff ff       	call   c000350e <_ZN2EcD1Ev>
c000d7fe:	8b 53 4c             	mov    0x4c(%ebx),%edx

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c000d801:	8b 82 b8 00 00 00    	mov    0xb8(%edx),%eax
c000d807:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c000d80d:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c000d812:	e8 49 2b 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
c000d817:	89 da                	mov    %ebx,%edx
c000d819:	89 f1                	mov    %esi,%ecx
}
c000d81b:	5b                   	pop    %ebx
c000d81c:	b8 7c b4 01 c0       	mov    $0xc001b47c,%eax
c000d821:	5e                   	pop    %esi
c000d822:	e9 39 2b 00 00       	jmp    c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
c000d827:	5b                   	pop    %ebx
c000d828:	5e                   	pop    %esi
c000d829:	c3                   	ret    

c000d82a <_ZN2PtC1EP2PdmP2Ec3Mtdm>:
#include "stdio.hpp"

INIT_PRIORITY (PRIO_SLAB)
Slab_cache Pt::cache (sizeof (Pt), 32);

Pt::Pt (Pd *own, mword sel, Ec *e, Mtd m, mword addr) : Kobject (PT, static_cast<Space_obj *>(own), sel, 0x3, free), ec (e), mtd (m), ip (addr), id(0)
c000d82a:	56                   	push   %esi
c000d82b:	85 d2                	test   %edx,%edx
c000d82d:	53                   	push   %ebx
c000d82e:	89 c3                	mov    %eax,%ebx
c000d830:	8b 74 24 0c          	mov    0xc(%esp),%esi
c000d834:	8d 82 88 01 00 00    	lea    0x188(%edx),%eax
c000d83a:	ba 00 00 00 00       	mov    $0x0,%edx
c000d83f:	6a 00                	push   $0x0
c000d841:	0f 45 d0             	cmovne %eax,%edx
c000d844:	68 b2 d7 00 c0       	push   $0xc000d7b2
c000d849:	89 d8                	mov    %ebx,%eax
c000d84b:	6a 03                	push   $0x3
c000d84d:	51                   	push   %ecx
c000d84e:	89 d9                	mov    %ebx,%ecx
c000d850:	e8 f1 53 ff ff       	call   c0002c46 <_ZN3MdbC1EP5SpacemmmPFvP8Rcu_elemES5_>
    private:
        uint32 ref;

    public:
        ALWAYS_INLINE
        inline Refex() : ref (1) {}
c000d855:	83 c4 10             	add    $0x10,%esp
c000d858:	c6 43 44 03          	movb   $0x3,0x44(%ebx)
c000d85c:	66 c7 43 46 00 00    	movw   $0x0,0x46(%ebx)
c000d862:	c7 43 48 01 00 00 00 	movl   $0x1,0x48(%ebx)

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c000d869:	8b 46 48             	mov    0x48(%esi),%eax
c000d86c:	85 c0                	test   %eax,%eax
c000d86e:	74 0c                	je     c000d87c <_ZN2PtC1EP2PdmP2Ec3Mtdm+0x52>
                if (Atomic::cmp_swap (ref, r, r + 1))
c000d870:	8d 50 01             	lea    0x1(%eax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c000d873:	f0 0f b1 56 48       	lock cmpxchg %edx,0x48(%esi)
c000d878:	75 ef                	jne    c000d869 <_ZN2PtC1EP2PdmP2Ec3Mtdm+0x3f>
c000d87a:	eb 02                	jmp    c000d87e <_ZN2PtC1EP2PdmP2Ec3Mtdm+0x54>
    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }

        ALWAYS_INLINE
        inline Refptr (T *p) : ptr (p->add_ref() ? p : nullptr) {}
c000d87c:	31 f6                	xor    %esi,%esi
c000d87e:	8b 44 24 10          	mov    0x10(%esp),%eax
c000d882:	89 73 4c             	mov    %esi,0x4c(%ebx)
c000d885:	c7 43 58 00 00 00 00 	movl   $0x0,0x58(%ebx)
c000d88c:	89 43 50             	mov    %eax,0x50(%ebx)
c000d88f:	8b 44 24 14          	mov    0x14(%esp),%eax
c000d893:	89 43 54             	mov    %eax,0x54(%ebx)
{
    trace (TRACE_SYSCALL, "PT:%p created (EC:%p IP:%#lx)", this, e, ip);
}
c000d896:	5b                   	pop    %ebx
c000d897:	5e                   	pop    %esi
c000d898:	c3                   	ret    

c000d899 <_GLOBAL__sub_I.00102__ZN2Pt5cacheE>:
#include "ec.hpp"
#include "pt.hpp"
#include "stdio.hpp"

INIT_PRIORITY (PRIO_SLAB)
Slab_cache Pt::cache (sizeof (Pt), 32);
c000d899:	b9 20 00 00 00       	mov    $0x20,%ecx
c000d89e:	ba 5c 00 00 00       	mov    $0x5c,%edx
c000d8a3:	b8 7c b4 01 c0       	mov    $0xc001b47c,%eax
c000d8a8:	e9 59 29 00 00       	jmp    c0010206 <_ZN10Slab_cacheC1Emj>
c000d8ad:	90                   	nop

c000d8ae <_ZN3PteI3DptyLj4ELj9ELb1EE4walkER5Quotaymb>:
mword Dpt::ord = ~0UL;
mword Ept::ord = ~0UL;
mword Hpt::ord = ~0UL;

template <typename P, typename E, unsigned L, unsigned B, bool F>
P *Pte<P,E,L,B,F>::walk (Quota &quota, E v, unsigned long n, bool a)
c000d8ae:	55                   	push   %ebp
c000d8af:	57                   	push   %edi
{
    unsigned long l = L;
c000d8b0:	bf 04 00 00 00       	mov    $0x4,%edi
mword Dpt::ord = ~0UL;
mword Ept::ord = ~0UL;
mword Hpt::ord = ~0UL;

template <typename P, typename E, unsigned L, unsigned B, bool F>
P *Pte<P,E,L,B,F>::walk (Quota &quota, E v, unsigned long n, bool a)
c000d8b5:	56                   	push   %esi
{
    unsigned long l = L;

    for (P *p, *e = static_cast<P *>(this);; e = static_cast<P *>(Buddy::phys_to_ptr (e->addr())) + (v >> (--l * B + PAGE_BITS) & ((1UL << B) - 1))) {
c000d8b6:	89 c6                	mov    %eax,%esi
mword Dpt::ord = ~0UL;
mword Ept::ord = ~0UL;
mword Hpt::ord = ~0UL;

template <typename P, typename E, unsigned L, unsigned B, bool F>
P *Pte<P,E,L,B,F>::walk (Quota &quota, E v, unsigned long n, bool a)
c000d8b8:	53                   	push   %ebx
c000d8b9:	83 ec 10             	sub    $0x10,%esp
c000d8bc:	8a 5c 24 30          	mov    0x30(%esp),%bl
c000d8c0:	89 14 24             	mov    %edx,(%esp)
c000d8c3:	88 5c 24 07          	mov    %bl,0x7(%esp)
{
    unsigned long l = L;

    for (P *p, *e = static_cast<P *>(this);; e = static_cast<P *>(Buddy::phys_to_ptr (e->addr())) + (v >> (--l * B + PAGE_BITS) & ((1UL << B) - 1))) {

        if (l == n)
c000d8c7:	3b 7c 24 2c          	cmp    0x2c(%esp),%edi
c000d8cb:	0f 84 b0 00 00 00    	je     c000d981 <_ZN3PteI3DptyLj4ELj9ELb1EE4walkER5Quotaymb+0xd3>
            return e;

        if (!e->val) {
c000d8d1:	8b 46 04             	mov    0x4(%esi),%eax
c000d8d4:	0b 06                	or     (%esi),%eax
c000d8d6:	75 76                	jne    c000d94e <_ZN3PteI3DptyLj4ELj9ELb1EE4walkER5Quotaymb+0xa0>

            if (!a)
c000d8d8:	80 7c 24 07 00       	cmpb   $0x0,0x7(%esp)
c000d8dd:	0f 84 a2 00 00 00    	je     c000d985 <_ZN3PteI3DptyLj4ELj9ELb1EE4walkER5Quotaymb+0xd7>
        }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota)
        {
            void *p = Buddy::allocator.alloc (0, quota, Buddy::FILL_0);
c000d8e3:	6a 01                	push   $0x1
c000d8e5:	31 d2                	xor    %edx,%edx
c000d8e7:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c000d8eb:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c000d8f0:	e8 17 3b ff ff       	call   c000140c <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
c000d8f5:	89 c5                	mov    %eax,%ebp
c000d8f7:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
c000d8fd:	58                   	pop    %eax
c000d8fe:	89 e8                	mov    %ebp,%eax
}

ALWAYS_INLINE NONNULL
inline void *flush (void *d, size_t n)
{
    for (char *p = static_cast<char *>(d); p < static_cast<char *>(d) + n; p += 32)
c000d900:	39 d0                	cmp    %edx,%eax
c000d902:	74 08                	je     c000d90c <_ZN3PteI3DptyLj4ELj9ELb1EE4walkER5Quotaymb+0x5e>

template <typename T>
ALWAYS_INLINE
static inline void flush (T t)
{
    asm volatile ("clflush %0" : : "m" (*t) : "memory");
c000d904:	0f ae 38             	clflush (%eax)
}

ALWAYS_INLINE NONNULL
inline void *flush (void *d, size_t n)
{
    for (char *p = static_cast<char *>(d); p < static_cast<char *>(d) + n; p += 32)
c000d907:	83 c0 20             	add    $0x20,%eax
c000d90a:	eb f4                	jmp    c000d900 <_ZN3PteI3DptyLj4ELj9ELb1EE4walkER5Quotaymb+0x52>
c000d90c:	89 ea                	mov    %ebp,%edx
                return nullptr;

            if (!e->set (0, Buddy::ptr_to_phys (p = new (quota) P) | (l == L ? 0 : P::PTE_N)))
c000d90e:	31 c0                	xor    %eax,%eax
c000d910:	81 ea 00 00 c0 bf    	sub    $0xbfc00000,%edx
c000d916:	83 ff 04             	cmp    $0x4,%edi
c000d919:	0f 95 c0             	setne  %al
c000d91c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c000d923:	00 
c000d924:	8d 04 40             	lea    (%eax,%eax,2),%eax
c000d927:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c000d92b:	09 d0                	or     %edx,%eax
c000d92d:	89 c3                	mov    %eax,%ebx
c000d92f:	89 44 24 08          	mov    %eax,0x8(%esp)
c000d933:	31 c0                	xor    %eax,%eax
c000d935:	89 c2                	mov    %eax,%edx

        void free_up (Quota &quota, unsigned l, P *, mword, bool (*) (Paddr, mword, unsigned), bool (*) (unsigned, mword));

    public:

        Pte() : val(0) {}
c000d937:	c7 45 00 00 00 00 00 	movl   $0x0,0x0(%ebp)
c000d93e:	c7 45 04 00 00 00 00 	movl   $0x0,0x4(%ebp)
c000d945:	f0 0f c7 0e          	lock cmpxchg8b (%esi)
        ALWAYS_INLINE
        inline bool set (E o, E v)
        {
            bool b = Atomic::cmp_swap (val, o, v);

            if (F && b)
c000d949:	75 3e                	jne    c000d989 <_ZN3PteI3DptyLj4ELj9ELb1EE4walkER5Quotaymb+0xdb>

template <typename T>
ALWAYS_INLINE
static inline void flush (T t)
{
    asm volatile ("clflush %0" : : "m" (*t) : "memory");
c000d94b:	0f ae 3e             	clflush (%esi)

        ALWAYS_INLINE
        inline mword attr() const { return static_cast<mword>(val) & PAGE_MASK; }

        ALWAYS_INLINE
        inline Paddr addr() const { return static_cast<Paddr>(val) & ~((1UL << order()) - 1); }
c000d94e:	8b 1e                	mov    (%esi),%ebx
template <typename P, typename E, unsigned L, unsigned B, bool F>
P *Pte<P,E,L,B,F>::walk (Quota &quota, E v, unsigned long n, bool a)
{
    unsigned long l = L;

    for (P *p, *e = static_cast<P *>(this);; e = static_cast<P *>(Buddy::phys_to_ptr (e->addr())) + (v >> (--l * B + PAGE_BITS) & ((1UL << B) - 1))) {
c000d950:	4f                   	dec    %edi
c000d951:	8b 54 24 28          	mov    0x28(%esp),%edx
c000d955:	8d 0c ff             	lea    (%edi,%edi,8),%ecx
c000d958:	8b 44 24 24          	mov    0x24(%esp),%eax
c000d95c:	83 c1 0c             	add    $0xc,%ecx
c000d95f:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
c000d965:	0f ad d0             	shrd   %cl,%edx,%eax
c000d968:	d3 ea                	shr    %cl,%edx
c000d96a:	f6 c1 20             	test   $0x20,%cl
c000d96d:	0f 45 c2             	cmovne %edx,%eax
c000d970:	25 ff 01 00 00       	and    $0x1ff,%eax
c000d975:	8d b4 c3 00 00 c0 bf 	lea    -0x40400000(%ebx,%eax,8),%esi
c000d97c:	e9 46 ff ff ff       	jmp    c000d8c7 <_ZN3PteI3DptyLj4ELj9ELb1EE4walkER5Quotaymb+0x19>
c000d981:	89 f0                	mov    %esi,%eax
c000d983:	eb 15                	jmp    c000d99a <_ZN3PteI3DptyLj4ELj9ELb1EE4walkER5Quotaymb+0xec>
            return e;

        if (!e->val) {

            if (!a)
                return nullptr;
c000d985:	31 c0                	xor    %eax,%eax
c000d987:	eb 11                	jmp    c000d99a <_ZN3PteI3DptyLj4ELj9ELb1EE4walkER5Quotaymb+0xec>

            return p;
        }

        ALWAYS_INLINE
        static inline void destroy(Pte *obj, Quota &quota) { obj->~Pte(); Buddy::allocator.free (reinterpret_cast<mword>(obj), quota); }
c000d989:	8b 0c 24             	mov    (%esp),%ecx
c000d98c:	89 ea                	mov    %ebp,%edx
c000d98e:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c000d993:	e8 d0 37 ff ff       	call   c0001168 <_ZN5Buddy4freeEmR5Quota>
c000d998:	eb b4                	jmp    c000d94e <_ZN3PteI3DptyLj4ELj9ELb1EE4walkER5Quotaymb+0xa0>

            if (!e->set (0, Buddy::ptr_to_phys (p = new (quota) P) | (l == L ? 0 : P::PTE_N)))
                Pte::destroy(p, quota);
        }
    }
}
c000d99a:	83 c4 10             	add    $0x10,%esp
c000d99d:	5b                   	pop    %ebx
c000d99e:	5e                   	pop    %esi
c000d99f:	5f                   	pop    %edi
c000d9a0:	5d                   	pop    %ebp
c000d9a1:	c3                   	ret    

c000d9a2 <_ZN3PteI3DptyLj4ELj9ELb1EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE>:

    Pte::destroy (e, quota);
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
void Pte<P,E,L,B,F>::free_up (Quota &quota, unsigned l, P * e, mword v, bool (*d)(Paddr, mword, unsigned), bool (*il) (unsigned, mword))
c000d9a2:	55                   	push   %ebp
c000d9a3:	57                   	push   %edi
c000d9a4:	56                   	push   %esi
c000d9a5:	53                   	push   %ebx
c000d9a6:	83 ec 10             	sub    $0x10,%esp
c000d9a9:	8b 6c 24 24          	mov    0x24(%esp),%ebp
{
    if (!e)
c000d9ad:	85 ed                	test   %ebp,%ebp
c000d9af:	0f 84 bc 00 00 00    	je     c000da71 <_ZN3PteI3DptyLj4ELj9ELb1EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0xcf>
    for (unsigned long i = 0; i < (1 << B); i++) {
        if (!e[i].val || e[i].super())
            continue;

        P *p = static_cast<P *>(Buddy::phys_to_ptr (e[i].addr()));
        mword virt = v + (i << (l * B + PAGE_BITS));
c000d9b5:	8d 04 c9             	lea    (%ecx,%ecx,8),%eax
c000d9b8:	89 ce                	mov    %ecx,%esi
c000d9ba:	83 c0 0c             	add    $0xc,%eax
c000d9bd:	31 db                	xor    %ebx,%ebx
c000d9bf:	89 44 24 08          	mov    %eax,0x8(%esp)

        if (il ? il(l, virt) : l > 1)
            p->free_up(quota, l - 1, p, virt, d, il);
c000d9c3:	8d 41 ff             	lea    -0x1(%ecx),%eax
c000d9c6:	89 54 24 04          	mov    %edx,0x4(%esp)
c000d9ca:	89 44 24 0c          	mov    %eax,0xc(%esp)
{
    if (!e)
        return;

    for (unsigned long i = 0; i < (1 << B); i++) {
        if (!e[i].val || e[i].super())
c000d9ce:	8b 44 dd 00          	mov    0x0(%ebp,%ebx,8),%eax
c000d9d2:	89 c2                	mov    %eax,%edx
c000d9d4:	0b 54 dd 04          	or     0x4(%ebp,%ebx,8),%edx
c000d9d8:	74 6d                	je     c000da47 <_ZN3PteI3DptyLj4ELj9ELb1EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0xa5>
c000d9da:	a8 80                	test   $0x80,%al
c000d9dc:	75 69                	jne    c000da47 <_ZN3PteI3DptyLj4ELj9ELb1EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0xa5>
            continue;

        P *p = static_cast<P *>(Buddy::phys_to_ptr (e[i].addr()));
        mword virt = v + (i << (l * B + PAGE_BITS));
c000d9de:	8a 4c 24 08          	mov    0x8(%esp),%cl
c000d9e2:	89 df                	mov    %ebx,%edi

        ALWAYS_INLINE
        inline mword attr() const { return static_cast<mword>(val) & PAGE_MASK; }

        ALWAYS_INLINE
        inline Paddr addr() const { return static_cast<Paddr>(val) & ~((1UL << order()) - 1); }
c000d9e4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
        }

        ALWAYS_INLINE
        inline mword phys_to_virt (mword phys)
        {
            return phys + reinterpret_cast<mword>(&OFFSET);
c000d9e9:	05 00 00 c0 bf       	add    $0xbfc00000,%eax
c000d9ee:	89 04 24             	mov    %eax,(%esp)
c000d9f1:	d3 e7                	shl    %cl,%edi
c000d9f3:	03 7c 24 28          	add    0x28(%esp),%edi

        if (il ? il(l, virt) : l > 1)
c000d9f7:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c000d9fc:	74 58                	je     c000da56 <_ZN3PteI3DptyLj4ELj9ELb1EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0xb4>
c000d9fe:	89 fa                	mov    %edi,%edx
c000da00:	89 f0                	mov    %esi,%eax
c000da02:	ff 54 24 30          	call   *0x30(%esp)
c000da06:	84 c0                	test   %al,%al
c000da08:	74 21                	je     c000da2b <_ZN3PteI3DptyLj4ELj9ELb1EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0x89>
            p->free_up(quota, l - 1, p, virt, d, il);
c000da0a:	ff 74 24 30          	pushl  0x30(%esp)
c000da0e:	ff 74 24 30          	pushl  0x30(%esp)
c000da12:	57                   	push   %edi
c000da13:	ff 74 24 0c          	pushl  0xc(%esp)
c000da17:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
c000da1b:	8b 54 24 14          	mov    0x14(%esp),%edx
c000da1f:	8b 44 24 10          	mov    0x10(%esp),%eax
c000da23:	e8 7a ff ff ff       	call   c000d9a2 <_ZN3PteI3DptyLj4ELj9ELb1EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE>
c000da28:	83 c4 10             	add    $0x10,%esp

        if (!d || d(e[i].addr(), virt, l))
c000da2b:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c000da30:	74 2c                	je     c000da5e <_ZN3PteI3DptyLj4ELj9ELb1EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0xbc>
c000da32:	8b 44 dd 00          	mov    0x0(%ebp,%ebx,8),%eax
c000da36:	89 f1                	mov    %esi,%ecx
c000da38:	89 fa                	mov    %edi,%edx
c000da3a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c000da3f:	ff 54 24 2c          	call   *0x2c(%esp)
c000da43:	84 c0                	test   %al,%al
c000da45:	75 17                	jne    c000da5e <_ZN3PteI3DptyLj4ELj9ELb1EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0xbc>
void Pte<P,E,L,B,F>::free_up (Quota &quota, unsigned l, P * e, mword v, bool (*d)(Paddr, mword, unsigned), bool (*il) (unsigned, mword))
{
    if (!e)
        return;

    for (unsigned long i = 0; i < (1 << B); i++) {
c000da47:	43                   	inc    %ebx
c000da48:	81 fb 00 02 00 00    	cmp    $0x200,%ebx
c000da4e:	0f 85 7a ff ff ff    	jne    c000d9ce <_ZN3PteI3DptyLj4ELj9ELb1EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0x2c>
c000da54:	eb 1b                	jmp    c000da71 <_ZN3PteI3DptyLj4ELj9ELb1EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0xcf>
            continue;

        P *p = static_cast<P *>(Buddy::phys_to_ptr (e[i].addr()));
        mword virt = v + (i << (l * B + PAGE_BITS));

        if (il ? il(l, virt) : l > 1)
c000da56:	83 fe 01             	cmp    $0x1,%esi
c000da59:	0f 97 c0             	seta   %al
c000da5c:	eb a8                	jmp    c000da06 <_ZN3PteI3DptyLj4ELj9ELb1EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0x64>

            return p;
        }

        ALWAYS_INLINE
        static inline void destroy(Pte *obj, Quota &quota) { obj->~Pte(); Buddy::allocator.free (reinterpret_cast<mword>(obj), quota); }
c000da5e:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c000da62:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c000da67:	8b 14 24             	mov    (%esp),%edx
c000da6a:	e8 f9 36 ff ff       	call   c0001168 <_ZN5Buddy4freeEmR5Quota>
c000da6f:	eb d6                	jmp    c000da47 <_ZN3PteI3DptyLj4ELj9ELb1EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0xa5>
            p->free_up(quota, l - 1, p, virt, d, il);

        if (!d || d(e[i].addr(), virt, l))
            Pte::destroy(p, quota);
    }
}
c000da71:	83 c4 10             	add    $0x10,%esp
c000da74:	5b                   	pop    %ebx
c000da75:	5e                   	pop    %esi
c000da76:	5f                   	pop    %edi
c000da77:	5d                   	pop    %ebp
c000da78:	c3                   	ret    
c000da79:	90                   	nop

c000da7a <_ZN3PteI3DptyLj4ELj9ELb1EE6updateER5QuotaymymNS1_4TypeE>:
        return s;
    }
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P,E,L,B,F>::update (Quota &quota, E v, mword o, E p, mword a, Type t)
c000da7a:	55                   	push   %ebp
{
    unsigned long l = o / B, n = 1UL << o % B, s;
c000da7b:	b9 09 00 00 00       	mov    $0x9,%ecx
        return s;
    }
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P,E,L,B,F>::update (Quota &quota, E v, mword o, E p, mword a, Type t)
c000da80:	57                   	push   %edi
c000da81:	89 c7                	mov    %eax,%edi
c000da83:	56                   	push   %esi
c000da84:	53                   	push   %ebx
{
    unsigned long l = o / B, n = 1UL << o % B, s;
c000da85:	bb 01 00 00 00       	mov    $0x1,%ebx
        return s;
    }
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P,E,L,B,F>::update (Quota &quota, E v, mword o, E p, mword a, Type t)
c000da8a:	83 ec 18             	sub    $0x18,%esp
c000da8d:	8b 44 24 34          	mov    0x34(%esp),%eax
c000da91:	89 54 24 0c          	mov    %edx,0xc(%esp)
{
    unsigned long l = o / B, n = 1UL << o % B, s;
c000da95:	31 d2                	xor    %edx,%edx
        return s;
    }
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P,E,L,B,F>::update (Quota &quota, E v, mword o, E p, mword a, Type t)
c000da97:	8b 74 24 38          	mov    0x38(%esp),%esi
{
    unsigned long l = o / B, n = 1UL << o % B, s;
c000da9b:	f7 f1                	div    %ecx
        return s;
    }
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P,E,L,B,F>::update (Quota &quota, E v, mword o, E p, mword a, Type t)
c000da9d:	89 74 24 08          	mov    %esi,0x8(%esp)
c000daa1:	8b 74 24 3c          	mov    0x3c(%esp),%esi
c000daa5:	89 74 24 10          	mov    %esi,0x10(%esp)
c000daa9:	8b 74 24 40          	mov    0x40(%esp),%esi
{
    unsigned long l = o / B, n = 1UL << o % B, s;
c000daad:	89 04 24             	mov    %eax,(%esp)
c000dab0:	88 d1                	mov    %dl,%cl
c000dab2:	89 d8                	mov    %ebx,%eax
c000dab4:	d3 e0                	shl    %cl,%eax
c000dab6:	89 44 24 04          	mov    %eax,0x4(%esp)

    P *e = walk (quota, v, l, t == TYPE_UP);
c000daba:	31 c0                	xor    %eax,%eax
c000dabc:	83 7c 24 44 00       	cmpl   $0x0,0x44(%esp)
c000dac1:	0f 94 c0             	sete   %al
c000dac4:	50                   	push   %eax
c000dac5:	89 f8                	mov    %edi,%eax
c000dac7:	ff 74 24 04          	pushl  0x4(%esp)
c000dacb:	ff 74 24 38          	pushl  0x38(%esp)
c000dacf:	ff 74 24 38          	pushl  0x38(%esp)
c000dad3:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c000dad7:	e8 d2 fd ff ff       	call   c000d8ae <_ZN3PteI3DptyLj4ELj9ELb1EE4walkER5Quotaymb>

    if (!e)
c000dadc:	83 c4 10             	add    $0x10,%esp
template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P,E,L,B,F>::update (Quota &quota, E v, mword o, E p, mword a, Type t)
{
    unsigned long l = o / B, n = 1UL << o % B, s;

    P *e = walk (quota, v, l, t == TYPE_UP);
c000dadf:	89 c5                	mov    %eax,%ebp

    if (!e)
        return false;
c000dae1:	31 c0                	xor    %eax,%eax
{
    unsigned long l = o / B, n = 1UL << o % B, s;

    P *e = walk (quota, v, l, t == TYPE_UP);

    if (!e)
c000dae3:	85 ed                	test   %ebp,%ebp
c000dae5:	0f 84 cf 00 00 00    	je     c000dbba <_ZN3PteI3DptyLj4ELj9ELb1EE6updateER5QuotaymymNS1_4TypeE+0x140>
        return false;

    if (a) {
c000daeb:	85 f6                	test   %esi,%esi
c000daed:	74 28                	je     c000db17 <_ZN3PteI3DptyLj4ELj9ELb1EE6updateER5QuotaymymNS1_4TypeE+0x9d>
        p |= P::order (o % B) | (l ? P::PTE_S : 0) | a;
c000daef:	83 3c 24 01          	cmpl   $0x1,(%esp)
c000daf3:	8b 4c 24 08          	mov    0x8(%esp),%ecx
c000daf7:	8b 7c 24 10          	mov    0x10(%esp),%edi
c000dafb:	19 c0                	sbb    %eax,%eax
c000dafd:	f7 d0                	not    %eax
c000daff:	25 80 00 00 00       	and    $0x80,%eax
c000db04:	09 f0                	or     %esi,%eax
c000db06:	09 c1                	or     %eax,%ecx
c000db08:	89 ce                	mov    %ecx,%esi
        s = 1UL << (l * B + PAGE_BITS);
c000db0a:	6b 0c 24 09          	imul   $0x9,(%esp),%ecx
c000db0e:	83 c1 0c             	add    $0xc,%ecx
c000db11:	d3 e3                	shl    %cl,%ebx
c000db13:	89 da                	mov    %ebx,%edx
c000db15:	eb 06                	jmp    c000db1d <_ZN3PteI3DptyLj4ELj9ELb1EE6updateER5QuotaymymNS1_4TypeE+0xa3>
    } else
        p = s = 0;
c000db17:	31 d2                	xor    %edx,%edx
c000db19:	31 f6                	xor    %esi,%esi
c000db1b:	31 ff                	xor    %edi,%edi
c000db1d:	8b 44 24 04          	mov    0x4(%esp),%eax
c000db21:	89 eb                	mov    %ebp,%ebx

    bool flush_tlb = false;

    for (unsigned long i = 0; i < n; e[i].val = p, i++, p += s) {
c000db23:	89 54 24 10          	mov    %edx,0x10(%esp)
c000db27:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c000db2e:	00 
c000db2f:	8d 44 c5 00          	lea    0x0(%ebp,%eax,8),%eax
c000db33:	89 44 24 08          	mov    %eax,0x8(%esp)
        p |= P::order (o % B) | (l ? P::PTE_S : 0) | a;
        s = 1UL << (l * B + PAGE_BITS);
    } else
        p = s = 0;

    bool flush_tlb = false;
c000db37:	31 c0                	xor    %eax,%eax

    for (unsigned long i = 0; i < n; e[i].val = p, i++, p += s) {

        if (l && e[i].val != p)
c000db39:	83 3c 24 00          	cmpl   $0x0,(%esp)
c000db3d:	74 0b                	je     c000db4a <_ZN3PteI3DptyLj4ELj9ELb1EE6updateER5QuotaymymNS1_4TypeE+0xd0>
c000db3f:	39 7b 04             	cmp    %edi,0x4(%ebx)
c000db42:	75 04                	jne    c000db48 <_ZN3PteI3DptyLj4ELj9ELb1EE6updateER5QuotaymymNS1_4TypeE+0xce>
c000db44:	39 33                	cmp    %esi,(%ebx)
c000db46:	74 02                	je     c000db4a <_ZN3PteI3DptyLj4ELj9ELb1EE6updateER5QuotaymymNS1_4TypeE+0xd0>
            flush_tlb = true;
c000db48:	b0 01                	mov    $0x1,%al

        if (!e[i].val)
c000db4a:	8b 13                	mov    (%ebx),%edx
c000db4c:	89 d1                	mov    %edx,%ecx
c000db4e:	0b 4b 04             	or     0x4(%ebx),%ecx
c000db51:	89 54 24 04          	mov    %edx,0x4(%esp)
c000db55:	0f 94 c2             	sete   %dl
            continue;

        if (t == TYPE_DF)
c000db58:	83 7c 24 44 02       	cmpl   $0x2,0x44(%esp)
c000db5d:	0f 94 c1             	sete   %cl
c000db60:	08 ca                	or     %cl,%dl
            continue;

        if (l && !e[i].super()) {
c000db62:	83 3c 24 00          	cmpl   $0x0,(%esp)
c000db66:	0f 95 c1             	setne  %cl
c000db69:	38 ca                	cmp    %cl,%dl
c000db6b:	73 07                	jae    c000db74 <_ZN3PteI3DptyLj4ELj9ELb1EE6updateER5QuotaymymNS1_4TypeE+0xfa>
c000db6d:	f6 44 24 04 80       	testb  $0x80,0x4(%esp)
c000db72:	74 25                	je     c000db99 <_ZN3PteI3DptyLj4ELj9ELb1EE6updateER5QuotaymymNS1_4TypeE+0x11f>
    } else
        p = s = 0;

    bool flush_tlb = false;

    for (unsigned long i = 0; i < n; e[i].val = p, i++, p += s) {
c000db74:	89 33                	mov    %esi,(%ebx)
c000db76:	03 74 24 10          	add    0x10(%esp),%esi
c000db7a:	89 7b 04             	mov    %edi,0x4(%ebx)
c000db7d:	13 7c 24 14          	adc    0x14(%esp),%edi
c000db81:	83 c3 08             	add    $0x8,%ebx
c000db84:	3b 5c 24 08          	cmp    0x8(%esp),%ebx
c000db88:	75 af                	jne    c000db39 <_ZN3PteI3DptyLj4ELj9ELb1EE6updateER5QuotaymymNS1_4TypeE+0xbf>
}

ALWAYS_INLINE NONNULL
inline void *flush (void *d, size_t n)
{
    for (char *p = static_cast<char *>(d); p < static_cast<char *>(d) + n; p += 32)
c000db8a:	3b 6c 24 08          	cmp    0x8(%esp),%ebp
c000db8e:	73 2a                	jae    c000dbba <_ZN3PteI3DptyLj4ELj9ELb1EE6updateER5QuotaymymNS1_4TypeE+0x140>

template <typename T>
ALWAYS_INLINE
static inline void flush (T t)
{
    asm volatile ("clflush %0" : : "m" (*t) : "memory");
c000db90:	0f ae 7d 00          	clflush 0x0(%ebp)
}

ALWAYS_INLINE NONNULL
inline void *flush (void *d, size_t n)
{
    for (char *p = static_cast<char *>(d); p < static_cast<char *>(d) + n; p += 32)
c000db94:	83 c5 20             	add    $0x20,%ebp
c000db97:	eb f1                	jmp    c000db8a <_ZN3PteI3DptyLj4ELj9ELb1EE6updateER5QuotaymymNS1_4TypeE+0x110>

        ALWAYS_INLINE
        inline mword attr() const { return static_cast<mword>(val) & PAGE_MASK; }

        ALWAYS_INLINE
        inline Paddr addr() const { return static_cast<Paddr>(val) & ~((1UL << order()) - 1); }
c000db99:	8b 44 24 04          	mov    0x4(%esp),%eax

            return p;
        }

        ALWAYS_INLINE
        static inline void destroy(Pte *obj, Quota &quota) { obj->~Pte(); Buddy::allocator.free (reinterpret_cast<mword>(obj), quota); }
c000db9d:	8b 4c 24 0c          	mov    0xc(%esp),%ecx

        ALWAYS_INLINE
        inline mword attr() const { return static_cast<mword>(val) & PAGE_MASK; }

        ALWAYS_INLINE
        inline Paddr addr() const { return static_cast<Paddr>(val) & ~((1UL << order()) - 1); }
c000dba1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c000dba6:	8d 90 00 00 c0 bf    	lea    -0x40400000(%eax),%edx

            return p;
        }

        ALWAYS_INLINE
        static inline void destroy(Pte *obj, Quota &quota) { obj->~Pte(); Buddy::allocator.free (reinterpret_cast<mword>(obj), quota); }
c000dbac:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c000dbb1:	e8 b2 35 ff ff       	call   c0001168 <_ZN5Buddy4freeEmR5Quota>
        if (t == TYPE_DF)
            continue;

        if (l && !e[i].super()) {
            Pte::destroy(static_cast<P *>(Buddy::phys_to_ptr (e[i].addr())), quota);
            flush_tlb = true;
c000dbb6:	b0 01                	mov    $0x1,%al
c000dbb8:	eb ba                	jmp    c000db74 <_ZN3PteI3DptyLj4ELj9ELb1EE6updateER5QuotaymymNS1_4TypeE+0xfa>

    if (F)
        flush (e, n * sizeof (E));

    return flush_tlb;
}
c000dbba:	83 c4 18             	add    $0x18,%esp
c000dbbd:	5b                   	pop    %ebx
c000dbbe:	5e                   	pop    %esi
c000dbbf:	5f                   	pop    %edi
c000dbc0:	5d                   	pop    %ebp
c000dbc1:	c3                   	ret    

c000dbc2 <_ZN3PteI3DptyLj4ELj9ELb1EE5clearER5QuotaPFbmmjEPFbjmE>:

template <typename P, typename E, unsigned L, unsigned B, bool F>
void Pte<P,E,L,B,F>::clear (Quota &quota, bool (*d) (Paddr, mword, unsigned), bool (*il) (unsigned, mword))
c000dbc2:	57                   	push   %edi
c000dbc3:	56                   	push   %esi
c000dbc4:	53                   	push   %ebx
{
    if (!val)
c000dbc5:	8b 18                	mov    (%eax),%ebx

    return flush_tlb;
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
void Pte<P,E,L,B,F>::clear (Quota &quota, bool (*d) (Paddr, mword, unsigned), bool (*il) (unsigned, mword))
c000dbc7:	8b 7c 24 10          	mov    0x10(%esp),%edi
{
    if (!val)
c000dbcb:	89 de                	mov    %ebx,%esi
c000dbcd:	0b 70 04             	or     0x4(%eax),%esi
c000dbd0:	74 33                	je     c000dc05 <_ZN3PteI3DptyLj4ELj9ELb1EE5clearER5QuotaPFbmmjEPFbjmE+0x43>
        return;

    P * e = static_cast<P *>(Buddy::phys_to_ptr (this->addr()));

    e->free_up(quota, L - 1, e, 0, d, il);
c000dbd2:	57                   	push   %edi

        ALWAYS_INLINE
        inline mword attr() const { return static_cast<mword>(val) & PAGE_MASK; }

        ALWAYS_INLINE
        inline Paddr addr() const { return static_cast<Paddr>(val) & ~((1UL << order()) - 1); }
c000dbd3:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
c000dbd9:	51                   	push   %ecx
c000dbda:	81 c3 00 00 c0 bf    	add    $0xbfc00000,%ebx
c000dbe0:	6a 00                	push   $0x0
c000dbe2:	89 d8                	mov    %ebx,%eax
c000dbe4:	53                   	push   %ebx
c000dbe5:	b9 03 00 00 00       	mov    $0x3,%ecx
c000dbea:	89 d6                	mov    %edx,%esi
c000dbec:	e8 b1 fd ff ff       	call   c000d9a2 <_ZN3PteI3DptyLj4ELj9ELb1EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE>

            return p;
        }

        ALWAYS_INLINE
        static inline void destroy(Pte *obj, Quota &quota) { obj->~Pte(); Buddy::allocator.free (reinterpret_cast<mword>(obj), quota); }
c000dbf1:	83 c4 10             	add    $0x10,%esp
c000dbf4:	89 da                	mov    %ebx,%edx

    Pte::destroy (e, quota);
}
c000dbf6:	5b                   	pop    %ebx
c000dbf7:	89 f1                	mov    %esi,%ecx
c000dbf9:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c000dbfe:	5e                   	pop    %esi
c000dbff:	5f                   	pop    %edi
c000dc00:	e9 63 35 ff ff       	jmp    c0001168 <_ZN5Buddy4freeEmR5Quota>
c000dc05:	5b                   	pop    %ebx
c000dc06:	5e                   	pop    %esi
c000dc07:	5f                   	pop    %edi
c000dc08:	c3                   	ret    
c000dc09:	90                   	nop

c000dc0a <_ZN3PteI3EptyLj4ELj9ELb0EE4walkER5Quotaymb>:
mword Dpt::ord = ~0UL;
mword Ept::ord = ~0UL;
mword Hpt::ord = ~0UL;

template <typename P, typename E, unsigned L, unsigned B, bool F>
P *Pte<P,E,L,B,F>::walk (Quota &quota, E v, unsigned long n, bool a)
c000dc0a:	55                   	push   %ebp
c000dc0b:	57                   	push   %edi
{
    unsigned long l = L;
c000dc0c:	bf 04 00 00 00       	mov    $0x4,%edi
mword Dpt::ord = ~0UL;
mword Ept::ord = ~0UL;
mword Hpt::ord = ~0UL;

template <typename P, typename E, unsigned L, unsigned B, bool F>
P *Pte<P,E,L,B,F>::walk (Quota &quota, E v, unsigned long n, bool a)
c000dc11:	56                   	push   %esi
{
    unsigned long l = L;

    for (P *p, *e = static_cast<P *>(this);; e = static_cast<P *>(Buddy::phys_to_ptr (e->addr())) + (v >> (--l * B + PAGE_BITS) & ((1UL << B) - 1))) {
c000dc12:	89 c6                	mov    %eax,%esi
mword Dpt::ord = ~0UL;
mword Ept::ord = ~0UL;
mword Hpt::ord = ~0UL;

template <typename P, typename E, unsigned L, unsigned B, bool F>
P *Pte<P,E,L,B,F>::walk (Quota &quota, E v, unsigned long n, bool a)
c000dc14:	53                   	push   %ebx
c000dc15:	83 ec 10             	sub    $0x10,%esp
c000dc18:	8a 5c 24 30          	mov    0x30(%esp),%bl
c000dc1c:	89 14 24             	mov    %edx,(%esp)
c000dc1f:	88 5c 24 07          	mov    %bl,0x7(%esp)
{
    unsigned long l = L;

    for (P *p, *e = static_cast<P *>(this);; e = static_cast<P *>(Buddy::phys_to_ptr (e->addr())) + (v >> (--l * B + PAGE_BITS) & ((1UL << B) - 1))) {

        if (l == n)
c000dc23:	3b 7c 24 2c          	cmp    0x2c(%esp),%edi
c000dc27:	0f 84 ab 00 00 00    	je     c000dcd8 <_ZN3PteI3EptyLj4ELj9ELb0EE4walkER5Quotaymb+0xce>
            return e;

        if (!e->val) {
c000dc2d:	8b 46 04             	mov    0x4(%esi),%eax
c000dc30:	0b 06                	or     (%esi),%eax
c000dc32:	89 c3                	mov    %eax,%ebx
c000dc34:	75 6f                	jne    c000dca5 <_ZN3PteI3EptyLj4ELj9ELb0EE4walkER5Quotaymb+0x9b>

            if (!a)
c000dc36:	80 7c 24 07 00       	cmpb   $0x0,0x7(%esp)
c000dc3b:	0f 84 9b 00 00 00    	je     c000dcdc <_ZN3PteI3EptyLj4ELj9ELb0EE4walkER5Quotaymb+0xd2>
        }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota)
        {
            void *p = Buddy::allocator.alloc (0, quota, Buddy::FILL_0);
c000dc41:	6a 01                	push   $0x1
c000dc43:	31 d2                	xor    %edx,%edx
c000dc45:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c000dc49:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c000dc4e:	e8 b9 37 ff ff       	call   c000140c <_ZN5Buddy5allocEtR5QuotaNS_4FillE>

        void free_up (Quota &quota, unsigned l, P *, mword, bool (*) (Paddr, mword, unsigned), bool (*) (unsigned, mword));

    public:

        Pte() : val(0) {}
c000dc53:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        }

        ALWAYS_INLINE
        inline mword virt_to_phys (mword virt)
        {
            return virt - reinterpret_cast<mword>(&OFFSET);
c000dc59:	89 c2                	mov    %eax,%edx
        }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota)
        {
            void *p = Buddy::allocator.alloc (0, quota, Buddy::FILL_0);
c000dc5b:	89 c5                	mov    %eax,%ebp

        void free_up (Quota &quota, unsigned l, P *, mword, bool (*) (Paddr, mword, unsigned), bool (*) (unsigned, mword));

    public:

        Pte() : val(0) {}
c000dc5d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
c000dc64:	81 ea 00 00 c0 bf    	sub    $0xbfc00000,%edx
                return nullptr;

            if (!e->set (0, Buddy::ptr_to_phys (p = new (quota) P) | (l == L ? 0 : P::PTE_N)))
c000dc6a:	83 ff 04             	cmp    $0x4,%edi
c000dc6d:	58                   	pop    %eax
c000dc6e:	b8 07 00 00 00       	mov    $0x7,%eax
c000dc73:	0f 44 c3             	cmove  %ebx,%eax
c000dc76:	09 d0                	or     %edx,%eax
c000dc78:	89 da                	mov    %ebx,%edx
c000dc7a:	89 c1                	mov    %eax,%ecx
c000dc7c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c000dc83:	00 
c000dc84:	89 44 24 08          	mov    %eax,0x8(%esp)
c000dc88:	89 d8                	mov    %ebx,%eax
c000dc8a:	89 cb                	mov    %ecx,%ebx
c000dc8c:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c000dc90:	f0 0f c7 0e          	lock cmpxchg8b (%esi)
c000dc94:	74 0f                	je     c000dca5 <_ZN3PteI3EptyLj4ELj9ELb0EE4walkER5Quotaymb+0x9b>

            return p;
        }

        ALWAYS_INLINE
        static inline void destroy(Pte *obj, Quota &quota) { obj->~Pte(); Buddy::allocator.free (reinterpret_cast<mword>(obj), quota); }
c000dc96:	8b 0c 24             	mov    (%esp),%ecx
c000dc99:	89 ea                	mov    %ebp,%edx
c000dc9b:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c000dca0:	e8 c3 34 ff ff       	call   c0001168 <_ZN5Buddy4freeEmR5Quota>

        ALWAYS_INLINE
        inline mword attr() const { return static_cast<mword>(val) & PAGE_MASK; }

        ALWAYS_INLINE
        inline Paddr addr() const { return static_cast<Paddr>(val) & ~((1UL << order()) - 1); }
c000dca5:	8b 1e                	mov    (%esi),%ebx
template <typename P, typename E, unsigned L, unsigned B, bool F>
P *Pte<P,E,L,B,F>::walk (Quota &quota, E v, unsigned long n, bool a)
{
    unsigned long l = L;

    for (P *p, *e = static_cast<P *>(this);; e = static_cast<P *>(Buddy::phys_to_ptr (e->addr())) + (v >> (--l * B + PAGE_BITS) & ((1UL << B) - 1))) {
c000dca7:	4f                   	dec    %edi
c000dca8:	8b 54 24 28          	mov    0x28(%esp),%edx
c000dcac:	8d 0c ff             	lea    (%edi,%edi,8),%ecx
c000dcaf:	8b 44 24 24          	mov    0x24(%esp),%eax
c000dcb3:	83 c1 0c             	add    $0xc,%ecx
c000dcb6:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
c000dcbc:	0f ad d0             	shrd   %cl,%edx,%eax
c000dcbf:	d3 ea                	shr    %cl,%edx
c000dcc1:	f6 c1 20             	test   $0x20,%cl
c000dcc4:	0f 45 c2             	cmovne %edx,%eax
c000dcc7:	25 ff 01 00 00       	and    $0x1ff,%eax
c000dccc:	8d b4 c3 00 00 c0 bf 	lea    -0x40400000(%ebx,%eax,8),%esi
c000dcd3:	e9 4b ff ff ff       	jmp    c000dc23 <_ZN3PteI3EptyLj4ELj9ELb0EE4walkER5Quotaymb+0x19>
c000dcd8:	89 f0                	mov    %esi,%eax
c000dcda:	eb 02                	jmp    c000dcde <_ZN3PteI3EptyLj4ELj9ELb0EE4walkER5Quotaymb+0xd4>
            return e;

        if (!e->val) {

            if (!a)
                return nullptr;
c000dcdc:	31 c0                	xor    %eax,%eax

            if (!e->set (0, Buddy::ptr_to_phys (p = new (quota) P) | (l == L ? 0 : P::PTE_N)))
                Pte::destroy(p, quota);
        }
    }
}
c000dcde:	83 c4 10             	add    $0x10,%esp
c000dce1:	5b                   	pop    %ebx
c000dce2:	5e                   	pop    %esi
c000dce3:	5f                   	pop    %edi
c000dce4:	5d                   	pop    %ebp
c000dce5:	c3                   	ret    

c000dce6 <_ZN3PteI3EptyLj4ELj9ELb0EE6lookupEyRmS2_>:

template <typename P, typename E, unsigned L, unsigned B, bool F>
size_t Pte<P,E,L,B,F>::lookup (E v, Paddr &p, mword &a)
c000dce6:	55                   	push   %ebp
{
    unsigned long l = L;
c000dce7:	bd 04 00 00 00       	mov    $0x4,%ebp
        }
    }
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
size_t Pte<P,E,L,B,F>::lookup (E v, Paddr &p, mword &a)
c000dcec:	57                   	push   %edi
c000dced:	89 cf                	mov    %ecx,%edi
c000dcef:	56                   	push   %esi
c000dcf0:	53                   	push   %ebx
c000dcf1:	56                   	push   %esi
c000dcf2:	89 d6                	mov    %edx,%esi
{
    unsigned long l = L;

    for (P *e = static_cast<P *>(this);; e = static_cast<P *>(Buddy::phys_to_ptr (e->addr())) + (v >> (--l * B + PAGE_BITS) & ((1UL << B) - 1))) {

        if (EXPECT_FALSE (!e->val))
c000dcf4:	8b 18                	mov    (%eax),%ebx
c000dcf6:	89 da                	mov    %ebx,%edx
c000dcf8:	0b 50 04             	or     0x4(%eax),%edx
c000dcfb:	74 3e                	je     c000dd3b <_ZN3PteI3EptyLj4ELj9ELb0EE6lookupEyRmS2_+0x55>
            return 0;

        if (EXPECT_FALSE (l && !e->super()))
c000dcfd:	85 ed                	test   %ebp,%ebp
c000dcff:	74 3e                	je     c000dd3f <_ZN3PteI3EptyLj4ELj9ELb0EE6lookupEyRmS2_+0x59>
c000dd01:	f6 c3 80             	test   $0x80,%bl
c000dd04:	75 39                	jne    c000dd3f <_ZN3PteI3EptyLj4ELj9ELb0EE6lookupEyRmS2_+0x59>
template <typename P, typename E, unsigned L, unsigned B, bool F>
size_t Pte<P,E,L,B,F>::lookup (E v, Paddr &p, mword &a)
{
    unsigned long l = L;

    for (P *e = static_cast<P *>(this);; e = static_cast<P *>(Buddy::phys_to_ptr (e->addr())) + (v >> (--l * B + PAGE_BITS) & ((1UL << B) - 1))) {
c000dd06:	4d                   	dec    %ebp
c000dd07:	89 d8                	mov    %ebx,%eax
c000dd09:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c000dd0e:	89 fa                	mov    %edi,%edx
c000dd10:	8d 4c ed 00          	lea    0x0(%ebp,%ebp,8),%ecx
c000dd14:	83 c1 0c             	add    $0xc,%ecx
c000dd17:	89 04 24             	mov    %eax,(%esp)
c000dd1a:	89 f0                	mov    %esi,%eax
c000dd1c:	0f ad f8             	shrd   %cl,%edi,%eax
c000dd1f:	d3 ea                	shr    %cl,%edx
c000dd21:	f6 c1 20             	test   $0x20,%cl
c000dd24:	0f 45 c2             	cmovne %edx,%eax
c000dd27:	89 c1                	mov    %eax,%ecx
c000dd29:	8b 04 24             	mov    (%esp),%eax
c000dd2c:	81 e1 ff 01 00 00    	and    $0x1ff,%ecx
c000dd32:	8d 84 c8 00 00 c0 bf 	lea    -0x40400000(%eax,%ecx,8),%eax
c000dd39:	eb b9                	jmp    c000dcf4 <_ZN3PteI3EptyLj4ELj9ELb0EE6lookupEyRmS2_+0xe>

        if (EXPECT_FALSE (!e->val))
            return 0;
c000dd3b:	31 c0                	xor    %eax,%eax
c000dd3d:	eb 3d                	jmp    c000dd7c <_ZN3PteI3EptyLj4ELj9ELb0EE6lookupEyRmS2_+0x96>

        ALWAYS_INLINE
        static inline mword hw_attr (mword a, mword t) { return a ? t << 3 | a | EPT_I | EPT_R : 0; }

        ALWAYS_INLINE
        inline mword order() const { return PAGE_BITS + (static_cast<mword>(val) >> 8 & 0xf); }
c000dd3f:	89 d9                	mov    %ebx,%ecx

        if (EXPECT_FALSE (l && !e->super()))
            continue;

        size_t s = 1UL << (l * B + e->order());
c000dd41:	bf 01 00 00 00       	mov    $0x1,%edi
c000dd46:	c1 e9 08             	shr    $0x8,%ecx
c000dd49:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
c000dd4f:	8d 54 ed 00          	lea    0x0(%ebp,%ebp,8),%edx
c000dd53:	83 e1 0f             	and    $0xf,%ecx
c000dd56:	8d 4c 0a 0c          	lea    0xc(%edx,%ecx,1),%ecx
c000dd5a:	89 fa                	mov    %edi,%edx
c000dd5c:	d3 e2                	shl    %cl,%edx
c000dd5e:	89 d1                	mov    %edx,%ecx

        p = static_cast<Paddr>(e->addr() | (v & (s - 1)));
c000dd60:	8d 52 ff             	lea    -0x1(%edx),%edx
c000dd63:	21 d6                	and    %edx,%esi

        a = e->attr();
c000dd65:	8b 54 24 1c          	mov    0x1c(%esp),%edx
        if (EXPECT_FALSE (l && !e->super()))
            continue;

        size_t s = 1UL << (l * B + e->order());

        p = static_cast<Paddr>(e->addr() | (v & (s - 1)));
c000dd69:	09 de                	or     %ebx,%esi
c000dd6b:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c000dd6f:	89 33                	mov    %esi,(%ebx)

        ALWAYS_INLINE
        inline bool super() const { return val & P::PTE_S; }

        ALWAYS_INLINE
        inline mword attr() const { return static_cast<mword>(val) & PAGE_MASK; }
c000dd71:	8b 00                	mov    (%eax),%eax
c000dd73:	25 ff 0f 00 00       	and    $0xfff,%eax

        a = e->attr();
c000dd78:	89 02                	mov    %eax,(%edx)

        return s;
c000dd7a:	89 c8                	mov    %ecx,%eax
    }
}
c000dd7c:	5a                   	pop    %edx
c000dd7d:	5b                   	pop    %ebx
c000dd7e:	5e                   	pop    %esi
c000dd7f:	5f                   	pop    %edi
c000dd80:	5d                   	pop    %ebp
c000dd81:	c3                   	ret    

c000dd82 <_ZN3PteI3EptyLj4ELj9ELb0EE6updateER5QuotaymymNS1_4TypeE>:

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P,E,L,B,F>::update (Quota &quota, E v, mword o, E p, mword a, Type t)
c000dd82:	55                   	push   %ebp
c000dd83:	57                   	push   %edi
c000dd84:	89 c7                	mov    %eax,%edi
c000dd86:	56                   	push   %esi
c000dd87:	53                   	push   %ebx
c000dd88:	83 ec 18             	sub    $0x18,%esp
c000dd8b:	8b 74 24 3c          	mov    0x3c(%esp),%esi
c000dd8f:	8b 44 24 34          	mov    0x34(%esp),%eax
c000dd93:	89 54 24 04          	mov    %edx,0x4(%esp)
{
    unsigned long l = o / B, n = 1UL << o % B, s;
c000dd97:	31 d2                	xor    %edx,%edx
        return s;
    }
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P,E,L,B,F>::update (Quota &quota, E v, mword o, E p, mword a, Type t)
c000dd99:	8b 5c 24 38          	mov    0x38(%esp),%ebx
c000dd9d:	8b 6c 24 40          	mov    0x40(%esp),%ebp
c000dda1:	89 74 24 14          	mov    %esi,0x14(%esp)
{
    unsigned long l = o / B, n = 1UL << o % B, s;
c000dda5:	be 09 00 00 00       	mov    $0x9,%esi
c000ddaa:	f7 f6                	div    %esi
c000ddac:	66 be 01 00          	mov    $0x1,%si
c000ddb0:	89 54 24 08          	mov    %edx,0x8(%esp)
c000ddb4:	8a 4c 24 08          	mov    0x8(%esp),%cl
c000ddb8:	89 04 24             	mov    %eax,(%esp)
c000ddbb:	89 f0                	mov    %esi,%eax
c000ddbd:	d3 e0                	shl    %cl,%eax
c000ddbf:	89 44 24 0c          	mov    %eax,0xc(%esp)

    P *e = walk (quota, v, l, t == TYPE_UP);
c000ddc3:	31 c0                	xor    %eax,%eax
c000ddc5:	83 7c 24 44 00       	cmpl   $0x0,0x44(%esp)
c000ddca:	0f 94 c0             	sete   %al
c000ddcd:	50                   	push   %eax
c000ddce:	89 f8                	mov    %edi,%eax
c000ddd0:	ff 74 24 04          	pushl  0x4(%esp)
c000ddd4:	ff 74 24 38          	pushl  0x38(%esp)
c000ddd8:	ff 74 24 38          	pushl  0x38(%esp)
c000dddc:	8b 54 24 14          	mov    0x14(%esp),%edx
c000dde0:	e8 25 fe ff ff       	call   c000dc0a <_ZN3PteI3EptyLj4ELj9ELb0EE4walkER5Quotaymb>

    if (!e)
c000dde5:	83 c4 10             	add    $0x10,%esp
c000dde8:	85 c0                	test   %eax,%eax
c000ddea:	0f 84 a1 00 00 00    	je     c000de91 <_ZN3PteI3EptyLj4ELj9ELb0EE6updateER5QuotaymymNS1_4TypeE+0x10f>
        return false;

    if (a) {
c000ddf0:	85 ed                	test   %ebp,%ebp
c000ddf2:	74 2c                	je     c000de20 <_ZN3PteI3EptyLj4ELj9ELb0EE6updateER5QuotaymymNS1_4TypeE+0x9e>

        ALWAYS_INLINE
        static inline mword order (mword o) { return o << 8; }
c000ddf4:	8b 4c 24 08          	mov    0x8(%esp),%ecx
c000ddf8:	c1 e1 08             	shl    $0x8,%ecx
        p |= P::order (o % B) | (l ? P::PTE_S : 0) | a;
c000ddfb:	83 3c 24 01          	cmpl   $0x1,(%esp)
c000ddff:	19 d2                	sbb    %edx,%edx
c000de01:	09 cd                	or     %ecx,%ebp
        s = 1UL << (l * B + PAGE_BITS);
c000de03:	6b 0c 24 09          	imul   $0x9,(%esp),%ecx

    if (!e)
        return false;

    if (a) {
        p |= P::order (o % B) | (l ? P::PTE_S : 0) | a;
c000de07:	f7 d2                	not    %edx
c000de09:	81 e2 80 00 00 00    	and    $0x80,%edx
c000de0f:	09 ea                	or     %ebp,%edx
c000de11:	8b 6c 24 14          	mov    0x14(%esp),%ebp
c000de15:	09 da                	or     %ebx,%edx
        s = 1UL << (l * B + PAGE_BITS);
c000de17:	83 c1 0c             	add    $0xc,%ecx

    if (!e)
        return false;

    if (a) {
        p |= P::order (o % B) | (l ? P::PTE_S : 0) | a;
c000de1a:	89 d7                	mov    %edx,%edi
        s = 1UL << (l * B + PAGE_BITS);
c000de1c:	d3 e6                	shl    %cl,%esi
c000de1e:	eb 06                	jmp    c000de26 <_ZN3PteI3EptyLj4ELj9ELb0EE6updateER5QuotaymymNS1_4TypeE+0xa4>
    } else
        p = s = 0;
c000de20:	31 f6                	xor    %esi,%esi
c000de22:	31 ff                	xor    %edi,%edi
c000de24:	31 ed                	xor    %ebp,%ebp
c000de26:	89 c3                	mov    %eax,%ebx
c000de28:	8b 44 24 0c          	mov    0xc(%esp),%eax

    bool flush_tlb = false;

    for (unsigned long i = 0; i < n; e[i].val = p, i++, p += s) {
c000de2c:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c000de33:	00 
c000de34:	89 74 24 0c          	mov    %esi,0xc(%esp)
c000de38:	8d 04 c3             	lea    (%ebx,%eax,8),%eax
c000de3b:	89 44 24 08          	mov    %eax,0x8(%esp)
        p |= P::order (o % B) | (l ? P::PTE_S : 0) | a;
        s = 1UL << (l * B + PAGE_BITS);
    } else
        p = s = 0;

    bool flush_tlb = false;
c000de3f:	31 c0                	xor    %eax,%eax

    for (unsigned long i = 0; i < n; e[i].val = p, i++, p += s) {

        if (l && e[i].val != p)
c000de41:	83 3c 24 00          	cmpl   $0x0,(%esp)
c000de45:	74 0b                	je     c000de52 <_ZN3PteI3EptyLj4ELj9ELb0EE6updateER5QuotaymymNS1_4TypeE+0xd0>
c000de47:	39 6b 04             	cmp    %ebp,0x4(%ebx)
c000de4a:	75 04                	jne    c000de50 <_ZN3PteI3EptyLj4ELj9ELb0EE6updateER5QuotaymymNS1_4TypeE+0xce>
c000de4c:	39 3b                	cmp    %edi,(%ebx)
c000de4e:	74 02                	je     c000de52 <_ZN3PteI3EptyLj4ELj9ELb0EE6updateER5QuotaymymNS1_4TypeE+0xd0>
            flush_tlb = true;
c000de50:	b0 01                	mov    $0x1,%al

        if (!e[i].val)
c000de52:	8b 33                	mov    (%ebx),%esi
c000de54:	89 f1                	mov    %esi,%ecx
c000de56:	0b 4b 04             	or     0x4(%ebx),%ecx
c000de59:	0f 94 c2             	sete   %dl
            continue;

        if (t == TYPE_DF)
c000de5c:	83 7c 24 44 02       	cmpl   $0x2,0x44(%esp)
c000de61:	0f 94 c1             	sete   %cl
c000de64:	08 ca                	or     %cl,%dl
            continue;

        if (l && !e[i].super()) {
c000de66:	83 3c 24 00          	cmpl   $0x0,(%esp)
c000de6a:	0f 95 c1             	setne  %cl
c000de6d:	38 ca                	cmp    %cl,%dl
c000de6f:	73 08                	jae    c000de79 <_ZN3PteI3EptyLj4ELj9ELb0EE6updateER5QuotaymymNS1_4TypeE+0xf7>
c000de71:	f7 c6 80 00 00 00    	test   $0x80,%esi
c000de77:	74 1c                	je     c000de95 <_ZN3PteI3EptyLj4ELj9ELb0EE6updateER5QuotaymymNS1_4TypeE+0x113>
    } else
        p = s = 0;

    bool flush_tlb = false;

    for (unsigned long i = 0; i < n; e[i].val = p, i++, p += s) {
c000de79:	89 3b                	mov    %edi,(%ebx)
c000de7b:	03 7c 24 0c          	add    0xc(%esp),%edi
c000de7f:	89 6b 04             	mov    %ebp,0x4(%ebx)
c000de82:	13 6c 24 10          	adc    0x10(%esp),%ebp
c000de86:	83 c3 08             	add    $0x8,%ebx
c000de89:	3b 5c 24 08          	cmp    0x8(%esp),%ebx
c000de8d:	75 b2                	jne    c000de41 <_ZN3PteI3EptyLj4ELj9ELb0EE6updateER5QuotaymymNS1_4TypeE+0xbf>
c000de8f:	eb 22                	jmp    c000deb3 <_ZN3PteI3EptyLj4ELj9ELb0EE6updateER5QuotaymymNS1_4TypeE+0x131>
    unsigned long l = o / B, n = 1UL << o % B, s;

    P *e = walk (quota, v, l, t == TYPE_UP);

    if (!e)
        return false;
c000de91:	31 c0                	xor    %eax,%eax
c000de93:	eb 1e                	jmp    c000deb3 <_ZN3PteI3EptyLj4ELj9ELb0EE6updateER5QuotaymymNS1_4TypeE+0x131>

            return p;
        }

        ALWAYS_INLINE
        static inline void destroy(Pte *obj, Quota &quota) { obj->~Pte(); Buddy::allocator.free (reinterpret_cast<mword>(obj), quota); }
c000de95:	8b 4c 24 04          	mov    0x4(%esp),%ecx

        ALWAYS_INLINE
        inline mword attr() const { return static_cast<mword>(val) & PAGE_MASK; }

        ALWAYS_INLINE
        inline Paddr addr() const { return static_cast<Paddr>(val) & ~((1UL << order()) - 1); }
c000de99:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi

            return p;
        }

        ALWAYS_INLINE
        static inline void destroy(Pte *obj, Quota &quota) { obj->~Pte(); Buddy::allocator.free (reinterpret_cast<mword>(obj), quota); }
c000de9f:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
        }

        ALWAYS_INLINE
        inline mword phys_to_virt (mword phys)
        {
            return phys + reinterpret_cast<mword>(&OFFSET);
c000dea4:	8d 96 00 00 c0 bf    	lea    -0x40400000(%esi),%edx
c000deaa:	e8 b9 32 ff ff       	call   c0001168 <_ZN5Buddy4freeEmR5Quota>
        if (t == TYPE_DF)
            continue;

        if (l && !e[i].super()) {
            Pte::destroy(static_cast<P *>(Buddy::phys_to_ptr (e[i].addr())), quota);
            flush_tlb = true;
c000deaf:	b0 01                	mov    $0x1,%al
c000deb1:	eb c6                	jmp    c000de79 <_ZN3PteI3EptyLj4ELj9ELb0EE6updateER5QuotaymymNS1_4TypeE+0xf7>

    if (F)
        flush (e, n * sizeof (E));

    return flush_tlb;
}
c000deb3:	83 c4 18             	add    $0x18,%esp
c000deb6:	5b                   	pop    %ebx
c000deb7:	5e                   	pop    %esi
c000deb8:	5f                   	pop    %edi
c000deb9:	5d                   	pop    %ebp
c000deba:	c3                   	ret    
c000debb:	90                   	nop

c000debc <_ZN3PteI3HptmLj2ELj10ELb0EE4walkER5Quotammb>:
mword Dpt::ord = ~0UL;
mword Ept::ord = ~0UL;
mword Hpt::ord = ~0UL;

template <typename P, typename E, unsigned L, unsigned B, bool F>
P *Pte<P,E,L,B,F>::walk (Quota &quota, E v, unsigned long n, bool a)
c000debc:	55                   	push   %ebp
c000debd:	57                   	push   %edi
{
    unsigned long l = L;
c000debe:	bf 02 00 00 00       	mov    $0x2,%edi
mword Dpt::ord = ~0UL;
mword Ept::ord = ~0UL;
mword Hpt::ord = ~0UL;

template <typename P, typename E, unsigned L, unsigned B, bool F>
P *Pte<P,E,L,B,F>::walk (Quota &quota, E v, unsigned long n, bool a)
c000dec3:	56                   	push   %esi
{
    unsigned long l = L;

    for (P *p, *e = static_cast<P *>(this);; e = static_cast<P *>(Buddy::phys_to_ptr (e->addr())) + (v >> (--l * B + PAGE_BITS) & ((1UL << B) - 1))) {
c000dec4:	89 c6                	mov    %eax,%esi
mword Dpt::ord = ~0UL;
mword Ept::ord = ~0UL;
mword Hpt::ord = ~0UL;

template <typename P, typename E, unsigned L, unsigned B, bool F>
P *Pte<P,E,L,B,F>::walk (Quota &quota, E v, unsigned long n, bool a)
c000dec6:	53                   	push   %ebx
c000dec7:	83 ec 08             	sub    $0x8,%esp
c000deca:	8a 5c 24 20          	mov    0x20(%esp),%bl
c000dece:	89 14 24             	mov    %edx,(%esp)
c000ded1:	89 4c 24 04          	mov    %ecx,0x4(%esp)
{
    unsigned long l = L;

    for (P *p, *e = static_cast<P *>(this);; e = static_cast<P *>(Buddy::phys_to_ptr (e->addr())) + (v >> (--l * B + PAGE_BITS) & ((1UL << B) - 1))) {

        if (l == n)
c000ded5:	3b 7c 24 1c          	cmp    0x1c(%esp),%edi
c000ded9:	74 6f                	je     c000df4a <_ZN3PteI3HptmLj2ELj10ELb0EE4walkER5Quotammb+0x8e>
            return e;

        if (!e->val) {
c000dedb:	8b 2e                	mov    (%esi),%ebp
c000dedd:	85 ed                	test   %ebp,%ebp
c000dedf:	75 46                	jne    c000df27 <_ZN3PteI3HptmLj2ELj10ELb0EE4walkER5Quotammb+0x6b>

            if (!a)
c000dee1:	84 db                	test   %bl,%bl
c000dee3:	74 69                	je     c000df4e <_ZN3PteI3HptmLj2ELj10ELb0EE4walkER5Quotammb+0x92>
        }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota)
        {
            void *p = Buddy::allocator.alloc (0, quota, Buddy::FILL_0);
c000dee5:	6a 01                	push   $0x1
c000dee7:	31 d2                	xor    %edx,%edx
c000dee9:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c000deed:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c000def2:	e8 15 35 ff ff       	call   c000140c <_ZN5Buddy5allocEtR5QuotaNS_4FillE>

        void free_up (Quota &quota, unsigned l, P *, mword, bool (*) (Paddr, mword, unsigned), bool (*) (unsigned, mword));

    public:

        Pte() : val(0) {}
c000def7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota)
        {
            void *p = Buddy::allocator.alloc (0, quota, Buddy::FILL_0);
c000defd:	89 c2                	mov    %eax,%edx
        }

        ALWAYS_INLINE
        inline mword virt_to_phys (mword virt)
        {
            return virt - reinterpret_cast<mword>(&OFFSET);
c000deff:	2d 00 00 c0 bf       	sub    $0xbfc00000,%eax
                return nullptr;

            if (!e->set (0, Buddy::ptr_to_phys (p = new (quota) P) | (l == L ? 0 : P::PTE_N)))
c000df04:	59                   	pop    %ecx
c000df05:	83 ff 02             	cmp    $0x2,%edi
c000df08:	b9 27 00 00 00       	mov    $0x27,%ecx
c000df0d:	0f 45 e9             	cmovne %ecx,%ebp
c000df10:	09 c5                	or     %eax,%ebp
c000df12:	31 c0                	xor    %eax,%eax
c000df14:	f0 0f b1 2e          	lock cmpxchg %ebp,(%esi)
c000df18:	74 0d                	je     c000df27 <_ZN3PteI3HptmLj2ELj10ELb0EE4walkER5Quotammb+0x6b>

            return p;
        }

        ALWAYS_INLINE
        static inline void destroy(Pte *obj, Quota &quota) { obj->~Pte(); Buddy::allocator.free (reinterpret_cast<mword>(obj), quota); }
c000df1a:	8b 0c 24             	mov    (%esp),%ecx
c000df1d:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c000df22:	e8 41 32 ff ff       	call   c0001168 <_ZN5Buddy4freeEmR5Quota>
template <typename P, typename E, unsigned L, unsigned B, bool F>
P *Pte<P,E,L,B,F>::walk (Quota &quota, E v, unsigned long n, bool a)
{
    unsigned long l = L;

    for (P *p, *e = static_cast<P *>(this);; e = static_cast<P *>(Buddy::phys_to_ptr (e->addr())) + (v >> (--l * B + PAGE_BITS) & ((1UL << B) - 1))) {
c000df27:	4f                   	dec    %edi
c000df28:	8b 54 24 04          	mov    0x4(%esp),%edx
c000df2c:	6b cf 0a             	imul   $0xa,%edi,%ecx
            PTE_S   = HPT_S,
            PTE_N   = HPT_A | HPT_U | HPT_W | HPT_P,
        };

        ALWAYS_INLINE
        inline Paddr addr() const { return static_cast<Paddr>(val) & ~PAGE_MASK; }
c000df2f:	8b 06                	mov    (%esi),%eax
c000df31:	83 c1 0c             	add    $0xc,%ecx
c000df34:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c000df39:	d3 ea                	shr    %cl,%edx
c000df3b:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
c000df41:	8d b4 90 00 00 c0 bf 	lea    -0x40400000(%eax,%edx,4),%esi
c000df48:	eb 8b                	jmp    c000ded5 <_ZN3PteI3HptmLj2ELj10ELb0EE4walkER5Quotammb+0x19>
c000df4a:	89 f0                	mov    %esi,%eax
c000df4c:	eb 02                	jmp    c000df50 <_ZN3PteI3HptmLj2ELj10ELb0EE4walkER5Quotammb+0x94>
            return e;

        if (!e->val) {

            if (!a)
                return nullptr;
c000df4e:	31 c0                	xor    %eax,%eax

            if (!e->set (0, Buddy::ptr_to_phys (p = new (quota) P) | (l == L ? 0 : P::PTE_N)))
                Pte::destroy(p, quota);
        }
    }
}
c000df50:	83 c4 08             	add    $0x8,%esp
c000df53:	5b                   	pop    %ebx
c000df54:	5e                   	pop    %esi
c000df55:	5f                   	pop    %edi
c000df56:	5d                   	pop    %ebp
c000df57:	c3                   	ret    

c000df58 <_ZN3PteI3HptmLj2ELj10ELb0EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE>:

    Pte::destroy (e, quota);
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
void Pte<P,E,L,B,F>::free_up (Quota &quota, unsigned l, P * e, mword v, bool (*d)(Paddr, mword, unsigned), bool (*il) (unsigned, mword))
c000df58:	55                   	push   %ebp
c000df59:	57                   	push   %edi
c000df5a:	56                   	push   %esi
c000df5b:	53                   	push   %ebx
c000df5c:	83 ec 10             	sub    $0x10,%esp
{
    if (!e)
c000df5f:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c000df64:	0f 84 ba 00 00 00    	je     c000e024 <_ZN3PteI3HptmLj2ELj10ELb0EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0xcc>
    for (unsigned long i = 0; i < (1 << B); i++) {
        if (!e[i].val || e[i].super())
            continue;

        P *p = static_cast<P *>(Buddy::phys_to_ptr (e[i].addr()));
        mword virt = v + (i << (l * B + PAGE_BITS));
c000df6a:	6b c1 0a             	imul   $0xa,%ecx,%eax
c000df6d:	89 ce                	mov    %ecx,%esi
c000df6f:	89 14 24             	mov    %edx,(%esp)
c000df72:	31 ff                	xor    %edi,%edi
c000df74:	83 c0 0c             	add    $0xc,%eax
c000df77:	89 44 24 04          	mov    %eax,0x4(%esp)

        if (il ? il(l, virt) : l > 1)
            p->free_up(quota, l - 1, p, virt, d, il);
c000df7b:	8d 41 ff             	lea    -0x1(%ecx),%eax
c000df7e:	89 44 24 0c          	mov    %eax,0xc(%esp)
{
    if (!e)
        return;

    for (unsigned long i = 0; i < (1 << B); i++) {
        if (!e[i].val || e[i].super())
c000df82:	8b 44 24 24          	mov    0x24(%esp),%eax
c000df86:	8b 1c b8             	mov    (%eax,%edi,4),%ebx
c000df89:	85 db                	test   %ebx,%ebx
c000df8b:	74 6f                	je     c000dffc <_ZN3PteI3HptmLj2ELj10ELb0EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0xa4>
c000df8d:	f6 c3 80             	test   $0x80,%bl
c000df90:	75 6a                	jne    c000dffc <_ZN3PteI3HptmLj2ELj10ELb0EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0xa4>
            continue;

        P *p = static_cast<P *>(Buddy::phys_to_ptr (e[i].addr()));
        mword virt = v + (i << (l * B + PAGE_BITS));
c000df92:	8a 4c 24 04          	mov    0x4(%esp),%cl
c000df96:	89 fd                	mov    %edi,%ebp
c000df98:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
        }

        ALWAYS_INLINE
        inline mword phys_to_virt (mword phys)
        {
            return phys + reinterpret_cast<mword>(&OFFSET);
c000df9e:	81 c3 00 00 c0 bf    	add    $0xbfc00000,%ebx
c000dfa4:	d3 e5                	shl    %cl,%ebp
c000dfa6:	03 6c 24 28          	add    0x28(%esp),%ebp

        if (il ? il(l, virt) : l > 1)
c000dfaa:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c000dfaf:	74 5a                	je     c000e00b <_ZN3PteI3HptmLj2ELj10ELb0EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0xb3>
c000dfb1:	89 ea                	mov    %ebp,%edx
c000dfb3:	89 f0                	mov    %esi,%eax
c000dfb5:	ff 54 24 30          	call   *0x30(%esp)
c000dfb9:	84 c0                	test   %al,%al
c000dfbb:	74 1c                	je     c000dfd9 <_ZN3PteI3HptmLj2ELj10ELb0EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0x81>
            p->free_up(quota, l - 1, p, virt, d, il);
c000dfbd:	ff 74 24 30          	pushl  0x30(%esp)
c000dfc1:	89 d8                	mov    %ebx,%eax
c000dfc3:	ff 74 24 30          	pushl  0x30(%esp)
c000dfc7:	55                   	push   %ebp
c000dfc8:	53                   	push   %ebx
c000dfc9:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
c000dfcd:	8b 54 24 10          	mov    0x10(%esp),%edx
c000dfd1:	e8 82 ff ff ff       	call   c000df58 <_ZN3PteI3HptmLj2ELj10ELb0EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE>
c000dfd6:	83 c4 10             	add    $0x10,%esp

        if (!d || d(e[i].addr(), virt, l))
c000dfd9:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c000dfde:	74 33                	je     c000e013 <_ZN3PteI3HptmLj2ELj10ELb0EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0xbb>
c000dfe0:	8b 44 24 24          	mov    0x24(%esp),%eax
c000dfe4:	89 f1                	mov    %esi,%ecx
c000dfe6:	89 ea                	mov    %ebp,%edx
c000dfe8:	8b 04 b8             	mov    (%eax,%edi,4),%eax
c000dfeb:	89 44 24 08          	mov    %eax,0x8(%esp)
c000dfef:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c000dff4:	ff 54 24 2c          	call   *0x2c(%esp)
c000dff8:	84 c0                	test   %al,%al
c000dffa:	75 17                	jne    c000e013 <_ZN3PteI3HptmLj2ELj10ELb0EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0xbb>
void Pte<P,E,L,B,F>::free_up (Quota &quota, unsigned l, P * e, mword v, bool (*d)(Paddr, mword, unsigned), bool (*il) (unsigned, mword))
{
    if (!e)
        return;

    for (unsigned long i = 0; i < (1 << B); i++) {
c000dffc:	47                   	inc    %edi
c000dffd:	81 ff 00 04 00 00    	cmp    $0x400,%edi
c000e003:	0f 85 79 ff ff ff    	jne    c000df82 <_ZN3PteI3HptmLj2ELj10ELb0EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0x2a>
c000e009:	eb 19                	jmp    c000e024 <_ZN3PteI3HptmLj2ELj10ELb0EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0xcc>
            continue;

        P *p = static_cast<P *>(Buddy::phys_to_ptr (e[i].addr()));
        mword virt = v + (i << (l * B + PAGE_BITS));

        if (il ? il(l, virt) : l > 1)
c000e00b:	83 fe 01             	cmp    $0x1,%esi
c000e00e:	0f 97 c0             	seta   %al
c000e011:	eb a6                	jmp    c000dfb9 <_ZN3PteI3HptmLj2ELj10ELb0EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0x61>
c000e013:	8b 0c 24             	mov    (%esp),%ecx
c000e016:	89 da                	mov    %ebx,%edx
c000e018:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c000e01d:	e8 46 31 ff ff       	call   c0001168 <_ZN5Buddy4freeEmR5Quota>
c000e022:	eb d8                	jmp    c000dffc <_ZN3PteI3HptmLj2ELj10ELb0EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0xa4>
            p->free_up(quota, l - 1, p, virt, d, il);

        if (!d || d(e[i].addr(), virt, l))
            Pte::destroy(p, quota);
    }
}
c000e024:	83 c4 10             	add    $0x10,%esp
c000e027:	5b                   	pop    %ebx
c000e028:	5e                   	pop    %esi
c000e029:	5f                   	pop    %edi
c000e02a:	5d                   	pop    %ebp
c000e02b:	c3                   	ret    

c000e02c <_ZN3PteI3HptmLj2ELj10ELb0EE6lookupEmRmS2_>:
        }
    }
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
size_t Pte<P,E,L,B,F>::lookup (E v, Paddr &p, mword &a)
c000e02c:	57                   	push   %edi
c000e02d:	56                   	push   %esi
c000e02e:	53                   	push   %ebx
{
    unsigned long l = L;

    for (P *e = static_cast<P *>(this);; e = static_cast<P *>(Buddy::phys_to_ptr (e->addr())) + (v >> (--l * B + PAGE_BITS) & ((1UL << B) - 1))) {

        if (EXPECT_FALSE (!e->val))
c000e02f:	8b 18                	mov    (%eax),%ebx
c000e031:	85 db                	test   %ebx,%ebx
c000e033:	74 59                	je     c000e08e <_ZN3PteI3HptmLj2ELj10ELb0EE6lookupEmRmS2_+0x62>
            return 0;

        if (EXPECT_FALSE (l && !e->super()))
c000e035:	f6 c3 80             	test   $0x80,%bl
c000e038:	89 cf                	mov    %ecx,%edi
c000e03a:	75 42                	jne    c000e07e <_ZN3PteI3HptmLj2ELj10ELb0EE6lookupEmRmS2_+0x52>
template <typename P, typename E, unsigned L, unsigned B, bool F>
size_t Pte<P,E,L,B,F>::lookup (E v, Paddr &p, mword &a)
{
    unsigned long l = L;

    for (P *e = static_cast<P *>(this);; e = static_cast<P *>(Buddy::phys_to_ptr (e->addr())) + (v >> (--l * B + PAGE_BITS) & ((1UL << B) - 1))) {
c000e03c:	89 d0                	mov    %edx,%eax
c000e03e:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
c000e044:	c1 e8 16             	shr    $0x16,%eax
c000e047:	8d b4 83 00 00 c0 bf 	lea    -0x40400000(%ebx,%eax,4),%esi

        if (EXPECT_FALSE (!e->val))
            return 0;
c000e04e:	31 c0                	xor    %eax,%eax
{
    unsigned long l = L;

    for (P *e = static_cast<P *>(this);; e = static_cast<P *>(Buddy::phys_to_ptr (e->addr())) + (v >> (--l * B + PAGE_BITS) & ((1UL << B) - 1))) {

        if (EXPECT_FALSE (!e->val))
c000e050:	8b 1e                	mov    (%esi),%ebx
c000e052:	85 db                	test   %ebx,%ebx
c000e054:	74 66                	je     c000e0bc <_ZN3PteI3HptmLj2ELj10ELb0EE6lookupEmRmS2_+0x90>
            return 0;

        if (EXPECT_FALSE (l && !e->super()))
c000e056:	f6 c3 80             	test   $0x80,%bl
c000e059:	75 2c                	jne    c000e087 <_ZN3PteI3HptmLj2ELj10ELb0EE6lookupEmRmS2_+0x5b>
template <typename P, typename E, unsigned L, unsigned B, bool F>
size_t Pte<P,E,L,B,F>::lookup (E v, Paddr &p, mword &a)
{
    unsigned long l = L;

    for (P *e = static_cast<P *>(this);; e = static_cast<P *>(Buddy::phys_to_ptr (e->addr())) + (v >> (--l * B + PAGE_BITS) & ((1UL << B) - 1))) {
c000e05b:	89 d0                	mov    %edx,%eax
c000e05d:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
c000e063:	c1 e8 0a             	shr    $0xa,%eax
c000e066:	31 c9                	xor    %ecx,%ecx
c000e068:	25 fc 0f 00 00       	and    $0xffc,%eax
c000e06d:	8d b4 03 00 00 c0 bf 	lea    -0x40400000(%ebx,%eax,1),%esi

        if (EXPECT_FALSE (!e->val))
            return 0;
c000e074:	31 c0                	xor    %eax,%eax
{
    unsigned long l = L;

    for (P *e = static_cast<P *>(this);; e = static_cast<P *>(Buddy::phys_to_ptr (e->addr())) + (v >> (--l * B + PAGE_BITS) & ((1UL << B) - 1))) {

        if (EXPECT_FALSE (!e->val))
c000e076:	8b 1e                	mov    (%esi),%ebx
c000e078:	85 db                	test   %ebx,%ebx
c000e07a:	75 16                	jne    c000e092 <_ZN3PteI3HptmLj2ELj10ELb0EE6lookupEmRmS2_+0x66>
c000e07c:	eb 3e                	jmp    c000e0bc <_ZN3PteI3HptmLj2ELj10ELb0EE6lookupEmRmS2_+0x90>
            return 0;

        if (EXPECT_FALSE (l && !e->super()))
c000e07e:	89 c6                	mov    %eax,%esi
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
size_t Pte<P,E,L,B,F>::lookup (E v, Paddr &p, mword &a)
{
    unsigned long l = L;
c000e080:	b9 02 00 00 00       	mov    $0x2,%ecx
c000e085:	eb 0b                	jmp    c000e092 <_ZN3PteI3HptmLj2ELj10ELb0EE6lookupEmRmS2_+0x66>

    for (P *e = static_cast<P *>(this);; e = static_cast<P *>(Buddy::phys_to_ptr (e->addr())) + (v >> (--l * B + PAGE_BITS) & ((1UL << B) - 1))) {
c000e087:	b9 01 00 00 00       	mov    $0x1,%ecx
c000e08c:	eb 04                	jmp    c000e092 <_ZN3PteI3HptmLj2ELj10ELb0EE6lookupEmRmS2_+0x66>

        if (EXPECT_FALSE (!e->val))
            return 0;
c000e08e:	31 c0                	xor    %eax,%eax
c000e090:	eb 2a                	jmp    c000e0bc <_ZN3PteI3HptmLj2ELj10ELb0EE6lookupEmRmS2_+0x90>

        if (EXPECT_FALSE (l && !e->super()))
            continue;

        size_t s = 1UL << (l * B + e->order());
c000e092:	6b c9 0a             	imul   $0xa,%ecx,%ecx
c000e095:	b8 01 00 00 00       	mov    $0x1,%eax
c000e09a:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
c000e0a0:	83 c1 0c             	add    $0xc,%ecx
c000e0a3:	d3 e0                	shl    %cl,%eax

        p = static_cast<Paddr>(e->addr() | (v & (s - 1)));
c000e0a5:	8d 48 ff             	lea    -0x1(%eax),%ecx
c000e0a8:	21 ca                	and    %ecx,%edx

        a = e->attr();
c000e0aa:	8b 4c 24 10          	mov    0x10(%esp),%ecx
        if (EXPECT_FALSE (l && !e->super()))
            continue;

        size_t s = 1UL << (l * B + e->order());

        p = static_cast<Paddr>(e->addr() | (v & (s - 1)));
c000e0ae:	09 d3                	or     %edx,%ebx
c000e0b0:	89 1f                	mov    %ebx,(%edi)

        ALWAYS_INLINE
        inline bool super() const { return val & P::PTE_S; }

        ALWAYS_INLINE
        inline mword attr() const { return static_cast<mword>(val) & PAGE_MASK; }
c000e0b2:	8b 16                	mov    (%esi),%edx
c000e0b4:	81 e2 ff 0f 00 00    	and    $0xfff,%edx

        a = e->attr();
c000e0ba:	89 11                	mov    %edx,(%ecx)

        return s;
    }
}
c000e0bc:	5b                   	pop    %ebx
c000e0bd:	5e                   	pop    %esi
c000e0be:	5f                   	pop    %edi
c000e0bf:	c3                   	ret    

c000e0c0 <_ZN3PteI3HptmLj2ELj10ELb0EE6updateER5QuotammmmNS1_4TypeE>:

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P,E,L,B,F>::update (Quota &quota, E v, mword o, E p, mword a, Type t)
c000e0c0:	55                   	push   %ebp
c000e0c1:	57                   	push   %edi
c000e0c2:	89 cf                	mov    %ecx,%edi
c000e0c4:	56                   	push   %esi
{
    unsigned long l = o / B, n = 1UL << o % B, s;
c000e0c5:	b9 0a 00 00 00       	mov    $0xa,%ecx
        return s;
    }
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P,E,L,B,F>::update (Quota &quota, E v, mword o, E p, mword a, Type t)
c000e0ca:	53                   	push   %ebx
c000e0cb:	89 c3                	mov    %eax,%ebx
c000e0cd:	83 ec 0c             	sub    $0xc,%esp
{
    unsigned long l = o / B, n = 1UL << o % B, s;
c000e0d0:	be 01 00 00 00       	mov    $0x1,%esi
        return s;
    }
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P,E,L,B,F>::update (Quota &quota, E v, mword o, E p, mword a, Type t)
c000e0d5:	8b 44 24 20          	mov    0x20(%esp),%eax
c000e0d9:	89 54 24 04          	mov    %edx,0x4(%esp)
{
    unsigned long l = o / B, n = 1UL << o % B, s;
c000e0dd:	31 d2                	xor    %edx,%edx
c000e0df:	f7 f1                	div    %ecx
c000e0e1:	88 d1                	mov    %dl,%cl
c000e0e3:	89 c5                	mov    %eax,%ebp
c000e0e5:	89 f0                	mov    %esi,%eax
c000e0e7:	d3 e0                	shl    %cl,%eax

    P *e = walk (quota, v, l, t == TYPE_UP);
c000e0e9:	89 f9                	mov    %edi,%ecx
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P,E,L,B,F>::update (Quota &quota, E v, mword o, E p, mword a, Type t)
{
    unsigned long l = o / B, n = 1UL << o % B, s;
c000e0eb:	89 44 24 08          	mov    %eax,0x8(%esp)

    P *e = walk (quota, v, l, t == TYPE_UP);
c000e0ef:	31 c0                	xor    %eax,%eax
c000e0f1:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c000e0f6:	0f 94 c0             	sete   %al
c000e0f9:	50                   	push   %eax
c000e0fa:	89 d8                	mov    %ebx,%eax
c000e0fc:	55                   	push   %ebp
c000e0fd:	8b 54 24 0c          	mov    0xc(%esp),%edx
c000e101:	e8 b6 fd ff ff       	call   c000debc <_ZN3PteI3HptmLj2ELj10ELb0EE4walkER5Quotammb>

    if (!e)
c000e106:	5a                   	pop    %edx
c000e107:	59                   	pop    %ecx
c000e108:	85 c0                	test   %eax,%eax
c000e10a:	74 7f                	je     c000e18b <_ZN3PteI3HptmLj2ELj10ELb0EE6updateER5QuotammmmNS1_4TypeE+0xcb>
        return false;

    if (a) {
c000e10c:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c000e111:	74 24                	je     c000e137 <_ZN3PteI3HptmLj2ELj10ELb0EE6updateER5QuotammmmNS1_4TypeE+0x77>
        p |= P::order (o % B) | (l ? P::PTE_S : 0) | a;
c000e113:	83 fd 01             	cmp    $0x1,%ebp
c000e116:	8b 7c 24 28          	mov    0x28(%esp),%edi
c000e11a:	19 d2                	sbb    %edx,%edx
        s = 1UL << (l * B + PAGE_BITS);
c000e11c:	6b cd 0a             	imul   $0xa,%ebp,%ecx

    if (!e)
        return false;

    if (a) {
        p |= P::order (o % B) | (l ? P::PTE_S : 0) | a;
c000e11f:	f7 d2                	not    %edx
c000e121:	0b 7c 24 24          	or     0x24(%esp),%edi
c000e125:	81 e2 80 00 00 00    	and    $0x80,%edx
        s = 1UL << (l * B + PAGE_BITS);
c000e12b:	83 c1 0c             	add    $0xc,%ecx

    if (!e)
        return false;

    if (a) {
        p |= P::order (o % B) | (l ? P::PTE_S : 0) | a;
c000e12e:	09 d7                	or     %edx,%edi
        s = 1UL << (l * B + PAGE_BITS);
c000e130:	d3 e6                	shl    %cl,%esi
c000e132:	89 34 24             	mov    %esi,(%esp)
c000e135:	eb 09                	jmp    c000e140 <_ZN3PteI3HptmLj2ELj10ELb0EE6updateER5QuotammmmNS1_4TypeE+0x80>
    } else
        p = s = 0;
c000e137:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c000e13e:	31 ff                	xor    %edi,%edi
c000e140:	89 c3                	mov    %eax,%ebx
c000e142:	8b 44 24 08          	mov    0x8(%esp),%eax
c000e146:	8d 04 83             	lea    (%ebx,%eax,4),%eax
c000e149:	89 44 24 08          	mov    %eax,0x8(%esp)

    bool flush_tlb = false;
c000e14d:	31 c0                	xor    %eax,%eax

    for (unsigned long i = 0; i < n; e[i].val = p, i++, p += s) {

        if (l && e[i].val != p)
c000e14f:	85 ed                	test   %ebp,%ebp
c000e151:	74 06                	je     c000e159 <_ZN3PteI3HptmLj2ELj10ELb0EE6updateER5QuotammmmNS1_4TypeE+0x99>
c000e153:	39 3b                	cmp    %edi,(%ebx)
c000e155:	74 02                	je     c000e159 <_ZN3PteI3HptmLj2ELj10ELb0EE6updateER5QuotammmmNS1_4TypeE+0x99>
            flush_tlb = true;
c000e157:	b0 01                	mov    $0x1,%al

        if (!e[i].val)
c000e159:	8b 33                	mov    (%ebx),%esi
c000e15b:	85 f6                	test   %esi,%esi
c000e15d:	0f 94 c2             	sete   %dl
            continue;

        if (t == TYPE_DF)
c000e160:	83 7c 24 2c 02       	cmpl   $0x2,0x2c(%esp)
c000e165:	0f 94 c1             	sete   %cl
c000e168:	08 ca                	or     %cl,%dl
            continue;

        if (l && !e[i].super()) {
c000e16a:	85 ed                	test   %ebp,%ebp
c000e16c:	0f 95 c1             	setne  %cl
c000e16f:	38 ca                	cmp    %cl,%dl
c000e171:	73 08                	jae    c000e17b <_ZN3PteI3HptmLj2ELj10ELb0EE6updateER5QuotammmmNS1_4TypeE+0xbb>
c000e173:	f7 c6 80 00 00 00    	test   $0x80,%esi
c000e179:	74 14                	je     c000e18f <_ZN3PteI3HptmLj2ELj10ELb0EE6updateER5QuotammmmNS1_4TypeE+0xcf>
    } else
        p = s = 0;

    bool flush_tlb = false;

    for (unsigned long i = 0; i < n; e[i].val = p, i++, p += s) {
c000e17b:	89 3b                	mov    %edi,(%ebx)
c000e17d:	83 c3 04             	add    $0x4,%ebx
c000e180:	03 3c 24             	add    (%esp),%edi
c000e183:	3b 5c 24 08          	cmp    0x8(%esp),%ebx
c000e187:	75 c6                	jne    c000e14f <_ZN3PteI3HptmLj2ELj10ELb0EE6updateER5QuotammmmNS1_4TypeE+0x8f>
c000e189:	eb 22                	jmp    c000e1ad <_ZN3PteI3HptmLj2ELj10ELb0EE6updateER5QuotammmmNS1_4TypeE+0xed>
    unsigned long l = o / B, n = 1UL << o % B, s;

    P *e = walk (quota, v, l, t == TYPE_UP);

    if (!e)
        return false;
c000e18b:	31 c0                	xor    %eax,%eax
c000e18d:	eb 1e                	jmp    c000e1ad <_ZN3PteI3HptmLj2ELj10ELb0EE6updateER5QuotammmmNS1_4TypeE+0xed>

            return p;
        }

        ALWAYS_INLINE
        static inline void destroy(Pte *obj, Quota &quota) { obj->~Pte(); Buddy::allocator.free (reinterpret_cast<mword>(obj), quota); }
c000e18f:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c000e193:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
c000e199:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c000e19e:	8d 96 00 00 c0 bf    	lea    -0x40400000(%esi),%edx
c000e1a4:	e8 bf 2f ff ff       	call   c0001168 <_ZN5Buddy4freeEmR5Quota>
        if (t == TYPE_DF)
            continue;

        if (l && !e[i].super()) {
            Pte::destroy(static_cast<P *>(Buddy::phys_to_ptr (e[i].addr())), quota);
            flush_tlb = true;
c000e1a9:	b0 01                	mov    $0x1,%al
c000e1ab:	eb ce                	jmp    c000e17b <_ZN3PteI3HptmLj2ELj10ELb0EE6updateER5QuotammmmNS1_4TypeE+0xbb>

    if (F)
        flush (e, n * sizeof (E));

    return flush_tlb;
}
c000e1ad:	83 c4 0c             	add    $0xc,%esp
c000e1b0:	5b                   	pop    %ebx
c000e1b1:	5e                   	pop    %esi
c000e1b2:	5f                   	pop    %edi
c000e1b3:	5d                   	pop    %ebp
c000e1b4:	c3                   	ret    
c000e1b5:	90                   	nop

c000e1b6 <_ZN3PteI3HptmLj2ELj10ELb0EE5clearER5QuotaPFbmmjEPFbjmE>:

template <typename P, typename E, unsigned L, unsigned B, bool F>
void Pte<P,E,L,B,F>::clear (Quota &quota, bool (*d) (Paddr, mword, unsigned), bool (*il) (unsigned, mword))
c000e1b6:	57                   	push   %edi
c000e1b7:	56                   	push   %esi
c000e1b8:	53                   	push   %ebx
{
    if (!val)
c000e1b9:	8b 18                	mov    (%eax),%ebx

    return flush_tlb;
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
void Pte<P,E,L,B,F>::clear (Quota &quota, bool (*d) (Paddr, mword, unsigned), bool (*il) (unsigned, mword))
c000e1bb:	8b 7c 24 10          	mov    0x10(%esp),%edi
{
    if (!val)
c000e1bf:	85 db                	test   %ebx,%ebx
c000e1c1:	74 33                	je     c000e1f6 <_ZN3PteI3HptmLj2ELj10ELb0EE5clearER5QuotaPFbmmjEPFbjmE+0x40>
        return;

    P * e = static_cast<P *>(Buddy::phys_to_ptr (this->addr()));

    e->free_up(quota, L - 1, e, 0, d, il);
c000e1c3:	57                   	push   %edi

        ALWAYS_INLINE
        inline mword attr() const { return static_cast<mword>(val) & PAGE_MASK; }

        ALWAYS_INLINE
        inline Paddr addr() const { return static_cast<Paddr>(val) & ~((1UL << order()) - 1); }
c000e1c4:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
c000e1ca:	51                   	push   %ecx
c000e1cb:	81 c3 00 00 c0 bf    	add    $0xbfc00000,%ebx
c000e1d1:	6a 00                	push   $0x0
c000e1d3:	89 d8                	mov    %ebx,%eax
c000e1d5:	53                   	push   %ebx
c000e1d6:	b9 01 00 00 00       	mov    $0x1,%ecx
c000e1db:	89 d6                	mov    %edx,%esi
c000e1dd:	e8 76 fd ff ff       	call   c000df58 <_ZN3PteI3HptmLj2ELj10ELb0EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE>

            return p;
        }

        ALWAYS_INLINE
        static inline void destroy(Pte *obj, Quota &quota) { obj->~Pte(); Buddy::allocator.free (reinterpret_cast<mword>(obj), quota); }
c000e1e2:	83 c4 10             	add    $0x10,%esp
c000e1e5:	89 da                	mov    %ebx,%edx

    Pte::destroy (e, quota);
}
c000e1e7:	5b                   	pop    %ebx
c000e1e8:	89 f1                	mov    %esi,%ecx
c000e1ea:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c000e1ef:	5e                   	pop    %esi
c000e1f0:	5f                   	pop    %edi
c000e1f1:	e9 72 2f ff ff       	jmp    c0001168 <_ZN5Buddy4freeEmR5Quota>
c000e1f6:	5b                   	pop    %ebx
c000e1f7:	5e                   	pop    %esi
c000e1f8:	5f                   	pop    %edi
c000e1f9:	c3                   	ret    

c000e1fa <_ZN3Rcu12invoke_batchEv>:
INIT_PRIORITY (PRIO_LOCAL) Rcu_list Rcu::curr;
INIT_PRIORITY (PRIO_LOCAL) Rcu_list Rcu::done;

void Rcu::invoke_batch()
{
    for (Rcu_elem *e = done.head, *n = nullptr; n != done.head; e = n) {
c000e1fa:	8b 15 d4 f7 ff cf    	mov    0xcffff7d4,%edx
INIT_PRIORITY (PRIO_LOCAL) Rcu_list Rcu::next;
INIT_PRIORITY (PRIO_LOCAL) Rcu_list Rcu::curr;
INIT_PRIORITY (PRIO_LOCAL) Rcu_list Rcu::done;

void Rcu::invoke_batch()
{
c000e200:	53                   	push   %ebx
    for (Rcu_elem *e = done.head, *n = nullptr; n != done.head; e = n) {
c000e201:	31 db                	xor    %ebx,%ebx
c000e203:	3b 1d d4 f7 ff cf    	cmp    0xcffff7d4,%ebx
c000e209:	74 11                	je     c000e21c <_ZN3Rcu12invoke_batchEv+0x22>
        n = e->next;
c000e20b:	8b 1a                	mov    (%edx),%ebx
        e->next = nullptr;
        (e->func)(e);
c000e20d:	89 d0                	mov    %edx,%eax

void Rcu::invoke_batch()
{
    for (Rcu_elem *e = done.head, *n = nullptr; n != done.head; e = n) {
        n = e->next;
        e->next = nullptr;
c000e20f:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
        (e->func)(e);
c000e215:	ff 52 04             	call   *0x4(%edx)
INIT_PRIORITY (PRIO_LOCAL) Rcu_list Rcu::curr;
INIT_PRIORITY (PRIO_LOCAL) Rcu_list Rcu::done;

void Rcu::invoke_batch()
{
    for (Rcu_elem *e = done.head, *n = nullptr; n != done.head; e = n) {
c000e218:	89 da                	mov    %ebx,%edx
c000e21a:	eb e7                	jmp    c000e203 <_ZN3Rcu12invoke_batchEv+0x9>

        ALWAYS_INLINE
        explicit Rcu_list() { clear(); }

        ALWAYS_INLINE
        inline void clear() { head = nullptr; tail = &head; count = 0;}
c000e21c:	c7 05 d4 f7 ff cf 00 	movl   $0x0,0xcffff7d4
c000e223:	00 00 00 
c000e226:	c7 05 d8 f7 ff cf d4 	movl   $0xcffff7d4,0xcffff7d8
c000e22d:	f7 ff cf 
c000e230:	c7 05 dc f7 ff cf 00 	movl   $0x0,0xcffff7dc
c000e237:	00 00 00 
        e->next = nullptr;
        (e->func)(e);
    }

    done.clear();
}
c000e23a:	5b                   	pop    %ebx
c000e23b:	c3                   	ret    

c000e23c <_ZN3Rcu11start_batchENS_5StateE>:

void Rcu::start_batch (State s)
{
c000e23c:	53                   	push   %ebx
c000e23d:	89 c2                	mov    %eax,%edx
    mword v, m = RCU_CMP | RCU_PND;

    do if ((v = state) >> 2 != l_batch) return; while (!(v & s) && !Atomic::cmp_swap (state, v, v | s));
c000e23f:	8b 0d 68 a2 01 c0    	mov    0xc001a268,%ecx
c000e245:	89 c8                	mov    %ecx,%eax
c000e247:	c1 e8 02             	shr    $0x2,%eax
c000e24a:	3b 05 fc f7 ff cf    	cmp    0xcffff7fc,%eax
c000e250:	75 2d                	jne    c000e27f <_ZN3Rcu11start_batchENS_5StateE+0x43>
c000e252:	85 ca                	test   %ecx,%edx
c000e254:	75 10                	jne    c000e266 <_ZN3Rcu11start_batchENS_5StateE+0x2a>
c000e256:	89 d3                	mov    %edx,%ebx
c000e258:	89 c8                	mov    %ecx,%eax
c000e25a:	09 cb                	or     %ecx,%ebx
c000e25c:	f0 0f b1 1d 68 a2 01 	lock cmpxchg %ebx,0xc001a268
c000e263:	c0 
c000e264:	75 d9                	jne    c000e23f <_ZN3Rcu11start_batchENS_5StateE+0x3>

    if ((v ^ ~s) & m)
c000e266:	f7 d2                	not    %edx
c000e268:	31 ca                	xor    %ecx,%edx
c000e26a:	f6 c2 03             	test   $0x3,%dl
c000e26d:	75 10                	jne    c000e27f <_ZN3Rcu11start_batchENS_5StateE+0x43>
        return;

    count = Cpu::online;
c000e26f:	a1 40 a4 01 c0       	mov    0xc001a440,%eax
c000e274:	a3 94 b4 01 c0       	mov    %eax,0xc001b494

    barrier();

    state++;
c000e279:	ff 05 68 a2 01 c0    	incl   0xc001a268
}
c000e27f:	5b                   	pop    %ebx
c000e280:	c3                   	ret    
c000e281:	90                   	nop

c000e282 <_ZN3Rcu5quietEv>:

void Rcu::quiet()
{
    Cpu::hazard &= ~HZD_RCU;
c000e282:	83 25 00 f0 ff cf ef 	andl   $0xffffffef,0xcffff000
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c000e289:	83 c8 ff             	or     $0xffffffff,%eax
c000e28c:	f0 0f c1 05 94 b4 01 	lock xadd %eax,0xc001b494
c000e293:	c0 

    if (Atomic::sub (count, 1UL) == 0)
c000e294:	83 f8 01             	cmp    $0x1,%eax
c000e297:	75 05                	jne    c000e29e <_ZN3Rcu5quietEv+0x1c>
        start_batch (RCU_CMP);
c000e299:	e9 9e ff ff ff       	jmp    c000e23c <_ZN3Rcu11start_batchENS_5StateE>
c000e29e:	c3                   	ret    
c000e29f:	90                   	nop

c000e2a0 <_ZN3Rcu6updateEv>:
            RCU_CMP = 1UL << 0,
            RCU_PND = 1UL << 1,
        };

        ALWAYS_INLINE
        static inline mword batch() { return state >> 2; }
c000e2a0:	8b 15 68 a2 01 c0    	mov    0xc001a268,%edx
}

void Rcu::update()
{
c000e2a6:	53                   	push   %ebx
c000e2a7:	c1 ea 02             	shr    $0x2,%edx
    if (l_batch != batch()) {
c000e2aa:	39 15 fc f7 ff cf    	cmp    %edx,0xcffff7fc
c000e2b0:	74 1a                	je     c000e2cc <_ZN3Rcu6updateEv+0x2c>
        }

        template <unsigned D, unsigned B>
        static void print (mword val, Console_vga::Color c, unsigned col)
        {
            if (EXPECT_FALSE (Cpu::row))
c000e2b2:	a1 50 f7 ff cf       	mov    0xcffff750,%eax
        l_batch = batch();
        Cpu::hazard |= HZD_RCU;
c000e2b7:	83 0d 00 f0 ff cf 10 	orl    $0x10,0xcffff000
}

void Rcu::update()
{
    if (l_batch != batch()) {
        l_batch = batch();
c000e2be:	89 15 fc f7 ff cf    	mov    %edx,0xcffff7fc
c000e2c4:	85 c0                	test   %eax,%eax
c000e2c6:	0f 85 99 01 00 00    	jne    c000e465 <_ZN3Rcu6updateEv+0x1c5>

        ALWAYS_INLINE
        inline void clear() { head = nullptr; tail = &head; count = 0;}

        ALWAYS_INLINE
        inline bool empty() { return &head == tail || head == nullptr; }
c000e2cc:	81 3d e4 f7 ff cf e0 	cmpl   $0xcffff7e0,0xcffff7e4
c000e2d3:	f7 ff cf 
c000e2d6:	74 67                	je     c000e33f <_ZN3Rcu6updateEv+0x9f>
c000e2d8:	8b 0d e0 f7 ff cf    	mov    0xcffff7e0,%ecx
c000e2de:	85 c9                	test   %ecx,%ecx
c000e2e0:	74 5d                	je     c000e33f <_ZN3Rcu6updateEv+0x9f>

        ALWAYS_INLINE
        static inline mword batch() { return state >> 2; }

        ALWAYS_INLINE
        static inline bool complete (mword b) { return static_cast<signed long>((state & ~RCU_PND) - (b << 2)) > 0; }
c000e2e2:	a1 68 a2 01 c0       	mov    0xc001a268,%eax
c000e2e7:	8b 1d f8 f7 ff cf    	mov    0xcffff7f8,%ebx
c000e2ed:	83 e0 fd             	and    $0xfffffffd,%eax
c000e2f0:	8d 14 9d 00 00 00 00 	lea    0x0(,%ebx,4),%edx
c000e2f7:	29 d0                	sub    %edx,%eax
        Cpu::hazard |= HZD_RCU;
        Counter::print<1,16> (l_batch, Console_vga::COLOR_LIGHT_GREEN, SPN_RCU);
    }

    if (!curr.empty() && complete (c_batch))
c000e2f9:	85 c0                	test   %eax,%eax
c000e2fb:	7e 42                	jle    c000e33f <_ZN3Rcu6updateEv+0x9f>
        inline bool empty() { return &head == tail || head == nullptr; }

        ALWAYS_INLINE
        inline void append (Rcu_list *l)
        {
           *tail   = l->head;
c000e2fd:	a1 d8 f7 ff cf       	mov    0xcffff7d8,%eax
c000e302:	89 08                	mov    %ecx,(%eax)
            tail   = l->tail;
c000e304:	a1 e4 f7 ff cf       	mov    0xcffff7e4,%eax
           *tail   = head;
c000e309:	8b 15 d4 f7 ff cf    	mov    0xcffff7d4,%edx

        ALWAYS_INLINE
        inline void append (Rcu_list *l)
        {
           *tail   = l->head;
            tail   = l->tail;
c000e30f:	a3 d8 f7 ff cf       	mov    %eax,0xcffff7d8
           *tail   = head;
c000e314:	89 10                	mov    %edx,(%eax)

            count += l->count;
c000e316:	a1 e8 f7 ff cf       	mov    0xcffff7e8,%eax
c000e31b:	01 05 dc f7 ff cf    	add    %eax,0xcffff7dc

        ALWAYS_INLINE
        explicit Rcu_list() { clear(); }

        ALWAYS_INLINE
        inline void clear() { head = nullptr; tail = &head; count = 0;}
c000e321:	c7 05 e0 f7 ff cf 00 	movl   $0x0,0xcffff7e0
c000e328:	00 00 00 
c000e32b:	c7 05 e4 f7 ff cf e0 	movl   $0xcffff7e0,0xcffff7e4
c000e332:	f7 ff cf 
c000e335:	c7 05 e8 f7 ff cf 00 	movl   $0x0,0xcffff7e8
c000e33c:	00 00 00 

        ALWAYS_INLINE
        inline bool empty() { return &head == tail || head == nullptr; }
c000e33f:	a1 e4 f7 ff cf       	mov    0xcffff7e4,%eax
c000e344:	3d e0 f7 ff cf       	cmp    $0xcffff7e0,%eax
c000e349:	74 09                	je     c000e354 <_ZN3Rcu6updateEv+0xb4>
c000e34b:	83 3d e0 f7 ff cf 00 	cmpl   $0x0,0xcffff7e0
c000e352:	75 0c                	jne    c000e360 <_ZN3Rcu6updateEv+0xc0>
c000e354:	81 3d f0 f7 ff cf ec 	cmpl   $0xcffff7ec,0xcffff7f0
c000e35b:	f7 ff cf 
c000e35e:	75 3b                	jne    c000e39b <_ZN3Rcu6updateEv+0xfb>
c000e360:	81 3d e4 f7 ff cf e0 	cmpl   $0xcffff7e0,0xcffff7e4
c000e367:	f7 ff cf 
c000e36a:	75 11                	jne    c000e37d <_ZN3Rcu6updateEv+0xdd>
c000e36c:	81 3d d8 f7 ff cf d4 	cmpl   $0xcffff7d4,0xcffff7d8
c000e373:	f7 ff cf 
c000e376:	75 10                	jne    c000e388 <_ZN3Rcu6updateEv+0xe8>
c000e378:	e9 0a 01 00 00       	jmp    c000e487 <_ZN3Rcu6updateEv+0x1e7>
c000e37d:	83 3d e0 f7 ff cf 00 	cmpl   $0x0,0xcffff7e0
c000e384:	75 76                	jne    c000e3fc <_ZN3Rcu6updateEv+0x15c>
c000e386:	eb e4                	jmp    c000e36c <_ZN3Rcu6updateEv+0xcc>
c000e388:	83 3d d4 f7 ff cf 00 	cmpl   $0x0,0xcffff7d4
c000e38f:	0f 84 f2 00 00 00    	je     c000e487 <_ZN3Rcu6updateEv+0x1e7>
            Lapic::send_ipi (cpu, VEC_IPI_IDL);
        }

    if (!done.empty())
        invoke_batch();
}
c000e395:	5b                   	pop    %ebx

            Lapic::send_ipi (cpu, VEC_IPI_IDL);
        }

    if (!done.empty())
        invoke_batch();
c000e396:	e9 5f fe ff ff       	jmp    c000e1fa <_ZN3Rcu12invoke_batchEv>
c000e39b:	8b 15 ec f7 ff cf    	mov    0xcffff7ec,%edx
c000e3a1:	85 d2                	test   %edx,%edx
c000e3a3:	74 bb                	je     c000e360 <_ZN3Rcu6updateEv+0xc0>

        ALWAYS_INLINE
        inline void append (Rcu_list *l)
        {
           *tail   = l->head;
c000e3a5:	89 10                	mov    %edx,(%eax)
            tail   = l->tail;
c000e3a7:	a1 f0 f7 ff cf       	mov    0xcffff7f0,%eax
           *tail   = head;
c000e3ac:	8b 15 e0 f7 ff cf    	mov    0xcffff7e0,%edx

        ALWAYS_INLINE
        inline void append (Rcu_list *l)
        {
           *tail   = l->head;
            tail   = l->tail;
c000e3b2:	a3 e4 f7 ff cf       	mov    %eax,0xcffff7e4
           *tail   = head;
c000e3b7:	89 10                	mov    %edx,(%eax)

            count += l->count;
c000e3b9:	a1 f4 f7 ff cf       	mov    0xcffff7f4,%eax
c000e3be:	01 05 e8 f7 ff cf    	add    %eax,0xcffff7e8
        done.append (&curr);

    if (curr.empty() && !next.empty()) {
        curr.append (&next);

        c_batch = l_batch + 1;
c000e3c4:	a1 fc f7 ff cf       	mov    0xcffff7fc,%eax

        ALWAYS_INLINE
        explicit Rcu_list() { clear(); }

        ALWAYS_INLINE
        inline void clear() { head = nullptr; tail = &head; count = 0;}
c000e3c9:	c7 05 ec f7 ff cf 00 	movl   $0x0,0xcffff7ec
c000e3d0:	00 00 00 
c000e3d3:	c7 05 f0 f7 ff cf ec 	movl   $0xcffff7ec,0xcffff7f0
c000e3da:	f7 ff cf 
c000e3dd:	c7 05 f4 f7 ff cf 00 	movl   $0x0,0xcffff7f4
c000e3e4:	00 00 00 
c000e3e7:	40                   	inc    %eax
c000e3e8:	a3 f8 f7 ff cf       	mov    %eax,0xcffff7f8

        start_batch (RCU_PND);
c000e3ed:	b8 02 00 00 00       	mov    $0x2,%eax
c000e3f2:	e8 45 fe ff ff       	call   c000e23c <_ZN3Rcu11start_batchENS_5StateE>
c000e3f7:	e9 64 ff ff ff       	jmp    c000e360 <_ZN3Rcu6updateEv+0xc0>

        ALWAYS_INLINE
        inline bool empty() { return &head == tail || head == nullptr; }
c000e3fc:	81 3d f0 f7 ff cf ec 	cmpl   $0xcffff7ec,0xcffff7f0
c000e403:	f7 ff cf 
c000e406:	0f 84 60 ff ff ff    	je     c000e36c <_ZN3Rcu6updateEv+0xcc>
c000e40c:	83 3d ec f7 ff cf 00 	cmpl   $0x0,0xcffff7ec
c000e413:	0f 84 53 ff ff ff    	je     c000e36c <_ZN3Rcu6updateEv+0xcc>
    }

    if (!curr.empty() && !next.empty() && (next.count > 2000 || curr.count > 2000))
c000e419:	81 3d f4 f7 ff cf d0 	cmpl   $0x7d0,0xcffff7f4
c000e420:	07 00 00 
c000e423:	77 10                	ja     c000e435 <_ZN3Rcu6updateEv+0x195>
c000e425:	81 3d e8 f7 ff cf d0 	cmpl   $0x7d0,0xcffff7e8
c000e42c:	07 00 00 
c000e42f:	0f 86 37 ff ff ff    	jbe    c000e36c <_ZN3Rcu6updateEv+0xcc>
c000e435:	31 db                	xor    %ebx,%ebx
c000e437:	f6 04 dd 38 e0 01 c0 	testb  $0x1,-0x3ffe1fc8(,%ebx,8)
c000e43e:	01 
c000e43f:	74 19                	je     c000e45a <_ZN3Rcu6updateEv+0x1ba>
        for (unsigned cpu = 0; cpu < NUM_CPU; cpu++) {

            if (!Hip::cpu_online (cpu) || Cpu::id == cpu)
c000e441:	39 1d 04 f0 ff cf    	cmp    %ebx,0xcffff004
c000e447:	74 11                	je     c000e45a <_ZN3Rcu6updateEv+0x1ba>
                continue;

            Lapic::send_ipi (cpu, VEC_IPI_IDL);
c000e449:	6a 00                	push   $0x0
c000e44b:	89 d8                	mov    %ebx,%eax
c000e44d:	31 c9                	xor    %ecx,%ecx
c000e44f:	ba a9 00 00 00       	mov    $0xa9,%edx
c000e454:	e8 fb 78 ff ff       	call   c0005d54 <_ZN5Lapic8send_ipiEjjNS_13Delivery_modeENS_9ShorthandE>
c000e459:	58                   	pop    %eax

        start_batch (RCU_PND);
    }

    if (!curr.empty() && !next.empty() && (next.count > 2000 || curr.count > 2000))
        for (unsigned cpu = 0; cpu < NUM_CPU; cpu++) {
c000e45a:	43                   	inc    %ebx
c000e45b:	83 fb 40             	cmp    $0x40,%ebx
c000e45e:	75 d7                	jne    c000e437 <_ZN3Rcu6updateEv+0x197>
c000e460:	e9 07 ff ff ff       	jmp    c000e36c <_ZN3Rcu6updateEv+0xcc>
                for (unsigned i = 0; i < D; i++, val /= B)
                    Console_vga::con.put (Cpu::row, col - i, c, !i || val ? (val % B)["0123456789ABCDEF"] : ' ');
c000e465:	83 e2 0f             	and    $0xf,%edx
c000e468:	66 0f be 92 14 66 01 	movsbw -0x3ffe99ec(%edx),%dx
c000e46f:	c0 
c000e470:	6b c0 50             	imul   $0x50,%eax,%eax
c000e473:	80 ce 0a             	or     $0xa,%dh
c000e476:	05 02 f8 df 67       	add    $0x67dff802,%eax
c000e47b:	0f b7 d2             	movzwl %dx,%edx
c000e47e:	66 89 14 00          	mov    %dx,(%eax,%eax,1)
c000e482:	e9 45 fe ff ff       	jmp    c000e2cc <_ZN3Rcu6updateEv+0x2c>
            Lapic::send_ipi (cpu, VEC_IPI_IDL);
        }

    if (!done.empty())
        invoke_batch();
}
c000e487:	5b                   	pop    %ebx
c000e488:	c3                   	ret    

c000e489 <_GLOBAL__sub_I.65534__ZN3Rcu5stateE>:

        ALWAYS_INLINE
        explicit Rcu_list() { clear(); }

        ALWAYS_INLINE
        inline void clear() { head = nullptr; tail = &head; count = 0;}
c000e489:	c7 05 ec f7 ff cf 00 	movl   $0x0,0xcffff7ec
c000e490:	00 00 00 
c000e493:	c7 05 f0 f7 ff cf ec 	movl   $0xcffff7ec,0xcffff7f0
c000e49a:	f7 ff cf 
c000e49d:	c7 05 f4 f7 ff cf 00 	movl   $0x0,0xcffff7f4
c000e4a4:	00 00 00 
c000e4a7:	c7 05 e0 f7 ff cf 00 	movl   $0x0,0xcffff7e0
c000e4ae:	00 00 00 
c000e4b1:	c7 05 e4 f7 ff cf e0 	movl   $0xcffff7e0,0xcffff7e4
c000e4b8:	f7 ff cf 
c000e4bb:	c7 05 e8 f7 ff cf 00 	movl   $0x0,0xcffff7e8
c000e4c2:	00 00 00 
c000e4c5:	c7 05 d4 f7 ff cf 00 	movl   $0x0,0xcffff7d4
c000e4cc:	00 00 00 
c000e4cf:	c7 05 d8 f7 ff cf d4 	movl   $0xcffff7d4,0xcffff7d8
c000e4d6:	f7 ff cf 
c000e4d9:	c7 05 dc f7 ff cf 00 	movl   $0x0,0xcffff7dc
c000e4e0:	00 00 00 
c000e4e3:	c3                   	ret    

c000e4e4 <_ZNK8Exc_regs9tlb_flushI4VmcbEEvb>:
template <> void Exc_regs::set_e_bmp<Vmcs> (uint32 v)   const { Vmcs::write (Vmcs::EXC_BITMAP, v); }
template <> void Exc_regs::set_s_cr0<Vmcs> (mword v)          { Vmcs::write (Vmcs::CR0_READ_SHADOW, cr0_shadow = v); }
template <> void Exc_regs::set_s_cr4<Vmcs> (mword v)          { Vmcs::write (Vmcs::CR4_READ_SHADOW, cr4_shadow = v); }

template <> void Exc_regs::tlb_flush<Vmcb>(bool full) const
{
c000e4e4:	53                   	push   %ebx
c000e4e5:	89 c3                	mov    %eax,%ebx
    vtlb->flush (full);
c000e4e7:	8b 40 24             	mov    0x24(%eax),%eax
c000e4ea:	0f b6 d2             	movzbl %dl,%edx
c000e4ed:	e8 1a 78 00 00       	call   c0015d0c <_ZN4Vtlb5flushEb>

    if (vmcb->asid)
c000e4f2:	8b 43 20             	mov    0x20(%ebx),%eax
c000e4f5:	83 78 58 00          	cmpl   $0x0,0x58(%eax)
c000e4f9:	74 07                	je     c000e502 <_ZNK8Exc_regs9tlb_flushI4VmcbEEvb+0x1e>
        vmcb->tlb_control = 1;
c000e4fb:	c7 40 5c 01 00 00 00 	movl   $0x1,0x5c(%eax)
}
c000e502:	5b                   	pop    %ebx
c000e503:	c3                   	ret    

c000e504 <_ZNK8Exc_regs9tlb_flushI4VmcsEEvb>:

template <> void Exc_regs::tlb_flush<Vmcs>(bool full) const
{
c000e504:	53                   	push   %ebx
c000e505:	0f b6 d2             	movzbl %dl,%edx
c000e508:	83 ec 10             	sub    $0x10,%esp
c000e50b:	89 d3                	mov    %edx,%ebx
    vtlb->flush (full);
c000e50d:	8b 40 24             	mov    0x24(%eax),%eax
c000e510:	e8 f7 77 00 00       	call   c0015d0c <_ZN4Vtlb5flushEb>
        }

        ALWAYS_INLINE
        static inline unsigned long vpid()
        {
            return has_vpid() ? read (VPID) : 0;
c000e515:	f6 05 54 fb ff cf 20 	testb  $0x20,0xcffffb54
c000e51c:	74 33                	je     c000e551 <_ZNK8Exc_regs9tlb_flushI4VmcsEEvb+0x4d>

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
c000e51e:	31 c9                	xor    %ecx,%ecx
c000e520:	0f 78 c9             	vmread %ecx,%ecx

    mword vpid = Vmcs::vpid();

    if (vpid)
c000e523:	85 c9                	test   %ecx,%ecx
c000e525:	74 2a                	je     c000e551 <_ZNK8Exc_regs9tlb_flushI4VmcsEEvb+0x4d>
        Vpid::flush (full ? Vpid::CONTEXT_GLOBAL : Vpid::CONTEXT_NOGLOBAL, vpid);
c000e527:	80 fb 01             	cmp    $0x1,%bl
c000e52a:	19 c0                	sbb    %eax,%eax
c000e52c:	83 e0 02             	and    $0x2,%eax
c000e52f:	40                   	inc    %eax
        uint64  vpid;
        uint64  addr;

    public:
        ALWAYS_INLINE
        inline Invvpid (unsigned long v, mword a) : vpid (v), addr (a) {}
c000e530:	89 0c 24             	mov    %ecx,(%esp)
c000e533:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c000e53a:	00 
c000e53b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c000e542:	00 
c000e543:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c000e54a:	00 
        };

        ALWAYS_INLINE
        static inline void flush (Type t, unsigned long vpid, mword addr = 0)
        {
            asm volatile ("invvpid %0, %1" : : "m" (Invvpid (vpid, addr)), "r" (static_cast<mword>(t)) : "cc");
c000e54b:	66 0f 38 81 04 24    	invvpid (%esp),%eax
}
c000e551:	83 c4 10             	add    $0x10,%esp
c000e554:	5b                   	pop    %ebx
c000e555:	c3                   	ret    

c000e556 <_ZNK8Exc_regs9tlb_flushI4VmcsEEvm>:

template <> void Exc_regs::tlb_flush<Vmcs>(mword addr) const
{
c000e556:	53                   	push   %ebx
c000e557:	89 d3                	mov    %edx,%ebx
c000e559:	83 ec 10             	sub    $0x10,%esp
    vtlb->flush (addr);
c000e55c:	8b 40 24             	mov    0x24(%eax),%eax
c000e55f:	e8 78 79 00 00       	call   c0015edc <_ZN4Vtlb5flushEm>
        }

        ALWAYS_INLINE
        static inline unsigned long vpid()
        {
            return has_vpid() ? read (VPID) : 0;
c000e564:	f6 05 54 fb ff cf 20 	testb  $0x20,0xcffffb54
c000e56b:	74 28                	je     c000e595 <_ZNK8Exc_regs9tlb_flushI4VmcsEEvm+0x3f>

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
c000e56d:	31 c0                	xor    %eax,%eax
c000e56f:	0f 78 c0             	vmread %eax,%eax

    mword vpid = Vmcs::vpid();

    if (vpid)
c000e572:	85 c0                	test   %eax,%eax
c000e574:	74 1f                	je     c000e595 <_ZNK8Exc_regs9tlb_flushI4VmcsEEvm+0x3f>
        uint64  vpid;
        uint64  addr;

    public:
        ALWAYS_INLINE
        inline Invvpid (unsigned long v, mword a) : vpid (v), addr (a) {}
c000e576:	89 04 24             	mov    %eax,(%esp)
        };

        ALWAYS_INLINE
        static inline void flush (Type t, unsigned long vpid, mword addr = 0)
        {
            asm volatile ("invvpid %0, %1" : : "m" (Invvpid (vpid, addr)), "r" (static_cast<mword>(t)) : "cc");
c000e579:	31 c0                	xor    %eax,%eax
        uint64  vpid;
        uint64  addr;

    public:
        ALWAYS_INLINE
        inline Invvpid (unsigned long v, mword a) : vpid (v), addr (a) {}
c000e57b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c000e582:	00 
c000e583:	89 5c 24 08          	mov    %ebx,0x8(%esp)
c000e587:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c000e58e:	00 
        };

        ALWAYS_INLINE
        static inline void flush (Type t, unsigned long vpid, mword addr = 0)
        {
            asm volatile ("invvpid %0, %1" : : "m" (Invvpid (vpid, addr)), "r" (static_cast<mword>(t)) : "cc");
c000e58f:	66 0f 38 81 04 24    	invvpid (%esp),%eax
        Vpid::flush (Vpid::ADDRESS, vpid, addr);
}
c000e595:	83 c4 10             	add    $0x10,%esp
c000e598:	5b                   	pop    %ebx
c000e599:	c3                   	ret    

c000e59a <_ZN8Exc_regs17svm_set_cpu_ctrl0Em>:

    set_e_bmp<T> (msk);
}

void Exc_regs::svm_set_cpu_ctrl0 (mword val)
{
c000e59a:	57                   	push   %edi
c000e59b:	56                   	push   %esi
c000e59c:	53                   	push   %ebx
c000e59d:	0f b6 48 40          	movzbl 0x40(%eax),%ecx
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
c000e5a1:	80 f9 01             	cmp    $0x1,%cl
c000e5a4:	19 db                	sbb    %ebx,%ebx
c000e5a6:	81 e3 01 00 01 80    	and    $0x80010001,%ebx
    if (!fpu_on)
        set |= Cpu::CR0_TS;
c000e5ac:	89 de                	mov    %ebx,%esi
c000e5ae:	83 ce 08             	or     $0x8,%esi
c000e5b1:	80 78 41 00          	cmpb   $0x0,0x41(%eax)
c000e5b5:	0f 44 de             	cmove  %esi,%ebx
    set_e_bmp<T> (msk);
}

void Exc_regs::svm_set_cpu_ctrl0 (mword val)
{
    unsigned const msk = !!cr0_msk<Vmcb>() << 0 | !nst_on << 3 | !!cr4_msk<Vmcb>() << 4;
c000e5b8:	85 db                	test   %ebx,%ebx
c000e5ba:	0f 95 c3             	setne  %bl
c000e5bd:	80 f9 01             	cmp    $0x1,%cl
c000e5c0:	19 ff                	sbb    %edi,%edi
c000e5c2:	0f b6 db             	movzbl %bl,%ebx
c000e5c5:	83 e7 08             	and    $0x8,%edi
c000e5c8:	09 df                	or     %ebx,%edi
template <typename T>
mword Exc_regs::cr4_msk() const
{
    mword clr = nst_on ? 0 :
#ifdef __i386__
                Cpu::CR4_PGE | Cpu::CR4_PAE;
c000e5ca:	80 f9 01             	cmp    $0x1,%cl
c000e5cd:	19 db                	sbb    %ebx,%ebx
c000e5cf:	81 e3 a0 00 00 00    	and    $0xa0,%ebx
c000e5d5:	80 f9 01             	cmp    $0x1,%cl
c000e5d8:	19 f6                	sbb    %esi,%esi
c000e5da:	83 e6 10             	and    $0x10,%esi
#else
                Cpu::CR4_PGE;
#endif

    return T::fix_cr4_clr | clr | cr4_set<T>();
c000e5dd:	09 de                	or     %ebx,%esi
    set_e_bmp<T> (msk);
}

void Exc_regs::svm_set_cpu_ctrl0 (mword val)
{
    unsigned const msk = !!cr0_msk<Vmcb>() << 0 | !nst_on << 3 | !!cr4_msk<Vmcb>() << 4;
c000e5df:	83 fe 01             	cmp    $0x1,%esi

    vmcb->npt_control  = nst_on;
c000e5e2:	8b 70 20             	mov    0x20(%eax),%esi
    set_e_bmp<T> (msk);
}

void Exc_regs::svm_set_cpu_ctrl0 (mword val)
{
    unsigned const msk = !!cr0_msk<Vmcb>() << 0 | !nst_on << 3 | !!cr4_msk<Vmcb>() << 4;
c000e5e5:	19 db                	sbb    %ebx,%ebx
c000e5e7:	f7 d3                	not    %ebx
c000e5e9:	83 e3 10             	and    $0x10,%ebx

    vmcb->npt_control  = nst_on;
c000e5ec:	89 8e 90 00 00 00    	mov    %ecx,0x90(%esi)
    set_e_bmp<T> (msk);
}

void Exc_regs::svm_set_cpu_ctrl0 (mword val)
{
    unsigned const msk = !!cr0_msk<Vmcb>() << 0 | !nst_on << 3 | !!cr4_msk<Vmcb>() << 4;
c000e5f2:	09 fb                	or     %edi,%ebx

    vmcb->npt_control  = nst_on;
c000e5f4:	c7 86 94 00 00 00 00 	movl   $0x0,0x94(%esi)
c000e5fb:	00 00 00 
    vmcb->intercept_cr = (msk << 16) | msk;
c000e5fe:	89 de                	mov    %ebx,%esi
c000e600:	8b 48 20             	mov    0x20(%eax),%ecx
c000e603:	c1 e6 10             	shl    $0x10,%esi
c000e606:	09 f3                	or     %esi,%ebx
c000e608:	89 19                	mov    %ebx,(%ecx)

    if (nst_on)
c000e60a:	80 78 40 00          	cmpb   $0x0,0x40(%eax)
c000e60e:	8b 40 20             	mov    0x20(%eax),%eax
c000e611:	74 0e                	je     c000e621 <_ZN8Exc_regs17svm_set_cpu_ctrl0Em+0x87>
        vmcb->intercept_cpu[0] = static_cast<uint32>((val & ~Vmcb::CPU_INVLPG) | Vmcb::force_ctrl0);
c000e613:	81 e2 f4 ff bf 64    	and    $0x64bffff4,%edx
c000e619:	81 ca 0b 00 40 99    	or     $0x9940000b,%edx
c000e61f:	eb 06                	jmp    c000e627 <_ZN8Exc_regs17svm_set_cpu_ctrl0Em+0x8d>
    else
        vmcb->intercept_cpu[0] = static_cast<uint32>((val |  Vmcb::CPU_INVLPG) | Vmcb::force_ctrl0);
c000e621:	81 ca 0b 00 40 9b    	or     $0x9b40000b,%edx
c000e627:	89 50 0c             	mov    %edx,0xc(%eax)
}
c000e62a:	5b                   	pop    %ebx
c000e62b:	5e                   	pop    %esi
c000e62c:	5f                   	pop    %edi
c000e62d:	c3                   	ret    

c000e62e <_ZN8Exc_regs17svm_set_cpu_ctrl1Em>:

void Exc_regs::svm_set_cpu_ctrl1 (mword val)
{
    vmcb->intercept_cpu[1] = static_cast<uint32>(val | Vmcb::force_ctrl1);
c000e62e:	8b 40 20             	mov    0x20(%eax),%eax
c000e631:	83 ca 6c             	or     $0x6c,%edx
c000e634:	89 50 10             	mov    %edx,0x10(%eax)
c000e637:	c3                   	ret    

c000e638 <_ZN8Exc_regs17vmx_set_cpu_ctrl0Em>:
void Exc_regs::vmx_set_cpu_ctrl0 (mword val)
{
    unsigned const msk = Vmcs::CPU_INVLPG | Vmcs::CPU_CR3_LOAD | Vmcs::CPU_CR3_STORE;

    if (nst_on)
        val &= ~msk;
c000e638:	89 d1                	mov    %edx,%ecx
c000e63a:	81 ca 00 82 01 00    	or     $0x18200,%edx
c000e640:	81 e1 ff 7d fe ff    	and    $0xfffe7dff,%ecx
c000e646:	80 78 40 00          	cmpb   $0x0,0x40(%eax)
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
c000e64a:	b8 02 40 00 00       	mov    $0x4002,%eax
c000e64f:	0f 45 d1             	cmovne %ecx,%edx
    else
        val |= msk;

    val |= Vmcs::ctrl_cpu[0].set;
c000e652:	0b 15 48 fb ff cf    	or     0xcffffb48,%edx
    val &= Vmcs::ctrl_cpu[0].clr;
c000e658:	23 15 4c fb ff cf    	and    0xcffffb4c,%edx
c000e65e:	0f 79 c2             	vmwrite %edx,%eax
c000e661:	c3                   	ret    

c000e662 <_ZN8Exc_regs17vmx_set_cpu_ctrl1Em>:
void Exc_regs::vmx_set_cpu_ctrl1 (mword val)
{
    unsigned const msk = Vmcs::CPU_EPT;

    if (nst_on)
        val |= msk;
c000e662:	89 d1                	mov    %edx,%ecx
c000e664:	83 e2 fd             	and    $0xfffffffd,%edx
c000e667:	83 c9 02             	or     $0x2,%ecx
c000e66a:	80 78 40 00          	cmpb   $0x0,0x40(%eax)
c000e66e:	b8 1e 40 00 00       	mov    $0x401e,%eax
c000e673:	0f 45 d1             	cmovne %ecx,%edx
    else
        val &= ~msk;

    val |= Vmcs::ctrl_cpu[1].set;
c000e676:	0b 15 50 fb ff cf    	or     0xcffffb50,%edx
    val &= Vmcs::ctrl_cpu[1].clr;
c000e67c:	23 15 54 fb ff cf    	and    0xcffffb54,%edx
c000e682:	0f 79 c2             	vmwrite %edx,%eax
c000e685:	c3                   	ret    

c000e686 <_ZN8Exc_regs8nst_ctrlI4VmcbEEvb>:

    Vmcs::write (Vmcs::CPU_EXEC_CTRL1, val);
}

template <> void Exc_regs::nst_ctrl<Vmcb>(bool on)
{
c000e686:	55                   	push   %ebp
c000e687:	57                   	push   %edi
c000e688:	56                   	push   %esi
c000e689:	53                   	push   %ebx
c000e68a:	89 c3                	mov    %eax,%ebx
c000e68c:	83 ec 08             	sub    $0x8,%esp
c000e68f:	8a 48 40             	mov    0x40(%eax),%cl
c000e692:	8b 73 20             	mov    0x20(%ebx),%esi
c000e695:	8a 40 41             	mov    0x41(%eax),%al
template <typename T>
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
c000e698:	84 c9                	test   %cl,%cl
c000e69a:	74 0c                	je     c000e6a8 <_ZN8Exc_regs8nst_ctrlI4VmcbEEvb+0x22>
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
c000e69c:	84 c0                	test   %al,%al
c000e69e:	0f 85 7e 01 00 00    	jne    c000e822 <_ZN8Exc_regs8nst_ctrlI4VmcbEEvb+0x19c>
}

template <typename T>
mword Exc_regs::cr0_set() const
{
    mword set = 0;
c000e6a4:	31 ff                	xor    %edi,%edi
c000e6a6:	eb 09                	jmp    c000e6b1 <_ZN8Exc_regs8nst_ctrlI4VmcbEEvb+0x2b>

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
c000e6a8:	84 c0                	test   %al,%al
c000e6aa:	75 2a                	jne    c000e6d6 <_ZN8Exc_regs8nst_ctrlI4VmcbEEvb+0x50>
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
c000e6ac:	bf 01 00 01 80       	mov    $0x80010001,%edi
    if (!fpu_on)
        set |= Cpu::CR0_TS;
c000e6b1:	83 cf 08             	or     $0x8,%edi
template <typename T>
mword Exc_regs::get_cr0() const
{
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
c000e6b4:	89 fd                	mov    %edi,%ebp
c000e6b6:	f7 d5                	not    %ebp
c000e6b8:	23 ae 58 05 00 00    	and    0x558(%esi),%ebp
c000e6be:	23 7b 28             	and    0x28(%ebx),%edi
c000e6c1:	09 fd                	or     %edi,%ebp
}

template <typename T>
mword Exc_regs::get_cr3() const
{
    return nst_on ? get_g_cr3<T>() : cr3_shadow;
c000e6c3:	84 c9                	test   %cl,%cl
template <typename T>
mword Exc_regs::get_cr0() const
{
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
c000e6c5:	89 2c 24             	mov    %ebp,(%esp)
}

template <typename T>
mword Exc_regs::get_cr3() const
{
    return nst_on ? get_g_cr3<T>() : cr3_shadow;
c000e6c8:	74 26                	je     c000e6f0 <_ZN8Exc_regs8nst_ctrlI4VmcbEEvb+0x6a>
template <> mword Exc_regs::get_g_cs_dl<Vmcb>()         const { return static_cast<mword>(vmcb->cs.ar) >> 9 & 0x3; }
template <> mword Exc_regs::get_g_flags<Vmcb>()         const { return static_cast<mword>(vmcb->rflags); }
template <> mword Exc_regs::get_g_efer<Vmcb>()          const { return static_cast<mword>(vmcb->efer); }
template <> mword Exc_regs::get_g_cr0<Vmcb>()           const { return static_cast<mword>(vmcb->cr0); }
template <> mword Exc_regs::get_g_cr2<Vmcb>()           const { return static_cast<mword>(vmcb->cr2); }
template <> mword Exc_regs::get_g_cr3<Vmcb>()           const { return static_cast<mword>(vmcb->cr3); }
c000e6ca:	8b 8e 50 05 00 00    	mov    0x550(%esi),%ecx
template <typename T>
mword Exc_regs::cr4_msk() const
{
    mword clr = nst_on ? 0 :
#ifdef __i386__
                Cpu::CR4_PGE | Cpu::CR4_PAE;
c000e6d0:	31 ed                	xor    %ebp,%ebp
template <typename T>
mword Exc_regs::cr4_set() const
{
    mword set = nst_on ? 0 :
#ifdef __i386__
                Cpu::CR4_PSE;
c000e6d2:	31 ff                	xor    %edi,%edi
c000e6d4:	eb 27                	jmp    c000e6fd <_ZN8Exc_regs8nst_ctrlI4VmcbEEvb+0x77>
template <typename T>
mword Exc_regs::get_cr0() const
{
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
c000e6d6:	8b be 58 05 00 00    	mov    0x558(%esi),%edi
c000e6dc:	8b 4b 28             	mov    0x28(%ebx),%ecx
c000e6df:	81 e7 fe ff fe 7f    	and    $0x7ffefffe,%edi
c000e6e5:	81 e1 01 00 01 80    	and    $0x80010001,%ecx
c000e6eb:	09 cf                	or     %ecx,%edi
c000e6ed:	89 3c 24             	mov    %edi,(%esp)
}

template <typename T>
mword Exc_regs::get_cr3() const
{
    return nst_on ? get_g_cr3<T>() : cr3_shadow;
c000e6f0:	8b 4b 2c             	mov    0x2c(%ebx),%ecx
template <typename T>
mword Exc_regs::cr4_msk() const
{
    mword clr = nst_on ? 0 :
#ifdef __i386__
                Cpu::CR4_PGE | Cpu::CR4_PAE;
c000e6f3:	bd a0 00 00 00       	mov    $0xa0,%ebp
template <typename T>
mword Exc_regs::cr4_set() const
{
    mword set = nst_on ? 0 :
#ifdef __i386__
                Cpu::CR4_PSE;
c000e6f8:	bf 10 00 00 00       	mov    $0x10,%edi
                Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
                Cpu::CR4_PGE;
#endif

    return T::fix_cr4_clr | clr | cr4_set<T>();
c000e6fd:	09 ef                	or     %ebp,%edi
template <typename T>
mword Exc_regs::get_cr4() const
{
    mword msk = cr4_msk<T>();

    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
c000e6ff:	89 fd                	mov    %edi,%ebp
template <> void Exc_regs::nst_ctrl<Vmcb>(bool on)
{
    mword cr0 = get_cr0<Vmcb>();
    mword cr3 = get_cr3<Vmcb>();
    mword cr4 = get_cr4<Vmcb>();
    nst_on = Vmcb::has_npt() && on;
c000e701:	22 15 30 fa ff cf    	and    0xcffffa30,%dl
template <typename T>
mword Exc_regs::get_cr4() const
{
    mword msk = cr4_msk<T>();

    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
c000e707:	f7 d5                	not    %ebp
c000e709:	23 ae 48 05 00 00    	and    0x548(%esi),%ebp
c000e70f:	23 7b 30             	and    0x30(%ebx),%edi
template <> void Exc_regs::nst_ctrl<Vmcb>(bool on)
{
    mword cr0 = get_cr0<Vmcb>();
    mword cr3 = get_cr3<Vmcb>();
    mword cr4 = get_cr4<Vmcb>();
    nst_on = Vmcb::has_npt() && on;
c000e712:	80 e2 01             	and    $0x1,%dl
c000e715:	88 53 40             	mov    %dl,0x40(%ebx)
template <typename T>
mword Exc_regs::get_cr4() const
{
    mword msk = cr4_msk<T>();

    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
c000e718:	09 fd                	or     %edi,%ebp
template <typename T>
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
c000e71a:	84 d2                	test   %dl,%dl
template <typename T>
mword Exc_regs::get_cr4() const
{
    mword msk = cr4_msk<T>();

    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
c000e71c:	89 6c 24 04          	mov    %ebp,0x4(%esp)
template <typename T>
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
c000e720:	75 0b                	jne    c000e72d <_ZN8Exc_regs8nst_ctrlI4VmcbEEvb+0xa7>
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
c000e722:	84 c0                	test   %al,%al
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
c000e724:	bf 01 00 01 80       	mov    $0x80010001,%edi
    if (!fpu_on)
c000e729:	75 0f                	jne    c000e73a <_ZN8Exc_regs8nst_ctrlI4VmcbEEvb+0xb4>
c000e72b:	eb 0a                	jmp    c000e737 <_ZN8Exc_regs8nst_ctrlI4VmcbEEvb+0xb1>
c000e72d:	84 c0                	test   %al,%al
c000e72f:	0f 85 fb 00 00 00    	jne    c000e830 <_ZN8Exc_regs8nst_ctrlI4VmcbEEvb+0x1aa>
}

template <typename T>
mword Exc_regs::cr0_set() const
{
    mword set = 0;
c000e735:	31 ff                	xor    %edi,%edi

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
        set |= Cpu::CR0_TS;
c000e737:	83 cf 08             	or     $0x8,%edi
}

template <typename T>
void Exc_regs::set_cr0 (mword v)
{
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
c000e73a:	f7 d7                	not    %edi
c000e73c:	83 cf 01             	or     $0x1,%edi
c000e73f:	23 3c 24             	and    (%esp),%edi
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
c000e742:	80 fa 01             	cmp    $0x1,%dl
c000e745:	19 d2                	sbb    %edx,%edx
c000e747:	81 e2 01 00 01 80    	and    $0x80010001,%edx
    if (!fpu_on)
        set |= Cpu::CR0_TS;
c000e74d:	89 d5                	mov    %edx,%ebp
c000e74f:	83 cd 08             	or     $0x8,%ebp
c000e752:	84 c0                	test   %al,%al
c000e754:	0f 44 d5             	cmove  %ebp,%edx
}

template <typename T>
void Exc_regs::set_cr0 (mword v)
{
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
c000e757:	83 e2 fe             	and    $0xfffffffe,%edx
template <> void Exc_regs::set_g_cr2<Vmcs> (mword v)          { cr2 = v; }
template <> void Exc_regs::set_g_cr3<Vmcs> (mword v)    const { Vmcs::write (Vmcs::GUEST_CR3, v); }
template <> void Exc_regs::set_g_cr4<Vmcs> (mword v)    const { Vmcs::write (Vmcs::GUEST_CR4, v); }

template <> void Exc_regs::set_e_bmp<Vmcb> (uint32 v)   const { vmcb->intercept_exc = v; }
template <> void Exc_regs::set_s_cr0<Vmcb> (mword v)          { cr0_shadow = v; }
c000e75a:	8b 04 24             	mov    (%esp),%eax
}

template <typename T>
void Exc_regs::set_cr0 (mword v)
{
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
c000e75d:	09 d7                	or     %edx,%edi
template <> mword Exc_regs::get_g_cr0<Vmcs>()           const { return Vmcs::read (Vmcs::GUEST_CR0); }
template <> mword Exc_regs::get_g_cr2<Vmcs>()           const { return cr2; }
template <> mword Exc_regs::get_g_cr3<Vmcs>()           const { return Vmcs::read (Vmcs::GUEST_CR3); }
template <> mword Exc_regs::get_g_cr4<Vmcs>()           const { return Vmcs::read (Vmcs::GUEST_CR4); }

template <> void Exc_regs::set_g_cr0<Vmcb> (mword v)    const { vmcb->cr0 = v; }
c000e75f:	89 be 58 05 00 00    	mov    %edi,0x558(%esi)
c000e765:	c7 86 5c 05 00 00 00 	movl   $0x0,0x55c(%esi)
c000e76c:	00 00 00 
}

template <typename T>
void Exc_regs::set_cr3 (mword v)
{
    if (nst_on)
c000e76f:	80 7b 40 00          	cmpb   $0x0,0x40(%ebx)
template <> void Exc_regs::set_g_cr2<Vmcs> (mword v)          { cr2 = v; }
template <> void Exc_regs::set_g_cr3<Vmcs> (mword v)    const { Vmcs::write (Vmcs::GUEST_CR3, v); }
template <> void Exc_regs::set_g_cr4<Vmcs> (mword v)    const { Vmcs::write (Vmcs::GUEST_CR4, v); }

template <> void Exc_regs::set_e_bmp<Vmcb> (uint32 v)   const { vmcb->intercept_exc = v; }
template <> void Exc_regs::set_s_cr0<Vmcb> (mword v)          { cr0_shadow = v; }
c000e773:	89 43 28             	mov    %eax,0x28(%ebx)
}

template <typename T>
void Exc_regs::set_cr3 (mword v)
{
    if (nst_on)
c000e776:	74 15                	je     c000e78d <_ZN8Exc_regs8nst_ctrlI4VmcbEEvb+0x107>
template <> mword Exc_regs::get_g_cr3<Vmcs>()           const { return Vmcs::read (Vmcs::GUEST_CR3); }
template <> mword Exc_regs::get_g_cr4<Vmcs>()           const { return Vmcs::read (Vmcs::GUEST_CR4); }

template <> void Exc_regs::set_g_cr0<Vmcb> (mword v)    const { vmcb->cr0 = v; }
template <> void Exc_regs::set_g_cr2<Vmcb> (mword v)          { vmcb->cr2 = v; }
template <> void Exc_regs::set_g_cr3<Vmcb> (mword v)    const { vmcb->cr3 = v; }
c000e778:	8b 43 20             	mov    0x20(%ebx),%eax
c000e77b:	89 88 50 05 00 00    	mov    %ecx,0x550(%eax)
c000e781:	c7 80 54 05 00 00 00 	movl   $0x0,0x554(%eax)
c000e788:	00 00 00 
c000e78b:	eb 03                	jmp    c000e790 <_ZN8Exc_regs8nst_ctrlI4VmcbEEvb+0x10a>
void Exc_regs::set_cr3 (mword v)
{
    if (nst_on)
        set_g_cr3<T> (v);
    else
        cr3_shadow = v;
c000e78d:	89 4b 2c             	mov    %ecx,0x2c(%ebx)
c000e790:	8a 53 40             	mov    0x40(%ebx),%dl
template <> mword Exc_regs::get_g_cr4<Vmcs>()           const { return Vmcs::read (Vmcs::GUEST_CR4); }

template <> void Exc_regs::set_g_cr0<Vmcb> (mword v)    const { vmcb->cr0 = v; }
template <> void Exc_regs::set_g_cr2<Vmcb> (mword v)          { vmcb->cr2 = v; }
template <> void Exc_regs::set_g_cr3<Vmcb> (mword v)    const { vmcb->cr3 = v; }
template <> void Exc_regs::set_g_cr4<Vmcb> (mword v)    const { vmcb->cr4 = v; }
c000e793:	8b 4b 20             	mov    0x20(%ebx),%ecx
template <typename T>
mword Exc_regs::cr4_msk() const
{
    mword clr = nst_on ? 0 :
#ifdef __i386__
                Cpu::CR4_PGE | Cpu::CR4_PAE;
c000e796:	80 fa 01             	cmp    $0x1,%dl
c000e799:	19 c0                	sbb    %eax,%eax
c000e79b:	25 a0 00 00 00       	and    $0xa0,%eax
c000e7a0:	80 fa 01             	cmp    $0x1,%dl
c000e7a3:	19 d2                	sbb    %edx,%edx
c000e7a5:	83 e2 10             	and    $0x10,%edx
#else
                Cpu::CR4_PGE;
#endif

    return T::fix_cr4_clr | clr | cr4_set<T>();
c000e7a8:	09 d0                	or     %edx,%eax
}

template <typename T>
void Exc_regs::set_cr4 (mword v)
{
    set_g_cr4<T> ((v & ~cr4_msk<T>()) | cr4_set<T>());
c000e7aa:	f7 d0                	not    %eax
c000e7ac:	23 44 24 04          	and    0x4(%esp),%eax
template <> mword Exc_regs::get_g_cr4<Vmcs>()           const { return Vmcs::read (Vmcs::GUEST_CR4); }

template <> void Exc_regs::set_g_cr0<Vmcb> (mword v)    const { vmcb->cr0 = v; }
template <> void Exc_regs::set_g_cr2<Vmcb> (mword v)          { vmcb->cr2 = v; }
template <> void Exc_regs::set_g_cr3<Vmcb> (mword v)    const { vmcb->cr3 = v; }
template <> void Exc_regs::set_g_cr4<Vmcb> (mword v)    const { vmcb->cr4 = v; }
c000e7b0:	c7 81 4c 05 00 00 00 	movl   $0x0,0x54c(%ecx)
c000e7b7:	00 00 00 
}

template <typename T>
void Exc_regs::set_cr4 (mword v)
{
    set_g_cr4<T> ((v & ~cr4_msk<T>()) | cr4_set<T>());
c000e7ba:	09 d0                	or     %edx,%eax
template <> mword Exc_regs::get_g_cr4<Vmcs>()           const { return Vmcs::read (Vmcs::GUEST_CR4); }

template <> void Exc_regs::set_g_cr0<Vmcb> (mword v)    const { vmcb->cr0 = v; }
template <> void Exc_regs::set_g_cr2<Vmcb> (mword v)          { vmcb->cr2 = v; }
template <> void Exc_regs::set_g_cr3<Vmcb> (mword v)    const { vmcb->cr3 = v; }
template <> void Exc_regs::set_g_cr4<Vmcb> (mword v)    const { vmcb->cr4 = v; }
c000e7bc:	89 81 48 05 00 00    	mov    %eax,0x548(%ecx)
template <> void Exc_regs::set_g_cr3<Vmcs> (mword v)    const { Vmcs::write (Vmcs::GUEST_CR3, v); }
template <> void Exc_regs::set_g_cr4<Vmcs> (mword v)    const { Vmcs::write (Vmcs::GUEST_CR4, v); }

template <> void Exc_regs::set_e_bmp<Vmcb> (uint32 v)   const { vmcb->intercept_exc = v; }
template <> void Exc_regs::set_s_cr0<Vmcb> (mword v)          { cr0_shadow = v; }
template <> void Exc_regs::set_s_cr4<Vmcb> (mword v)          { cr4_shadow = v; }
c000e7c2:	8b 44 24 04          	mov    0x4(%esp),%eax
c000e7c6:	89 43 30             	mov    %eax,0x30(%ebx)
    nst_on = Vmcb::has_npt() && on;
    set_cr0<Vmcb> (cr0);
    set_cr3<Vmcb> (cr3);
    set_cr4<Vmcb> (cr4);

    svm_set_cpu_ctrl0 (vmcb->intercept_cpu[0]);
c000e7c9:	8b 43 20             	mov    0x20(%ebx),%eax
c000e7cc:	8b 50 0c             	mov    0xc(%eax),%edx
c000e7cf:	89 d8                	mov    %ebx,%eax
c000e7d1:	e8 c4 fd ff ff       	call   c000e59a <_ZN8Exc_regs17svm_set_cpu_ctrl0Em>
    svm_set_cpu_ctrl1 (vmcb->intercept_cpu[1]);
c000e7d6:	8b 43 20             	mov    0x20(%ebx),%eax
        vmcb->intercept_cpu[0] = static_cast<uint32>((val |  Vmcb::CPU_INVLPG) | Vmcb::force_ctrl0);
}

void Exc_regs::svm_set_cpu_ctrl1 (mword val)
{
    vmcb->intercept_cpu[1] = static_cast<uint32>(val | Vmcb::force_ctrl1);
c000e7d9:	83 48 10 6c          	orl    $0x6c,0x10(%eax)
void Exc_regs::set_exc() const
{
    unsigned msk = 1UL << Cpu::EXC_AC;

    if (!nst_on)
        msk |= 1UL << Cpu::EXC_PF;
c000e7dd:	80 7b 40 01          	cmpb   $0x1,0x40(%ebx)
c000e7e1:	19 c0                	sbb    %eax,%eax
c000e7e3:	25 00 40 00 00       	and    $0x4000,%eax
c000e7e8:	05 00 00 02 00       	add    $0x20000,%eax
    if (!fpu_on)
        msk |= 1UL << Cpu::EXC_NM;
c000e7ed:	89 c2                	mov    %eax,%edx
c000e7ef:	80 ca 80             	or     $0x80,%dl
c000e7f2:	80 7b 41 00          	cmpb   $0x0,0x41(%ebx)
c000e7f6:	0f 44 c2             	cmove  %edx,%eax
template <> void Exc_regs::set_g_cr0<Vmcs> (mword v)    const { Vmcs::write (Vmcs::GUEST_CR0, v); }
template <> void Exc_regs::set_g_cr2<Vmcs> (mword v)          { cr2 = v; }
template <> void Exc_regs::set_g_cr3<Vmcs> (mword v)    const { Vmcs::write (Vmcs::GUEST_CR3, v); }
template <> void Exc_regs::set_g_cr4<Vmcs> (mword v)    const { Vmcs::write (Vmcs::GUEST_CR4, v); }

template <> void Exc_regs::set_e_bmp<Vmcb> (uint32 v)   const { vmcb->intercept_exc = v; }
c000e7f9:	8b 53 20             	mov    0x20(%ebx),%edx
c000e7fc:	89 42 08             	mov    %eax,0x8(%edx)

    svm_set_cpu_ctrl0 (vmcb->intercept_cpu[0]);
    svm_set_cpu_ctrl1 (vmcb->intercept_cpu[1]);
    set_exc<Vmcb>();

    if (!nst_on)
c000e7ff:	80 7b 40 00          	cmpb   $0x0,0x40(%ebx)
c000e803:	75 35                	jne    c000e83a <_ZN8Exc_regs8nst_ctrlI4VmcbEEvb+0x1b4>
        }

        ALWAYS_INLINE
        inline mword virt_to_phys (mword virt)
        {
            return virt - reinterpret_cast<mword>(&OFFSET);
c000e805:	8b 43 24             	mov    0x24(%ebx),%eax
template <> mword Exc_regs::get_g_cr3<Vmcs>()           const { return Vmcs::read (Vmcs::GUEST_CR3); }
template <> mword Exc_regs::get_g_cr4<Vmcs>()           const { return Vmcs::read (Vmcs::GUEST_CR4); }

template <> void Exc_regs::set_g_cr0<Vmcb> (mword v)    const { vmcb->cr0 = v; }
template <> void Exc_regs::set_g_cr2<Vmcb> (mword v)          { vmcb->cr2 = v; }
template <> void Exc_regs::set_g_cr3<Vmcb> (mword v)    const { vmcb->cr3 = v; }
c000e808:	8b 53 20             	mov    0x20(%ebx),%edx
c000e80b:	2d 00 00 c0 bf       	sub    $0xbfc00000,%eax
c000e810:	89 82 50 05 00 00    	mov    %eax,0x550(%edx)
c000e816:	c7 82 54 05 00 00 00 	movl   $0x0,0x554(%edx)
c000e81d:	00 00 00 
c000e820:	eb 18                	jmp    c000e83a <_ZN8Exc_regs8nst_ctrlI4VmcbEEvb+0x1b4>
#include "vtlb.hpp"

template <> mword Exc_regs::get_g_cs_dl<Vmcb>()         const { return static_cast<mword>(vmcb->cs.ar) >> 9 & 0x3; }
template <> mword Exc_regs::get_g_flags<Vmcb>()         const { return static_cast<mword>(vmcb->rflags); }
template <> mword Exc_regs::get_g_efer<Vmcb>()          const { return static_cast<mword>(vmcb->efer); }
template <> mword Exc_regs::get_g_cr0<Vmcb>()           const { return static_cast<mword>(vmcb->cr0); }
c000e822:	8b 8e 58 05 00 00    	mov    0x558(%esi),%ecx
c000e828:	89 0c 24             	mov    %ecx,(%esp)
c000e82b:	e9 9a fe ff ff       	jmp    c000e6ca <_ZN8Exc_regs8nst_ctrlI4VmcbEEvb+0x44>
}

template <typename T>
void Exc_regs::set_cr0 (mword v)
{
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
c000e830:	8b 3c 24             	mov    (%esp),%edi
}

template <typename T>
mword Exc_regs::cr0_set() const
{
    mword set = 0;
c000e833:	31 d2                	xor    %edx,%edx
c000e835:	e9 1d ff ff ff       	jmp    c000e757 <_ZN8Exc_regs8nst_ctrlI4VmcbEEvb+0xd1>
    svm_set_cpu_ctrl1 (vmcb->intercept_cpu[1]);
    set_exc<Vmcb>();

    if (!nst_on)
        set_g_cr3<Vmcb> (Buddy::ptr_to_phys (vtlb));
}
c000e83a:	83 c4 08             	add    $0x8,%esp
c000e83d:	5b                   	pop    %ebx
c000e83e:	5e                   	pop    %esi
c000e83f:	5f                   	pop    %edi
c000e840:	5d                   	pop    %ebp
c000e841:	c3                   	ret    

c000e842 <_ZN8Exc_regs8nst_ctrlI4VmcsEEvb>:

template <> void Exc_regs::nst_ctrl<Vmcs>(bool on)
{
c000e842:	55                   	push   %ebp
c000e843:	57                   	push   %edi
c000e844:	56                   	push   %esi
c000e845:	53                   	push   %ebx
c000e846:	89 c3                	mov    %eax,%ebx
c000e848:	83 ec 18             	sub    $0x18,%esp
    assert (Vmcs::current == vmcs);
c000e84b:	8b 40 20             	mov    0x20(%eax),%eax
c000e84e:	39 05 14 f0 ff cf    	cmp    %eax,0xcffff014
c000e854:	74 1e                	je     c000e874 <_ZN8Exc_regs8nst_ctrlI4VmcsEEvb+0x32>
c000e856:	68 00 8d 01 c0       	push   $0xc0018d00
c000e85b:	68 1a 01 00 00       	push   $0x11a
c000e860:	68 43 8c 01 c0       	push   $0xc0018c43
c000e865:	68 b0 8c 01 c0       	push   $0xc0018cb0
c000e86a:	68 69 60 01 c0       	push   $0xc0016069
c000e86f:	e8 d2 30 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>
c000e874:	8a 4b 40             	mov    0x40(%ebx),%cl
c000e877:	8a 43 41             	mov    0x41(%ebx),%al
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
c000e87a:	80 f9 01             	cmp    $0x1,%cl
c000e87d:	19 f6                	sbb    %esi,%esi
c000e87f:	81 e6 01 00 01 80    	and    $0x80010001,%esi
    if (!fpu_on)
        set |= Cpu::CR0_TS;
c000e885:	89 f7                	mov    %esi,%edi
c000e887:	83 cf 08             	or     $0x8,%edi
c000e88a:	84 c0                	test   %al,%al
c000e88c:	0f 44 f7             	cmove  %edi,%esi

    return T::fix_cr0_set | set;
c000e88f:	8b 3d 34 fb ff cf    	mov    0xcffffb34,%edi
c000e895:	89 7c 24 0c          	mov    %edi,0xc(%esp)
c000e899:	0b 3d 30 fb ff cf    	or     0xcffffb30,%edi
c000e89f:	89 7c 24 04          	mov    %edi,0x4(%esp)
}

template <typename T>
mword Exc_regs::cr0_msk() const
{
    return T::fix_cr0_clr | cr0_set<T>();
c000e8a3:	09 fe                	or     %edi,%esi

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
c000e8a5:	bf 00 68 00 00       	mov    $0x6800,%edi
c000e8aa:	0f 78 ff             	vmread %edi,%edi
template <typename T>
mword Exc_regs::get_cr0() const
{
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
c000e8ad:	89 f5                	mov    %esi,%ebp
c000e8af:	23 73 28             	and    0x28(%ebx),%esi
c000e8b2:	f7 d5                	not    %ebp
c000e8b4:	21 ef                	and    %ebp,%edi
c000e8b6:	09 f7                	or     %esi,%edi
}

template <typename T>
mword Exc_regs::get_cr3() const
{
    return nst_on ? get_g_cr3<T>() : cr3_shadow;
c000e8b8:	84 c9                	test   %cl,%cl
template <typename T>
mword Exc_regs::get_cr0() const
{
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
c000e8ba:	89 3c 24             	mov    %edi,(%esp)
}

template <typename T>
mword Exc_regs::get_cr3() const
{
    return nst_on ? get_g_cr3<T>() : cr3_shadow;
c000e8bd:	74 0e                	je     c000e8cd <_ZN8Exc_regs8nst_ctrlI4VmcsEEvb+0x8b>
c000e8bf:	be 02 68 00 00       	mov    $0x6802,%esi
c000e8c4:	0f 78 74 24 08       	vmread %esi,0x8(%esp)
template <typename T>
mword Exc_regs::cr4_msk() const
{
    mword clr = nst_on ? 0 :
#ifdef __i386__
                Cpu::CR4_PGE | Cpu::CR4_PAE;
c000e8c9:	31 ff                	xor    %edi,%edi
c000e8cb:	eb 0c                	jmp    c000e8d9 <_ZN8Exc_regs8nst_ctrlI4VmcsEEvb+0x97>
}

template <typename T>
mword Exc_regs::get_cr3() const
{
    return nst_on ? get_g_cr3<T>() : cr3_shadow;
c000e8cd:	8b 7b 2c             	mov    0x2c(%ebx),%edi
c000e8d0:	89 7c 24 08          	mov    %edi,0x8(%esp)
template <typename T>
mword Exc_regs::cr4_msk() const
{
    mword clr = nst_on ? 0 :
#ifdef __i386__
                Cpu::CR4_PGE | Cpu::CR4_PAE;
c000e8d4:	bf a0 00 00 00       	mov    $0xa0,%edi
                Cpu::CR4_PSE;
#else
                Cpu::CR4_PSE | Cpu::CR4_PAE;
#endif

    return T::fix_cr4_set | set;
c000e8d9:	8b 35 2c fb ff cf    	mov    0xcffffb2c,%esi
template <typename T>
mword Exc_regs::cr4_set() const
{
    mword set = nst_on ? 0 :
#ifdef __i386__
                Cpu::CR4_PSE;
c000e8df:	80 f9 01             	cmp    $0x1,%cl
c000e8e2:	19 ed                	sbb    %ebp,%ebp
c000e8e4:	83 e5 10             	and    $0x10,%ebp
#else
                Cpu::CR4_PSE | Cpu::CR4_PAE;
#endif

    return T::fix_cr4_set | set;
c000e8e7:	89 74 24 10          	mov    %esi,0x10(%esp)
c000e8eb:	0b 35 28 fb ff cf    	or     0xcffffb28,%esi
c000e8f1:	09 f7                	or     %esi,%edi
c000e8f3:	89 f9                	mov    %edi,%ecx
c000e8f5:	89 74 24 14          	mov    %esi,0x14(%esp)
                Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
                Cpu::CR4_PGE;
#endif

    return T::fix_cr4_clr | clr | cr4_set<T>();
c000e8f9:	09 e9                	or     %ebp,%ecx
c000e8fb:	be 04 68 00 00       	mov    $0x6804,%esi
c000e900:	0f 78 f6             	vmread %esi,%esi
template <typename T>
mword Exc_regs::get_cr4() const
{
    mword msk = cr4_msk<T>();

    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
c000e903:	89 cf                	mov    %ecx,%edi
c000e905:	23 4b 30             	and    0x30(%ebx),%ecx
c000e908:	f7 d7                	not    %edi
c000e90a:	21 fe                	and    %edi,%esi
c000e90c:	09 ce                	or     %ecx,%esi
    assert (Vmcs::current == vmcs);

    mword cr0 = get_cr0<Vmcs>();
    mword cr3 = get_cr3<Vmcs>();
    mword cr4 = get_cr4<Vmcs>();
    nst_on = Vmcs::has_ept() && on;
c000e90e:	8b 0d 54 fb ff cf    	mov    0xcffffb54,%ecx
c000e914:	d1 e9                	shr    %ecx
c000e916:	80 e1 01             	and    $0x1,%cl
c000e919:	20 ca                	and    %cl,%dl
template <typename T>
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
c000e91b:	84 d2                	test   %dl,%dl
    assert (Vmcs::current == vmcs);

    mword cr0 = get_cr0<Vmcs>();
    mword cr3 = get_cr3<Vmcs>();
    mword cr4 = get_cr4<Vmcs>();
    nst_on = Vmcs::has_ept() && on;
c000e91d:	88 53 40             	mov    %dl,0x40(%ebx)
template <typename T>
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
c000e920:	75 0b                	jne    c000e92d <_ZN8Exc_regs8nst_ctrlI4VmcsEEvb+0xeb>
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
c000e922:	84 c0                	test   %al,%al
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
c000e924:	b9 01 00 01 80       	mov    $0x80010001,%ecx
    if (!fpu_on)
c000e929:	75 0f                	jne    c000e93a <_ZN8Exc_regs8nst_ctrlI4VmcsEEvb+0xf8>
c000e92b:	eb 0a                	jmp    c000e937 <_ZN8Exc_regs8nst_ctrlI4VmcsEEvb+0xf5>
c000e92d:	84 c0                	test   %al,%al
c000e92f:	0f 85 48 01 00 00    	jne    c000ea7d <_ZN8Exc_regs8nst_ctrlI4VmcsEEvb+0x23b>
}

template <typename T>
mword Exc_regs::cr0_set() const
{
    mword set = 0;
c000e935:	31 c9                	xor    %ecx,%ecx

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
        set |= Cpu::CR0_TS;
c000e937:	83 c9 08             	or     $0x8,%ecx
}

template <typename T>
mword Exc_regs::cr0_msk() const
{
    return T::fix_cr0_clr | cr0_set<T>();
c000e93a:	0b 4c 24 04          	or     0x4(%esp),%ecx
}

template <typename T>
void Exc_regs::set_cr0 (mword v)
{
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
c000e93e:	f7 d1                	not    %ecx
c000e940:	83 c9 01             	or     $0x1,%ecx
c000e943:	23 0c 24             	and    (%esp),%ecx
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
c000e946:	80 fa 01             	cmp    $0x1,%dl
c000e949:	19 ff                	sbb    %edi,%edi
c000e94b:	81 e7 01 00 01 80    	and    $0x80010001,%edi
    if (!fpu_on)
        set |= Cpu::CR0_TS;
c000e951:	89 fd                	mov    %edi,%ebp
c000e953:	83 cd 08             	or     $0x8,%ebp
c000e956:	84 c0                	test   %al,%al
c000e958:	0f 44 fd             	cmove  %ebp,%edi

    return T::fix_cr0_set | set;
c000e95b:	0b 7c 24 0c          	or     0xc(%esp),%edi
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
c000e95f:	b8 00 68 00 00       	mov    $0x6800,%eax
}

template <typename T>
void Exc_regs::set_cr0 (mword v)
{
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
c000e964:	83 e7 fe             	and    $0xfffffffe,%edi
c000e967:	09 f9                	or     %edi,%ecx
c000e969:	0f 79 c1             	vmwrite %ecx,%eax
template <> void Exc_regs::set_e_bmp<Vmcb> (uint32 v)   const { vmcb->intercept_exc = v; }
template <> void Exc_regs::set_s_cr0<Vmcb> (mword v)          { cr0_shadow = v; }
template <> void Exc_regs::set_s_cr4<Vmcb> (mword v)          { cr4_shadow = v; }

template <> void Exc_regs::set_e_bmp<Vmcs> (uint32 v)   const { Vmcs::write (Vmcs::EXC_BITMAP, v); }
template <> void Exc_regs::set_s_cr0<Vmcs> (mword v)          { Vmcs::write (Vmcs::CR0_READ_SHADOW, cr0_shadow = v); }
c000e96c:	8b 04 24             	mov    (%esp),%eax
c000e96f:	89 43 28             	mov    %eax,0x28(%ebx)
c000e972:	b8 04 60 00 00       	mov    $0x6004,%eax
c000e977:	0f 79 04 24          	vmwrite (%esp),%eax
}

template <typename T>
void Exc_regs::set_cr3 (mword v)
{
    if (nst_on)
c000e97b:	84 d2                	test   %dl,%dl
c000e97d:	74 10                	je     c000e98f <_ZN8Exc_regs8nst_ctrlI4VmcsEEvb+0x14d>
c000e97f:	66 b8 02 68          	mov    $0x6802,%ax
c000e983:	0f 79 44 24 08       	vmwrite 0x8(%esp),%eax
template <typename T>
mword Exc_regs::cr4_msk() const
{
    mword clr = nst_on ? 0 :
#ifdef __i386__
                Cpu::CR4_PGE | Cpu::CR4_PAE;
c000e988:	31 c9                	xor    %ecx,%ecx
template <typename T>
mword Exc_regs::cr4_set() const
{
    mword set = nst_on ? 0 :
#ifdef __i386__
                Cpu::CR4_PSE;
c000e98a:	66 31 c0             	xor    %ax,%ax
c000e98d:	eb 11                	jmp    c000e9a0 <_ZN8Exc_regs8nst_ctrlI4VmcsEEvb+0x15e>
void Exc_regs::set_cr3 (mword v)
{
    if (nst_on)
        set_g_cr3<T> (v);
    else
        cr3_shadow = v;
c000e98f:	8b 44 24 08          	mov    0x8(%esp),%eax
template <typename T>
mword Exc_regs::cr4_msk() const
{
    mword clr = nst_on ? 0 :
#ifdef __i386__
                Cpu::CR4_PGE | Cpu::CR4_PAE;
c000e993:	b9 a0 00 00 00       	mov    $0xa0,%ecx
void Exc_regs::set_cr3 (mword v)
{
    if (nst_on)
        set_g_cr3<T> (v);
    else
        cr3_shadow = v;
c000e998:	89 43 2c             	mov    %eax,0x2c(%ebx)
template <typename T>
mword Exc_regs::cr4_set() const
{
    mword set = nst_on ? 0 :
#ifdef __i386__
                Cpu::CR4_PSE;
c000e99b:	b8 10 00 00 00       	mov    $0x10,%eax
c000e9a0:	0b 4c 24 14          	or     0x14(%esp),%ecx
                Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
                Cpu::CR4_PGE;
#endif

    return T::fix_cr4_clr | clr | cr4_set<T>();
c000e9a4:	09 c8                	or     %ecx,%eax
}

template <typename T>
void Exc_regs::set_cr4 (mword v)
{
    set_g_cr4<T> ((v & ~cr4_msk<T>()) | cr4_set<T>());
c000e9a6:	f7 d0                	not    %eax
c000e9a8:	21 f0                	and    %esi,%eax
template <typename T>
mword Exc_regs::cr4_set() const
{
    mword set = nst_on ? 0 :
#ifdef __i386__
                Cpu::CR4_PSE;
c000e9aa:	80 fa 01             	cmp    $0x1,%dl
c000e9ad:	19 d2                	sbb    %edx,%edx
c000e9af:	0b 44 24 10          	or     0x10(%esp),%eax
c000e9b3:	83 e2 10             	and    $0x10,%edx
}

template <typename T>
void Exc_regs::set_cr4 (mword v)
{
    set_g_cr4<T> ((v & ~cr4_msk<T>()) | cr4_set<T>());
c000e9b6:	09 d0                	or     %edx,%eax
c000e9b8:	ba 04 68 00 00       	mov    $0x6804,%edx
c000e9bd:	0f 79 d0             	vmwrite %eax,%edx
c000e9c0:	b8 06 60 00 00       	mov    $0x6006,%eax
template <> void Exc_regs::set_s_cr0<Vmcb> (mword v)          { cr0_shadow = v; }
template <> void Exc_regs::set_s_cr4<Vmcb> (mword v)          { cr4_shadow = v; }

template <> void Exc_regs::set_e_bmp<Vmcs> (uint32 v)   const { Vmcs::write (Vmcs::EXC_BITMAP, v); }
template <> void Exc_regs::set_s_cr0<Vmcs> (mword v)          { Vmcs::write (Vmcs::CR0_READ_SHADOW, cr0_shadow = v); }
template <> void Exc_regs::set_s_cr4<Vmcs> (mword v)          { Vmcs::write (Vmcs::CR4_READ_SHADOW, cr4_shadow = v); }
c000e9c5:	89 73 30             	mov    %esi,0x30(%ebx)
c000e9c8:	0f 79 c6             	vmwrite %esi,%eax

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
c000e9cb:	66 ba 02 40          	mov    $0x4002,%dx
c000e9cf:	0f 78 d2             	vmread %edx,%edx
    nst_on = Vmcs::has_ept() && on;
    set_cr0<Vmcs> (cr0);
    set_cr3<Vmcs> (cr3);
    set_cr4<Vmcs> (cr4);

    vmx_set_cpu_ctrl0 (Vmcs::read (Vmcs::CPU_EXEC_CTRL0));
c000e9d2:	89 d8                	mov    %ebx,%eax
c000e9d4:	e8 5f fc ff ff       	call   c000e638 <_ZN8Exc_regs17vmx_set_cpu_ctrl0Em>
c000e9d9:	ba 1e 40 00 00       	mov    $0x401e,%edx
c000e9de:	0f 78 d2             	vmread %edx,%edx
    vmx_set_cpu_ctrl1 (Vmcs::read (Vmcs::CPU_EXEC_CTRL1));
c000e9e1:	89 d8                	mov    %ebx,%eax
c000e9e3:	e8 7a fc ff ff       	call   c000e662 <_ZN8Exc_regs17vmx_set_cpu_ctrl1Em>
template <typename T>
void Exc_regs::set_exc() const
{
    unsigned msk = 1UL << Cpu::EXC_AC;

    if (!nst_on)
c000e9e8:	8a 53 40             	mov    0x40(%ebx),%dl
        msk |= 1UL << Cpu::EXC_PF;
    if (!fpu_on)
c000e9eb:	8a 4b 41             	mov    0x41(%ebx),%cl
void Exc_regs::set_exc() const
{
    unsigned msk = 1UL << Cpu::EXC_AC;

    if (!nst_on)
        msk |= 1UL << Cpu::EXC_PF;
c000e9ee:	80 fa 01             	cmp    $0x1,%dl
c000e9f1:	19 c0                	sbb    %eax,%eax
c000e9f3:	25 00 40 00 00       	and    $0x4000,%eax
c000e9f8:	05 00 00 02 00       	add    $0x20000,%eax
    if (!fpu_on)
        msk |= 1UL << Cpu::EXC_NM;
c000e9fd:	89 c6                	mov    %eax,%esi
c000e9ff:	81 ce 80 00 00 00    	or     $0x80,%esi
c000ea05:	84 c9                	test   %cl,%cl
c000ea07:	0f 44 c6             	cmove  %esi,%eax
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
c000ea0a:	be 04 40 00 00       	mov    $0x4004,%esi
c000ea0f:	0f 79 f0             	vmwrite %eax,%esi
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
c000ea12:	80 fa 01             	cmp    $0x1,%dl
c000ea15:	19 c0                	sbb    %eax,%eax
c000ea17:	25 01 00 01 80       	and    $0x80010001,%eax
    if (!fpu_on)
        set |= Cpu::CR0_TS;
c000ea1c:	89 c6                	mov    %eax,%esi
c000ea1e:	83 ce 08             	or     $0x8,%esi
c000ea21:	84 c9                	test   %cl,%cl
c000ea23:	8b 0d 30 fb ff cf    	mov    0xcffffb30,%ecx
c000ea29:	0f 44 c6             	cmove  %esi,%eax
c000ea2c:	0b 0d 34 fb ff cf    	or     0xcffffb34,%ecx
}

template <typename T>
mword Exc_regs::cr0_msk() const
{
    return T::fix_cr0_clr | cr0_set<T>();
c000ea32:	09 c8                	or     %ecx,%eax
c000ea34:	b9 00 60 00 00       	mov    $0x6000,%ecx
c000ea39:	0f 79 c8             	vmwrite %eax,%ecx
template <typename T>
mword Exc_regs::cr4_msk() const
{
    mword clr = nst_on ? 0 :
#ifdef __i386__
                Cpu::CR4_PGE | Cpu::CR4_PAE;
c000ea3c:	80 fa 01             	cmp    $0x1,%dl
c000ea3f:	8b 35 28 fb ff cf    	mov    0xcffffb28,%esi
c000ea45:	19 c9                	sbb    %ecx,%ecx
c000ea47:	81 e1 a0 00 00 00    	and    $0xa0,%ecx
template <typename T>
mword Exc_regs::cr4_set() const
{
    mword set = nst_on ? 0 :
#ifdef __i386__
                Cpu::CR4_PSE;
c000ea4d:	80 fa 01             	cmp    $0x1,%dl
c000ea50:	19 c0                	sbb    %eax,%eax
c000ea52:	0b 35 2c fb ff cf    	or     0xcffffb2c,%esi
c000ea58:	83 e0 10             	and    $0x10,%eax
c000ea5b:	09 f1                	or     %esi,%ecx
                Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
                Cpu::CR4_PGE;
#endif

    return T::fix_cr4_clr | clr | cr4_set<T>();
c000ea5d:	09 c8                	or     %ecx,%eax
c000ea5f:	b9 02 60 00 00       	mov    $0x6002,%ecx
c000ea64:	0f 79 c8             	vmwrite %eax,%ecx
    set_exc<Vmcs>();

    Vmcs::write (Vmcs::CR0_MASK, cr0_msk<Vmcs>());
    Vmcs::write (Vmcs::CR4_MASK, cr4_msk<Vmcs>());

    if (!nst_on)
c000ea67:	84 d2                	test   %dl,%dl
c000ea69:	75 25                	jne    c000ea90 <_ZN8Exc_regs8nst_ctrlI4VmcsEEvb+0x24e>
c000ea6b:	8b 43 24             	mov    0x24(%ebx),%eax
c000ea6e:	ba 02 68 00 00       	mov    $0x6802,%edx
c000ea73:	2d 00 00 c0 bf       	sub    $0xbfc00000,%eax
c000ea78:	0f 79 d0             	vmwrite %eax,%edx
c000ea7b:	eb 13                	jmp    c000ea90 <_ZN8Exc_regs8nst_ctrlI4VmcsEEvb+0x24e>
}

template <typename T>
void Exc_regs::set_cr0 (mword v)
{
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
c000ea7d:	8b 4c 24 04          	mov    0x4(%esp),%ecx
}

template <typename T>
mword Exc_regs::cr0_set() const
{
    mword set = 0;
c000ea81:	31 ff                	xor    %edi,%edi
}

template <typename T>
void Exc_regs::set_cr0 (mword v)
{
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
c000ea83:	f7 d1                	not    %ecx
c000ea85:	83 c9 01             	or     $0x1,%ecx
c000ea88:	23 0c 24             	and    (%esp),%ecx
c000ea8b:	e9 cb fe ff ff       	jmp    c000e95b <_ZN8Exc_regs8nst_ctrlI4VmcsEEvb+0x119>
    Vmcs::write (Vmcs::CR0_MASK, cr0_msk<Vmcs>());
    Vmcs::write (Vmcs::CR4_MASK, cr4_msk<Vmcs>());

    if (!nst_on)
        set_g_cr3<Vmcs> (Buddy::ptr_to_phys (vtlb));
}
c000ea90:	83 c4 18             	add    $0x18,%esp
c000ea93:	5b                   	pop    %ebx
c000ea94:	5e                   	pop    %esi
c000ea95:	5f                   	pop    %edi
c000ea96:	5d                   	pop    %ebp
c000ea97:	c3                   	ret    

c000ea98 <_ZN8Exc_regs8fpu_ctrlEb>:

void Exc_regs::fpu_ctrl (bool on)
{
c000ea98:	55                   	push   %ebp
c000ea99:	57                   	push   %edi
c000ea9a:	89 d7                	mov    %edx,%edi
c000ea9c:	56                   	push   %esi
c000ea9d:	53                   	push   %ebx
c000ea9e:	83 ec 10             	sub    $0x10,%esp
    if (Hip::feature() & Hip::FEAT_VMX) {
c000eaa1:	f6 05 10 e0 01 c0 02 	testb  $0x2,0xc001e010
    if (!nst_on)
        set_g_cr3<Vmcs> (Buddy::ptr_to_phys (vtlb));
}

void Exc_regs::fpu_ctrl (bool on)
{
c000eaa8:	88 54 24 03          	mov    %dl,0x3(%esp)
    if (Hip::feature() & Hip::FEAT_VMX) {
c000eaac:	0f 84 44 01 00 00    	je     c000ebf6 <_ZN8Exc_regs8fpu_ctrlEb+0x15e>

        vmcs->make_current();
c000eab2:	8b 50 20             	mov    0x20(%eax),%edx
        }

        ALWAYS_INLINE
        inline void make_current()
        {
            if (EXPECT_TRUE (current == this))
c000eab5:	39 15 14 f0 ff cf    	cmp    %edx,0xcffff014
c000eabb:	74 42                	je     c000eaff <_ZN8Exc_regs8fpu_ctrlEb+0x67>
                return;

            uint64 phys = Buddy::ptr_to_phys (current = this);
c000eabd:	89 15 14 f0 ff cf    	mov    %edx,0xcffff014
c000eac3:	81 ea 00 00 c0 bf    	sub    $0xbfc00000,%edx
c000eac9:	89 54 24 08          	mov    %edx,0x8(%esp)
c000eacd:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c000ead4:	00 

            bool ret;
            asm volatile ("vmptrld %1; seta %0" : "=q" (ret) : "m" (phys) : "cc");
c000ead5:	0f c7 74 24 08       	vmptrld 0x8(%esp)
c000eada:	0f 97 c2             	seta   %dl
            assert (ret);
c000eadd:	84 d2                	test   %dl,%dl
c000eadf:	75 1e                	jne    c000eaff <_ZN8Exc_regs8fpu_ctrlEb+0x67>
c000eae1:	68 c8 8c 01 c0       	push   $0xc0018cc8
c000eae6:	68 96 01 00 00       	push   $0x196
c000eaeb:	68 13 69 01 c0       	push   $0xc0016913
c000eaf0:	68 83 69 01 c0       	push   $0xc0016983
c000eaf5:	68 69 60 01 c0       	push   $0xc0016069
c000eafa:	e8 47 2e ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>
c000eaff:	8a 48 40             	mov    0x40(%eax),%cl
    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
        set |= Cpu::CR0_TS;

    return T::fix_cr0_set | set;
c000eb02:	8b 2d 34 fb ff cf    	mov    0xcffffb34,%ebp
c000eb08:	8b 35 30 fb ff cf    	mov    0xcffffb30,%esi
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
c000eb0e:	80 f9 01             	cmp    $0x1,%cl
c000eb11:	19 db                	sbb    %ebx,%ebx
c000eb13:	81 e3 01 00 01 80    	and    $0x80010001,%ebx
    if (!fpu_on)
        set |= Cpu::CR0_TS;
c000eb19:	89 da                	mov    %ebx,%edx
c000eb1b:	83 ca 08             	or     $0x8,%edx
c000eb1e:	80 78 41 00          	cmpb   $0x0,0x41(%eax)
c000eb22:	0f 44 da             	cmove  %edx,%ebx
c000eb25:	09 ee                	or     %ebp,%esi
}

template <typename T>
mword Exc_regs::cr0_msk() const
{
    return T::fix_cr0_clr | cr0_set<T>();
c000eb27:	09 f3                	or     %esi,%ebx

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
c000eb29:	ba 00 68 00 00       	mov    $0x6800,%edx
c000eb2e:	0f 78 d2             	vmread %edx,%edx
template <typename T>
mword Exc_regs::get_cr0() const
{
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
c000eb31:	89 df                	mov    %ebx,%edi
c000eb33:	23 58 28             	and    0x28(%eax),%ebx
c000eb36:	f7 d7                	not    %edi
c000eb38:	21 fa                	and    %edi,%edx
c000eb3a:	09 da                	or     %ebx,%edx
    if (Hip::feature() & Hip::FEAT_VMX) {

        vmcs->make_current();

        mword cr0 = get_cr0<Vmcs>();
        fpu_on = on;
c000eb3c:	8a 5c 24 03          	mov    0x3(%esp),%bl
template <typename T>
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
c000eb40:	84 c9                	test   %cl,%cl
template <typename T>
mword Exc_regs::get_cr0() const
{
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
c000eb42:	89 54 24 04          	mov    %edx,0x4(%esp)
    if (Hip::feature() & Hip::FEAT_VMX) {

        vmcs->make_current();

        mword cr0 = get_cr0<Vmcs>();
        fpu_on = on;
c000eb46:	88 58 41             	mov    %bl,0x41(%eax)
template <typename T>
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
c000eb49:	75 0e                	jne    c000eb59 <_ZN8Exc_regs8fpu_ctrlEb+0xc1>
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
c000eb4b:	80 7c 24 03 00       	cmpb   $0x0,0x3(%esp)
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
c000eb50:	bb 01 00 01 80       	mov    $0x80010001,%ebx
    if (!fpu_on)
c000eb55:	75 12                	jne    c000eb69 <_ZN8Exc_regs8fpu_ctrlEb+0xd1>
c000eb57:	eb 0d                	jmp    c000eb66 <_ZN8Exc_regs8fpu_ctrlEb+0xce>
c000eb59:	80 7c 24 03 00       	cmpb   $0x0,0x3(%esp)
c000eb5e:	0f 85 a8 00 00 00    	jne    c000ec0c <_ZN8Exc_regs8fpu_ctrlEb+0x174>
}

template <typename T>
mword Exc_regs::cr0_set() const
{
    mword set = 0;
c000eb64:	31 db                	xor    %ebx,%ebx

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
        set |= Cpu::CR0_TS;
c000eb66:	83 cb 08             	or     $0x8,%ebx
}

template <typename T>
void Exc_regs::set_cr0 (mword v)
{
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
c000eb69:	8b 7c 24 04          	mov    0x4(%esp),%edi
}

template <typename T>
mword Exc_regs::cr0_msk() const
{
    return T::fix_cr0_clr | cr0_set<T>();
c000eb6d:	09 f3                	or     %esi,%ebx
}

template <typename T>
void Exc_regs::set_cr0 (mword v)
{
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
c000eb6f:	f7 d3                	not    %ebx
c000eb71:	83 cb 01             	or     $0x1,%ebx
c000eb74:	21 df                	and    %ebx,%edi
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
c000eb76:	80 f9 01             	cmp    $0x1,%cl
c000eb79:	19 db                	sbb    %ebx,%ebx
c000eb7b:	81 e3 01 00 01 80    	and    $0x80010001,%ebx
    if (!fpu_on)
        set |= Cpu::CR0_TS;
c000eb81:	89 da                	mov    %ebx,%edx
c000eb83:	83 ca 08             	or     $0x8,%edx
c000eb86:	80 7c 24 03 00       	cmpb   $0x0,0x3(%esp)
c000eb8b:	0f 44 da             	cmove  %edx,%ebx

    return T::fix_cr0_set | set;
c000eb8e:	09 eb                	or     %ebp,%ebx
}

template <typename T>
void Exc_regs::set_cr0 (mword v)
{
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
c000eb90:	83 e3 fe             	and    $0xfffffffe,%ebx
c000eb93:	09 fb                	or     %edi,%ebx
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
c000eb95:	bf 00 68 00 00       	mov    $0x6800,%edi
c000eb9a:	0f 79 fb             	vmwrite %ebx,%edi
template <> void Exc_regs::set_e_bmp<Vmcb> (uint32 v)   const { vmcb->intercept_exc = v; }
template <> void Exc_regs::set_s_cr0<Vmcb> (mword v)          { cr0_shadow = v; }
template <> void Exc_regs::set_s_cr4<Vmcb> (mword v)          { cr4_shadow = v; }

template <> void Exc_regs::set_e_bmp<Vmcs> (uint32 v)   const { Vmcs::write (Vmcs::EXC_BITMAP, v); }
template <> void Exc_regs::set_s_cr0<Vmcs> (mword v)          { Vmcs::write (Vmcs::CR0_READ_SHADOW, cr0_shadow = v); }
c000eb9d:	8b 7c 24 04          	mov    0x4(%esp),%edi
c000eba1:	89 78 28             	mov    %edi,0x28(%eax)
c000eba4:	b8 04 60 00 00       	mov    $0x6004,%eax
c000eba9:	0f 79 c7             	vmwrite %edi,%eax
void Exc_regs::set_exc() const
{
    unsigned msk = 1UL << Cpu::EXC_AC;

    if (!nst_on)
        msk |= 1UL << Cpu::EXC_PF;
c000ebac:	80 f9 01             	cmp    $0x1,%cl
c000ebaf:	19 c0                	sbb    %eax,%eax
c000ebb1:	25 00 40 00 00       	and    $0x4000,%eax
c000ebb6:	05 00 00 02 00       	add    $0x20000,%eax
    if (!fpu_on)
        msk |= 1UL << Cpu::EXC_NM;
c000ebbb:	89 c2                	mov    %eax,%edx
c000ebbd:	80 ca 80             	or     $0x80,%dl
c000ebc0:	80 7c 24 03 00       	cmpb   $0x0,0x3(%esp)
c000ebc5:	0f 44 c2             	cmove  %edx,%eax
c000ebc8:	ba 04 40 00 00       	mov    $0x4004,%edx
c000ebcd:	0f 79 d0             	vmwrite %eax,%edx
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
c000ebd0:	80 f9 01             	cmp    $0x1,%cl
c000ebd3:	19 c0                	sbb    %eax,%eax
c000ebd5:	25 01 00 01 80       	and    $0x80010001,%eax
    if (!fpu_on)
        set |= Cpu::CR0_TS;
c000ebda:	89 c2                	mov    %eax,%edx
c000ebdc:	83 ca 08             	or     $0x8,%edx
c000ebdf:	80 7c 24 03 00       	cmpb   $0x0,0x3(%esp)
c000ebe4:	0f 44 c2             	cmove  %edx,%eax
}

template <typename T>
mword Exc_regs::cr0_msk() const
{
    return T::fix_cr0_clr | cr0_set<T>();
c000ebe7:	09 c6                	or     %eax,%esi
c000ebe9:	b8 00 60 00 00       	mov    $0x6000,%eax
c000ebee:	0f 79 c6             	vmwrite %esi,%eax
c000ebf1:	e9 2b 01 00 00       	jmp    c000ed21 <_ZN8Exc_regs8fpu_ctrlEb+0x289>
c000ebf6:	8a 48 40             	mov    0x40(%eax),%cl
c000ebf9:	8b 70 20             	mov    0x20(%eax),%esi
c000ebfc:	88 4c 24 04          	mov    %cl,0x4(%esp)
c000ec00:	8a 48 41             	mov    0x41(%eax),%cl
template <typename T>
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
c000ec03:	80 7c 24 04 00       	cmpb   $0x0,0x4(%esp)
c000ec08:	74 22                	je     c000ec2c <_ZN8Exc_regs8fpu_ctrlEb+0x194>
c000ec0a:	eb 14                	jmp    c000ec20 <_ZN8Exc_regs8fpu_ctrlEb+0x188>
}

template <typename T>
void Exc_regs::set_cr0 (mword v)
{
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
c000ec0c:	8b 7c 24 04          	mov    0x4(%esp),%edi
c000ec10:	89 f3                	mov    %esi,%ebx
c000ec12:	f7 d3                	not    %ebx
c000ec14:	83 cb 01             	or     $0x1,%ebx
c000ec17:	21 df                	and    %ebx,%edi
}

template <typename T>
mword Exc_regs::cr0_set() const
{
    mword set = 0;
c000ec19:	31 db                	xor    %ebx,%ebx
c000ec1b:	e9 6e ff ff ff       	jmp    c000eb8e <_ZN8Exc_regs8fpu_ctrlEb+0xf6>

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
c000ec20:	84 c9                	test   %cl,%cl
c000ec22:	0f 85 bd 00 00 00    	jne    c000ece5 <_ZN8Exc_regs8fpu_ctrlEb+0x24d>
}

template <typename T>
mword Exc_regs::cr0_set() const
{
    mword set = 0;
c000ec28:	31 db                	xor    %ebx,%ebx
c000ec2a:	eb 0d                	jmp    c000ec39 <_ZN8Exc_regs8fpu_ctrlEb+0x1a1>

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
c000ec2c:	84 c9                	test   %cl,%cl
c000ec2e:	0f 85 c3 00 00 00    	jne    c000ecf7 <_ZN8Exc_regs8fpu_ctrlEb+0x25f>
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
c000ec34:	bb 01 00 01 80       	mov    $0x80010001,%ebx
    if (!fpu_on)
        set |= Cpu::CR0_TS;
c000ec39:	83 cb 08             	or     $0x8,%ebx
template <typename T>
mword Exc_regs::get_cr0() const
{
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
c000ec3c:	89 d9                	mov    %ebx,%ecx
c000ec3e:	f7 d1                	not    %ecx
c000ec40:	23 8e 58 05 00 00    	and    0x558(%esi),%ecx
c000ec46:	23 58 28             	and    0x28(%eax),%ebx
c000ec49:	09 d9                	or     %ebx,%ecx
        Vmcs::write (Vmcs::CR0_MASK, cr0_msk<Vmcs>());

    } else {

        mword cr0 = get_cr0<Vmcb>();
        fpu_on = on;
c000ec4b:	8a 5c 24 03          	mov    0x3(%esp),%bl
template <typename T>
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
c000ec4f:	80 7c 24 04 00       	cmpb   $0x0,0x4(%esp)
        Vmcs::write (Vmcs::CR0_MASK, cr0_msk<Vmcs>());

    } else {

        mword cr0 = get_cr0<Vmcb>();
        fpu_on = on;
c000ec54:	88 58 41             	mov    %bl,0x41(%eax)
template <typename T>
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
c000ec57:	75 0b                	jne    c000ec64 <_ZN8Exc_regs8fpu_ctrlEb+0x1cc>
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
c000ec59:	bf 01 00 01 80       	mov    $0x80010001,%edi
    if (!fpu_on)
c000ec5e:	84 db                	test   %bl,%bl
c000ec60:	75 18                	jne    c000ec7a <_ZN8Exc_regs8fpu_ctrlEb+0x1e2>
c000ec62:	eb 0d                	jmp    c000ec71 <_ZN8Exc_regs8fpu_ctrlEb+0x1d9>
c000ec64:	80 7c 24 03 00       	cmpb   $0x0,0x3(%esp)
c000ec69:	0f 85 a9 00 00 00    	jne    c000ed18 <_ZN8Exc_regs8fpu_ctrlEb+0x280>
}

template <typename T>
mword Exc_regs::cr0_set() const
{
    mword set = 0;
c000ec6f:	31 ff                	xor    %edi,%edi

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
        set |= Cpu::CR0_TS;
c000ec71:	83 cf 08             	or     $0x8,%edi
c000ec74:	89 cd                	mov    %ecx,%ebp
c000ec76:	31 db                	xor    %ebx,%ebx
c000ec78:	eb 04                	jmp    c000ec7e <_ZN8Exc_regs8fpu_ctrlEb+0x1e6>
{
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
c000ec7a:	89 cd                	mov    %ecx,%ebp
c000ec7c:	b3 01                	mov    $0x1,%bl
}

template <typename T>
void Exc_regs::set_cr0 (mword v)
{
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
c000ec7e:	f7 d7                	not    %edi
c000ec80:	83 cf 01             	or     $0x1,%edi
c000ec83:	21 f9                	and    %edi,%ecx
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
c000ec85:	80 7c 24 04 01       	cmpb   $0x1,0x4(%esp)
c000ec8a:	19 d2                	sbb    %edx,%edx
c000ec8c:	81 e2 01 00 01 80    	and    $0x80010001,%edx
    if (!fpu_on)
        set |= Cpu::CR0_TS;
c000ec92:	89 d7                	mov    %edx,%edi
c000ec94:	83 cf 08             	or     $0x8,%edi
c000ec97:	84 db                	test   %bl,%bl
c000ec99:	0f 44 d7             	cmove  %edi,%edx
}

template <typename T>
void Exc_regs::set_cr0 (mword v)
{
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
c000ec9c:	83 e2 fe             	and    $0xfffffffe,%edx
c000ec9f:	09 d1                	or     %edx,%ecx
template <> mword Exc_regs::get_g_cr0<Vmcs>()           const { return Vmcs::read (Vmcs::GUEST_CR0); }
template <> mword Exc_regs::get_g_cr2<Vmcs>()           const { return cr2; }
template <> mword Exc_regs::get_g_cr3<Vmcs>()           const { return Vmcs::read (Vmcs::GUEST_CR3); }
template <> mword Exc_regs::get_g_cr4<Vmcs>()           const { return Vmcs::read (Vmcs::GUEST_CR4); }

template <> void Exc_regs::set_g_cr0<Vmcb> (mword v)    const { vmcb->cr0 = v; }
c000eca1:	89 8e 58 05 00 00    	mov    %ecx,0x558(%esi)
c000eca7:	c7 86 5c 05 00 00 00 	movl   $0x0,0x55c(%esi)
c000ecae:	00 00 00 
void Exc_regs::set_exc() const
{
    unsigned msk = 1UL << Cpu::EXC_AC;

    if (!nst_on)
        msk |= 1UL << Cpu::EXC_PF;
c000ecb1:	80 78 40 01          	cmpb   $0x1,0x40(%eax)
template <> void Exc_regs::set_g_cr2<Vmcs> (mword v)          { cr2 = v; }
template <> void Exc_regs::set_g_cr3<Vmcs> (mword v)    const { Vmcs::write (Vmcs::GUEST_CR3, v); }
template <> void Exc_regs::set_g_cr4<Vmcs> (mword v)    const { Vmcs::write (Vmcs::GUEST_CR4, v); }

template <> void Exc_regs::set_e_bmp<Vmcb> (uint32 v)   const { vmcb->intercept_exc = v; }
template <> void Exc_regs::set_s_cr0<Vmcb> (mword v)          { cr0_shadow = v; }
c000ecb5:	89 68 28             	mov    %ebp,0x28(%eax)
void Exc_regs::set_exc() const
{
    unsigned msk = 1UL << Cpu::EXC_AC;

    if (!nst_on)
        msk |= 1UL << Cpu::EXC_PF;
c000ecb8:	19 d2                	sbb    %edx,%edx
c000ecba:	81 e2 00 40 00 00    	and    $0x4000,%edx
c000ecc0:	81 c2 00 00 02 00    	add    $0x20000,%edx
    if (!fpu_on)
        msk |= 1UL << Cpu::EXC_NM;
c000ecc6:	89 d1                	mov    %edx,%ecx
c000ecc8:	80 c9 80             	or     $0x80,%cl
c000eccb:	80 78 41 00          	cmpb   $0x0,0x41(%eax)
c000eccf:	0f 44 d1             	cmove  %ecx,%edx
template <> void Exc_regs::set_g_cr0<Vmcs> (mword v)    const { Vmcs::write (Vmcs::GUEST_CR0, v); }
template <> void Exc_regs::set_g_cr2<Vmcs> (mword v)          { cr2 = v; }
template <> void Exc_regs::set_g_cr3<Vmcs> (mword v)    const { Vmcs::write (Vmcs::GUEST_CR3, v); }
template <> void Exc_regs::set_g_cr4<Vmcs> (mword v)    const { Vmcs::write (Vmcs::GUEST_CR4, v); }

template <> void Exc_regs::set_e_bmp<Vmcb> (uint32 v)   const { vmcb->intercept_exc = v; }
c000ecd2:	8b 48 20             	mov    0x20(%eax),%ecx
c000ecd5:	89 51 08             	mov    %edx,0x8(%ecx)
        fpu_on = on;
        set_cr0<Vmcb> (cr0);

        set_exc<Vmcb>();

        svm_set_cpu_ctrl0 (vmcb->intercept_cpu[0]);
c000ecd8:	8b 50 20             	mov    0x20(%eax),%edx
c000ecdb:	8b 52 0c             	mov    0xc(%edx),%edx
c000ecde:	e8 b7 f8 ff ff       	call   c000e59a <_ZN8Exc_regs17svm_set_cpu_ctrl0Em>
c000ece3:	eb 3c                	jmp    c000ed21 <_ZN8Exc_regs8fpu_ctrlEb+0x289>
        Vmcs::write (Vmcs::CR0_MASK, cr0_msk<Vmcs>());

    } else {

        mword cr0 = get_cr0<Vmcb>();
        fpu_on = on;
c000ece5:	89 fb                	mov    %edi,%ebx
#include "vtlb.hpp"

template <> mword Exc_regs::get_g_cs_dl<Vmcb>()         const { return static_cast<mword>(vmcb->cs.ar) >> 9 & 0x3; }
template <> mword Exc_regs::get_g_flags<Vmcb>()         const { return static_cast<mword>(vmcb->rflags); }
template <> mword Exc_regs::get_g_efer<Vmcb>()          const { return static_cast<mword>(vmcb->efer); }
template <> mword Exc_regs::get_g_cr0<Vmcb>()           const { return static_cast<mword>(vmcb->cr0); }
c000ece7:	8b 8e 58 05 00 00    	mov    0x558(%esi),%ecx
}

template <typename T>
mword Exc_regs::cr0_set() const
{
    mword set = 0;
c000eced:	31 ff                	xor    %edi,%edi
        Vmcs::write (Vmcs::CR0_MASK, cr0_msk<Vmcs>());

    } else {

        mword cr0 = get_cr0<Vmcb>();
        fpu_on = on;
c000ecef:	88 58 41             	mov    %bl,0x41(%eax)
c000ecf2:	e9 67 ff ff ff       	jmp    c000ec5e <_ZN8Exc_regs8fpu_ctrlEb+0x1c6>
template <typename T>
mword Exc_regs::get_cr0() const
{
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
c000ecf7:	8b 9e 58 05 00 00    	mov    0x558(%esi),%ebx
c000ecfd:	8b 48 28             	mov    0x28(%eax),%ecx
c000ed00:	81 e3 fe ff fe 7f    	and    $0x7ffefffe,%ebx
c000ed06:	81 e1 01 00 01 80    	and    $0x80010001,%ecx
c000ed0c:	09 d9                	or     %ebx,%ecx
        Vmcs::write (Vmcs::CR0_MASK, cr0_msk<Vmcs>());

    } else {

        mword cr0 = get_cr0<Vmcb>();
        fpu_on = on;
c000ed0e:	89 fb                	mov    %edi,%ebx
c000ed10:	88 58 41             	mov    %bl,0x41(%eax)
c000ed13:	e9 41 ff ff ff       	jmp    c000ec59 <_ZN8Exc_regs8fpu_ctrlEb+0x1c1>
template <typename T>
mword Exc_regs::get_cr0() const
{
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
c000ed18:	89 cd                	mov    %ecx,%ebp
}

template <typename T>
mword Exc_regs::cr0_set() const
{
    mword set = 0;
c000ed1a:	31 d2                	xor    %edx,%edx
c000ed1c:	e9 7b ff ff ff       	jmp    c000ec9c <_ZN8Exc_regs8fpu_ctrlEb+0x204>

        set_exc<Vmcb>();

        svm_set_cpu_ctrl0 (vmcb->intercept_cpu[0]);
    }
}
c000ed21:	83 c4 10             	add    $0x10,%esp
c000ed24:	5b                   	pop    %ebx
c000ed25:	5e                   	pop    %esi
c000ed26:	5f                   	pop    %edi
c000ed27:	5d                   	pop    %ebp
c000ed28:	c3                   	ret    
c000ed29:	90                   	nop

c000ed2a <_ZN8Exc_regs18svm_update_shadowsEv>:

void Exc_regs::svm_update_shadows()
{
c000ed2a:	8a 48 40             	mov    0x40(%eax),%cl
c000ed2d:	56                   	push   %esi
c000ed2e:	8a 50 41             	mov    0x41(%eax),%dl
c000ed31:	53                   	push   %ebx
c000ed32:	8b 58 20             	mov    0x20(%eax),%ebx
template <typename T>
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
c000ed35:	84 c9                	test   %cl,%cl
c000ed37:	74 08                	je     c000ed41 <_ZN8Exc_regs18svm_update_shadowsEv+0x17>
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
c000ed39:	84 d2                	test   %dl,%dl
c000ed3b:	75 78                	jne    c000edb5 <_ZN8Exc_regs18svm_update_shadowsEv+0x8b>
}

template <typename T>
mword Exc_regs::cr0_set() const
{
    mword set = 0;
c000ed3d:	31 d2                	xor    %edx,%edx
c000ed3f:	eb 09                	jmp    c000ed4a <_ZN8Exc_regs18svm_update_shadowsEv+0x20>

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
c000ed41:	84 d2                	test   %dl,%dl
c000ed43:	75 26                	jne    c000ed6b <_ZN8Exc_regs18svm_update_shadowsEv+0x41>
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
c000ed45:	ba 01 00 01 80       	mov    $0x80010001,%edx
    if (!fpu_on)
        set |= Cpu::CR0_TS;
c000ed4a:	83 ca 08             	or     $0x8,%edx
template <typename T>
mword Exc_regs::get_cr0() const
{
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
c000ed4d:	89 d6                	mov    %edx,%esi
c000ed4f:	f7 d6                	not    %esi
c000ed51:	23 b3 58 05 00 00    	and    0x558(%ebx),%esi
c000ed57:	23 50 28             	and    0x28(%eax),%edx
c000ed5a:	09 f2                	or     %esi,%edx
}

template <typename T>
mword Exc_regs::get_cr3() const
{
    return nst_on ? get_g_cr3<T>() : cr3_shadow;
c000ed5c:	84 c9                	test   %cl,%cl
template <typename T>
mword Exc_regs::get_cr0() const
{
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
c000ed5e:	89 50 28             	mov    %edx,0x28(%eax)
}

template <typename T>
mword Exc_regs::get_cr3() const
{
    return nst_on ? get_g_cr3<T>() : cr3_shadow;
c000ed61:	74 22                	je     c000ed85 <_ZN8Exc_regs18svm_update_shadowsEv+0x5b>
template <> mword Exc_regs::get_g_cs_dl<Vmcb>()         const { return static_cast<mword>(vmcb->cs.ar) >> 9 & 0x3; }
template <> mword Exc_regs::get_g_flags<Vmcb>()         const { return static_cast<mword>(vmcb->rflags); }
template <> mword Exc_regs::get_g_efer<Vmcb>()          const { return static_cast<mword>(vmcb->efer); }
template <> mword Exc_regs::get_g_cr0<Vmcb>()           const { return static_cast<mword>(vmcb->cr0); }
template <> mword Exc_regs::get_g_cr2<Vmcb>()           const { return static_cast<mword>(vmcb->cr2); }
template <> mword Exc_regs::get_g_cr3<Vmcb>()           const { return static_cast<mword>(vmcb->cr3); }
c000ed63:	8b 93 50 05 00 00    	mov    0x550(%ebx),%edx
c000ed69:	eb 1d                	jmp    c000ed88 <_ZN8Exc_regs18svm_update_shadowsEv+0x5e>
template <typename T>
mword Exc_regs::get_cr0() const
{
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
c000ed6b:	8b b3 58 05 00 00    	mov    0x558(%ebx),%esi
c000ed71:	8b 50 28             	mov    0x28(%eax),%edx
c000ed74:	81 e6 fe ff fe 7f    	and    $0x7ffefffe,%esi
c000ed7a:	81 e2 01 00 01 80    	and    $0x80010001,%edx
c000ed80:	09 f2                	or     %esi,%edx
c000ed82:	89 50 28             	mov    %edx,0x28(%eax)
}

template <typename T>
mword Exc_regs::get_cr3() const
{
    return nst_on ? get_g_cr3<T>() : cr3_shadow;
c000ed85:	8b 50 2c             	mov    0x2c(%eax),%edx
template <typename T>
mword Exc_regs::cr4_msk() const
{
    mword clr = nst_on ? 0 :
#ifdef __i386__
                Cpu::CR4_PGE | Cpu::CR4_PAE;
c000ed88:	80 f9 01             	cmp    $0x1,%cl
c000ed8b:	19 f6                	sbb    %esi,%esi
c000ed8d:	81 e6 a0 00 00 00    	and    $0xa0,%esi
c000ed93:	80 f9 01             	cmp    $0x1,%cl
}

void Exc_regs::svm_update_shadows()
{
    cr0_shadow = get_cr0<Vmcb>();
    cr3_shadow = get_cr3<Vmcb>();
c000ed96:	89 50 2c             	mov    %edx,0x2c(%eax)
template <typename T>
mword Exc_regs::cr4_msk() const
{
    mword clr = nst_on ? 0 :
#ifdef __i386__
                Cpu::CR4_PGE | Cpu::CR4_PAE;
c000ed99:	19 d2                	sbb    %edx,%edx
c000ed9b:	83 e2 10             	and    $0x10,%edx
#else
                Cpu::CR4_PGE;
#endif

    return T::fix_cr4_clr | clr | cr4_set<T>();
c000ed9e:	09 f2                	or     %esi,%edx
template <typename T>
mword Exc_regs::get_cr4() const
{
    mword msk = cr4_msk<T>();

    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
c000eda0:	89 d1                	mov    %edx,%ecx
c000eda2:	f7 d1                	not    %ecx
c000eda4:	23 8b 48 05 00 00    	and    0x548(%ebx),%ecx
c000edaa:	23 50 30             	and    0x30(%eax),%edx
void Exc_regs::svm_update_shadows()
{
    cr0_shadow = get_cr0<Vmcb>();
    cr3_shadow = get_cr3<Vmcb>();
    cr4_shadow = get_cr4<Vmcb>();
}
c000edad:	5b                   	pop    %ebx
template <typename T>
mword Exc_regs::get_cr4() const
{
    mword msk = cr4_msk<T>();

    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
c000edae:	09 ca                	or     %ecx,%edx
c000edb0:	89 50 30             	mov    %edx,0x30(%eax)
void Exc_regs::svm_update_shadows()
{
    cr0_shadow = get_cr0<Vmcb>();
    cr3_shadow = get_cr3<Vmcb>();
    cr4_shadow = get_cr4<Vmcb>();
}
c000edb3:	5e                   	pop    %esi
c000edb4:	c3                   	ret    
#include "vtlb.hpp"

template <> mword Exc_regs::get_g_cs_dl<Vmcb>()         const { return static_cast<mword>(vmcb->cs.ar) >> 9 & 0x3; }
template <> mword Exc_regs::get_g_flags<Vmcb>()         const { return static_cast<mword>(vmcb->rflags); }
template <> mword Exc_regs::get_g_efer<Vmcb>()          const { return static_cast<mword>(vmcb->efer); }
template <> mword Exc_regs::get_g_cr0<Vmcb>()           const { return static_cast<mword>(vmcb->cr0); }
c000edb5:	8b 93 58 05 00 00    	mov    0x558(%ebx),%edx
c000edbb:	89 50 28             	mov    %edx,0x28(%eax)
c000edbe:	eb a3                	jmp    c000ed63 <_ZN8Exc_regs18svm_update_shadowsEv+0x39>

c000edc0 <_ZN8Exc_regs12svm_read_gprEj>:
    cr4_shadow = get_cr4<Vmcb>();
}

mword Exc_regs::svm_read_gpr (unsigned reg)
{
    switch (reg) {
c000edc0:	85 d2                	test   %edx,%edx
c000edc2:	74 0f                	je     c000edd3 <_ZN8Exc_regs12svm_read_gprEj+0x13>
c000edc4:	83 fa 04             	cmp    $0x4,%edx
c000edc7:	75 14                	jne    c000eddd <_ZN8Exc_regs12svm_read_gprEj+0x1d>
        case 0:     return static_cast<mword>(vmcb->rax);
        case 4:     return static_cast<mword>(vmcb->rsp);
c000edc9:	8b 40 20             	mov    0x20(%eax),%eax
c000edcc:	8b 80 d8 05 00 00    	mov    0x5d8(%eax),%eax
c000edd2:	c3                   	ret    
}

mword Exc_regs::svm_read_gpr (unsigned reg)
{
    switch (reg) {
        case 0:     return static_cast<mword>(vmcb->rax);
c000edd3:	8b 40 20             	mov    0x20(%eax),%eax
c000edd6:	8b 80 f8 05 00 00    	mov    0x5f8(%eax),%eax
c000eddc:	c3                   	ret    
        case 4:     return static_cast<mword>(vmcb->rsp);
        default:    return gpr[sizeof (Sys_regs) / sizeof (mword) - 1 - reg];
c000eddd:	b9 07 00 00 00       	mov    $0x7,%ecx
c000ede2:	29 d1                	sub    %edx,%ecx
c000ede4:	8b 04 88             	mov    (%eax,%ecx,4),%eax
    }
}
c000ede7:	c3                   	ret    

c000ede8 <_ZN8Exc_regs13svm_write_gprEjm>:

void Exc_regs::svm_write_gpr (unsigned reg, mword val)
{
    switch (reg) {
c000ede8:	85 d2                	test   %edx,%edx
c000edea:	74 12                	je     c000edfe <_ZN8Exc_regs13svm_write_gprEjm+0x16>
c000edec:	83 fa 04             	cmp    $0x4,%edx
c000edef:	74 21                	je     c000ee12 <_ZN8Exc_regs13svm_write_gprEjm+0x2a>
        default:    return gpr[sizeof (Sys_regs) / sizeof (mword) - 1 - reg];
    }
}

void Exc_regs::svm_write_gpr (unsigned reg, mword val)
{
c000edf1:	53                   	push   %ebx
    switch (reg) {
        case 0:     vmcb->rax = val; return;
        case 4:     vmcb->rsp = val; return;
        default:    gpr[sizeof (Sys_regs) / sizeof (mword) - 1 - reg] = val; return;
c000edf2:	bb 07 00 00 00       	mov    $0x7,%ebx
c000edf7:	29 d3                	sub    %edx,%ebx
c000edf9:	89 0c 98             	mov    %ecx,(%eax,%ebx,4)
    }
}
c000edfc:	5b                   	pop    %ebx
c000edfd:	c3                   	ret    
}

void Exc_regs::svm_write_gpr (unsigned reg, mword val)
{
    switch (reg) {
        case 0:     vmcb->rax = val; return;
c000edfe:	8b 40 20             	mov    0x20(%eax),%eax
c000ee01:	89 88 f8 05 00 00    	mov    %ecx,0x5f8(%eax)
c000ee07:	c7 80 fc 05 00 00 00 	movl   $0x0,0x5fc(%eax)
c000ee0e:	00 00 00 
c000ee11:	c3                   	ret    
        case 4:     vmcb->rsp = val; return;
c000ee12:	8b 40 20             	mov    0x20(%eax),%eax
c000ee15:	89 88 d8 05 00 00    	mov    %ecx,0x5d8(%eax)
c000ee1b:	c7 80 dc 05 00 00 00 	movl   $0x0,0x5dc(%eax)
c000ee22:	00 00 00 
c000ee25:	c3                   	ret    

c000ee26 <_ZN8Exc_regs12vmx_read_gprEj>:
    }
}

mword Exc_regs::vmx_read_gpr (unsigned reg)
{
    if (EXPECT_FALSE (reg == 4))
c000ee26:	83 fa 04             	cmp    $0x4,%edx
c000ee29:	75 09                	jne    c000ee34 <_ZN8Exc_regs12vmx_read_gprEj+0xe>
        return Vmcs::read (Vmcs::GUEST_RSP);
c000ee2b:	b8 1c 68 00 00       	mov    $0x681c,%eax
c000ee30:	0f 78 c0             	vmread %eax,%eax
c000ee33:	c3                   	ret    
    else
        return gpr[sizeof (Sys_regs) / sizeof (mword) - 1 - reg];
c000ee34:	b9 07 00 00 00       	mov    $0x7,%ecx
c000ee39:	29 d1                	sub    %edx,%ecx
c000ee3b:	8b 04 88             	mov    (%eax,%ecx,4),%eax
}
c000ee3e:	c3                   	ret    
c000ee3f:	90                   	nop

c000ee40 <_ZN8Exc_regs13vmx_write_gprEjm>:

void Exc_regs::vmx_write_gpr (unsigned reg, mword val)
{
    if (EXPECT_FALSE (reg == 4))
c000ee40:	83 fa 04             	cmp    $0x4,%edx
c000ee43:	75 09                	jne    c000ee4e <_ZN8Exc_regs13vmx_write_gprEjm+0xe>
c000ee45:	b8 1c 68 00 00       	mov    $0x681c,%eax
c000ee4a:	0f 79 c1             	vmwrite %ecx,%eax
c000ee4d:	c3                   	ret    
    else
        return gpr[sizeof (Sys_regs) / sizeof (mword) - 1 - reg];
}

void Exc_regs::vmx_write_gpr (unsigned reg, mword val)
{
c000ee4e:	53                   	push   %ebx
    if (EXPECT_FALSE (reg == 4))
        Vmcs::write (Vmcs::GUEST_RSP, val);
    else
        gpr[sizeof (Sys_regs) / sizeof (mword) - 1 - reg] = val;
c000ee4f:	bb 07 00 00 00       	mov    $0x7,%ebx
c000ee54:	29 d3                	sub    %edx,%ebx
c000ee56:	89 0c 98             	mov    %ecx,(%eax,%ebx,4)
}
c000ee59:	5b                   	pop    %ebx
c000ee5a:	c3                   	ret    
c000ee5b:	90                   	nop

c000ee5c <_ZNK8Exc_regs14linear_addressI4VmcbEEmm>:

    return (get_g_efer<T>() & Cpu::EFER_LMA) && (dl & 1) ? MODE_PROT_64 : dl & 2 ? MODE_PROT_32 : MODE_PROT_16;
}

template <typename T>
mword Exc_regs::linear_address (mword val) const
c000ee5c:	89 d0                	mov    %edx,%eax
{
    return mode<T>() == MODE_PROT_64 ? val : val & 0xffffffff;
}
c000ee5e:	c3                   	ret    
c000ee5f:	90                   	nop

c000ee60 <_ZNK8Exc_regs7read_crI4VmcbEEmj>:
}

template <typename T>
mword Exc_regs::read_cr (unsigned cr) const
{
    switch (cr) {
c000ee60:	83 fa 02             	cmp    $0x2,%edx
    else
        gpr[sizeof (Sys_regs) / sizeof (mword) - 1 - reg] = val;
}

template <typename T>
mword Exc_regs::read_cr (unsigned cr) const
c000ee63:	89 c1                	mov    %eax,%ecx
c000ee65:	53                   	push   %ebx
{
    switch (cr) {
c000ee66:	74 66                	je     c000eece <_ZNK8Exc_regs7read_crI4VmcbEEmj+0x6e>
c000ee68:	77 32                	ja     c000ee9c <_ZNK8Exc_regs7read_crI4VmcbEEmj+0x3c>
c000ee6a:	85 d2                	test   %edx,%edx
c000ee6c:	0f 85 81 00 00 00    	jne    c000eef3 <_ZNK8Exc_regs7read_crI4VmcbEEmj+0x93>
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
c000ee72:	80 78 40 01          	cmpb   $0x1,0x40(%eax)
template <typename T>
mword Exc_regs::get_cr0() const
{
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
c000ee76:	8b 59 20             	mov    0x20(%ecx),%ebx
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
c000ee79:	19 d2                	sbb    %edx,%edx
c000ee7b:	81 e2 01 00 01 80    	and    $0x80010001,%edx
    if (!fpu_on)
        set |= Cpu::CR0_TS;
c000ee81:	89 d0                	mov    %edx,%eax
c000ee83:	83 c8 08             	or     $0x8,%eax
c000ee86:	80 79 41 00          	cmpb   $0x0,0x41(%ecx)
c000ee8a:	0f 44 d0             	cmove  %eax,%edx
template <typename T>
mword Exc_regs::get_cr0() const
{
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
c000ee8d:	89 d0                	mov    %edx,%eax
c000ee8f:	f7 d0                	not    %eax
c000ee91:	23 83 58 05 00 00    	and    0x558(%ebx),%eax
c000ee97:	23 51 28             	and    0x28(%ecx),%edx
c000ee9a:	eb 53                	jmp    c000eeef <_ZNK8Exc_regs7read_crI4VmcbEEmj+0x8f>
}

template <typename T>
mword Exc_regs::read_cr (unsigned cr) const
{
    switch (cr) {
c000ee9c:	83 fa 03             	cmp    $0x3,%edx
c000ee9f:	74 38                	je     c000eed9 <_ZNK8Exc_regs7read_crI4VmcbEEmj+0x79>
c000eea1:	83 fa 04             	cmp    $0x4,%edx
c000eea4:	75 4d                	jne    c000eef3 <_ZNK8Exc_regs7read_crI4VmcbEEmj+0x93>
template <typename T>
mword Exc_regs::cr4_msk() const
{
    mword clr = nst_on ? 0 :
#ifdef __i386__
                Cpu::CR4_PGE | Cpu::CR4_PAE;
c000eea6:	80 78 40 01          	cmpb   $0x1,0x40(%eax)
template <typename T>
mword Exc_regs::get_cr4() const
{
    mword msk = cr4_msk<T>();

    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
c000eeaa:	8b 59 20             	mov    0x20(%ecx),%ebx
template <typename T>
mword Exc_regs::cr4_msk() const
{
    mword clr = nst_on ? 0 :
#ifdef __i386__
                Cpu::CR4_PGE | Cpu::CR4_PAE;
c000eead:	19 c0                	sbb    %eax,%eax
c000eeaf:	25 a0 00 00 00       	and    $0xa0,%eax
c000eeb4:	80 79 40 01          	cmpb   $0x1,0x40(%ecx)
c000eeb8:	19 d2                	sbb    %edx,%edx
c000eeba:	83 e2 10             	and    $0x10,%edx
#else
                Cpu::CR4_PGE;
#endif

    return T::fix_cr4_clr | clr | cr4_set<T>();
c000eebd:	09 c2                	or     %eax,%edx
template <typename T>
mword Exc_regs::get_cr4() const
{
    mword msk = cr4_msk<T>();

    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
c000eebf:	89 d0                	mov    %edx,%eax
c000eec1:	f7 d0                	not    %eax
c000eec3:	23 83 48 05 00 00    	and    0x548(%ebx),%eax
c000eec9:	23 51 30             	and    0x30(%ecx),%edx
c000eecc:	eb 21                	jmp    c000eeef <_ZNK8Exc_regs7read_crI4VmcbEEmj+0x8f>

template <> mword Exc_regs::get_g_cs_dl<Vmcb>()         const { return static_cast<mword>(vmcb->cs.ar) >> 9 & 0x3; }
template <> mword Exc_regs::get_g_flags<Vmcb>()         const { return static_cast<mword>(vmcb->rflags); }
template <> mword Exc_regs::get_g_efer<Vmcb>()          const { return static_cast<mword>(vmcb->efer); }
template <> mword Exc_regs::get_g_cr0<Vmcb>()           const { return static_cast<mword>(vmcb->cr0); }
template <> mword Exc_regs::get_g_cr2<Vmcb>()           const { return static_cast<mword>(vmcb->cr2); }
c000eece:	8b 40 20             	mov    0x20(%eax),%eax
c000eed1:	8b 80 40 06 00 00    	mov    0x640(%eax),%eax
template <typename T>
mword Exc_regs::read_cr (unsigned cr) const
{
    switch (cr) {
        case 0: return get_cr0<T>();
        case 2: return get_g_cr2<T>();
c000eed7:	eb 1a                	jmp    c000eef3 <_ZNK8Exc_regs7read_crI4VmcbEEmj+0x93>
}

template <typename T>
mword Exc_regs::get_cr3() const
{
    return nst_on ? get_g_cr3<T>() : cr3_shadow;
c000eed9:	80 78 40 00          	cmpb   $0x0,0x40(%eax)
c000eedd:	74 0b                	je     c000eeea <_ZNK8Exc_regs7read_crI4VmcbEEmj+0x8a>
template <> mword Exc_regs::get_g_cs_dl<Vmcb>()         const { return static_cast<mword>(vmcb->cs.ar) >> 9 & 0x3; }
template <> mword Exc_regs::get_g_flags<Vmcb>()         const { return static_cast<mword>(vmcb->rflags); }
template <> mword Exc_regs::get_g_efer<Vmcb>()          const { return static_cast<mword>(vmcb->efer); }
template <> mword Exc_regs::get_g_cr0<Vmcb>()           const { return static_cast<mword>(vmcb->cr0); }
template <> mword Exc_regs::get_g_cr2<Vmcb>()           const { return static_cast<mword>(vmcb->cr2); }
template <> mword Exc_regs::get_g_cr3<Vmcb>()           const { return static_cast<mword>(vmcb->cr3); }
c000eedf:	8b 40 20             	mov    0x20(%eax),%eax
c000eee2:	8b 80 50 05 00 00    	mov    0x550(%eax),%eax
c000eee8:	eb 09                	jmp    c000eef3 <_ZNK8Exc_regs7read_crI4VmcbEEmj+0x93>
}

template <typename T>
mword Exc_regs::get_cr3() const
{
    return nst_on ? get_g_cr3<T>() : cr3_shadow;
c000eeea:	8b 40 2c             	mov    0x2c(%eax),%eax
c000eeed:	eb 04                	jmp    c000eef3 <_ZNK8Exc_regs7read_crI4VmcbEEmj+0x93>
template <typename T>
mword Exc_regs::get_cr4() const
{
    mword msk = cr4_msk<T>();

    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
c000eeef:	09 d0                	or     %edx,%eax
{
    switch (cr) {
        case 0: return get_cr0<T>();
        case 2: return get_g_cr2<T>();
        case 3: return get_cr3<T>();
        case 4: return get_cr4<T>();
c000eef1:	eb 00                	jmp    c000eef3 <_ZNK8Exc_regs7read_crI4VmcbEEmj+0x93>
        default: UNREACHED;
    }
}
c000eef3:	5b                   	pop    %ebx
c000eef4:	c3                   	ret    
c000eef5:	90                   	nop

c000eef6 <_ZNK8Exc_regs7read_crI4VmcsEEmj>:
}

template <typename T>
mword Exc_regs::read_cr (unsigned cr) const
{
    switch (cr) {
c000eef6:	83 fa 02             	cmp    $0x2,%edx
    else
        gpr[sizeof (Sys_regs) / sizeof (mword) - 1 - reg] = val;
}

template <typename T>
mword Exc_regs::read_cr (unsigned cr) const
c000eef9:	53                   	push   %ebx
c000eefa:	89 c3                	mov    %eax,%ebx
{
    switch (cr) {
c000eefc:	0f 84 86 00 00 00    	je     c000ef88 <_ZNK8Exc_regs7read_crI4VmcsEEmj+0x92>
c000ef02:	77 42                	ja     c000ef46 <_ZNK8Exc_regs7read_crI4VmcsEEmj+0x50>
c000ef04:	85 d2                	test   %edx,%edx
c000ef06:	0f 85 96 00 00 00    	jne    c000efa2 <_ZNK8Exc_regs7read_crI4VmcsEEmj+0xac>
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
c000ef0c:	80 78 40 01          	cmpb   $0x1,0x40(%eax)
c000ef10:	19 d2                	sbb    %edx,%edx
c000ef12:	81 e2 01 00 01 80    	and    $0x80010001,%edx
    if (!fpu_on)
        set |= Cpu::CR0_TS;
c000ef18:	89 d0                	mov    %edx,%eax
c000ef1a:	83 c8 08             	or     $0x8,%eax
c000ef1d:	80 7b 41 00          	cmpb   $0x0,0x41(%ebx)
c000ef21:	0f 44 d0             	cmove  %eax,%edx
c000ef24:	a1 30 fb ff cf       	mov    0xcffffb30,%eax
c000ef29:	0b 05 34 fb ff cf    	or     0xcffffb34,%eax
}

template <typename T>
mword Exc_regs::cr0_msk() const
{
    return T::fix_cr0_clr | cr0_set<T>();
c000ef2f:	09 c2                	or     %eax,%edx

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
c000ef31:	b8 00 68 00 00       	mov    $0x6800,%eax
c000ef36:	0f 78 c0             	vmread %eax,%eax
template <typename T>
mword Exc_regs::get_cr0() const
{
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
c000ef39:	89 d1                	mov    %edx,%ecx
c000ef3b:	23 53 28             	and    0x28(%ebx),%edx
c000ef3e:	f7 d1                	not    %ecx
c000ef40:	21 c8                	and    %ecx,%eax
c000ef42:	09 d0                	or     %edx,%eax

template <typename T>
mword Exc_regs::read_cr (unsigned cr) const
{
    switch (cr) {
        case 0: return get_cr0<T>();
c000ef44:	eb 5c                	jmp    c000efa2 <_ZNK8Exc_regs7read_crI4VmcsEEmj+0xac>
}

template <typename T>
mword Exc_regs::read_cr (unsigned cr) const
{
    switch (cr) {
c000ef46:	83 fa 03             	cmp    $0x3,%edx
c000ef49:	74 42                	je     c000ef8d <_ZNK8Exc_regs7read_crI4VmcsEEmj+0x97>
c000ef4b:	83 fa 04             	cmp    $0x4,%edx
c000ef4e:	75 52                	jne    c000efa2 <_ZNK8Exc_regs7read_crI4VmcsEEmj+0xac>
c000ef50:	8a 40 40             	mov    0x40(%eax),%al
template <typename T>
mword Exc_regs::cr4_msk() const
{
    mword clr = nst_on ? 0 :
#ifdef __i386__
                Cpu::CR4_PGE | Cpu::CR4_PAE;
c000ef53:	3c 01                	cmp    $0x1,%al
c000ef55:	19 d2                	sbb    %edx,%edx
c000ef57:	81 e2 a0 00 00 00    	and    $0xa0,%edx
template <typename T>
mword Exc_regs::cr4_set() const
{
    mword set = nst_on ? 0 :
#ifdef __i386__
                Cpu::CR4_PSE;
c000ef5d:	3c 01                	cmp    $0x1,%al
c000ef5f:	a1 28 fb ff cf       	mov    0xcffffb28,%eax
c000ef64:	19 c9                	sbb    %ecx,%ecx
c000ef66:	0b 05 2c fb ff cf    	or     0xcffffb2c,%eax
c000ef6c:	83 e1 10             	and    $0x10,%ecx
c000ef6f:	09 c2                	or     %eax,%edx
c000ef71:	b8 04 68 00 00       	mov    $0x6804,%eax
                Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
                Cpu::CR4_PGE;
#endif

    return T::fix_cr4_clr | clr | cr4_set<T>();
c000ef76:	09 d1                	or     %edx,%ecx
c000ef78:	0f 78 c0             	vmread %eax,%eax
template <typename T>
mword Exc_regs::get_cr4() const
{
    mword msk = cr4_msk<T>();

    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
c000ef7b:	89 ca                	mov    %ecx,%edx
c000ef7d:	23 4b 30             	and    0x30(%ebx),%ecx
c000ef80:	f7 d2                	not    %edx
c000ef82:	21 d0                	and    %edx,%eax
c000ef84:	09 c8                	or     %ecx,%eax
{
    switch (cr) {
        case 0: return get_cr0<T>();
        case 2: return get_g_cr2<T>();
        case 3: return get_cr3<T>();
        case 4: return get_cr4<T>();
c000ef86:	eb 1a                	jmp    c000efa2 <_ZNK8Exc_regs7read_crI4VmcsEEmj+0xac>

template <> mword Exc_regs::get_g_cs_dl<Vmcs>()         const { return Vmcs::read (Vmcs::GUEST_AR_CS) >> 13 & 0x3; }
template <> mword Exc_regs::get_g_flags<Vmcs>()         const { return Vmcs::read (Vmcs::GUEST_RFLAGS); }
template <> mword Exc_regs::get_g_efer<Vmcs>()          const { return Vmcs::read (Vmcs::GUEST_EFER); }
template <> mword Exc_regs::get_g_cr0<Vmcs>()           const { return Vmcs::read (Vmcs::GUEST_CR0); }
template <> mword Exc_regs::get_g_cr2<Vmcs>()           const { return cr2; }
c000ef88:	8b 40 0c             	mov    0xc(%eax),%eax
template <typename T>
mword Exc_regs::read_cr (unsigned cr) const
{
    switch (cr) {
        case 0: return get_cr0<T>();
        case 2: return get_g_cr2<T>();
c000ef8b:	eb 15                	jmp    c000efa2 <_ZNK8Exc_regs7read_crI4VmcsEEmj+0xac>
}

template <typename T>
mword Exc_regs::get_cr3() const
{
    return nst_on ? get_g_cr3<T>() : cr3_shadow;
c000ef8d:	80 78 40 00          	cmpb   $0x0,0x40(%eax)
c000ef91:	74 0a                	je     c000ef9d <_ZNK8Exc_regs7read_crI4VmcsEEmj+0xa7>
c000ef93:	b8 02 68 00 00       	mov    $0x6802,%eax
c000ef98:	0f 78 c0             	vmread %eax,%eax
c000ef9b:	eb 05                	jmp    c000efa2 <_ZNK8Exc_regs7read_crI4VmcsEEmj+0xac>
c000ef9d:	8b 40 2c             	mov    0x2c(%eax),%eax
c000efa0:	eb 00                	jmp    c000efa2 <_ZNK8Exc_regs7read_crI4VmcsEEmj+0xac>
        case 2: return get_g_cr2<T>();
        case 3: return get_cr3<T>();
        case 4: return get_cr4<T>();
        default: UNREACHED;
    }
}
c000efa2:	5b                   	pop    %ebx
c000efa3:	c3                   	ret    

c000efa4 <_ZN8Exc_regs8write_crI4VmcbEEvjm>:
template <typename T>
void Exc_regs::write_cr (unsigned cr, mword val)
{
    mword toggled;

    switch (cr) {
c000efa4:	83 fa 02             	cmp    $0x2,%edx
c000efa7:	74 26                	je     c000efcf <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x2b>
        default: UNREACHED;
    }
}

template <typename T>
void Exc_regs::write_cr (unsigned cr, mword val)
c000efa9:	55                   	push   %ebp
c000efaa:	57                   	push   %edi
c000efab:	56                   	push   %esi
c000efac:	89 ce                	mov    %ecx,%esi
c000efae:	53                   	push   %ebx
c000efaf:	89 c3                	mov    %eax,%ebx
{
    mword toggled;

    switch (cr) {
c000efb1:	77 09                	ja     c000efbc <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x18>
c000efb3:	85 d2                	test   %edx,%edx
c000efb5:	74 5f                	je     c000f016 <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x72>
c000efb7:	e9 81 01 00 00       	jmp    c000f13d <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x199>
c000efbc:	83 fa 03             	cmp    $0x3,%edx
c000efbf:	74 22                	je     c000efe3 <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x3f>
c000efc1:	83 fa 04             	cmp    $0x4,%edx
c000efc4:	0f 84 fb 00 00 00    	je     c000f0c5 <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x121>
c000efca:	e9 6e 01 00 00       	jmp    c000f13d <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x199>
template <> mword Exc_regs::get_g_cr2<Vmcs>()           const { return cr2; }
template <> mword Exc_regs::get_g_cr3<Vmcs>()           const { return Vmcs::read (Vmcs::GUEST_CR3); }
template <> mword Exc_regs::get_g_cr4<Vmcs>()           const { return Vmcs::read (Vmcs::GUEST_CR4); }

template <> void Exc_regs::set_g_cr0<Vmcb> (mword v)    const { vmcb->cr0 = v; }
template <> void Exc_regs::set_g_cr2<Vmcb> (mword v)          { vmcb->cr2 = v; }
c000efcf:	8b 40 20             	mov    0x20(%eax),%eax
c000efd2:	89 88 40 06 00 00    	mov    %ecx,0x640(%eax)
c000efd8:	c7 80 44 06 00 00 00 	movl   $0x0,0x644(%eax)
c000efdf:	00 00 00 
c000efe2:	c3                   	ret    
        case 2:
            set_g_cr2<T> (val);
            break;

        case 3:
            if (!nst_on)
c000efe3:	80 78 40 00          	cmpb   $0x0,0x40(%eax)
c000efe7:	75 07                	jne    c000eff0 <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x4c>
                tlb_flush<T> (false);
c000efe9:	31 d2                	xor    %edx,%edx
c000efeb:	e8 f4 f4 ff ff       	call   c000e4e4 <_ZNK8Exc_regs9tlb_flushI4VmcbEEvb>
}

template <typename T>
void Exc_regs::set_cr3 (mword v)
{
    if (nst_on)
c000eff0:	80 7b 40 00          	cmpb   $0x0,0x40(%ebx)
c000eff4:	74 18                	je     c000f00e <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x6a>
template <> mword Exc_regs::get_g_cr3<Vmcs>()           const { return Vmcs::read (Vmcs::GUEST_CR3); }
template <> mword Exc_regs::get_g_cr4<Vmcs>()           const { return Vmcs::read (Vmcs::GUEST_CR4); }

template <> void Exc_regs::set_g_cr0<Vmcb> (mword v)    const { vmcb->cr0 = v; }
template <> void Exc_regs::set_g_cr2<Vmcb> (mword v)          { vmcb->cr2 = v; }
template <> void Exc_regs::set_g_cr3<Vmcb> (mword v)    const { vmcb->cr3 = v; }
c000eff6:	8b 43 20             	mov    0x20(%ebx),%eax
c000eff9:	89 b0 50 05 00 00    	mov    %esi,0x550(%eax)
c000efff:	c7 80 54 05 00 00 00 	movl   $0x0,0x554(%eax)
c000f006:	00 00 00 
c000f009:	e9 51 01 00 00       	jmp    c000f15f <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x1bb>
void Exc_regs::set_cr3 (mword v)
{
    if (nst_on)
        set_g_cr3<T> (v);
    else
        cr3_shadow = v;
c000f00e:	89 73 2c             	mov    %esi,0x2c(%ebx)
c000f011:	e9 49 01 00 00       	jmp    c000f15f <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x1bb>
c000f016:	8a 48 40             	mov    0x40(%eax),%cl
c000f019:	8a 50 41             	mov    0x41(%eax),%dl
c000f01c:	8b 68 20             	mov    0x20(%eax),%ebp
c000f01f:	8b 78 28             	mov    0x28(%eax),%edi
template <typename T>
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
c000f022:	84 c9                	test   %cl,%cl
c000f024:	74 08                	je     c000f02e <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x8a>
}

template <typename T>
mword Exc_regs::cr0_set() const
{
    mword set = 0;
c000f026:	31 c0                	xor    %eax,%eax

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
c000f028:	84 d2                	test   %dl,%dl
c000f02a:	75 12                	jne    c000f03e <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x9a>
c000f02c:	eb 0d                	jmp    c000f03b <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x97>
c000f02e:	84 d2                	test   %dl,%dl
c000f030:	0f 85 07 01 00 00    	jne    c000f13d <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x199>
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
c000f036:	b8 01 00 01 80       	mov    $0x80010001,%eax
    if (!fpu_on)
        set |= Cpu::CR0_TS;
c000f03b:	83 c8 08             	or     $0x8,%eax
            break;

        case 0:
            toggled = get_cr0<T>() ^ val;

            if (!nst_on)
c000f03e:	84 c9                	test   %cl,%cl
#include "vtlb.hpp"

template <> mword Exc_regs::get_g_cs_dl<Vmcb>()         const { return static_cast<mword>(vmcb->cs.ar) >> 9 & 0x3; }
template <> mword Exc_regs::get_g_flags<Vmcb>()         const { return static_cast<mword>(vmcb->rflags); }
template <> mword Exc_regs::get_g_efer<Vmcb>()          const { return static_cast<mword>(vmcb->efer); }
template <> mword Exc_regs::get_g_cr0<Vmcb>()           const { return static_cast<mword>(vmcb->cr0); }
c000f040:	8b 95 58 05 00 00    	mov    0x558(%ebp),%edx
            break;

        case 0:
            toggled = get_cr0<T>() ^ val;

            if (!nst_on)
c000f046:	75 1f                	jne    c000f067 <_ZN8Exc_regs8write_crI4VmcbEEvjm+0xc3>
template <typename T>
mword Exc_regs::get_cr0() const
{
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
c000f048:	89 c1                	mov    %eax,%ecx
c000f04a:	21 f8                	and    %edi,%eax
c000f04c:	f7 d1                	not    %ecx
c000f04e:	21 ca                	and    %ecx,%edx
c000f050:	09 d0                	or     %edx,%eax
            set_cr3<T> (val);

            break;

        case 0:
            toggled = get_cr0<T>() ^ val;
c000f052:	31 f0                	xor    %esi,%eax

            if (!nst_on)
                if (toggled & (Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE))
c000f054:	a9 01 00 01 80       	test   $0x80010001,%eax
c000f059:	74 0c                	je     c000f067 <_ZN8Exc_regs8write_crI4VmcbEEvjm+0xc3>
                    tlb_flush<T> (true);
c000f05b:	ba 01 00 00 00       	mov    $0x1,%edx
c000f060:	89 d8                	mov    %ebx,%eax
c000f062:	e8 7d f4 ff ff       	call   c000e4e4 <_ZNK8Exc_regs9tlb_flushI4VmcbEEvb>
c000f067:	8a 53 40             	mov    0x40(%ebx),%dl
c000f06a:	8a 43 41             	mov    0x41(%ebx),%al
template <typename T>
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
c000f06d:	84 d2                	test   %dl,%dl
c000f06f:	75 0b                	jne    c000f07c <_ZN8Exc_regs8write_crI4VmcbEEvjm+0xd8>
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
c000f071:	84 c0                	test   %al,%al
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
c000f073:	b9 01 00 01 80       	mov    $0x80010001,%ecx
    if (!fpu_on)
c000f078:	75 0f                	jne    c000f089 <_ZN8Exc_regs8write_crI4VmcbEEvjm+0xe5>
c000f07a:	eb 0a                	jmp    c000f086 <_ZN8Exc_regs8write_crI4VmcbEEvjm+0xe2>
c000f07c:	84 c0                	test   %al,%al
c000f07e:	0f 85 d2 00 00 00    	jne    c000f156 <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x1b2>
}

template <typename T>
mword Exc_regs::cr0_set() const
{
    mword set = 0;
c000f084:	31 c9                	xor    %ecx,%ecx

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
        set |= Cpu::CR0_TS;
c000f086:	83 c9 08             	or     $0x8,%ecx
}

template <typename T>
void Exc_regs::set_cr0 (mword v)
{
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
c000f089:	f7 d1                	not    %ecx
c000f08b:	83 c9 01             	or     $0x1,%ecx
c000f08e:	21 f1                	and    %esi,%ecx
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
c000f090:	80 fa 01             	cmp    $0x1,%dl
c000f093:	19 d2                	sbb    %edx,%edx
c000f095:	81 e2 01 00 01 80    	and    $0x80010001,%edx
    if (!fpu_on)
        set |= Cpu::CR0_TS;
c000f09b:	89 d7                	mov    %edx,%edi
c000f09d:	83 cf 08             	or     $0x8,%edi
c000f0a0:	84 c0                	test   %al,%al
c000f0a2:	0f 44 d7             	cmove  %edi,%edx
template <> mword Exc_regs::get_g_cr0<Vmcs>()           const { return Vmcs::read (Vmcs::GUEST_CR0); }
template <> mword Exc_regs::get_g_cr2<Vmcs>()           const { return cr2; }
template <> mword Exc_regs::get_g_cr3<Vmcs>()           const { return Vmcs::read (Vmcs::GUEST_CR3); }
template <> mword Exc_regs::get_g_cr4<Vmcs>()           const { return Vmcs::read (Vmcs::GUEST_CR4); }

template <> void Exc_regs::set_g_cr0<Vmcb> (mword v)    const { vmcb->cr0 = v; }
c000f0a5:	8b 43 20             	mov    0x20(%ebx),%eax
}

template <typename T>
void Exc_regs::set_cr0 (mword v)
{
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
c000f0a8:	83 e2 fe             	and    $0xfffffffe,%edx
c000f0ab:	09 d1                	or     %edx,%ecx
template <> mword Exc_regs::get_g_cr0<Vmcs>()           const { return Vmcs::read (Vmcs::GUEST_CR0); }
template <> mword Exc_regs::get_g_cr2<Vmcs>()           const { return cr2; }
template <> mword Exc_regs::get_g_cr3<Vmcs>()           const { return Vmcs::read (Vmcs::GUEST_CR3); }
template <> mword Exc_regs::get_g_cr4<Vmcs>()           const { return Vmcs::read (Vmcs::GUEST_CR4); }

template <> void Exc_regs::set_g_cr0<Vmcb> (mword v)    const { vmcb->cr0 = v; }
c000f0ad:	89 88 58 05 00 00    	mov    %ecx,0x558(%eax)
c000f0b3:	c7 80 5c 05 00 00 00 	movl   $0x0,0x55c(%eax)
c000f0ba:	00 00 00 
template <> void Exc_regs::set_g_cr2<Vmcs> (mword v)          { cr2 = v; }
template <> void Exc_regs::set_g_cr3<Vmcs> (mword v)    const { Vmcs::write (Vmcs::GUEST_CR3, v); }
template <> void Exc_regs::set_g_cr4<Vmcs> (mword v)    const { Vmcs::write (Vmcs::GUEST_CR4, v); }

template <> void Exc_regs::set_e_bmp<Vmcb> (uint32 v)   const { vmcb->intercept_exc = v; }
template <> void Exc_regs::set_s_cr0<Vmcb> (mword v)          { cr0_shadow = v; }
c000f0bd:	89 73 28             	mov    %esi,0x28(%ebx)
c000f0c0:	e9 9a 00 00 00       	jmp    c000f15f <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x1bb>
c000f0c5:	8a 50 40             	mov    0x40(%eax),%dl
template <> mword Exc_regs::get_g_flags<Vmcb>()         const { return static_cast<mword>(vmcb->rflags); }
template <> mword Exc_regs::get_g_efer<Vmcb>()          const { return static_cast<mword>(vmcb->efer); }
template <> mword Exc_regs::get_g_cr0<Vmcb>()           const { return static_cast<mword>(vmcb->cr0); }
template <> mword Exc_regs::get_g_cr2<Vmcb>()           const { return static_cast<mword>(vmcb->cr2); }
template <> mword Exc_regs::get_g_cr3<Vmcb>()           const { return static_cast<mword>(vmcb->cr3); }
template <> mword Exc_regs::get_g_cr4<Vmcb>()           const { return static_cast<mword>(vmcb->cr4); }
c000f0c8:	8b 4b 20             	mov    0x20(%ebx),%ecx
template <typename T>
mword Exc_regs::cr4_msk() const
{
    mword clr = nst_on ? 0 :
#ifdef __i386__
                Cpu::CR4_PGE | Cpu::CR4_PAE;
c000f0cb:	80 fa 01             	cmp    $0x1,%dl
c000f0ce:	19 c0                	sbb    %eax,%eax
template <> mword Exc_regs::get_g_flags<Vmcb>()         const { return static_cast<mword>(vmcb->rflags); }
template <> mword Exc_regs::get_g_efer<Vmcb>()          const { return static_cast<mword>(vmcb->efer); }
template <> mword Exc_regs::get_g_cr0<Vmcb>()           const { return static_cast<mword>(vmcb->cr0); }
template <> mword Exc_regs::get_g_cr2<Vmcb>()           const { return static_cast<mword>(vmcb->cr2); }
template <> mword Exc_regs::get_g_cr3<Vmcb>()           const { return static_cast<mword>(vmcb->cr3); }
template <> mword Exc_regs::get_g_cr4<Vmcb>()           const { return static_cast<mword>(vmcb->cr4); }
c000f0d0:	8b a9 48 05 00 00    	mov    0x548(%ecx),%ebp
template <typename T>
mword Exc_regs::cr4_msk() const
{
    mword clr = nst_on ? 0 :
#ifdef __i386__
                Cpu::CR4_PGE | Cpu::CR4_PAE;
c000f0d6:	25 a0 00 00 00       	and    $0xa0,%eax
c000f0db:	80 fa 01             	cmp    $0x1,%dl
template <typename T>
mword Exc_regs::get_cr4() const
{
    mword msk = cr4_msk<T>();

    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
c000f0de:	8b 4b 30             	mov    0x30(%ebx),%ecx
template <typename T>
mword Exc_regs::cr4_msk() const
{
    mword clr = nst_on ? 0 :
#ifdef __i386__
                Cpu::CR4_PGE | Cpu::CR4_PAE;
c000f0e1:	19 ff                	sbb    %edi,%edi
c000f0e3:	83 e7 10             	and    $0x10,%edi
            break;

        case 4:
            toggled = get_cr4<T>() ^ val;

            if (!nst_on)
c000f0e6:	84 d2                	test   %dl,%dl
c000f0e8:	75 1e                	jne    c000f108 <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x164>
                Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
                Cpu::CR4_PGE;
#endif

    return T::fix_cr4_clr | clr | cr4_set<T>();
c000f0ea:	09 f8                	or     %edi,%eax
c000f0ec:	89 c2                	mov    %eax,%edx
template <typename T>
mword Exc_regs::get_cr4() const
{
    mword msk = cr4_msk<T>();

    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
c000f0ee:	f7 d0                	not    %eax
c000f0f0:	21 e8                	and    %ebp,%eax
c000f0f2:	21 ca                	and    %ecx,%edx
c000f0f4:	09 d0                	or     %edx,%eax
            }

            break;

        case 4:
            toggled = get_cr4<T>() ^ val;
c000f0f6:	31 f0                	xor    %esi,%eax

            if (!nst_on)
                if (toggled & (Cpu::CR4_PGE | Cpu::CR4_PAE | Cpu::CR4_PSE))
c000f0f8:	a8 b0                	test   $0xb0,%al
c000f0fa:	74 0c                	je     c000f108 <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x164>
                    tlb_flush<T> (true);
c000f0fc:	ba 01 00 00 00       	mov    $0x1,%edx
c000f101:	89 d8                	mov    %ebx,%eax
c000f103:	e8 dc f3 ff ff       	call   c000e4e4 <_ZNK8Exc_regs9tlb_flushI4VmcbEEvb>
c000f108:	8a 53 40             	mov    0x40(%ebx),%dl
template <> mword Exc_regs::get_g_cr4<Vmcs>()           const { return Vmcs::read (Vmcs::GUEST_CR4); }

template <> void Exc_regs::set_g_cr0<Vmcb> (mword v)    const { vmcb->cr0 = v; }
template <> void Exc_regs::set_g_cr2<Vmcb> (mword v)          { vmcb->cr2 = v; }
template <> void Exc_regs::set_g_cr3<Vmcb> (mword v)    const { vmcb->cr3 = v; }
template <> void Exc_regs::set_g_cr4<Vmcb> (mword v)    const { vmcb->cr4 = v; }
c000f10b:	8b 4b 20             	mov    0x20(%ebx),%ecx
template <typename T>
mword Exc_regs::cr4_msk() const
{
    mword clr = nst_on ? 0 :
#ifdef __i386__
                Cpu::CR4_PGE | Cpu::CR4_PAE;
c000f10e:	80 fa 01             	cmp    $0x1,%dl
c000f111:	19 c0                	sbb    %eax,%eax
c000f113:	25 a0 00 00 00       	and    $0xa0,%eax
c000f118:	80 fa 01             	cmp    $0x1,%dl
c000f11b:	19 d2                	sbb    %edx,%edx
c000f11d:	83 e2 10             	and    $0x10,%edx
#else
                Cpu::CR4_PGE;
#endif

    return T::fix_cr4_clr | clr | cr4_set<T>();
c000f120:	09 d0                	or     %edx,%eax
}

template <typename T>
void Exc_regs::set_cr4 (mword v)
{
    set_g_cr4<T> ((v & ~cr4_msk<T>()) | cr4_set<T>());
c000f122:	f7 d0                	not    %eax
c000f124:	21 f0                	and    %esi,%eax
c000f126:	09 d0                	or     %edx,%eax
template <> mword Exc_regs::get_g_cr4<Vmcs>()           const { return Vmcs::read (Vmcs::GUEST_CR4); }

template <> void Exc_regs::set_g_cr0<Vmcb> (mword v)    const { vmcb->cr0 = v; }
template <> void Exc_regs::set_g_cr2<Vmcb> (mword v)          { vmcb->cr2 = v; }
template <> void Exc_regs::set_g_cr3<Vmcb> (mword v)    const { vmcb->cr3 = v; }
template <> void Exc_regs::set_g_cr4<Vmcb> (mword v)    const { vmcb->cr4 = v; }
c000f128:	89 81 48 05 00 00    	mov    %eax,0x548(%ecx)
c000f12e:	c7 81 4c 05 00 00 00 	movl   $0x0,0x54c(%ecx)
c000f135:	00 00 00 
template <> void Exc_regs::set_g_cr3<Vmcs> (mword v)    const { Vmcs::write (Vmcs::GUEST_CR3, v); }
template <> void Exc_regs::set_g_cr4<Vmcs> (mword v)    const { Vmcs::write (Vmcs::GUEST_CR4, v); }

template <> void Exc_regs::set_e_bmp<Vmcb> (uint32 v)   const { vmcb->intercept_exc = v; }
template <> void Exc_regs::set_s_cr0<Vmcb> (mword v)          { cr0_shadow = v; }
template <> void Exc_regs::set_s_cr4<Vmcb> (mword v)          { cr4_shadow = v; }
c000f138:	89 73 30             	mov    %esi,0x30(%ebx)
c000f13b:	eb 22                	jmp    c000f15f <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x1bb>
template <typename T>
mword Exc_regs::get_cr0() const
{
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
c000f13d:	8b 85 58 05 00 00    	mov    0x558(%ebp),%eax
c000f143:	25 fe ff fe 7f       	and    $0x7ffefffe,%eax
c000f148:	89 c2                	mov    %eax,%edx
c000f14a:	89 f8                	mov    %edi,%eax
c000f14c:	25 01 00 01 80       	and    $0x80010001,%eax
c000f151:	e9 fa fe ff ff       	jmp    c000f050 <_ZN8Exc_regs8write_crI4VmcbEEvjm+0xac>
}

template <typename T>
void Exc_regs::set_cr0 (mword v)
{
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
c000f156:	89 f1                	mov    %esi,%ecx
}

template <typename T>
mword Exc_regs::cr0_set() const
{
    mword set = 0;
c000f158:	31 d2                	xor    %edx,%edx
c000f15a:	e9 46 ff ff ff       	jmp    c000f0a5 <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x101>
            break;

        default:
            UNREACHED;
    }
}
c000f15f:	5b                   	pop    %ebx
c000f160:	5e                   	pop    %esi
c000f161:	5f                   	pop    %edi
c000f162:	5d                   	pop    %ebp
c000f163:	c3                   	ret    

c000f164 <_ZN8Exc_regs8write_crI4VmcsEEvjm>:
        default: UNREACHED;
    }
}

template <typename T>
void Exc_regs::write_cr (unsigned cr, mword val)
c000f164:	55                   	push   %ebp
{
    mword toggled;

    switch (cr) {
c000f165:	83 fa 02             	cmp    $0x2,%edx
        default: UNREACHED;
    }
}

template <typename T>
void Exc_regs::write_cr (unsigned cr, mword val)
c000f168:	57                   	push   %edi
c000f169:	56                   	push   %esi
c000f16a:	53                   	push   %ebx
c000f16b:	53                   	push   %ebx
{
    mword toggled;

    switch (cr) {
c000f16c:	74 22                	je     c000f190 <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x2c>
c000f16e:	89 ce                	mov    %ecx,%esi
c000f170:	89 c3                	mov    %eax,%ebx
c000f172:	77 09                	ja     c000f17d <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x19>
c000f174:	85 d2                	test   %edx,%edx
c000f176:	74 44                	je     c000f1bc <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x58>
c000f178:	e9 c0 01 00 00       	jmp    c000f33d <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x1d9>
c000f17d:	83 fa 03             	cmp    $0x3,%edx
c000f180:	74 16                	je     c000f198 <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x34>
c000f182:	83 fa 04             	cmp    $0x4,%edx
c000f185:	0f 84 17 01 00 00    	je     c000f2a2 <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x13e>
c000f18b:	e9 ad 01 00 00       	jmp    c000f33d <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x1d9>
template <> void Exc_regs::set_g_cr2<Vmcb> (mword v)          { vmcb->cr2 = v; }
template <> void Exc_regs::set_g_cr3<Vmcb> (mword v)    const { vmcb->cr3 = v; }
template <> void Exc_regs::set_g_cr4<Vmcb> (mword v)    const { vmcb->cr4 = v; }

template <> void Exc_regs::set_g_cr0<Vmcs> (mword v)    const { Vmcs::write (Vmcs::GUEST_CR0, v); }
template <> void Exc_regs::set_g_cr2<Vmcs> (mword v)          { cr2 = v; }
c000f190:	89 48 0c             	mov    %ecx,0xc(%eax)
c000f193:	e9 b5 01 00 00       	jmp    c000f34d <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x1e9>
        case 2:
            set_g_cr2<T> (val);
            break;

        case 3:
            if (!nst_on)
c000f198:	80 78 40 00          	cmpb   $0x0,0x40(%eax)
c000f19c:	75 07                	jne    c000f1a5 <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x41>
                tlb_flush<T> (false);
c000f19e:	31 d2                	xor    %edx,%edx
c000f1a0:	e8 5f f3 ff ff       	call   c000e504 <_ZNK8Exc_regs9tlb_flushI4VmcsEEvb>
}

template <typename T>
void Exc_regs::set_cr3 (mword v)
{
    if (nst_on)
c000f1a5:	80 7b 40 00          	cmpb   $0x0,0x40(%ebx)
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
c000f1a9:	b8 02 68 00 00       	mov    $0x6802,%eax
c000f1ae:	0f 85 84 01 00 00    	jne    c000f338 <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x1d4>
        set_g_cr3<T> (v);
    else
        cr3_shadow = v;
c000f1b4:	89 73 2c             	mov    %esi,0x2c(%ebx)
c000f1b7:	e9 91 01 00 00       	jmp    c000f34d <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x1e9>
c000f1bc:	8a 50 40             	mov    0x40(%eax),%dl
c000f1bf:	8b 0d 30 fb ff cf    	mov    0xcffffb30,%ecx
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
c000f1c5:	80 fa 01             	cmp    $0x1,%dl
c000f1c8:	19 ff                	sbb    %edi,%edi
c000f1ca:	81 e7 01 00 01 80    	and    $0x80010001,%edi
    if (!fpu_on)
        set |= Cpu::CR0_TS;
c000f1d0:	89 f8                	mov    %edi,%eax
c000f1d2:	83 c8 08             	or     $0x8,%eax
c000f1d5:	80 7b 41 00          	cmpb   $0x0,0x41(%ebx)
c000f1d9:	0f 44 f8             	cmove  %eax,%edi

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
c000f1dc:	b8 00 68 00 00       	mov    $0x6800,%eax
c000f1e1:	0b 0d 34 fb ff cf    	or     0xcffffb34,%ecx
}

template <typename T>
mword Exc_regs::cr0_msk() const
{
    return T::fix_cr0_clr | cr0_set<T>();
c000f1e7:	09 f9                	or     %edi,%ecx
c000f1e9:	0f 78 c0             	vmread %eax,%eax
template <typename T>
mword Exc_regs::get_cr0() const
{
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
c000f1ec:	89 cf                	mov    %ecx,%edi
c000f1ee:	23 4b 28             	and    0x28(%ebx),%ecx
c000f1f1:	f7 d7                	not    %edi
c000f1f3:	21 f8                	and    %edi,%eax
c000f1f5:	09 c8                	or     %ecx,%eax
            set_cr3<T> (val);

            break;

        case 0:
            toggled = get_cr0<T>() ^ val;
c000f1f7:	31 f0                	xor    %esi,%eax

            if (!nst_on)
c000f1f9:	84 d2                	test   %dl,%dl
            set_cr3<T> (val);

            break;

        case 0:
            toggled = get_cr0<T>() ^ val;
c000f1fb:	89 04 24             	mov    %eax,(%esp)

            if (!nst_on)
c000f1fe:	75 13                	jne    c000f213 <_ZN8Exc_regs8write_crI4VmcsEEvjm+0xaf>
                if (toggled & (Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE))
c000f200:	a9 01 00 01 80       	test   $0x80010001,%eax
c000f205:	74 0c                	je     c000f213 <_ZN8Exc_regs8write_crI4VmcsEEvjm+0xaf>
                    tlb_flush<T> (true);
c000f207:	ba 01 00 00 00       	mov    $0x1,%edx
c000f20c:	89 d8                	mov    %ebx,%eax
c000f20e:	e8 f1 f2 ff ff       	call   c000e504 <_ZNK8Exc_regs9tlb_flushI4VmcsEEvb>
c000f213:	8a 53 40             	mov    0x40(%ebx),%dl
}

template <typename T>
mword Exc_regs::cr0_msk() const
{
    return T::fix_cr0_clr | cr0_set<T>();
c000f216:	8b 0d 30 fb ff cf    	mov    0xcffffb30,%ecx
c000f21c:	8a 43 41             	mov    0x41(%ebx),%al
c000f21f:	8b 3d 34 fb ff cf    	mov    0xcffffb34,%edi
template <typename T>
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
c000f225:	84 d2                	test   %dl,%dl
c000f227:	75 0b                	jne    c000f234 <_ZN8Exc_regs8write_crI4VmcsEEvjm+0xd0>
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
c000f229:	84 c0                	test   %al,%al
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
c000f22b:	bd 01 00 01 80       	mov    $0x80010001,%ebp
    if (!fpu_on)
c000f230:	75 0f                	jne    c000f241 <_ZN8Exc_regs8write_crI4VmcsEEvjm+0xdd>
c000f232:	eb 0a                	jmp    c000f23e <_ZN8Exc_regs8write_crI4VmcsEEvjm+0xda>
c000f234:	84 c0                	test   %al,%al
c000f236:	0f 85 01 01 00 00    	jne    c000f33d <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x1d9>
}

template <typename T>
mword Exc_regs::cr0_set() const
{
    mword set = 0;
c000f23c:	31 ed                	xor    %ebp,%ebp

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
        set |= Cpu::CR0_TS;
c000f23e:	83 cd 08             	or     $0x8,%ebp
c000f241:	09 f9                	or     %edi,%ecx
}

template <typename T>
mword Exc_regs::cr0_msk() const
{
    return T::fix_cr0_clr | cr0_set<T>();
c000f243:	09 e9                	or     %ebp,%ecx
}

template <typename T>
void Exc_regs::set_cr0 (mword v)
{
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
c000f245:	f7 d1                	not    %ecx
c000f247:	83 c9 01             	or     $0x1,%ecx
c000f24a:	21 f1                	and    %esi,%ecx
mword Exc_regs::cr0_set() const
{
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
c000f24c:	80 fa 01             	cmp    $0x1,%dl
c000f24f:	19 d2                	sbb    %edx,%edx
c000f251:	81 e2 01 00 01 80    	and    $0x80010001,%edx
    if (!fpu_on)
        set |= Cpu::CR0_TS;
c000f257:	89 d5                	mov    %edx,%ebp
c000f259:	83 cd 08             	or     $0x8,%ebp
c000f25c:	84 c0                	test   %al,%al
c000f25e:	0f 44 d5             	cmove  %ebp,%edx

    return T::fix_cr0_set | set;
c000f261:	09 fa                	or     %edi,%edx
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
c000f263:	b8 00 68 00 00       	mov    $0x6800,%eax
}

template <typename T>
void Exc_regs::set_cr0 (mword v)
{
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
c000f268:	83 e2 fe             	and    $0xfffffffe,%edx
c000f26b:	09 d1                	or     %edx,%ecx
c000f26d:	0f 79 c1             	vmwrite %ecx,%eax
template <> void Exc_regs::set_e_bmp<Vmcb> (uint32 v)   const { vmcb->intercept_exc = v; }
template <> void Exc_regs::set_s_cr0<Vmcb> (mword v)          { cr0_shadow = v; }
template <> void Exc_regs::set_s_cr4<Vmcb> (mword v)          { cr4_shadow = v; }

template <> void Exc_regs::set_e_bmp<Vmcs> (uint32 v)   const { Vmcs::write (Vmcs::EXC_BITMAP, v); }
template <> void Exc_regs::set_s_cr0<Vmcs> (mword v)          { Vmcs::write (Vmcs::CR0_READ_SHADOW, cr0_shadow = v); }
c000f270:	89 73 28             	mov    %esi,0x28(%ebx)
c000f273:	66 b8 04 60          	mov    $0x6004,%ax
c000f277:	0f 79 c6             	vmwrite %esi,%eax
                if (toggled & (Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE))
                    tlb_flush<T> (true);

            set_cr0<T> (val);

            if (toggled & Cpu::CR0_PG) {
c000f27a:	83 3c 24 00          	cmpl   $0x0,(%esp)
c000f27e:	0f 89 c9 00 00 00    	jns    c000f34d <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x1e9>

                if (!T::has_urg())
c000f284:	f6 05 54 fb ff cf 80 	testb  $0x80,0xcffffb54
c000f28b:	0f 85 bc 00 00 00    	jne    c000f34d <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x1e9>
            break;

        default:
            UNREACHED;
    }
}
c000f291:	59                   	pop    %ecx
            set_cr0<T> (val);

            if (toggled & Cpu::CR0_PG) {

                if (!T::has_urg())
                    nst_ctrl<T> (val & Cpu::CR0_PG);
c000f292:	89 d8                	mov    %ebx,%eax
c000f294:	c1 ee 1f             	shr    $0x1f,%esi
            break;

        default:
            UNREACHED;
    }
}
c000f297:	5b                   	pop    %ebx
            set_cr0<T> (val);

            if (toggled & Cpu::CR0_PG) {

                if (!T::has_urg())
                    nst_ctrl<T> (val & Cpu::CR0_PG);
c000f298:	89 f2                	mov    %esi,%edx
            break;

        default:
            UNREACHED;
    }
}
c000f29a:	5e                   	pop    %esi
c000f29b:	5f                   	pop    %edi
c000f29c:	5d                   	pop    %ebp
            set_cr0<T> (val);

            if (toggled & Cpu::CR0_PG) {

                if (!T::has_urg())
                    nst_ctrl<T> (val & Cpu::CR0_PG);
c000f29d:	e9 a0 f5 ff ff       	jmp    c000e842 <_ZN8Exc_regs8nst_ctrlI4VmcsEEvb>
template <typename T>
mword Exc_regs::cr4_msk() const
{
    mword clr = nst_on ? 0 :
#ifdef __i386__
                Cpu::CR4_PGE | Cpu::CR4_PAE;
c000f2a2:	80 78 40 01          	cmpb   $0x1,0x40(%eax)
#else
                Cpu::CR4_PGE;
#endif

    return T::fix_cr4_clr | clr | cr4_set<T>();
c000f2a6:	8b 15 28 fb ff cf    	mov    0xcffffb28,%edx
                Cpu::CR4_PSE;
#else
                Cpu::CR4_PSE | Cpu::CR4_PAE;
#endif

    return T::fix_cr4_set | set;
c000f2ac:	8b 2d 2c fb ff cf    	mov    0xcffffb2c,%ebp
template <typename T>
mword Exc_regs::cr4_msk() const
{
    mword clr = nst_on ? 0 :
#ifdef __i386__
                Cpu::CR4_PGE | Cpu::CR4_PAE;
c000f2b2:	19 ff                	sbb    %edi,%edi
c000f2b4:	81 e7 a0 00 00 00    	and    $0xa0,%edi
template <typename T>
mword Exc_regs::cr4_set() const
{
    mword set = nst_on ? 0 :
#ifdef __i386__
                Cpu::CR4_PSE;
c000f2ba:	80 78 40 01          	cmpb   $0x1,0x40(%eax)

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
c000f2be:	b8 04 68 00 00       	mov    $0x6804,%eax
c000f2c3:	19 c9                	sbb    %ecx,%ecx
c000f2c5:	83 e1 10             	and    $0x10,%ecx
c000f2c8:	0f 78 04 24          	vmread %eax,(%esp)
            break;

        case 4:
            toggled = get_cr4<T>() ^ val;

            if (!nst_on)
c000f2cc:	80 7b 40 00          	cmpb   $0x0,0x40(%ebx)
template <typename T>
mword Exc_regs::get_cr4() const
{
    mword msk = cr4_msk<T>();

    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
c000f2d0:	8b 43 30             	mov    0x30(%ebx),%eax
            break;

        case 4:
            toggled = get_cr4<T>() ^ val;

            if (!nst_on)
c000f2d3:	75 25                	jne    c000f2fa <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x196>
c000f2d5:	09 d5                	or     %edx,%ebp
c000f2d7:	09 ef                	or     %ebp,%edi
                Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
                Cpu::CR4_PGE;
#endif

    return T::fix_cr4_clr | clr | cr4_set<T>();
c000f2d9:	09 f9                	or     %edi,%ecx
template <typename T>
mword Exc_regs::get_cr4() const
{
    mword msk = cr4_msk<T>();

    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
c000f2db:	89 cf                	mov    %ecx,%edi
c000f2dd:	21 c1                	and    %eax,%ecx
c000f2df:	f7 d7                	not    %edi
c000f2e1:	23 3c 24             	and    (%esp),%edi
c000f2e4:	89 f8                	mov    %edi,%eax
c000f2e6:	09 c8                	or     %ecx,%eax
            }

            break;

        case 4:
            toggled = get_cr4<T>() ^ val;
c000f2e8:	31 f0                	xor    %esi,%eax

            if (!nst_on)
                if (toggled & (Cpu::CR4_PGE | Cpu::CR4_PAE | Cpu::CR4_PSE))
c000f2ea:	a8 b0                	test   $0xb0,%al
c000f2ec:	74 0c                	je     c000f2fa <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x196>
                    tlb_flush<T> (true);
c000f2ee:	ba 01 00 00 00       	mov    $0x1,%edx
c000f2f3:	89 d8                	mov    %ebx,%eax
c000f2f5:	e8 0a f2 ff ff       	call   c000e504 <_ZNK8Exc_regs9tlb_flushI4VmcsEEvb>
c000f2fa:	8a 53 40             	mov    0x40(%ebx),%dl
                Cpu::CR4_PSE;
#else
                Cpu::CR4_PSE | Cpu::CR4_PAE;
#endif

    return T::fix_cr4_set | set;
c000f2fd:	8b 0d 2c fb ff cf    	mov    0xcffffb2c,%ecx
c000f303:	8b 3d 28 fb ff cf    	mov    0xcffffb28,%edi
template <typename T>
mword Exc_regs::cr4_msk() const
{
    mword clr = nst_on ? 0 :
#ifdef __i386__
                Cpu::CR4_PGE | Cpu::CR4_PAE;
c000f309:	80 fa 01             	cmp    $0x1,%dl
c000f30c:	19 c0                	sbb    %eax,%eax
c000f30e:	25 a0 00 00 00       	and    $0xa0,%eax
template <typename T>
mword Exc_regs::cr4_set() const
{
    mword set = nst_on ? 0 :
#ifdef __i386__
                Cpu::CR4_PSE;
c000f313:	80 fa 01             	cmp    $0x1,%dl
c000f316:	19 d2                	sbb    %edx,%edx
c000f318:	09 cf                	or     %ecx,%edi
c000f31a:	83 e2 10             	and    $0x10,%edx
c000f31d:	09 f8                	or     %edi,%eax
                Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
                Cpu::CR4_PGE;
#endif

    return T::fix_cr4_clr | clr | cr4_set<T>();
c000f31f:	09 d0                	or     %edx,%eax
}

template <typename T>
void Exc_regs::set_cr4 (mword v)
{
    set_g_cr4<T> ((v & ~cr4_msk<T>()) | cr4_set<T>());
c000f321:	f7 d0                	not    %eax
c000f323:	21 f0                	and    %esi,%eax
c000f325:	09 c8                	or     %ecx,%eax
c000f327:	09 c2                	or     %eax,%edx
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
c000f329:	b8 04 68 00 00       	mov    $0x6804,%eax
c000f32e:	0f 79 c2             	vmwrite %edx,%eax
template <> void Exc_regs::set_s_cr0<Vmcb> (mword v)          { cr0_shadow = v; }
template <> void Exc_regs::set_s_cr4<Vmcb> (mword v)          { cr4_shadow = v; }

template <> void Exc_regs::set_e_bmp<Vmcs> (uint32 v)   const { Vmcs::write (Vmcs::EXC_BITMAP, v); }
template <> void Exc_regs::set_s_cr0<Vmcs> (mword v)          { Vmcs::write (Vmcs::CR0_READ_SHADOW, cr0_shadow = v); }
template <> void Exc_regs::set_s_cr4<Vmcs> (mword v)          { Vmcs::write (Vmcs::CR4_READ_SHADOW, cr4_shadow = v); }
c000f331:	89 73 30             	mov    %esi,0x30(%ebx)
c000f334:	66 b8 06 60          	mov    $0x6006,%ax
c000f338:	0f 79 c6             	vmwrite %esi,%eax
c000f33b:	eb 10                	jmp    c000f34d <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x1e9>
}

template <typename T>
mword Exc_regs::cr0_msk() const
{
    return T::fix_cr0_clr | cr0_set<T>();
c000f33d:	09 f9                	or     %edi,%ecx
}

template <typename T>
mword Exc_regs::cr0_set() const
{
    mword set = 0;
c000f33f:	31 d2                	xor    %edx,%edx
}

template <typename T>
void Exc_regs::set_cr0 (mword v)
{
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
c000f341:	f7 d1                	not    %ecx
c000f343:	83 c9 01             	or     $0x1,%ecx
c000f346:	21 f1                	and    %esi,%ecx
c000f348:	e9 14 ff ff ff       	jmp    c000f261 <_ZN8Exc_regs8write_crI4VmcsEEvjm+0xfd>
            break;

        default:
            UNREACHED;
    }
}
c000f34d:	58                   	pop    %eax
c000f34e:	5b                   	pop    %ebx
c000f34f:	5e                   	pop    %esi
c000f350:	5f                   	pop    %edi
c000f351:	5d                   	pop    %ebp
c000f352:	c3                   	ret    
c000f353:	90                   	nop

c000f354 <_ZN2ScC1EP2PdmP2Ec>:

Sc *Sc::list[Sc::priorities];

unsigned Sc::prio_top;

Sc::Sc (Pd *own, mword sel, Ec *e) : Kobject (SC, static_cast<Space_obj *>(own), sel, 0x1, free), ec (e), cpu (static_cast<unsigned>(sel)), prio (0), budget (Lapic::freq_tsc * 1000), left (0), prev (nullptr), next (nullptr)
c000f354:	57                   	push   %edi
c000f355:	85 d2                	test   %edx,%edx
c000f357:	56                   	push   %esi
c000f358:	89 cf                	mov    %ecx,%edi
c000f35a:	53                   	push   %ebx
c000f35b:	89 c3                	mov    %eax,%ebx
c000f35d:	8b 74 24 10          	mov    0x10(%esp),%esi
c000f361:	8d 82 88 01 00 00    	lea    0x188(%edx),%eax
c000f367:	ba 00 00 00 00       	mov    $0x0,%edx
c000f36c:	6a 00                	push   $0x0
c000f36e:	0f 45 d0             	cmovne %eax,%edx
c000f371:	68 60 f9 00 c0       	push   $0xc000f960
c000f376:	89 d8                	mov    %ebx,%eax
c000f378:	6a 01                	push   $0x1
c000f37a:	51                   	push   %ecx
c000f37b:	89 d9                	mov    %ebx,%ecx
c000f37d:	e8 c4 38 ff ff       	call   c0002c46 <_ZN3MdbC1EP5SpacemmmPFvP8Rcu_elemES5_>
    private:
        uint32 ref;

    public:
        ALWAYS_INLINE
        inline Refex() : ref (1) {}
c000f382:	83 c4 10             	add    $0x10,%esp
c000f385:	c6 43 44 02          	movb   $0x2,0x44(%ebx)
c000f389:	66 c7 43 46 00 00    	movw   $0x0,0x46(%ebx)
c000f38f:	c7 43 48 01 00 00 00 	movl   $0x1,0x48(%ebx)

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c000f396:	8b 46 48             	mov    0x48(%esi),%eax
c000f399:	85 c0                	test   %eax,%eax
c000f39b:	74 0c                	je     c000f3a9 <_ZN2ScC1EP2PdmP2Ec+0x55>
                if (Atomic::cmp_swap (ref, r, r + 1))
c000f39d:	8d 50 01             	lea    0x1(%eax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c000f3a0:	f0 0f b1 56 48       	lock cmpxchg %edx,0x48(%esi)
c000f3a5:	75 ef                	jne    c000f396 <_ZN2ScC1EP2PdmP2Ec+0x42>
c000f3a7:	eb 02                	jmp    c000f3ab <_ZN2ScC1EP2PdmP2Ec+0x57>
    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }

        ALWAYS_INLINE
        inline Refptr (T *p) : ptr (p->add_ref() ? p : nullptr) {}
c000f3a9:	31 f6                	xor    %esi,%esi
c000f3ab:	69 05 78 b0 01 c0 e8 	imul   $0x3e8,0xc001b078,%eax
c000f3b2:	03 00 00 
c000f3b5:	89 73 4c             	mov    %esi,0x4c(%ebx)
c000f3b8:	89 7b 50             	mov    %edi,0x50(%ebx)
c000f3bb:	c7 43 54 00 00 00 00 	movl   $0x0,0x54(%ebx)
c000f3c2:	89 43 58             	mov    %eax,0x58(%ebx)
c000f3c5:	c7 43 5c 00 00 00 00 	movl   $0x0,0x5c(%ebx)
c000f3cc:	c7 43 68 00 00 00 00 	movl   $0x0,0x68(%ebx)
c000f3d3:	c7 43 6c 00 00 00 00 	movl   $0x0,0x6c(%ebx)
c000f3da:	c7 43 70 00 00 00 00 	movl   $0x0,0x70(%ebx)
c000f3e1:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
{
    trace (TRACE_SYSCALL, "SC:%p created (PD:%p Kernel)", this, own);
}
c000f3e8:	5b                   	pop    %ebx
c000f3e9:	5e                   	pop    %esi
c000f3ea:	5f                   	pop    %edi
c000f3eb:	c3                   	ret    

c000f3ec <_ZN2ScC1EP2PdmP2Ecjjj>:

Sc::Sc (Pd *own, mword sel, Ec *e, unsigned c, unsigned p, unsigned q) : Kobject (SC, static_cast<Space_obj *>(own), sel, 0x1, free), ec (e), cpu (c), prio (p), budget (Lapic::freq_tsc / 1000 * q), left (0), prev (nullptr), next (nullptr)
c000f3ec:	56                   	push   %esi
c000f3ed:	85 d2                	test   %edx,%edx
c000f3ef:	53                   	push   %ebx
c000f3f0:	89 c3                	mov    %eax,%ebx
c000f3f2:	8b 74 24 0c          	mov    0xc(%esp),%esi
c000f3f6:	8d 82 88 01 00 00    	lea    0x188(%edx),%eax
c000f3fc:	ba 00 00 00 00       	mov    $0x0,%edx
c000f401:	6a 00                	push   $0x0
c000f403:	0f 45 d0             	cmovne %eax,%edx
c000f406:	68 60 f9 00 c0       	push   $0xc000f960
c000f40b:	89 d8                	mov    %ebx,%eax
c000f40d:	6a 01                	push   $0x1
c000f40f:	51                   	push   %ecx
c000f410:	89 d9                	mov    %ebx,%ecx
c000f412:	e8 2f 38 ff ff       	call   c0002c46 <_ZN3MdbC1EP5SpacemmmPFvP8Rcu_elemES5_>
    private:
        uint32 ref;

    public:
        ALWAYS_INLINE
        inline Refex() : ref (1) {}
c000f417:	83 c4 10             	add    $0x10,%esp
c000f41a:	c6 43 44 02          	movb   $0x2,0x44(%ebx)
c000f41e:	66 c7 43 46 00 00    	movw   $0x0,0x46(%ebx)
c000f424:	c7 43 48 01 00 00 00 	movl   $0x1,0x48(%ebx)

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c000f42b:	8b 46 48             	mov    0x48(%esi),%eax
c000f42e:	85 c0                	test   %eax,%eax
c000f430:	74 0c                	je     c000f43e <_ZN2ScC1EP2PdmP2Ecjjj+0x52>
                if (Atomic::cmp_swap (ref, r, r + 1))
c000f432:	8d 50 01             	lea    0x1(%eax),%edx
c000f435:	f0 0f b1 56 48       	lock cmpxchg %edx,0x48(%esi)
c000f43a:	75 ef                	jne    c000f42b <_ZN2ScC1EP2PdmP2Ecjjj+0x3f>
c000f43c:	eb 02                	jmp    c000f440 <_ZN2ScC1EP2PdmP2Ecjjj+0x54>
    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }

        ALWAYS_INLINE
        inline Refptr (T *p) : ptr (p->add_ref() ? p : nullptr) {}
c000f43e:	31 f6                	xor    %esi,%esi
c000f440:	8b 44 24 10          	mov    0x10(%esp),%eax
c000f444:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
c000f449:	31 d2                	xor    %edx,%edx
c000f44b:	89 73 4c             	mov    %esi,0x4c(%ebx)
c000f44e:	c7 43 5c 00 00 00 00 	movl   $0x0,0x5c(%ebx)
c000f455:	c7 43 68 00 00 00 00 	movl   $0x0,0x68(%ebx)
c000f45c:	89 43 50             	mov    %eax,0x50(%ebx)
c000f45f:	8b 44 24 14          	mov    0x14(%esp),%eax
c000f463:	c7 43 6c 00 00 00 00 	movl   $0x0,0x6c(%ebx)
c000f46a:	c7 43 70 00 00 00 00 	movl   $0x0,0x70(%ebx)
c000f471:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
c000f478:	89 43 54             	mov    %eax,0x54(%ebx)
c000f47b:	a1 78 b0 01 c0       	mov    0xc001b078,%eax
c000f480:	f7 f1                	div    %ecx
c000f482:	0f af 44 24 18       	imul   0x18(%esp),%eax
c000f487:	89 43 58             	mov    %eax,0x58(%ebx)
{
    trace (TRACE_SYSCALL, "SC:%p created (EC:%p CPU:%#x P:%#x Q:%#x)", this, e, c, p, q);
}
c000f48a:	5b                   	pop    %ebx
c000f48b:	5e                   	pop    %esi
c000f48c:	c3                   	ret    
c000f48d:	90                   	nop

c000f48e <_ZN2ScC1EP2PdP2EcjPS_>:

Sc::Sc (Pd *own, Ec *e, unsigned c, Sc *x) : Kobject (SC, static_cast<Space_obj *>(own), 0, 0x1, free), ec (e), cpu (c), prio (x->prio), budget (x->budget), left (x->left)
c000f48e:	57                   	push   %edi
c000f48f:	85 d2                	test   %edx,%edx
c000f491:	56                   	push   %esi
c000f492:	89 ce                	mov    %ecx,%esi
c000f494:	53                   	push   %ebx
c000f495:	89 c3                	mov    %eax,%ebx
c000f497:	8b 7c 24 14          	mov    0x14(%esp),%edi
c000f49b:	8d 82 88 01 00 00    	lea    0x188(%edx),%eax
c000f4a1:	ba 00 00 00 00       	mov    $0x0,%edx
c000f4a6:	6a 00                	push   $0x0
c000f4a8:	0f 45 d0             	cmovne %eax,%edx
c000f4ab:	68 60 f9 00 c0       	push   $0xc000f960
c000f4b0:	89 d9                	mov    %ebx,%ecx
c000f4b2:	6a 01                	push   $0x1
c000f4b4:	89 d8                	mov    %ebx,%eax
c000f4b6:	6a 00                	push   $0x0
c000f4b8:	e8 89 37 ff ff       	call   c0002c46 <_ZN3MdbC1EP5SpacemmmPFvP8Rcu_elemES5_>
    private:
        uint32 ref;

    public:
        ALWAYS_INLINE
        inline Refex() : ref (1) {}
c000f4bd:	83 c4 10             	add    $0x10,%esp
c000f4c0:	c6 43 44 02          	movb   $0x2,0x44(%ebx)
c000f4c4:	66 c7 43 46 00 00    	movw   $0x0,0x46(%ebx)
c000f4ca:	c7 43 48 01 00 00 00 	movl   $0x1,0x48(%ebx)

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c000f4d1:	8b 46 48             	mov    0x48(%esi),%eax
c000f4d4:	85 c0                	test   %eax,%eax
c000f4d6:	74 0c                	je     c000f4e4 <_ZN2ScC1EP2PdP2EcjPS_+0x56>
                if (Atomic::cmp_swap (ref, r, r + 1))
c000f4d8:	8d 50 01             	lea    0x1(%eax),%edx
c000f4db:	f0 0f b1 56 48       	lock cmpxchg %edx,0x48(%esi)
c000f4e0:	75 ef                	jne    c000f4d1 <_ZN2ScC1EP2PdP2EcjPS_+0x43>
c000f4e2:	eb 02                	jmp    c000f4e6 <_ZN2ScC1EP2PdP2EcjPS_+0x58>
    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }

        ALWAYS_INLINE
        inline Refptr (T *p) : ptr (p->add_ref() ? p : nullptr) {}
c000f4e4:	31 f6                	xor    %esi,%esi
c000f4e6:	8b 44 24 10          	mov    0x10(%esp),%eax
c000f4ea:	89 73 4c             	mov    %esi,0x4c(%ebx)
c000f4ed:	89 43 50             	mov    %eax,0x50(%ebx)
c000f4f0:	8b 47 54             	mov    0x54(%edi),%eax
c000f4f3:	89 43 54             	mov    %eax,0x54(%ebx)
c000f4f6:	8b 47 58             	mov    0x58(%edi),%eax
c000f4f9:	8b 57 5c             	mov    0x5c(%edi),%edx
c000f4fc:	89 43 58             	mov    %eax,0x58(%ebx)
c000f4ff:	89 53 5c             	mov    %edx,0x5c(%ebx)
c000f502:	8b 47 68             	mov    0x68(%edi),%eax
c000f505:	8b 57 6c             	mov    0x6c(%edi),%edx
c000f508:	89 43 68             	mov    %eax,0x68(%ebx)
c000f50b:	89 53 6c             	mov    %edx,0x6c(%ebx)
{
    trace (TRACE_SYSCALL, "SC:%p created (EC:%p CPU:%#x P:%#x Q:%#llx) - xCPU", this, e, c, prio, budget / (Lapic::freq_bus / 1000));
}
c000f50e:	5b                   	pop    %ebx
c000f50f:	5e                   	pop    %esi
c000f510:	5f                   	pop    %edi
c000f511:	c3                   	ret    

c000f512 <_ZN2Sc13ready_enqueueEyb>:

void Sc::ready_enqueue (uint64 t, bool use_left)
{
c000f512:	55                   	push   %ebp
c000f513:	57                   	push   %edi
c000f514:	56                   	push   %esi
c000f515:	53                   	push   %ebx
c000f516:	89 c3                	mov    %eax,%ebx
c000f518:	83 ec 08             	sub    $0x8,%esp
c000f51b:	8a 44 24 1c          	mov    0x1c(%esp),%al
    assert (prio < priorities);
c000f51f:	83 7b 54 7f          	cmpl   $0x7f,0x54(%ebx)
{
    trace (TRACE_SYSCALL, "SC:%p created (EC:%p CPU:%#x P:%#x Q:%#llx) - xCPU", this, e, c, prio, budget / (Lapic::freq_bus / 1000));
}

void Sc::ready_enqueue (uint64 t, bool use_left)
{
c000f523:	88 44 24 03          	mov    %al,0x3(%esp)
    assert (prio < priorities);
c000f527:	76 13                	jbe    c000f53c <_ZN2Sc13ready_enqueueEyb+0x2a>
c000f529:	68 80 8f 01 c0       	push   $0xc0018f80
c000f52e:	6a 3b                	push   $0x3b
c000f530:	68 2e 8d 01 c0       	push   $0xc0018d2e
c000f535:	68 99 8d 01 c0       	push   $0xc0018d99
c000f53a:	eb 1b                	jmp    c000f557 <_ZN2Sc13ready_enqueueEyb+0x45>
    assert (cpu == Cpu::id);
c000f53c:	a1 04 f0 ff cf       	mov    0xcffff004,%eax
c000f541:	39 43 50             	cmp    %eax,0x50(%ebx)
c000f544:	74 25                	je     c000f56b <_ZN2Sc13ready_enqueueEyb+0x59>
c000f546:	68 80 8f 01 c0       	push   $0xc0018f80
c000f54b:	6a 3c                	push   $0x3c
c000f54d:	68 2e 8d 01 c0       	push   $0xc0018d2e
c000f552:	68 ab 8d 01 c0       	push   $0xc0018dab
c000f557:	68 69 60 01 c0       	push   $0xc0016069
c000f55c:	e8 e5 23 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
                if (Atomic::cmp_swap (ref, r, r + 1))
c000f561:	8d 70 01             	lea    0x1(%eax),%esi
c000f564:	f0 0f b1 73 48       	lock cmpxchg %esi,0x48(%ebx)
c000f569:	74 38                	je     c000f5a3 <_ZN2Sc13ready_enqueueEyb+0x91>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c000f56b:	8b 43 48             	mov    0x48(%ebx),%eax
c000f56e:	83 f8 ff             	cmp    $0xffffffff,%eax
c000f571:	75 ee                	jne    c000f561 <_ZN2Sc13ready_enqueueEyb+0x4f>

    if (!add_ref()) {
        trace (TRACE_ERROR, "SC:%p add_ref failed - %s", this, __func__);
c000f573:	8d 54 24 03          	lea    0x3(%esp),%edx
c000f577:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c000f57d:	81 fa 00 d0 ff cf    	cmp    $0xcfffd000,%edx
c000f583:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c000f58a:	68 68 8f 01 c0       	push   $0xc0018f68
c000f58f:	53                   	push   %ebx
c000f590:	50                   	push   %eax
c000f591:	68 ba 8d 01 c0       	push   $0xc0018dba
c000f596:	e8 43 24 ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c000f59b:	83 c4 10             	add    $0x10,%esp
c000f59e:	e9 95 00 00 00       	jmp    c000f638 <_ZN2Sc13ready_enqueueEyb+0x126>
        return;
    }

    if (prio > prio_top)
c000f5a3:	8b 43 54             	mov    0x54(%ebx),%eax
c000f5a6:	3b 05 00 f8 ff cf    	cmp    0xcffff800,%eax
c000f5ac:	76 05                	jbe    c000f5b3 <_ZN2Sc13ready_enqueueEyb+0xa1>
        prio_top = prio;
c000f5ae:	a3 00 f8 ff cf       	mov    %eax,0xcffff800

    if (!list[prio])
c000f5b3:	8b 34 85 20 f8 ff cf 	mov    -0x300007e0(,%eax,4),%esi
c000f5ba:	85 f6                	test   %esi,%esi
c000f5bc:	75 08                	jne    c000f5c6 <_ZN2Sc13ready_enqueueEyb+0xb4>
        list[prio] = prev = next = this;
c000f5be:	89 5b 74             	mov    %ebx,0x74(%ebx)
c000f5c1:	89 5b 70             	mov    %ebx,0x70(%ebx)
c000f5c4:	eb 28                	jmp    c000f5ee <_ZN2Sc13ready_enqueueEyb+0xdc>
    else {
        next = list[prio];
c000f5c6:	89 73 74             	mov    %esi,0x74(%ebx)
        prev = list[prio]->prev;
c000f5c9:	8b 04 85 20 f8 ff cf 	mov    -0x300007e0(,%eax,4),%eax
        next->prev = prev->next = this;
        if (use_left && left)
c000f5d0:	80 7c 24 03 00       	cmpb   $0x0,0x3(%esp)

    if (!list[prio])
        list[prio] = prev = next = this;
    else {
        next = list[prio];
        prev = list[prio]->prev;
c000f5d5:	8b 40 70             	mov    0x70(%eax),%eax
c000f5d8:	89 43 70             	mov    %eax,0x70(%ebx)
        next->prev = prev->next = this;
c000f5db:	89 58 74             	mov    %ebx,0x74(%eax)
c000f5de:	89 5e 70             	mov    %ebx,0x70(%esi)
        if (use_left && left)
c000f5e1:	74 12                	je     c000f5f5 <_ZN2Sc13ready_enqueueEyb+0xe3>
c000f5e3:	8b 43 6c             	mov    0x6c(%ebx),%eax
c000f5e6:	0b 43 68             	or     0x68(%ebx),%eax
c000f5e9:	74 0a                	je     c000f5f5 <_ZN2Sc13ready_enqueueEyb+0xe3>
            list[prio] = this;
c000f5eb:	8b 43 54             	mov    0x54(%ebx),%eax
c000f5ee:	89 1c 85 20 f8 ff cf 	mov    %ebx,-0x300007e0(,%eax,4)
    }

    trace (TRACE_SCHEDULE, "ENQ:%p (%llu) PRIO:%#x TOP:%#x %s", this, left, prio, prio_top, prio > current->prio ? "reschedule" : "");

    if (prio > current->prio || (this != current && prio == current->prio && (use_left && left)))
c000f5f5:	8b 2d 10 f0 ff cf    	mov    0xcffff010,%ebp
c000f5fb:	8b 73 6c             	mov    0x6c(%ebx),%esi
c000f5fe:	8b 45 54             	mov    0x54(%ebp),%eax
c000f601:	39 43 54             	cmp    %eax,0x54(%ebx)
c000f604:	77 14                	ja     c000f61a <_ZN2Sc13ready_enqueueEyb+0x108>
c000f606:	0f 94 c0             	sete   %al
c000f609:	84 44 24 03          	test   %al,0x3(%esp)
c000f60d:	74 12                	je     c000f621 <_ZN2Sc13ready_enqueueEyb+0x10f>
c000f60f:	39 eb                	cmp    %ebp,%ebx
c000f611:	74 0e                	je     c000f621 <_ZN2Sc13ready_enqueueEyb+0x10f>
c000f613:	89 f0                	mov    %esi,%eax
c000f615:	0b 43 68             	or     0x68(%ebx),%eax
c000f618:	74 07                	je     c000f621 <_ZN2Sc13ready_enqueueEyb+0x10f>
        Cpu::hazard |= HZD_SCHED;
c000f61a:	83 0d 00 f0 ff cf 01 	orl    $0x1,0xcffff000

    if (!left)
c000f621:	0b 73 68             	or     0x68(%ebx),%esi
c000f624:	75 0c                	jne    c000f632 <_ZN2Sc13ready_enqueueEyb+0x120>
        left = budget;
c000f626:	8b 73 58             	mov    0x58(%ebx),%esi
c000f629:	8b 7b 5c             	mov    0x5c(%ebx),%edi
c000f62c:	89 73 68             	mov    %esi,0x68(%ebx)
c000f62f:	89 7b 6c             	mov    %edi,0x6c(%ebx)

    tsc = t;
c000f632:	89 53 78             	mov    %edx,0x78(%ebx)
c000f635:	89 4b 7c             	mov    %ecx,0x7c(%ebx)
}
c000f638:	83 c4 08             	add    $0x8,%esp
c000f63b:	5b                   	pop    %ebx
c000f63c:	5e                   	pop    %esi
c000f63d:	5f                   	pop    %edi
c000f63e:	5d                   	pop    %ebp
c000f63f:	c3                   	ret    

c000f640 <_ZN2Sc13ready_dequeueEy>:

void Sc::ready_dequeue (uint64 t)
{
c000f640:	57                   	push   %edi
    assert (prio < priorities);
c000f641:	8b 78 54             	mov    0x54(%eax),%edi

    tsc = t;
}

void Sc::ready_dequeue (uint64 t)
{
c000f644:	56                   	push   %esi
c000f645:	53                   	push   %ebx
    assert (prio < priorities);
c000f646:	83 ff 7f             	cmp    $0x7f,%edi
c000f649:	76 13                	jbe    c000f65e <_ZN2Sc13ready_dequeueEy+0x1e>
c000f64b:	68 48 8f 01 c0       	push   $0xc0018f48
c000f650:	6a 5d                	push   $0x5d
c000f652:	68 2e 8d 01 c0       	push   $0xc0018d2e
c000f657:	68 99 8d 01 c0       	push   $0xc0018d99
c000f65c:	eb 1c                	jmp    c000f67a <_ZN2Sc13ready_dequeueEy+0x3a>
    assert (cpu == Cpu::id);
c000f65e:	8b 1d 04 f0 ff cf    	mov    0xcffff004,%ebx
c000f664:	39 58 50             	cmp    %ebx,0x50(%eax)
c000f667:	74 1b                	je     c000f684 <_ZN2Sc13ready_dequeueEy+0x44>
c000f669:	68 48 8f 01 c0       	push   $0xc0018f48
c000f66e:	6a 5e                	push   $0x5e
c000f670:	68 2e 8d 01 c0       	push   $0xc0018d2e
c000f675:	68 ab 8d 01 c0       	push   $0xc0018dab
c000f67a:	68 69 60 01 c0       	push   $0xc0016069
c000f67f:	e8 c2 22 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>
    assert (prev && next);
c000f684:	83 78 70 00          	cmpl   $0x0,0x70(%eax)
c000f688:	74 06                	je     c000f690 <_ZN2Sc13ready_dequeueEy+0x50>
c000f68a:	83 78 74 00          	cmpl   $0x0,0x74(%eax)
c000f68e:	75 13                	jne    c000f6a3 <_ZN2Sc13ready_dequeueEy+0x63>
c000f690:	68 48 8f 01 c0       	push   $0xc0018f48
c000f695:	6a 5f                	push   $0x5f
c000f697:	68 2e 8d 01 c0       	push   $0xc0018d2e
c000f69c:	68 db 8d 01 c0       	push   $0xc0018ddb
c000f6a1:	eb d7                	jmp    c000f67a <_ZN2Sc13ready_dequeueEy+0x3a>

    if (list[prio] == this)
c000f6a3:	39 04 bd 20 f8 ff cf 	cmp    %eax,-0x300007e0(,%edi,4)
c000f6aa:	75 14                	jne    c000f6c0 <_ZN2Sc13ready_dequeueEy+0x80>
        list[prio] = next == this ? nullptr : next;
c000f6ac:	8b 70 74             	mov    0x74(%eax),%esi
c000f6af:	bb 00 00 00 00       	mov    $0x0,%ebx
c000f6b4:	39 c6                	cmp    %eax,%esi
c000f6b6:	0f 44 f3             	cmove  %ebx,%esi
c000f6b9:	89 34 bd 20 f8 ff cf 	mov    %esi,-0x300007e0(,%edi,4)

    next->prev = prev;
c000f6c0:	8b 58 74             	mov    0x74(%eax),%ebx
c000f6c3:	8b 70 70             	mov    0x70(%eax),%esi
c000f6c6:	89 73 70             	mov    %esi,0x70(%ebx)
    prev->next = next;
c000f6c9:	8b 58 70             	mov    0x70(%eax),%ebx
c000f6cc:	8b 70 74             	mov    0x74(%eax),%esi
c000f6cf:	89 73 74             	mov    %esi,0x74(%ebx)
c000f6d2:	8b 1d 00 f8 ff cf    	mov    0xcffff800,%ebx
    prev = next = nullptr;
c000f6d8:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
c000f6df:	c7 40 70 00 00 00 00 	movl   $0x0,0x70(%eax)

    while (!list[prio_top] && prio_top)
c000f6e6:	83 3c 9d 20 f8 ff cf 	cmpl   $0x0,-0x300007e0(,%ebx,4)
c000f6ed:	00 
c000f6ee:	8d 73 ff             	lea    -0x1(%ebx),%esi
c000f6f1:	75 08                	jne    c000f6fb <_ZN2Sc13ready_dequeueEy+0xbb>
c000f6f3:	85 db                	test   %ebx,%ebx
c000f6f5:	74 04                	je     c000f6fb <_ZN2Sc13ready_dequeueEy+0xbb>
c000f6f7:	89 f3                	mov    %esi,%ebx
c000f6f9:	eb eb                	jmp    c000f6e6 <_ZN2Sc13ready_dequeueEy+0xa6>
c000f6fb:	89 1d 00 f8 ff cf    	mov    %ebx,0xcffff800
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
c000f701:	8b 58 4c             	mov    0x4c(%eax),%ebx
c000f704:	8b 70 78             	mov    0x78(%eax),%esi
c000f707:	8b 78 7c             	mov    0x7c(%eax),%edi
c000f70a:	03 b3 a4 00 00 00    	add    0xa4(%ebx),%esi
c000f710:	13 bb a8 00 00 00    	adc    0xa8(%ebx),%edi
        inline void clr_hazard (mword h) { Atomic::clr_mask (hzd, h); }

        ALWAYS_INLINE
        inline void add_tsc_offset (uint64 tsc)
        {
            tsc_offset += tsc;
c000f716:	29 d6                	sub    %edx,%esi
c000f718:	89 b3 a4 00 00 00    	mov    %esi,0xa4(%ebx)
c000f71e:	19 cf                	sbb    %ecx,%edi
c000f720:	89 bb a8 00 00 00    	mov    %edi,0xa8(%ebx)
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }
c000f726:	f0 81 8b a0 00 00 00 	lock orl $0x20000000,0xa0(%ebx)
c000f72d:	00 00 00 20 
    trace (TRACE_SCHEDULE, "DEQ:%p (%llu) PRIO:%#x TOP:%#x", this, left, prio, prio_top);

    ec->add_tsc_offset (tsc - t);

    tsc = t;
}
c000f731:	5b                   	pop    %ebx

    trace (TRACE_SCHEDULE, "DEQ:%p (%llu) PRIO:%#x TOP:%#x", this, left, prio, prio_top);

    ec->add_tsc_offset (tsc - t);

    tsc = t;
c000f732:	89 50 78             	mov    %edx,0x78(%eax)
}
c000f735:	5e                   	pop    %esi

    trace (TRACE_SCHEDULE, "DEQ:%p (%llu) PRIO:%#x TOP:%#x", this, left, prio, prio_top);

    ec->add_tsc_offset (tsc - t);

    tsc = t;
c000f736:	89 48 7c             	mov    %ecx,0x7c(%eax)
}
c000f739:	5f                   	pop    %edi
c000f73a:	c3                   	ret    
c000f73b:	90                   	nop

c000f73c <_ZN2Sc14remote_enqueueEv>:
    sc->ready_dequeue (t);
    sc->ec->activate();
}

void Sc::remote_enqueue()
{
c000f73c:	55                   	push   %ebp
c000f73d:	57                   	push   %edi
c000f73e:	56                   	push   %esi
c000f73f:	89 c6                	mov    %eax,%esi
c000f741:	53                   	push   %ebx
c000f742:	53                   	push   %ebx
    if (Cpu::id == cpu)
c000f743:	8b 40 50             	mov    0x50(%eax),%eax
c000f746:	39 05 04 f0 ff cf    	cmp    %eax,0xcffff004
c000f74c:	75 1f                	jne    c000f76d <_ZN2Sc14remote_enqueueEv+0x31>

ALWAYS_INLINE
static inline uint64 rdtsc()
{
    mword h, l;
    asm volatile ("rdtsc" : "=a" (l), "=d" (h));
c000f74e:	0f 31                	rdtsc  
c000f750:	89 d1                	mov    %edx,%ecx
        ready_enqueue (rdtsc());
c000f752:	89 c2                	mov    %eax,%edx
c000f754:	6a 01                	push   $0x1
c000f756:	89 f0                	mov    %esi,%eax
c000f758:	e8 b5 fd ff ff       	call   c000f512 <_ZN2Sc13ready_enqueueEyb>
c000f75d:	59                   	pop    %ecx
c000f75e:	e9 f5 00 00 00       	jmp    c000f858 <_ZN2Sc14remote_enqueueEv+0x11c>

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
                if (Atomic::cmp_swap (ref, r, r + 1))
c000f763:	8d 50 01             	lea    0x1(%eax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c000f766:	f0 0f b1 56 48       	lock cmpxchg %edx,0x48(%esi)
c000f76b:	74 38                	je     c000f7a5 <_ZN2Sc14remote_enqueueEv+0x69>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c000f76d:	8b 46 48             	mov    0x48(%esi),%eax
c000f770:	83 f8 ff             	cmp    $0xffffffff,%eax
c000f773:	75 ee                	jne    c000f763 <_ZN2Sc14remote_enqueueEv+0x27>

    else {
        if (!add_ref()) {
            trace (TRACE_ERROR, "SC:%p add_ref failed - %s", this, __func__);
c000f775:	8d 54 24 ff          	lea    -0x1(%esp),%edx
c000f779:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c000f77f:	81 fa 00 d0 ff cf    	cmp    $0xcfffd000,%edx
c000f785:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c000f78c:	68 04 8f 01 c0       	push   $0xc0018f04
c000f791:	56                   	push   %esi
c000f792:	50                   	push   %eax
c000f793:	68 ba 8d 01 c0       	push   $0xc0018dba
c000f798:	e8 41 22 ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c000f79d:	83 c4 10             	add    $0x10,%esp
c000f7a0:	e9 b3 00 00 00       	jmp    c000f858 <_ZN2Sc14remote_enqueueEv+0x11c>
        Sc (Pd *, Ec *, unsigned, Sc *);

        ALWAYS_INLINE
        static inline Rq *remote (unsigned long c)
        {
            return reinterpret_cast<typeof rq *>(reinterpret_cast<mword>(&rq) - CPU_LOCAL_DATA + HV_GLOBAL_CPUS + c * PAGE_SIZE);
c000f7a5:	8b 6e 50             	mov    0x50(%esi),%ebp
c000f7a8:	c1 e5 0c             	shl    $0xc,%ebp
c000f7ab:	8d bd 28 0a c0 ce    	lea    -0x313ff5d8(%ebp),%edi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c000f7b1:	9c                   	pushf  
c000f7b2:	5b                   	pop    %ebx
            return flags & 0x200;
c000f7b3:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c000f7b6:	80 e3 01             	and    $0x1,%bl
c000f7b9:	74 27                	je     c000f7e2 <_ZN2Sc14remote_enqueueEv+0xa6>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c000f7bb:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000f7c2:	75 16                	jne    c000f7da <_ZN2Sc14remote_enqueueEv+0x9e>
c000f7c4:	68 e0 8e 01 c0       	push   $0xc0018ee0
c000f7c9:	68 b7 00 00 00       	push   $0xb7
c000f7ce:	68 12 61 01 c0       	push   $0xc0016112
c000f7d3:	68 83 61 01 c0       	push   $0xc0016183
c000f7d8:	eb 6c                	jmp    c000f846 <_ZN2Sc14remote_enqueueEv+0x10a>

            asm volatile ("cli" : : : "memory");
c000f7da:	fa                   	cli    
            preemption = false;
c000f7db:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c000f7e2:	89 f8                	mov    %edi,%eax
c000f7e4:	e8 43 13 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>

        Sc::Rq *r = remote (cpu);

        Lock_guard <Spinlock> guard (r->lock);

        if (r->queue) {
c000f7e9:	8b 47 04             	mov    0x4(%edi),%eax
c000f7ec:	85 c0                	test   %eax,%eax
c000f7ee:	74 14                	je     c000f804 <_ZN2Sc14remote_enqueueEv+0xc8>
            next = r->queue;
c000f7f0:	89 46 74             	mov    %eax,0x74(%esi)
            prev = r->queue->prev;
c000f7f3:	8b 57 04             	mov    0x4(%edi),%edx
c000f7f6:	8b 52 70             	mov    0x70(%edx),%edx
c000f7f9:	89 56 70             	mov    %edx,0x70(%esi)
            next->prev = prev->next = this;
c000f7fc:	89 72 74             	mov    %esi,0x74(%edx)
c000f7ff:	89 70 70             	mov    %esi,0x70(%eax)
c000f802:	eb 1b                	jmp    c000f81f <_ZN2Sc14remote_enqueueEv+0xe3>
        } else {
            r->queue = prev = next = this;
c000f804:	89 76 74             	mov    %esi,0x74(%esi)
            Lapic::send_ipi (cpu, VEC_IPI_RRQ);
c000f807:	ba a7 00 00 00       	mov    $0xa7,%edx
c000f80c:	31 c9                	xor    %ecx,%ecx
        if (r->queue) {
            next = r->queue;
            prev = r->queue->prev;
            next->prev = prev->next = this;
        } else {
            r->queue = prev = next = this;
c000f80e:	89 76 70             	mov    %esi,0x70(%esi)
c000f811:	89 77 04             	mov    %esi,0x4(%edi)
            Lapic::send_ipi (cpu, VEC_IPI_RRQ);
c000f814:	8b 46 50             	mov    0x50(%esi),%eax
c000f817:	6a 00                	push   $0x0
c000f819:	e8 36 65 ff ff       	call   c0005d54 <_ZN5Lapic8send_ipiEjjNS_13Delivery_modeENS_9ShorthandE>
c000f81e:	5a                   	pop    %edx
        }

        ALWAYS_INLINE
        inline void unlock()
        {
            asm volatile ("incb %0" : "=m" (val) : : "memory");
c000f81f:	fe 85 28 0a c0 ce    	incb   -0x313ff5d8(%ebp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c000f825:	84 db                	test   %bl,%bl
c000f827:	74 2f                	je     c000f858 <_ZN2Sc14remote_enqueueEv+0x11c>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000f829:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000f830:	74 1e                	je     c000f850 <_ZN2Sc14remote_enqueueEv+0x114>
c000f832:	68 a0 8e 01 c0       	push   $0xc0018ea0
c000f837:	68 c0 00 00 00       	push   $0xc0
c000f83c:	68 12 61 01 c0       	push   $0xc0016112
c000f841:	68 82 61 01 c0       	push   $0xc0016182
c000f846:	68 69 60 01 c0       	push   $0xc0016069
c000f84b:	e8 f6 20 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

            preemption = true;
c000f850:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000f857:	fb                   	sti    
        }
    }
}
c000f858:	58                   	pop    %eax
c000f859:	5b                   	pop    %ebx
c000f85a:	5e                   	pop    %esi
c000f85b:	5f                   	pop    %edi
c000f85c:	5d                   	pop    %ebp
c000f85d:	c3                   	ret    

c000f85e <_ZN2Sc11rrq_handlerEv>:

void Sc::rrq_handler()
{
c000f85e:	55                   	push   %ebp
c000f85f:	57                   	push   %edi
c000f860:	56                   	push   %esi
c000f861:	53                   	push   %ebx
c000f862:	0f 31                	rdtsc  
c000f864:	89 d5                	mov    %edx,%ebp
c000f866:	89 c7                	mov    %eax,%edi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c000f868:	9c                   	pushf  
c000f869:	5b                   	pop    %ebx
            return flags & 0x200;
c000f86a:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c000f86d:	80 e3 01             	and    $0x1,%bl
c000f870:	74 27                	je     c000f899 <_ZN2Sc11rrq_handlerEv+0x3b>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c000f872:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000f879:	75 16                	jne    c000f891 <_ZN2Sc11rrq_handlerEv+0x33>
c000f87b:	68 e0 8e 01 c0       	push   $0xc0018ee0
c000f880:	68 b7 00 00 00       	push   $0xb7
c000f885:	68 12 61 01 c0       	push   $0xc0016112
c000f88a:	68 83 61 01 c0       	push   $0xc0016183
c000f88f:	eb 7f                	jmp    c000f910 <_ZN2Sc11rrq_handlerEv+0xb2>

            asm volatile ("cli" : : : "memory");
c000f891:	fa                   	cli    
            preemption = false;
c000f892:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c000f899:	b8 28 fa ff cf       	mov    $0xcffffa28,%eax
c000f89e:	e8 89 12 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    uint64 t = rdtsc();

    Lock_guard <Spinlock> guard (rq.lock);

    for (Sc *ptr = rq.queue; ptr; ) {
c000f8a3:	a1 2c fa ff cf       	mov    0xcffffa2c,%eax
c000f8a8:	85 c0                	test   %eax,%eax
c000f8aa:	74 33                	je     c000f8df <_ZN2Sc11rrq_handlerEv+0x81>

        ptr->next->prev = ptr->prev;
c000f8ac:	8b 50 74             	mov    0x74(%eax),%edx
c000f8af:	8b 48 70             	mov    0x70(%eax),%ecx
c000f8b2:	89 4a 70             	mov    %ecx,0x70(%edx)
        ptr->prev->next = ptr->next;
c000f8b5:	8b 50 70             	mov    0x70(%eax),%edx
c000f8b8:	8b 48 74             	mov    0x74(%eax),%ecx
c000f8bb:	89 4a 74             	mov    %ecx,0x74(%edx)

        Sc *sc = ptr;

        ptr = ptr->next == ptr ? nullptr : ptr->next;
c000f8be:	ba 00 00 00 00       	mov    $0x0,%edx
c000f8c3:	8b 70 74             	mov    0x74(%eax),%esi
c000f8c6:	39 c6                	cmp    %eax,%esi
c000f8c8:	0f 44 f2             	cmove  %edx,%esi
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c000f8cb:	f0 ff 48 48          	lock decl 0x48(%eax)

        sc->del_ref();
        sc->ready_enqueue (t);
c000f8cf:	6a 01                	push   $0x1
c000f8d1:	89 fa                	mov    %edi,%edx
c000f8d3:	89 e9                	mov    %ebp,%ecx
c000f8d5:	e8 38 fc ff ff       	call   c000f512 <_ZN2Sc13ready_enqueueEyb>
c000f8da:	58                   	pop    %eax
        ptr->next->prev = ptr->prev;
        ptr->prev->next = ptr->next;

        Sc *sc = ptr;

        ptr = ptr->next == ptr ? nullptr : ptr->next;
c000f8db:	89 f0                	mov    %esi,%eax
c000f8dd:	eb c9                	jmp    c000f8a8 <_ZN2Sc11rrq_handlerEv+0x4a>

        sc->del_ref();
        sc->ready_enqueue (t);
    }

    rq.queue = nullptr;
c000f8df:	c7 05 2c fa ff cf 00 	movl   $0x0,0xcffffa2c
c000f8e6:	00 00 00 
c000f8e9:	fe 05 28 fa ff cf    	incb   0xcffffa28
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c000f8ef:	84 db                	test   %bl,%bl
c000f8f1:	74 2f                	je     c000f922 <_ZN2Sc11rrq_handlerEv+0xc4>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000f8f3:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000f8fa:	74 1e                	je     c000f91a <_ZN2Sc11rrq_handlerEv+0xbc>
c000f8fc:	68 a0 8e 01 c0       	push   $0xc0018ea0
c000f901:	68 c0 00 00 00       	push   $0xc0
c000f906:	68 12 61 01 c0       	push   $0xc0016112
c000f90b:	68 82 61 01 c0       	push   $0xc0016182
c000f910:	68 69 60 01 c0       	push   $0xc0016069
c000f915:	e8 2c 20 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

            preemption = true;
c000f91a:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000f921:	fb                   	sti    
}
c000f922:	5b                   	pop    %ebx
c000f923:	5e                   	pop    %esi
c000f924:	5f                   	pop    %edi
c000f925:	5d                   	pop    %ebp
c000f926:	c3                   	ret    
c000f927:	90                   	nop

c000f928 <_ZN2Sc11rke_handlerEv>:

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
c000f928:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c000f92d:	8b 90 70 01 00 00    	mov    0x170(%eax),%edx

void Sc::rke_handler()
{
    if (Pd::current->Space_mem::htlb.chk (Cpu::id))
c000f933:	a1 04 f0 ff cf       	mov    0xcffff004,%eax
c000f938:	0f a3 c2             	bt     %eax,%edx
c000f93b:	73 07                	jae    c000f944 <_ZN2Sc11rke_handlerEv+0x1c>
        Cpu::hazard |= HZD_SCHED;
c000f93d:	83 0d 00 f0 ff cf 01 	orl    $0x1,0xcffff000
c000f944:	c3                   	ret    

c000f945 <_ZN2ScdlEPv>:
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
c000f945:	8b 50 4c             	mov    0x4c(%eax),%edx
}

void Sc::operator delete (void *ptr) { cache.free (ptr, static_cast<Sc *>(ptr)->ec->pd->quota); }
c000f948:	8b 8a b8 00 00 00    	mov    0xb8(%edx),%ecx
c000f94e:	89 c2                	mov    %eax,%edx
c000f950:	b8 98 b4 01 c0       	mov    $0xc001b498,%eax
c000f955:	81 c1 90 01 00 00    	add    $0x190,%ecx
c000f95b:	e9 00 0a 00 00       	jmp    c0010360 <_ZN10Slab_cache4freeEPvR5Quota>

c000f960 <_ZN2Sc4freeEP8Rcu_elem>:

        void ready_enqueue (uint64, bool use_left = true);
        void ready_dequeue (uint64);

        static void free (Rcu_elem * a) {
            Sc * s = static_cast<Sc *>(a);
c000f960:	8d 50 f4             	lea    -0xc(%eax),%edx
c000f963:	85 c0                	test   %eax,%eax
        static unsigned prio_top CPULOCAL;

        void ready_enqueue (uint64, bool use_left = true);
        void ready_dequeue (uint64);

        static void free (Rcu_elem * a) {
c000f965:	53                   	push   %ebx
            Sc * s = static_cast<Sc *>(a);
c000f966:	bb 00 00 00 00       	mov    $0x0,%ebx
c000f96b:	0f 45 da             	cmovne %edx,%ebx
c000f96e:	83 c8 ff             	or     $0xffffffff,%eax
c000f971:	f0 0f c1 43 48       	lock xadd %eax,0x48(%ebx)
              
            if (s->del_ref()) {
c000f976:	48                   	dec    %eax
c000f977:	75 36                	jne    c000f9af <_ZN2Sc4freeEP8Rcu_elem+0x4f>
                assert(Sc::current != s);
c000f979:	39 1d 10 f0 ff cf    	cmp    %ebx,0xcffff010
c000f97f:	75 1b                	jne    c000f99c <_ZN2Sc4freeEP8Rcu_elem+0x3c>
c000f981:	68 c0 8f 01 c0       	push   $0xc0018fc0
c000f986:	6a 41                	push   $0x41
c000f988:	68 e8 8d 01 c0       	push   $0xc0018de8
c000f98d:	68 57 8e 01 c0       	push   $0xc0018e57
c000f992:	68 69 60 01 c0       	push   $0xc0016069
c000f997:	e8 aa 1f ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>
                delete s;
c000f99c:	85 db                	test   %ebx,%ebx
c000f99e:	74 0f                	je     c000f9af <_ZN2Sc4freeEP8Rcu_elem+0x4f>
c000f9a0:	89 d8                	mov    %ebx,%eax
c000f9a2:	e8 d3 69 ff ff       	call   c000637a <_ZN2ScD1Ev>
c000f9a7:	89 d8                	mov    %ebx,%eax
            }
        }
c000f9a9:	5b                   	pop    %ebx
        static void free (Rcu_elem * a) {
            Sc * s = static_cast<Sc *>(a);
              
            if (s->del_ref()) {
                assert(Sc::current != s);
                delete s;
c000f9aa:	e9 96 ff ff ff       	jmp    c000f945 <_ZN2ScdlEPv>
            }
        }
c000f9af:	5b                   	pop    %ebx
c000f9b0:	c3                   	ret    
c000f9b1:	90                   	nop

c000f9b2 <_ZN2Sc8scheduleEbb>:

    tsc = t;
}

void Sc::schedule (bool suspend, bool use_left)
{
c000f9b2:	55                   	push   %ebp
c000f9b3:	57                   	push   %edi
c000f9b4:	56                   	push   %esi
c000f9b5:	53                   	push   %ebx
c000f9b6:	88 c3                	mov    %al,%bl
c000f9b8:	83 ec 0c             	sub    $0xc,%esp
    Counter::print<1,16> (++Counter::schedule, Console_vga::COLOR_LIGHT_CYAN, SPN_SCH);
c000f9bb:	a1 2c f0 ff cf       	mov    0xcffff02c,%eax

    tsc = t;
}

void Sc::schedule (bool suspend, bool use_left)
{
c000f9c0:	88 54 24 0b          	mov    %dl,0xb(%esp)
    Counter::print<1,16> (++Counter::schedule, Console_vga::COLOR_LIGHT_CYAN, SPN_SCH);
c000f9c4:	8d 50 01             	lea    0x1(%eax),%edx
        }

        template <unsigned D, unsigned B>
        static void print (mword val, Console_vga::Color c, unsigned col)
        {
            if (EXPECT_FALSE (Cpu::row))
c000f9c7:	a1 50 f7 ff cf       	mov    0xcffff750,%eax
c000f9cc:	89 15 2c f0 ff cf    	mov    %edx,0xcffff02c
c000f9d2:	85 c0                	test   %eax,%eax
c000f9d4:	0f 85 4f 01 00 00    	jne    c000fb29 <_ZN2Sc8scheduleEbb+0x177>

    assert (current);
c000f9da:	a1 10 f0 ff cf       	mov    0xcffff010,%eax
c000f9df:	85 c0                	test   %eax,%eax
c000f9e1:	75 13                	jne    c000f9f6 <_ZN2Sc8scheduleEbb+0x44>
c000f9e3:	68 20 8f 01 c0       	push   $0xc0018f20
c000f9e8:	6a 76                	push   $0x76
c000f9ea:	68 2e 8d 01 c0       	push   $0xc0018d2e
c000f9ef:	68 a6 6c 01 c0       	push   $0xc0016ca6
c000f9f4:	eb 1b                	jmp    c000fa11 <_ZN2Sc8scheduleEbb+0x5f>
    assert (suspend || !current->prev);
c000f9f6:	84 db                	test   %bl,%bl
c000f9f8:	75 21                	jne    c000fa1b <_ZN2Sc8scheduleEbb+0x69>
c000f9fa:	83 78 70 00          	cmpl   $0x0,0x70(%eax)
c000f9fe:	74 1b                	je     c000fa1b <_ZN2Sc8scheduleEbb+0x69>
c000fa00:	68 20 8f 01 c0       	push   $0xc0018f20
c000fa05:	6a 77                	push   $0x77
c000fa07:	68 2e 8d 01 c0       	push   $0xc0018d2e
c000fa0c:	68 6b 8e 01 c0       	push   $0xc0018e6b
    else
    if (EXPECT_TRUE (!suspend))
        current->ready_enqueue (t, use_left);

    Sc *sc = list[prio_top];
    assert (sc);
c000fa11:	68 69 60 01 c0       	push   $0xc0016069
c000fa16:	e8 2b 1f ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>
c000fa1b:	0f 31                	rdtsc  
    return static_cast<uint64>(h) << 32 | l;
c000fa1d:	89 c6                	mov    %eax,%esi

    assert (current);
    assert (suspend || !current->prev);

    uint64 t = rdtsc();
    uint64 d = Timeout_budget::budget.dequeue();
c000fa1f:	b8 44 fa ff cf       	mov    $0xcffffa44,%eax
c000fa24:	89 d7                	mov    %edx,%edi
c000fa26:	e8 6d 48 00 00       	call   c0014298 <_ZN7Timeout7dequeueEv>

    current->time += t - current->tsc;
c000fa2b:	8b 0d 10 f0 ff cf    	mov    0xcffff010,%ecx

    assert (current);
    assert (suspend || !current->prev);

    uint64 t = rdtsc();
    uint64 d = Timeout_budget::budget.dequeue();
c000fa31:	89 04 24             	mov    %eax,(%esp)
c000fa34:	89 f0                	mov    %esi,%eax
c000fa36:	03 41 60             	add    0x60(%ecx),%eax
c000fa39:	89 54 24 04          	mov    %edx,0x4(%esp)
c000fa3d:	89 fa                	mov    %edi,%edx
c000fa3f:	13 51 64             	adc    0x64(%ecx),%edx

    current->time += t - current->tsc;
c000fa42:	2b 41 78             	sub    0x78(%ecx),%eax
c000fa45:	1b 51 7c             	sbb    0x7c(%ecx),%edx
    current->left = d > t ? d - t : 0;
c000fa48:	39 7c 24 04          	cmp    %edi,0x4(%esp)
    assert (suspend || !current->prev);

    uint64 t = rdtsc();
    uint64 d = Timeout_budget::budget.dequeue();

    current->time += t - current->tsc;
c000fa4c:	89 41 60             	mov    %eax,0x60(%ecx)
c000fa4f:	89 51 64             	mov    %edx,0x64(%ecx)
    current->left = d > t ? d - t : 0;
c000fa52:	0f 86 bd 00 00 00    	jbe    c000fb15 <_ZN2Sc8scheduleEbb+0x163>
c000fa58:	8b 04 24             	mov    (%esp),%eax
c000fa5b:	8b 54 24 04          	mov    0x4(%esp),%edx
c000fa5f:	29 f0                	sub    %esi,%eax
c000fa61:	19 fa                	sbb    %edi,%edx

    Cpu::hazard &= ~HZD_SCHED;
c000fa63:	83 25 00 f0 ff cf fe 	andl   $0xfffffffe,0xcffff000

    uint64 t = rdtsc();
    uint64 d = Timeout_budget::budget.dequeue();

    current->time += t - current->tsc;
    current->left = d > t ? d - t : 0;
c000fa6a:	89 41 68             	mov    %eax,0x68(%ecx)
c000fa6d:	83 c8 ff             	or     $0xffffffff,%eax
c000fa70:	89 51 6c             	mov    %edx,0x6c(%ecx)
c000fa73:	f0 0f c1 41 48       	lock xadd %eax,0x48(%ecx)

    Cpu::hazard &= ~HZD_SCHED;

    if (EXPECT_FALSE(current->del_ref()) && (Ec::current == current->ec))
c000fa78:	48                   	dec    %eax
c000fa79:	75 21                	jne    c000fa9c <_ZN2Sc8scheduleEbb+0xea>
c000fa7b:	8b 2d 10 f0 ff cf    	mov    0xcffff010,%ebp
c000fa81:	8b 45 4c             	mov    0x4c(%ebp),%eax
c000fa84:	39 05 08 f0 ff cf    	cmp    %eax,0xcffff008
c000fa8a:	75 10                	jne    c000fa9c <_ZN2Sc8scheduleEbb+0xea>
        delete current;
c000fa8c:	89 e8                	mov    %ebp,%eax
c000fa8e:	e8 e7 68 ff ff       	call   c000637a <_ZN2ScD1Ev>
c000fa93:	89 e8                	mov    %ebp,%eax
c000fa95:	e8 ab fe ff ff       	call   c000f945 <_ZN2ScdlEPv>
c000fa9a:	eb 19                	jmp    c000fab5 <_ZN2Sc8scheduleEbb+0x103>
    else
    if (EXPECT_TRUE (!suspend))
c000fa9c:	84 db                	test   %bl,%bl
c000fa9e:	75 15                	jne    c000fab5 <_ZN2Sc8scheduleEbb+0x103>
        current->ready_enqueue (t, use_left);
c000faa0:	0f b6 54 24 0b       	movzbl 0xb(%esp),%edx
c000faa5:	89 f9                	mov    %edi,%ecx
c000faa7:	a1 10 f0 ff cf       	mov    0xcffff010,%eax
c000faac:	52                   	push   %edx
c000faad:	89 f2                	mov    %esi,%edx
c000faaf:	e8 5e fa ff ff       	call   c000f512 <_ZN2Sc13ready_enqueueEyb>
c000fab4:	58                   	pop    %eax

    Sc *sc = list[prio_top];
c000fab5:	a1 00 f8 ff cf       	mov    0xcffff800,%eax
c000faba:	8b 1c 85 20 f8 ff cf 	mov    -0x300007e0(,%eax,4),%ebx
    assert (sc);
c000fac1:	85 db                	test   %ebx,%ebx
c000fac3:	75 19                	jne    c000fade <_ZN2Sc8scheduleEbb+0x12c>
c000fac5:	68 20 8f 01 c0       	push   $0xc0018f20
c000faca:	68 88 00 00 00       	push   $0x88
c000facf:	68 2e 8d 01 c0       	push   $0xc0018d2e
c000fad4:	68 68 8e 01 c0       	push   $0xc0018e68
c000fad9:	e9 33 ff ff ff       	jmp    c000fa11 <_ZN2Sc8scheduleEbb+0x5f>

    Timeout_budget::budget.enqueue (t + sc->left);
c000fade:	89 f2                	mov    %esi,%edx
c000fae0:	89 f9                	mov    %edi,%ecx
c000fae2:	03 53 68             	add    0x68(%ebx),%edx
c000fae5:	b8 44 fa ff cf       	mov    $0xcffffa44,%eax
c000faea:	13 4b 6c             	adc    0x6c(%ebx),%ecx
c000faed:	e8 fc 46 00 00       	call   c00141ee <_ZN7Timeout7enqueueEy>

    ctr_loop = 0;

    current = sc;
    sc->ready_dequeue (t);
c000faf2:	89 d8                	mov    %ebx,%eax
c000faf4:	89 f2                	mov    %esi,%edx
c000faf6:	89 f9                	mov    %edi,%ecx
    Sc *sc = list[prio_top];
    assert (sc);

    Timeout_budget::budget.enqueue (t + sc->left);

    ctr_loop = 0;
c000faf8:	c7 05 20 fa ff cf 00 	movl   $0x0,0xcffffa20
c000faff:	00 00 00 

    current = sc;
c000fb02:	89 1d 10 f0 ff cf    	mov    %ebx,0xcffff010
    sc->ready_dequeue (t);
c000fb08:	e8 33 fb ff ff       	call   c000f640 <_ZN2Sc13ready_dequeueEy>
    sc->ec->activate();
c000fb0d:	8b 43 4c             	mov    0x4c(%ebx),%eax
c000fb10:	e8 03 1d 00 00       	call   c0011818 <_ZN2Ec8activateEv>

    uint64 t = rdtsc();
    uint64 d = Timeout_budget::budget.dequeue();

    current->time += t - current->tsc;
    current->left = d > t ? d - t : 0;
c000fb15:	72 09                	jb     c000fb20 <_ZN2Sc8scheduleEbb+0x16e>
c000fb17:	39 34 24             	cmp    %esi,(%esp)
c000fb1a:	0f 87 38 ff ff ff    	ja     c000fa58 <_ZN2Sc8scheduleEbb+0xa6>
c000fb20:	31 c0                	xor    %eax,%eax
c000fb22:	31 d2                	xor    %edx,%edx
c000fb24:	e9 3a ff ff ff       	jmp    c000fa63 <_ZN2Sc8scheduleEbb+0xb1>
                for (unsigned i = 0; i < D; i++, val /= B)
                    Console_vga::con.put (Cpu::row, col - i, c, !i || val ? (val % B)["0123456789ABCDEF"] : ' ');
c000fb29:	83 e2 0f             	and    $0xf,%edx
c000fb2c:	66 0f be 92 14 66 01 	movsbw -0x3ffe99ec(%edx),%dx
c000fb33:	c0 
c000fb34:	6b c0 50             	imul   $0x50,%eax,%eax
c000fb37:	80 ce 0b             	or     $0xb,%dh
c000fb3a:	05 00 f8 df 67       	add    $0x67dff800,%eax
c000fb3f:	0f b7 d2             	movzwl %dx,%edx
c000fb42:	66 89 14 00          	mov    %dx,(%eax,%eax,1)
c000fb46:	e9 8f fe ff ff       	jmp    c000f9da <_ZN2Sc8scheduleEbb+0x28>

c000fb4b <_GLOBAL__sub_I.00102__ZN2Sc5cacheE>:
#include "stdio.hpp"
#include "timeout_budget.hpp"
#include "vectors.hpp"

INIT_PRIORITY (PRIO_SLAB)
Slab_cache Sc::cache (sizeof (Sc), 32);
c000fb4b:	b9 20 00 00 00       	mov    $0x20,%ecx
c000fb50:	ba 80 00 00 00       	mov    $0x80,%edx
c000fb55:	b8 98 b4 01 c0       	mov    $0xc001b498,%eax
c000fb5a:	e9 a7 06 00 00       	jmp    c0010206 <_ZN10Slab_cacheC1Emj>

c000fb5f <_GLOBAL__sub_I.65534__ZN2Sc5cacheE>:
    private:
        uint16 val;

    public:
        ALWAYS_INLINE
        inline Spinlock() : val (0) {}
c000fb5f:	66 c7 05 28 fa ff cf 	movw   $0x0,0xcffffa28
c000fb66:	00 00 
c000fb68:	c3                   	ret    
c000fb69:	90                   	nop

c000fb6a <_ZN2SiC1EP2Smm>:

Si::Si (Sm * s, mword v) : sm(s), prev(nullptr), next(nullptr), value(v)
{
    trace (TRACE_SYSCALL, "SI:%p created (SM:%p signal:%#lx)", this, s, v);

    if (sm)
c000fb6a:	85 d2                	test   %edx,%edx

#include "stdio.hpp"

static Spinlock lock;

Si::Si (Sm * s, mword v) : sm(s), prev(nullptr), next(nullptr), value(v)
c000fb6c:	89 10                	mov    %edx,(%eax)
c000fb6e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
c000fb75:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
c000fb7c:	89 48 0c             	mov    %ecx,0xc(%eax)
{
    trace (TRACE_SYSCALL, "SI:%p created (SM:%p signal:%#lx)", this, s, v);

    if (sm)
c000fb7f:	75 0b                	jne    c000fb8c <_ZN2SiC1EP2Smm+0x22>
c000fb81:	c3                   	ret    

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
                if (Atomic::cmp_swap (ref, r, r + 1))
c000fb82:	8d 48 01             	lea    0x1(%eax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c000fb85:	f0 0f b1 4a 48       	lock cmpxchg %ecx,0x48(%edx)
c000fb8a:	74 07                	je     c000fb93 <_ZN2SiC1EP2Smm+0x29>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c000fb8c:	8b 42 48             	mov    0x48(%edx),%eax
c000fb8f:	85 c0                	test   %eax,%eax
c000fb91:	75 ef                	jne    c000fb82 <_ZN2SiC1EP2Smm+0x18>
c000fb93:	c3                   	ret    

c000fb94 <_ZN2SiD1Ev>:
        sm->add_ref();
}

Si::~Si()
{
    if (!sm)
c000fb94:	8b 10                	mov    (%eax),%edx
c000fb96:	85 d2                	test   %edx,%edx
c000fb98:	0f 84 97 00 00 00    	je     c000fc35 <_ZN2SiD1Ev+0xa1>

    if (sm)
        sm->add_ref();
}

Si::~Si()
c000fb9e:	56                   	push   %esi
c000fb9f:	53                   	push   %ebx
c000fba0:	8b 48 08             	mov    0x8(%eax),%ecx
{
    if (!sm)
        return;

    if (queued()) {
c000fba3:	85 c9                	test   %ecx,%ecx
c000fba5:	74 39                	je     c000fbe0 <_ZN2SiD1Ev+0x4c>
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c000fba7:	8b 58 04             	mov    0x4(%eax),%ebx
c000fbaa:	85 db                	test   %ebx,%ebx
c000fbac:	74 6a                	je     c000fc18 <_ZN2SiD1Ev+0x84>
                return false;

            if (t == t->next)
c000fbae:	39 c8                	cmp    %ecx,%eax
c000fbb0:	75 09                	jne    c000fbbb <_ZN2SiD1Ev+0x27>
                headptr = nullptr;
c000fbb2:	c7 42 50 00 00 00 00 	movl   $0x0,0x50(%edx)
c000fbb9:	eb 17                	jmp    c000fbd2 <_ZN2SiD1Ev+0x3e>

            else {
                t->next->prev = t->prev;
c000fbbb:	89 59 04             	mov    %ebx,0x4(%ecx)
                t->prev->next = t->next;
c000fbbe:	8b 48 04             	mov    0x4(%eax),%ecx
c000fbc1:	8b 58 08             	mov    0x8(%eax),%ebx
c000fbc4:	89 59 08             	mov    %ebx,0x8(%ecx)
                if (t == headptr)
c000fbc7:	3b 42 50             	cmp    0x50(%edx),%eax
c000fbca:	75 06                	jne    c000fbd2 <_ZN2SiD1Ev+0x3e>
                    headptr = t->next;
c000fbcc:	8b 48 08             	mov    0x8(%eax),%ecx
c000fbcf:	89 4a 50             	mov    %ecx,0x50(%edx)
            }

            t->next = t->prev = nullptr;
c000fbd2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
c000fbd9:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c000fbe0:	8b 10                	mov    (%eax),%edx
c000fbe2:	83 cb ff             	or     $0xffffffff,%ebx
c000fbe5:	f0 0f c1 5a 48       	lock xadd %ebx,0x48(%edx)
        bool r = sm->Queue<Si>::dequeue(this);
        assert(r);
    }

    if (sm->del_ref()) {
c000fbea:	4b                   	dec    %ebx
c000fbeb:	75 46                	jne    c000fc33 <_ZN2SiD1Ev+0x9f>
        Pd *pd = static_cast<Pd *>(static_cast<Space_obj *>(sm->space));
c000fbed:	8b 30                	mov    (%eax),%esi
c000fbef:	8b 46 28             	mov    0x28(%esi),%eax
c000fbf2:	8d 88 78 fe ff ff    	lea    -0x188(%eax),%ecx
c000fbf8:	85 c0                	test   %eax,%eax

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void destroy(Sm *obj, Quota &quota) { obj->~Sm(); cache.free (obj, quota); }
c000fbfa:	89 f0                	mov    %esi,%eax
c000fbfc:	0f 45 d9             	cmovne %ecx,%ebx
c000fbff:	e8 0a 8a ff ff       	call   c000860e <_ZN2SmD1Ev>
        Sm::destroy(sm, pd->quota);
c000fc04:	8d 8b 90 01 00 00    	lea    0x190(%ebx),%ecx
c000fc0a:	89 f2                	mov    %esi,%edx
    }
}
c000fc0c:	5b                   	pop    %ebx
c000fc0d:	b8 b4 b4 01 c0       	mov    $0xc001b4b4,%eax
c000fc12:	5e                   	pop    %esi
c000fc13:	e9 48 07 00 00       	jmp    c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
    if (!sm)
        return;

    if (queued()) {
        bool r = sm->Queue<Si>::dequeue(this);
        assert(r);
c000fc18:	68 24 91 01 c0       	push   $0xc0019124
c000fc1d:	6a 29                	push   $0x29
c000fc1f:	68 e0 8f 01 c0       	push   $0xc0018fe0
c000fc24:	68 c6 5f 01 c0       	push   $0xc0015fc6
c000fc29:	68 69 60 01 c0       	push   $0xc0016069
c000fc2e:	e8 13 1d ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

    if (sm->del_ref()) {
        Pd *pd = static_cast<Pd *>(static_cast<Space_obj *>(sm->space));
        Sm::destroy(sm, pd->quota);
    }
}
c000fc33:	5b                   	pop    %ebx
c000fc34:	5e                   	pop    %esi
c000fc35:	c3                   	ret    

c000fc36 <_ZN2Si6submitEv>:
    for (unsigned i = 0; i < c; i++)
        kern_sm->submit();
}

void Si::submit()
{
c000fc36:	55                   	push   %ebp
c000fc37:	57                   	push   %edi
c000fc38:	56                   	push   %esi
c000fc39:	89 c6                	mov    %eax,%esi
c000fc3b:	53                   	push   %ebx
    Sm * i = static_cast<Sm *>(this);
    assert(i);
c000fc3c:	83 fe 54             	cmp    $0x54,%esi
c000fc3f:	75 13                	jne    c000fc54 <_ZN2Si6submitEv+0x1e>
c000fc41:	68 8c 90 01 c0       	push   $0xc001908c
c000fc46:	6a 4d                	push   $0x4d
c000fc48:	68 e0 8f 01 c0       	push   $0xc0018fe0
c000fc4d:	68 4b 90 01 c0       	push   $0xc001904b
c000fc52:	eb 3e                	jmp    c000fc92 <_ZN2Si6submitEv+0x5c>

    if (i->space == static_cast<Space_obj *>(&Pd::kern)) {
c000fc54:	81 7e d4 48 b4 01 c0 	cmpl   $0xc001b448,-0x2c(%esi)
c000fc5b:	75 0b                	jne    c000fc68 <_ZN2Si6submitEv+0x32>
        Sm * si = ACCESS_ONCE(i->sm);
c000fc5d:	8b 06                	mov    (%esi),%eax
        if (si) {
c000fc5f:	85 c0                	test   %eax,%eax
c000fc61:	74 05                	je     c000fc68 <_ZN2Si6submitEv+0x32>
            si->submit();
c000fc63:	8d 70 54             	lea    0x54(%eax),%esi
            return;
c000fc66:	eb d4                	jmp    c000fc3c <_ZN2Si6submitEv+0x6>
        ALWAYS_INLINE
        inline void up (void (*c)() = nullptr, Sm * si = nullptr)
        {
            Ec *ec;

            {   Lock_guard <Spinlock> guard (lock);
c000fc68:	8d 6e f2             	lea    -0xe(%esi),%ebp

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c000fc6b:	9c                   	pushf  
c000fc6c:	5b                   	pop    %ebx
            return flags & 0x200;
c000fc6d:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c000fc70:	80 e3 01             	and    $0x1,%bl
c000fc73:	74 2f                	je     c000fca4 <_ZN2Si6submitEv+0x6e>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c000fc75:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000fc7c:	75 1e                	jne    c000fc9c <_ZN2Si6submitEv+0x66>
c000fc7e:	68 00 91 01 c0       	push   $0xc0019100
c000fc83:	68 b7 00 00 00       	push   $0xb7
c000fc88:	68 12 61 01 c0       	push   $0xc0016112
c000fc8d:	68 83 61 01 c0       	push   $0xc0016183
c000fc92:	68 69 60 01 c0       	push   $0xc0016069
c000fc97:	e8 aa 1c ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

            asm volatile ("cli" : : : "memory");
c000fc9c:	fa                   	cli    
            preemption = false;
c000fc9d:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c000fca4:	89 e8                	mov    %ebp,%eax
c000fca6:	e8 81 0e ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c000fcab:	8b 7e f8             	mov    -0x8(%esi),%edi
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c000fcae:	85 ff                	test   %edi,%edi
c000fcb0:	0f 84 51 01 00 00    	je     c000fe07 <_ZN2Si6submitEv+0x1d1>
c000fcb6:	8b 87 c4 00 00 00    	mov    0xc4(%edi),%eax
c000fcbc:	85 c0                	test   %eax,%eax
c000fcbe:	0f 84 43 01 00 00    	je     c000fe07 <_ZN2Si6submitEv+0x1d1>
c000fcc4:	8b 97 c0 00 00 00    	mov    0xc0(%edi),%edx
c000fcca:	85 d2                	test   %edx,%edx
c000fccc:	0f 84 35 01 00 00    	je     c000fe07 <_ZN2Si6submitEv+0x1d1>
                return false;

            if (t == t->next)
c000fcd2:	39 c7                	cmp    %eax,%edi
c000fcd4:	75 09                	jne    c000fcdf <_ZN2Si6submitEv+0xa9>
                headptr = nullptr;
c000fcd6:	c7 46 f8 00 00 00 00 	movl   $0x0,-0x8(%esi)
c000fcdd:	eb 26                	jmp    c000fd05 <_ZN2Si6submitEv+0xcf>

            else {
                t->next->prev = t->prev;
c000fcdf:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
                t->prev->next = t->next;
c000fce5:	8b 87 c0 00 00 00    	mov    0xc0(%edi),%eax
c000fceb:	8b 97 c4 00 00 00    	mov    0xc4(%edi),%edx
c000fcf1:	89 90 c4 00 00 00    	mov    %edx,0xc4(%eax)
                if (t == headptr)
c000fcf7:	3b 7e f8             	cmp    -0x8(%esi),%edi
c000fcfa:	75 09                	jne    c000fd05 <_ZN2Si6submitEv+0xcf>
                    headptr = t->next;
c000fcfc:	8b 87 c4 00 00 00    	mov    0xc4(%edi),%eax
c000fd02:	89 46 f8             	mov    %eax,-0x8(%esi)
            }

            t->next = t->prev = nullptr;
c000fd05:	c7 87 c0 00 00 00 00 	movl   $0x0,0xc0(%edi)
c000fd0c:	00 00 00 
c000fd0f:	83 c8 ff             	or     $0xffffffff,%eax
c000fd12:	c7 87 c4 00 00 00 00 	movl   $0x0,0xc4(%edi)
c000fd19:	00 00 00 
c000fd1c:	f0 0f c1 47 48       	lock xadd %eax,0x48(%edi)

                    counter++;
                    return;
                }

                if (EXPECT_FALSE(ec->del_ref())) {
c000fd21:	48                   	dec    %eax
c000fd22:	75 24                	jne    c000fd48 <_ZN2Si6submitEv+0x112>
                    delete ec;
c000fd24:	89 f8                	mov    %edi,%eax
c000fd26:	e8 e3 37 ff ff       	call   c000350e <_ZN2EcD1Ev>
c000fd2b:	8b 87 b8 00 00 00    	mov    0xb8(%edi),%eax
c000fd31:	89 fa                	mov    %edi,%edx
c000fd33:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c000fd39:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c000fd3e:	e8 1d 06 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
c000fd43:	e9 63 ff ff ff       	jmp    c000fcab <_ZN2Si6submitEv+0x75>
        }

        ALWAYS_INLINE
        inline void unlock()
        {
            asm volatile ("incb %0" : "=m" (val) : : "memory");
c000fd48:	fe 45 00             	incb   0x0(%ebp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c000fd4b:	84 db                	test   %bl,%bl
c000fd4d:	74 2a                	je     c000fd79 <_ZN2Si6submitEv+0x143>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000fd4f:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000fd56:	74 19                	je     c000fd71 <_ZN2Si6submitEv+0x13b>
c000fd58:	68 c0 90 01 c0       	push   $0xc00190c0
c000fd5d:	68 c0 00 00 00       	push   $0xc0
c000fd62:	68 12 61 01 c0       	push   $0xc0016112
c000fd67:	68 82 61 01 c0       	push   $0xc0016182
c000fd6c:	e9 21 ff ff ff       	jmp    c000fc92 <_ZN2Si6submitEv+0x5c>

            preemption = true;
c000fd71:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000fd78:	fb                   	sti    
        inline void release (void (*c)())
        {
            if (c)
                cont = c;

            Lock_guard <Spinlock> guard (lock);
c000fd79:	8d 47 46             	lea    0x46(%edi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c000fd7c:	9c                   	pushf  
c000fd7d:	5b                   	pop    %ebx
            return flags & 0x200;
c000fd7e:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c000fd81:	80 e3 01             	and    $0x1,%bl
c000fd84:	74 15                	je     c000fd9b <_ZN2Si6submitEv+0x165>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c000fd86:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000fd8d:	0f 84 eb fe ff ff    	je     c000fc7e <_ZN2Si6submitEv+0x48>

            asm volatile ("cli" : : : "memory");
c000fd93:	fa                   	cli    
            preemption = false;
c000fd94:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c000fd9b:	e8 8c 0d ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c000fda0:	8b 6f 4c             	mov    0x4c(%edi),%ebp
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c000fda3:	85 ed                	test   %ebp,%ebp
c000fda5:	74 71                	je     c000fe18 <_ZN2Si6submitEv+0x1e2>
c000fda7:	8b 45 74             	mov    0x74(%ebp),%eax
c000fdaa:	85 c0                	test   %eax,%eax
c000fdac:	74 6a                	je     c000fe18 <_ZN2Si6submitEv+0x1e2>
c000fdae:	8b 55 70             	mov    0x70(%ebp),%edx
c000fdb1:	85 d2                	test   %edx,%edx
c000fdb3:	74 63                	je     c000fe18 <_ZN2Si6submitEv+0x1e2>
                return false;

            if (t == t->next)
c000fdb5:	39 c5                	cmp    %eax,%ebp
c000fdb7:	75 09                	jne    c000fdc2 <_ZN2Si6submitEv+0x18c>
                headptr = nullptr;
c000fdb9:	c7 47 4c 00 00 00 00 	movl   $0x0,0x4c(%edi)
c000fdc0:	eb 17                	jmp    c000fdd9 <_ZN2Si6submitEv+0x1a3>

            else {
                t->next->prev = t->prev;
c000fdc2:	89 50 70             	mov    %edx,0x70(%eax)
                t->prev->next = t->next;
c000fdc5:	8b 45 70             	mov    0x70(%ebp),%eax
c000fdc8:	8b 55 74             	mov    0x74(%ebp),%edx
c000fdcb:	89 50 74             	mov    %edx,0x74(%eax)
                if (t == headptr)
c000fdce:	3b 6f 4c             	cmp    0x4c(%edi),%ebp
c000fdd1:	75 06                	jne    c000fdd9 <_ZN2Si6submitEv+0x1a3>
                    headptr = t->next;
c000fdd3:	8b 45 74             	mov    0x74(%ebp),%eax
c000fdd6:	89 47 4c             	mov    %eax,0x4c(%edi)
            }

            t->next = t->prev = nullptr;
c000fdd9:	c7 45 70 00 00 00 00 	movl   $0x0,0x70(%ebp)
c000fde0:	83 c8 ff             	or     $0xffffffff,%eax
c000fde3:	c7 45 74 00 00 00 00 	movl   $0x0,0x74(%ebp)
c000fdea:	f0 0f c1 45 48       	lock xadd %eax,0x48(%ebp)

            for (Sc *s; dequeue (s = head()); ) {
                if (EXPECT_FALSE(s->del_ref()) && (this == s->ec)) {
c000fdef:	48                   	dec    %eax
c000fdf0:	75 1d                	jne    c000fe0f <_ZN2Si6submitEv+0x1d9>
c000fdf2:	3b 7d 4c             	cmp    0x4c(%ebp),%edi
c000fdf5:	75 18                	jne    c000fe0f <_ZN2Si6submitEv+0x1d9>
                    delete s;
c000fdf7:	89 e8                	mov    %ebp,%eax
c000fdf9:	e8 7c 65 ff ff       	call   c000637a <_ZN2ScD1Ev>
c000fdfe:	89 e8                	mov    %ebp,%eax
c000fe00:	e8 40 fb ff ff       	call   c000f945 <_ZN2ScdlEPv>
c000fe05:	eb 99                	jmp    c000fda0 <_ZN2Si6submitEv+0x16a>
                    if (si) {
                       if (si->queued()) return;
                       Queue<Si>::enqueue(si);
                    }

                    counter++;
c000fe07:	ff 46 10             	incl   0x10(%esi)
c000fe0a:	fe 45 00             	incb   0x0(%ebp)
c000fe0d:	eb 0c                	jmp    c000fe1b <_ZN2Si6submitEv+0x1e5>
                    continue;
                }
                s->remote_enqueue();
c000fe0f:	89 e8                	mov    %ebp,%eax
c000fe11:	e8 26 f9 ff ff       	call   c000f73c <_ZN2Sc14remote_enqueueEv>
c000fe16:	eb 88                	jmp    c000fda0 <_ZN2Si6submitEv+0x16a>
c000fe18:	fe 47 46             	incb   0x46(%edi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c000fe1b:	84 db                	test   %bl,%bl
c000fe1d:	74 15                	je     c000fe34 <_ZN2Si6submitEv+0x1fe>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000fe1f:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000fe26:	0f 85 2c ff ff ff    	jne    c000fd58 <_ZN2Si6submitEv+0x122>

            preemption = true;
c000fe2c:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000fe33:	fb                   	sti    
        }
    }

    i->up();

    Sm * sm_chained = ACCESS_ONCE(sm);
c000fe34:	8b 2e                	mov    (%esi),%ebp
    /* if !sm than it is just a semaphore */
    if (!sm_chained) return;
c000fe36:	85 ed                	test   %ebp,%ebp
c000fe38:	0f 84 da 01 00 00    	je     c0010018 <_ZN2Si6submitEv+0x3e2>
        ALWAYS_INLINE
        inline void up (void (*c)() = nullptr, Sm * si = nullptr)
        {
            Ec *ec;

            {   Lock_guard <Spinlock> guard (lock);
c000fe3e:	8d 45 46             	lea    0x46(%ebp),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c000fe41:	9c                   	pushf  
c000fe42:	5b                   	pop    %ebx
            return flags & 0x200;
c000fe43:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c000fe46:	80 e3 01             	and    $0x1,%bl
c000fe49:	74 15                	je     c000fe60 <_ZN2Si6submitEv+0x22a>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c000fe4b:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000fe52:	0f 84 26 fe ff ff    	je     c000fc7e <_ZN2Si6submitEv+0x48>

            asm volatile ("cli" : : : "memory");
c000fe58:	fa                   	cli    
            preemption = false;
c000fe59:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c000fe60:	e8 c7 0c ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c000fe65:	8b 7d 4c             	mov    0x4c(%ebp),%edi
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c000fe68:	85 ff                	test   %edi,%edi
c000fe6a:	0f 84 76 01 00 00    	je     c000ffe6 <_ZN2Si6submitEv+0x3b0>
c000fe70:	8b 87 c4 00 00 00    	mov    0xc4(%edi),%eax
c000fe76:	85 c0                	test   %eax,%eax
c000fe78:	0f 84 68 01 00 00    	je     c000ffe6 <_ZN2Si6submitEv+0x3b0>
c000fe7e:	8b 97 c0 00 00 00    	mov    0xc0(%edi),%edx
c000fe84:	85 d2                	test   %edx,%edx
c000fe86:	0f 84 5a 01 00 00    	je     c000ffe6 <_ZN2Si6submitEv+0x3b0>
                return false;

            if (t == t->next)
c000fe8c:	39 c7                	cmp    %eax,%edi
c000fe8e:	75 09                	jne    c000fe99 <_ZN2Si6submitEv+0x263>
                headptr = nullptr;
c000fe90:	c7 45 4c 00 00 00 00 	movl   $0x0,0x4c(%ebp)
c000fe97:	eb 26                	jmp    c000febf <_ZN2Si6submitEv+0x289>

            else {
                t->next->prev = t->prev;
c000fe99:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
                t->prev->next = t->next;
c000fe9f:	8b 87 c0 00 00 00    	mov    0xc0(%edi),%eax
c000fea5:	8b 97 c4 00 00 00    	mov    0xc4(%edi),%edx
c000feab:	89 90 c4 00 00 00    	mov    %edx,0xc4(%eax)
                if (t == headptr)
c000feb1:	3b 7d 4c             	cmp    0x4c(%ebp),%edi
c000feb4:	75 09                	jne    c000febf <_ZN2Si6submitEv+0x289>
                    headptr = t->next;
c000feb6:	8b 87 c4 00 00 00    	mov    0xc4(%edi),%eax
c000febc:	89 45 4c             	mov    %eax,0x4c(%ebp)
            }

            t->next = t->prev = nullptr;
c000febf:	c7 87 c0 00 00 00 00 	movl   $0x0,0xc0(%edi)
c000fec6:	00 00 00 
c000fec9:	83 c8 ff             	or     $0xffffffff,%eax
c000fecc:	c7 87 c4 00 00 00 00 	movl   $0x0,0xc4(%edi)
c000fed3:	00 00 00 
c000fed6:	f0 0f c1 47 48       	lock xadd %eax,0x48(%edi)

                    counter++;
                    return;
                }

                if (EXPECT_FALSE(ec->del_ref())) {
c000fedb:	48                   	dec    %eax
c000fedc:	75 24                	jne    c000ff02 <_ZN2Si6submitEv+0x2cc>
                    delete ec;
c000fede:	89 f8                	mov    %edi,%eax
c000fee0:	e8 29 36 ff ff       	call   c000350e <_ZN2EcD1Ev>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c000fee5:	8b 87 b8 00 00 00    	mov    0xb8(%edi),%eax
c000feeb:	89 fa                	mov    %edi,%edx
c000feed:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c000fef3:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c000fef8:	e8 63 04 00 00       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
c000fefd:	e9 63 ff ff ff       	jmp    c000fe65 <_ZN2Si6submitEv+0x22f>

    public:

        mword reset(bool l = false) {
            if (l) lock.lock();
            mword c = counter;
c000ff02:	8b 46 10             	mov    0x10(%esi),%eax
                if (EXPECT_FALSE(ec->del_ref())) {
                    delete ec;
                    goto loop;
                }

                if (si) ec->set_si_regs(si->value, si->reset());
c000ff05:	8b 56 0c             	mov    0xc(%esi),%edx
    public:

        mword reset(bool l = false) {
            if (l) lock.lock();
            mword c = counter;
            counter = 0;
c000ff08:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)

        ALWAYS_INLINE
        inline void set_si_regs(mword sig, mword cnt)
        {
            regs.ARG_2 = sig;
            regs.ARG_3 = cnt;
c000ff0f:	89 47 58             	mov    %eax,0x58(%edi)
        }

        ALWAYS_INLINE
        inline void set_si_regs(mword sig, mword cnt)
        {
            regs.ARG_2 = sig;
c000ff12:	89 57 54             	mov    %edx,0x54(%edi)
c000ff15:	fe 45 46             	incb   0x46(%ebp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c000ff18:	84 db                	test   %bl,%bl
c000ff1a:	74 15                	je     c000ff31 <_ZN2Si6submitEv+0x2fb>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000ff1c:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000ff23:	0f 85 2f fe ff ff    	jne    c000fd58 <_ZN2Si6submitEv+0x122>

            preemption = true;
c000ff29:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000ff30:	fb                   	sti    
        inline void release (void (*c)())
        {
            if (c)
                cont = c;

            Lock_guard <Spinlock> guard (lock);
c000ff31:	8d 47 46             	lea    0x46(%edi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c000ff34:	9c                   	pushf  
c000ff35:	5b                   	pop    %ebx
            return flags & 0x200;
c000ff36:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c000ff39:	80 e3 01             	and    $0x1,%bl
c000ff3c:	74 15                	je     c000ff53 <_ZN2Si6submitEv+0x31d>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c000ff3e:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000ff45:	0f 84 33 fd ff ff    	je     c000fc7e <_ZN2Si6submitEv+0x48>

            asm volatile ("cli" : : : "memory");
c000ff4b:	fa                   	cli    
            preemption = false;
c000ff4c:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c000ff53:	e8 d4 0b ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c000ff58:	8b 77 4c             	mov    0x4c(%edi),%esi
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c000ff5b:	85 f6                	test   %esi,%esi
c000ff5d:	74 69                	je     c000ffc8 <_ZN2Si6submitEv+0x392>
c000ff5f:	8b 46 74             	mov    0x74(%esi),%eax
c000ff62:	85 c0                	test   %eax,%eax
c000ff64:	74 62                	je     c000ffc8 <_ZN2Si6submitEv+0x392>
c000ff66:	8b 56 70             	mov    0x70(%esi),%edx
c000ff69:	85 d2                	test   %edx,%edx
c000ff6b:	74 5b                	je     c000ffc8 <_ZN2Si6submitEv+0x392>
                return false;

            if (t == t->next)
c000ff6d:	39 c6                	cmp    %eax,%esi
c000ff6f:	75 09                	jne    c000ff7a <_ZN2Si6submitEv+0x344>
                headptr = nullptr;
c000ff71:	c7 47 4c 00 00 00 00 	movl   $0x0,0x4c(%edi)
c000ff78:	eb 17                	jmp    c000ff91 <_ZN2Si6submitEv+0x35b>

            else {
                t->next->prev = t->prev;
c000ff7a:	89 50 70             	mov    %edx,0x70(%eax)
                t->prev->next = t->next;
c000ff7d:	8b 46 70             	mov    0x70(%esi),%eax
c000ff80:	8b 56 74             	mov    0x74(%esi),%edx
c000ff83:	89 50 74             	mov    %edx,0x74(%eax)
                if (t == headptr)
c000ff86:	3b 77 4c             	cmp    0x4c(%edi),%esi
c000ff89:	75 06                	jne    c000ff91 <_ZN2Si6submitEv+0x35b>
                    headptr = t->next;
c000ff8b:	8b 46 74             	mov    0x74(%esi),%eax
c000ff8e:	89 47 4c             	mov    %eax,0x4c(%edi)
            }

            t->next = t->prev = nullptr;
c000ff91:	c7 46 70 00 00 00 00 	movl   $0x0,0x70(%esi)
c000ff98:	83 c8 ff             	or     $0xffffffff,%eax
c000ff9b:	c7 46 74 00 00 00 00 	movl   $0x0,0x74(%esi)
c000ffa2:	f0 0f c1 46 48       	lock xadd %eax,0x48(%esi)

            for (Sc *s; dequeue (s = head()); ) {
                if (EXPECT_FALSE(s->del_ref()) && (this == s->ec)) {
c000ffa7:	48                   	dec    %eax
c000ffa8:	75 15                	jne    c000ffbf <_ZN2Si6submitEv+0x389>
c000ffaa:	3b 7e 4c             	cmp    0x4c(%esi),%edi
c000ffad:	75 10                	jne    c000ffbf <_ZN2Si6submitEv+0x389>
                    delete s;
c000ffaf:	89 f0                	mov    %esi,%eax
c000ffb1:	e8 c4 63 ff ff       	call   c000637a <_ZN2ScD1Ev>
c000ffb6:	89 f0                	mov    %esi,%eax
c000ffb8:	e8 88 f9 ff ff       	call   c000f945 <_ZN2ScdlEPv>
c000ffbd:	eb 99                	jmp    c000ff58 <_ZN2Si6submitEv+0x322>
                    continue;
                }
                s->remote_enqueue();
c000ffbf:	89 f0                	mov    %esi,%eax
c000ffc1:	e8 76 f7 ff ff       	call   c000f73c <_ZN2Sc14remote_enqueueEv>
c000ffc6:	eb 90                	jmp    c000ff58 <_ZN2Si6submitEv+0x322>
c000ffc8:	fe 47 46             	incb   0x46(%edi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c000ffcb:	84 db                	test   %bl,%bl
c000ffcd:	74 49                	je     c0010018 <_ZN2Si6submitEv+0x3e2>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c000ffcf:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c000ffd6:	0f 85 7c fd ff ff    	jne    c000fd58 <_ZN2Si6submitEv+0x122>

            preemption = true;
c000ffdc:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c000ffe3:	fb                   	sti    
c000ffe4:	eb 32                	jmp    c0010018 <_ZN2Si6submitEv+0x3e2>
                loop:

                if (!Queue<Ec>::dequeue (ec = Queue<Ec>::head())) {

                    if (si) {
                       if (si->queued()) return;
c000ffe6:	83 7e 08 00          	cmpl   $0x0,0x8(%esi)
c000ffea:	75 27                	jne    c0010013 <_ZN2Si6submitEv+0x3dd>
        inline T *head() const { return headptr; }

        ALWAYS_INLINE
        inline void enqueue (T *t)
        {
            if (!headptr)
c000ffec:	8b 45 50             	mov    0x50(%ebp),%eax
c000ffef:	85 c0                	test   %eax,%eax
c000fff1:	75 0b                	jne    c000fffe <_ZN2Si6submitEv+0x3c8>
                headptr = t->prev = t->next = t;
c000fff3:	89 76 08             	mov    %esi,0x8(%esi)
c000fff6:	89 76 04             	mov    %esi,0x4(%esi)
c000fff9:	89 75 50             	mov    %esi,0x50(%ebp)
c000fffc:	eb 12                	jmp    c0010010 <_ZN2Si6submitEv+0x3da>
            else {
                t->next = headptr;
c000fffe:	89 46 08             	mov    %eax,0x8(%esi)
                t->prev = headptr->prev;
c0010001:	8b 55 50             	mov    0x50(%ebp),%edx
c0010004:	8b 52 04             	mov    0x4(%edx),%edx
c0010007:	89 56 04             	mov    %edx,0x4(%esi)
                t->next->prev = t->prev->next = t;
c001000a:	89 72 08             	mov    %esi,0x8(%edx)
c001000d:	89 70 04             	mov    %esi,0x4(%eax)
                       Queue<Si>::enqueue(si);
                    }

                    counter++;
c0010010:	ff 45 64             	incl   0x64(%ebp)
c0010013:	fe 45 46             	incb   0x46(%ebp)
c0010016:	eb b3                	jmp    c000ffcb <_ZN2Si6submitEv+0x395>

    /* signal mode - send up() to chained sm */
    sm_chained->up(nullptr, i);
}
c0010018:	5b                   	pop    %ebx
c0010019:	5e                   	pop    %esi
c001001a:	5f                   	pop    %edi
c001001b:	5d                   	pop    %ebp
c001001c:	c3                   	ret    
c001001d:	90                   	nop

c001001e <_ZN2Si5chainEP2Sm>:
        Sm::destroy(sm, pd->quota);
    }
}

void Si::chain(Sm *si)
{
c001001e:	55                   	push   %ebp
c001001f:	57                   	push   %edi
c0010020:	56                   	push   %esi
c0010021:	89 c6                	mov    %eax,%esi
c0010023:	53                   	push   %ebx
c0010024:	83 ec 08             	sub    $0x8,%esp
    Sm * kern_sm = static_cast<Sm *>(this);
    assert (kern_sm);
c0010027:	83 f8 54             	cmp    $0x54,%eax
c001002a:	75 13                	jne    c001003f <_ZN2Si5chainEP2Sm+0x21>
c001002c:	68 a0 90 01 c0       	push   $0xc00190a0
c0010031:	6a 35                	push   $0x35
c0010033:	68 e0 8f 01 c0       	push   $0xc0018fe0
c0010038:	68 4d 90 01 c0       	push   $0xc001904d
c001003d:	eb 1a                	jmp    c0010059 <_ZN2Si5chainEP2Sm+0x3b>
    assert (kern_sm->space == static_cast<Space_obj *>(&Pd::kern));
c001003f:	81 78 d4 48 b4 01 c0 	cmpl   $0xc001b448,-0x2c(%eax)
c0010046:	74 1b                	je     c0010063 <_ZN2Si5chainEP2Sm+0x45>
c0010048:	68 a0 90 01 c0       	push   $0xc00190a0
c001004d:	6a 36                	push   $0x36
c001004f:	68 e0 8f 01 c0       	push   $0xc0018fe0
c0010054:	68 55 90 01 c0       	push   $0xc0019055
c0010059:	68 69 60 01 c0       	push   $0xc0016069
c001005e:	e8 e3 18 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>
c0010063:	89 d7                	mov    %edx,%edi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c0010065:	9c                   	pushf  
c0010066:	5b                   	pop    %ebx
            return flags & 0x200;
c0010067:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c001006a:	88 d8                	mov    %bl,%al
c001006c:	24 01                	and    $0x1,%al
c001006e:	88 44 24 03          	mov    %al,0x3(%esp)
c0010072:	74 27                	je     c001009b <_ZN2Si5chainEP2Sm+0x7d>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0010074:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c001007b:	75 16                	jne    c0010093 <_ZN2Si5chainEP2Sm+0x75>
c001007d:	68 00 91 01 c0       	push   $0xc0019100
c0010082:	68 b7 00 00 00       	push   $0xb7
c0010087:	68 12 61 01 c0       	push   $0xc0016112
c001008c:	68 83 61 01 c0       	push   $0xc0016183
c0010091:	eb c6                	jmp    c0010059 <_ZN2Si5chainEP2Sm+0x3b>

            asm volatile ("cli" : : : "memory");
c0010093:	fa                   	cli    
            preemption = false;
c0010094:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c001009b:	b8 b0 b4 01 c0       	mov    $0xc001b4b0,%eax
c00100a0:	e8 87 0a ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>

    Lock_guard <Spinlock> guard (lock);

    if (sm && sm->del_ref()) {
c00100a5:	8b 06                	mov    (%esi),%eax
c00100a7:	85 c0                	test   %eax,%eax
c00100a9:	74 27                	je     c00100d2 <_ZN2Si5chainEP2Sm+0xb4>
c00100ab:	83 ca ff             	or     $0xffffffff,%edx
c00100ae:	f0 0f c1 50 48       	lock xadd %edx,0x48(%eax)
c00100b3:	4a                   	dec    %edx
c00100b4:	75 1c                	jne    c00100d2 <_ZN2Si5chainEP2Sm+0xb4>
        sm->add_ref();
c00100b6:	8b 16                	mov    (%esi),%edx
c00100b8:	8b 42 48             	mov    0x48(%edx),%eax
c00100bb:	85 c0                	test   %eax,%eax
c00100bd:	74 0a                	je     c00100c9 <_ZN2Si5chainEP2Sm+0xab>
                if (Atomic::cmp_swap (ref, r, r + 1))
c00100bf:	8d 48 01             	lea    0x1(%eax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c00100c2:	f0 0f b1 4a 48       	lock cmpxchg %ecx,0x48(%edx)
c00100c7:	75 ef                	jne    c00100b8 <_ZN2Si5chainEP2Sm+0x9a>
        sm->call_rcu();
c00100c9:	8b 2e                	mov    (%esi),%ebp
        }

        ALWAYS_INLINE
        inline void call_rcu(bool r = false)
        {
            if (ACCESS_ONCE(rcu))
c00100cb:	8a 45 68             	mov    0x68(%ebp),%al
c00100ce:	84 c0                	test   %al,%al
c00100d0:	74 7b                	je     c001014d <_ZN2Si5chainEP2Sm+0x12f>
    }

    sm = si;
c00100d2:	89 3e                	mov    %edi,(%esi)

    if (sm)
c00100d4:	85 ff                	test   %edi,%edi
c00100d6:	75 19                	jne    c00100f1 <_ZN2Si5chainEP2Sm+0xd3>
        }

    public:

        mword reset(bool l = false) {
            if (l) lock.lock();
c00100d8:	8d 46 f2             	lea    -0xe(%esi),%eax
c00100db:	e8 4c 0a ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
            mword c = counter;
c00100e0:	8b 6e 10             	mov    0x10(%esi),%ebp
            counter = 0;
c00100e3:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
c00100ea:	fe 46 f2             	incb   -0xe(%esi)
        sm->add_ref();

    mword c = kern_sm->reset(true);

    for (unsigned i = 0; i < c; i++)
c00100ed:	31 ff                	xor    %edi,%edi
c00100ef:	eb 11                	jmp    c0010102 <_ZN2Si5chainEP2Sm+0xe4>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c00100f1:	8b 47 48             	mov    0x48(%edi),%eax
c00100f4:	85 c0                	test   %eax,%eax
c00100f6:	74 e0                	je     c00100d8 <_ZN2Si5chainEP2Sm+0xba>
                if (Atomic::cmp_swap (ref, r, r + 1))
c00100f8:	8d 50 01             	lea    0x1(%eax),%edx
c00100fb:	f0 0f b1 57 48       	lock cmpxchg %edx,0x48(%edi)
c0010100:	eb d4                	jmp    c00100d6 <_ZN2Si5chainEP2Sm+0xb8>
c0010102:	39 ef                	cmp    %ebp,%edi
c0010104:	74 0a                	je     c0010110 <_ZN2Si5chainEP2Sm+0xf2>
        kern_sm->submit();
c0010106:	89 f0                	mov    %esi,%eax
    if (sm)
        sm->add_ref();

    mword c = kern_sm->reset(true);

    for (unsigned i = 0; i < c; i++)
c0010108:	47                   	inc    %edi
        kern_sm->submit();
c0010109:	e8 28 fb ff ff       	call   c000fc36 <_ZN2Si6submitEv>
c001010e:	eb f2                	jmp    c0010102 <_ZN2Si5chainEP2Sm+0xe4>
c0010110:	fe 05 b0 b4 01 c0    	incb   0xc001b4b0
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c0010116:	80 7c 24 03 00       	cmpb   $0x0,0x3(%esp)
c001011b:	0f 84 8c 00 00 00    	je     c00101ad <_ZN2Si5chainEP2Sm+0x18f>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0010121:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0010128:	74 19                	je     c0010143 <_ZN2Si5chainEP2Sm+0x125>
c001012a:	68 c0 90 01 c0       	push   $0xc00190c0
c001012f:	68 c0 00 00 00       	push   $0xc0
c0010134:	68 12 61 01 c0       	push   $0xc0016112
c0010139:	68 82 61 01 c0       	push   $0xc0016182
c001013e:	e9 16 ff ff ff       	jmp    c0010059 <_ZN2Si5chainEP2Sm+0x3b>

            preemption = true;
c0010143:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c001014a:	fb                   	sti    
c001014b:	eb 60                	jmp    c00101ad <_ZN2Si5chainEP2Sm+0x18f>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
c001014d:	8b 4d 14             	mov    0x14(%ebp),%ecx
            rcu = true;

            if (r)
                add_ref();

            Rcu::call (this);
c0010150:	8d 5d 0c             	lea    0xc(%ebp),%ebx
        inline void call_rcu(bool r = false)
        {
            if (ACCESS_ONCE(rcu))
                return;

            rcu = true;
c0010153:	c6 45 68 01          	movb   $0x1,0x68(%ebp)
c0010157:	85 c9                	test   %ecx,%ecx
c0010159:	74 04                	je     c001015f <_ZN2Si5chainEP2Sm+0x141>
                e->pre_func(e);
c001015b:	89 d8                	mov    %ebx,%eax
c001015d:	ff d1                	call   *%ecx
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
c001015f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0010163:	75 09                	jne    c001016e <_ZN2Si5chainEP2Sm+0x150>
c0010165:	a1 f0 f7 ff cf       	mov    0xcffff7f0,%eax
c001016a:	39 d8                	cmp    %ebx,%eax
c001016c:	75 2c                	jne    c001019a <_ZN2Si5chainEP2Sm+0x17c>
                trace (0, "warning: rcu element already enqueued");
c001016e:	8d 44 24 03          	lea    0x3(%esp),%eax
c0010172:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0010177:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c001017c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0010181:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0010188:	50                   	push   %eax
c0010189:	68 ae 6c 01 c0       	push   $0xc0016cae
c001018e:	e8 4b 18 ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c0010193:	59                   	pop    %ecx
c0010194:	5b                   	pop    %ebx
c0010195:	e9 38 ff ff ff       	jmp    c00100d2 <_ZN2Si5chainEP2Sm+0xb4>
                return;
            }

            count ++;
c001019a:	ff 05 f4 f7 ff cf    	incl   0xcffff7f4

           *tail = e;
c00101a0:	89 18                	mov    %ebx,(%eax)
            tail = &e->next;
c00101a2:	89 1d f0 f7 ff cf    	mov    %ebx,0xcffff7f0
c00101a8:	e9 25 ff ff ff       	jmp    c00100d2 <_ZN2Si5chainEP2Sm+0xb4>
}
c00101ad:	83 c4 08             	add    $0x8,%esp
c00101b0:	5b                   	pop    %ebx
c00101b1:	5e                   	pop    %esi
c00101b2:	5f                   	pop    %edi
c00101b3:	5d                   	pop    %ebp
c00101b4:	c3                   	ret    

c00101b5 <_GLOBAL__sub_I__ZN2SiC2EP2Smm>:
    private:
        uint16 val;

    public:
        ALWAYS_INLINE
        inline Spinlock() : val (0) {}
c00101b5:	66 c7 05 b0 b4 01 c0 	movw   $0x0,0xc001b4b0
c00101bc:	00 00 
c00101be:	c3                   	ret    
c00101bf:	90                   	nop

c00101c0 <_ZN4SlabC1EP10Slab_cache>:
#include "bits.hpp"
#include "lock_guard.hpp"
#include "slab.hpp"
#include "stdio.hpp"

Slab::Slab (Slab_cache *slab_cache)
c00101c0:	53                   	push   %ebx
    : avail (slab_cache->elem),
      cache (slab_cache),
      prev  (nullptr),
      next  (nullptr),
      head  (nullptr)
c00101c1:	8b 5a 14             	mov    0x14(%edx),%ebx
c00101c4:	89 50 04             	mov    %edx,0x4(%eax)
c00101c7:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
c00101ce:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
c00101d5:	89 18                	mov    %ebx,(%eax)
c00101d7:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
c00101de:	8b 4a 0c             	mov    0xc(%edx),%ecx
c00101e1:	81 c1 00 10 00 00    	add    $0x1000,%ecx
{
    char *link = reinterpret_cast<char *>(this) + PAGE_SIZE - cache->buff + cache->size;
c00101e7:	2b 4a 10             	sub    0x10(%edx),%ecx
c00101ea:	89 ca                	mov    %ecx,%edx
c00101ec:	01 c2                	add    %eax,%edx

    for (unsigned long i = avail; i; i--, link -= cache->buff) {
c00101ee:	85 db                	test   %ebx,%ebx
c00101f0:	74 11                	je     c0010203 <_ZN4SlabC1EP10Slab_cache+0x43>
        *reinterpret_cast<char **>(link) = head;
c00101f2:	8b 48 10             	mov    0x10(%eax),%ecx
      next  (nullptr),
      head  (nullptr)
{
    char *link = reinterpret_cast<char *>(this) + PAGE_SIZE - cache->buff + cache->size;

    for (unsigned long i = avail; i; i--, link -= cache->buff) {
c00101f5:	4b                   	dec    %ebx
        *reinterpret_cast<char **>(link) = head;
c00101f6:	89 0a                	mov    %ecx,(%edx)
      next  (nullptr),
      head  (nullptr)
{
    char *link = reinterpret_cast<char *>(this) + PAGE_SIZE - cache->buff + cache->size;

    for (unsigned long i = avail; i; i--, link -= cache->buff) {
c00101f8:	8b 48 04             	mov    0x4(%eax),%ecx
        *reinterpret_cast<char **>(link) = head;
        head = link;
c00101fb:	89 50 10             	mov    %edx,0x10(%eax)
      next  (nullptr),
      head  (nullptr)
{
    char *link = reinterpret_cast<char *>(this) + PAGE_SIZE - cache->buff + cache->size;

    for (unsigned long i = avail; i; i--, link -= cache->buff) {
c00101fe:	2b 51 10             	sub    0x10(%ecx),%edx
c0010201:	eb eb                	jmp    c00101ee <_ZN4SlabC1EP10Slab_cache+0x2e>
        *reinterpret_cast<char **>(link) = head;
        head = link;
    }
}
c0010203:	5b                   	pop    %ebx
c0010204:	c3                   	ret    
c0010205:	90                   	nop

c0010206 <_ZN10Slab_cacheC1Emj>:
}

ALWAYS_INLINE
static inline mword align_up (mword val, mword align)
{
    val += (align - 1);                 // Expect power-of-2
c0010206:	83 c2 03             	add    $0x3,%edx
}

ALWAYS_INLINE
static inline mword align_dn (mword val, mword align)
{
    val &= ~(align - 1);                // Expect power-of-2
c0010209:	83 e2 fc             	and    $0xfffffffc,%edx
    char *link = reinterpret_cast<char *>(ptr) + cache->size;
    *reinterpret_cast<char **>(link) = head;
    head = link;
}

Slab_cache::Slab_cache (unsigned long elem_size, unsigned elem_align)
c001020c:	53                   	push   %ebx
c001020d:	89 c3                	mov    %eax,%ebx
          : curr (nullptr),
            head (nullptr),
            size (align_up (elem_size, sizeof (mword))),
            buff (align_up (size + sizeof (mword), elem_align)),
            elem ((PAGE_SIZE - sizeof (Slab)) / buff)
c001020f:	89 50 0c             	mov    %edx,0xc(%eax)
c0010212:	66 c7 00 00 00       	movw   $0x0,(%eax)
c0010217:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
c001021e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
}

ALWAYS_INLINE
static inline mword align_up (mword val, mword align)
{
    val += (align - 1);                 // Expect power-of-2
c0010225:	8d 44 0a 03          	lea    0x3(%edx,%ecx,1),%eax
}

ALWAYS_INLINE
static inline mword align_dn (mword val, mword align)
{
    val &= ~(align - 1);                // Expect power-of-2
c0010229:	f7 d9                	neg    %ecx
c001022b:	21 c1                	and    %eax,%ecx
c001022d:	31 d2                	xor    %edx,%edx
c001022f:	b8 ec 0f 00 00       	mov    $0xfec,%eax
c0010234:	f7 f1                	div    %ecx
c0010236:	89 4b 10             	mov    %ecx,0x10(%ebx)
c0010239:	89 43 14             	mov    %eax,0x14(%ebx)
{
    trace (TRACE_MEMORY, "Slab Cache:%p (S:%lu A:%u)",
           this,
           elem_size,
           elem_align);
}
c001023c:	5b                   	pop    %ebx
c001023d:	c3                   	ret    

c001023e <_ZN10Slab_cache4growER5Quota>:

void Slab_cache::grow(Quota &quota)
{
c001023e:	56                   	push   %esi
        char *          head;

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota)
        {
            return Buddy::allocator.alloc (0, quota, Buddy::FILL_0);
c001023f:	89 d1                	mov    %edx,%ecx
c0010241:	53                   	push   %ebx
c0010242:	31 d2                	xor    %edx,%edx
c0010244:	89 c3                	mov    %eax,%ebx
c0010246:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c001024b:	6a 01                	push   $0x1
c001024d:	e8 ba 11 ff ff       	call   c000140c <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
    Slab *slab = new (quota) Slab (this);
c0010252:	89 da                	mov    %ebx,%edx
c0010254:	89 c6                	mov    %eax,%esi
c0010256:	e8 65 ff ff ff       	call   c00101c0 <_ZN4SlabC1EP10Slab_cache>

    if (head)
c001025b:	8b 43 08             	mov    0x8(%ebx),%eax
c001025e:	5a                   	pop    %edx
c001025f:	85 c0                	test   %eax,%eax
c0010261:	74 03                	je     c0010266 <_ZN10Slab_cache4growER5Quota+0x28>
        head->prev = slab;
c0010263:	89 70 08             	mov    %esi,0x8(%eax)

    slab->next = head;
c0010266:	8b 43 08             	mov    0x8(%ebx),%eax
c0010269:	89 46 0c             	mov    %eax,0xc(%esi)
    head = curr = slab;
c001026c:	89 73 04             	mov    %esi,0x4(%ebx)
c001026f:	89 73 08             	mov    %esi,0x8(%ebx)
}
c0010272:	5b                   	pop    %ebx
c0010273:	5e                   	pop    %esi
c0010274:	c3                   	ret    
c0010275:	90                   	nop

c0010276 <_ZN10Slab_cache5allocER5Quota>:

void *Slab_cache::alloc(Quota &quota)
{
c0010276:	57                   	push   %edi
c0010277:	56                   	push   %esi
c0010278:	89 c6                	mov    %eax,%esi
c001027a:	53                   	push   %ebx
c001027b:	51                   	push   %ecx

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c001027c:	9c                   	pushf  
c001027d:	5b                   	pop    %ebx
            return flags & 0x200;
c001027e:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c0010281:	80 e3 01             	and    $0x1,%bl
c0010284:	74 27                	je     c00102ad <_ZN10Slab_cache5allocER5Quota+0x37>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0010286:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c001028d:	75 16                	jne    c00102a5 <_ZN10Slab_cache5allocER5Quota+0x2f>
c001028f:	68 60 92 01 c0       	push   $0xc0019260
c0010294:	68 b7 00 00 00       	push   $0xb7
c0010299:	68 12 61 01 c0       	push   $0xc0016112
c001029e:	68 83 61 01 c0       	push   $0xc0016183
c00102a3:	eb 3c                	jmp    c00102e1 <_ZN10Slab_cache5allocER5Quota+0x6b>

            asm volatile ("cli" : : : "memory");
c00102a5:	fa                   	cli    
            preemption = false;
c00102a6:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c00102ad:	89 f0                	mov    %esi,%eax
c00102af:	89 14 24             	mov    %edx,(%esp)
c00102b2:	e8 75 08 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    Lock_guard <Spinlock> guard (lock);

    if (EXPECT_FALSE (!curr))
c00102b7:	8b 14 24             	mov    (%esp),%edx
c00102ba:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
c00102be:	75 07                	jne    c00102c7 <_ZN10Slab_cache5allocER5Quota+0x51>
        grow(quota);
c00102c0:	89 f0                	mov    %esi,%eax
c00102c2:	e8 77 ff ff ff       	call   c001023e <_ZN10Slab_cache4growER5Quota>

    assert (!curr->full());
c00102c7:	8b 56 04             	mov    0x4(%esi),%edx
c00102ca:	8b 02                	mov    (%edx),%eax
c00102cc:	85 c0                	test   %eax,%eax
c00102ce:	75 1b                	jne    c00102eb <_ZN10Slab_cache5allocER5Quota+0x75>
c00102d0:	68 a0 92 01 c0       	push   $0xc00192a0
c00102d5:	6a 5b                	push   $0x5b
c00102d7:	68 2e 91 01 c0       	push   $0xc001912e
c00102dc:	68 9b 91 01 c0       	push   $0xc001919b
c00102e1:	68 69 60 01 c0       	push   $0xc0016069
c00102e6:	e8 5b 16 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>
    assert (!curr->next || curr->next->full());
c00102eb:	8b 4a 0c             	mov    0xc(%edx),%ecx
c00102ee:	85 c9                	test   %ecx,%ecx
c00102f0:	74 18                	je     c001030a <_ZN10Slab_cache5allocER5Quota+0x94>
c00102f2:	83 39 00             	cmpl   $0x0,(%ecx)
c00102f5:	74 13                	je     c001030a <_ZN10Slab_cache5allocER5Quota+0x94>
c00102f7:	68 a0 92 01 c0       	push   $0xc00192a0
c00102fc:	6a 5c                	push   $0x5c
c00102fe:	68 2e 91 01 c0       	push   $0xc001912e
c0010303:	68 a9 91 01 c0       	push   $0xc00191a9
c0010308:	eb d7                	jmp    c00102e1 <_ZN10Slab_cache5allocER5Quota+0x6b>

void *Slab::alloc()
{
    avail--;

    void *link = reinterpret_cast<void *>(head - cache->size);
c001030a:	8b 4a 10             	mov    0x10(%edx),%ecx
    }
}

void *Slab::alloc()
{
    avail--;
c001030d:	48                   	dec    %eax
c001030e:	89 02                	mov    %eax,(%edx)

    void *link = reinterpret_cast<void *>(head - cache->size);
c0010310:	8b 42 04             	mov    0x4(%edx),%eax
c0010313:	89 cf                	mov    %ecx,%edi
    head = *reinterpret_cast<char **>(head);
c0010315:	8b 09                	mov    (%ecx),%ecx

void *Slab::alloc()
{
    avail--;

    void *link = reinterpret_cast<void *>(head - cache->size);
c0010317:	2b 78 0c             	sub    0xc(%eax),%edi
    head = *reinterpret_cast<char **>(head);
c001031a:	89 4a 10             	mov    %ecx,0x10(%edx)

void *Slab::alloc()
{
    avail--;

    void *link = reinterpret_cast<void *>(head - cache->size);
c001031d:	89 f8                	mov    %edi,%eax
    assert (!curr->next || curr->next->full());

    // Allocate from slab
    void *ret = curr->alloc();

    if (EXPECT_FALSE (curr->full()))
c001031f:	8b 56 04             	mov    0x4(%esi),%edx
c0010322:	83 3a 00             	cmpl   $0x0,(%edx)
c0010325:	75 06                	jne    c001032d <_ZN10Slab_cache5allocER5Quota+0xb7>
        curr = curr->prev;
c0010327:	8b 52 08             	mov    0x8(%edx),%edx
c001032a:	89 56 04             	mov    %edx,0x4(%esi)
        }

        ALWAYS_INLINE
        inline void unlock()
        {
            asm volatile ("incb %0" : "=m" (val) : : "memory");
c001032d:	fe 06                	incb   (%esi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c001032f:	84 db                	test   %bl,%bl
c0010331:	74 27                	je     c001035a <_ZN10Slab_cache5allocER5Quota+0xe4>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0010333:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c001033a:	74 16                	je     c0010352 <_ZN10Slab_cache5allocER5Quota+0xdc>
c001033c:	68 20 92 01 c0       	push   $0xc0019220
c0010341:	68 c0 00 00 00       	push   $0xc0
c0010346:	68 12 61 01 c0       	push   $0xc0016112
c001034b:	68 82 61 01 c0       	push   $0xc0016182
c0010350:	eb 8f                	jmp    c00102e1 <_ZN10Slab_cache5allocER5Quota+0x6b>

            preemption = true;
c0010352:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c0010359:	fb                   	sti    

    return ret;
}
c001035a:	5a                   	pop    %edx
c001035b:	5b                   	pop    %ebx
c001035c:	5e                   	pop    %esi
c001035d:	5f                   	pop    %edi
c001035e:	c3                   	ret    
c001035f:	90                   	nop

c0010360 <_ZN10Slab_cache4freeEPvR5Quota>:

void Slab_cache::free (void *ptr, Quota &quota)
{
c0010360:	55                   	push   %ebp
c0010361:	89 d5                	mov    %edx,%ebp
c0010363:	57                   	push   %edi
c0010364:	89 c7                	mov    %eax,%edi
c0010366:	56                   	push   %esi
c0010367:	53                   	push   %ebx
c0010368:	53                   	push   %ebx

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c0010369:	9c                   	pushf  
c001036a:	5b                   	pop    %ebx
            return flags & 0x200;
c001036b:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c001036e:	80 e3 01             	and    $0x1,%bl
c0010371:	74 2a                	je     c001039d <_ZN10Slab_cache4freeEPvR5Quota+0x3d>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0010373:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c001037a:	75 19                	jne    c0010395 <_ZN10Slab_cache4freeEPvR5Quota+0x35>
c001037c:	68 60 92 01 c0       	push   $0xc0019260
c0010381:	68 b7 00 00 00       	push   $0xb7
c0010386:	68 12 61 01 c0       	push   $0xc0016112
c001038b:	68 83 61 01 c0       	push   $0xc0016183
c0010390:	e9 eb 00 00 00       	jmp    c0010480 <_ZN10Slab_cache4freeEPvR5Quota+0x120>

            asm volatile ("cli" : : : "memory");
c0010395:	fa                   	cli    
            preemption = false;
c0010396:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
    Lock_guard <Spinlock> guard (lock);

    Slab *slab = reinterpret_cast<Slab *>(reinterpret_cast<mword>(ptr) & ~PAGE_MASK);
c001039d:	89 ee                	mov    %ebp,%esi
                Cpu::preempt_disable();

            _lock.lock();
c001039f:	89 f8                	mov    %edi,%eax
c00103a1:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
c00103a7:	89 0c 24             	mov    %ecx,(%esp)
c00103aa:	e8 7d 07 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
c00103af:	8b 06                	mov    (%esi),%eax

    bool was_full = slab->full();

    slab->free (ptr);       // Deallocate from slab

    if (EXPECT_FALSE (was_full)) {
c00103b1:	8b 0c 24             	mov    (%esp),%ecx
    return link;
}

void Slab::free (void *ptr)
{
    avail++;
c00103b4:	8d 50 01             	lea    0x1(%eax),%edx
c00103b7:	89 16                	mov    %edx,(%esi)

    char *link = reinterpret_cast<char *>(ptr) + cache->size;
c00103b9:	8b 56 04             	mov    0x4(%esi),%edx
c00103bc:	03 6a 0c             	add    0xc(%edx),%ebp

    bool was_full = slab->full();

    slab->free (ptr);       // Deallocate from slab

    if (EXPECT_FALSE (was_full)) {
c00103bf:	85 c0                	test   %eax,%eax
void Slab::free (void *ptr)
{
    avail++;

    char *link = reinterpret_cast<char *>(ptr) + cache->size;
    *reinterpret_cast<char **>(link) = head;
c00103c1:	8b 56 10             	mov    0x10(%esi),%edx
c00103c4:	89 55 00             	mov    %edx,0x0(%ebp)
    head = link;
c00103c7:	89 6e 10             	mov    %ebp,0x10(%esi)

    bool was_full = slab->full();

    slab->free (ptr);       // Deallocate from slab

    if (EXPECT_FALSE (was_full)) {
c00103ca:	75 4a                	jne    c0010416 <_ZN10Slab_cache4freeEPvR5Quota+0xb6>

        // There are full slabs in front of us and we're partial; requeue
        if (slab->prev && slab->prev->full()) {
c00103cc:	8b 46 08             	mov    0x8(%esi),%eax
c00103cf:	85 c0                	test   %eax,%eax
c00103d1:	74 3b                	je     c001040e <_ZN10Slab_cache4freeEPvR5Quota+0xae>
c00103d3:	83 38 00             	cmpl   $0x0,(%eax)
c00103d6:	75 36                	jne    c001040e <_ZN10Slab_cache4freeEPvR5Quota+0xae>

            // Dequeue
            slab->prev->next = slab->next;
c00103d8:	8b 56 0c             	mov    0xc(%esi),%edx
c00103db:	89 50 0c             	mov    %edx,0xc(%eax)
            if (slab->next)
c00103de:	8b 46 0c             	mov    0xc(%esi),%eax
c00103e1:	85 c0                	test   %eax,%eax
c00103e3:	74 06                	je     c00103eb <_ZN10Slab_cache4freeEPvR5Quota+0x8b>
                slab->next->prev = slab->prev;
c00103e5:	8b 56 08             	mov    0x8(%esi),%edx
c00103e8:	89 50 08             	mov    %edx,0x8(%eax)

            // Enqueue after curr
            if (curr) {
c00103eb:	8b 47 04             	mov    0x4(%edi),%eax
c00103ee:	85 c0                	test   %eax,%eax
c00103f0:	0f 84 cf 00 00 00    	je     c00104c5 <_ZN10Slab_cache4freeEPvR5Quota+0x165>
                slab->prev = curr;
c00103f6:	89 46 08             	mov    %eax,0x8(%esi)
                slab->next = curr->next;
c00103f9:	8b 47 04             	mov    0x4(%edi),%eax
c00103fc:	8b 40 0c             	mov    0xc(%eax),%eax
c00103ff:	89 46 0c             	mov    %eax,0xc(%esi)
                curr->next = curr->next->prev = slab;
c0010402:	8b 47 04             	mov    0x4(%edi),%eax
c0010405:	8b 50 0c             	mov    0xc(%eax),%edx
c0010408:	89 72 08             	mov    %esi,0x8(%edx)
c001040b:	89 70 0c             	mov    %esi,0xc(%eax)
                slab->next = head;
                head = head->prev = slab;
            }
        }

        curr = slab;
c001040e:	89 77 04             	mov    %esi,0x4(%edi)
c0010411:	e9 80 00 00 00       	jmp    c0010496 <_ZN10Slab_cache4freeEPvR5Quota+0x136>
        }

        ALWAYS_INLINE
        inline bool empty() const
        {
            return avail == cache->elem;
c0010416:	8b 46 04             	mov    0x4(%esi),%eax

    } else if (EXPECT_FALSE (slab->empty())) {
c0010419:	8b 40 14             	mov    0x14(%eax),%eax
c001041c:	39 06                	cmp    %eax,(%esi)
c001041e:	75 76                	jne    c0010496 <_ZN10Slab_cache4freeEPvR5Quota+0x136>

        // There are slabs in front of us and we're empty; requeue
        if (slab->prev) {
c0010420:	8b 46 08             	mov    0x8(%esi),%eax
c0010423:	85 c0                	test   %eax,%eax
c0010425:	74 6f                	je     c0010496 <_ZN10Slab_cache4freeEPvR5Quota+0x136>

            // Make slab in front of us current if we were current
            if (slab == curr)
c0010427:	3b 77 04             	cmp    0x4(%edi),%esi
c001042a:	75 03                	jne    c001042f <_ZN10Slab_cache4freeEPvR5Quota+0xcf>
                curr = slab->prev;
c001042c:	89 47 04             	mov    %eax,0x4(%edi)

            // Dequeue
            slab->prev->next = slab->next;
c001042f:	8b 46 08             	mov    0x8(%esi),%eax
c0010432:	8b 56 0c             	mov    0xc(%esi),%edx
c0010435:	89 50 0c             	mov    %edx,0xc(%eax)
            if (slab->next)
c0010438:	8b 46 0c             	mov    0xc(%esi),%eax
c001043b:	85 c0                	test   %eax,%eax
c001043d:	74 06                	je     c0010445 <_ZN10Slab_cache4freeEPvR5Quota+0xe5>
                slab->next->prev = slab->prev;
c001043f:	8b 56 08             	mov    0x8(%esi),%edx
c0010442:	89 50 08             	mov    %edx,0x8(%eax)

            if (slab->prev->empty() || (head && head->empty())) {
c0010445:	8b 46 08             	mov    0x8(%esi),%eax
c0010448:	8b 50 04             	mov    0x4(%eax),%edx
c001044b:	8b 52 14             	mov    0x14(%edx),%edx
c001044e:	39 10                	cmp    %edx,(%eax)
c0010450:	74 15                	je     c0010467 <_ZN10Slab_cache4freeEPvR5Quota+0x107>
c0010452:	8b 47 08             	mov    0x8(%edi),%eax
c0010455:	85 c0                	test   %eax,%eax
c0010457:	0f 84 83 00 00 00    	je     c00104e0 <_ZN10Slab_cache4freeEPvR5Quota+0x180>
c001045d:	8b 50 04             	mov    0x4(%eax),%edx
c0010460:	8b 52 14             	mov    0x14(%edx),%edx
c0010463:	39 10                	cmp    %edx,(%eax)
c0010465:	75 79                	jne    c00104e0 <_ZN10Slab_cache4freeEPvR5Quota+0x180>
                // There are already empty slabs - delete current slab
                assert(head != slab);
c0010467:	39 77 08             	cmp    %esi,0x8(%edi)
c001046a:	75 1e                	jne    c001048a <_ZN10Slab_cache4freeEPvR5Quota+0x12a>
c001046c:	68 e0 91 01 c0       	push   $0xc00191e0
c0010471:	68 9c 00 00 00       	push   $0x9c
c0010476:	68 2e 91 01 c0       	push   $0xc001912e
c001047b:	68 cb 91 01 c0       	push   $0xc00191cb
c0010480:	68 69 60 01 c0       	push   $0xc0016069
c0010485:	e8 bc 14 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

        ALWAYS_INLINE
        static inline void destroy(Slab *slab, Quota &quota)
        {
            slab->~Slab();
            Buddy::allocator.free (reinterpret_cast<mword>(slab), quota);
c001048a:	89 f2                	mov    %esi,%edx
c001048c:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c0010491:	e8 d2 0c ff ff       	call   c0001168 <_ZN5Buddy4freeEmR5Quota>
c0010496:	fe 07                	incb   (%edi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c0010498:	84 db                	test   %bl,%bl
c001049a:	74 5c                	je     c00104f8 <_ZN10Slab_cache4freeEPvR5Quota+0x198>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c001049c:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c00104a3:	74 16                	je     c00104bb <_ZN10Slab_cache4freeEPvR5Quota+0x15b>
c00104a5:	68 20 92 01 c0       	push   $0xc0019220
c00104aa:	68 c0 00 00 00       	push   $0xc0
c00104af:	68 12 61 01 c0       	push   $0xc0016112
c00104b4:	68 82 61 01 c0       	push   $0xc0016182
c00104b9:	eb c5                	jmp    c0010480 <_ZN10Slab_cache4freeEPvR5Quota+0x120>

            preemption = true;
c00104bb:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c00104c2:	fb                   	sti    
c00104c3:	eb 33                	jmp    c00104f8 <_ZN10Slab_cache4freeEPvR5Quota+0x198>
                curr->next = curr->next->prev = slab;
            }

            // Enqueue as head
            else {
                slab->prev = nullptr;
c00104c5:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
                slab->next = head;
c00104cc:	8b 47 08             	mov    0x8(%edi),%eax
c00104cf:	89 46 0c             	mov    %eax,0xc(%esi)
                head = head->prev = slab;
c00104d2:	8b 47 08             	mov    0x8(%edi),%eax
c00104d5:	89 70 08             	mov    %esi,0x8(%eax)
c00104d8:	89 77 08             	mov    %esi,0x8(%edi)
c00104db:	e9 2e ff ff ff       	jmp    c001040e <_ZN10Slab_cache4freeEPvR5Quota+0xae>
                assert(head != slab);
                Slab::destroy (slab, quota);
            } else {
                // There are partial slabs in front of us - requeue empty one
                // Enqueue as head
                slab->prev = nullptr;
c00104e0:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
                slab->next = head;
c00104e7:	8b 47 08             	mov    0x8(%edi),%eax
c00104ea:	89 46 0c             	mov    %eax,0xc(%esi)
                head = head->prev = slab;
c00104ed:	8b 47 08             	mov    0x8(%edi),%eax
c00104f0:	89 70 08             	mov    %esi,0x8(%eax)
c00104f3:	89 77 08             	mov    %esi,0x8(%edi)
c00104f6:	eb 9e                	jmp    c0010496 <_ZN10Slab_cache4freeEPvR5Quota+0x136>
            }
        }
    }
}
c00104f8:	58                   	pop    %eax
c00104f9:	5b                   	pop    %ebx
c00104fa:	5e                   	pop    %esi
c00104fb:	5f                   	pop    %edi
c00104fc:	5d                   	pop    %ebp
c00104fd:	c3                   	ret    

c00104fe <_ZN2Sm4freeEP8Rcu_elem>:
        mword counter;
        bool  rcu;

        static Slab_cache cache;

        static void free (Rcu_elem * a) {
c00104fe:	55                   	push   %ebp
            Sm * sm = static_cast <Sm *>(a);
c00104ff:	85 c0                	test   %eax,%eax
        mword counter;
        bool  rcu;

        static Slab_cache cache;

        static void free (Rcu_elem * a) {
c0010501:	57                   	push   %edi
c0010502:	56                   	push   %esi
            Sm * sm = static_cast <Sm *>(a);
c0010503:	8d 78 f4             	lea    -0xc(%eax),%edi
c0010506:	b8 00 00 00 00       	mov    $0x0,%eax
        mword counter;
        bool  rcu;

        static Slab_cache cache;

        static void free (Rcu_elem * a) {
c001050b:	53                   	push   %ebx
            Sm * sm = static_cast <Sm *>(a);
c001050c:	0f 44 f8             	cmove  %eax,%edi
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c001050f:	83 cb ff             	or     $0xffffffff,%ebx
c0010512:	f0 0f c1 5f 48       	lock xadd %ebx,0x48(%edi)

            if (sm->del_ref()) {
c0010517:	4b                   	dec    %ebx
c0010518:	75 2b                	jne    c0010545 <_ZN2Sm4freeEP8Rcu_elem+0x47>
                Pd *pd = static_cast<Pd *>(static_cast<Space_obj *>(sm->space));
c001051a:	8b 57 28             	mov    0x28(%edi),%edx
c001051d:	8d 82 78 fe ff ff    	lea    -0x188(%edx),%eax
c0010523:	85 d2                	test   %edx,%edx
c0010525:	0f 45 d8             	cmovne %eax,%ebx

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void destroy(Sm *obj, Quota &quota) { obj->~Sm(); cache.free (obj, quota); }
c0010528:	89 f8                	mov    %edi,%eax
c001052a:	e8 df 80 ff ff       	call   c000860e <_ZN2SmD1Ev>
        static void free (Rcu_elem * a) {
            Sm * sm = static_cast <Sm *>(a);

            if (sm->del_ref()) {
                Pd *pd = static_cast<Pd *>(static_cast<Space_obj *>(sm->space));
                destroy(sm, pd->quota);
c001052f:	8d 8b 90 01 00 00    	lea    0x190(%ebx),%ecx

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void destroy(Sm *obj, Quota &quota) { obj->~Sm(); cache.free (obj, quota); }
c0010535:	89 fa                	mov    %edi,%edx
                destroy(sm, pd->quota);
            } else {
                sm->rcu = false;
                sm->up();
            }
        }
c0010537:	5b                   	pop    %ebx

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void destroy(Sm *obj, Quota &quota) { obj->~Sm(); cache.free (obj, quota); }
c0010538:	b8 b4 b4 01 c0       	mov    $0xc001b4b4,%eax
                destroy(sm, pd->quota);
            } else {
                sm->rcu = false;
                sm->up();
            }
        }
c001053d:	5e                   	pop    %esi
c001053e:	5f                   	pop    %edi
c001053f:	5d                   	pop    %ebp

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void destroy(Sm *obj, Quota &quota) { obj->~Sm(); cache.free (obj, quota); }
c0010540:	e9 1b fe ff ff       	jmp    c0010360 <_ZN10Slab_cache4freeEPvR5Quota>

            if (sm->del_ref()) {
                Pd *pd = static_cast<Pd *>(static_cast<Space_obj *>(sm->space));
                destroy(sm, pd->quota);
            } else {
                sm->rcu = false;
c0010545:	c6 47 68 00          	movb   $0x0,0x68(%edi)
        ALWAYS_INLINE
        inline void up (void (*c)() = nullptr, Sm * si = nullptr)
        {
            Ec *ec;

            {   Lock_guard <Spinlock> guard (lock);
c0010549:	8d 6f 46             	lea    0x46(%edi),%ebp

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c001054c:	9c                   	pushf  
c001054d:	5b                   	pop    %ebx
            return flags & 0x200;
c001054e:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c0010551:	80 e3 01             	and    $0x1,%bl
c0010554:	74 2a                	je     c0010580 <_ZN2Sm4freeEP8Rcu_elem+0x82>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0010556:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c001055d:	75 19                	jne    c0010578 <_ZN2Sm4freeEP8Rcu_elem+0x7a>
c001055f:	68 00 93 01 c0       	push   $0xc0019300
c0010564:	68 b7 00 00 00       	push   $0xb7
c0010569:	68 12 61 01 c0       	push   $0xc0016112
c001056e:	68 83 61 01 c0       	push   $0xc0016183
c0010573:	e9 d0 00 00 00       	jmp    c0010648 <_ZN2Sm4freeEP8Rcu_elem+0x14a>

            asm volatile ("cli" : : : "memory");
c0010578:	fa                   	cli    
            preemption = false;
c0010579:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c0010580:	89 e8                	mov    %ebp,%eax
c0010582:	e8 a5 05 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c0010587:	8b 77 4c             	mov    0x4c(%edi),%esi
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c001058a:	85 f6                	test   %esi,%esi
c001058c:	0f 84 56 01 00 00    	je     c00106e8 <_ZN2Sm4freeEP8Rcu_elem+0x1ea>
c0010592:	8b 86 c4 00 00 00    	mov    0xc4(%esi),%eax
c0010598:	85 c0                	test   %eax,%eax
c001059a:	0f 84 48 01 00 00    	je     c00106e8 <_ZN2Sm4freeEP8Rcu_elem+0x1ea>
c00105a0:	8b 96 c0 00 00 00    	mov    0xc0(%esi),%edx
c00105a6:	85 d2                	test   %edx,%edx
c00105a8:	0f 84 3a 01 00 00    	je     c00106e8 <_ZN2Sm4freeEP8Rcu_elem+0x1ea>
                return false;

            if (t == t->next)
c00105ae:	39 c6                	cmp    %eax,%esi
c00105b0:	75 09                	jne    c00105bb <_ZN2Sm4freeEP8Rcu_elem+0xbd>
                headptr = nullptr;
c00105b2:	c7 47 4c 00 00 00 00 	movl   $0x0,0x4c(%edi)
c00105b9:	eb 26                	jmp    c00105e1 <_ZN2Sm4freeEP8Rcu_elem+0xe3>

            else {
                t->next->prev = t->prev;
c00105bb:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
                t->prev->next = t->next;
c00105c1:	8b 86 c0 00 00 00    	mov    0xc0(%esi),%eax
c00105c7:	8b 96 c4 00 00 00    	mov    0xc4(%esi),%edx
c00105cd:	89 90 c4 00 00 00    	mov    %edx,0xc4(%eax)
                if (t == headptr)
c00105d3:	3b 77 4c             	cmp    0x4c(%edi),%esi
c00105d6:	75 09                	jne    c00105e1 <_ZN2Sm4freeEP8Rcu_elem+0xe3>
                    headptr = t->next;
c00105d8:	8b 86 c4 00 00 00    	mov    0xc4(%esi),%eax
c00105de:	89 47 4c             	mov    %eax,0x4c(%edi)
            }

            t->next = t->prev = nullptr;
c00105e1:	c7 86 c0 00 00 00 00 	movl   $0x0,0xc0(%esi)
c00105e8:	00 00 00 
c00105eb:	83 c8 ff             	or     $0xffffffff,%eax
c00105ee:	c7 86 c4 00 00 00 00 	movl   $0x0,0xc4(%esi)
c00105f5:	00 00 00 
c00105f8:	f0 0f c1 46 48       	lock xadd %eax,0x48(%esi)

                    counter++;
                    return;
                }

                if (EXPECT_FALSE(ec->del_ref())) {
c00105fd:	48                   	dec    %eax
c00105fe:	75 24                	jne    c0010624 <_ZN2Sm4freeEP8Rcu_elem+0x126>
                    delete ec;
c0010600:	89 f0                	mov    %esi,%eax
c0010602:	e8 07 2f ff ff       	call   c000350e <_ZN2EcD1Ev>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c0010607:	8b 86 b8 00 00 00    	mov    0xb8(%esi),%eax
c001060d:	89 f2                	mov    %esi,%edx
c001060f:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c0010615:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c001061a:	e8 41 fd ff ff       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
c001061f:	e9 63 ff ff ff       	jmp    c0010587 <_ZN2Sm4freeEP8Rcu_elem+0x89>
c0010624:	fe 45 00             	incb   0x0(%ebp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c0010627:	84 db                	test   %bl,%bl
c0010629:	74 2f                	je     c001065a <_ZN2Sm4freeEP8Rcu_elem+0x15c>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c001062b:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0010632:	74 1e                	je     c0010652 <_ZN2Sm4freeEP8Rcu_elem+0x154>
c0010634:	68 c0 92 01 c0       	push   $0xc00192c0
c0010639:	68 c0 00 00 00       	push   $0xc0
c001063e:	68 12 61 01 c0       	push   $0xc0016112
c0010643:	68 82 61 01 c0       	push   $0xc0016182
c0010648:	68 69 60 01 c0       	push   $0xc0016069
c001064d:	e8 f4 12 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

            preemption = true;
c0010652:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c0010659:	fb                   	sti    
        inline void release (void (*c)())
        {
            if (c)
                cont = c;

            Lock_guard <Spinlock> guard (lock);
c001065a:	8d 46 46             	lea    0x46(%esi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c001065d:	9c                   	pushf  
c001065e:	5b                   	pop    %ebx
            return flags & 0x200;
c001065f:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c0010662:	80 e3 01             	and    $0x1,%bl
c0010665:	74 15                	je     c001067c <_ZN2Sm4freeEP8Rcu_elem+0x17e>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0010667:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c001066e:	0f 84 eb fe ff ff    	je     c001055f <_ZN2Sm4freeEP8Rcu_elem+0x61>

            asm volatile ("cli" : : : "memory");
c0010674:	fa                   	cli    
            preemption = false;
c0010675:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c001067c:	e8 ab 04 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c0010681:	8b 7e 4c             	mov    0x4c(%esi),%edi
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c0010684:	85 ff                	test   %edi,%edi
c0010686:	74 71                	je     c00106f9 <_ZN2Sm4freeEP8Rcu_elem+0x1fb>
c0010688:	8b 47 74             	mov    0x74(%edi),%eax
c001068b:	85 c0                	test   %eax,%eax
c001068d:	74 6a                	je     c00106f9 <_ZN2Sm4freeEP8Rcu_elem+0x1fb>
c001068f:	8b 57 70             	mov    0x70(%edi),%edx
c0010692:	85 d2                	test   %edx,%edx
c0010694:	74 63                	je     c00106f9 <_ZN2Sm4freeEP8Rcu_elem+0x1fb>
                return false;

            if (t == t->next)
c0010696:	39 c7                	cmp    %eax,%edi
c0010698:	75 09                	jne    c00106a3 <_ZN2Sm4freeEP8Rcu_elem+0x1a5>
                headptr = nullptr;
c001069a:	c7 46 4c 00 00 00 00 	movl   $0x0,0x4c(%esi)
c00106a1:	eb 17                	jmp    c00106ba <_ZN2Sm4freeEP8Rcu_elem+0x1bc>

            else {
                t->next->prev = t->prev;
c00106a3:	89 50 70             	mov    %edx,0x70(%eax)
                t->prev->next = t->next;
c00106a6:	8b 47 70             	mov    0x70(%edi),%eax
c00106a9:	8b 57 74             	mov    0x74(%edi),%edx
c00106ac:	89 50 74             	mov    %edx,0x74(%eax)
                if (t == headptr)
c00106af:	3b 7e 4c             	cmp    0x4c(%esi),%edi
c00106b2:	75 06                	jne    c00106ba <_ZN2Sm4freeEP8Rcu_elem+0x1bc>
                    headptr = t->next;
c00106b4:	8b 47 74             	mov    0x74(%edi),%eax
c00106b7:	89 46 4c             	mov    %eax,0x4c(%esi)
            }

            t->next = t->prev = nullptr;
c00106ba:	c7 47 70 00 00 00 00 	movl   $0x0,0x70(%edi)
c00106c1:	83 c8 ff             	or     $0xffffffff,%eax
c00106c4:	c7 47 74 00 00 00 00 	movl   $0x0,0x74(%edi)
c00106cb:	f0 0f c1 47 48       	lock xadd %eax,0x48(%edi)

            for (Sc *s; dequeue (s = head()); ) {
                if (EXPECT_FALSE(s->del_ref()) && (this == s->ec)) {
c00106d0:	48                   	dec    %eax
c00106d1:	75 1d                	jne    c00106f0 <_ZN2Sm4freeEP8Rcu_elem+0x1f2>
c00106d3:	3b 77 4c             	cmp    0x4c(%edi),%esi
c00106d6:	75 18                	jne    c00106f0 <_ZN2Sm4freeEP8Rcu_elem+0x1f2>
                    delete s;
c00106d8:	89 f8                	mov    %edi,%eax
c00106da:	e8 9b 5c ff ff       	call   c000637a <_ZN2ScD1Ev>
c00106df:	89 f8                	mov    %edi,%eax
c00106e1:	e8 5f f2 ff ff       	call   c000f945 <_ZN2ScdlEPv>
c00106e6:	eb 99                	jmp    c0010681 <_ZN2Sm4freeEP8Rcu_elem+0x183>
                    if (si) {
                       if (si->queued()) return;
                       Queue<Si>::enqueue(si);
                    }

                    counter++;
c00106e8:	ff 47 64             	incl   0x64(%edi)
c00106eb:	fe 45 00             	incb   0x0(%ebp)
c00106ee:	eb 0c                	jmp    c00106fc <_ZN2Sm4freeEP8Rcu_elem+0x1fe>
                    continue;
                }
                s->remote_enqueue();
c00106f0:	89 f8                	mov    %edi,%eax
c00106f2:	e8 45 f0 ff ff       	call   c000f73c <_ZN2Sc14remote_enqueueEv>
c00106f7:	eb 88                	jmp    c0010681 <_ZN2Sm4freeEP8Rcu_elem+0x183>
c00106f9:	fe 46 46             	incb   0x46(%esi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c00106fc:	84 db                	test   %bl,%bl
c00106fe:	74 15                	je     c0010715 <_ZN2Sm4freeEP8Rcu_elem+0x217>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0010700:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0010707:	0f 85 27 ff ff ff    	jne    c0010634 <_ZN2Sm4freeEP8Rcu_elem+0x136>

            preemption = true;
c001070d:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c0010714:	fb                   	sti    
                destroy(sm, pd->quota);
            } else {
                sm->rcu = false;
                sm->up();
            }
        }
c0010715:	5b                   	pop    %ebx
c0010716:	5e                   	pop    %esi
c0010717:	5f                   	pop    %edi
c0010718:	5d                   	pop    %ebp
c0010719:	c3                   	ret    

c001071a <_ZN2SmC1EP2PdmmPS_m>:
#include "stdio.hpp"

INIT_PRIORITY (PRIO_SLAB)
Slab_cache Sm::cache (sizeof (Sm), 32);

Sm::Sm (Pd *own, mword sel, mword cnt, Sm * s, mword v) : Kobject (SM, static_cast<Space_obj *>(own), sel, 0x3, free), Si (s, v), counter (cnt), rcu (false)
c001071a:	53                   	push   %ebx
c001071b:	85 d2                	test   %edx,%edx
c001071d:	6a 00                	push   $0x0
c001071f:	89 c3                	mov    %eax,%ebx
c0010721:	68 fe 04 01 c0       	push   $0xc00104fe
c0010726:	6a 03                	push   $0x3
c0010728:	8d 82 88 01 00 00    	lea    0x188(%edx),%eax
c001072e:	ba 00 00 00 00       	mov    $0x0,%edx
c0010733:	51                   	push   %ecx
c0010734:	0f 45 d0             	cmovne %eax,%edx
c0010737:	89 d9                	mov    %ebx,%ecx
c0010739:	89 d8                	mov    %ebx,%eax
c001073b:	e8 06 25 ff ff       	call   c0002c46 <_ZN3MdbC1EP5SpacemmmPFvP8Rcu_elemES5_>
c0010740:	8b 4c 24 20          	mov    0x20(%esp),%ecx
c0010744:	8d 43 54             	lea    0x54(%ebx),%eax
c0010747:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c001074b:	c6 43 44 04          	movb   $0x4,0x44(%ebx)
    private:
        uint16 val;

    public:
        ALWAYS_INLINE
        inline Spinlock() : val (0) {}
c001074f:	66 c7 43 46 00 00    	movw   $0x0,0x46(%ebx)
    private:
        uint32 ref;

    public:
        ALWAYS_INLINE
        inline Refex() : ref (1) {}
c0010755:	c7 43 48 01 00 00 00 	movl   $0x1,0x48(%ebx)
    private:
        T *headptr;

    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}
c001075c:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
c0010763:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
c001076a:	e8 fb f3 ff ff       	call   c000fb6a <_ZN2SiC1EP2Smm>
c001076f:	8b 44 24 18          	mov    0x18(%esp),%eax
c0010773:	83 c4 10             	add    $0x10,%esp
c0010776:	c6 43 68 00          	movb   $0x0,0x68(%ebx)
c001077a:	89 43 64             	mov    %eax,0x64(%ebx)
{
    trace (TRACE_SYSCALL, "SM:%p created (CNT:%lu)", this, cnt);
}
c001077d:	5b                   	pop    %ebx
c001077e:	c3                   	ret    

c001077f <_GLOBAL__sub_I.00102__ZN2Sm5cacheE>:

#include "sm.hpp"
#include "stdio.hpp"

INIT_PRIORITY (PRIO_SLAB)
Slab_cache Sm::cache (sizeof (Sm), 32);
c001077f:	b9 20 00 00 00       	mov    $0x20,%ecx
c0010784:	ba 6c 00 00 00       	mov    $0x6c,%edx
c0010789:	b8 b4 b4 01 c0       	mov    $0xc001b4b4,%eax
c001078e:	e9 73 fa ff ff       	jmp    c0010206 <_ZN10Slab_cacheC1Emj>

c0010793 <_ZL8free_mdbP8Rcu_elem>:

static void free_mdb(Rcu_elem * e)
{
    Mdb       *mdb   = static_cast<Mdb *>(e);
c0010793:	85 c0                	test   %eax,%eax
c0010795:	74 23                	je     c00107ba <_ZL8free_mdbP8Rcu_elem+0x27>
    Space_mem *space = static_cast<Space_mem *>(mdb->space);
c0010797:	8b 48 1c             	mov    0x1c(%eax),%ecx
    }
}

static void free_mdb(Rcu_elem * e)
{
    Mdb       *mdb   = static_cast<Mdb *>(e);
c001079a:	8d 50 f4             	lea    -0xc(%eax),%edx
    Space_mem *space = static_cast<Space_mem *>(mdb->space);
    Pd        *pd    = static_cast<Pd *>(space);
c001079d:	85 c9                	test   %ecx,%ecx
c001079f:	8d 41 b4             	lea    -0x4c(%ecx),%eax
c00107a2:	b9 00 00 00 00       	mov    $0x0,%ecx
c00107a7:	0f 45 c8             	cmovne %eax,%ecx
c00107aa:	b8 80 b0 01 c0       	mov    $0xc001b080,%eax

    Mdb::destroy (mdb, pd->quota);
c00107af:	81 c1 90 01 00 00    	add    $0x190,%ecx
c00107b5:	e9 a6 fb ff ff       	jmp    c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
}

static void free_mdb(Rcu_elem * e)
{
    Mdb       *mdb   = static_cast<Mdb *>(e);
    Space_mem *space = static_cast<Space_mem *>(mdb->space);
c00107ba:	a1 28 00 00 00       	mov    0x28,%eax
c00107bf:	0f 0b                	ud2    
c00107c1:	90                   	nop

c00107c2 <_ZN9Space_mem4initER5Quotaj>:

mword Space_mem::did_c [4096 / 8 / sizeof(mword)];
mword Space_mem::did_f = 0;

void Space_mem::init (Quota &quota, unsigned cpu)
{
c00107c2:	56                   	push   %esi
c00107c3:	53                   	push   %ebx
        template <typename T>
        ALWAYS_INLINE
        static inline bool test_set_bit (T &val, unsigned long bit)
        {
            bool ret;
            asm volatile ("lock; bts%z1 %2, %1; setc %0" : "=q" (ret), "+m" (val) : "ir" (bit) : "cc");
c00107c4:	f0 0f ab 88 20 01 00 	lock bts %ecx,0x120(%eax)
c00107cb:	00 
c00107cc:	0f 92 c3             	setb   %bl
    if (cpus.set (cpu)) {
c00107cf:	84 db                	test   %bl,%bl
c00107d1:	75 34                	jne    c0010807 <_ZN9Space_mem4initER5Quotaj+0x45>
        loc[cpu].sync_from (quota, Pd::kern.loc[cpu], CPU_LOCAL, SPC_LOCAL);
c00107d3:	8d 74 88 08          	lea    0x8(%eax,%ecx,4),%esi
c00107d7:	8b 0c 8d 14 b3 01 c0 	mov    -0x3ffe4cec(,%ecx,4),%ecx
c00107de:	89 d3                	mov    %edx,%ebx
c00107e0:	68 00 00 00 d0       	push   $0xd0000000
c00107e5:	89 f0                	mov    %esi,%eax
c00107e7:	68 00 00 c0 cf       	push   $0xcfc00000
c00107ec:	e8 d1 52 ff ff       	call   c0005ac2 <_ZN3Hpt9sync_fromER5QuotaS_mm>
        loc[cpu].sync_master_range (quota, LINK_ADDR, CPU_LOCAL);
c00107f1:	b9 00 00 00 c0       	mov    $0xc0000000,%ecx
c00107f6:	89 da                	mov    %ebx,%edx
c00107f8:	68 00 00 c0 cf       	push   $0xcfc00000
c00107fd:	89 f0                	mov    %esi,%eax
c00107ff:	e8 48 53 ff ff       	call   c0005b4c <_ZN3Hpt17sync_master_rangeER5Quotamm>
c0010804:	83 c4 0c             	add    $0xc,%esp
    }
}
c0010807:	5b                   	pop    %ebx
c0010808:	5e                   	pop    %esi
c0010809:	c3                   	ret    

c001080a <_ZN9Space_mem6updateER11Quota_guardP3Mdbm>:

bool Space_mem::update (Quota_guard &quota, Mdb *mdb, mword r)
{
c001080a:	55                   	push   %ebp
c001080b:	57                   	push   %edi
c001080c:	56                   	push   %esi
c001080d:	53                   	push   %ebx
c001080e:	83 ec 3c             	sub    $0x3c,%esp
    assert (this == mdb->space && this != &Pd::kern);
c0010811:	3d 0c b3 01 c0       	cmp    $0xc001b30c,%eax
        loc[cpu].sync_master_range (quota, LINK_ADDR, CPU_LOCAL);
    }
}

bool Space_mem::update (Quota_guard &quota, Mdb *mdb, mword r)
{
c0010816:	89 44 24 04          	mov    %eax,0x4(%esp)
    assert (this == mdb->space && this != &Pd::kern);
c001081a:	8b 7c 24 04          	mov    0x4(%esp),%edi
        loc[cpu].sync_master_range (quota, LINK_ADDR, CPU_LOCAL);
    }
}

bool Space_mem::update (Quota_guard &quota, Mdb *mdb, mword r)
{
c001081e:	89 54 24 0c          	mov    %edx,0xc(%esp)
    assert (this == mdb->space && this != &Pd::kern);
c0010822:	0f 94 c2             	sete   %dl
c0010825:	3b 79 28             	cmp    0x28(%ecx),%edi
        loc[cpu].sync_master_range (quota, LINK_ADDR, CPU_LOCAL);
    }
}

bool Space_mem::update (Quota_guard &quota, Mdb *mdb, mword r)
{
c0010828:	89 4c 24 10          	mov    %ecx,0x10(%esp)
    assert (this == mdb->space && this != &Pd::kern);
c001082c:	0f 95 c0             	setne  %al
c001082f:	08 c2                	or     %al,%dl
c0010831:	0f 85 a9 03 00 00    	jne    c0010be0 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x3d6>

    Lock_guard <Spinlock> guard (mdb->node_lock);
c0010837:	8b 44 24 10          	mov    0x10(%esp),%eax
c001083b:	83 c0 18             	add    $0x18,%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c001083e:	9c                   	pushf  
c001083f:	5a                   	pop    %edx
            return flags & 0x200;
c0010840:	c1 ea 09             	shr    $0x9,%edx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c0010843:	88 d3                	mov    %dl,%bl
c0010845:	80 e3 01             	and    $0x1,%bl
c0010848:	88 5c 24 2f          	mov    %bl,0x2f(%esp)
c001084c:	74 2a                	je     c0010878 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x6e>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c001084e:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0010855:	75 19                	jne    c0010870 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x66>
c0010857:	68 00 94 01 c0       	push   $0xc0019400
c001085c:	68 b7 00 00 00       	push   $0xb7
c0010861:	68 12 61 01 c0       	push   $0xc0016112
c0010866:	68 83 61 01 c0       	push   $0xc0016183
c001086b:	e9 59 03 00 00       	jmp    c0010bc9 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x3bf>

            asm volatile ("cli" : : : "memory");
c0010870:	fa                   	cli    
            preemption = false;
c0010871:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c0010878:	e8 af 02 ff ff       	call   c0000b2c <_ZN8Spinlock4lockEv>

    Paddr p = mdb->node_phys << PAGE_BITS;
c001087d:	8b 44 24 10          	mov    0x10(%esp),%eax
    mword b = mdb->node_base << PAGE_BITS;
    mword o = mdb->node_order;
    mword a = mdb->node_attr & ~r;
c0010881:	8b 7c 24 10          	mov    0x10(%esp),%edi
{
    assert (this == mdb->space && this != &Pd::kern);

    Lock_guard <Spinlock> guard (mdb->node_lock);

    Paddr p = mdb->node_phys << PAGE_BITS;
c0010885:	8b 40 2c             	mov    0x2c(%eax),%eax
c0010888:	c1 e0 0c             	shl    $0xc,%eax
c001088b:	89 44 24 18          	mov    %eax,0x18(%esp)
    mword b = mdb->node_base << PAGE_BITS;
c001088f:	8b 44 24 10          	mov    0x10(%esp),%eax
c0010893:	8b 40 30             	mov    0x30(%eax),%eax
c0010896:	c1 e0 0c             	shl    $0xc,%eax
c0010899:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    mword o = mdb->node_order;
c001089d:	8b 44 24 10          	mov    0x10(%esp),%eax
c00108a1:	8b 40 34             	mov    0x34(%eax),%eax
c00108a4:	89 04 24             	mov    %eax,(%esp)
    mword a = mdb->node_attr & ~r;
c00108a7:	8b 44 24 50          	mov    0x50(%esp),%eax
c00108ab:	f7 d0                	not    %eax
c00108ad:	23 47 38             	and    0x38(%edi),%eax
c00108b0:	89 44 24 08          	mov    %eax,0x8(%esp)
    mword s = mdb->node_sub;
c00108b4:	8b 47 40             	mov    0x40(%edi),%eax

    if (s & 1 && Dpt::ord != ~0UL) {
c00108b7:	a8 01                	test   $0x1,%al

    Paddr p = mdb->node_phys << PAGE_BITS;
    mword b = mdb->node_base << PAGE_BITS;
    mword o = mdb->node_order;
    mword a = mdb->node_attr & ~r;
    mword s = mdb->node_sub;
c00108b9:	89 44 24 28          	mov    %eax,0x28(%esp)

    if (s & 1 && Dpt::ord != ~0UL) {
c00108bd:	75 0c                	jne    c00108cb <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0xc1>

            dpt.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (Dpt::ord + PAGE_BITS)), a, r ? Dpt::TYPE_DN : Dpt::TYPE_UP);
        }
    }

    if (s & 2) {
c00108bf:	f6 44 24 28 02       	testb  $0x2,0x28(%esp)
c00108c4:	75 72                	jne    c0010938 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x12e>
c00108c6:	e9 7d 01 00 00       	jmp    c0010a48 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x23e>
    mword b = mdb->node_base << PAGE_BITS;
    mword o = mdb->node_order;
    mword a = mdb->node_attr & ~r;
    mword s = mdb->node_sub;

    if (s & 1 && Dpt::ord != ~0UL) {
c00108cb:	8b 2d 64 a2 01 c0    	mov    0xc001a264,%ebp
c00108d1:	83 fd ff             	cmp    $0xffffffff,%ebp
c00108d4:	74 e9                	je     c00108bf <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0xb5>
c00108d6:	3b 2c 24             	cmp    (%esp),%ebp
        mword ord = min (o, Dpt::ord);
        for (unsigned long i = 0; i < 1UL << (o - ord); i++) {
c00108d9:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
c00108e0:	00 
c00108e1:	0f 47 2c 24          	cmova  (%esp),%ebp

        bool update (Quota &quota, E, mword, E, mword, Type = TYPE_UP);

        void clear (Quota &quota, bool (*) (Paddr, mword, unsigned) = nullptr, bool (*) (unsigned, mword) = nullptr);

        bool check(Quota_guard &qg, mword o) { return qg.check(o / (4096 / sizeof(E)) + L); }
c00108e5:	89 e8                	mov    %ebp,%eax
c00108e7:	c1 e8 09             	shr    $0x9,%eax
c00108ea:	83 c0 04             	add    $0x4,%eax
c00108ed:	89 44 24 24          	mov    %eax,0x24(%esp)
c00108f1:	8b 04 24             	mov    (%esp),%eax
c00108f4:	29 e8                	sub    %ebp,%eax
c00108f6:	89 44 24 30          	mov    %eax,0x30(%esp)
            if (!r && !dpt.check(quota, ord)) {
                Cpu::hazard |= HZD_OOM;
                return false;
            }

            dpt.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (Dpt::ord + PAGE_BITS)), a, r ? Dpt::TYPE_DN : Dpt::TYPE_UP);
c00108fa:	8d 45 0c             	lea    0xc(%ebp),%eax
c00108fd:	89 44 24 34          	mov    %eax,0x34(%esp)
    mword a = mdb->node_attr & ~r;
    mword s = mdb->node_sub;

    if (s & 1 && Dpt::ord != ~0UL) {
        mword ord = min (o, Dpt::ord);
        for (unsigned long i = 0; i < 1UL << (o - ord); i++) {
c0010901:	8b 44 24 20          	mov    0x20(%esp),%eax
c0010905:	8a 4c 24 30          	mov    0x30(%esp),%cl
c0010909:	d3 e8                	shr    %cl,%eax
c001090b:	85 c0                	test   %eax,%eax
c001090d:	75 b0                	jne    c00108bf <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0xb5>
            if (!r && !dpt.check(quota, ord)) {
c001090f:	83 7c 24 50 00       	cmpl   $0x0,0x50(%esp)
c0010914:	0f 85 d9 02 00 00    	jne    c0010bf3 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x3e9>
c001091a:	8b 54 24 24          	mov    0x24(%esp),%edx
c001091e:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0010922:	e8 71 b1 ff ff       	call   c000ba98 <_ZN11Quota_guard5checkEm>
c0010927:	84 c0                	test   %al,%al
c0010929:	88 44 24 14          	mov    %al,0x14(%esp)
c001092d:	0f 85 c0 02 00 00    	jne    c0010bf3 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x3e9>
c0010933:	e9 5b 02 00 00       	jmp    c0010b93 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x389>
            dpt.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (Dpt::ord + PAGE_BITS)), a, r ? Dpt::TYPE_DN : Dpt::TYPE_UP);
        }
    }

    if (s & 2) {
        if (Vmcb::has_npt()) {
c0010938:	f6 05 30 fa ff cf 01 	testb  $0x1,0xcffffa30
c001093f:	8b 04 24             	mov    (%esp),%eax
c0010942:	74 76                	je     c00109ba <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x1b0>

        ALWAYS_INLINE
        static inline mword hw_attr (mword a) { return a ? a | HPT_D | HPT_A | HPT_U | HPT_P : 0; }
c0010944:	8b 6c 24 08          	mov    0x8(%esp),%ebp
c0010948:	89 c6                	mov    %eax,%esi
c001094a:	39 05 5c a2 01 c0    	cmp    %eax,0xc001a25c
c0010950:	b8 00 00 00 00       	mov    $0x0,%eax
c0010955:	0f 46 35 5c a2 01 c0 	cmovbe 0xc001a25c,%esi
c001095c:	83 cd 65             	or     $0x65,%ebp
c001095f:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0010964:	0f 44 e8             	cmove  %eax,%ebp
c0010967:	89 f0                	mov    %esi,%eax
c0010969:	c1 e8 0a             	shr    $0xa,%eax
            mword ord = min (o, Hpt::ord);
            for (unsigned long i = 0; i < 1UL << (o - ord); i++) {
c001096c:	31 db                	xor    %ebx,%ebx
c001096e:	83 c0 02             	add    $0x2,%eax
c0010971:	89 44 24 20          	mov    %eax,0x20(%esp)
c0010975:	8b 04 24             	mov    (%esp),%eax
c0010978:	29 f0                	sub    %esi,%eax
c001097a:	89 44 24 24          	mov    %eax,0x24(%esp)
                if (!r && !npt.check(quota, ord)) {
                    Cpu::hazard |= HZD_OOM;
                    return false;
                }

                npt.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (ord + PAGE_BITS)), Hpt::hw_attr (a), r ? Hpt::TYPE_DN : Hpt::TYPE_UP);
c001097e:	8d 46 0c             	lea    0xc(%esi),%eax
c0010981:	89 44 24 30          	mov    %eax,0x30(%esp)
    }

    if (s & 2) {
        if (Vmcb::has_npt()) {
            mword ord = min (o, Hpt::ord);
            for (unsigned long i = 0; i < 1UL << (o - ord); i++) {
c0010985:	8a 4c 24 24          	mov    0x24(%esp),%cl
c0010989:	89 d8                	mov    %ebx,%eax
c001098b:	d3 e8                	shr    %cl,%eax
c001098d:	85 c0                	test   %eax,%eax
c001098f:	75 70                	jne    c0010a01 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x1f7>
                if (!r && !npt.check(quota, ord)) {
c0010991:	83 7c 24 50 00       	cmpl   $0x0,0x50(%esp)
c0010996:	0f 85 af 02 00 00    	jne    c0010c4b <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x441>
c001099c:	8b 54 24 20          	mov    0x20(%esp),%edx
c00109a0:	8b 44 24 0c          	mov    0xc(%esp),%eax
c00109a4:	e8 ef b0 ff ff       	call   c000ba98 <_ZN11Quota_guard5checkEm>
c00109a9:	84 c0                	test   %al,%al
c00109ab:	88 44 24 14          	mov    %al,0x14(%esp)
c00109af:	0f 85 96 02 00 00    	jne    c0010c4b <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x441>
c00109b5:	e9 d9 01 00 00       	jmp    c0010b93 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x389>
c00109ba:	39 05 60 a2 01 c0    	cmp    %eax,0xc001a260

                npt.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (ord + PAGE_BITS)), Hpt::hw_attr (a), r ? Hpt::TYPE_DN : Hpt::TYPE_UP);
            }
        } else {
            mword ord = min (o, Ept::ord);
            for (unsigned long i = 0; i < 1UL << (o - ord); i++) {
c00109c0:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
c00109c7:	00 
c00109c8:	0f 46 05 60 a2 01 c0 	cmovbe 0xc001a260,%eax
c00109cf:	89 44 24 20          	mov    %eax,0x20(%esp)
c00109d3:	c1 e8 09             	shr    $0x9,%eax
c00109d6:	83 c0 04             	add    $0x4,%eax
c00109d9:	89 44 24 30          	mov    %eax,0x30(%esp)
c00109dd:	8b 04 24             	mov    (%esp),%eax
c00109e0:	2b 44 24 20          	sub    0x20(%esp),%eax
c00109e4:	89 44 24 34          	mov    %eax,0x34(%esp)
                if (!r && !ept.check(quota, ord)) {
                    Cpu::hazard |= HZD_OOM;
                    return false;
                }

                ept.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (ord + PAGE_BITS)), Ept::hw_attr (a, mdb->node_type), r ? Ept::TYPE_DN : Ept::TYPE_UP);
c00109e8:	8b 44 24 20          	mov    0x20(%esp),%eax
c00109ec:	83 c0 0c             	add    $0xc,%eax
c00109ef:	89 44 24 38          	mov    %eax,0x38(%esp)

                npt.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (ord + PAGE_BITS)), Hpt::hw_attr (a), r ? Hpt::TYPE_DN : Hpt::TYPE_UP);
            }
        } else {
            mword ord = min (o, Ept::ord);
            for (unsigned long i = 0; i < 1UL << (o - ord); i++) {
c00109f3:	8b 6c 24 24          	mov    0x24(%esp),%ebp
c00109f7:	8a 4c 24 34          	mov    0x34(%esp),%cl
c00109fb:	d3 ed                	shr    %cl,%ebp
c00109fd:	85 ed                	test   %ebp,%ebp
c00109ff:	74 1e                	je     c0010a1f <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x215>
                }

                ept.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (ord + PAGE_BITS)), Ept::hw_attr (a, mdb->node_type), r ? Ept::TYPE_DN : Ept::TYPE_UP);
            }
        }
        if (r)
c0010a01:	83 7c 24 50 00       	cmpl   $0x0,0x50(%esp)
c0010a06:	74 40                	je     c0010a48 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x23e>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }
c0010a08:	8b 44 24 04          	mov    0x4(%esp),%eax
c0010a0c:	8b 7c 24 04          	mov    0x4(%esp),%edi
c0010a10:	8b 80 20 01 00 00    	mov    0x120(%eax),%eax
c0010a16:	f0 09 87 28 01 00 00 	lock or %eax,0x128(%edi)
c0010a1d:	eb 29                	jmp    c0010a48 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x23e>
                npt.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (ord + PAGE_BITS)), Hpt::hw_attr (a), r ? Hpt::TYPE_DN : Hpt::TYPE_UP);
            }
        } else {
            mword ord = min (o, Ept::ord);
            for (unsigned long i = 0; i < 1UL << (o - ord); i++) {
                if (!r && !ept.check(quota, ord)) {
c0010a1f:	83 7c 24 50 00       	cmpl   $0x0,0x50(%esp)
c0010a24:	0f 85 5f 02 00 00    	jne    c0010c89 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x47f>
c0010a2a:	8b 54 24 30          	mov    0x30(%esp),%edx
c0010a2e:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0010a32:	e8 61 b0 ff ff       	call   c000ba98 <_ZN11Quota_guard5checkEm>
c0010a37:	84 c0                	test   %al,%al
c0010a39:	88 44 24 14          	mov    %al,0x14(%esp)
c0010a3d:	0f 85 46 02 00 00    	jne    c0010c89 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x47f>
c0010a43:	e9 4b 01 00 00       	jmp    c0010b93 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x389>
        }
        if (r)
            gtlb.merge (cpus);
    }

    if (s & 4) {
c0010a48:	f6 44 24 28 04       	testb  $0x4,0x28(%esp)
c0010a4d:	74 15                	je     c0010a64 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x25a>
        if (a)
            a |= Hpt::HPT_PWT;
c0010a4f:	8b 44 24 08          	mov    0x8(%esp),%eax
c0010a53:	83 c8 08             	or     $0x8,%eax
c0010a56:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0010a5b:	0f 44 44 24 08       	cmove  0x8(%esp),%eax
c0010a60:	89 44 24 08          	mov    %eax,0x8(%esp)
    }


    if ((mdb->node_base >= USER_ADDR >> PAGE_BITS) ||
c0010a64:	8b 44 24 10          	mov    0x10(%esp),%eax
c0010a68:	8b 50 30             	mov    0x30(%eax),%edx
c0010a6b:	81 fa ff ff 0b 00    	cmp    $0xbffff,%edx
c0010a71:	76 0a                	jbe    c0010a7d <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x273>
        (mdb->node_base + (1UL << o) > USER_ADDR >> PAGE_BITS) ||
        (mdb->node_base + (1UL << o) <= mdb->node_base))
        return false;
c0010a73:	c6 44 24 14 00       	movb   $0x0,0x14(%esp)
c0010a78:	e9 1d 01 00 00       	jmp    c0010b9a <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x390>
            a |= Hpt::HPT_PWT;
    }


    if ((mdb->node_base >= USER_ADDR >> PAGE_BITS) ||
        (mdb->node_base + (1UL << o) > USER_ADDR >> PAGE_BITS) ||
c0010a7d:	8a 0c 24             	mov    (%esp),%cl
c0010a80:	b8 01 00 00 00       	mov    $0x1,%eax
c0010a85:	d3 e0                	shl    %cl,%eax
c0010a87:	01 d0                	add    %edx,%eax
c0010a89:	39 d0                	cmp    %edx,%eax
c0010a8b:	76 e6                	jbe    c0010a73 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x269>
c0010a8d:	3d 00 00 0c 00       	cmp    $0xc0000,%eax
c0010a92:	77 df                	ja     c0010a73 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x269>
c0010a94:	8b 04 24             	mov    (%esp),%eax
c0010a97:	39 05 5c a2 01 c0    	cmp    %eax,0xc001a25c
c0010a9d:	8b 54 24 08          	mov    0x8(%esp),%edx
c0010aa1:	89 c6                	mov    %eax,%esi
c0010aa3:	0f 46 35 5c a2 01 c0 	cmovbe 0xc001a25c,%esi
c0010aaa:	83 ca 65             	or     $0x65,%edx
c0010aad:	89 f0                	mov    %esi,%eax
c0010aaf:	c1 e8 0a             	shr    $0xa,%eax
c0010ab2:	83 c0 02             	add    $0x2,%eax
c0010ab5:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0010aba:	89 44 24 20          	mov    %eax,0x20(%esp)
c0010abe:	b8 00 00 00 00       	mov    $0x0,%eax
c0010ac3:	0f 45 c2             	cmovne %edx,%eax
        return false;

    mword ord = min (o, Hpt::ord);
    bool f = false;

    for (unsigned long i = 0; i < 1UL << (o - ord); i++) {
c0010ac6:	31 ff                	xor    %edi,%edi
c0010ac8:	89 44 24 08          	mov    %eax,0x8(%esp)
c0010acc:	8b 04 24             	mov    (%esp),%eax
        (mdb->node_base + (1UL << o) > USER_ADDR >> PAGE_BITS) ||
        (mdb->node_base + (1UL << o) <= mdb->node_base))
        return false;

    mword ord = min (o, Hpt::ord);
    bool f = false;
c0010acf:	31 db                	xor    %ebx,%ebx

    for (unsigned long i = 0; i < 1UL << (o - ord); i++) {
c0010ad1:	29 f0                	sub    %esi,%eax
c0010ad3:	89 04 24             	mov    %eax,(%esp)
        if (!r && !hpt.check(quota, ord)) {
            Cpu::hazard |= HZD_OOM;
            return f;
        }

        f |= hpt.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (ord + PAGE_BITS)), Hpt::hw_attr (a), r ? Hpt::TYPE_DN : Hpt::TYPE_UP);
c0010ad6:	8d 46 0c             	lea    0xc(%esi),%eax
c0010ad9:	89 44 24 14          	mov    %eax,0x14(%esp)
        return false;

    mword ord = min (o, Hpt::ord);
    bool f = false;

    for (unsigned long i = 0; i < 1UL << (o - ord); i++) {
c0010add:	8a 0c 24             	mov    (%esp),%cl
c0010ae0:	89 f8                	mov    %edi,%eax
c0010ae2:	d3 e8                	shr    %cl,%eax
c0010ae4:	85 c0                	test   %eax,%eax
c0010ae6:	75 30                	jne    c0010b18 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x30e>
        if (!r && !hpt.check(quota, ord)) {
c0010ae8:	83 7c 24 50 00       	cmpl   $0x0,0x50(%esp)
c0010aed:	0f 85 ff 01 00 00    	jne    c0010cf2 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x4e8>
c0010af3:	8b 54 24 20          	mov    0x20(%esp),%edx
c0010af7:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0010afb:	e8 98 af ff ff       	call   c000ba98 <_ZN11Quota_guard5checkEm>
c0010b00:	84 c0                	test   %al,%al
c0010b02:	0f 85 ea 01 00 00    	jne    c0010cf2 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x4e8>
            Cpu::hazard |= HZD_OOM;
c0010b08:	83 0d 00 f0 ff cf 20 	orl    $0x20,0xcffff000
            return f;
c0010b0f:	88 5c 24 14          	mov    %bl,0x14(%esp)
c0010b13:	e9 82 00 00 00       	jmp    c0010b9a <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x390>
        }

        f |= hpt.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (ord + PAGE_BITS)), Hpt::hw_attr (a), r ? Hpt::TYPE_DN : Hpt::TYPE_UP);
    }

    if (r || f) {
c0010b18:	83 7c 24 50 00       	cmpl   $0x0,0x50(%esp)
c0010b1d:	0f 95 c0             	setne  %al
c0010b20:	08 c3                	or     %al,%bl
c0010b22:	88 5c 24 14          	mov    %bl,0x14(%esp)
c0010b26:	0f 84 47 ff ff ff    	je     c0010a73 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x269>
c0010b2c:	8b 44 24 04          	mov    0x4(%esp),%eax
c0010b30:	8d 58 08             	lea    0x8(%eax),%ebx
c0010b33:	8d a8 08 01 00 00    	lea    0x108(%eax),%ebp
                if (!r && !loc[j].check(quota, ord)) {
                    Cpu::hazard |= HZD_OOM;
                    return (r || f);
                }

                loc[j].update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (ord + PAGE_BITS)), Hpt::hw_attr (a), Hpt::TYPE_DF);
c0010b39:	8d 46 0c             	lea    0xc(%esi),%eax
c0010b3c:	89 44 24 24          	mov    %eax,0x24(%esp)
    }

    if (r || f) {

        for (unsigned j = 0; j < sizeof (loc) / sizeof (*loc); j++) {
            if (!loc[j].addr())
c0010b40:	f7 03 00 f0 ff ff    	testl  $0xfffff000,(%ebx)
c0010b46:	75 1e                	jne    c0010b66 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x35c>
c0010b48:	83 c3 04             	add    $0x4,%ebx
        f |= hpt.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (ord + PAGE_BITS)), Hpt::hw_attr (a), r ? Hpt::TYPE_DN : Hpt::TYPE_UP);
    }

    if (r || f) {

        for (unsigned j = 0; j < sizeof (loc) / sizeof (*loc); j++) {
c0010b4b:	39 eb                	cmp    %ebp,%ebx
c0010b4d:	75 f1                	jne    c0010b40 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x336>
c0010b4f:	8b 44 24 04          	mov    0x4(%esp),%eax
c0010b53:	8b 7c 24 04          	mov    0x4(%esp),%edi
c0010b57:	8b 80 20 01 00 00    	mov    0x120(%eax),%eax
c0010b5d:	f0 09 87 24 01 00 00 	lock or %eax,0x124(%edi)
c0010b64:	eb 34                	jmp    c0010b9a <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x390>
c0010b66:	31 ff                	xor    %edi,%edi
            if (!loc[j].addr())
                continue;

            for (unsigned long i = 0; i < 1UL << (o - ord); i++) {
c0010b68:	8a 0c 24             	mov    (%esp),%cl
c0010b6b:	89 f8                	mov    %edi,%eax
c0010b6d:	d3 e8                	shr    %cl,%eax
c0010b6f:	85 c0                	test   %eax,%eax
c0010b71:	75 d5                	jne    c0010b48 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x33e>
                if (!r && !loc[j].check(quota, ord)) {
c0010b73:	83 7c 24 50 00       	cmpl   $0x0,0x50(%esp)
c0010b78:	0f 85 b7 01 00 00    	jne    c0010d35 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x52b>
c0010b7e:	8b 54 24 20          	mov    0x20(%esp),%edx
c0010b82:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0010b86:	e8 0d af ff ff       	call   c000ba98 <_ZN11Quota_guard5checkEm>
c0010b8b:	84 c0                	test   %al,%al
c0010b8d:	0f 85 a2 01 00 00    	jne    c0010d35 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x52b>
                    Cpu::hazard |= HZD_OOM;
c0010b93:	83 0d 00 f0 ff cf 20 	orl    $0x20,0xcffff000
        }

        ALWAYS_INLINE
        inline void unlock()
        {
            asm volatile ("incb %0" : "=m" (val) : : "memory");
c0010b9a:	8b 44 24 10          	mov    0x10(%esp),%eax
c0010b9e:	fe 40 18             	incb   0x18(%eax)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c0010ba1:	80 7c 24 2f 00       	cmpb   $0x0,0x2f(%esp)
c0010ba6:	0f 84 b9 01 00 00    	je     c0010d65 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x55b>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0010bac:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0010bb3:	74 1e                	je     c0010bd3 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x3c9>
c0010bb5:	68 c0 93 01 c0       	push   $0xc00193c0
c0010bba:	68 c0 00 00 00       	push   $0xc0
c0010bbf:	68 12 61 01 c0       	push   $0xc0016112
c0010bc4:	68 82 61 01 c0       	push   $0xc0016182
c0010bc9:	68 69 60 01 c0       	push   $0xc0016069
c0010bce:	e8 73 0d ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

            preemption = true;
c0010bd3:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c0010bda:	fb                   	sti    
c0010bdb:	e9 85 01 00 00       	jmp    c0010d65 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x55b>
    }
}

bool Space_mem::update (Quota_guard &quota, Mdb *mdb, mword r)
{
    assert (this == mdb->space && this != &Pd::kern);
c0010be0:	68 40 94 01 c0       	push   $0xc0019440
c0010be5:	6a 2d                	push   $0x2d
c0010be7:	68 23 93 01 c0       	push   $0xc0019323
c0010bec:	68 95 93 01 c0       	push   $0xc0019395
c0010bf1:	eb d6                	jmp    c0010bc9 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x3bf>
            if (!r && !dpt.check(quota, ord)) {
                Cpu::hazard |= HZD_OOM;
                return false;
            }

            dpt.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (Dpt::ord + PAGE_BITS)), a, r ? Dpt::TYPE_DN : Dpt::TYPE_UP);
c0010bf3:	a1 64 a2 01 c0       	mov    0xc001a264,%eax
c0010bf8:	31 d2                	xor    %edx,%edx
c0010bfa:	8b 74 24 20          	mov    0x20(%esp),%esi
c0010bfe:	83 7c 24 50 00       	cmpl   $0x0,0x50(%esp)
c0010c03:	8d 48 0c             	lea    0xc(%eax),%ecx
c0010c06:	8b 44 24 20          	mov    0x20(%esp),%eax
c0010c0a:	0f 95 c2             	setne  %dl
c0010c0d:	31 ff                	xor    %edi,%edi
c0010c0f:	d3 e6                	shl    %cl,%esi
c0010c11:	8a 4c 24 34          	mov    0x34(%esp),%cl
c0010c15:	31 db                	xor    %ebx,%ebx
c0010c17:	03 74 24 18          	add    0x18(%esp),%esi
c0010c1b:	d3 e0                	shl    %cl,%eax
c0010c1d:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
c0010c21:	01 c1                	add    %eax,%ecx
c0010c23:	8b 44 24 04          	mov    0x4(%esp),%eax
c0010c27:	52                   	push   %edx
c0010c28:	ff 74 24 0c          	pushl  0xc(%esp)
c0010c2c:	05 0c 01 00 00       	add    $0x10c,%eax
c0010c31:	57                   	push   %edi
c0010c32:	56                   	push   %esi
c0010c33:	55                   	push   %ebp
c0010c34:	53                   	push   %ebx
c0010c35:	51                   	push   %ecx
c0010c36:	8b 54 24 28          	mov    0x28(%esp),%edx
c0010c3a:	e8 3b ce ff ff       	call   c000da7a <_ZN3PteI3DptyLj4ELj9ELb1EE6updateER5QuotaymymNS1_4TypeE>
    mword a = mdb->node_attr & ~r;
    mword s = mdb->node_sub;

    if (s & 1 && Dpt::ord != ~0UL) {
        mword ord = min (o, Dpt::ord);
        for (unsigned long i = 0; i < 1UL << (o - ord); i++) {
c0010c3f:	ff 44 24 3c          	incl   0x3c(%esp)
c0010c43:	83 c4 1c             	add    $0x1c,%esp
c0010c46:	e9 b6 fc ff ff       	jmp    c0010901 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0xf7>
                if (!r && !npt.check(quota, ord)) {
                    Cpu::hazard |= HZD_OOM;
                    return false;
                }

                npt.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (ord + PAGE_BITS)), Hpt::hw_attr (a), r ? Hpt::TYPE_DN : Hpt::TYPE_UP);
c0010c4b:	8a 4c 24 30          	mov    0x30(%esp),%cl
c0010c4f:	31 d2                	xor    %edx,%edx
c0010c51:	89 d8                	mov    %ebx,%eax
c0010c53:	83 7c 24 50 00       	cmpl   $0x0,0x50(%esp)
c0010c58:	0f 95 c2             	setne  %dl
    }

    if (s & 2) {
        if (Vmcb::has_npt()) {
            mword ord = min (o, Hpt::ord);
            for (unsigned long i = 0; i < 1UL << (o - ord); i++) {
c0010c5b:	43                   	inc    %ebx
                if (!r && !npt.check(quota, ord)) {
                    Cpu::hazard |= HZD_OOM;
                    return false;
                }

                npt.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (ord + PAGE_BITS)), Hpt::hw_attr (a), r ? Hpt::TYPE_DN : Hpt::TYPE_UP);
c0010c5c:	d3 e0                	shl    %cl,%eax
c0010c5e:	89 c1                	mov    %eax,%ecx
c0010c60:	8b 44 24 18          	mov    0x18(%esp),%eax
c0010c64:	8d 3c 01             	lea    (%ecx,%eax,1),%edi
c0010c67:	8b 44 24 04          	mov    0x4(%esp),%eax
c0010c6b:	03 4c 24 1c          	add    0x1c(%esp),%ecx
c0010c6f:	52                   	push   %edx
c0010c70:	55                   	push   %ebp
c0010c71:	57                   	push   %edi
c0010c72:	05 14 01 00 00       	add    $0x114,%eax
c0010c77:	56                   	push   %esi
c0010c78:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0010c7c:	e8 3f d4 ff ff       	call   c000e0c0 <_ZN3PteI3HptmLj2ELj10ELb0EE6updateER5QuotammmmNS1_4TypeE>
    }

    if (s & 2) {
        if (Vmcb::has_npt()) {
            mword ord = min (o, Hpt::ord);
            for (unsigned long i = 0; i < 1UL << (o - ord); i++) {
c0010c81:	83 c4 10             	add    $0x10,%esp
c0010c84:	e9 fc fc ff ff       	jmp    c0010985 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x17b>
                if (!r && !ept.check(quota, ord)) {
                    Cpu::hazard |= HZD_OOM;
                    return false;
                }

                ept.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (ord + PAGE_BITS)), Ept::hw_attr (a, mdb->node_type), r ? Ept::TYPE_DN : Ept::TYPE_UP);
c0010c89:	31 d2                	xor    %edx,%edx
c0010c8b:	8b 44 24 10          	mov    0x10(%esp),%eax
c0010c8f:	83 7c 24 50 00       	cmpl   $0x0,0x50(%esp)
c0010c94:	0f 95 c2             	setne  %dl
c0010c97:	8b 40 3c             	mov    0x3c(%eax),%eax
            PTE_S   = EPT_S,
            PTE_N   = EPT_R | EPT_W | EPT_X,
        };

        ALWAYS_INLINE
        static inline mword hw_attr (mword a, mword t) { return a ? t << 3 | a | EPT_I | EPT_R : 0; }
c0010c9a:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0010c9f:	74 0e                	je     c0010caf <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x4a5>
c0010ca1:	8d 2c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebp
c0010ca8:	83 cd 41             	or     $0x41,%ebp
c0010cab:	0b 6c 24 08          	or     0x8(%esp),%ebp
c0010caf:	8a 4c 24 38          	mov    0x38(%esp),%cl
c0010cb3:	31 ff                	xor    %edi,%edi
c0010cb5:	31 db                	xor    %ebx,%ebx
c0010cb7:	8b 44 24 24          	mov    0x24(%esp),%eax
c0010cbb:	d3 e0                	shl    %cl,%eax
c0010cbd:	89 c1                	mov    %eax,%ecx
c0010cbf:	8b 44 24 18          	mov    0x18(%esp),%eax
c0010cc3:	8d 34 01             	lea    (%ecx,%eax,1),%esi
c0010cc6:	8b 44 24 04          	mov    0x4(%esp),%eax
c0010cca:	03 4c 24 1c          	add    0x1c(%esp),%ecx
c0010cce:	52                   	push   %edx
c0010ccf:	55                   	push   %ebp
c0010cd0:	57                   	push   %edi
c0010cd1:	05 14 01 00 00       	add    $0x114,%eax
c0010cd6:	56                   	push   %esi
c0010cd7:	ff 74 24 30          	pushl  0x30(%esp)
c0010cdb:	53                   	push   %ebx
c0010cdc:	51                   	push   %ecx
c0010cdd:	8b 54 24 28          	mov    0x28(%esp),%edx
c0010ce1:	e8 9c d0 ff ff       	call   c000dd82 <_ZN3PteI3EptyLj4ELj9ELb0EE6updateER5QuotaymymNS1_4TypeE>

                npt.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (ord + PAGE_BITS)), Hpt::hw_attr (a), r ? Hpt::TYPE_DN : Hpt::TYPE_UP);
            }
        } else {
            mword ord = min (o, Ept::ord);
            for (unsigned long i = 0; i < 1UL << (o - ord); i++) {
c0010ce6:	ff 44 24 40          	incl   0x40(%esp)
c0010cea:	83 c4 1c             	add    $0x1c,%esp
c0010ced:	e9 01 fd ff ff       	jmp    c00109f3 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x1e9>
        if (!r && !hpt.check(quota, ord)) {
            Cpu::hazard |= HZD_OOM;
            return f;
        }

        f |= hpt.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (ord + PAGE_BITS)), Hpt::hw_attr (a), r ? Hpt::TYPE_DN : Hpt::TYPE_UP);
c0010cf2:	8a 4c 24 14          	mov    0x14(%esp),%cl
c0010cf6:	31 d2                	xor    %edx,%edx
c0010cf8:	89 f8                	mov    %edi,%eax
c0010cfa:	83 7c 24 50 00       	cmpl   $0x0,0x50(%esp)
c0010cff:	0f 95 c2             	setne  %dl
        return false;

    mword ord = min (o, Hpt::ord);
    bool f = false;

    for (unsigned long i = 0; i < 1UL << (o - ord); i++) {
c0010d02:	47                   	inc    %edi
        if (!r && !hpt.check(quota, ord)) {
            Cpu::hazard |= HZD_OOM;
            return f;
        }

        f |= hpt.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (ord + PAGE_BITS)), Hpt::hw_attr (a), r ? Hpt::TYPE_DN : Hpt::TYPE_UP);
c0010d03:	d3 e0                	shl    %cl,%eax
c0010d05:	89 c1                	mov    %eax,%ecx
c0010d07:	8b 44 24 18          	mov    0x18(%esp),%eax
c0010d0b:	8d 2c 01             	lea    (%ecx,%eax,1),%ebp
c0010d0e:	8b 44 24 04          	mov    0x4(%esp),%eax
c0010d12:	03 4c 24 1c          	add    0x1c(%esp),%ecx
c0010d16:	52                   	push   %edx
c0010d17:	ff 74 24 0c          	pushl  0xc(%esp)
c0010d1b:	05 08 01 00 00       	add    $0x108,%eax
c0010d20:	55                   	push   %ebp
c0010d21:	56                   	push   %esi
c0010d22:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0010d26:	e8 95 d3 ff ff       	call   c000e0c0 <_ZN3PteI3HptmLj2ELj10ELb0EE6updateER5QuotammmmNS1_4TypeE>
        return false;

    mword ord = min (o, Hpt::ord);
    bool f = false;

    for (unsigned long i = 0; i < 1UL << (o - ord); i++) {
c0010d2b:	83 c4 10             	add    $0x10,%esp
        if (!r && !hpt.check(quota, ord)) {
            Cpu::hazard |= HZD_OOM;
            return f;
        }

        f |= hpt.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (ord + PAGE_BITS)), Hpt::hw_attr (a), r ? Hpt::TYPE_DN : Hpt::TYPE_UP);
c0010d2e:	08 c3                	or     %al,%bl
c0010d30:	e9 a8 fd ff ff       	jmp    c0010add <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x2d3>
                if (!r && !loc[j].check(quota, ord)) {
                    Cpu::hazard |= HZD_OOM;
                    return (r || f);
                }

                loc[j].update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (ord + PAGE_BITS)), Hpt::hw_attr (a), Hpt::TYPE_DF);
c0010d35:	8a 4c 24 24          	mov    0x24(%esp),%cl
c0010d39:	89 f8                	mov    %edi,%eax

        for (unsigned j = 0; j < sizeof (loc) / sizeof (*loc); j++) {
            if (!loc[j].addr())
                continue;

            for (unsigned long i = 0; i < 1UL << (o - ord); i++) {
c0010d3b:	47                   	inc    %edi
                if (!r && !loc[j].check(quota, ord)) {
                    Cpu::hazard |= HZD_OOM;
                    return (r || f);
                }

                loc[j].update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (ord + PAGE_BITS)), Hpt::hw_attr (a), Hpt::TYPE_DF);
c0010d3c:	d3 e0                	shl    %cl,%eax
c0010d3e:	89 c1                	mov    %eax,%ecx
c0010d40:	8b 44 24 18          	mov    0x18(%esp),%eax
c0010d44:	01 c8                	add    %ecx,%eax
c0010d46:	03 4c 24 1c          	add    0x1c(%esp),%ecx
c0010d4a:	6a 02                	push   $0x2
c0010d4c:	ff 74 24 0c          	pushl  0xc(%esp)
c0010d50:	50                   	push   %eax
c0010d51:	89 d8                	mov    %ebx,%eax
c0010d53:	56                   	push   %esi
c0010d54:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0010d58:	e8 63 d3 ff ff       	call   c000e0c0 <_ZN3PteI3HptmLj2ELj10ELb0EE6updateER5QuotammmmNS1_4TypeE>

        for (unsigned j = 0; j < sizeof (loc) / sizeof (*loc); j++) {
            if (!loc[j].addr())
                continue;

            for (unsigned long i = 0; i < 1UL << (o - ord); i++) {
c0010d5d:	83 c4 10             	add    $0x10,%esp
c0010d60:	e9 03 fe ff ff       	jmp    c0010b68 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x35e>

        htlb.merge (cpus);
    }

    return (r || f);
}
c0010d65:	8a 44 24 14          	mov    0x14(%esp),%al
c0010d69:	83 c4 3c             	add    $0x3c,%esp
c0010d6c:	5b                   	pop    %ebx
c0010d6d:	5e                   	pop    %esi
c0010d6e:	5f                   	pop    %edi
c0010d6f:	5d                   	pop    %ebp
c0010d70:	c3                   	ret    
c0010d71:	90                   	nop

c0010d72 <_ZN9Space_mem9shootdownEv>:

void Space_mem::shootdown()
{
c0010d72:	55                   	push   %ebp
c0010d73:	b8 04 00 00 00       	mov    $0x4,%eax
c0010d78:	57                   	push   %edi
c0010d79:	2d 0c f0 ff cf       	sub    $0xcffff00c,%eax
c0010d7e:	56                   	push   %esi
c0010d7f:	be 0c 00 c0 ce       	mov    $0xcec0000c,%esi
c0010d84:	53                   	push   %ebx
    for (unsigned cpu = 0; cpu < NUM_CPU; cpu++) {
c0010d85:	31 db                	xor    %ebx,%ebx

    return (r || f);
}

void Space_mem::shootdown()
{
c0010d87:	51                   	push   %ecx
c0010d88:	89 04 24             	mov    %eax,(%esp)
c0010d8b:	f6 04 dd 38 e0 01 c0 	testb  $0x1,-0x3ffe1fc8(,%ebx,8)
c0010d92:	01 
c0010d93:	74 18                	je     c0010dad <_ZN9Space_mem9shootdownEv+0x3b>
        }

        ALWAYS_INLINE
        static inline Pd *remote (unsigned c)
        {
            return *reinterpret_cast<volatile typeof current *>(reinterpret_cast<mword>(&current) - CPU_LOCAL_DATA + HV_GLOBAL_CPUS + c * PAGE_SIZE);
c0010d95:	8b 06                	mov    (%esi),%eax
c0010d97:	8b 90 70 01 00 00    	mov    0x170(%eax),%edx
        if (!Hip::cpu_online (cpu))
            continue;

        Pd *pd = Pd::remote (cpu);

        if (!pd->htlb.chk (cpu) && !pd->gtlb.chk (cpu))
c0010d9d:	0f a3 da             	bt     %ebx,%edx
c0010da0:	72 1d                	jb     c0010dbf <_ZN9Space_mem9shootdownEv+0x4d>
c0010da2:	8b 80 74 01 00 00    	mov    0x174(%eax),%eax
c0010da8:	0f a3 d8             	bt     %ebx,%eax
c0010dab:	72 12                	jb     c0010dbf <_ZN9Space_mem9shootdownEv+0x4d>
    return (r || f);
}

void Space_mem::shootdown()
{
    for (unsigned cpu = 0; cpu < NUM_CPU; cpu++) {
c0010dad:	43                   	inc    %ebx
c0010dae:	81 c6 00 10 00 00    	add    $0x1000,%esi
c0010db4:	83 fb 40             	cmp    $0x40,%ebx
c0010db7:	75 d2                	jne    c0010d8b <_ZN9Space_mem9shootdownEv+0x19>
            pause();

        if (!Cpu::preemption)
            asm volatile ("cli" : : : "memory");
    }
}
c0010db9:	58                   	pop    %eax
c0010dba:	5b                   	pop    %ebx
c0010dbb:	5e                   	pop    %esi
c0010dbc:	5f                   	pop    %edi
c0010dbd:	5d                   	pop    %ebp
c0010dbe:	c3                   	ret    
        Pd *pd = Pd::remote (cpu);

        if (!pd->htlb.chk (cpu) && !pd->gtlb.chk (cpu))
            continue;

        if (Cpu::id == cpu) {
c0010dbf:	39 1d 04 f0 ff cf    	cmp    %ebx,0xcffff004
c0010dc5:	75 09                	jne    c0010dd0 <_ZN9Space_mem9shootdownEv+0x5e>
            Cpu::hazard |= HZD_SCHED;
c0010dc7:	83 0d 00 f0 ff cf 01 	orl    $0x1,0xcffff000
            continue;
c0010dce:	eb dd                	jmp    c0010dad <_ZN9Space_mem9shootdownEv+0x3b>
c0010dd0:	8b 04 24             	mov    (%esp),%eax
        }

        unsigned ctr = Counter::remote (cpu, 1);

        Lapic::send_ipi (cpu, VEC_IPI_RKE);
c0010dd3:	31 c9                	xor    %ecx,%ecx
c0010dd5:	ba a8 00 00 00       	mov    $0xa8,%edx
c0010dda:	6a 00                	push   $0x0
c0010ddc:	01 f0                	add    %esi,%eax
        static void dump();

        ALWAYS_INLINE
        static inline unsigned remote (unsigned c, unsigned i)
        {
            return *reinterpret_cast<volatile unsigned *>(reinterpret_cast<mword>(ipi + i) - CPU_LOCAL_DATA + HV_GLOBAL_CPUS + c * PAGE_SIZE);
c0010dde:	8b b8 d8 f6 ff cf    	mov    -0x30000928(%eax),%edi
c0010de4:	8d a8 d8 f6 ff cf    	lea    -0x30000928(%eax),%ebp
c0010dea:	89 d8                	mov    %ebx,%eax
c0010dec:	e8 63 4f ff ff       	call   c0005d54 <_ZN5Lapic8send_ipiEjjNS_13Delivery_modeENS_9ShorthandE>

        if (!Cpu::preemption)
c0010df1:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0010df8:	5a                   	pop    %edx
c0010df9:	75 01                	jne    c0010dfc <_ZN9Space_mem9shootdownEv+0x8a>
            asm volatile ("sti" : : : "memory");
c0010dfb:	fb                   	sti    
c0010dfc:	8b 45 00             	mov    0x0(%ebp),%eax

        while (Counter::remote (cpu, 1) == ctr)
c0010dff:	39 f8                	cmp    %edi,%eax
c0010e01:	75 04                	jne    c0010e07 <_ZN9Space_mem9shootdownEv+0x95>
}

ALWAYS_INLINE
static inline void pause()
{
    asm volatile ("pause" : : : "memory");
c0010e03:	f3 90                	pause  
c0010e05:	eb f5                	jmp    c0010dfc <_ZN9Space_mem9shootdownEv+0x8a>
            pause();

        if (!Cpu::preemption)
c0010e07:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0010e0e:	75 9d                	jne    c0010dad <_ZN9Space_mem9shootdownEv+0x3b>
            asm volatile ("cli" : : : "memory");
c0010e10:	fa                   	cli    
c0010e11:	eb 9a                	jmp    c0010dad <_ZN9Space_mem9shootdownEv+0x3b>
c0010e13:	90                   	nop

c0010e14 <_ZN9Space_mem11insert_utcbER5Quotamm>:

    Mdb::destroy (mdb, pd->quota);
}

bool Space_mem::insert_utcb (Quota &quota, mword b, mword phys)
{
c0010e14:	55                   	push   %ebp
c0010e15:	57                   	push   %edi
c0010e16:	56                   	push   %esi
c0010e17:	53                   	push   %ebx
c0010e18:	53                   	push   %ebx
    if (!phys)
       return true;

    if (!b)
c0010e19:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
c0010e1e:	74 04                	je     c0010e24 <_ZN9Space_mem11insert_utcbER5Quotamm+0x10>
c0010e20:	85 c9                	test   %ecx,%ecx
c0010e22:	75 07                	jne    c0010e2b <_ZN9Space_mem11insert_utcbER5Quotamm+0x17>
        return true;
c0010e24:	c6 44 24 03 01       	movb   $0x1,0x3(%esp)
c0010e29:	eb 51                	jmp    c0010e7c <_ZN9Space_mem11insert_utcbER5Quotamm+0x68>
c0010e2b:	89 c5                	mov    %eax,%ebp
        bool insert_node (Mdb *, mword);
        void demote_node (mword);
        bool remove_node();

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
c0010e2d:	b8 80 b0 01 c0       	mov    $0xc001b080,%eax
c0010e32:	89 cb                	mov    %ecx,%ebx
c0010e34:	89 d6                	mov    %edx,%esi
c0010e36:	e8 3b f4 ff ff       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>

    Mdb *mdb = new (quota) Mdb (this, free_mdb, phys, b >> PAGE_BITS, 0, 0x3);
c0010e3b:	c1 eb 0c             	shr    $0xc,%ebx
c0010e3e:	b9 93 07 01 c0       	mov    $0xc0010793,%ecx
c0010e43:	6a 00                	push   $0x0
c0010e45:	89 ea                	mov    %ebp,%edx
c0010e47:	6a 00                	push   $0x0
c0010e49:	6a 03                	push   $0x3
c0010e4b:	6a 00                	push   $0x0
c0010e4d:	53                   	push   %ebx
c0010e4e:	ff 74 24 2c          	pushl  0x2c(%esp)
c0010e52:	89 c7                	mov    %eax,%edi
c0010e54:	e8 3d 14 ff ff       	call   c0002296 <_ZN3MdbC1EP5SpacePFvP8Rcu_elemEmmmmmm>

    if (tree_insert (mdb))
c0010e59:	89 f8                	mov    %edi,%eax
c0010e5b:	e8 33 ad ff ff       	call   c000bb93 <_ZN5Space11tree_insertEP3Mdb>
c0010e60:	88 44 24 1b          	mov    %al,0x1b(%esp)
c0010e64:	83 c4 18             	add    $0x18,%esp
c0010e67:	80 7c 24 03 00       	cmpb   $0x0,0x3(%esp)
c0010e6c:	75 b6                	jne    c0010e24 <_ZN9Space_mem11insert_utcbER5Quotamm+0x10>

        ALWAYS_INLINE
        static inline void destroy (Mdb *obj, Quota &quota) { obj->~Mdb(); cache.free (obj, quota); }
c0010e6e:	89 f1                	mov    %esi,%ecx
c0010e70:	89 fa                	mov    %edi,%edx
c0010e72:	b8 80 b0 01 c0       	mov    $0xc001b080,%eax
c0010e77:	e8 e4 f4 ff ff       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
        return true;

    Mdb::destroy (mdb, quota);

    return false;
}
c0010e7c:	8a 44 24 03          	mov    0x3(%esp),%al
c0010e80:	5a                   	pop    %edx
c0010e81:	5b                   	pop    %ebx
c0010e82:	5e                   	pop    %esi
c0010e83:	5f                   	pop    %edi
c0010e84:	5d                   	pop    %ebp
c0010e85:	c3                   	ret    

c0010e86 <_ZN9Space_mem11remove_utcbEm>:

bool Space_mem::remove_utcb (mword b)
{
    if (!b)
c0010e86:	85 d2                	test   %edx,%edx
c0010e88:	0f 84 b0 00 00 00    	je     c0010f3e <_ZN9Space_mem11remove_utcbEm+0xb8>

    return false;
}

bool Space_mem::remove_utcb (mword b)
{
c0010e8e:	56                   	push   %esi
    if (!b)
        return false;

    Mdb *mdb = tree_lookup(b >> PAGE_BITS, false);
c0010e8f:	31 c9                	xor    %ecx,%ecx

    return false;
}

bool Space_mem::remove_utcb (mword b)
{
c0010e91:	53                   	push   %ebx
c0010e92:	83 ec 08             	sub    $0x8,%esp
    if (!b)
        return false;

    Mdb *mdb = tree_lookup(b >> PAGE_BITS, false);
c0010e95:	c1 ea 0c             	shr    $0xc,%edx
c0010e98:	e8 3d ac ff ff       	call   c000bada <_ZN5Space11tree_lookupEmb>
    if (!mdb)
c0010e9d:	85 c0                	test   %eax,%eax
bool Space_mem::remove_utcb (mword b)
{
    if (!b)
        return false;

    Mdb *mdb = tree_lookup(b >> PAGE_BITS, false);
c0010e9f:	89 c3                	mov    %eax,%ebx
    if (!mdb)
c0010ea1:	0f 84 8d 00 00 00    	je     c0010f34 <_ZN9Space_mem11remove_utcbEm+0xae>
        return false;

    mdb->demote_node(0x3);
c0010ea7:	ba 03 00 00 00       	mov    $0x3,%edx
c0010eac:	e8 53 53 ff ff       	call   c0006204 <_ZN3Mdb11demote_nodeEm>

    if (mdb->remove_node() && tree_remove(mdb)) {
c0010eb1:	89 d8                	mov    %ebx,%eax
c0010eb3:	e8 d2 53 ff ff       	call   c000628a <_ZN3Mdb11remove_nodeEv>
c0010eb8:	84 c0                	test   %al,%al
c0010eba:	74 78                	je     c0010f34 <_ZN9Space_mem11remove_utcbEm+0xae>
c0010ebc:	ba 01 00 00 00       	mov    $0x1,%edx
c0010ec1:	89 d8                	mov    %ebx,%eax
c0010ec3:	e8 53 ad ff ff       	call   c000bc1b <_ZN5Space11tree_removeEP3MdbN3Avl5StateE>
c0010ec8:	84 c0                	test   %al,%al
c0010eca:	88 c2                	mov    %al,%dl
c0010ecc:	74 66                	je     c0010f34 <_ZN9Space_mem11remove_utcbEm+0xae>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
c0010ece:	8b 4b 14             	mov    0x14(%ebx),%ecx
        Rcu::call (mdb);
c0010ed1:	8d 73 0c             	lea    0xc(%ebx),%esi
c0010ed4:	85 c9                	test   %ecx,%ecx
c0010ed6:	74 0c                	je     c0010ee4 <_ZN9Space_mem11remove_utcbEm+0x5e>
                e->pre_func(e);
c0010ed8:	89 f0                	mov    %esi,%eax
c0010eda:	88 54 24 03          	mov    %dl,0x3(%esp)
c0010ede:	ff d1                	call   *%ecx
c0010ee0:	8a 54 24 03          	mov    0x3(%esp),%dl
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
c0010ee4:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
c0010ee8:	75 09                	jne    c0010ef3 <_ZN9Space_mem11remove_utcbEm+0x6d>
c0010eea:	a1 f0 f7 ff cf       	mov    0xcffff7f0,%eax
c0010eef:	39 f0                	cmp    %esi,%eax
c0010ef1:	75 31                	jne    c0010f24 <_ZN9Space_mem11remove_utcbEm+0x9e>
                trace (0, "warning: rcu element already enqueued");
c0010ef3:	8d 44 24 03          	lea    0x3(%esp),%eax
c0010ef7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0010efc:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c0010f01:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0010f06:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0010f0d:	88 54 24 03          	mov    %dl,0x3(%esp)
c0010f11:	50                   	push   %eax
c0010f12:	68 ae 6c 01 c0       	push   $0xc0016cae
c0010f17:	e8 c2 0a ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c0010f1c:	5b                   	pop    %ebx
c0010f1d:	5e                   	pop    %esi
c0010f1e:	8a 54 24 03          	mov    0x3(%esp),%dl
c0010f22:	eb 12                	jmp    c0010f36 <_ZN9Space_mem11remove_utcbEm+0xb0>
                return;
            }

            count ++;
c0010f24:	ff 05 f4 f7 ff cf    	incl   0xcffff7f4

           *tail = e;
c0010f2a:	89 30                	mov    %esi,(%eax)
            tail = &e->next;
c0010f2c:	89 35 f0 f7 ff cf    	mov    %esi,0xcffff7f0
c0010f32:	eb 02                	jmp    c0010f36 <_ZN9Space_mem11remove_utcbEm+0xb0>
        return true;
    }

    return false;
c0010f34:	31 d2                	xor    %edx,%edx
}
c0010f36:	83 c4 08             	add    $0x8,%esp
c0010f39:	88 d0                	mov    %dl,%al
c0010f3b:	5b                   	pop    %ebx
c0010f3c:	5e                   	pop    %esi
c0010f3d:	c3                   	ret    
}

bool Space_mem::remove_utcb (mword b)
{
    if (!b)
        return false;
c0010f3e:	31 d2                	xor    %edx,%edx
        Rcu::call (mdb);
        return true;
    }

    return false;
}
c0010f40:	88 d0                	mov    %dl,%al
c0010f42:	c3                   	ret    
c0010f43:	90                   	nop

c0010f44 <_ZN9Space_obj4walkER5Quotam>:
{
    return static_cast<Pd *>(this);
}

Paddr Space_obj::walk (Quota &quota, mword idx)
{
c0010f44:	55                   	push   %ebp
{
    private:
        ALWAYS_INLINE
        static inline mword idx_to_virt (unsigned long idx)
        {
            return SPC_LOCAL_OBJ + (idx % caps) * sizeof (Capability);
c0010f45:	81 e1 ff ff ff 07    	and    $0x7ffffff,%ecx
c0010f4b:	57                   	push   %edi
c0010f4c:	89 d7                	mov    %edx,%edi
c0010f4e:	56                   	push   %esi
c0010f4f:	53                   	push   %ebx
c0010f50:	83 ec 0c             	sub    $0xc,%esp

        ALWAYS_INLINE
        inline size_t lookup (mword virt, Paddr &phys)
        {
            mword attr;
            return hpt.lookup (virt, phys, attr);
c0010f53:	8d 70 cc             	lea    -0x34(%eax),%esi
c0010f56:	8d 44 24 08          	lea    0x8(%esp),%eax
c0010f5a:	50                   	push   %eax
c0010f5b:	89 f0                	mov    %esi,%eax
c0010f5d:	8d 1c 8d 00 00 00 e0 	lea    -0x20000000(,%ecx,4),%ebx
c0010f64:	89 da                	mov    %ebx,%edx
c0010f66:	8d 4c 24 08          	lea    0x8(%esp),%ecx
c0010f6a:	e8 bd d0 ff ff       	call   c000e02c <_ZN3PteI3HptmLj2ELj10ELb0EE6lookupEmRmS2_>
    mword virt = idx_to_virt (idx); Paddr phys; void *ptr;

    if (!space_mem()->lookup (virt, phys) || (phys & ~PAGE_MASK) == reinterpret_cast<Paddr>(&FRAME_0)) {
c0010f6f:	5d                   	pop    %ebp
c0010f70:	85 c0                	test   %eax,%eax
c0010f72:	74 10                	je     c0010f84 <_ZN9Space_obj4walkER5Quotam+0x40>
c0010f74:	8b 44 24 04          	mov    0x4(%esp),%eax
c0010f78:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0010f7d:	3d 00 c0 41 00       	cmp    $0x41c000,%eax
c0010f82:	75 4d                	jne    c0010fd1 <_ZN9Space_obj4walkER5Quotam+0x8d>

        Paddr p = Buddy::ptr_to_phys (ptr = Buddy::allocator.alloc (0, quota, Buddy::FILL_0));
c0010f84:	6a 01                	push   $0x1
c0010f86:	31 d2                	xor    %edx,%edx
c0010f88:	89 f9                	mov    %edi,%ecx
c0010f8a:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c0010f8f:	e8 78 04 ff ff       	call   c000140c <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
        }

        ALWAYS_INLINE
        inline Paddr replace (Quota &quota, mword v, Paddr p)
        {
            return hpt.replace (quota, v, p);
c0010f94:	89 d9                	mov    %ebx,%ecx
c0010f96:	89 fa                	mov    %edi,%edx
c0010f98:	89 c5                	mov    %eax,%ebp
c0010f9a:	2d 00 00 c0 bf       	sub    $0xbfc00000,%eax
c0010f9f:	89 44 24 04          	mov    %eax,0x4(%esp)

        if ((phys = space_mem()->replace (quota, virt, p | Hpt::HPT_NX | Hpt::HPT_D | Hpt::HPT_A | Hpt::HPT_W | Hpt::HPT_P)) != p)
c0010fa3:	83 c8 63             	or     $0x63,%eax
c0010fa6:	50                   	push   %eax
c0010fa7:	89 f0                	mov    %esi,%eax
c0010fa9:	e8 ee 4b ff ff       	call   c0005b9c <_ZN3Hpt7replaceER5Quotamm>
c0010fae:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0010fb2:	5a                   	pop    %edx
c0010fb3:	59                   	pop    %ecx
c0010fb4:	3b 04 24             	cmp    (%esp),%eax
c0010fb7:	74 0e                	je     c0010fc7 <_ZN9Space_obj4walkER5Quotam+0x83>
            Buddy::allocator.free (reinterpret_cast<mword>(ptr), quota);
c0010fb9:	89 f9                	mov    %edi,%ecx
c0010fbb:	89 ea                	mov    %ebp,%edx
c0010fbd:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c0010fc2:	e8 a1 01 ff ff       	call   c0001168 <_ZN5Buddy4freeEmR5Quota>

        phys |= virt & PAGE_MASK;
c0010fc7:	81 e3 ff 0f 00 00    	and    $0xfff,%ebx
c0010fcd:	09 5c 24 04          	or     %ebx,0x4(%esp)
    }

    return phys;
c0010fd1:	8b 44 24 04          	mov    0x4(%esp),%eax
}
c0010fd5:	83 c4 0c             	add    $0xc,%esp
c0010fd8:	5b                   	pop    %ebx
c0010fd9:	5e                   	pop    %esi
c0010fda:	5f                   	pop    %edi
c0010fdb:	5d                   	pop    %ebp
c0010fdc:	c3                   	ret    
c0010fdd:	90                   	nop

c0010fde <_ZN9Space_obj6updateER5Quotam10Capability>:

void Space_obj::update (Quota &quota, mword idx, Capability cap)
{
    *static_cast<Capability *>(Buddy::phys_to_ptr (walk (quota, idx))) = cap;
c0010fde:	e8 61 ff ff ff       	call   c0010f44 <_ZN9Space_obj4walkER5Quotam>
c0010fe3:	8b 54 24 04          	mov    0x4(%esp),%edx
c0010fe7:	89 90 00 00 c0 bf    	mov    %edx,-0x40400000(%eax)
c0010fed:	c3                   	ret    

c0010fee <_ZN9Space_obj6updateER5QuotaP3Mdbm>:

    return 1;
}

bool Space_obj::update (Quota &quota, Mdb *mdb, mword r)
{
c0010fee:	55                   	push   %ebp
    assert (this == mdb->space && this != &Pd::kern);
c0010fef:	3d 48 b4 01 c0       	cmp    $0xc001b448,%eax

    return 1;
}

bool Space_obj::update (Quota &quota, Mdb *mdb, mword r)
{
c0010ff4:	57                   	push   %edi
c0010ff5:	89 c5                	mov    %eax,%ebp
c0010ff7:	56                   	push   %esi
c0010ff8:	53                   	push   %ebx
c0010ff9:	53                   	push   %ebx
    assert (this == mdb->space && this != &Pd::kern);
c0010ffa:	0f 84 a1 00 00 00    	je     c00110a1 <_ZN9Space_obj6updateER5QuotaP3Mdbm+0xb3>
c0011000:	3b 41 28             	cmp    0x28(%ecx),%eax
c0011003:	89 cf                	mov    %ecx,%edi
c0011005:	0f 85 96 00 00 00    	jne    c00110a1 <_ZN9Space_obj6updateER5QuotaP3Mdbm+0xb3>
    Lock_guard <Spinlock> guard (mdb->node_lock);
c001100b:	8d 41 18             	lea    0x18(%ecx),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c001100e:	9c                   	pushf  
c001100f:	5b                   	pop    %ebx
            return flags & 0x200;
c0011010:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c0011013:	80 e3 01             	and    $0x1,%bl
c0011016:	74 27                	je     c001103f <_ZN9Space_obj6updateER5QuotaP3Mdbm+0x51>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0011018:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c001101f:	75 16                	jne    c0011037 <_ZN9Space_obj6updateER5QuotaP3Mdbm+0x49>
c0011021:	68 80 95 01 c0       	push   $0xc0019580
c0011026:	68 b7 00 00 00       	push   $0xb7
c001102b:	68 12 61 01 c0       	push   $0xc0016112
c0011030:	68 83 61 01 c0       	push   $0xc0016183
c0011035:	eb 56                	jmp    c001108d <_ZN9Space_obj6updateER5QuotaP3Mdbm+0x9f>

            asm volatile ("cli" : : : "memory");
c0011037:	fa                   	cli    
            preemption = false;
c0011038:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
c001103f:	89 14 24             	mov    %edx,(%esp)
                Cpu::preempt_disable();

            _lock.lock();
c0011042:	e8 e5 fa fe ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    update (quota, mdb->node_base, Capability (reinterpret_cast<Kobject *>(mdb->node_phys), mdb->node_attr & ~r));
c0011047:	8b 74 24 18          	mov    0x18(%esp),%esi
c001104b:	8b 47 2c             	mov    0x2c(%edi),%eax
        static mword const perm = 0x1f;

    public:
        Capability() : val (0) {}

        Capability (Kobject *o, mword a) : val (a ? reinterpret_cast<mword>(o) | (a & perm) : 0) {}
c001104e:	8b 14 24             	mov    (%esp),%edx
c0011051:	f7 d6                	not    %esi
c0011053:	23 77 38             	and    0x38(%edi),%esi
c0011056:	74 05                	je     c001105d <_ZN9Space_obj6updateER5QuotaP3Mdbm+0x6f>
c0011058:	83 e6 1f             	and    $0x1f,%esi
c001105b:	09 c6                	or     %eax,%esi
c001105d:	8b 4f 30             	mov    0x30(%edi),%ecx
c0011060:	89 e8                	mov    %ebp,%eax
c0011062:	56                   	push   %esi
c0011063:	e8 76 ff ff ff       	call   c0010fde <_ZN9Space_obj6updateER5Quotam10Capability>
c0011068:	fe 47 18             	incb   0x18(%edi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c001106b:	84 db                	test   %bl,%bl
c001106d:	59                   	pop    %ecx
c001106e:	74 44                	je     c00110b4 <_ZN9Space_obj6updateER5QuotaP3Mdbm+0xc6>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0011070:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0011077:	74 1e                	je     c0011097 <_ZN9Space_obj6updateER5QuotaP3Mdbm+0xa9>
c0011079:	68 40 95 01 c0       	push   $0xc0019540
c001107e:	68 c0 00 00 00       	push   $0xc0
c0011083:	68 12 61 01 c0       	push   $0xc0016112
c0011088:	68 82 61 01 c0       	push   $0xc0016182
c001108d:	68 69 60 01 c0       	push   $0xc0016069
c0011092:	e8 af 08 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

            preemption = true;
c0011097:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c001109e:	fb                   	sti    
c001109f:	eb 13                	jmp    c00110b4 <_ZN9Space_obj6updateER5QuotaP3Mdbm+0xc6>
    return 1;
}

bool Space_obj::update (Quota &quota, Mdb *mdb, mword r)
{
    assert (this == mdb->space && this != &Pd::kern);
c00110a1:	68 c0 95 01 c0       	push   $0xc00195c0
c00110a6:	6a 3f                	push   $0x3f
c00110a8:	68 72 94 01 c0       	push   $0xc0019472
c00110ad:	68 95 93 01 c0       	push   $0xc0019395
c00110b2:	eb d9                	jmp    c001108d <_ZN9Space_obj6updateER5QuotaP3Mdbm+0x9f>
    Lock_guard <Spinlock> guard (mdb->node_lock);
    update (quota, mdb->node_base, Capability (reinterpret_cast<Kobject *>(mdb->node_phys), mdb->node_attr & ~r));

    return false;
}
c00110b4:	5a                   	pop    %edx
c00110b5:	31 c0                	xor    %eax,%eax
c00110b7:	5b                   	pop    %ebx
c00110b8:	5e                   	pop    %esi
c00110b9:	5f                   	pop    %edi
c00110ba:	5d                   	pop    %ebp
c00110bb:	c3                   	ret    

c00110bc <_ZN9Space_obj11insert_rootER5QuotaP7Kobject>:

bool Space_obj::insert_root (Quota &quota, Kobject *obj)
{
c00110bc:	57                   	push   %edi
c00110bd:	89 c7                	mov    %eax,%edi
c00110bf:	56                   	push   %esi
    if (!obj->space->tree_insert (obj))
c00110c0:	89 d0                	mov    %edx,%eax

    return false;
}

bool Space_obj::insert_root (Quota &quota, Kobject *obj)
{
c00110c2:	53                   	push   %ebx
c00110c3:	89 d6                	mov    %edx,%esi
c00110c5:	53                   	push   %ebx
    if (!obj->space->tree_insert (obj))
c00110c6:	e8 c8 aa ff ff       	call   c000bb93 <_ZN5Space11tree_insertEP3Mdb>
c00110cb:	84 c0                	test   %al,%al
c00110cd:	88 44 24 03          	mov    %al,0x3(%esp)
c00110d1:	74 22                	je     c00110f5 <_ZN9Space_obj11insert_rootER5QuotaP7Kobject+0x39>
        return false;

    if (obj->space != static_cast<Space_obj *>(&Pd::kern))
c00110d3:	8b 46 28             	mov    0x28(%esi),%eax
c00110d6:	3d 48 b4 01 c0       	cmp    $0xc001b448,%eax
c00110db:	74 18                	je     c00110f5 <_ZN9Space_obj11insert_rootER5QuotaP7Kobject+0x39>
        static_cast<Space_obj *>(obj->space)->update (quota, obj->node_base, Capability (obj, obj->node_attr));
c00110dd:	8b 5e 38             	mov    0x38(%esi),%ebx
c00110e0:	85 db                	test   %ebx,%ebx
c00110e2:	74 05                	je     c00110e9 <_ZN9Space_obj11insert_rootER5QuotaP7Kobject+0x2d>
c00110e4:	83 e3 1f             	and    $0x1f,%ebx
c00110e7:	09 f3                	or     %esi,%ebx
c00110e9:	8b 4e 30             	mov    0x30(%esi),%ecx
c00110ec:	89 fa                	mov    %edi,%edx
c00110ee:	53                   	push   %ebx
c00110ef:	e8 ea fe ff ff       	call   c0010fde <_ZN9Space_obj6updateER5Quotam10Capability>
c00110f4:	59                   	pop    %ecx

    return true;
}
c00110f5:	8a 44 24 03          	mov    0x3(%esp),%al
c00110f9:	5a                   	pop    %edx
c00110fa:	5b                   	pop    %ebx
c00110fb:	5e                   	pop    %esi
c00110fc:	5f                   	pop    %edi
c00110fd:	c3                   	ret    

c00110fe <_ZN9Space_obj10page_faultEmm>:

void Space_obj::page_fault (mword addr, mword error)
{
c00110fe:	56                   	push   %esi
    assert (!(error & Hpt::ERR_W));
c00110ff:	f6 c2 02             	test   $0x2,%dl

    return true;
}

void Space_obj::page_fault (mword addr, mword error)
{
c0011102:	53                   	push   %ebx
    assert (!(error & Hpt::ERR_W));
c0011103:	74 1b                	je     c0011120 <_ZN9Space_obj10page_faultEmm+0x22>
c0011105:	68 00 95 01 c0       	push   $0xc0019500
c001110a:	6a 53                	push   $0x53
c001110c:	68 72 94 01 c0       	push   $0xc0019472
c0011111:	68 e4 94 01 c0       	push   $0xc00194e4
c0011116:	68 69 60 01 c0       	push   $0xc0016069
c001111b:	e8 26 08 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>
c0011120:	89 c6                	mov    %eax,%esi

    if (!Pd::current->Space_mem::loc[Cpu::id].sync_from (Pd::current->quota, Pd::current->Space_mem::hpt, addr, CPU_LOCAL))
c0011122:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c0011127:	8b 1d 04 f0 ff cf    	mov    0xcffff004,%ebx
c001112d:	8b 88 54 01 00 00    	mov    0x154(%eax),%ecx
c0011133:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx
c0011139:	68 00 00 c0 cf       	push   $0xcfc00000
c001113e:	56                   	push   %esi
c001113f:	8d 44 98 54          	lea    0x54(%eax,%ebx,4),%eax
c0011143:	e8 7a 49 ff ff       	call   c0005ac2 <_ZN3Hpt9sync_fromER5QuotaS_mm>
c0011148:	5a                   	pop    %edx
c0011149:	59                   	pop    %ecx
c001114a:	84 c0                	test   %al,%al
c001114c:	75 23                	jne    c0011171 <_ZN9Space_obj10page_faultEmm+0x73>
        Pd::current->Space_mem::replace (Pd::current->quota, addr, reinterpret_cast<Paddr>(&FRAME_0) | Hpt::HPT_NX | Hpt::HPT_A | Hpt::HPT_P);
c001114e:	8b 1d 0c f0 ff cf    	mov    0xcffff00c,%ebx
c0011154:	89 f1                	mov    %esi,%ecx
c0011156:	8d 93 90 01 00 00    	lea    0x190(%ebx),%edx
c001115c:	8d 83 54 01 00 00    	lea    0x154(%ebx),%eax
c0011162:	bb 00 c0 41 00       	mov    $0x41c000,%ebx
c0011167:	83 cb 21             	or     $0x21,%ebx
c001116a:	53                   	push   %ebx
c001116b:	e8 2c 4a ff ff       	call   c0005b9c <_ZN3Hpt7replaceER5Quotamm>
c0011170:	58                   	pop    %eax
}
c0011171:	5b                   	pop    %ebx
c0011172:	5e                   	pop    %esi
c0011173:	c3                   	ret    

c0011174 <_ZN9Space_pio4walkER5Quotabm>:
{
    return static_cast<Pd *>(this);
}

Paddr Space_pio::walk (Quota &quota, bool host, mword idx)
{
c0011174:	57                   	push   %edi
    Paddr &bmp = host ? hbmp : gbmp;
c0011175:	84 c9                	test   %cl,%cl
{
    return static_cast<Pd *>(this);
}

Paddr Space_pio::walk (Quota &quota, bool host, mword idx)
{
c0011177:	56                   	push   %esi
c0011178:	89 d7                	mov    %edx,%edi
c001117a:	53                   	push   %ebx
c001117b:	89 c3                	mov    %eax,%ebx
    Paddr &bmp = host ? hbmp : gbmp;
c001117d:	74 41                	je     c00111c0 <_ZN9Space_pio4walkER5Quotabm+0x4c>

    if (!bmp) {
c001117f:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
    return static_cast<Pd *>(this);
}

Paddr Space_pio::walk (Quota &quota, bool host, mword idx)
{
    Paddr &bmp = host ? hbmp : gbmp;
c0011183:	8d 70 08             	lea    0x8(%eax),%esi

    if (!bmp) {
c0011186:	75 5d                	jne    c00111e5 <_ZN9Space_pio4walkER5Quotabm+0x71>
        bmp = Buddy::ptr_to_phys (Buddy::allocator.alloc (1, quota, Buddy::FILL_1));
c0011188:	6a 02                	push   $0x2
c001118a:	89 d1                	mov    %edx,%ecx
c001118c:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c0011191:	ba 01 00 00 00       	mov    $0x1,%edx
c0011196:	e8 71 02 ff ff       	call   c000140c <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
        }

        ALWAYS_INLINE
        inline void insert (Quota &quota, mword virt, unsigned o, mword attr, Paddr phys)
        {
            hpt.update (quota, virt, o, phys, attr);
c001119b:	b9 00 00 00 d0       	mov    $0xd0000000,%ecx
c00111a0:	6a 00                	push   $0x0
c00111a2:	6a 63                	push   $0x63
c00111a4:	2d 00 00 c0 bf       	sub    $0xbfc00000,%eax
c00111a9:	89 c2                	mov    %eax,%edx
c00111ab:	52                   	push   %edx
c00111ac:	89 fa                	mov    %edi,%edx
c00111ae:	6a 01                	push   $0x1
c00111b0:	89 43 08             	mov    %eax,0x8(%ebx)
c00111b3:	8d 43 dc             	lea    -0x24(%ebx),%eax
c00111b6:	e8 05 cf ff ff       	call   c000e0c0 <_ZN3PteI3HptmLj2ELj10ELb0EE6updateER5QuotammmmNS1_4TypeE>
c00111bb:	83 c4 14             	add    $0x14,%esp
c00111be:	eb 25                	jmp    c00111e5 <_ZN9Space_pio4walkER5Quotabm+0x71>

Paddr Space_pio::walk (Quota &quota, bool host, mword idx)
{
    Paddr &bmp = host ? hbmp : gbmp;

    if (!bmp) {
c00111c0:	83 78 0c 00          	cmpl   $0x0,0xc(%eax)
    return static_cast<Pd *>(this);
}

Paddr Space_pio::walk (Quota &quota, bool host, mword idx)
{
    Paddr &bmp = host ? hbmp : gbmp;
c00111c4:	8d 70 0c             	lea    0xc(%eax),%esi

    if (!bmp) {
c00111c7:	75 1c                	jne    c00111e5 <_ZN9Space_pio4walkER5Quotabm+0x71>
        bmp = Buddy::ptr_to_phys (Buddy::allocator.alloc (1, quota, Buddy::FILL_1));
c00111c9:	6a 02                	push   $0x2
c00111cb:	89 d1                	mov    %edx,%ecx
c00111cd:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c00111d2:	ba 01 00 00 00       	mov    $0x1,%edx
c00111d7:	e8 30 02 ff ff       	call   c000140c <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
c00111dc:	2d 00 00 c0 bf       	sub    $0xbfc00000,%eax
c00111e1:	89 43 0c             	mov    %eax,0xc(%ebx)
c00111e4:	58                   	pop    %eax
        Paddr hbmp, gbmp;

        ALWAYS_INLINE
        static inline mword idx_to_virt (mword idx)
        {
            return SPC_LOCAL_IOP + (idx / 8 / sizeof (mword)) * sizeof (mword);
c00111e5:	8b 44 24 10          	mov    0x10(%esp),%eax
        if (host)
            space_mem()->insert (quota, SPC_LOCAL_IOP, 1, Hpt::HPT_NX | Hpt::HPT_D | Hpt::HPT_A | Hpt::HPT_W | Hpt::HPT_P, bmp);
    }

    return bmp | (idx_to_virt (idx) & (2 * PAGE_SIZE - 1));
}
c00111e9:	5b                   	pop    %ebx
c00111ea:	c1 e8 03             	shr    $0x3,%eax

        if (host)
            space_mem()->insert (quota, SPC_LOCAL_IOP, 1, Hpt::HPT_NX | Hpt::HPT_D | Hpt::HPT_A | Hpt::HPT_W | Hpt::HPT_P, bmp);
    }

    return bmp | (idx_to_virt (idx) & (2 * PAGE_SIZE - 1));
c00111ed:	25 fc 1f 00 00       	and    $0x1ffc,%eax
c00111f2:	0b 06                	or     (%esi),%eax
}
c00111f4:	5e                   	pop    %esi
c00111f5:	5f                   	pop    %edi
c00111f6:	c3                   	ret    
c00111f7:	90                   	nop

c00111f8 <_ZN9Space_pio6updateER5Quotabmm>:

void Space_pio::update (Quota &quota, bool host, mword idx, mword attr)
{
c00111f8:	53                   	push   %ebx
c00111f9:	0f b6 c9             	movzbl %cl,%ecx
    mword *m = static_cast<mword *>(Buddy::phys_to_ptr (walk (quota, host, idx)));
c00111fc:	ff 74 24 08          	pushl  0x8(%esp)
c0011200:	e8 6f ff ff ff       	call   c0011174 <_ZN9Space_pio4walkER5Quotabm>

    if (attr)
c0011205:	5a                   	pop    %edx
        }

        ALWAYS_INLINE
        static inline mword idx_to_mask (mword idx)
        {
            return 1UL << (idx % (8 * sizeof (mword)));
c0011206:	ba 01 00 00 00       	mov    $0x1,%edx
c001120b:	8b 4c 24 08          	mov    0x8(%esp),%ecx
        }

        ALWAYS_INLINE
        inline mword phys_to_virt (mword phys)
        {
            return phys + reinterpret_cast<mword>(&OFFSET);
c001120f:	05 00 00 c0 bf       	add    $0xbfc00000,%eax
c0011214:	d3 e2                	shl    %cl,%edx
c0011216:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c001121b:	74 07                	je     c0011224 <_ZN9Space_pio6updateER5Quotabmm+0x2c>

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
c001121d:	f7 d2                	not    %edx
c001121f:	f0 21 10             	lock and %edx,(%eax)
c0011222:	eb 03                	jmp    c0011227 <_ZN9Space_pio6updateER5Quotabmm+0x2f>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }
c0011224:	f0 09 10             	lock or %edx,(%eax)
        Atomic::clr_mask (*m, idx_to_mask (idx));
    else
        Atomic::set_mask (*m, idx_to_mask (idx));
}
c0011227:	5b                   	pop    %ebx
c0011228:	c3                   	ret    
c0011229:	90                   	nop

c001122a <_ZN9Space_pio6updateER5QuotaP3Mdbm>:

bool Space_pio::update (Quota &quota, Mdb *mdb, mword r)
{
c001122a:	55                   	push   %ebp
c001122b:	57                   	push   %edi
c001122c:	56                   	push   %esi
c001122d:	89 c6                	mov    %eax,%esi
c001122f:	53                   	push   %ebx
c0011230:	83 ec 08             	sub    $0x8,%esp
    assert (this == mdb->space && this != &Pd::kern);
c0011233:	3d 38 b4 01 c0       	cmp    $0xc001b438,%eax
    else
        Atomic::set_mask (*m, idx_to_mask (idx));
}

bool Space_pio::update (Quota &quota, Mdb *mdb, mword r)
{
c0011238:	89 14 24             	mov    %edx,(%esp)
    assert (this == mdb->space && this != &Pd::kern);
c001123b:	0f 84 f3 00 00 00    	je     c0011334 <_ZN9Space_pio6updateER5QuotaP3Mdbm+0x10a>
c0011241:	3b 41 28             	cmp    0x28(%ecx),%eax
c0011244:	89 cb                	mov    %ecx,%ebx
c0011246:	0f 85 e8 00 00 00    	jne    c0011334 <_ZN9Space_pio6updateER5QuotaP3Mdbm+0x10a>

    Lock_guard <Spinlock> guard (mdb->node_lock);
c001124c:	8d 41 18             	lea    0x18(%ecx),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c001124f:	9c                   	pushf  
c0011250:	5a                   	pop    %edx
            return flags & 0x200;
c0011251:	c1 ea 09             	shr    $0x9,%edx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c0011254:	80 e2 01             	and    $0x1,%dl
c0011257:	88 54 24 07          	mov    %dl,0x7(%esp)
c001125b:	74 2a                	je     c0011287 <_ZN9Space_pio6updateER5QuotaP3Mdbm+0x5d>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c001125d:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0011264:	75 19                	jne    c001127f <_ZN9Space_pio6updateER5QuotaP3Mdbm+0x55>
c0011266:	68 e0 96 01 c0       	push   $0xc00196e0
c001126b:	68 b7 00 00 00       	push   $0xb7
c0011270:	68 12 61 01 c0       	push   $0xc0016112
c0011275:	68 83 61 01 c0       	push   $0xc0016183
c001127a:	e9 a1 00 00 00       	jmp    c0011320 <_ZN9Space_pio6updateER5QuotaP3Mdbm+0xf6>

            asm volatile ("cli" : : : "memory");
c001127f:	fa                   	cli    
            preemption = false;
c0011280:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c0011287:	e8 a0 f8 fe ff       	call   c0000b2c <_ZN8Spinlock4lockEv>

    if (mdb->node_sub & 2)
c001128c:	f6 43 40 02          	testb  $0x2,0x40(%ebx)
c0011290:	75 0a                	jne    c001129c <_ZN9Space_pio6updateER5QuotaP3Mdbm+0x72>
        for (unsigned long i = 0; i < (1UL << mdb->node_order); i++)
            update (quota, false, mdb->node_base + i, mdb->node_attr & ~r);

    for (unsigned long i = 0; i < (1UL << mdb->node_order); i++)
        update (quota, true, mdb->node_base + i, mdb->node_attr & ~r);
c0011292:	8b 6c 24 1c          	mov    0x1c(%esp),%ebp
c0011296:	31 ff                	xor    %edi,%edi
c0011298:	f7 d5                	not    %ebp
c001129a:	eb 31                	jmp    c00112cd <_ZN9Space_pio6updateER5QuotaP3Mdbm+0xa3>

    Lock_guard <Spinlock> guard (mdb->node_lock);

    if (mdb->node_sub & 2)
        for (unsigned long i = 0; i < (1UL << mdb->node_order); i++)
            update (quota, false, mdb->node_base + i, mdb->node_attr & ~r);
c001129c:	8b 6c 24 1c          	mov    0x1c(%esp),%ebp
c00112a0:	31 ff                	xor    %edi,%edi
c00112a2:	f7 d5                	not    %ebp
    assert (this == mdb->space && this != &Pd::kern);

    Lock_guard <Spinlock> guard (mdb->node_lock);

    if (mdb->node_sub & 2)
        for (unsigned long i = 0; i < (1UL << mdb->node_order); i++)
c00112a4:	8b 4b 34             	mov    0x34(%ebx),%ecx
c00112a7:	89 f8                	mov    %edi,%eax
c00112a9:	d3 e8                	shr    %cl,%eax
c00112ab:	85 c0                	test   %eax,%eax
c00112ad:	75 e3                	jne    c0011292 <_ZN9Space_pio6updateER5QuotaP3Mdbm+0x68>
            update (quota, false, mdb->node_base + i, mdb->node_attr & ~r);
c00112af:	8b 43 38             	mov    0x38(%ebx),%eax
c00112b2:	31 c9                	xor    %ecx,%ecx
c00112b4:	21 e8                	and    %ebp,%eax
c00112b6:	50                   	push   %eax
c00112b7:	8b 43 30             	mov    0x30(%ebx),%eax
c00112ba:	01 f8                	add    %edi,%eax
    assert (this == mdb->space && this != &Pd::kern);

    Lock_guard <Spinlock> guard (mdb->node_lock);

    if (mdb->node_sub & 2)
        for (unsigned long i = 0; i < (1UL << mdb->node_order); i++)
c00112bc:	47                   	inc    %edi
            update (quota, false, mdb->node_base + i, mdb->node_attr & ~r);
c00112bd:	50                   	push   %eax
c00112be:	89 f0                	mov    %esi,%eax
c00112c0:	8b 54 24 08          	mov    0x8(%esp),%edx
c00112c4:	e8 2f ff ff ff       	call   c00111f8 <_ZN9Space_pio6updateER5Quotabmm>
    assert (this == mdb->space && this != &Pd::kern);

    Lock_guard <Spinlock> guard (mdb->node_lock);

    if (mdb->node_sub & 2)
        for (unsigned long i = 0; i < (1UL << mdb->node_order); i++)
c00112c9:	59                   	pop    %ecx
c00112ca:	58                   	pop    %eax
c00112cb:	eb d7                	jmp    c00112a4 <_ZN9Space_pio6updateER5QuotaP3Mdbm+0x7a>
            update (quota, false, mdb->node_base + i, mdb->node_attr & ~r);

    for (unsigned long i = 0; i < (1UL << mdb->node_order); i++)
c00112cd:	8b 4b 34             	mov    0x34(%ebx),%ecx
c00112d0:	89 f8                	mov    %edi,%eax
c00112d2:	d3 e8                	shr    %cl,%eax
c00112d4:	85 c0                	test   %eax,%eax
c00112d6:	75 21                	jne    c00112f9 <_ZN9Space_pio6updateER5QuotaP3Mdbm+0xcf>
        update (quota, true, mdb->node_base + i, mdb->node_attr & ~r);
c00112d8:	8b 43 38             	mov    0x38(%ebx),%eax
c00112db:	b9 01 00 00 00       	mov    $0x1,%ecx
c00112e0:	21 e8                	and    %ebp,%eax
c00112e2:	50                   	push   %eax
c00112e3:	8b 43 30             	mov    0x30(%ebx),%eax
c00112e6:	01 f8                	add    %edi,%eax

    if (mdb->node_sub & 2)
        for (unsigned long i = 0; i < (1UL << mdb->node_order); i++)
            update (quota, false, mdb->node_base + i, mdb->node_attr & ~r);

    for (unsigned long i = 0; i < (1UL << mdb->node_order); i++)
c00112e8:	47                   	inc    %edi
        update (quota, true, mdb->node_base + i, mdb->node_attr & ~r);
c00112e9:	50                   	push   %eax
c00112ea:	89 f0                	mov    %esi,%eax
c00112ec:	8b 54 24 08          	mov    0x8(%esp),%edx
c00112f0:	e8 03 ff ff ff       	call   c00111f8 <_ZN9Space_pio6updateER5Quotabmm>

    if (mdb->node_sub & 2)
        for (unsigned long i = 0; i < (1UL << mdb->node_order); i++)
            update (quota, false, mdb->node_base + i, mdb->node_attr & ~r);

    for (unsigned long i = 0; i < (1UL << mdb->node_order); i++)
c00112f5:	58                   	pop    %eax
c00112f6:	5a                   	pop    %edx
c00112f7:	eb d4                	jmp    c00112cd <_ZN9Space_pio6updateER5QuotaP3Mdbm+0xa3>
c00112f9:	fe 43 18             	incb   0x18(%ebx)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c00112fc:	80 7c 24 07 00       	cmpb   $0x0,0x7(%esp)
c0011301:	74 44                	je     c0011347 <_ZN9Space_pio6updateER5QuotaP3Mdbm+0x11d>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0011303:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c001130a:	74 1e                	je     c001132a <_ZN9Space_pio6updateER5QuotaP3Mdbm+0x100>
c001130c:	68 a0 96 01 c0       	push   $0xc00196a0
c0011311:	68 c0 00 00 00       	push   $0xc0
c0011316:	68 12 61 01 c0       	push   $0xc0016112
c001131b:	68 82 61 01 c0       	push   $0xc0016182
c0011320:	68 69 60 01 c0       	push   $0xc0016069
c0011325:	e8 1c 06 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

            preemption = true;
c001132a:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c0011331:	fb                   	sti    
c0011332:	eb 13                	jmp    c0011347 <_ZN9Space_pio6updateER5QuotaP3Mdbm+0x11d>
        Atomic::set_mask (*m, idx_to_mask (idx));
}

bool Space_pio::update (Quota &quota, Mdb *mdb, mword r)
{
    assert (this == mdb->space && this != &Pd::kern);
c0011334:	68 20 97 01 c0       	push   $0xc0019720
c0011339:	6a 36                	push   $0x36
c001133b:	68 ec 95 01 c0       	push   $0xc00195ec
c0011340:	68 95 93 01 c0       	push   $0xc0019395
c0011345:	eb d9                	jmp    c0011320 <_ZN9Space_pio6updateER5QuotaP3Mdbm+0xf6>

    for (unsigned long i = 0; i < (1UL << mdb->node_order); i++)
        update (quota, true, mdb->node_base + i, mdb->node_attr & ~r);

    return false;
}
c0011347:	83 c4 08             	add    $0x8,%esp
c001134a:	31 c0                	xor    %eax,%eax
c001134c:	5b                   	pop    %ebx
c001134d:	5e                   	pop    %esi
c001134e:	5f                   	pop    %edi
c001134f:	5d                   	pop    %ebp
c0011350:	c3                   	ret    
c0011351:	90                   	nop

c0011352 <_ZN9Space_pio10page_faultEmm>:

void Space_pio::page_fault (mword addr, mword error)
{
c0011352:	56                   	push   %esi
    assert (!(error & Hpt::ERR_W));
c0011353:	f6 c2 02             	test   $0x2,%dl

    return false;
}

void Space_pio::page_fault (mword addr, mword error)
{
c0011356:	53                   	push   %ebx
    assert (!(error & Hpt::ERR_W));
c0011357:	74 1b                	je     c0011374 <_ZN9Space_pio10page_faultEmm+0x22>
c0011359:	68 60 96 01 c0       	push   $0xc0019660
c001135e:	6a 46                	push   $0x46
c0011360:	68 ec 95 01 c0       	push   $0xc00195ec
c0011365:	68 e4 94 01 c0       	push   $0xc00194e4
c001136a:	68 69 60 01 c0       	push   $0xc0016069
c001136f:	e8 d2 05 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>
c0011374:	89 c6                	mov    %eax,%esi

    if (!Pd::current->Space_mem::loc[Cpu::id].sync_from (Pd::current->quota, Pd::current->Space_mem::hpt, addr, CPU_LOCAL))
c0011376:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c001137b:	8b 1d 04 f0 ff cf    	mov    0xcffff004,%ebx
c0011381:	8b 88 54 01 00 00    	mov    0x154(%eax),%ecx
c0011387:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx
c001138d:	68 00 00 c0 cf       	push   $0xcfc00000
c0011392:	56                   	push   %esi
c0011393:	8d 44 98 54          	lea    0x54(%eax,%ebx,4),%eax
c0011397:	e8 26 47 ff ff       	call   c0005ac2 <_ZN3Hpt9sync_fromER5QuotaS_mm>
c001139c:	5a                   	pop    %edx
c001139d:	59                   	pop    %ecx
c001139e:	84 c0                	test   %al,%al
c00113a0:	75 23                	jne    c00113c5 <_ZN9Space_pio10page_faultEmm+0x73>
        Pd::current->Space_mem::replace (Pd::current->quota, addr, reinterpret_cast<Paddr>(&FRAME_1) | Hpt::HPT_NX | Hpt::HPT_A | Hpt::HPT_P);
c00113a2:	8b 1d 0c f0 ff cf    	mov    0xcffff00c,%ebx
        }

        ALWAYS_INLINE
        inline Paddr replace (Quota &quota, mword v, Paddr p)
        {
            return hpt.replace (quota, v, p);
c00113a8:	89 f1                	mov    %esi,%ecx
c00113aa:	8d 93 90 01 00 00    	lea    0x190(%ebx),%edx
c00113b0:	8d 83 54 01 00 00    	lea    0x154(%ebx),%eax
c00113b6:	bb 00 d0 41 00       	mov    $0x41d000,%ebx
c00113bb:	83 cb 21             	or     $0x21,%ebx
c00113be:	53                   	push   %ebx
c00113bf:	e8 d8 47 ff ff       	call   c0005b9c <_ZN3Hpt7replaceER5Quotamm>
c00113c4:	58                   	pop    %eax
}
c00113c5:	5b                   	pop    %ebx
c00113c6:	5e                   	pop    %esi
c00113c7:	c3                   	ret    

.text

1:                      mov     %REG(ax), %cr3
c00113c8:	0f 22 d8             	mov    %eax,%cr3
                        mov     $(CPU_LOCAL_STCK + PAGE_SIZE), %REG(sp)
c00113cb:	bc 00 e0 ff cf       	mov    $0xcfffe000,%esp
                        jmp     bootstrap
c00113d0:	e9 11 fb fe ff       	jmp    c0000ee6 <bootstrap>
c00113d5:	90                   	nop

c00113d6 <_ZN4VmcbC1ER5Quotamm>:
Paddr       Vmcb::root;
unsigned    Vmcb::asid_ctr;
uint32      Vmcb::svm_version;
uint32      Vmcb::svm_feature;

Vmcb::Vmcb (Quota &quota, mword bmp, mword nptp) : base_io (bmp), asid (++asid_ctr), int_control (1ul << 24), npt_cr3 (nptp), efer (Cpu::EFER_SVME), g_pat (0x7040600070406ull)
c00113d6:	53                   	push   %ebx
c00113d7:	89 c3                	mov    %eax,%ebx
c00113d9:	89 48 40             	mov    %ecx,0x40(%eax)
{
    base_msr = Buddy::ptr_to_phys (Buddy::allocator.alloc (1, quota, Buddy::FILL_1));
c00113dc:	89 d1                	mov    %edx,%ecx
c00113de:	ba 01 00 00 00       	mov    $0x1,%edx
Paddr       Vmcb::root;
unsigned    Vmcb::asid_ctr;
uint32      Vmcb::svm_version;
uint32      Vmcb::svm_feature;

Vmcb::Vmcb (Quota &quota, mword bmp, mword nptp) : base_io (bmp), asid (++asid_ctr), int_control (1ul << 24), npt_cr3 (nptp), efer (Cpu::EFER_SVME), g_pat (0x7040600070406ull)
c00113e3:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
c00113ea:	a1 38 fa ff cf       	mov    0xcffffa38,%eax
c00113ef:	c7 43 60 00 00 00 01 	movl   $0x1000000,0x60(%ebx)
c00113f6:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
c00113fd:	c7 83 b4 00 00 00 00 	movl   $0x0,0xb4(%ebx)
c0011404:	00 00 00 
c0011407:	40                   	inc    %eax
c0011408:	89 43 58             	mov    %eax,0x58(%ebx)
c001140b:	a3 38 fa ff cf       	mov    %eax,0xcffffa38
c0011410:	8b 44 24 08          	mov    0x8(%esp),%eax
c0011414:	c7 83 d0 04 00 00 00 	movl   $0x1000,0x4d0(%ebx)
c001141b:	10 00 00 
{
    base_msr = Buddy::ptr_to_phys (Buddy::allocator.alloc (1, quota, Buddy::FILL_1));
c001141e:	6a 02                	push   $0x2
Paddr       Vmcb::root;
unsigned    Vmcb::asid_ctr;
uint32      Vmcb::svm_version;
uint32      Vmcb::svm_feature;

Vmcb::Vmcb (Quota &quota, mword bmp, mword nptp) : base_io (bmp), asid (++asid_ctr), int_control (1ul << 24), npt_cr3 (nptp), efer (Cpu::EFER_SVME), g_pat (0x7040600070406ull)
c0011420:	89 83 b0 00 00 00    	mov    %eax,0xb0(%ebx)
{
    base_msr = Buddy::ptr_to_phys (Buddy::allocator.alloc (1, quota, Buddy::FILL_1));
c0011426:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
Paddr       Vmcb::root;
unsigned    Vmcb::asid_ctr;
uint32      Vmcb::svm_version;
uint32      Vmcb::svm_feature;

Vmcb::Vmcb (Quota &quota, mword bmp, mword nptp) : base_io (bmp), asid (++asid_ctr), int_control (1ul << 24), npt_cr3 (nptp), efer (Cpu::EFER_SVME), g_pat (0x7040600070406ull)
c001142b:	c7 83 d4 04 00 00 00 	movl   $0x0,0x4d4(%ebx)
c0011432:	00 00 00 
c0011435:	c7 83 68 06 00 00 06 	movl   $0x70406,0x668(%ebx)
c001143c:	04 07 00 
c001143f:	c7 83 6c 06 00 00 06 	movl   $0x70406,0x66c(%ebx)
c0011446:	04 07 00 
{
    base_msr = Buddy::ptr_to_phys (Buddy::allocator.alloc (1, quota, Buddy::FILL_1));
c0011449:	e8 be ff fe ff       	call   c000140c <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
c001144e:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
        }

        ALWAYS_INLINE
        inline mword virt_to_phys (mword virt)
        {
            return virt - reinterpret_cast<mword>(&OFFSET);
c0011455:	2d 00 00 c0 bf       	sub    $0xbfc00000,%eax
c001145a:	89 43 48             	mov    %eax,0x48(%ebx)
c001145d:	58                   	pop    %eax
}
c001145e:	5b                   	pop    %ebx
c001145f:	c3                   	ret    

c0011460 <_ZN4Vmcb4initEv>:

void Vmcb::init()
{
    if (!Cpu::feature (Cpu::FEAT_SVM)) {
c0011460:	f6 05 18 f7 ff cf 04 	testb  $0x4,0xcffff718
c0011467:	75 09                	jne    c0011472 <_ZN4Vmcb4initEv+0x12>

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
c0011469:	f0 83 25 10 e0 01 c0 	lock andl $0xfffffffb,0xc001e010
c0011470:	fb 
c0011471:	c3                   	ret    
        Hip::clr_feature (Hip::FEAT_SVM);
        return;
    }

    if (Cmdline::vtlb)
c0011472:	80 3d 88 a3 01 c0 00 	cmpb   $0x0,0xc001a388
{
    base_msr = Buddy::ptr_to_phys (Buddy::allocator.alloc (1, quota, Buddy::FILL_1));
}

void Vmcb::init()
{
c0011479:	53                   	push   %ebx
    if (!Cpu::feature (Cpu::FEAT_SVM)) {
        Hip::clr_feature (Hip::FEAT_SVM);
        return;
    }

    if (Cmdline::vtlb)
c001147a:	74 07                	je     c0011483 <_ZN4Vmcb4initEv+0x23>
        svm_feature &= ~1;
c001147c:	83 25 30 fa ff cf fe 	andl   $0xfffffffe,0xcffffa30
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
c0011483:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
c0011488:	0f 32                	rdmsr  

        template <typename T>
        ALWAYS_INLINE
        static inline void write (Register msr, T val)
        {
            asm volatile ("wrmsr" : : "a" (static_cast<mword>(val)), "d" (static_cast<mword>(static_cast<uint64>(val) >> 32)), "c" (msr));
c001148a:	31 db                	xor    %ebx,%ebx

    Msr::write (Msr::IA32_EFER, Msr::read<uint32>(Msr::IA32_EFER) | Cpu::EFER_SVME);
c001148c:	80 cc 10             	or     $0x10,%ah
c001148f:	89 da                	mov    %ebx,%edx
c0011491:	0f 30                	wrmsr  
                                            CPU_SKINIT;

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota)
        {
            return Buddy::allocator.alloc (0, quota, Buddy::FILL_0);
c0011493:	b9 50 b4 01 c0       	mov    $0xc001b450,%ecx
c0011498:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c001149d:	6a 01                	push   $0x1
c001149f:	e8 68 ff fe ff       	call   c000140c <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
c00114a4:	2d 00 00 c0 bf       	sub    $0xbfc00000,%eax
        Vmcb (Quota &quota, mword, mword);

        ALWAYS_INLINE
        inline Vmcb()
        {
            asm volatile ("vmsave" : : "a" (Buddy::ptr_to_phys (this)) : "memory");
c00114a9:	0f 01 db             	vmsave 
c00114ac:	b9 17 01 01 c0       	mov    $0xc0010117,%ecx
c00114b1:	89 da                	mov    %ebx,%edx
    Msr::write (Msr::AMD_SVM_HSAVE_PA, root = Buddy::ptr_to_phys (new (Pd::kern.quota) Vmcb));
c00114b3:	a3 3c fa ff cf       	mov    %eax,0xcffffa3c
c00114b8:	0f 30                	wrmsr  
c00114ba:	58                   	pop    %eax

    trace (TRACE_SVM, "VMCB:%#010lx REV:%#x NPT:%d", root, svm_version, has_npt());
}
c00114bb:	5b                   	pop    %ebx
c00114bc:	c3                   	ret    
c00114bd:	90                   	nop

c00114be <_ZN5Quota9hit_limitEm>:
            }
        }

        bool hit_limit(mword free_space = 0)
        {
             if (free_space > upli)
c00114be:	8b 48 0c             	mov    0xc(%eax),%ecx
c00114c1:	39 ca                	cmp    %ecx,%edx
c00114c3:	77 09                	ja     c00114ce <_ZN5Quota9hit_limitEm+0x10>
                 return true;

             return usage() > upli - free_space;
c00114c5:	29 d1                	sub    %edx,%ecx
c00114c7:	39 48 04             	cmp    %ecx,0x4(%eax)
c00114ca:	0f 97 c0             	seta   %al
c00114cd:	c3                   	ret    
        }

        bool hit_limit(mword free_space = 0)
        {
             if (free_space > upli)
                 return true;
c00114ce:	b0 01                	mov    $0x1,%al

             return usage() > upli - free_space;
        }
c00114d0:	c3                   	ret    
c00114d1:	90                   	nop

c00114d2 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb0EEEvv>:
#include "syscall.hpp"
#include "utcb.hpp"
#include "vectors.hpp"

template <Sys_regs::Status S, bool T>
void Ec::sys_finish()
c00114d2:	53                   	push   %ebx
c00114d3:	50                   	push   %eax
{
    if (T)
        current->clr_timeout();

    current->regs.set_status (S);
c00114d4:	a1 08 f0 ff cf       	mov    0xcffff008,%eax

    if (current->xcpu_sm)
c00114d9:	83 b8 f4 00 00 00 00 	cmpl   $0x0,0xf4(%eax)

        ALWAYS_INLINE
        inline void set_status (Status s, bool c = true)
        {
            if (c)
                ARG_1 = s;
c00114e0:	c7 40 70 00 00 00 00 	movl   $0x0,0x70(%eax)
c00114e7:	74 05                	je     c00114ee <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb0EEEvv+0x1c>
        xcpu_return();
c00114e9:	e8 a0 2b ff ff       	call   c000408e <_ZN2Ec11xcpu_returnEv>

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
c00114ee:	8b 1d 0c f0 ff cf    	mov    0xcffff00c,%ebx
c00114f4:	31 d2                	xor    %edx,%edx
c00114f6:	8d 83 90 01 00 00    	lea    0x190(%ebx),%eax
c00114fc:	e8 bd ff ff ff       	call   c00114be <_ZN5Quota9hit_limitEm>
c0011501:	84 c0                	test   %al,%al
c0011503:	75 05                	jne    c001150a <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb0EEEvv+0x38>
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());

    ret_user_sysexit();
c0011505:	e8 f6 ea fe ff       	call   c0000000 <_ZN2Ec16ret_user_sysexitEv>

    if (current->xcpu_sm)
        xcpu_return();

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());
c001150a:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c001150e:	ff b3 9c 01 00 00    	pushl  0x19c(%ebx)
c0011514:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0011519:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c001151e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0011523:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c001152a:	ff b3 94 01 00 00    	pushl  0x194(%ebx)
c0011530:	50                   	push   %eax
c0011531:	68 4c 97 01 c0       	push   $0xc001974c
c0011536:	e8 a3 04 ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c001153b:	83 c4 10             	add    $0x10,%esp
c001153e:	eb c5                	jmp    c0011505 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb0EEEvv+0x33>

c0011540 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb1EEEvv>:
#include "syscall.hpp"
#include "utcb.hpp"
#include "vectors.hpp"

template <Sys_regs::Status S, bool T>
void Ec::sys_finish()
c0011540:	53                   	push   %ebx
c0011541:	50                   	push   %eax
{
    if (T)
        current->clr_timeout();
c0011542:	8b 15 08 f0 ff cf    	mov    0xcffff008,%edx

        ALWAYS_INLINE
        inline bool active() const { return prev || list == this; }
c0011548:	83 ba d8 00 00 00 00 	cmpl   $0x0,0xd8(%edx)
        }

        ALWAYS_INLINE
        inline void clr_timeout()
        {
            if (EXPECT_FALSE (timeout.active()))
c001154f:	8d 82 d4 00 00 00    	lea    0xd4(%edx),%eax
c0011555:	75 3e                	jne    c0011595 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb1EEEvv+0x55>
c0011557:	39 05 40 fa ff cf    	cmp    %eax,0xcffffa40
c001155d:	74 36                	je     c0011595 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb1EEEvv+0x55>

    current->regs.set_status (S);
c001155f:	a1 08 f0 ff cf       	mov    0xcffff008,%eax

    if (current->xcpu_sm)
c0011564:	83 b8 f4 00 00 00 00 	cmpl   $0x0,0xf4(%eax)
c001156b:	c7 40 70 04 00 00 00 	movl   $0x4,0x70(%eax)
c0011572:	74 05                	je     c0011579 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb1EEEvv+0x39>
        xcpu_return();
c0011574:	e8 15 2b ff ff       	call   c000408e <_ZN2Ec11xcpu_returnEv>

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
c0011579:	8b 1d 0c f0 ff cf    	mov    0xcffff00c,%ebx
c001157f:	31 d2                	xor    %edx,%edx
c0011581:	8d 83 90 01 00 00    	lea    0x190(%ebx),%eax
c0011587:	e8 32 ff ff ff       	call   c00114be <_ZN5Quota9hit_limitEm>
c001158c:	84 c0                	test   %al,%al
c001158e:	75 0c                	jne    c001159c <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb1EEEvv+0x5c>
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());

    ret_user_sysexit();
c0011590:	e8 6b ea fe ff       	call   c0000000 <_ZN2Ec16ret_user_sysexitEv>
                timeout.dequeue();
c0011595:	e8 fe 2c 00 00       	call   c0014298 <_ZN7Timeout7dequeueEv>
c001159a:	eb c3                	jmp    c001155f <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb1EEEvv+0x1f>

    if (current->xcpu_sm)
        xcpu_return();

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());
c001159c:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c00115a0:	ff b3 9c 01 00 00    	pushl  0x19c(%ebx)
c00115a6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c00115ab:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c00115b0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00115b5:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c00115bc:	ff b3 94 01 00 00    	pushl  0x194(%ebx)
c00115c2:	50                   	push   %eax
c00115c3:	68 4c 97 01 c0       	push   $0xc001974c
c00115c8:	e8 11 04 ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c00115cd:	83 c4 10             	add    $0x10,%esp
c00115d0:	eb be                	jmp    c0011590 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb1EEEvv+0x50>

c00115d2 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb1EEEvv>:
#include "syscall.hpp"
#include "utcb.hpp"
#include "vectors.hpp"

template <Sys_regs::Status S, bool T>
void Ec::sys_finish()
c00115d2:	53                   	push   %ebx
c00115d3:	50                   	push   %eax
{
    if (T)
        current->clr_timeout();
c00115d4:	8b 15 08 f0 ff cf    	mov    0xcffff008,%edx
c00115da:	83 ba d8 00 00 00 00 	cmpl   $0x0,0xd8(%edx)
        }

        ALWAYS_INLINE
        inline void clr_timeout()
        {
            if (EXPECT_FALSE (timeout.active()))
c00115e1:	8d 82 d4 00 00 00    	lea    0xd4(%edx),%eax
c00115e7:	75 3e                	jne    c0011627 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb1EEEvv+0x55>
c00115e9:	39 05 40 fa ff cf    	cmp    %eax,0xcffffa40
c00115ef:	74 36                	je     c0011627 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb1EEEvv+0x55>

    current->regs.set_status (S);
c00115f1:	a1 08 f0 ff cf       	mov    0xcffff008,%eax

    if (current->xcpu_sm)
c00115f6:	83 b8 f4 00 00 00 00 	cmpl   $0x0,0xf4(%eax)
c00115fd:	c7 40 70 00 00 00 00 	movl   $0x0,0x70(%eax)
c0011604:	74 05                	je     c001160b <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb1EEEvv+0x39>
        xcpu_return();
c0011606:	e8 83 2a ff ff       	call   c000408e <_ZN2Ec11xcpu_returnEv>

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
c001160b:	8b 1d 0c f0 ff cf    	mov    0xcffff00c,%ebx
c0011611:	31 d2                	xor    %edx,%edx
c0011613:	8d 83 90 01 00 00    	lea    0x190(%ebx),%eax
c0011619:	e8 a0 fe ff ff       	call   c00114be <_ZN5Quota9hit_limitEm>
c001161e:	84 c0                	test   %al,%al
c0011620:	75 0c                	jne    c001162e <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb1EEEvv+0x5c>
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());

    ret_user_sysexit();
c0011622:	e8 d9 e9 fe ff       	call   c0000000 <_ZN2Ec16ret_user_sysexitEv>
                timeout.dequeue();
c0011627:	e8 6c 2c 00 00       	call   c0014298 <_ZN7Timeout7dequeueEv>
c001162c:	eb c3                	jmp    c00115f1 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb1EEEvv+0x1f>

    if (current->xcpu_sm)
        xcpu_return();

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());
c001162e:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c0011632:	ff b3 9c 01 00 00    	pushl  0x19c(%ebx)
c0011638:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c001163d:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c0011642:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0011647:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c001164e:	ff b3 94 01 00 00    	pushl  0x194(%ebx)
c0011654:	50                   	push   %eax
c0011655:	68 4c 97 01 c0       	push   $0xc001974c
c001165a:	e8 7f 03 ff ff       	call   c00019de <_ZN7Console5printEPKcz>
c001165f:	83 c4 10             	add    $0x10,%esp
c0011662:	eb be                	jmp    c0011622 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb1EEEvv+0x50>

c0011664 <_ZN2Ec14ret_xcpu_replyEv>:

    ret_xcpu_reply();
}

void Ec::ret_xcpu_reply()
{
c0011664:	55                   	push   %ebp
    assert (current->xcpu_sm);
c0011665:	a1 08 f0 ff cf       	mov    0xcffff008,%eax

    ret_xcpu_reply();
}

void Ec::ret_xcpu_reply()
{
c001166a:	57                   	push   %edi
c001166b:	56                   	push   %esi
c001166c:	53                   	push   %ebx
    assert (current->xcpu_sm);
c001166d:	8b 98 f4 00 00 00    	mov    0xf4(%eax),%ebx
c0011673:	85 db                	test   %ebx,%ebx
c0011675:	75 19                	jne    c0011690 <_ZN2Ec14ret_xcpu_replyEv+0x2c>
c0011677:	68 c0 9b 01 c0       	push   $0xc0019bc0
c001167c:	68 a7 03 00 00       	push   $0x3a7
c0011681:	68 7b 97 01 c0       	push   $0xc001977b
c0011686:	68 66 6c 01 c0       	push   $0xc0016c66
c001168b:	e9 07 01 00 00       	jmp    c0011797 <_ZN2Ec14ret_xcpu_replyEv+0x133>

    Sm::destroy(current->xcpu_sm, Pd::current->quota);
c0011690:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c0011695:	8d b0 90 01 00 00    	lea    0x190(%eax),%esi

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void destroy(Sm *obj, Quota &quota) { obj->~Sm(); cache.free (obj, quota); }
c001169b:	89 d8                	mov    %ebx,%eax
c001169d:	e8 6c 6f ff ff       	call   c000860e <_ZN2SmD1Ev>
c00116a2:	89 da                	mov    %ebx,%edx
c00116a4:	b8 b4 b4 01 c0       	mov    $0xc001b4b4,%eax
c00116a9:	89 f1                	mov    %esi,%ecx
c00116ab:	e8 b0 ec ff ff       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
    current->xcpu_sm = nullptr;
c00116b0:	8b 1d 08 f0 ff cf    	mov    0xcffff008,%ebx
c00116b6:	8b 43 70             	mov    0x70(%ebx),%eax
c00116b9:	c7 83 f4 00 00 00 00 	movl   $0x0,0xf4(%ebx)
c00116c0:	00 00 00 

    if (current->regs.status() != Sys_regs::SUCCESS) {
c00116c3:	84 c0                	test   %al,%al
c00116c5:	74 0e                	je     c00116d5 <_ZN2Ec14ret_xcpu_replyEv+0x71>
            else
                ARG_1 = (ARG_1 & ~0xfful) | s;
c00116c7:	30 c0                	xor    %al,%al
        current->cont = sys_call;
c00116c9:	c7 43 50 70 06 00 c0 	movl   $0xc0000670,0x50(%ebx)
c00116d0:	89 43 70             	mov    %eax,0x70(%ebx)
c00116d3:	eb 07                	jmp    c00116dc <_ZN2Ec14ret_xcpu_replyEv+0x78>
        current->regs.set_status (Sys_regs::SUCCESS, false);
    } else
        current->cont = ret_user_sysexit;
c00116d5:	c7 43 50 00 00 00 c0 	movl   $0xc0000000,0x50(%ebx)
        }

        ALWAYS_INLINE
        inline bool del_ref()
        {
            return Atomic::sub (ref, 1U) == 0;
c00116dc:	8d 73 48             	lea    0x48(%ebx),%esi
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c00116df:	83 c8 ff             	or     $0xffffffff,%eax
c00116e2:	f0 0f c1 06          	lock xadd %eax,(%esi)
        }

        ALWAYS_INLINE NORETURN
        inline void make_current()
        {
            if (EXPECT_FALSE(current->del_ref())) {
c00116e6:	48                   	dec    %eax
c00116e7:	75 29                	jne    c0011712 <_ZN2Ec14ret_xcpu_replyEv+0xae>
                delete current;
c00116e9:	8b 3d 08 f0 ff cf    	mov    0xcffff008,%edi
c00116ef:	85 ff                	test   %edi,%edi
c00116f1:	74 1f                	je     c0011712 <_ZN2Ec14ret_xcpu_replyEv+0xae>
c00116f3:	89 f8                	mov    %edi,%eax
c00116f5:	e8 14 1e ff ff       	call   c000350e <_ZN2EcD1Ev>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c00116fa:	8b 87 b8 00 00 00    	mov    0xb8(%edi),%eax
c0011700:	89 fa                	mov    %edi,%edx
c0011702:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c0011708:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c001170d:	e8 4e ec ff ff       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
        {
            if (EXPECT_FALSE(current->del_ref())) {
                delete current;
            }

            current = this;
c0011712:	89 1d 08 f0 ff cf    	mov    %ebx,0xcffff008
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0011718:	8b 43 48             	mov    0x48(%ebx),%eax
c001171b:	85 c0                	test   %eax,%eax
c001171d:	74 09                	je     c0011728 <_ZN2Ec14ret_xcpu_replyEv+0xc4>
                if (Atomic::cmp_swap (ref, r, r + 1))
c001171f:	8d 50 01             	lea    0x1(%eax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c0011722:	f0 0f b1 16          	lock cmpxchg %edx,(%esi)
c0011726:	75 f0                	jne    c0011718 <_ZN2Ec14ret_xcpu_replyEv+0xb4>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
c0011728:	8b b3 b8 00 00 00    	mov    0xb8(%ebx),%esi

            current->add_ref();

            Tss::run.sp0 = reinterpret_cast<mword>(exc_regs() + 1);
c001172e:	8d 83 a0 00 00 00    	lea    0xa0(%ebx),%eax
c0011734:	a3 c4 fa ff cf       	mov    %eax,0xcffffac4
c0011739:	8b 0d 04 f0 ff cf    	mov    0xcffff004,%ecx
c001173f:	8b 86 70 01 00 00    	mov    0x170(%esi),%eax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
c0011745:	8b 96 68 01 00 00    	mov    0x168(%esi),%edx

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
c001174b:	0f a3 c8             	bt     %ecx,%eax
c001174e:	73 10                	jae    c0011760 <_ZN2Ec14ret_xcpu_replyEv+0xfc>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
c0011750:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
c0011755:	d3 c0                	rol    %cl,%eax
c0011757:	f0 21 86 70 01 00 00 	lock and %eax,0x170(%esi)
c001175e:	eb 0c                	jmp    c001176c <_ZN2Ec14ret_xcpu_replyEv+0x108>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
c0011760:	39 35 0c f0 ff cf    	cmp    %esi,0xcffff00c
c0011766:	0f 84 a2 00 00 00    	je     c001180e <_ZN2Ec14ret_xcpu_replyEv+0x1aa>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c001176c:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c0011771:	83 c9 ff             	or     $0xffffffff,%ecx
c0011774:	f0 0f c1 48 48       	lock xadd %ecx,0x48(%eax)
                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
c0011779:	49                   	dec    %ecx
c001177a:	75 25                	jne    c00117a1 <_ZN2Ec14ret_xcpu_replyEv+0x13d>
                assert (current != this);
c001177c:	8b 3d 0c f0 ff cf    	mov    0xcffff00c,%edi
c0011782:	39 f7                	cmp    %esi,%edi
c0011784:	75 1d                	jne    c00117a3 <_ZN2Ec14ret_xcpu_replyEv+0x13f>
c0011786:	68 5c 9d 01 c0       	push   $0xc0019d5c
c001178b:	6a 5e                	push   $0x5e
c001178d:	68 18 73 01 c0       	push   $0xc0017318
c0011792:	68 87 73 01 c0       	push   $0xc0017387
c0011797:	68 69 60 01 c0       	push   $0xc0016069
c001179c:	e8 a5 01 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
c00117a1:	31 ff                	xor    %edi,%edi
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
c00117a3:	89 35 0c f0 ff cf    	mov    %esi,0xcffff00c
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c00117a9:	8b 46 48             	mov    0x48(%esi),%eax
c00117ac:	85 c0                	test   %eax,%eax
c00117ae:	74 0a                	je     c00117ba <_ZN2Ec14ret_xcpu_replyEv+0x156>
                if (Atomic::cmp_swap (ref, r, r + 1))
c00117b0:	8d 48 01             	lea    0x1(%eax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c00117b3:	f0 0f b1 4e 48       	lock cmpxchg %ecx,0x48(%esi)
c00117b8:	75 ef                	jne    c00117a9 <_ZN2Ec14ret_xcpu_replyEv+0x145>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
c00117ba:	31 ed                	xor    %ebp,%ebp
        }

        ALWAYS_INLINE
        inline void make_current (mword pcid)
        {
            asm volatile ("mov %0, %%cr3" : : "r" (val | pcid) : "memory");
c00117bc:	a1 04 f0 ff cf       	mov    0xcffff004,%eax
c00117c1:	f6 05 0a f7 ff cf 02 	testb  $0x2,0xcffff70a
c00117c8:	0f 44 d5             	cmove  %ebp,%edx
c00117cb:	0b 54 86 54          	or     0x54(%esi,%eax,4),%edx
c00117cf:	0f 22 da             	mov    %edx,%cr3

            if (del_pd)
c00117d2:	85 ff                	test   %edi,%edi
c00117d4:	74 38                	je     c001180e <_ZN2Ec14ret_xcpu_replyEv+0x1aa>
                delete del_pd;
c00117d6:	89 f8                	mov    %edi,%eax

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c00117d8:	89 ee                	mov    %ebp,%esi
            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);

            if (del_pd)
                delete del_pd;
c00117da:	e8 09 b2 ff ff       	call   c000c9e8 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c00117df:	8b 57 28             	mov    0x28(%edi),%edx
c00117e2:	85 d2                	test   %edx,%edx
c00117e4:	8d 82 78 fe ff ff    	lea    -0x188(%edx),%eax
c00117ea:	0f 45 f0             	cmovne %eax,%esi

            pd_del->quota.free_up(pd_to->quota);
c00117ed:	81 c6 90 01 00 00    	add    $0x190,%esi
c00117f3:	8d 87 90 01 00 00    	lea    0x190(%edi),%eax
c00117f9:	89 f2                	mov    %esi,%edx
c00117fb:	e8 cc 11 ff ff       	call   c00029cc <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
c0011800:	89 f1                	mov    %esi,%ecx
c0011802:	89 fa                	mov    %edi,%edx
c0011804:	b8 64 b4 01 c0       	mov    $0xc001b464,%eax
c0011809:	e8 52 eb ff ff       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>

            pd->make_current();

            asm volatile ("mov %0," EXPAND (PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory"); UNREACHED;
c001180e:	8b 43 50             	mov    0x50(%ebx),%eax
c0011811:	bc 00 e0 ff cf       	mov    $0xcfffe000,%esp
c0011816:	ff e0                	jmp    *%eax

c0011818 <_ZN2Ec8activateEv>:

    ret_user_sysexit();
}

void Ec::activate()
{
c0011818:	55                   	push   %ebp
c0011819:	57                   	push   %edi
c001181a:	56                   	push   %esi
c001181b:	53                   	push   %ebx
c001181c:	89 c3                	mov    %eax,%ebx
    Ec *ec = this;

    // XXX: Make the loop preemptible
    for (Sc::ctr_link = 0; ec->partner; ec = ec->partner)
c001181e:	31 c0                	xor    %eax,%eax
c0011820:	8b 93 bc 00 00 00    	mov    0xbc(%ebx),%edx
c0011826:	8d 48 01             	lea    0x1(%eax),%ecx
c0011829:	85 d2                	test   %edx,%edx
c001182b:	74 06                	je     c0011833 <_ZN2Ec8activateEv+0x1b>
c001182d:	89 c8                	mov    %ecx,%eax
c001182f:	89 d3                	mov    %edx,%ebx
c0011831:	eb ed                	jmp    c0011820 <_ZN2Ec8activateEv+0x8>
        {
            regs.add_tsc_offset (tsc);
        }

        ALWAYS_INLINE
        inline bool blocked() const { return next || !cont; }
c0011833:	83 bb c4 00 00 00 00 	cmpl   $0x0,0xc4(%ebx)
c001183a:	a3 24 fa ff cf       	mov    %eax,0xcffffa24
c001183f:	0f 85 4a 01 00 00    	jne    c001198f <_ZN2Ec8activateEv+0x177>
c0011845:	83 7b 50 00          	cmpl   $0x0,0x50(%ebx)
c0011849:	0f 84 40 01 00 00    	je     c001198f <_ZN2Ec8activateEv+0x177>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c001184f:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0011854:	83 ca ff             	or     $0xffffffff,%edx
c0011857:	f0 0f c1 50 48       	lock xadd %edx,0x48(%eax)
        }

        ALWAYS_INLINE NORETURN
        inline void make_current()
        {
            if (EXPECT_FALSE(current->del_ref())) {
c001185c:	4a                   	dec    %edx
c001185d:	75 29                	jne    c0011888 <_ZN2Ec8activateEv+0x70>
                delete current;
c001185f:	8b 35 08 f0 ff cf    	mov    0xcffff008,%esi
c0011865:	85 f6                	test   %esi,%esi
c0011867:	74 1f                	je     c0011888 <_ZN2Ec8activateEv+0x70>
c0011869:	89 f0                	mov    %esi,%eax
c001186b:	e8 9e 1c ff ff       	call   c000350e <_ZN2EcD1Ev>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c0011870:	8b 86 b8 00 00 00    	mov    0xb8(%esi),%eax
c0011876:	89 f2                	mov    %esi,%edx
c0011878:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c001187e:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c0011883:	e8 d8 ea ff ff       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
        {
            if (EXPECT_FALSE(current->del_ref())) {
                delete current;
            }

            current = this;
c0011888:	89 1d 08 f0 ff cf    	mov    %ebx,0xcffff008
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c001188e:	8b 43 48             	mov    0x48(%ebx),%eax
c0011891:	85 c0                	test   %eax,%eax
c0011893:	74 0a                	je     c001189f <_ZN2Ec8activateEv+0x87>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0011895:	8d 50 01             	lea    0x1(%eax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c0011898:	f0 0f b1 53 48       	lock cmpxchg %edx,0x48(%ebx)
c001189d:	75 ef                	jne    c001188e <_ZN2Ec8activateEv+0x76>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
c001189f:	8b b3 b8 00 00 00    	mov    0xb8(%ebx),%esi

            current->add_ref();

            Tss::run.sp0 = reinterpret_cast<mword>(exc_regs() + 1);
c00118a5:	8d 83 a0 00 00 00    	lea    0xa0(%ebx),%eax
c00118ab:	a3 c4 fa ff cf       	mov    %eax,0xcffffac4
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
c00118b0:	8b 0d 04 f0 ff cf    	mov    0xcffff004,%ecx
c00118b6:	8b 86 70 01 00 00    	mov    0x170(%esi),%eax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
c00118bc:	8b 96 68 01 00 00    	mov    0x168(%esi),%edx

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
c00118c2:	0f a3 c8             	bt     %ecx,%eax
c00118c5:	73 10                	jae    c00118d7 <_ZN2Ec8activateEv+0xbf>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
c00118c7:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
c00118cc:	d3 c0                	rol    %cl,%eax
c00118ce:	f0 21 86 70 01 00 00 	lock and %eax,0x170(%esi)
c00118d5:	eb 0c                	jmp    c00118e3 <_ZN2Ec8activateEv+0xcb>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
c00118d7:	39 35 0c f0 ff cf    	cmp    %esi,0xcffff00c
c00118dd:	0f 84 a2 00 00 00    	je     c0011985 <_ZN2Ec8activateEv+0x16d>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c00118e3:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c00118e8:	83 c9 ff             	or     $0xffffffff,%ecx
c00118eb:	f0 0f c1 48 48       	lock xadd %ecx,0x48(%eax)
                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
c00118f0:	49                   	dec    %ecx
c00118f1:	75 25                	jne    c0011918 <_ZN2Ec8activateEv+0x100>
                assert (current != this);
c00118f3:	8b 3d 0c f0 ff cf    	mov    0xcffff00c,%edi
c00118f9:	39 f7                	cmp    %esi,%edi
c00118fb:	75 1d                	jne    c001191a <_ZN2Ec8activateEv+0x102>
c00118fd:	68 5c 9d 01 c0       	push   $0xc0019d5c
c0011902:	6a 5e                	push   $0x5e
c0011904:	68 18 73 01 c0       	push   $0xc0017318
c0011909:	68 87 73 01 c0       	push   $0xc0017387
c001190e:	68 69 60 01 c0       	push   $0xc0016069
c0011913:	e8 2e 00 ff ff       	call   c0001946 <_ZN7Console5panicEPKcz>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
c0011918:	31 ff                	xor    %edi,%edi
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
c001191a:	89 35 0c f0 ff cf    	mov    %esi,0xcffff00c
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0011920:	8b 46 48             	mov    0x48(%esi),%eax
c0011923:	85 c0                	test   %eax,%eax
c0011925:	74 0a                	je     c0011931 <_ZN2Ec8activateEv+0x119>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0011927:	8d 48 01             	lea    0x1(%eax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c001192a:	f0 0f b1 4e 48       	lock cmpxchg %ecx,0x48(%esi)
c001192f:	75 ef                	jne    c0011920 <_ZN2Ec8activateEv+0x108>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
c0011931:	31 ed                	xor    %ebp,%ebp
c0011933:	a1 04 f0 ff cf       	mov    0xcffff004,%eax
c0011938:	f6 05 0a f7 ff cf 02 	testb  $0x2,0xcffff70a
c001193f:	0f 44 d5             	cmove  %ebp,%edx
c0011942:	0b 54 86 54          	or     0x54(%esi,%eax,4),%edx
c0011946:	0f 22 da             	mov    %edx,%cr3

            if (del_pd)
c0011949:	85 ff                	test   %edi,%edi
c001194b:	74 38                	je     c0011985 <_ZN2Ec8activateEv+0x16d>
                delete del_pd;
c001194d:	89 f8                	mov    %edi,%eax

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c001194f:	89 ee                	mov    %ebp,%esi
            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);

            if (del_pd)
                delete del_pd;
c0011951:	e8 92 b0 ff ff       	call   c000c9e8 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c0011956:	8b 57 28             	mov    0x28(%edi),%edx
c0011959:	85 d2                	test   %edx,%edx
c001195b:	8d 82 78 fe ff ff    	lea    -0x188(%edx),%eax
c0011961:	0f 45 f0             	cmovne %eax,%esi

            pd_del->quota.free_up(pd_to->quota);
c0011964:	81 c6 90 01 00 00    	add    $0x190,%esi
c001196a:	8d 87 90 01 00 00    	lea    0x190(%edi),%eax
c0011970:	89 f2                	mov    %esi,%edx
c0011972:	e8 55 10 ff ff       	call   c00029cc <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
c0011977:	89 f1                	mov    %esi,%ecx
c0011979:	89 fa                	mov    %edi,%edx
c001197b:	b8 64 b4 01 c0       	mov    $0xc001b464,%eax
c0011980:	e8 db e9 ff ff       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>

            pd->make_current();

            asm volatile ("mov %0," EXPAND (PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory"); UNREACHED;
c0011985:	8b 43 50             	mov    0x50(%ebx),%eax
c0011988:	bc 00 e0 ff cf       	mov    $0xcfffe000,%esp
c001198d:	ff e0                	jmp    *%eax
        Sc::ctr_link++;

    if (EXPECT_FALSE (ec->blocked()))
        ec->block_sc();
c001198f:	89 d8                	mov    %ebx,%eax
c0011991:	e8 7a 6b ff ff       	call   c0008510 <_ZN2Ec8block_scEv>
c0011996:	e9 b4 fe ff ff       	jmp    c001184f <_ZN2Ec8activateEv+0x37>
c001199b:	90                   	nop

c001199c <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv>:
        current->oom_delegate(dst, ec, src, user, C);
    }
}

template <void (*C)()>
void Ec::send_msg()
c001199c:	55                   	push   %ebp
{
    Exc_regs *r = &current->regs;
c001199d:	8b 15 08 f0 ff cf    	mov    0xcffff008,%edx
        current->oom_delegate(dst, ec, src, user, C);
    }
}

template <void (*C)()>
void Ec::send_msg()
c00119a3:	57                   	push   %edi
c00119a4:	56                   	push   %esi
c00119a5:	53                   	push   %ebx
{
    Exc_regs *r = &current->regs;

    Kobject *obj = Space_obj::lookup (current->evt + r->dst_portal).obj();
c00119a6:	8b 82 d0 00 00 00    	mov    0xd0(%edx),%eax
c00119ac:	03 82 88 00 00 00    	add    0x88(%edx),%eax
c00119b2:	25 ff ff ff 07       	and    $0x7ffffff,%eax

        ALWAYS_INLINE
        inline Kobject *obj() const { return reinterpret_cast<Kobject *>(val & ~perm); }
c00119b7:	8b 0c 85 00 00 00 e0 	mov    -0x20000000(,%eax,4),%ecx

    public:
        ALWAYS_INLINE
        inline Type type() const
        {
            return EXPECT_TRUE (this) ? Type (objtype) : INVALID;
c00119be:	83 e1 e0             	and    $0xffffffe0,%ecx
c00119c1:	74 06                	je     c00119c9 <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x2d>
    if (EXPECT_FALSE (obj->type() != Kobject::PT))
c00119c3:	80 79 44 03          	cmpb   $0x3,0x44(%ecx)
c00119c7:	74 0a                	je     c00119d3 <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x37>
        die ("PT not found");
c00119c9:	83 c2 54             	add    $0x54,%edx
c00119cc:	b8 e8 69 01 c0       	mov    $0xc00169e8,%eax
c00119d1:	eb 1a                	jmp    c00119ed <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x51>
{
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
c00119d3:	8b 59 4c             	mov    0x4c(%ecx),%ebx

    Pt *pt = static_cast<Pt *>(obj);
    Ec *ec = pt->ec;

    if (EXPECT_FALSE (current->cpu != ec->xcpu))
c00119d6:	0f b7 82 cc 00 00 00 	movzwl 0xcc(%edx),%eax
c00119dd:	3b 83 cc 00 00 00    	cmp    0xcc(%ebx),%eax
c00119e3:	74 0d                	je     c00119f2 <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x56>
        die ("PT wrong CPU");
c00119e5:	83 c2 54             	add    $0x54,%edx
c00119e8:	b8 eb 97 01 c0       	mov    $0xc00197eb,%eax
c00119ed:	e8 1a 21 ff ff       	call   c0003b0c <_ZN2Ec3dieEPKcP8Exc_regs>

    if (EXPECT_TRUE (!ec->cont)) {
c00119f2:	83 7b 50 00          	cmpl   $0x0,0x50(%ebx)
c00119f6:	0f 85 a9 01 00 00    	jne    c0011ba5 <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x209>
        current->cont = C;
c00119fc:	c7 42 50 2c 3f 00 c0 	movl   $0xc0003f2c,0x50(%edx)
        inline Exc_regs *exc_regs() { return &regs; }

        ALWAYS_INLINE
        inline void set_partner (Ec *p)
        {
            partner = p;
c0011a03:	89 9a bc 00 00 00    	mov    %ebx,0xbc(%edx)
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0011a09:	8b 43 48             	mov    0x48(%ebx),%eax
c0011a0c:	85 c0                	test   %eax,%eax
c0011a0e:	74 0a                	je     c0011a1a <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x7e>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0011a10:	8d 70 01             	lea    0x1(%eax),%esi
c0011a13:	f0 0f b1 73 48       	lock cmpxchg %esi,0x48(%ebx)
c0011a18:	75 ef                	jne    c0011a09 <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x6d>
            partner->add_ref();
            partner->rcap = this;
c0011a1a:	8b 82 bc 00 00 00    	mov    0xbc(%edx),%eax
c0011a20:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
            partner->rcap->add_ref();
c0011a26:	8b 82 bc 00 00 00    	mov    0xbc(%edx),%eax
c0011a2c:	8b 90 b0 00 00 00    	mov    0xb0(%eax),%edx
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0011a32:	8b 42 48             	mov    0x48(%edx),%eax
c0011a35:	85 c0                	test   %eax,%eax
c0011a37:	74 0a                	je     c0011a43 <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0xa7>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0011a39:	8d 70 01             	lea    0x1(%eax),%esi
c0011a3c:	f0 0f b1 72 48       	lock cmpxchg %esi,0x48(%edx)
c0011a41:	75 ef                	jne    c0011a32 <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x96>
        current->set_partner (ec);
        current->regs.mtd = pt->mtd.val;
c0011a43:	8b 51 50             	mov    0x50(%ecx),%edx
c0011a46:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
            Sc::ctr_link++;
c0011a4b:	ff 05 24 fa ff cf    	incl   0xcffffa24
c0011a51:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
        ec->cont = recv_kern;
c0011a57:	c7 43 50 8c 00 00 c0 	movl   $0xc000008c,0x50(%ebx)
        ec->regs.set_pt (pt->id);
c0011a5e:	8b 51 58             	mov    0x58(%ecx),%edx
        }

        ALWAYS_INLINE
        inline void set_pt (mword pt) { ARG_1 = pt; }
c0011a61:	89 53 70             	mov    %edx,0x70(%ebx)
        ec->regs.set_ip (pt->ip);
c0011a64:	8b 51 54             	mov    0x54(%ecx),%edx

        ALWAYS_INLINE
        inline void set_pt (mword pt, mword pt2, mword s) { ARG_1 = pt; ARG_2 = pt2; ARG_3 = s; }

        ALWAYS_INLINE
        inline void set_ip (mword ip) { ARG_IP = ip; }
c0011a67:	89 53 68             	mov    %edx,0x68(%ebx)
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c0011a6a:	83 ca ff             	or     $0xffffffff,%edx
c0011a6d:	f0 0f c1 50 48       	lock xadd %edx,0x48(%eax)
        }

        ALWAYS_INLINE NORETURN
        inline void make_current()
        {
            if (EXPECT_FALSE(current->del_ref())) {
c0011a72:	4a                   	dec    %edx
c0011a73:	75 29                	jne    c0011a9e <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x102>
                delete current;
c0011a75:	8b 35 08 f0 ff cf    	mov    0xcffff008,%esi
c0011a7b:	85 f6                	test   %esi,%esi
c0011a7d:	74 1f                	je     c0011a9e <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x102>
c0011a7f:	89 f0                	mov    %esi,%eax
c0011a81:	e8 88 1a ff ff       	call   c000350e <_ZN2EcD1Ev>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c0011a86:	8b 86 b8 00 00 00    	mov    0xb8(%esi),%eax
c0011a8c:	89 f2                	mov    %esi,%edx
c0011a8e:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c0011a94:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c0011a99:	e8 c2 e8 ff ff       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
        {
            if (EXPECT_FALSE(current->del_ref())) {
                delete current;
            }

            current = this;
c0011a9e:	89 1d 08 f0 ff cf    	mov    %ebx,0xcffff008
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0011aa4:	8b 43 48             	mov    0x48(%ebx),%eax
c0011aa7:	85 c0                	test   %eax,%eax
c0011aa9:	74 0a                	je     c0011ab5 <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x119>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0011aab:	8d 50 01             	lea    0x1(%eax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c0011aae:	f0 0f b1 53 48       	lock cmpxchg %edx,0x48(%ebx)
c0011ab3:	75 ef                	jne    c0011aa4 <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x108>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
c0011ab5:	8b b3 b8 00 00 00    	mov    0xb8(%ebx),%esi

            current->add_ref();

            Tss::run.sp0 = reinterpret_cast<mword>(exc_regs() + 1);
c0011abb:	8d 83 a0 00 00 00    	lea    0xa0(%ebx),%eax
c0011ac1:	a3 c4 fa ff cf       	mov    %eax,0xcffffac4
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
c0011ac6:	8b 0d 04 f0 ff cf    	mov    0xcffff004,%ecx
c0011acc:	8b 86 70 01 00 00    	mov    0x170(%esi),%eax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
c0011ad2:	8b 96 68 01 00 00    	mov    0x168(%esi),%edx

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
c0011ad8:	0f a3 c8             	bt     %ecx,%eax
c0011adb:	73 10                	jae    c0011aed <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x151>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
c0011add:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
c0011ae2:	d3 c0                	rol    %cl,%eax
c0011ae4:	f0 21 86 70 01 00 00 	lock and %eax,0x170(%esi)
c0011aeb:	eb 0c                	jmp    c0011af9 <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x15d>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
c0011aed:	39 35 0c f0 ff cf    	cmp    %esi,0xcffff00c
c0011af3:	0f 84 a2 00 00 00    	je     c0011b9b <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x1ff>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c0011af9:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c0011afe:	83 c9 ff             	or     $0xffffffff,%ecx
c0011b01:	f0 0f c1 48 48       	lock xadd %ecx,0x48(%eax)
                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
c0011b06:	49                   	dec    %ecx
c0011b07:	75 25                	jne    c0011b2e <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x192>
                assert (current != this);
c0011b09:	8b 3d 0c f0 ff cf    	mov    0xcffff00c,%edi
c0011b0f:	39 f7                	cmp    %esi,%edi
c0011b11:	75 1d                	jne    c0011b30 <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x194>
c0011b13:	68 5c 9d 01 c0       	push   $0xc0019d5c
c0011b18:	6a 5e                	push   $0x5e
c0011b1a:	68 18 73 01 c0       	push   $0xc0017318
c0011b1f:	68 87 73 01 c0       	push   $0xc0017387
c0011b24:	68 69 60 01 c0       	push   $0xc0016069
c0011b29:	e8 18 fe fe ff       	call   c0001946 <_ZN7Console5panicEPKcz>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
c0011b2e:	31 ff                	xor    %edi,%edi
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
c0011b30:	89 35 0c f0 ff cf    	mov    %esi,0xcffff00c
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0011b36:	8b 46 48             	mov    0x48(%esi),%eax
c0011b39:	85 c0                	test   %eax,%eax
c0011b3b:	74 0a                	je     c0011b47 <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x1ab>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0011b3d:	8d 48 01             	lea    0x1(%eax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c0011b40:	f0 0f b1 4e 48       	lock cmpxchg %ecx,0x48(%esi)
c0011b45:	75 ef                	jne    c0011b36 <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x19a>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
c0011b47:	31 ed                	xor    %ebp,%ebp
c0011b49:	a1 04 f0 ff cf       	mov    0xcffff004,%eax
c0011b4e:	f6 05 0a f7 ff cf 02 	testb  $0x2,0xcffff70a
c0011b55:	0f 44 d5             	cmove  %ebp,%edx
c0011b58:	0b 54 86 54          	or     0x54(%esi,%eax,4),%edx
c0011b5c:	0f 22 da             	mov    %edx,%cr3

            if (del_pd)
c0011b5f:	85 ff                	test   %edi,%edi
c0011b61:	74 38                	je     c0011b9b <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x1ff>
                delete del_pd;
c0011b63:	89 f8                	mov    %edi,%eax

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c0011b65:	89 ee                	mov    %ebp,%esi
            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);

            if (del_pd)
                delete del_pd;
c0011b67:	e8 7c ae ff ff       	call   c000c9e8 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c0011b6c:	8b 57 28             	mov    0x28(%edi),%edx
c0011b6f:	85 d2                	test   %edx,%edx
c0011b71:	8d 82 78 fe ff ff    	lea    -0x188(%edx),%eax
c0011b77:	0f 45 f0             	cmovne %eax,%esi

            pd_del->quota.free_up(pd_to->quota);
c0011b7a:	81 c6 90 01 00 00    	add    $0x190,%esi
c0011b80:	8d 87 90 01 00 00    	lea    0x190(%edi),%eax
c0011b86:	89 f2                	mov    %esi,%edx
c0011b88:	e8 3f 0e ff ff       	call   c00029cc <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
c0011b8d:	89 f1                	mov    %esi,%ecx
c0011b8f:	89 fa                	mov    %edi,%edx
c0011b91:	b8 64 b4 01 c0       	mov    $0xc001b464,%eax
c0011b96:	e8 c5 e7 ff ff       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>

            pd->make_current();

            asm volatile ("mov %0," EXPAND (PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory"); UNREACHED;
c0011b9b:	8b 43 50             	mov    0x50(%ebx),%eax
c0011b9e:	bc 00 e0 ff cf       	mov    $0xcfffe000,%esp
c0011ba3:	ff e0                	jmp    *%eax
        ec->make_current();
    }

    ec->help (send_msg<C>);
c0011ba5:	ba 9c 19 01 c0       	mov    $0xc001199c,%edx
c0011baa:	89 d8                	mov    %ebx,%eax
c0011bac:	e8 ed 68 ff ff       	call   c000849e <_ZN2Ec4helpEPFvvE>

    die ("IPC Timeout");
c0011bb1:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0011bb6:	8d 50 54             	lea    0x54(%eax),%edx
c0011bb9:	b8 f8 97 01 c0       	mov    $0xc00197f8,%eax
c0011bbe:	e9 2a fe ff ff       	jmp    c00119ed <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x51>
c0011bc3:	90                   	nop

c0011bc4 <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv>:
        current->oom_delegate(dst, ec, src, user, C);
    }
}

template <void (*C)()>
void Ec::send_msg()
c0011bc4:	55                   	push   %ebp
{
    Exc_regs *r = &current->regs;
c0011bc5:	8b 15 08 f0 ff cf    	mov    0xcffff008,%edx
        current->oom_delegate(dst, ec, src, user, C);
    }
}

template <void (*C)()>
void Ec::send_msg()
c0011bcb:	57                   	push   %edi
c0011bcc:	56                   	push   %esi
c0011bcd:	53                   	push   %ebx
{
    Exc_regs *r = &current->regs;

    Kobject *obj = Space_obj::lookup (current->evt + r->dst_portal).obj();
c0011bce:	8b 82 d0 00 00 00    	mov    0xd0(%edx),%eax
c0011bd4:	03 82 88 00 00 00    	add    0x88(%edx),%eax
c0011bda:	25 ff ff ff 07       	and    $0x7ffffff,%eax
c0011bdf:	8b 0c 85 00 00 00 e0 	mov    -0x20000000(,%eax,4),%ecx
c0011be6:	83 e1 e0             	and    $0xffffffe0,%ecx
c0011be9:	74 06                	je     c0011bf1 <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x2d>
    if (EXPECT_FALSE (obj->type() != Kobject::PT))
c0011beb:	80 79 44 03          	cmpb   $0x3,0x44(%ecx)
c0011bef:	74 0a                	je     c0011bfb <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x37>
        die ("PT not found");
c0011bf1:	83 c2 54             	add    $0x54,%edx
c0011bf4:	b8 e8 69 01 c0       	mov    $0xc00169e8,%eax
c0011bf9:	eb 1a                	jmp    c0011c15 <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x51>
{
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
c0011bfb:	8b 59 4c             	mov    0x4c(%ecx),%ebx

    Pt *pt = static_cast<Pt *>(obj);
    Ec *ec = pt->ec;

    if (EXPECT_FALSE (current->cpu != ec->xcpu))
c0011bfe:	0f b7 82 cc 00 00 00 	movzwl 0xcc(%edx),%eax
c0011c05:	3b 83 cc 00 00 00    	cmp    0xcc(%ebx),%eax
c0011c0b:	74 0d                	je     c0011c1a <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x56>
        die ("PT wrong CPU");
c0011c0d:	83 c2 54             	add    $0x54,%edx
c0011c10:	b8 eb 97 01 c0       	mov    $0xc00197eb,%eax
c0011c15:	e8 f2 1e ff ff       	call   c0003b0c <_ZN2Ec3dieEPKcP8Exc_regs>

    if (EXPECT_TRUE (!ec->cont)) {
c0011c1a:	83 7b 50 00          	cmpl   $0x0,0x50(%ebx)
c0011c1e:	0f 85 a9 01 00 00    	jne    c0011dcd <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x209>
        current->cont = C;
c0011c24:	c7 42 50 44 3a 00 c0 	movl   $0xc0003a44,0x50(%edx)
        inline Exc_regs *exc_regs() { return &regs; }

        ALWAYS_INLINE
        inline void set_partner (Ec *p)
        {
            partner = p;
c0011c2b:	89 9a bc 00 00 00    	mov    %ebx,0xbc(%edx)
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0011c31:	8b 43 48             	mov    0x48(%ebx),%eax
c0011c34:	85 c0                	test   %eax,%eax
c0011c36:	74 0a                	je     c0011c42 <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x7e>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0011c38:	8d 70 01             	lea    0x1(%eax),%esi
c0011c3b:	f0 0f b1 73 48       	lock cmpxchg %esi,0x48(%ebx)
c0011c40:	75 ef                	jne    c0011c31 <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x6d>
            partner->add_ref();
            partner->rcap = this;
c0011c42:	8b 82 bc 00 00 00    	mov    0xbc(%edx),%eax
c0011c48:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
            partner->rcap->add_ref();
c0011c4e:	8b 82 bc 00 00 00    	mov    0xbc(%edx),%eax
c0011c54:	8b 90 b0 00 00 00    	mov    0xb0(%eax),%edx
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0011c5a:	8b 42 48             	mov    0x48(%edx),%eax
c0011c5d:	85 c0                	test   %eax,%eax
c0011c5f:	74 0a                	je     c0011c6b <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0xa7>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0011c61:	8d 70 01             	lea    0x1(%eax),%esi
c0011c64:	f0 0f b1 72 48       	lock cmpxchg %esi,0x48(%edx)
c0011c69:	75 ef                	jne    c0011c5a <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x96>
        current->set_partner (ec);
        current->regs.mtd = pt->mtd.val;
c0011c6b:	8b 51 50             	mov    0x50(%ecx),%edx
c0011c6e:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
            Sc::ctr_link++;
c0011c73:	ff 05 24 fa ff cf    	incl   0xcffffa24
c0011c79:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
        ec->cont = recv_kern;
c0011c7f:	c7 43 50 8c 00 00 c0 	movl   $0xc000008c,0x50(%ebx)
        ec->regs.set_pt (pt->id);
c0011c86:	8b 51 58             	mov    0x58(%ecx),%edx
            else
                ARG_1 = (ARG_1 & ~0xfful) | s;
        }

        ALWAYS_INLINE
        inline void set_pt (mword pt) { ARG_1 = pt; }
c0011c89:	89 53 70             	mov    %edx,0x70(%ebx)
        ec->regs.set_ip (pt->ip);
c0011c8c:	8b 51 54             	mov    0x54(%ecx),%edx

        ALWAYS_INLINE
        inline void set_pt (mword pt, mword pt2, mword s) { ARG_1 = pt; ARG_2 = pt2; ARG_3 = s; }

        ALWAYS_INLINE
        inline void set_ip (mword ip) { ARG_IP = ip; }
c0011c8f:	89 53 68             	mov    %edx,0x68(%ebx)
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c0011c92:	83 ca ff             	or     $0xffffffff,%edx
c0011c95:	f0 0f c1 50 48       	lock xadd %edx,0x48(%eax)
        }

        ALWAYS_INLINE NORETURN
        inline void make_current()
        {
            if (EXPECT_FALSE(current->del_ref())) {
c0011c9a:	4a                   	dec    %edx
c0011c9b:	75 29                	jne    c0011cc6 <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x102>
                delete current;
c0011c9d:	8b 35 08 f0 ff cf    	mov    0xcffff008,%esi
c0011ca3:	85 f6                	test   %esi,%esi
c0011ca5:	74 1f                	je     c0011cc6 <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x102>
c0011ca7:	89 f0                	mov    %esi,%eax
c0011ca9:	e8 60 18 ff ff       	call   c000350e <_ZN2EcD1Ev>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c0011cae:	8b 86 b8 00 00 00    	mov    0xb8(%esi),%eax
c0011cb4:	89 f2                	mov    %esi,%edx
c0011cb6:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c0011cbc:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c0011cc1:	e8 9a e6 ff ff       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
        {
            if (EXPECT_FALSE(current->del_ref())) {
                delete current;
            }

            current = this;
c0011cc6:	89 1d 08 f0 ff cf    	mov    %ebx,0xcffff008
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0011ccc:	8b 43 48             	mov    0x48(%ebx),%eax
c0011ccf:	85 c0                	test   %eax,%eax
c0011cd1:	74 0a                	je     c0011cdd <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x119>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0011cd3:	8d 50 01             	lea    0x1(%eax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c0011cd6:	f0 0f b1 53 48       	lock cmpxchg %edx,0x48(%ebx)
c0011cdb:	75 ef                	jne    c0011ccc <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x108>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
c0011cdd:	8b b3 b8 00 00 00    	mov    0xb8(%ebx),%esi

            current->add_ref();

            Tss::run.sp0 = reinterpret_cast<mword>(exc_regs() + 1);
c0011ce3:	8d 83 a0 00 00 00    	lea    0xa0(%ebx),%eax
c0011ce9:	a3 c4 fa ff cf       	mov    %eax,0xcffffac4
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
c0011cee:	8b 0d 04 f0 ff cf    	mov    0xcffff004,%ecx
c0011cf4:	8b 86 70 01 00 00    	mov    0x170(%esi),%eax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
c0011cfa:	8b 96 68 01 00 00    	mov    0x168(%esi),%edx

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
c0011d00:	0f a3 c8             	bt     %ecx,%eax
c0011d03:	73 10                	jae    c0011d15 <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x151>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
c0011d05:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
c0011d0a:	d3 c0                	rol    %cl,%eax
c0011d0c:	f0 21 86 70 01 00 00 	lock and %eax,0x170(%esi)
c0011d13:	eb 0c                	jmp    c0011d21 <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x15d>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
c0011d15:	39 35 0c f0 ff cf    	cmp    %esi,0xcffff00c
c0011d1b:	0f 84 a2 00 00 00    	je     c0011dc3 <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x1ff>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c0011d21:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c0011d26:	83 c9 ff             	or     $0xffffffff,%ecx
c0011d29:	f0 0f c1 48 48       	lock xadd %ecx,0x48(%eax)
                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
c0011d2e:	49                   	dec    %ecx
c0011d2f:	75 25                	jne    c0011d56 <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x192>
                assert (current != this);
c0011d31:	8b 3d 0c f0 ff cf    	mov    0xcffff00c,%edi
c0011d37:	39 f7                	cmp    %esi,%edi
c0011d39:	75 1d                	jne    c0011d58 <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x194>
c0011d3b:	68 5c 9d 01 c0       	push   $0xc0019d5c
c0011d40:	6a 5e                	push   $0x5e
c0011d42:	68 18 73 01 c0       	push   $0xc0017318
c0011d47:	68 87 73 01 c0       	push   $0xc0017387
c0011d4c:	68 69 60 01 c0       	push   $0xc0016069
c0011d51:	e8 f0 fb fe ff       	call   c0001946 <_ZN7Console5panicEPKcz>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
c0011d56:	31 ff                	xor    %edi,%edi
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
c0011d58:	89 35 0c f0 ff cf    	mov    %esi,0xcffff00c
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0011d5e:	8b 46 48             	mov    0x48(%esi),%eax
c0011d61:	85 c0                	test   %eax,%eax
c0011d63:	74 0a                	je     c0011d6f <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x1ab>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0011d65:	8d 48 01             	lea    0x1(%eax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c0011d68:	f0 0f b1 4e 48       	lock cmpxchg %ecx,0x48(%esi)
c0011d6d:	75 ef                	jne    c0011d5e <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x19a>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
c0011d6f:	31 ed                	xor    %ebp,%ebp
c0011d71:	a1 04 f0 ff cf       	mov    0xcffff004,%eax
c0011d76:	f6 05 0a f7 ff cf 02 	testb  $0x2,0xcffff70a
c0011d7d:	0f 44 d5             	cmove  %ebp,%edx
c0011d80:	0b 54 86 54          	or     0x54(%esi,%eax,4),%edx
c0011d84:	0f 22 da             	mov    %edx,%cr3

            if (del_pd)
c0011d87:	85 ff                	test   %edi,%edi
c0011d89:	74 38                	je     c0011dc3 <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x1ff>
                delete del_pd;
c0011d8b:	89 f8                	mov    %edi,%eax

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c0011d8d:	89 ee                	mov    %ebp,%esi
            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);

            if (del_pd)
                delete del_pd;
c0011d8f:	e8 54 ac ff ff       	call   c000c9e8 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c0011d94:	8b 57 28             	mov    0x28(%edi),%edx
c0011d97:	85 d2                	test   %edx,%edx
c0011d99:	8d 82 78 fe ff ff    	lea    -0x188(%edx),%eax
c0011d9f:	0f 45 f0             	cmovne %eax,%esi

            pd_del->quota.free_up(pd_to->quota);
c0011da2:	81 c6 90 01 00 00    	add    $0x190,%esi
c0011da8:	8d 87 90 01 00 00    	lea    0x190(%edi),%eax
c0011dae:	89 f2                	mov    %esi,%edx
c0011db0:	e8 17 0c ff ff       	call   c00029cc <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
c0011db5:	89 f1                	mov    %esi,%ecx
c0011db7:	89 fa                	mov    %edi,%edx
c0011db9:	b8 64 b4 01 c0       	mov    $0xc001b464,%eax
c0011dbe:	e8 9d e5 ff ff       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>

            pd->make_current();

            asm volatile ("mov %0," EXPAND (PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory"); UNREACHED;
c0011dc3:	8b 43 50             	mov    0x50(%ebx),%eax
c0011dc6:	bc 00 e0 ff cf       	mov    $0xcfffe000,%esp
c0011dcb:	ff e0                	jmp    *%eax
        ec->make_current();
    }

    ec->help (send_msg<C>);
c0011dcd:	ba c4 1b 01 c0       	mov    $0xc0011bc4,%edx
c0011dd2:	89 d8                	mov    %ebx,%eax
c0011dd4:	e8 c5 66 ff ff       	call   c000849e <_ZN2Ec4helpEPFvvE>

    die ("IPC Timeout");
c0011dd9:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0011dde:	8d 50 54             	lea    0x54(%eax),%edx
c0011de1:	b8 f8 97 01 c0       	mov    $0xc00197f8,%eax
c0011de6:	e9 2a fe ff ff       	jmp    c0011c15 <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x51>
c0011deb:	90                   	nop

c0011dec <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv>:
        current->oom_delegate(dst, ec, src, user, C);
    }
}

template <void (*C)()>
void Ec::send_msg()
c0011dec:	55                   	push   %ebp
{
    Exc_regs *r = &current->regs;
c0011ded:	8b 15 08 f0 ff cf    	mov    0xcffff008,%edx
        current->oom_delegate(dst, ec, src, user, C);
    }
}

template <void (*C)()>
void Ec::send_msg()
c0011df3:	57                   	push   %edi
c0011df4:	56                   	push   %esi
c0011df5:	53                   	push   %ebx
{
    Exc_regs *r = &current->regs;

    Kobject *obj = Space_obj::lookup (current->evt + r->dst_portal).obj();
c0011df6:	8b 82 d0 00 00 00    	mov    0xd0(%edx),%eax
c0011dfc:	03 82 88 00 00 00    	add    0x88(%edx),%eax
c0011e02:	25 ff ff ff 07       	and    $0x7ffffff,%eax
c0011e07:	8b 0c 85 00 00 00 e0 	mov    -0x20000000(,%eax,4),%ecx
c0011e0e:	83 e1 e0             	and    $0xffffffe0,%ecx
c0011e11:	74 06                	je     c0011e19 <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x2d>
    if (EXPECT_FALSE (obj->type() != Kobject::PT))
c0011e13:	80 79 44 03          	cmpb   $0x3,0x44(%ecx)
c0011e17:	74 0a                	je     c0011e23 <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x37>
        die ("PT not found");
c0011e19:	83 c2 54             	add    $0x54,%edx
c0011e1c:	b8 e8 69 01 c0       	mov    $0xc00169e8,%eax
c0011e21:	eb 1a                	jmp    c0011e3d <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x51>
{
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
c0011e23:	8b 59 4c             	mov    0x4c(%ecx),%ebx

    Pt *pt = static_cast<Pt *>(obj);
    Ec *ec = pt->ec;

    if (EXPECT_FALSE (current->cpu != ec->xcpu))
c0011e26:	0f b7 82 cc 00 00 00 	movzwl 0xcc(%edx),%eax
c0011e2d:	3b 83 cc 00 00 00    	cmp    0xcc(%ebx),%eax
c0011e33:	74 0d                	je     c0011e42 <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x56>
        die ("PT wrong CPU");
c0011e35:	83 c2 54             	add    $0x54,%edx
c0011e38:	b8 eb 97 01 c0       	mov    $0xc00197eb,%eax
c0011e3d:	e8 ca 1c ff ff       	call   c0003b0c <_ZN2Ec3dieEPKcP8Exc_regs>

    if (EXPECT_TRUE (!ec->cont)) {
c0011e42:	83 7b 50 00          	cmpl   $0x0,0x50(%ebx)
c0011e46:	0f 85 a9 01 00 00    	jne    c0011ff5 <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x209>
        current->cont = C;
c0011e4c:	c7 42 50 2e 00 00 c0 	movl   $0xc000002e,0x50(%edx)
        inline Exc_regs *exc_regs() { return &regs; }

        ALWAYS_INLINE
        inline void set_partner (Ec *p)
        {
            partner = p;
c0011e53:	89 9a bc 00 00 00    	mov    %ebx,0xbc(%edx)
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0011e59:	8b 43 48             	mov    0x48(%ebx),%eax
c0011e5c:	85 c0                	test   %eax,%eax
c0011e5e:	74 0a                	je     c0011e6a <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x7e>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0011e60:	8d 70 01             	lea    0x1(%eax),%esi
c0011e63:	f0 0f b1 73 48       	lock cmpxchg %esi,0x48(%ebx)
c0011e68:	75 ef                	jne    c0011e59 <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x6d>
            partner->add_ref();
            partner->rcap = this;
c0011e6a:	8b 82 bc 00 00 00    	mov    0xbc(%edx),%eax
c0011e70:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
            partner->rcap->add_ref();
c0011e76:	8b 82 bc 00 00 00    	mov    0xbc(%edx),%eax
c0011e7c:	8b 90 b0 00 00 00    	mov    0xb0(%eax),%edx
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0011e82:	8b 42 48             	mov    0x48(%edx),%eax
c0011e85:	85 c0                	test   %eax,%eax
c0011e87:	74 0a                	je     c0011e93 <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0xa7>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0011e89:	8d 70 01             	lea    0x1(%eax),%esi
c0011e8c:	f0 0f b1 72 48       	lock cmpxchg %esi,0x48(%edx)
c0011e91:	75 ef                	jne    c0011e82 <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x96>
        current->set_partner (ec);
        current->regs.mtd = pt->mtd.val;
c0011e93:	8b 51 50             	mov    0x50(%ecx),%edx
c0011e96:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
            Sc::ctr_link++;
c0011e9b:	ff 05 24 fa ff cf    	incl   0xcffffa24
c0011ea1:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
        ec->cont = recv_kern;
c0011ea7:	c7 43 50 8c 00 00 c0 	movl   $0xc000008c,0x50(%ebx)
        ec->regs.set_pt (pt->id);
c0011eae:	8b 51 58             	mov    0x58(%ecx),%edx
            else
                ARG_1 = (ARG_1 & ~0xfful) | s;
        }

        ALWAYS_INLINE
        inline void set_pt (mword pt) { ARG_1 = pt; }
c0011eb1:	89 53 70             	mov    %edx,0x70(%ebx)
        ec->regs.set_ip (pt->ip);
c0011eb4:	8b 51 54             	mov    0x54(%ecx),%edx

        ALWAYS_INLINE
        inline void set_pt (mword pt, mword pt2, mword s) { ARG_1 = pt; ARG_2 = pt2; ARG_3 = s; }

        ALWAYS_INLINE
        inline void set_ip (mword ip) { ARG_IP = ip; }
c0011eb7:	89 53 68             	mov    %edx,0x68(%ebx)
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c0011eba:	83 ca ff             	or     $0xffffffff,%edx
c0011ebd:	f0 0f c1 50 48       	lock xadd %edx,0x48(%eax)
        }

        ALWAYS_INLINE NORETURN
        inline void make_current()
        {
            if (EXPECT_FALSE(current->del_ref())) {
c0011ec2:	4a                   	dec    %edx
c0011ec3:	75 29                	jne    c0011eee <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x102>
                delete current;
c0011ec5:	8b 35 08 f0 ff cf    	mov    0xcffff008,%esi
c0011ecb:	85 f6                	test   %esi,%esi
c0011ecd:	74 1f                	je     c0011eee <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x102>
c0011ecf:	89 f0                	mov    %esi,%eax
c0011ed1:	e8 38 16 ff ff       	call   c000350e <_ZN2EcD1Ev>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c0011ed6:	8b 86 b8 00 00 00    	mov    0xb8(%esi),%eax
c0011edc:	89 f2                	mov    %esi,%edx
c0011ede:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c0011ee4:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c0011ee9:	e8 72 e4 ff ff       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
        {
            if (EXPECT_FALSE(current->del_ref())) {
                delete current;
            }

            current = this;
c0011eee:	89 1d 08 f0 ff cf    	mov    %ebx,0xcffff008
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0011ef4:	8b 43 48             	mov    0x48(%ebx),%eax
c0011ef7:	85 c0                	test   %eax,%eax
c0011ef9:	74 0a                	je     c0011f05 <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x119>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0011efb:	8d 50 01             	lea    0x1(%eax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c0011efe:	f0 0f b1 53 48       	lock cmpxchg %edx,0x48(%ebx)
c0011f03:	75 ef                	jne    c0011ef4 <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x108>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
c0011f05:	8b b3 b8 00 00 00    	mov    0xb8(%ebx),%esi

            current->add_ref();

            Tss::run.sp0 = reinterpret_cast<mword>(exc_regs() + 1);
c0011f0b:	8d 83 a0 00 00 00    	lea    0xa0(%ebx),%eax
c0011f11:	a3 c4 fa ff cf       	mov    %eax,0xcffffac4
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
c0011f16:	8b 0d 04 f0 ff cf    	mov    0xcffff004,%ecx
c0011f1c:	8b 86 70 01 00 00    	mov    0x170(%esi),%eax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
c0011f22:	8b 96 68 01 00 00    	mov    0x168(%esi),%edx

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
c0011f28:	0f a3 c8             	bt     %ecx,%eax
c0011f2b:	73 10                	jae    c0011f3d <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x151>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
c0011f2d:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
c0011f32:	d3 c0                	rol    %cl,%eax
c0011f34:	f0 21 86 70 01 00 00 	lock and %eax,0x170(%esi)
c0011f3b:	eb 0c                	jmp    c0011f49 <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x15d>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
c0011f3d:	39 35 0c f0 ff cf    	cmp    %esi,0xcffff00c
c0011f43:	0f 84 a2 00 00 00    	je     c0011feb <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x1ff>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c0011f49:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c0011f4e:	83 c9 ff             	or     $0xffffffff,%ecx
c0011f51:	f0 0f c1 48 48       	lock xadd %ecx,0x48(%eax)
                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
c0011f56:	49                   	dec    %ecx
c0011f57:	75 25                	jne    c0011f7e <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x192>
                assert (current != this);
c0011f59:	8b 3d 0c f0 ff cf    	mov    0xcffff00c,%edi
c0011f5f:	39 f7                	cmp    %esi,%edi
c0011f61:	75 1d                	jne    c0011f80 <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x194>
c0011f63:	68 5c 9d 01 c0       	push   $0xc0019d5c
c0011f68:	6a 5e                	push   $0x5e
c0011f6a:	68 18 73 01 c0       	push   $0xc0017318
c0011f6f:	68 87 73 01 c0       	push   $0xc0017387
c0011f74:	68 69 60 01 c0       	push   $0xc0016069
c0011f79:	e8 c8 f9 fe ff       	call   c0001946 <_ZN7Console5panicEPKcz>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
c0011f7e:	31 ff                	xor    %edi,%edi
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
c0011f80:	89 35 0c f0 ff cf    	mov    %esi,0xcffff00c
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0011f86:	8b 46 48             	mov    0x48(%esi),%eax
c0011f89:	85 c0                	test   %eax,%eax
c0011f8b:	74 0a                	je     c0011f97 <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x1ab>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0011f8d:	8d 48 01             	lea    0x1(%eax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c0011f90:	f0 0f b1 4e 48       	lock cmpxchg %ecx,0x48(%esi)
c0011f95:	75 ef                	jne    c0011f86 <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x19a>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
c0011f97:	31 ed                	xor    %ebp,%ebp
c0011f99:	a1 04 f0 ff cf       	mov    0xcffff004,%eax
c0011f9e:	f6 05 0a f7 ff cf 02 	testb  $0x2,0xcffff70a
c0011fa5:	0f 44 d5             	cmove  %ebp,%edx
c0011fa8:	0b 54 86 54          	or     0x54(%esi,%eax,4),%edx
c0011fac:	0f 22 da             	mov    %edx,%cr3

            if (del_pd)
c0011faf:	85 ff                	test   %edi,%edi
c0011fb1:	74 38                	je     c0011feb <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x1ff>
                delete del_pd;
c0011fb3:	89 f8                	mov    %edi,%eax

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c0011fb5:	89 ee                	mov    %ebp,%esi
            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);

            if (del_pd)
                delete del_pd;
c0011fb7:	e8 2c aa ff ff       	call   c000c9e8 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c0011fbc:	8b 57 28             	mov    0x28(%edi),%edx
c0011fbf:	85 d2                	test   %edx,%edx
c0011fc1:	8d 82 78 fe ff ff    	lea    -0x188(%edx),%eax
c0011fc7:	0f 45 f0             	cmovne %eax,%esi

            pd_del->quota.free_up(pd_to->quota);
c0011fca:	81 c6 90 01 00 00    	add    $0x190,%esi
c0011fd0:	8d 87 90 01 00 00    	lea    0x190(%edi),%eax
c0011fd6:	89 f2                	mov    %esi,%edx
c0011fd8:	e8 ef 09 ff ff       	call   c00029cc <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
c0011fdd:	89 f1                	mov    %esi,%ecx
c0011fdf:	89 fa                	mov    %edi,%edx
c0011fe1:	b8 64 b4 01 c0       	mov    $0xc001b464,%eax
c0011fe6:	e8 75 e3 ff ff       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>

            pd->make_current();

            asm volatile ("mov %0," EXPAND (PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory"); UNREACHED;
c0011feb:	8b 43 50             	mov    0x50(%ebx),%eax
c0011fee:	bc 00 e0 ff cf       	mov    $0xcfffe000,%esp
c0011ff3:	ff e0                	jmp    *%eax
        ec->make_current();
    }

    ec->help (send_msg<C>);
c0011ff5:	ba ec 1d 01 c0       	mov    $0xc0011dec,%edx
c0011ffa:	89 d8                	mov    %ebx,%eax
c0011ffc:	e8 9d 64 ff ff       	call   c000849e <_ZN2Ec4helpEPFvvE>

    die ("IPC Timeout");
c0012001:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0012006:	8d 50 54             	lea    0x54(%eax),%edx
c0012009:	b8 f8 97 01 c0       	mov    $0xc00197f8,%eax
c001200e:	e9 2a fe ff ff       	jmp    c0011e3d <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x51>
c0012013:	90                   	nop

c0012014 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE2ELb0EEEvv>:
#include "syscall.hpp"
#include "utcb.hpp"
#include "vectors.hpp"

template <Sys_regs::Status S, bool T>
void Ec::sys_finish()
c0012014:	53                   	push   %ebx
c0012015:	50                   	push   %eax
{
    if (T)
        current->clr_timeout();

    current->regs.set_status (S);
c0012016:	a1 08 f0 ff cf       	mov    0xcffff008,%eax

    if (current->xcpu_sm)
c001201b:	83 b8 f4 00 00 00 00 	cmpl   $0x0,0xf4(%eax)

        ALWAYS_INLINE
        inline void set_status (Status s, bool c = true)
        {
            if (c)
                ARG_1 = s;
c0012022:	c7 40 70 02 00 00 00 	movl   $0x2,0x70(%eax)
c0012029:	74 05                	je     c0012030 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE2ELb0EEEvv+0x1c>
        xcpu_return();
c001202b:	e8 5e 20 ff ff       	call   c000408e <_ZN2Ec11xcpu_returnEv>

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
c0012030:	8b 1d 0c f0 ff cf    	mov    0xcffff00c,%ebx
c0012036:	31 d2                	xor    %edx,%edx
c0012038:	8d 83 90 01 00 00    	lea    0x190(%ebx),%eax
c001203e:	e8 7b f4 ff ff       	call   c00114be <_ZN5Quota9hit_limitEm>
c0012043:	84 c0                	test   %al,%al
c0012045:	75 05                	jne    c001204c <_ZN2Ec10sys_finishILN8Sys_regs6StatusE2ELb0EEEvv+0x38>
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());

    ret_user_sysexit();
c0012047:	e8 b4 df fe ff       	call   c0000000 <_ZN2Ec16ret_user_sysexitEv>

    if (current->xcpu_sm)
        xcpu_return();

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());
c001204c:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c0012050:	ff b3 9c 01 00 00    	pushl  0x19c(%ebx)
c0012056:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c001205b:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c0012060:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0012065:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c001206c:	ff b3 94 01 00 00    	pushl  0x194(%ebx)
c0012072:	50                   	push   %eax
c0012073:	68 4c 97 01 c0       	push   $0xc001974c
c0012078:	e8 61 f9 fe ff       	call   c00019de <_ZN7Console5printEPKcz>
c001207d:	83 c4 10             	add    $0x10,%esp
c0012080:	eb c5                	jmp    c0012047 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE2ELb0EEEvv+0x33>

c0012082 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE1ELb0EEEvv>:
#include "syscall.hpp"
#include "utcb.hpp"
#include "vectors.hpp"

template <Sys_regs::Status S, bool T>
void Ec::sys_finish()
c0012082:	53                   	push   %ebx
c0012083:	50                   	push   %eax
{
    if (T)
        current->clr_timeout();

    current->regs.set_status (S);
c0012084:	a1 08 f0 ff cf       	mov    0xcffff008,%eax

    if (current->xcpu_sm)
c0012089:	83 b8 f4 00 00 00 00 	cmpl   $0x0,0xf4(%eax)
c0012090:	c7 40 70 01 00 00 00 	movl   $0x1,0x70(%eax)
c0012097:	74 05                	je     c001209e <_ZN2Ec10sys_finishILN8Sys_regs6StatusE1ELb0EEEvv+0x1c>
        xcpu_return();
c0012099:	e8 f0 1f ff ff       	call   c000408e <_ZN2Ec11xcpu_returnEv>

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
c001209e:	8b 1d 0c f0 ff cf    	mov    0xcffff00c,%ebx
c00120a4:	31 d2                	xor    %edx,%edx
c00120a6:	8d 83 90 01 00 00    	lea    0x190(%ebx),%eax
c00120ac:	e8 0d f4 ff ff       	call   c00114be <_ZN5Quota9hit_limitEm>
c00120b1:	84 c0                	test   %al,%al
c00120b3:	75 05                	jne    c00120ba <_ZN2Ec10sys_finishILN8Sys_regs6StatusE1ELb0EEEvv+0x38>
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());

    ret_user_sysexit();
c00120b5:	e8 46 df fe ff       	call   c0000000 <_ZN2Ec16ret_user_sysexitEv>

    if (current->xcpu_sm)
        xcpu_return();

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());
c00120ba:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c00120be:	ff b3 9c 01 00 00    	pushl  0x19c(%ebx)
c00120c4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c00120c9:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c00120ce:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00120d3:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c00120da:	ff b3 94 01 00 00    	pushl  0x194(%ebx)
c00120e0:	50                   	push   %eax
c00120e1:	68 4c 97 01 c0       	push   $0xc001974c
c00120e6:	e8 f3 f8 fe ff       	call   c00019de <_ZN7Console5printEPKcz>
c00120eb:	83 c4 10             	add    $0x10,%esp
c00120ee:	eb c5                	jmp    c00120b5 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE1ELb0EEEvv+0x33>

c00120f0 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>:
#include "syscall.hpp"
#include "utcb.hpp"
#include "vectors.hpp"

template <Sys_regs::Status S, bool T>
void Ec::sys_finish()
c00120f0:	53                   	push   %ebx
c00120f1:	50                   	push   %eax
{
    if (T)
        current->clr_timeout();

    current->regs.set_status (S);
c00120f2:	a1 08 f0 ff cf       	mov    0xcffff008,%eax

    if (current->xcpu_sm)
c00120f7:	83 b8 f4 00 00 00 00 	cmpl   $0x0,0xf4(%eax)
c00120fe:	c7 40 70 04 00 00 00 	movl   $0x4,0x70(%eax)
c0012105:	74 05                	je     c001210c <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv+0x1c>
        xcpu_return();
c0012107:	e8 82 1f ff ff       	call   c000408e <_ZN2Ec11xcpu_returnEv>

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
c001210c:	8b 1d 0c f0 ff cf    	mov    0xcffff00c,%ebx
c0012112:	31 d2                	xor    %edx,%edx
c0012114:	8d 83 90 01 00 00    	lea    0x190(%ebx),%eax
c001211a:	e8 9f f3 ff ff       	call   c00114be <_ZN5Quota9hit_limitEm>
c001211f:	84 c0                	test   %al,%al
c0012121:	75 05                	jne    c0012128 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv+0x38>
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());

    ret_user_sysexit();
c0012123:	e8 d8 de fe ff       	call   c0000000 <_ZN2Ec16ret_user_sysexitEv>

    if (current->xcpu_sm)
        xcpu_return();

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());
c0012128:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c001212c:	ff b3 9c 01 00 00    	pushl  0x19c(%ebx)
c0012132:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0012137:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c001213c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0012141:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0012148:	ff b3 94 01 00 00    	pushl  0x194(%ebx)
c001214e:	50                   	push   %eax
c001214f:	68 4c 97 01 c0       	push   $0xc001974c
c0012154:	e8 85 f8 fe ff       	call   c00019de <_ZN7Console5printEPKcz>
c0012159:	83 c4 10             	add    $0x10,%esp
c001215c:	eb c5                	jmp    c0012123 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv+0x33>

c001215e <_ZN2Ec10sys_revokeEv>:

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_revoke()
{
c001215e:	57                   	push   %edi
c001215f:	56                   	push   %esi
c0012160:	53                   	push   %ebx
c0012161:	50                   	push   %eax
    Sys_revoke *r = static_cast<Sys_revoke *>(current->sys_regs());
c0012162:	8b 1d 08 f0 ff cf    	mov    0xcffff008,%ebx

    trace (TRACE_SYSCALL, "EC:%p SYS_REVOKE", current);

    Pd * pd = Pd::current;
c0012168:	8b 35 0c f0 ff cf    	mov    0xcffff00c,%esi

    if (current->cont != sys_revoke) {
c001216e:	81 7b 50 5e 21 01 c0 	cmpl   $0xc001215e,0x50(%ebx)
c0012175:	74 78                	je     c00121ef <_ZN2Ec10sys_revokeEv+0x91>
        if (r->remote()) {
c0012177:	f6 43 70 20          	testb  $0x20,0x70(%ebx)
c001217b:	74 61                	je     c00121de <_ZN2Ec10sys_revokeEv+0x80>
c001217d:	8b 4b 58             	mov    0x58(%ebx),%ecx
c0012180:	89 c8                	mov    %ecx,%eax
c0012182:	25 ff ff ff 07       	and    $0x7ffffff,%eax
c0012187:	8b 14 85 00 00 00 e0 	mov    -0x20000000(,%eax,4),%edx
c001218e:	83 e2 e0             	and    $0xffffffe0,%edx
c0012191:	85 d2                	test   %edx,%edx
c0012193:	89 d6                	mov    %edx,%esi
c0012195:	74 06                	je     c001219d <_ZN2Ec10sys_revokeEv+0x3f>
            Capability cap = Space_obj::lookup (r->pd());
            if (EXPECT_FALSE (cap.obj()->type() != Kobject::PD)) {
c0012197:	80 7a 44 00          	cmpb   $0x0,0x44(%edx)
c001219b:	74 3a                	je     c00121d7 <_ZN2Ec10sys_revokeEv+0x79>
                trace (TRACE_ERROR, "%s: Bad PD CAP (%#lx)", __func__, r->pd());
c001219d:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c00121a1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c00121a6:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c00121ab:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00121b0:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c00121b7:	51                   	push   %ecx
c00121b8:	68 44 9c 01 c0       	push   $0xc0019c44
c00121bd:	50                   	push   %eax
c00121be:	68 04 98 01 c0       	push   $0xc0019804
c00121c3:	e8 16 f8 fe ff       	call   c00019de <_ZN7Console5printEPKcz>
                sys_finish<Sys_regs::BAD_CAP>();
c00121c8:	e8 23 ff ff ff       	call   c00120f0 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>
c00121cd:	8d 48 01             	lea    0x1(%eax),%ecx
c00121d0:	f0 0f b1 4a 48       	lock cmpxchg %ecx,0x48(%edx)
c00121d5:	74 07                	je     c00121de <_ZN2Ec10sys_revokeEv+0x80>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c00121d7:	8b 42 48             	mov    0x48(%edx),%eax
c00121da:	85 c0                	test   %eax,%eax
c00121dc:	75 ef                	jne    c00121cd <_ZN2Ec10sys_revokeEv+0x6f>
            }
            pd = static_cast<Pd *>(cap.obj());
            pd->add_ref();
        }
        current->cont = sys_revoke;
c00121de:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c00121e3:	c7 40 50 5e 21 01 c0 	movl   $0xc001215e,0x50(%eax)
        inline mword pd() const { return ARG_3; }

        ALWAYS_INLINE
        inline mword sm() const { return ARG_1 >> 8; }

        inline void rem(Pd * p) { ARG_3 = reinterpret_cast<mword>(p); }
c00121ea:	89 73 58             	mov    %esi,0x58(%ebx)
c00121ed:	eb 03                	jmp    c00121f2 <_ZN2Ec10sys_revokeEv+0x94>

        r->rem(pd);
    } else
        pd = reinterpret_cast<Pd *>(r->pd());
c00121ef:	8b 73 58             	mov    0x58(%ebx),%esi
            BAD_DEV,
            QUO_OOM,
        };

        ALWAYS_INLINE
        inline unsigned flags() const { return ARG_1 >> 4 & 0xf; }
c00121f2:	8b 43 70             	mov    0x70(%ebx),%eax
c00121f5:	8b 53 54             	mov    0x54(%ebx),%edx
c00121f8:	89 c1                	mov    %eax,%ecx

        ALWAYS_INLINE
        inline bool remote() const { return flags() & 0x2; }

        ALWAYS_INLINE
        inline bool keep() const { return flags() & 0x4; }
c00121fa:	c1 e8 06             	shr    $0x6,%eax
c00121fd:	83 e0 01             	and    $0x1,%eax

    pd->rev_crd (r->crd(), r->self(), true, r->keep());
c0012200:	50                   	push   %eax
c0012201:	89 f0                	mov    %esi,%eax
c0012203:	c1 e9 04             	shr    $0x4,%ecx
c0012206:	6a 01                	push   $0x1
    public:
        ALWAYS_INLINE
        inline Crd crd() const { return Crd (ARG_2); }

        ALWAYS_INLINE
        inline bool self() const { return flags() & 0x1; }
c0012208:	83 e1 01             	and    $0x1,%ecx
c001220b:	e8 56 a9 ff ff       	call   c000cb66 <_ZN2Pd7rev_crdE3Crdbbb>

    current->cont = sys_finish<Sys_regs::SUCCESS>;
c0012210:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0012215:	c7 40 50 d2 14 01 c0 	movl   $0xc00114d2,0x50(%eax)
    r->rem(nullptr);

    if (r->remote() && pd->del_ref()) {
c001221c:	f6 43 70 20          	testb  $0x20,0x70(%ebx)
        inline mword pd() const { return ARG_3; }

        ALWAYS_INLINE
        inline mword sm() const { return ARG_1 >> 8; }

        inline void rem(Pd * p) { ARG_3 = reinterpret_cast<mword>(p); }
c0012220:	c7 43 58 00 00 00 00 	movl   $0x0,0x58(%ebx)
c0012227:	5f                   	pop    %edi
c0012228:	58                   	pop    %eax
c0012229:	74 71                	je     c001229c <_ZN2Ec10sys_revokeEv+0x13e>
        }

        ALWAYS_INLINE
        inline bool del_ref()
        {
            return Atomic::sub (ref, 1U) == 0;
c001222b:	8d 56 48             	lea    0x48(%esi),%edx
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c001222e:	83 c8 ff             	or     $0xffffffff,%eax
c0012231:	f0 0f c1 02          	lock xadd %eax,(%edx)
c0012235:	48                   	dec    %eax
c0012236:	75 64                	jne    c001229c <_ZN2Ec10sys_revokeEv+0x13e>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0012238:	8b 46 48             	mov    0x48(%esi),%eax
c001223b:	85 c0                	test   %eax,%eax
c001223d:	74 09                	je     c0012248 <_ZN2Ec10sys_revokeEv+0xea>
                if (Atomic::cmp_swap (ref, r, r + 1))
c001223f:	8d 48 01             	lea    0x1(%eax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c0012242:	f0 0f b1 0a          	lock cmpxchg %ecx,(%edx)
c0012246:	75 f0                	jne    c0012238 <_ZN2Ec10sys_revokeEv+0xda>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
c0012248:	8b 56 14             	mov    0x14(%esi),%edx
        pd->add_ref();
        Rcu::call(pd);
c001224b:	8d 7e 0c             	lea    0xc(%esi),%edi
c001224e:	85 d2                	test   %edx,%edx
c0012250:	74 04                	je     c0012256 <_ZN2Ec10sys_revokeEv+0xf8>
                e->pre_func(e);
c0012252:	89 f8                	mov    %edi,%eax
c0012254:	ff d2                	call   *%edx
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
c0012256:	83 7e 0c 00          	cmpl   $0x0,0xc(%esi)
c001225a:	75 09                	jne    c0012265 <_ZN2Ec10sys_revokeEv+0x107>
c001225c:	a1 f0 f7 ff cf       	mov    0xcffff7f0,%eax
c0012261:	39 f8                	cmp    %edi,%eax
c0012263:	75 29                	jne    c001228e <_ZN2Ec10sys_revokeEv+0x130>
                trace (0, "warning: rcu element already enqueued");
c0012265:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c0012269:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c001226e:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c0012273:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0012278:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c001227f:	50                   	push   %eax
c0012280:	68 ae 6c 01 c0       	push   $0xc0016cae
c0012285:	e8 54 f7 fe ff       	call   c00019de <_ZN7Console5printEPKcz>
c001228a:	59                   	pop    %ecx
c001228b:	5e                   	pop    %esi
c001228c:	eb 0e                	jmp    c001229c <_ZN2Ec10sys_revokeEv+0x13e>
                return;
            }

            count ++;
c001228e:	ff 05 f4 f7 ff cf    	incl   0xcffff7f4

           *tail = e;
c0012294:	89 38                	mov    %edi,(%eax)
            tail = &e->next;
c0012296:	89 3d f0 f7 ff cf    	mov    %edi,0xcffff7f0

        ALWAYS_INLINE
        inline mword pd() const { return ARG_3; }

        ALWAYS_INLINE
        inline mword sm() const { return ARG_1 >> 8; }
c001229c:	8b 43 70             	mov    0x70(%ebx),%eax
    }

    if (EXPECT_FALSE (r->sm())) {
c001229f:	c1 e8 08             	shr    $0x8,%eax
c00122a2:	0f 84 06 01 00 00    	je     c00123ae <_ZN2Ec10sys_revokeEv+0x250>
        static unsigned const caps = (END_SPACE_LIM - SPC_LOCAL_OBJ) / sizeof (Capability);

        ALWAYS_INLINE
        static inline Capability lookup (unsigned long idx)
        {
            return *reinterpret_cast<Capability *>(idx_to_virt (idx));
c00122a8:	8b 04 85 00 00 00 e0 	mov    -0x20000000(,%eax,4),%eax
c00122af:	89 c6                	mov    %eax,%esi
c00122b1:	83 e6 e0             	and    $0xffffffe0,%esi
c00122b4:	0f 84 f4 00 00 00    	je     c00123ae <_ZN2Ec10sys_revokeEv+0x250>
        Capability cap_sm = Space_obj::lookup (r->sm());
        if (EXPECT_FALSE (cap_sm.obj()->type() == Kobject::SM && (cap_sm.prm() & 1))) {
c00122ba:	80 7e 44 04          	cmpb   $0x4,0x44(%esi)
c00122be:	0f 85 ea 00 00 00    	jne    c00123ae <_ZN2Ec10sys_revokeEv+0x250>
c00122c4:	a8 01                	test   $0x1,%al
c00122c6:	0f 84 e2 00 00 00    	je     c00123ae <_ZN2Ec10sys_revokeEv+0x250>
        }

        ALWAYS_INLINE
        inline void add_to_rcu()
        {
            Lock_guard <Spinlock> guard (lock);
c00122cc:	8d 46 46             	lea    0x46(%esi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c00122cf:	9c                   	pushf  
c00122d0:	5b                   	pop    %ebx
            return flags & 0x200;
c00122d1:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c00122d4:	80 e3 01             	and    $0x1,%bl
c00122d7:	74 2a                	je     c0012303 <_ZN2Ec10sys_revokeEv+0x1a5>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c00122d9:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c00122e0:	75 19                	jne    c00122fb <_ZN2Ec10sys_revokeEv+0x19d>
c00122e2:	68 c0 9d 01 c0       	push   $0xc0019dc0
c00122e7:	68 b7 00 00 00       	push   $0xb7
c00122ec:	68 12 61 01 c0       	push   $0xc0016112
c00122f1:	68 83 61 01 c0       	push   $0xc0016183
c00122f6:	e9 a1 00 00 00       	jmp    c001239c <_ZN2Ec10sys_revokeEv+0x23e>

            asm volatile ("cli" : : : "memory");
c00122fb:	fa                   	cli    
            preemption = false;
c00122fc:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c0012303:	e8 24 e8 fe ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
        }

        ALWAYS_INLINE
        inline void call_rcu(bool r = false)
        {
            if (ACCESS_ONCE(rcu))
c0012308:	8a 46 68             	mov    0x68(%esi),%al
c001230b:	84 c0                	test   %al,%al
c001230d:	75 69                	jne    c0012378 <_ZN2Ec10sys_revokeEv+0x21a>
                return;

            rcu = true;
c001230f:	c6 46 68 01          	movb   $0x1,0x68(%esi)
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0012313:	8b 46 48             	mov    0x48(%esi),%eax
c0012316:	85 c0                	test   %eax,%eax
c0012318:	74 0a                	je     c0012324 <_ZN2Ec10sys_revokeEv+0x1c6>
                if (Atomic::cmp_swap (ref, r, r + 1))
c001231a:	8d 50 01             	lea    0x1(%eax),%edx
c001231d:	f0 0f b1 56 48       	lock cmpxchg %edx,0x48(%esi)
c0012322:	75 ef                	jne    c0012313 <_ZN2Ec10sys_revokeEv+0x1b5>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
c0012324:	8b 56 14             	mov    0x14(%esi),%edx

            if (r)
                add_ref();

            Rcu::call (this);
c0012327:	8d 7e 0c             	lea    0xc(%esi),%edi
c001232a:	85 d2                	test   %edx,%edx
c001232c:	74 04                	je     c0012332 <_ZN2Ec10sys_revokeEv+0x1d4>
                e->pre_func(e);
c001232e:	89 f8                	mov    %edi,%eax
c0012330:	ff d2                	call   *%edx
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
c0012332:	83 7e 0c 00          	cmpl   $0x0,0xc(%esi)
c0012336:	75 09                	jne    c0012341 <_ZN2Ec10sys_revokeEv+0x1e3>
c0012338:	a1 f0 f7 ff cf       	mov    0xcffff7f0,%eax
c001233d:	39 f8                	cmp    %edi,%eax
c001233f:	75 29                	jne    c001236a <_ZN2Ec10sys_revokeEv+0x20c>
                trace (0, "warning: rcu element already enqueued");
c0012341:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c0012345:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c001234a:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c001234f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0012354:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c001235b:	50                   	push   %eax
c001235c:	68 ae 6c 01 c0       	push   $0xc0016cae
c0012361:	e8 78 f6 fe ff       	call   c00019de <_ZN7Console5printEPKcz>
c0012366:	58                   	pop    %eax
c0012367:	5a                   	pop    %edx
c0012368:	eb 0e                	jmp    c0012378 <_ZN2Ec10sys_revokeEv+0x21a>
                return;
            }

            count ++;
c001236a:	ff 05 f4 f7 ff cf    	incl   0xcffff7f4

           *tail = e;
c0012370:	89 38                	mov    %edi,(%eax)
            tail = &e->next;
c0012372:	89 3d f0 f7 ff cf    	mov    %edi,0xcffff7f0
c0012378:	fe 46 46             	incb   0x46(%esi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c001237b:	84 db                	test   %bl,%bl
c001237d:	74 2f                	je     c00123ae <_ZN2Ec10sys_revokeEv+0x250>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c001237f:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0012386:	74 1e                	je     c00123a6 <_ZN2Ec10sys_revokeEv+0x248>
c0012388:	68 80 9d 01 c0       	push   $0xc0019d80
c001238d:	68 c0 00 00 00       	push   $0xc0
c0012392:	68 12 61 01 c0       	push   $0xc0016112
c0012397:	68 82 61 01 c0       	push   $0xc0016182
c001239c:	68 69 60 01 c0       	push   $0xc0016069
c00123a1:	e8 a0 f5 fe ff       	call   c0001946 <_ZN7Console5panicEPKcz>

            preemption = true;
c00123a6:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c00123ad:	fb                   	sti    
            Sm *sm = static_cast<Sm *>(cap_sm.obj());
            sm->add_to_rcu();
        }
    }

    sys_finish<Sys_regs::SUCCESS>();
c00123ae:	e8 1f f1 ff ff       	call   c00114d2 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb0EEEvv>
c00123b3:	90                   	nop

c00123b4 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE9ELb0EEEvv>:
void Ec::sys_finish()
{
    if (T)
        current->clr_timeout();

    current->regs.set_status (S);
c00123b4:	a1 08 f0 ff cf       	mov    0xcffff008,%eax

    if (current->xcpu_sm)
c00123b9:	83 b8 f4 00 00 00 00 	cmpl   $0x0,0xf4(%eax)

        ALWAYS_INLINE
        inline void set_status (Status s, bool c = true)
        {
            if (c)
                ARG_1 = s;
c00123c0:	c7 40 70 09 00 00 00 	movl   $0x9,0x70(%eax)
c00123c7:	74 05                	je     c00123ce <_ZN2Ec10sys_finishILN8Sys_regs6StatusE9ELb0EEEvv+0x1a>
        xcpu_return();
c00123c9:	e8 c0 1c ff ff       	call   c000408e <_ZN2Ec11xcpu_returnEv>

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());

    ret_user_sysexit();
c00123ce:	e8 2d dc fe ff       	call   c0000000 <_ZN2Ec16ret_user_sysexitEv>
c00123d3:	90                   	nop

c00123d4 <_ZN2Ec13sys_create_ptEv>:

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_create_pt()
{
c00123d4:	55                   	push   %ebp
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
c00123d5:	31 d2                	xor    %edx,%edx

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_create_pt()
{
c00123d7:	57                   	push   %edi
c00123d8:	56                   	push   %esi
c00123d9:	53                   	push   %ebx
c00123da:	83 ec 10             	sub    $0x10,%esp
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
c00123dd:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c00123e2:	05 90 01 00 00       	add    $0x190,%eax
c00123e7:	e8 d2 f0 ff ff       	call   c00114be <_ZN5Quota9hit_limitEm>
c00123ec:	84 c0                	test   %al,%al
c00123ee:	74 05                	je     c00123f5 <_ZN2Ec13sys_create_ptEv+0x21>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu (%lu)", __func__, __LINE__, Pd::current->quota.usage(), Pd::current->quota.limit(), r);

        if (Ec::current->pt_oom && call)
            Ec::current->oom_call_cpu (Ec::current->pt_oom, Ec::current->pt_oom->id, C, C);

        sys_finish<Sys_regs::QUO_OOM>();
c00123f0:	e8 bf ff ff ff       	call   c00123b4 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE9ELb0EEEvv>

void Ec::sys_create_pt()
{
    check<sys_create_pt>(0, false);

    Sys_create_pt *r = static_cast<Sys_create_pt *>(current->sys_regs());
c00123f5:	8b 35 08 f0 ff cf    	mov    0xcffff008,%esi
c00123fb:	8d 5c 24 0b          	lea    0xb(%esp),%ebx
c00123ff:	8b 4e 54             	mov    0x54(%esi),%ecx
{
    private:
        ALWAYS_INLINE
        static inline mword idx_to_virt (unsigned long idx)
        {
            return SPC_LOCAL_OBJ + (idx % caps) * sizeof (Capability);
c0012402:	89 c8                	mov    %ecx,%eax
c0012404:	25 ff ff ff 07       	and    $0x7ffffff,%eax
        static unsigned const caps = (END_SPACE_LIM - SPC_LOCAL_OBJ) / sizeof (Capability);

        ALWAYS_INLINE
        static inline Capability lookup (unsigned long idx)
        {
            return *reinterpret_cast<Capability *>(idx_to_virt (idx));
c0012409:	8b 04 85 00 00 00 e0 	mov    -0x20000000(,%eax,4),%eax
c0012410:	89 c2                	mov    %eax,%edx
c0012412:	83 e2 e0             	and    $0xffffffe0,%edx
c0012415:	74 0a                	je     c0012421 <_ZN2Ec13sys_create_ptEv+0x4d>

    trace (TRACE_SYSCALL, "EC:%p SYS_CREATE PT:%#lx EC:%#lx EIP:%#lx", current, r->sel(), r->ec(), r->eip());

    Capability cap = Space_obj::lookup (r->pd());
    if (EXPECT_FALSE (cap.obj()->type() != Kobject::PD) || !(cap.prm() & 1UL << Kobject::PT)) {
c0012417:	80 7a 44 00          	cmpb   $0x0,0x44(%edx)
c001241b:	75 04                	jne    c0012421 <_ZN2Ec13sys_create_ptEv+0x4d>
c001241d:	a8 08                	test   $0x8,%al
c001241f:	75 26                	jne    c0012447 <_ZN2Ec13sys_create_ptEv+0x73>
        trace (TRACE_ERROR, "%s: Non-PD CAP (%#lx)", __func__, r->pd());
c0012421:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
c0012427:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c001242c:	81 fb 00 d0 ff cf    	cmp    $0xcfffd000,%ebx
c0012432:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0012439:	51                   	push   %ecx
c001243a:	68 60 9c 01 c0       	push   $0xc0019c60
c001243f:	50                   	push   %eax
c0012440:	68 21 98 01 c0       	push   $0xc0019821
c0012445:	eb 5c                	jmp    c00124a3 <_ZN2Ec13sys_create_ptEv+0xcf>
        sys_finish<Sys_regs::BAD_CAP>();
    }
    Pd *pd = static_cast<Pd *>(cap.obj());

    if (pd->quota.hit_limit(2)) {
c0012447:	8d aa 90 01 00 00    	lea    0x190(%edx),%ebp
c001244d:	ba 02 00 00 00       	mov    $0x2,%edx
c0012452:	89 e8                	mov    %ebp,%eax
c0012454:	e8 65 f0 ff ff       	call   c00114be <_ZN5Quota9hit_limitEm>
c0012459:	84 c0                	test   %al,%al
c001245b:	75 93                	jne    c00123f0 <_ZN2Ec13sys_create_ptEv+0x1c>
c001245d:	8b 56 58             	mov    0x58(%esi),%edx
{
    private:
        ALWAYS_INLINE
        static inline mword idx_to_virt (unsigned long idx)
        {
            return SPC_LOCAL_OBJ + (idx % caps) * sizeof (Capability);
c0012460:	89 d0                	mov    %edx,%eax
c0012462:	25 ff ff ff 07       	and    $0x7ffffff,%eax
        static unsigned const caps = (END_SPACE_LIM - SPC_LOCAL_OBJ) / sizeof (Capability);

        ALWAYS_INLINE
        static inline Capability lookup (unsigned long idx)
        {
            return *reinterpret_cast<Capability *>(idx_to_virt (idx));
c0012467:	8b 04 85 00 00 00 e0 	mov    -0x20000000(,%eax,4),%eax
c001246e:	89 c7                	mov    %eax,%edi
c0012470:	83 e7 e0             	and    $0xffffffe0,%edi
c0012473:	74 0a                	je     c001247f <_ZN2Ec13sys_create_ptEv+0xab>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu", __func__, __LINE__, pd->quota.usage(), pd->quota.limit());
        sys_finish<Sys_regs::QUO_OOM>();
    }

    Capability cap_ec = Space_obj::lookup (r->ec());
    if (EXPECT_FALSE (cap_ec.obj()->type() != Kobject::EC) || !(cap_ec.prm() & 1UL << Kobject::PT)) {
c0012475:	80 7f 44 01          	cmpb   $0x1,0x44(%edi)
c0012479:	75 04                	jne    c001247f <_ZN2Ec13sys_create_ptEv+0xab>
c001247b:	a8 08                	test   $0x8,%al
c001247d:	75 2e                	jne    c00124ad <_ZN2Ec13sys_create_ptEv+0xd9>
        trace (TRACE_ERROR, "%s: Non-EC CAP (%#lx)", __func__, r->ec());
c001247f:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
c0012485:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c001248a:	81 fb 00 d0 ff cf    	cmp    $0xcfffd000,%ebx
c0012490:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0012497:	52                   	push   %edx
c0012498:	68 60 9c 01 c0       	push   $0xc0019c60
c001249d:	50                   	push   %eax
c001249e:	68 3e 98 01 c0       	push   $0xc001983e
c00124a3:	e8 36 f5 fe ff       	call   c00019de <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_CAP>();
c00124a8:	e8 43 fc ff ff       	call   c00120f0 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>
    }
    Ec *ec = static_cast<Ec *>(cap_ec.obj());

    if (EXPECT_FALSE (ec->glb)) {
c00124ad:	66 83 bf ce 00 00 00 	cmpw   $0x0,0xce(%edi)
c00124b4:	00 
c00124b5:	74 2d                	je     c00124e4 <_ZN2Ec13sys_create_ptEv+0x110>
        trace (TRACE_ERROR, "%s: Cannot bind PT", __func__);
c00124b7:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
c00124bd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00124c2:	81 fb 00 d0 ff cf    	cmp    $0xcfffd000,%ebx
c00124c8:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c00124cf:	68 60 9c 01 c0       	push   $0xc0019c60
c00124d4:	50                   	push   %eax
c00124d5:	68 5b 98 01 c0       	push   $0xc001985b
c00124da:	e8 ff f4 fe ff       	call   c00019de <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_CAP>();
c00124df:	e8 0c fc ff ff       	call   c00120f0 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>
    }

    Pt *pt = new (pd->quota) Pt (Pd::current, r->sel(), ec, r->mtd(), r->eip());
c00124e4:	8b 46 64             	mov    0x64(%esi),%eax

        ALWAYS_INLINE
        inline void set_id (mword i) { id = i; }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
c00124e7:	89 ea                	mov    %ebp,%edx

class Sys_create_pt : public Sys_regs
{
    public:
        ALWAYS_INLINE
        inline unsigned long sel() const { return ARG_1 >> 8; }
c00124e9:	8b 4e 70             	mov    0x70(%esi),%ecx
c00124ec:	89 44 24 04          	mov    %eax,0x4(%esp)
c00124f0:	8b 46 5c             	mov    0x5c(%esi),%eax
c00124f3:	c1 e9 08             	shr    $0x8,%ecx
c00124f6:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c00124fa:	89 04 24             	mov    %eax,(%esp)
c00124fd:	b8 7c b4 01 c0       	mov    $0xc001b47c,%eax
c0012502:	e8 6f dd ff ff       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c0012507:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c001250d:	ff 34 24             	pushl  (%esp)
c0012510:	ff 74 24 08          	pushl  0x8(%esp)
c0012514:	89 c3                	mov    %eax,%ebx
c0012516:	57                   	push   %edi
c0012517:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c001251b:	e8 0a b3 ff ff       	call   c000d82a <_ZN2PtC1EP2PdmP2Ec3Mtdm>
    if (!Space_obj::insert_root (pd->quota, pt)) {
c0012520:	89 da                	mov    %ebx,%edx
c0012522:	89 e8                	mov    %ebp,%eax
c0012524:	e8 93 eb ff ff       	call   c00110bc <_ZN9Space_obj11insert_rootER5QuotaP7Kobject>
c0012529:	83 c4 0c             	add    $0xc,%esp
c001252c:	84 c0                	test   %al,%al
c001252e:	75 7e                	jne    c00125ae <_ZN2Ec13sys_create_ptEv+0x1da>
c0012530:	8b 56 70             	mov    0x70(%esi),%edx
        trace (TRACE_ERROR, "%s: Non-NULL CAP (%#lx)", __func__, r->sel());
c0012533:	8d 44 24 0b          	lea    0xb(%esp),%eax
c0012537:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c001253c:	c1 ea 08             	shr    $0x8,%edx
c001253f:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c0012544:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0012549:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0012550:	52                   	push   %edx
c0012551:	68 60 9c 01 c0       	push   $0xc0019c60
c0012556:	50                   	push   %eax
c0012557:	68 75 98 01 c0       	push   $0xc0019875
c001255c:	e8 7d f4 fe ff       	call   c00019de <_ZN7Console5printEPKcz>
        inline Refptr (T *p) : ptr (p->add_ref() ? p : nullptr) {}

        ALWAYS_INLINE
        inline ~Refptr()
        {
            if (ptr && ptr->del_ref())
c0012561:	8b 43 4c             	mov    0x4c(%ebx),%eax
c0012564:	83 c4 10             	add    $0x10,%esp
c0012567:	85 c0                	test   %eax,%eax
c0012569:	74 30                	je     c001259b <_ZN2Ec13sys_create_ptEv+0x1c7>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c001256b:	83 ca ff             	or     $0xffffffff,%edx
c001256e:	f0 0f c1 50 48       	lock xadd %edx,0x48(%eax)
c0012573:	4a                   	dec    %edx
c0012574:	75 25                	jne    c001259b <_ZN2Ec13sys_create_ptEv+0x1c7>
                delete ptr;
c0012576:	8b 43 4c             	mov    0x4c(%ebx),%eax
c0012579:	85 c0                	test   %eax,%eax
c001257b:	74 1e                	je     c001259b <_ZN2Ec13sys_create_ptEv+0x1c7>
c001257d:	e8 8c 0f ff ff       	call   c000350e <_ZN2EcD1Ev>
c0012582:	8b 53 4c             	mov    0x4c(%ebx),%edx

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c0012585:	8b 82 b8 00 00 00    	mov    0xb8(%edx),%eax
c001258b:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c0012591:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c0012596:	e8 c5 dd ff ff       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>

        ALWAYS_INLINE
        static inline void destroy(Pt *obj, Quota &quota) { obj->~Pt(); cache.free (obj, quota); }
c001259b:	89 e9                	mov    %ebp,%ecx
c001259d:	89 da                	mov    %ebx,%edx
c001259f:	b8 7c b4 01 c0       	mov    $0xc001b47c,%eax
c00125a4:	e8 b7 dd ff ff       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
        Pt::destroy (pt, pd->quota);
        sys_finish<Sys_regs::BAD_CAP>();
c00125a9:	e8 42 fb ff ff       	call   c00120f0 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>
    }

    sys_finish<Sys_regs::SUCCESS>();
c00125ae:	e8 1f ef ff ff       	call   c00114d2 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb0EEEvv>
c00125b3:	90                   	nop

c00125b4 <_ZN2Ec13sys_create_smEv>:
}

void Ec::sys_create_sm()
{
c00125b4:	55                   	push   %ebp
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
c00125b5:	31 d2                	xor    %edx,%edx

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_create_sm()
{
c00125b7:	57                   	push   %edi
c00125b8:	56                   	push   %esi
c00125b9:	53                   	push   %ebx
c00125ba:	83 ec 0c             	sub    $0xc,%esp
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
c00125bd:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c00125c2:	05 90 01 00 00       	add    $0x190,%eax
c00125c7:	e8 f2 ee ff ff       	call   c00114be <_ZN5Quota9hit_limitEm>
c00125cc:	84 c0                	test   %al,%al
c00125ce:	74 05                	je     c00125d5 <_ZN2Ec13sys_create_smEv+0x21>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu (%lu)", __func__, __LINE__, Pd::current->quota.usage(), Pd::current->quota.limit(), r);

        if (Ec::current->pt_oom && call)
            Ec::current->oom_call_cpu (Ec::current->pt_oom, Ec::current->pt_oom->id, C, C);

        sys_finish<Sys_regs::QUO_OOM>();
c00125d0:	e8 df fd ff ff       	call   c00123b4 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE9ELb0EEEvv>

void Ec::sys_create_sm()
{
    check<sys_create_sm>(0, false);

    Sys_create_sm *r = static_cast<Sys_create_sm *>(current->sys_regs());
c00125d5:	8b 35 08 f0 ff cf    	mov    0xcffff008,%esi
c00125db:	8b 56 54             	mov    0x54(%esi),%edx
{
    private:
        ALWAYS_INLINE
        static inline mword idx_to_virt (unsigned long idx)
        {
            return SPC_LOCAL_OBJ + (idx % caps) * sizeof (Capability);
c00125de:	89 d0                	mov    %edx,%eax
c00125e0:	25 ff ff ff 07       	and    $0x7ffffff,%eax
        static unsigned const caps = (END_SPACE_LIM - SPC_LOCAL_OBJ) / sizeof (Capability);

        ALWAYS_INLINE
        static inline Capability lookup (unsigned long idx)
        {
            return *reinterpret_cast<Capability *>(idx_to_virt (idx));
c00125e5:	8b 04 85 00 00 00 e0 	mov    -0x20000000(,%eax,4),%eax
c00125ec:	89 c3                	mov    %eax,%ebx
c00125ee:	83 e3 e0             	and    $0xffffffe0,%ebx
c00125f1:	74 0a                	je     c00125fd <_ZN2Ec13sys_create_smEv+0x49>

    trace (TRACE_SYSCALL, "EC:%p SYS_CREATE SM:%#lx CNT:%lu", current, r->sel(), r->cnt());

    Capability cap = Space_obj::lookup (r->pd());
    if (EXPECT_FALSE (cap.obj()->type() != Kobject::PD) || !(cap.prm() & 1UL << Kobject::SM)) {
c00125f3:	80 7b 44 00          	cmpb   $0x0,0x44(%ebx)
c00125f7:	75 04                	jne    c00125fd <_ZN2Ec13sys_create_smEv+0x49>
c00125f9:	a8 10                	test   $0x10,%al
c00125fb:	75 28                	jne    c0012625 <_ZN2Ec13sys_create_smEv+0x71>
        trace (TRACE_ERROR, "%s: Non-PD CAP (%#lx)", __func__, r->pd());
c00125fd:	8d 44 24 07          	lea    0x7(%esp),%eax
c0012601:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0012606:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c001260b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0012610:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0012617:	52                   	push   %edx
c0012618:	68 50 9c 01 c0       	push   $0xc0019c50
c001261d:	50                   	push   %eax
c001261e:	68 21 98 01 c0       	push   $0xc0019821
c0012623:	eb 63                	jmp    c0012688 <_ZN2Ec13sys_create_smEv+0xd4>
        sys_finish<Sys_regs::BAD_CAP>();
    }
    Pd *pd = static_cast<Pd *>(cap.obj());

    if (pd->quota.hit_limit(1)) {
c0012625:	81 c3 90 01 00 00    	add    $0x190,%ebx
c001262b:	ba 01 00 00 00       	mov    $0x1,%edx
c0012630:	89 d8                	mov    %ebx,%eax
c0012632:	e8 87 ee ff ff       	call   c00114be <_ZN5Quota9hit_limitEm>
c0012637:	84 c0                	test   %al,%al
c0012639:	75 95                	jne    c00125d0 <_ZN2Ec13sys_create_smEv+0x1c>
c001263b:	8b 46 64             	mov    0x64(%esi),%eax
        sys_finish<Sys_regs::QUO_OOM>();
    }

    Sm * sm;

    if (r->sm()) {
c001263e:	85 c0                	test   %eax,%eax
c0012640:	0f 84 a6 00 00 00    	je     c00126ec <_ZN2Ec13sys_create_smEv+0x138>
{
    private:
        ALWAYS_INLINE
        static inline mword idx_to_virt (unsigned long idx)
        {
            return SPC_LOCAL_OBJ + (idx % caps) * sizeof (Capability);
c0012646:	89 c2                	mov    %eax,%edx
c0012648:	81 e2 ff ff ff 07    	and    $0x7ffffff,%edx
c001264e:	8b 2c 95 00 00 00 e0 	mov    -0x20000000(,%edx,4),%ebp
c0012655:	83 e5 e0             	and    $0xffffffe0,%ebp
c0012658:	74 06                	je     c0012660 <_ZN2Ec13sys_create_smEv+0xac>
        /* check for valid SM to be chained with */
        Capability cap_si = Space_obj::lookup (r->sm());
        if (EXPECT_FALSE (cap_si.obj()->type() != Kobject::SM)) {
c001265a:	80 7d 44 04          	cmpb   $0x4,0x44(%ebp)
c001265e:	74 32                	je     c0012692 <_ZN2Ec13sys_create_smEv+0xde>
            trace (TRACE_ERROR, "%s: Non-SM CAP (%#lx)", __func__, r->sm());
c0012660:	8d 54 24 07          	lea    0x7(%esp),%edx
c0012664:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c001266a:	81 fa 00 d0 ff cf    	cmp    $0xcfffd000,%edx
c0012670:	ba ff ff ff ff       	mov    $0xffffffff,%edx
c0012675:	0f 44 15 04 f0 ff cf 	cmove  0xcffff004,%edx
c001267c:	50                   	push   %eax
c001267d:	68 50 9c 01 c0       	push   $0xc0019c50
c0012682:	52                   	push   %edx
c0012683:	68 94 98 01 c0       	push   $0xc0019894
c0012688:	e8 51 f3 fe ff       	call   c00019de <_ZN7Console5printEPKcz>
            sys_finish<Sys_regs::BAD_CAP>();
c001268d:	e8 5e fa ff ff       	call   c00120f0 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>
        }

        Sm * si = static_cast<Sm *>(cap_si.obj());
        if (si->is_signal()) {
c0012692:	83 7d 54 00          	cmpl   $0x0,0x54(%ebp)
c0012696:	74 2a                	je     c00126c2 <_ZN2Ec13sys_create_smEv+0x10e>
            /* limit chaining to solely one level */
            trace (TRACE_ERROR, "%s: SM CAP (%#lx) is signal", __func__, r->sm());
c0012698:	8d 54 24 07          	lea    0x7(%esp),%edx
c001269c:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c00126a2:	81 fa 00 d0 ff cf    	cmp    $0xcfffd000,%edx
c00126a8:	ba ff ff ff ff       	mov    $0xffffffff,%edx
c00126ad:	0f 44 15 04 f0 ff cf 	cmove  0xcffff004,%edx
c00126b4:	50                   	push   %eax
c00126b5:	68 50 9c 01 c0       	push   $0xc0019c50
c00126ba:	52                   	push   %edx
c00126bb:	68 b1 98 01 c0       	push   $0xc00198b1
c00126c0:	eb c6                	jmp    c0012688 <_ZN2Ec13sys_create_smEv+0xd4>
c00126c2:	8b 46 58             	mov    0x58(%esi),%eax

            call_rcu(true);
        }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
c00126c5:	89 da                	mov    %ebx,%edx

class Sys_create_sm : public Sys_regs
{
    public:
        ALWAYS_INLINE
        inline unsigned long sel() const { return ARG_1 >> 8; }
c00126c7:	8b 4e 70             	mov    0x70(%esi),%ecx
c00126ca:	89 04 24             	mov    %eax,(%esp)
c00126cd:	b8 b4 b4 01 c0       	mov    $0xc001b4b4,%eax
c00126d2:	c1 e9 08             	shr    $0x8,%ecx
c00126d5:	89 4c 24 04          	mov    %ecx,0x4(%esp)
c00126d9:	e8 98 db ff ff       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
            sys_finish<Sys_regs::BAD_CAP>();
        }

        sm = new (pd->quota) Sm (Pd::current, r->sel(), 0, si, r->cnt());
c00126de:	ff 34 24             	pushl  (%esp)
c00126e1:	55                   	push   %ebp
c00126e2:	6a 00                	push   $0x0
c00126e4:	89 c7                	mov    %eax,%edi
c00126e6:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c00126ea:	eb 23                	jmp    c001270f <_ZN2Ec13sys_create_smEv+0x15b>
c00126ec:	8b 4e 70             	mov    0x70(%esi),%ecx
c00126ef:	89 da                	mov    %ebx,%edx
c00126f1:	b8 b4 b4 01 c0       	mov    $0xc001b4b4,%eax
c00126f6:	8b 6e 58             	mov    0x58(%esi),%ebp
c00126f9:	c1 e9 08             	shr    $0x8,%ecx
c00126fc:	89 0c 24             	mov    %ecx,(%esp)
c00126ff:	e8 72 db ff ff       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
    } else
        sm = new (pd->quota) Sm (Pd::current, r->sel(), r->cnt());
c0012704:	6a 00                	push   $0x0
c0012706:	6a 00                	push   $0x0
c0012708:	55                   	push   %ebp
c0012709:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c001270d:	89 c7                	mov    %eax,%edi
c001270f:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c0012715:	89 f8                	mov    %edi,%eax
c0012717:	e8 fe df ff ff       	call   c001071a <_ZN2SmC1EP2PdmmPS_m>
c001271c:	83 c4 0c             	add    $0xc,%esp

    if (!Space_obj::insert_root (pd->quota, sm)) {
c001271f:	89 fa                	mov    %edi,%edx
c0012721:	89 d8                	mov    %ebx,%eax
c0012723:	e8 94 e9 ff ff       	call   c00110bc <_ZN9Space_obj11insert_rootER5QuotaP7Kobject>
c0012728:	84 c0                	test   %al,%al
c001272a:	75 4b                	jne    c0012777 <_ZN2Ec13sys_create_smEv+0x1c3>
c001272c:	8b 56 70             	mov    0x70(%esi),%edx
        trace (TRACE_ERROR, "%s: Non-NULL CAP (%#lx)", __func__, r->sel());
c001272f:	8d 44 24 07          	lea    0x7(%esp),%eax
c0012733:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0012738:	c1 ea 08             	shr    $0x8,%edx
c001273b:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c0012740:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0012745:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c001274c:	52                   	push   %edx
c001274d:	68 50 9c 01 c0       	push   $0xc0019c50
c0012752:	50                   	push   %eax
c0012753:	68 75 98 01 c0       	push   $0xc0019875
c0012758:	e8 81 f2 fe ff       	call   c00019de <_ZN7Console5printEPKcz>

        ALWAYS_INLINE
        static inline void destroy(Sm *obj, Quota &quota) { obj->~Sm(); cache.free (obj, quota); }
c001275d:	89 f8                	mov    %edi,%eax
c001275f:	e8 aa 5e ff ff       	call   c000860e <_ZN2SmD1Ev>
c0012764:	89 d9                	mov    %ebx,%ecx
c0012766:	89 fa                	mov    %edi,%edx
c0012768:	b8 b4 b4 01 c0       	mov    $0xc001b4b4,%eax
c001276d:	e8 ee db ff ff       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
c0012772:	e9 16 ff ff ff       	jmp    c001268d <_ZN2Ec13sys_create_smEv+0xd9>
        Sm::destroy(sm, pd->quota);
        sys_finish<Sys_regs::BAD_CAP>();
    }

    sys_finish<Sys_regs::SUCCESS>();
c0012777:	e8 56 ed ff ff       	call   c00114d2 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb0EEEvv>

c001277c <_ZN2Ec10sys_lookupEv>:

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_lookup()
{
c001277c:	56                   	push   %esi
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
c001277d:	ba 02 00 00 00       	mov    $0x2,%edx

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_lookup()
{
c0012782:	53                   	push   %ebx
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
c0012783:	8b 1d 0c f0 ff cf    	mov    0xcffff00c,%ebx
c0012789:	8d 83 90 01 00 00    	lea    0x190(%ebx),%eax
c001278f:	e8 2a ed ff ff       	call   c00114be <_ZN5Quota9hit_limitEm>
c0012794:	8b 35 08 f0 ff cf    	mov    0xcffff008,%esi
c001279a:	84 c0                	test   %al,%al
c001279c:	74 23                	je     c00127c1 <_ZN2Ec10sys_lookupEv+0x45>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu (%lu)", __func__, __LINE__, Pd::current->quota.usage(), Pd::current->quota.limit(), r);

        if (Ec::current->pt_oom && call)
c001279e:	8b 96 f8 00 00 00    	mov    0xf8(%esi),%edx
c00127a4:	85 d2                	test   %edx,%edx
c00127a6:	74 14                	je     c00127bc <_ZN2Ec10sys_lookupEv+0x40>
            Ec::current->oom_call_cpu (Ec::current->pt_oom, Ec::current->pt_oom->id, C, C);
c00127a8:	8b 4a 58             	mov    0x58(%edx),%ecx
c00127ab:	89 f0                	mov    %esi,%eax
c00127ad:	68 7c 27 01 c0       	push   $0xc001277c
c00127b2:	68 7c 27 01 c0       	push   $0xc001277c
c00127b7:	e8 d4 90 ff ff       	call   c000b890 <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_>

        sys_finish<Sys_regs::QUO_OOM>();
c00127bc:	e8 f3 fb ff ff       	call   c00123b4 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE9ELb0EEEvv>

        ALWAYS_INLINE
        inline explicit Crd (Type t, mword b = 0, mword o = 0x1f, mword a = 0x1f) : val (b << 12 | o << 7 | a << 2 | t) {}

        ALWAYS_INLINE
        inline Type type() const { return static_cast<Type>(val & 0x3); }
c00127c1:	8b 56 54             	mov    0x54(%esi),%edx
c00127c4:	89 d0                	mov    %edx,%eax
c00127c6:	83 e0 03             	and    $0x3,%eax
        }

        ALWAYS_INLINE
        inline Space *subspace (Crd::Type t)
        {
            switch (t) {
c00127c9:	83 f8 02             	cmp    $0x2,%eax
c00127cc:	74 0d                	je     c00127db <_ZN2Ec10sys_lookupEv+0x5f>
c00127ce:	83 f8 03             	cmp    $0x3,%eax
c00127d1:	74 10                	je     c00127e3 <_ZN2Ec10sys_lookupEv+0x67>
c00127d3:	48                   	dec    %eax
c00127d4:	75 25                	jne    c00127fb <_ZN2Ec10sys_lookupEv+0x7f>
                case Crd::MEM:  return static_cast<Space_mem *>(this);
c00127d6:	8d 43 4c             	lea    0x4c(%ebx),%eax
c00127d9:	eb 0e                	jmp    c00127e9 <_ZN2Ec10sys_lookupEv+0x6d>
                case Crd::PIO:  return static_cast<Space_pio *>(this);
c00127db:	8d 83 78 01 00 00    	lea    0x178(%ebx),%eax
c00127e1:	eb 06                	jmp    c00127e9 <_ZN2Ec10sys_lookupEv+0x6d>
                case Crd::OBJ:  return static_cast<Space_obj *>(this);
c00127e3:	8d 83 88 01 00 00    	lea    0x188(%ebx),%eax
    Sys_lookup *s = static_cast<Sys_lookup *>(current->sys_regs());

    trace (TRACE_SYSCALL, "EC:%p SYS_LOOKUP T:%d B:%#lx", current, s->crd().type(), s->crd().base());

    Space *space; Mdb *mdb;
    if ((space = Pd::current->subspace (s->crd().type())) && (mdb = space->tree_lookup (s->crd().base())))
c00127e9:	85 c0                	test   %eax,%eax
c00127eb:	74 0e                	je     c00127fb <_ZN2Ec10sys_lookupEv+0x7f>

        ALWAYS_INLINE
        inline unsigned order() const { return val >> 7 & 0x1f; }

        ALWAYS_INLINE
        inline mword base() const { return val >> 12; }
c00127ed:	c1 ea 0c             	shr    $0xc,%edx
c00127f0:	31 c9                	xor    %ecx,%ecx
c00127f2:	e8 e3 92 ff ff       	call   c000bada <_ZN5Space11tree_lookupEmb>
c00127f7:	85 c0                	test   %eax,%eax
c00127f9:	75 0c                	jne    c0012807 <_ZN2Ec10sys_lookupEv+0x8b>
        s->crd() = Crd (s->crd().type(), mdb->node_base, mdb->node_order, mdb->node_attr);
    else
        s->crd() = Crd (0);
c00127fb:	c7 46 54 00 00 00 00 	movl   $0x0,0x54(%esi)

    sys_finish<Sys_regs::SUCCESS>();
c0012802:	e8 cb ec ff ff       	call   c00114d2 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb0EEEvv>

        ALWAYS_INLINE
        inline explicit Crd (mword v) : val (v) {}

        ALWAYS_INLINE
        inline explicit Crd (Type t, mword b = 0, mword o = 0x1f, mword a = 0x1f) : val (b << 12 | o << 7 | a << 2 | t) {}
c0012807:	8b 48 30             	mov    0x30(%eax),%ecx

        ALWAYS_INLINE
        inline Type type() const { return static_cast<Type>(val & 0x3); }
c001280a:	8b 56 54             	mov    0x54(%esi),%edx

        ALWAYS_INLINE
        inline explicit Crd (mword v) : val (v) {}

        ALWAYS_INLINE
        inline explicit Crd (Type t, mword b = 0, mword o = 0x1f, mword a = 0x1f) : val (b << 12 | o << 7 | a << 2 | t) {}
c001280d:	c1 e1 0c             	shl    $0xc,%ecx

        ALWAYS_INLINE
        inline Type type() const { return static_cast<Type>(val & 0x3); }
c0012810:	83 e2 03             	and    $0x3,%edx
c0012813:	09 d1                	or     %edx,%ecx

        ALWAYS_INLINE
        inline explicit Crd (mword v) : val (v) {}

        ALWAYS_INLINE
        inline explicit Crd (Type t, mword b = 0, mword o = 0x1f, mword a = 0x1f) : val (b << 12 | o << 7 | a << 2 | t) {}
c0012815:	8b 50 34             	mov    0x34(%eax),%edx
c0012818:	c1 e2 07             	shl    $0x7,%edx
c001281b:	09 d1                	or     %edx,%ecx
c001281d:	8b 50 38             	mov    0x38(%eax),%edx
c0012820:	89 c8                	mov    %ecx,%eax
c0012822:	c1 e2 02             	shl    $0x2,%edx
c0012825:	09 d0                	or     %edx,%eax
c0012827:	89 46 54             	mov    %eax,0x54(%esi)
c001282a:	eb d6                	jmp    c0012802 <_ZN2Ec10sys_lookupEv+0x86>

c001282c <_ZN2Ec11sys_sc_ctrlEv>:

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_sc_ctrl()
{
c001282c:	57                   	push   %edi
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
c001282d:	ba 01 00 00 00       	mov    $0x1,%edx

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_sc_ctrl()
{
c0012832:	56                   	push   %esi
c0012833:	53                   	push   %ebx
c0012834:	50                   	push   %eax
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
c0012835:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c001283a:	05 90 01 00 00       	add    $0x190,%eax
c001283f:	e8 7a ec ff ff       	call   c00114be <_ZN5Quota9hit_limitEm>
c0012844:	8b 1d 08 f0 ff cf    	mov    0xcffff008,%ebx
c001284a:	84 c0                	test   %al,%al
c001284c:	74 23                	je     c0012871 <_ZN2Ec11sys_sc_ctrlEv+0x45>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu (%lu)", __func__, __LINE__, Pd::current->quota.usage(), Pd::current->quota.limit(), r);

        if (Ec::current->pt_oom && call)
c001284e:	8b 93 f8 00 00 00    	mov    0xf8(%ebx),%edx
c0012854:	85 d2                	test   %edx,%edx
c0012856:	74 14                	je     c001286c <_ZN2Ec11sys_sc_ctrlEv+0x40>
            Ec::current->oom_call_cpu (Ec::current->pt_oom, Ec::current->pt_oom->id, C, C);
c0012858:	8b 4a 58             	mov    0x58(%edx),%ecx
c001285b:	89 d8                	mov    %ebx,%eax
c001285d:	68 2c 28 01 c0       	push   $0xc001282c
c0012862:	68 2c 28 01 c0       	push   $0xc001282c
c0012867:	e8 24 90 ff ff       	call   c000b890 <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_>

        sys_finish<Sys_regs::QUO_OOM>();
c001286c:	e8 43 fb ff ff       	call   c00123b4 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE9ELb0EEEvv>

class Sys_sc_ctrl : public Sys_regs
{
    public:
        ALWAYS_INLINE
        inline unsigned long sc() const { return ARG_1 >> 8; }
c0012871:	8b 43 70             	mov    0x70(%ebx),%eax
c0012874:	c1 e8 08             	shr    $0x8,%eax
        static unsigned const caps = (END_SPACE_LIM - SPC_LOCAL_OBJ) / sizeof (Capability);

        ALWAYS_INLINE
        static inline Capability lookup (unsigned long idx)
        {
            return *reinterpret_cast<Capability *>(idx_to_virt (idx));
c0012877:	8b 14 85 00 00 00 e0 	mov    -0x20000000(,%eax,4),%edx
c001287e:	89 d1                	mov    %edx,%ecx
c0012880:	83 e1 e0             	and    $0xffffffe0,%ecx
c0012883:	74 0b                	je     c0012890 <_ZN2Ec11sys_sc_ctrlEv+0x64>
    check<sys_sc_ctrl>(1);

    Sys_sc_ctrl *r = static_cast<Sys_sc_ctrl *>(current->sys_regs());

    Capability cap = Space_obj::lookup (r->sc());
    if (EXPECT_FALSE (cap.obj()->type() != Kobject::SC || !(cap.prm() & 1UL << 0))) {
c0012885:	80 79 44 02          	cmpb   $0x2,0x44(%ecx)
c0012889:	75 05                	jne    c0012890 <_ZN2Ec11sys_sc_ctrlEv+0x64>
c001288b:	f6 c2 01             	test   $0x1,%dl
c001288e:	75 32                	jne    c00128c2 <_ZN2Ec11sys_sc_ctrlEv+0x96>
        trace (TRACE_ERROR, "%s: Bad SC CAP (%#lx)", __func__, r->sc());
c0012890:	8d 54 24 ff          	lea    -0x1(%esp),%edx
c0012894:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c001289a:	81 fa 00 d0 ff cf    	cmp    $0xcfffd000,%edx
c00128a0:	ba ff ff ff ff       	mov    $0xffffffff,%edx
c00128a5:	0f 44 15 04 f0 ff cf 	cmove  0xcffff004,%edx
c00128ac:	50                   	push   %eax
c00128ad:	68 2c 9c 01 c0       	push   $0xc0019c2c
c00128b2:	52                   	push   %edx
c00128b3:	68 d4 98 01 c0       	push   $0xc00198d4
c00128b8:	e8 21 f1 fe ff       	call   c00019de <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_CAP>();
c00128bd:	e8 2e f8 ff ff       	call   c00120f0 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>
    }

    uint32 dummy;
    r->set_time (div64 (static_cast<Sc *>(cap.obj())->time * 1000, Lapic::freq_tsc, &dummy));
c00128c2:	bf e8 03 00 00       	mov    $0x3e8,%edi
c00128c7:	89 f8                	mov    %edi,%eax
c00128c9:	f7 61 60             	mull   0x60(%ecx)
c00128cc:	69 71 64 e8 03 00 00 	imul   $0x3e8,0x64(%ecx),%esi
c00128d3:	89 d1                	mov    %edx,%ecx
c00128d5:	89 c2                	mov    %eax,%edx
c00128d7:	89 c8                	mov    %ecx,%eax
c00128d9:	01 f0                	add    %esi,%eax
                  : "=A" (q),   // quotient
                    "=r" (*r)   // remainder
                  : "a"  (static_cast<uint32>(n >> 32)),
                    "d"  (0),
                    "1"  (static_cast<uint32>(n)),
                    "rm" (d));
c00128db:	89 d6                	mov    %edx,%esi
c00128dd:	31 d2                	xor    %edx,%edx
c00128df:	f7 35 78 b0 01 c0    	divl   0xc001b078
c00128e5:	96                   	xchg   %eax,%esi
c00128e6:	f7 35 78 b0 01 c0    	divl   0xc001b078
c00128ec:	87 f2                	xchg   %esi,%edx
c00128ee:	89 d1                	mov    %edx,%ecx
c00128f0:	89 c2                	mov    %eax,%edx

        ALWAYS_INLINE
        inline void set_time (uint64 val)
        {
            ARG_2 = static_cast<mword>(val >> 32);
c00128f2:	89 4b 54             	mov    %ecx,0x54(%ebx)
            ARG_3 = static_cast<mword>(val);
c00128f5:	89 53 58             	mov    %edx,0x58(%ebx)

    sys_finish<Sys_regs::SUCCESS>();
c00128f8:	e8 d5 eb ff ff       	call   c00114d2 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb0EEEvv>
c00128fd:	90                   	nop

c00128fe <_ZN2Ec11sys_pt_ctrlEv>:
}

void Ec::sys_pt_ctrl()
{
c00128fe:	53                   	push   %ebx
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
c00128ff:	ba 01 00 00 00       	mov    $0x1,%edx

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_pt_ctrl()
{
c0012904:	50                   	push   %eax
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
c0012905:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c001290a:	05 90 01 00 00       	add    $0x190,%eax
c001290f:	e8 aa eb ff ff       	call   c00114be <_ZN5Quota9hit_limitEm>
c0012914:	84 c0                	test   %al,%al
c0012916:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c001291b:	74 21                	je     c001293e <_ZN2Ec11sys_pt_ctrlEv+0x40>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu (%lu)", __func__, __LINE__, Pd::current->quota.usage(), Pd::current->quota.limit(), r);

        if (Ec::current->pt_oom && call)
c001291d:	8b 90 f8 00 00 00    	mov    0xf8(%eax),%edx
c0012923:	85 d2                	test   %edx,%edx
c0012925:	74 12                	je     c0012939 <_ZN2Ec11sys_pt_ctrlEv+0x3b>
            Ec::current->oom_call_cpu (Ec::current->pt_oom, Ec::current->pt_oom->id, C, C);
c0012927:	8b 4a 58             	mov    0x58(%edx),%ecx
c001292a:	68 fe 28 01 c0       	push   $0xc00128fe
c001292f:	68 fe 28 01 c0       	push   $0xc00128fe
c0012934:	e8 57 8f ff ff       	call   c000b890 <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_>

        sys_finish<Sys_regs::QUO_OOM>();
c0012939:	e8 76 fa ff ff       	call   c00123b4 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE9ELb0EEEvv>

class Sys_pt_ctrl : public Sys_regs
{
    public:
        ALWAYS_INLINE
        inline unsigned long pt() const { return ARG_1 >> 8; }
c001293e:	8b 50 70             	mov    0x70(%eax),%edx
c0012941:	c1 ea 08             	shr    $0x8,%edx
c0012944:	8b 0c 95 00 00 00 e0 	mov    -0x20000000(,%edx,4),%ecx
c001294b:	89 cb                	mov    %ecx,%ebx
c001294d:	83 e3 e0             	and    $0xffffffe0,%ebx
c0012950:	74 0b                	je     c001295d <_ZN2Ec11sys_pt_ctrlEv+0x5f>
    check<sys_pt_ctrl>(1);

    Sys_pt_ctrl *r = static_cast<Sys_pt_ctrl *>(current->sys_regs());

    Capability cap = Space_obj::lookup (r->pt());
    if (EXPECT_FALSE (cap.obj()->type() != Kobject::PT || !(cap.prm() & 1UL << 0))) {
c0012952:	80 7b 44 03          	cmpb   $0x3,0x44(%ebx)
c0012956:	75 05                	jne    c001295d <_ZN2Ec11sys_pt_ctrlEv+0x5f>
c0012958:	f6 c1 01             	test   $0x1,%cl
c001295b:	75 30                	jne    c001298d <_ZN2Ec11sys_pt_ctrlEv+0x8f>
        trace (TRACE_ERROR, "%s: Bad PT CAP (%#lx)", __func__, r->pt());
c001295d:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c0012961:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0012966:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c001296b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0012970:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0012977:	52                   	push   %edx
c0012978:	68 20 9c 01 c0       	push   $0xc0019c20
c001297d:	50                   	push   %eax
c001297e:	68 f1 98 01 c0       	push   $0xc00198f1
c0012983:	e8 56 f0 fe ff       	call   c00019de <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_CAP>();
c0012988:	e8 63 f7 ff ff       	call   c00120f0 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>
c001298d:	8b 40 54             	mov    0x54(%eax),%eax
        mword      id;

        Pt (Pd *, mword, Ec *, Mtd, mword);

        ALWAYS_INLINE
        inline void set_id (mword i) { id = i; }
c0012990:	89 43 58             	mov    %eax,0x58(%ebx)

    Pt *pt = static_cast<Pt *>(cap.obj());

    pt->set_id (r->id());

    sys_finish<Sys_regs::SUCCESS>();
c0012993:	e8 3a eb ff ff       	call   c00114d2 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb0EEEvv>

c0012998 <_ZN2Ec11sys_sm_ctrlEv>:
}

void Ec::sys_sm_ctrl()
{
c0012998:	55                   	push   %ebp
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
c0012999:	ba 01 00 00 00       	mov    $0x1,%edx

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_sm_ctrl()
{
c001299e:	57                   	push   %edi
c001299f:	56                   	push   %esi
c00129a0:	53                   	push   %ebx
c00129a1:	83 ec 08             	sub    $0x8,%esp
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
c00129a4:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c00129a9:	05 90 01 00 00       	add    $0x190,%eax
c00129ae:	e8 0b eb ff ff       	call   c00114be <_ZN5Quota9hit_limitEm>
c00129b3:	8b 1d 08 f0 ff cf    	mov    0xcffff008,%ebx
c00129b9:	84 c0                	test   %al,%al
c00129bb:	74 23                	je     c00129e0 <_ZN2Ec11sys_sm_ctrlEv+0x48>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu (%lu)", __func__, __LINE__, Pd::current->quota.usage(), Pd::current->quota.limit(), r);

        if (Ec::current->pt_oom && call)
c00129bd:	8b 93 f8 00 00 00    	mov    0xf8(%ebx),%edx
c00129c3:	85 d2                	test   %edx,%edx
c00129c5:	74 14                	je     c00129db <_ZN2Ec11sys_sm_ctrlEv+0x43>
            Ec::current->oom_call_cpu (Ec::current->pt_oom, Ec::current->pt_oom->id, C, C);
c00129c7:	8b 4a 58             	mov    0x58(%edx),%ecx
c00129ca:	89 d8                	mov    %ebx,%eax
c00129cc:	68 98 29 01 c0       	push   $0xc0012998
c00129d1:	68 98 29 01 c0       	push   $0xc0012998
c00129d6:	e8 b5 8e ff ff       	call   c000b890 <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_>

        sys_finish<Sys_regs::QUO_OOM>();
c00129db:	e8 d4 f9 ff ff       	call   c00123b4 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE9ELb0EEEvv>
c00129e0:	8b 7b 70             	mov    0x70(%ebx),%edi

class Sys_sm_ctrl : public Sys_regs
{
    public:
        ALWAYS_INLINE
        inline unsigned long sm() const { return ARG_1 >> 8; }
c00129e3:	89 f8                	mov    %edi,%eax
c00129e5:	c1 e8 08             	shr    $0x8,%eax
c00129e8:	8b 04 85 00 00 00 e0 	mov    -0x20000000(,%eax,4),%eax
c00129ef:	89 c6                	mov    %eax,%esi
c00129f1:	83 e6 e0             	and    $0xffffffe0,%esi
c00129f4:	74 16                	je     c0012a0c <_ZN2Ec11sys_sm_ctrlEv+0x74>
    check<sys_sm_ctrl>(1);

    Sys_sm_ctrl *r = static_cast<Sys_sm_ctrl *>(current->sys_regs());
    Capability cap = Space_obj::lookup (r->sm());

    if (EXPECT_FALSE (cap.obj()->type() != Kobject::SM || !(cap.prm() & 1UL << r->op()))) {
c00129f6:	80 7e 44 04          	cmpb   $0x4,0x44(%esi)
c00129fa:	75 10                	jne    c0012a0c <_ZN2Ec11sys_sm_ctrlEv+0x74>
            BAD_DEV,
            QUO_OOM,
        };

        ALWAYS_INLINE
        inline unsigned flags() const { return ARG_1 >> 4 & 0xf; }
c00129fc:	c1 ef 04             	shr    $0x4,%edi

        ALWAYS_INLINE
        inline unsigned prm() const { return val & perm; }
c00129ff:	83 e0 1f             	and    $0x1f,%eax

        ALWAYS_INLINE
        inline unsigned op() const { return flags() & 0x1; }
c0012a02:	89 fa                	mov    %edi,%edx
c0012a04:	83 e2 01             	and    $0x1,%edx
c0012a07:	0f a3 d0             	bt     %edx,%eax
c0012a0a:	72 05                	jb     c0012a11 <_ZN2Ec11sys_sm_ctrlEv+0x79>
//        trace (TRACE_ERROR, "%s: Bad SM CAP (%#lx)", __func__, r->sm());
        sys_finish<Sys_regs::BAD_CAP>();
c0012a0c:	e8 df f6 ff ff       	call   c00120f0 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>
    }

    Sm *sm = static_cast<Sm *>(cap.obj());

    switch (r->op()) {
c0012a11:	4a                   	dec    %edx
c0012a12:	74 0d                	je     c0012a21 <_ZN2Ec11sys_sm_ctrlEv+0x89>

        case 0:
            sm->submit();
c0012a14:	8d 46 54             	lea    0x54(%esi),%eax
c0012a17:	e8 1a d2 ff ff       	call   c000fc36 <_ZN2Si6submitEv>
            break;
c0012a1c:	e9 bb 01 00 00       	jmp    c0012bdc <_ZN2Ec11sys_sm_ctrlEv+0x244>

        case 1:
            if (sm->space == static_cast<Space_obj *>(&Pd::kern)) {
c0012a21:	81 7e 28 48 b4 01 c0 	cmpl   $0xc001b448,0x28(%esi)
c0012a28:	75 10                	jne    c0012a3a <_ZN2Ec11sys_sm_ctrlEv+0xa2>
                Gsi::unmask (static_cast<unsigned>(sm->node_base - NUM_CPU));
c0012a2a:	8b 46 30             	mov    0x30(%esi),%eax
c0012a2d:	83 e8 40             	sub    $0x40,%eax
c0012a30:	e8 b9 2e ff ff       	call   c00058ee <_ZN3Gsi6unmaskEj>
                break;
c0012a35:	e9 a2 01 00 00       	jmp    c0012bdc <_ZN2Ec11sys_sm_ctrlEv+0x244>
            }

            if (sm->is_signal())
c0012a3a:	83 7e 54 00          	cmpl   $0x0,0x54(%esi)
c0012a3e:	75 cc                	jne    c0012a0c <_ZN2Ec11sys_sm_ctrlEv+0x74>
                sys_finish<Sys_regs::BAD_CAP>();

            current->cont = Ec::sys_finish<Sys_regs::SUCCESS, true>;
c0012a40:	c7 43 50 d2 15 01 c0 	movl   $0xc00115d2,0x50(%ebx)

        ALWAYS_INLINE
        inline unsigned zc() const { return flags() & 0x2; }

        ALWAYS_INLINE
        inline uint64 time() const { return static_cast<uint64>(ARG_2) << 32 | ARG_3; }
c0012a47:	8b 6b 54             	mov    0x54(%ebx),%ebp
        }

        ALWAYS_INLINE
        inline void dn (bool zero, uint64 t, Ec *ec = Ec::current, bool block = true)
        {
            {   Lock_guard <Spinlock> guard (lock);
c0012a4a:	8d 46 46             	lea    0x46(%esi),%eax
c0012a4d:	8b 53 58             	mov    0x58(%ebx),%edx

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c0012a50:	9c                   	pushf  
c0012a51:	59                   	pop    %ecx
            return flags & 0x200;
c0012a52:	c1 e9 09             	shr    $0x9,%ecx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c0012a55:	80 e1 01             	and    $0x1,%cl
c0012a58:	88 4c 24 03          	mov    %cl,0x3(%esp)
c0012a5c:	74 2a                	je     c0012a88 <_ZN2Ec11sys_sm_ctrlEv+0xf0>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0012a5e:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0012a65:	75 19                	jne    c0012a80 <_ZN2Ec11sys_sm_ctrlEv+0xe8>
c0012a67:	68 c0 9d 01 c0       	push   $0xc0019dc0
c0012a6c:	68 b7 00 00 00       	push   $0xb7
c0012a71:	68 12 61 01 c0       	push   $0xc0016112
c0012a76:	68 83 61 01 c0       	push   $0xc0016183
c0012a7b:	e9 0b 01 00 00       	jmp    c0012b8b <_ZN2Ec11sys_sm_ctrlEv+0x1f3>

            asm volatile ("cli" : : : "memory");
c0012a80:	fa                   	cli    
            preemption = false;
c0012a81:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
c0012a88:	89 54 24 04          	mov    %edx,0x4(%esp)
                Cpu::preempt_disable();

            _lock.lock();
c0012a8c:	e8 9b e0 fe ff       	call   c0000b2c <_ZN8Spinlock4lockEv>

                if (counter) {
c0012a91:	8b 46 64             	mov    0x64(%esi),%eax
c0012a94:	8b 54 24 04          	mov    0x4(%esp),%edx
c0012a98:	85 c0                	test   %eax,%eax
c0012a9a:	0f 84 84 00 00 00    	je     c0012b24 <_ZN2Ec11sys_sm_ctrlEv+0x18c>
                    counter = zero ? 0 : counter - 1;
c0012aa0:	48                   	dec    %eax
c0012aa1:	ba 00 00 00 00       	mov    $0x0,%edx
c0012aa6:	83 e7 02             	and    $0x2,%edi
c0012aa9:	0f 45 c2             	cmovne %edx,%eax
c0012aac:	89 46 64             	mov    %eax,0x64(%esi)

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c0012aaf:	8b 46 50             	mov    0x50(%esi),%eax
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c0012ab2:	85 c0                	test   %eax,%eax
c0012ab4:	0f 84 e5 00 00 00    	je     c0012b9f <_ZN2Ec11sys_sm_ctrlEv+0x207>
c0012aba:	8b 50 08             	mov    0x8(%eax),%edx
c0012abd:	85 d2                	test   %edx,%edx
c0012abf:	0f 84 da 00 00 00    	je     c0012b9f <_ZN2Ec11sys_sm_ctrlEv+0x207>
c0012ac5:	8b 48 04             	mov    0x4(%eax),%ecx
c0012ac8:	85 c9                	test   %ecx,%ecx
c0012aca:	0f 84 cf 00 00 00    	je     c0012b9f <_ZN2Ec11sys_sm_ctrlEv+0x207>
                return false;

            if (t == t->next)
c0012ad0:	39 d0                	cmp    %edx,%eax
c0012ad2:	75 09                	jne    c0012add <_ZN2Ec11sys_sm_ctrlEv+0x145>
                headptr = nullptr;
c0012ad4:	c7 46 50 00 00 00 00 	movl   $0x0,0x50(%esi)
c0012adb:	eb 17                	jmp    c0012af4 <_ZN2Ec11sys_sm_ctrlEv+0x15c>

            else {
                t->next->prev = t->prev;
c0012add:	89 4a 04             	mov    %ecx,0x4(%edx)
                t->prev->next = t->next;
c0012ae0:	8b 50 04             	mov    0x4(%eax),%edx
c0012ae3:	8b 48 08             	mov    0x8(%eax),%ecx
c0012ae6:	89 4a 08             	mov    %ecx,0x8(%edx)
                if (t == headptr)
c0012ae9:	3b 46 50             	cmp    0x50(%esi),%eax
c0012aec:	75 06                	jne    c0012af4 <_ZN2Ec11sys_sm_ctrlEv+0x15c>
                    headptr = t->next;
c0012aee:	8b 50 08             	mov    0x8(%eax),%edx
c0012af1:	89 56 50             	mov    %edx,0x50(%esi)

    public:

        mword reset(bool l = false) {
            if (l) lock.lock();
            mword c = counter;
c0012af4:	8b 50 10             	mov    0x10(%eax),%edx
            }

            t->next = t->prev = nullptr;
c0012af7:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
c0012afe:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
            counter = 0;
c0012b05:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
                if (counter) {
                    counter = zero ? 0 : counter - 1;

                    Si * si;
                    if (Queue<Si>::dequeue(si = Queue<Si>::head()))
                        ec->set_si_regs(si->value, static_cast <Sm *>(si)->reset());
c0012b0c:	8b 40 0c             	mov    0xc(%eax),%eax

        ALWAYS_INLINE
        inline void set_si_regs(mword sig, mword cnt)
        {
            regs.ARG_2 = sig;
            regs.ARG_3 = cnt;
c0012b0f:	89 53 58             	mov    %edx,0x58(%ebx)
        }

        ALWAYS_INLINE
        inline void set_si_regs(mword sig, mword cnt)
        {
            regs.ARG_2 = sig;
c0012b12:	89 43 54             	mov    %eax,0x54(%ebx)
c0012b15:	e9 85 00 00 00       	jmp    c0012b9f <_ZN2Ec11sys_sm_ctrlEv+0x207>

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
                if (Atomic::cmp_swap (ref, r, r + 1))
c0012b1a:	8d 48 01             	lea    0x1(%eax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c0012b1d:	f0 0f b1 4b 48       	lock cmpxchg %ecx,0x48(%ebx)
c0012b22:	74 07                	je     c0012b2b <_ZN2Ec11sys_sm_ctrlEv+0x193>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0012b24:	8b 43 48             	mov    0x48(%ebx),%eax
c0012b27:	85 c0                	test   %eax,%eax
c0012b29:	75 ef                	jne    c0012b1a <_ZN2Ec11sys_sm_ctrlEv+0x182>
        inline T *head() const { return headptr; }

        ALWAYS_INLINE
        inline void enqueue (T *t)
        {
            if (!headptr)
c0012b2b:	8b 46 4c             	mov    0x4c(%esi),%eax
c0012b2e:	85 c0                	test   %eax,%eax
c0012b30:	75 11                	jne    c0012b43 <_ZN2Ec11sys_sm_ctrlEv+0x1ab>
                headptr = t->prev = t->next = t;
c0012b32:	89 9b c4 00 00 00    	mov    %ebx,0xc4(%ebx)
c0012b38:	89 9b c0 00 00 00    	mov    %ebx,0xc0(%ebx)
c0012b3e:	89 5e 4c             	mov    %ebx,0x4c(%esi)
c0012b41:	eb 21                	jmp    c0012b64 <_ZN2Ec11sys_sm_ctrlEv+0x1cc>
            else {
                t->next = headptr;
c0012b43:	89 83 c4 00 00 00    	mov    %eax,0xc4(%ebx)
                t->prev = headptr->prev;
c0012b49:	8b 4e 4c             	mov    0x4c(%esi),%ecx
c0012b4c:	8b 89 c0 00 00 00    	mov    0xc0(%ecx),%ecx
c0012b52:	89 8b c0 00 00 00    	mov    %ecx,0xc0(%ebx)
                t->next->prev = t->prev->next = t;
c0012b58:	89 99 c4 00 00 00    	mov    %ebx,0xc4(%ecx)
c0012b5e:	89 98 c0 00 00 00    	mov    %ebx,0xc0(%eax)
c0012b64:	fe 46 46             	incb   0x46(%esi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c0012b67:	80 7c 24 03 00       	cmpb   $0x0,0x3(%esp)
c0012b6c:	74 4e                	je     c0012bbc <_ZN2Ec11sys_sm_ctrlEv+0x224>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0012b6e:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0012b75:	74 1e                	je     c0012b95 <_ZN2Ec11sys_sm_ctrlEv+0x1fd>
c0012b77:	68 80 9d 01 c0       	push   $0xc0019d80
c0012b7c:	68 c0 00 00 00       	push   $0xc0
c0012b81:	68 12 61 01 c0       	push   $0xc0016112
c0012b86:	68 82 61 01 c0       	push   $0xc0016182
c0012b8b:	68 69 60 01 c0       	push   $0xc0016069
c0012b90:	e8 b1 ed fe ff       	call   c0001946 <_ZN7Console5panicEPKcz>

            preemption = true;
c0012b95:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c0012b9c:	fb                   	sti    
c0012b9d:	eb 1d                	jmp    c0012bbc <_ZN2Ec11sys_sm_ctrlEv+0x224>
c0012b9f:	fe 46 46             	incb   0x46(%esi)
c0012ba2:	80 7c 24 03 00       	cmpb   $0x0,0x3(%esp)
c0012ba7:	74 33                	je     c0012bdc <_ZN2Ec11sys_sm_ctrlEv+0x244>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0012ba9:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0012bb0:	75 c5                	jne    c0012b77 <_ZN2Ec11sys_sm_ctrlEv+0x1df>

            preemption = true;
c0012bb2:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c0012bb9:	fb                   	sti    
c0012bba:	eb 20                	jmp    c0012bdc <_ZN2Ec11sys_sm_ctrlEv+0x244>
        inline bool blocked() const { return next || !cont; }

        ALWAYS_INLINE
        inline void set_timeout (uint64 t, Sm *s)
        {
            if (EXPECT_FALSE (t))
c0012bbc:	89 e8                	mov    %ebp,%eax
c0012bbe:	09 d0                	or     %edx,%eax
c0012bc0:	74 13                	je     c0012bd5 <_ZN2Ec11sys_sm_ctrlEv+0x23d>

        ALWAYS_INLINE
        inline void enqueue (uint64 t, Sm *s) { sm = s; Timeout::enqueue (t); }
c0012bc2:	89 b3 ec 00 00 00    	mov    %esi,0xec(%ebx)
c0012bc8:	8d 83 d4 00 00 00    	lea    0xd4(%ebx),%eax
c0012bce:	89 e9                	mov    %ebp,%ecx
c0012bd0:	e8 19 16 00 00       	call   c00141ee <_ZN7Timeout7enqueueEy>
            if (!block)
                Sc::schedule (false);

            ec->set_timeout (t, this);

            ec->block_sc();
c0012bd5:	89 d8                	mov    %ebx,%eax
c0012bd7:	e8 34 59 ff ff       	call   c0008510 <_ZN2Ec8block_scEv>
            sm->dn (r->zc(), r->time());
            break;
    }

    sys_finish<Sys_regs::SUCCESS>();
c0012bdc:	e8 f1 e8 ff ff       	call   c00114d2 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb0EEEvv>
c0012be1:	90                   	nop

c0012be2 <_ZN2Ec8delegateILb1EEEvv>:

    ec->make_current();
}

template <bool C>
void Ec::delegate()
c0012be2:	55                   	push   %ebp
c0012be3:	57                   	push   %edi
c0012be4:	56                   	push   %esi
c0012be5:	53                   	push   %ebx
c0012be6:	83 ec 0c             	sub    $0xc,%esp
{
    Ec *ec = current->rcap;
c0012be9:	8b 1d 08 f0 ff cf    	mov    0xcffff008,%ebx
c0012bef:	8b b3 b0 00 00 00    	mov    0xb0(%ebx),%esi
    assert (ec);
c0012bf5:	85 f6                	test   %esi,%esi
c0012bf7:	75 1b                	jne    c0012c14 <_ZN2Ec8delegateILb1EEEvv+0x32>
c0012bf9:	68 20 9d 01 c0       	push   $0xc0019d20
c0012bfe:	6a 47                	push   $0x47
c0012c00:	68 7b 97 01 c0       	push   $0xc001977b
c0012c05:	68 0e 99 01 c0       	push   $0xc001990e
c0012c0a:	68 69 60 01 c0       	push   $0xc0016069
c0012c0f:	e8 32 ed fe ff       	call   c0001946 <_ZN7Console5panicEPKcz>
    dst->pd->xfer_items (src->pd,
                         user ? dst->utcb->xlt : Crd (0),
                         user ? dst->utcb->del : Crd (Crd::MEM, (dst->cont == ret_user_iret ? dst->regs.cr2 : dst->regs.nst_fault) >> PAGE_BITS),
                         src->utcb->xfer(),
                         user ? dst->utcb->xfer() : nullptr,
                         src->utcb->ti());
c0012c14:	8b be b4 00 00 00    	mov    0xb4(%esi),%edi
c0012c1a:	ba fe 01 00 00       	mov    $0x1fe,%edx

    dst->pd->xfer_items (src->pd,
                         user ? dst->utcb->xlt : Crd (0),
                         user ? dst->utcb->del : Crd (Crd::MEM, (dst->cont == ret_user_iret ? dst->regs.cr2 : dst->regs.nst_fault) >> PAGE_BITS),
                         src->utcb->xfer(),
                         user ? dst->utcb->xfer() : nullptr,
c0012c1f:	8b ab b4 00 00 00    	mov    0xb4(%ebx),%ebp
c0012c25:	8b 07                	mov    (%edi),%eax
                         src->utcb->ti());
c0012c27:	8b 4d 04             	mov    0x4(%ebp),%ecx
c0012c2a:	c1 e8 10             	shr    $0x10,%eax
c0012c2d:	3d fe 01 00 00       	cmp    $0x1fe,%eax
c0012c32:	0f 47 c2             	cmova  %edx,%eax
    Ec *src = C ? ec : current;
    Ec *dst = C ? current : ec;

    bool user = C || ((dst->cont == ret_user_sysexit) || (dst->cont == xcpu_return));

    dst->pd->xfer_items (src->pd,
c0012c35:	8b 96 b8 00 00 00    	mov    0xb8(%esi),%edx
                dst->mr[i] = mr[i];
#endif
        }

        ALWAYS_INLINE
        inline Xfer *xfer() { return reinterpret_cast<Xfer *>(this) + PAGE_SIZE / sizeof (Xfer) - 1; }
c0012c3b:	81 c7 f8 0f 00 00    	add    $0xff8,%edi
c0012c41:	89 14 24             	mov    %edx,(%esp)
c0012c44:	8b 93 b8 00 00 00    	mov    0xb8(%ebx),%edx
c0012c4a:	89 54 24 04          	mov    %edx,0x4(%esp)
c0012c4e:	50                   	push   %eax
c0012c4f:	8d 85 f8 0f 00 00    	lea    0xff8(%ebp),%eax
c0012c55:	50                   	push   %eax
c0012c56:	57                   	push   %edi
c0012c57:	ff 75 08             	pushl  0x8(%ebp)
c0012c5a:	8b 54 24 10          	mov    0x10(%esp),%edx
c0012c5e:	8b 44 24 14          	mov    0x14(%esp),%eax
c0012c62:	e8 c7 a9 ff ff       	call   c000d62e <_ZN2Pd10xfer_itemsEPS_3CrdS1_P4XferS3_m>
                         user ? dst->utcb->del : Crd (Crd::MEM, (dst->cont == ret_user_iret ? dst->regs.cr2 : dst->regs.nst_fault) >> PAGE_BITS),
                         src->utcb->xfer(),
                         user ? dst->utcb->xfer() : nullptr,
                         src->utcb->ti());

    if (Cpu::hazard & HZD_OOM) {
c0012c67:	83 c4 10             	add    $0x10,%esp
c0012c6a:	f6 05 00 f0 ff cf 20 	testb  $0x20,0xcffff000
c0012c71:	74 65                	je     c0012cd8 <_ZN2Ec8delegateILb1EEEvv+0xf6>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
c0012c73:	8b bb b8 00 00 00    	mov    0xb8(%ebx),%edi
        if (dst->pd->quota.hit_limit())
c0012c79:	31 d2                	xor    %edx,%edx
c0012c7b:	8d 87 90 01 00 00    	lea    0x190(%edi),%eax
c0012c81:	e8 38 e8 ff ff       	call   c00114be <_ZN5Quota9hit_limitEm>
c0012c86:	84 c0                	test   %al,%al
c0012c88:	74 34                	je     c0012cbe <_ZN2Ec8delegateILb1EEEvv+0xdc>
            trace (0, "warning: insufficient resources %lx/%lx", dst->pd->quota.usage(), dst->pd->quota.limit());
c0012c8a:	8d 44 24 07          	lea    0x7(%esp),%eax
c0012c8e:	ff b7 9c 01 00 00    	pushl  0x19c(%edi)
c0012c94:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0012c99:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c0012c9e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0012ca3:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0012caa:	ff b7 94 01 00 00    	pushl  0x194(%edi)
c0012cb0:	50                   	push   %eax
c0012cb1:	68 11 99 01 c0       	push   $0xc0019911
c0012cb6:	e8 23 ed fe ff       	call   c00019de <_ZN7Console5printEPKcz>
c0012cbb:	83 c4 10             	add    $0x10,%esp

        Cpu::hazard ^= HZD_OOM;
        current->oom_delegate(dst, ec, src, user, C);
c0012cbe:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0012cc3:	89 f1                	mov    %esi,%ecx
c0012cc5:	89 da                	mov    %ebx,%edx
c0012cc7:	6a 01                	push   $0x1
c0012cc9:	6a 01                	push   $0x1
c0012ccb:	56                   	push   %esi

    if (Cpu::hazard & HZD_OOM) {
        if (dst->pd->quota.hit_limit())
            trace (0, "warning: insufficient resources %lx/%lx", dst->pd->quota.usage(), dst->pd->quota.limit());

        Cpu::hazard ^= HZD_OOM;
c0012ccc:	83 35 00 f0 ff cf 20 	xorl   $0x20,0xcffff000
        current->oom_delegate(dst, ec, src, user, C);
c0012cd3:	e8 aa 72 ff ff       	call   c0009f82 <_ZN2Ec12oom_delegateEPS_S0_S0_bb>
    }
}
c0012cd8:	83 c4 0c             	add    $0xc,%esp
c0012cdb:	5b                   	pop    %ebx
c0012cdc:	5e                   	pop    %esi
c0012cdd:	5f                   	pop    %edi
c0012cde:	5d                   	pop    %ebp
c0012cdf:	c3                   	ret    

c0012ce0 <_ZN2Ec8delegateILb0EEEvv>:

    ec->make_current();
}

template <bool C>
void Ec::delegate()
c0012ce0:	55                   	push   %ebp
c0012ce1:	57                   	push   %edi
c0012ce2:	56                   	push   %esi
c0012ce3:	53                   	push   %ebx
c0012ce4:	83 ec 10             	sub    $0x10,%esp
{
    Ec *ec = current->rcap;
c0012ce7:	8b 3d 08 f0 ff cf    	mov    0xcffff008,%edi
c0012ced:	8b 9f b0 00 00 00    	mov    0xb0(%edi),%ebx
    assert (ec);
c0012cf3:	85 db                	test   %ebx,%ebx
c0012cf5:	75 1b                	jne    c0012d12 <_ZN2Ec8delegateILb0EEEvv+0x32>
c0012cf7:	68 a0 9c 01 c0       	push   $0xc0019ca0
c0012cfc:	6a 47                	push   $0x47
c0012cfe:	68 7b 97 01 c0       	push   $0xc001977b
c0012d03:	68 0e 99 01 c0       	push   $0xc001990e
c0012d08:	68 69 60 01 c0       	push   $0xc0016069
c0012d0d:	e8 34 ec fe ff       	call   c0001946 <_ZN7Console5panicEPKcz>
    dst->pd->xfer_items (src->pd,
                         user ? dst->utcb->xlt : Crd (0),
                         user ? dst->utcb->del : Crd (Crd::MEM, (dst->cont == ret_user_iret ? dst->regs.cr2 : dst->regs.nst_fault) >> PAGE_BITS),
                         src->utcb->xfer(),
                         user ? dst->utcb->xfer() : nullptr,
                         src->utcb->ti());
c0012d12:	8b 8f b4 00 00 00    	mov    0xb4(%edi),%ecx
c0012d18:	bd fe 01 00 00       	mov    $0x1fe,%ebp
    assert (ec);

    Ec *src = C ? ec : current;
    Ec *dst = C ? current : ec;

    bool user = C || ((dst->cont == ret_user_sysexit) || (dst->cont == xcpu_return));
c0012d1d:	8b 43 50             	mov    0x50(%ebx),%eax
        WARN_UNUSED_RESULT bool save_exc (Cpu_regs *);
        WARN_UNUSED_RESULT bool save_vmx (Cpu_regs *);
        WARN_UNUSED_RESULT bool save_svm (Cpu_regs *);

        inline mword ucnt() const { return static_cast<uint16>(items); }
        inline mword tcnt() const { return static_cast<uint16>(items >> 16); }
c0012d20:	8b 31                	mov    (%ecx),%esi
c0012d22:	3d 00 00 00 c0       	cmp    $0xc0000000,%eax
c0012d27:	0f 94 c2             	sete   %dl
c0012d2a:	3d 8e 40 00 c0       	cmp    $0xc000408e,%eax
c0012d2f:	0f 94 44 24 03       	sete   0x3(%esp)
c0012d34:	c1 ee 10             	shr    $0x10,%esi
c0012d37:	81 fe fe 01 00 00    	cmp    $0x1fe,%esi
c0012d3d:	0f 47 f5             	cmova  %ebp,%esi
    dst->pd->xfer_items (src->pd,
                         user ? dst->utcb->xlt : Crd (0),
                         user ? dst->utcb->del : Crd (Crd::MEM, (dst->cont == ret_user_iret ? dst->regs.cr2 : dst->regs.nst_fault) >> PAGE_BITS),
                         src->utcb->xfer(),
                         user ? dst->utcb->xfer() : nullptr,
                         src->utcb->ti());
c0012d40:	66 31 ed             	xor    %bp,%bp
c0012d43:	0a 54 24 03          	or     0x3(%esp),%dl
c0012d47:	88 54 24 03          	mov    %dl,0x3(%esp)
c0012d4b:	74 0c                	je     c0012d59 <_ZN2Ec8delegateILb0EEEvv+0x79>
                dst->mr[i] = mr[i];
#endif
        }

        ALWAYS_INLINE
        inline Xfer *xfer() { return reinterpret_cast<Xfer *>(this) + PAGE_SIZE / sizeof (Xfer) - 1; }
c0012d4d:	8b 93 b4 00 00 00    	mov    0xb4(%ebx),%edx
c0012d53:	8d aa f8 0f 00 00    	lea    0xff8(%edx),%ebp
c0012d59:	81 c1 f8 0f 00 00    	add    $0xff8,%ecx
c0012d5f:	80 7c 24 03 00       	cmpb   $0x0,0x3(%esp)
c0012d64:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c0012d68:	74 12                	je     c0012d7c <_ZN2Ec8delegateILb0EEEvv+0x9c>
c0012d6a:	8b 83 b4 00 00 00    	mov    0xb4(%ebx),%eax
c0012d70:	8b 50 08             	mov    0x8(%eax),%edx
c0012d73:	8b 48 04             	mov    0x4(%eax),%ecx
c0012d76:	89 54 24 04          	mov    %edx,0x4(%esp)
c0012d7a:	eb 23                	jmp    c0012d9f <_ZN2Ec8delegateILb0EEEvv+0xbf>
c0012d7c:	3d 2e 00 00 c0       	cmp    $0xc000002e,%eax
c0012d81:	75 05                	jne    c0012d88 <_ZN2Ec8delegateILb0EEEvv+0xa8>
c0012d83:	8b 43 60             	mov    0x60(%ebx),%eax
c0012d86:	eb 06                	jmp    c0012d8e <_ZN2Ec8delegateILb0EEEvv+0xae>
c0012d88:	8b 83 8c 00 00 00    	mov    0x8c(%ebx),%eax
c0012d8e:	c1 e8 0c             	shr    $0xc,%eax
c0012d91:	31 c9                	xor    %ecx,%ecx
c0012d93:	c1 e0 0c             	shl    $0xc,%eax
c0012d96:	0d fd 0f 00 00       	or     $0xffd,%eax
c0012d9b:	89 44 24 04          	mov    %eax,0x4(%esp)
    Ec *src = C ? ec : current;
    Ec *dst = C ? current : ec;

    bool user = C || ((dst->cont == ret_user_sysexit) || (dst->cont == xcpu_return));

    dst->pd->xfer_items (src->pd,
c0012d9f:	8b 97 b8 00 00 00    	mov    0xb8(%edi),%edx
c0012da5:	8b 83 b8 00 00 00    	mov    0xb8(%ebx),%eax
c0012dab:	56                   	push   %esi
c0012dac:	55                   	push   %ebp
c0012dad:	ff 74 24 10          	pushl  0x10(%esp)
c0012db1:	ff 74 24 10          	pushl  0x10(%esp)
c0012db5:	e8 74 a8 ff ff       	call   c000d62e <_ZN2Pd10xfer_itemsEPS_3CrdS1_P4XferS3_m>
                         user ? dst->utcb->del : Crd (Crd::MEM, (dst->cont == ret_user_iret ? dst->regs.cr2 : dst->regs.nst_fault) >> PAGE_BITS),
                         src->utcb->xfer(),
                         user ? dst->utcb->xfer() : nullptr,
                         src->utcb->ti());

    if (Cpu::hazard & HZD_OOM) {
c0012dba:	83 c4 10             	add    $0x10,%esp
c0012dbd:	f6 05 00 f0 ff cf 20 	testb  $0x20,0xcffff000
c0012dc4:	74 69                	je     c0012e2f <_ZN2Ec8delegateILb0EEEvv+0x14f>
c0012dc6:	8b b3 b8 00 00 00    	mov    0xb8(%ebx),%esi
        if (dst->pd->quota.hit_limit())
c0012dcc:	31 d2                	xor    %edx,%edx
c0012dce:	8d 86 90 01 00 00    	lea    0x190(%esi),%eax
c0012dd4:	e8 e5 e6 ff ff       	call   c00114be <_ZN5Quota9hit_limitEm>
c0012dd9:	84 c0                	test   %al,%al
c0012ddb:	74 34                	je     c0012e11 <_ZN2Ec8delegateILb0EEEvv+0x131>
            trace (0, "warning: insufficient resources %lx/%lx", dst->pd->quota.usage(), dst->pd->quota.limit());
c0012ddd:	8d 44 24 0b          	lea    0xb(%esp),%eax
c0012de1:	ff b6 9c 01 00 00    	pushl  0x19c(%esi)
c0012de7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0012dec:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c0012df1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0012df6:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0012dfd:	ff b6 94 01 00 00    	pushl  0x194(%esi)
c0012e03:	50                   	push   %eax
c0012e04:	68 11 99 01 c0       	push   $0xc0019911
c0012e09:	e8 d0 eb fe ff       	call   c00019de <_ZN7Console5printEPKcz>
c0012e0e:	83 c4 10             	add    $0x10,%esp

        Cpu::hazard ^= HZD_OOM;
        current->oom_delegate(dst, ec, src, user, C);
c0012e11:	6a 00                	push   $0x0
c0012e13:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c0012e18:	89 d9                	mov    %ebx,%ecx
c0012e1a:	0f b6 54 24 07       	movzbl 0x7(%esp),%edx

    if (Cpu::hazard & HZD_OOM) {
        if (dst->pd->quota.hit_limit())
            trace (0, "warning: insufficient resources %lx/%lx", dst->pd->quota.usage(), dst->pd->quota.limit());

        Cpu::hazard ^= HZD_OOM;
c0012e1f:	83 35 00 f0 ff cf 20 	xorl   $0x20,0xcffff000
        current->oom_delegate(dst, ec, src, user, C);
c0012e26:	52                   	push   %edx
c0012e27:	89 da                	mov    %ebx,%edx
c0012e29:	57                   	push   %edi
c0012e2a:	e8 53 71 ff ff       	call   c0009f82 <_ZN2Ec12oom_delegateEPS_S0_S0_bb>
    }
}
c0012e2f:	83 c4 10             	add    $0x10,%esp
c0012e32:	5b                   	pop    %ebx
c0012e33:	5e                   	pop    %esi
c0012e34:	5f                   	pop    %edi
c0012e35:	5d                   	pop    %ebp
c0012e36:	c3                   	ret    
c0012e37:	90                   	nop

c0012e38 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE5ELb0EEEvv>:
#include "syscall.hpp"
#include "utcb.hpp"
#include "vectors.hpp"

template <Sys_regs::Status S, bool T>
void Ec::sys_finish()
c0012e38:	53                   	push   %ebx
c0012e39:	50                   	push   %eax
{
    if (T)
        current->clr_timeout();

    current->regs.set_status (S);
c0012e3a:	a1 08 f0 ff cf       	mov    0xcffff008,%eax

    if (current->xcpu_sm)
c0012e3f:	83 b8 f4 00 00 00 00 	cmpl   $0x0,0xf4(%eax)

        ALWAYS_INLINE
        inline void set_status (Status s, bool c = true)
        {
            if (c)
                ARG_1 = s;
c0012e46:	c7 40 70 05 00 00 00 	movl   $0x5,0x70(%eax)
c0012e4d:	74 05                	je     c0012e54 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE5ELb0EEEvv+0x1c>
        xcpu_return();
c0012e4f:	e8 3a 12 ff ff       	call   c000408e <_ZN2Ec11xcpu_returnEv>

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
c0012e54:	8b 1d 0c f0 ff cf    	mov    0xcffff00c,%ebx
c0012e5a:	31 d2                	xor    %edx,%edx
c0012e5c:	8d 83 90 01 00 00    	lea    0x190(%ebx),%eax
c0012e62:	e8 57 e6 ff ff       	call   c00114be <_ZN5Quota9hit_limitEm>
c0012e67:	84 c0                	test   %al,%al
c0012e69:	75 05                	jne    c0012e70 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE5ELb0EEEvv+0x38>
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());

    ret_user_sysexit();
c0012e6b:	e8 90 d1 fe ff       	call   c0000000 <_ZN2Ec16ret_user_sysexitEv>

    if (current->xcpu_sm)
        xcpu_return();

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());
c0012e70:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c0012e74:	ff b3 9c 01 00 00    	pushl  0x19c(%ebx)
c0012e7a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0012e7f:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c0012e84:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0012e89:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0012e90:	ff b3 94 01 00 00    	pushl  0x194(%ebx)
c0012e96:	50                   	push   %eax
c0012e97:	68 4c 97 01 c0       	push   $0xc001974c
c0012e9c:	e8 3d eb fe ff       	call   c00019de <_ZN7Console5printEPKcz>
c0012ea1:	83 c4 10             	add    $0x10,%esp
c0012ea4:	eb c5                	jmp    c0012e6b <_ZN2Ec10sys_finishILN8Sys_regs6StatusE5ELb0EEEvv+0x33>

c0012ea6 <_ZN2Ec13sys_create_pdEv>:
        sys_finish<Sys_regs::QUO_OOM>();
    }
}

void Ec::sys_create_pd()
{
c0012ea6:	55                   	push   %ebp
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
c0012ea7:	31 d2                	xor    %edx,%edx
        sys_finish<Sys_regs::QUO_OOM>();
    }
}

void Ec::sys_create_pd()
{
c0012ea9:	57                   	push   %edi
c0012eaa:	56                   	push   %esi
c0012eab:	53                   	push   %ebx
c0012eac:	83 ec 0c             	sub    $0xc,%esp
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
c0012eaf:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c0012eb4:	8d 98 90 01 00 00    	lea    0x190(%eax),%ebx
c0012eba:	89 d8                	mov    %ebx,%eax
c0012ebc:	e8 fd e5 ff ff       	call   c00114be <_ZN5Quota9hit_limitEm>
c0012ec1:	84 c0                	test   %al,%al
c0012ec3:	74 05                	je     c0012eca <_ZN2Ec13sys_create_pdEv+0x24>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu (%lu)", __func__, __LINE__, Pd::current->quota.usage(), Pd::current->quota.limit(), r);

        if (Ec::current->pt_oom && call)
            Ec::current->oom_call_cpu (Ec::current->pt_oom, Ec::current->pt_oom->id, C, C);

        sys_finish<Sys_regs::QUO_OOM>();
c0012ec5:	e8 ea f4 ff ff       	call   c00123b4 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE9ELb0EEEvv>

void Ec::sys_create_pd()
{
    check<sys_create_pd>(0, false);

    Sys_create_pd *r = static_cast<Sys_create_pd *>(current->sys_regs());
c0012eca:	8b 35 08 f0 ff cf    	mov    0xcffff008,%esi
c0012ed0:	8b 4e 54             	mov    0x54(%esi),%ecx
{
    private:
        ALWAYS_INLINE
        static inline mword idx_to_virt (unsigned long idx)
        {
            return SPC_LOCAL_OBJ + (idx % caps) * sizeof (Capability);
c0012ed3:	89 c8                	mov    %ecx,%eax
c0012ed5:	25 ff ff ff 07       	and    $0x7ffffff,%eax
        static unsigned const caps = (END_SPACE_LIM - SPC_LOCAL_OBJ) / sizeof (Capability);

        ALWAYS_INLINE
        static inline Capability lookup (unsigned long idx)
        {
            return *reinterpret_cast<Capability *>(idx_to_virt (idx));
c0012eda:	8b 3c 85 00 00 00 e0 	mov    -0x20000000(,%eax,4),%edi
c0012ee1:	89 fa                	mov    %edi,%edx
c0012ee3:	83 e2 e0             	and    $0xffffffe0,%edx
c0012ee6:	74 10                	je     c0012ef8 <_ZN2Ec13sys_create_pdEv+0x52>
c0012ee8:	0f b6 6a 44          	movzbl 0x44(%edx),%ebp

    trace (TRACE_SYSCALL, "EC:%p SYS_CREATE PD:%#lx", current, r->sel());

    Capability cap = Space_obj::lookup (r->pd());
    if (EXPECT_FALSE (cap.obj()->type() != Kobject::PD) || !(cap.prm() & 1UL << Kobject::PD)) {
c0012eec:	85 ed                	test   %ebp,%ebp
c0012eee:	75 08                	jne    c0012ef8 <_ZN2Ec13sys_create_pdEv+0x52>
c0012ef0:	f7 c7 01 00 00 00    	test   $0x1,%edi
c0012ef6:	75 30                	jne    c0012f28 <_ZN2Ec13sys_create_pdEv+0x82>
        trace (TRACE_ERROR, "%s: Non-PD CAP (%#lx)", __func__, r->pd());
c0012ef8:	8d 44 24 07          	lea    0x7(%esp),%eax
c0012efc:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0012f01:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c0012f06:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0012f0b:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0012f12:	51                   	push   %ecx
c0012f13:	68 90 9c 01 c0       	push   $0xc0019c90
c0012f18:	50                   	push   %eax
c0012f19:	68 21 98 01 c0       	push   $0xc0019821
c0012f1e:	e8 bb ea fe ff       	call   c00019de <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_CAP>();
c0012f23:	e8 c8 f1 ff ff       	call   c00120f0 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>
c0012f28:	8b 46 64             	mov    0x64(%esi),%eax

        ALWAYS_INLINE
        inline Crd crd() const { return Crd (ARG_3); }

        ALWAYS_INLINE
        inline unsigned long limit_lower() const { return ARG_4 & (~0UL >> (sizeof(mword) * 4)); }
c0012f2b:	0f b7 c8             	movzwl %ax,%ecx

        ALWAYS_INLINE
        inline unsigned long limit_upper() const { return ARG_4 >> (sizeof(mword) * 4); }
c0012f2e:	c1 e8 10             	shr    $0x10,%eax
    }
    Pd * pd_src = static_cast<Pd *>(cap.obj());

    if (r->limit_lower() > r->limit_upper())
c0012f31:	39 c1                	cmp    %eax,%ecx
c0012f33:	76 05                	jbe    c0012f3a <_ZN2Ec13sys_create_pdEv+0x94>
        sys_finish<Sys_regs::BAD_PAR>();
c0012f35:	e8 fe fe ff ff       	call   c0012e38 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE5ELb0EEEvv>

    if (pd_src->quota.hit_limit(1)) {
c0012f3a:	8d 82 90 01 00 00    	lea    0x190(%edx),%eax
c0012f40:	ba 01 00 00 00       	mov    $0x1,%edx
c0012f45:	89 04 24             	mov    %eax,(%esp)
c0012f48:	e8 71 e5 ff ff       	call   c00114be <_ZN5Quota9hit_limitEm>
c0012f4d:	84 c0                	test   %al,%al
c0012f4f:	0f 85 70 ff ff ff    	jne    c0012ec5 <_ZN2Ec13sys_create_pdEv+0x1f>

class Sys_create_pd : public Sys_regs
{
    public:
        ALWAYS_INLINE
        inline unsigned long sel() const { return ARG_1 >> 8; }
c0012f55:	8b 4e 70             	mov    0x70(%esi),%ecx
        void xlt_crd (Pd *, Crd, Crd &);
        void del_crd (Pd *, Crd, Crd &, mword = 0, mword = 0);
        void rev_crd (Crd, bool, bool, bool);

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
c0012f58:	89 da                	mov    %ebx,%edx
c0012f5a:	b8 64 b4 01 c0       	mov    $0xc001b464,%eax
c0012f5f:	83 e7 1f             	and    $0x1f,%edi
c0012f62:	c1 e9 08             	shr    $0x8,%ecx
c0012f65:	89 4c 24 04          	mov    %ecx,0x4(%esp)
c0012f69:	e8 08 d3 ff ff       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu", __func__, __LINE__, pd_src->quota.usage(), pd_src->quota.limit());
        sys_finish<Sys_regs::QUO_OOM>();
    }

    Pd *pd = new (Pd::current->quota) Pd (Pd::current, r->sel(), cap.prm());
c0012f6e:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c0012f74:	57                   	push   %edi
c0012f75:	8b 4c 24 08          	mov    0x8(%esp),%ecx
c0012f79:	89 c3                	mov    %eax,%ebx
c0012f7b:	e8 28 8d ff ff       	call   c000bca8 <_ZN2PdC1EPS_mm>
c0012f80:	8b 46 64             	mov    0x64(%esi),%eax

    if (!pd->quota.set_limit(r->limit_lower(), r->limit_upper(), pd_src->quota)) {
c0012f83:	8d bb 90 01 00 00    	lea    0x190(%ebx),%edi
             return true;
        }

        bool set_limit(mword l, mword h, Quota &from)
        {
            if (!from.transfer_to(*this, h))
c0012f89:	89 fa                	mov    %edi,%edx
c0012f8b:	89 44 24 08          	mov    %eax,0x8(%esp)

        ALWAYS_INLINE
        inline unsigned long limit_lower() const { return ARG_4 & (~0UL >> (sizeof(mword) * 4)); }

        ALWAYS_INLINE
        inline unsigned long limit_upper() const { return ARG_4 >> (sizeof(mword) * 4); }
c0012f8f:	89 c1                	mov    %eax,%ecx
c0012f91:	6a 01                	push   $0x1
c0012f93:	8b 44 24 08          	mov    0x8(%esp),%eax
c0012f97:	c1 e9 10             	shr    $0x10,%ecx
c0012f9a:	e8 4d fb fe ff       	call   c0002aec <_ZN5Quota11transfer_toERS_mb>
c0012f9f:	59                   	pop    %ecx
c0012fa0:	5a                   	pop    %edx
c0012fa1:	84 c0                	test   %al,%al
c0012fa3:	8d 4c 24 07          	lea    0x7(%esp),%ecx
c0012fa7:	0f 84 ae 00 00 00    	je     c001305b <_ZN2Ec13sys_create_pdEv+0x1b5>

        ALWAYS_INLINE
        inline Crd crd() const { return Crd (ARG_3); }

        ALWAYS_INLINE
        inline unsigned long limit_lower() const { return ARG_4 & (~0UL >> (sizeof(mword) * 4)); }
c0012fad:	0f b7 44 24 04       	movzwl 0x4(%esp),%eax
        trace (0, "Insufficient kernel memory for creating new PD");
        delete pd;
        sys_finish<Sys_regs::BAD_PAR>();
    }

    if (!Space_obj::insert_root (pd->quota, pd)) {
c0012fb2:	89 da                	mov    %ebx,%edx
c0012fb4:	89 0c 24             	mov    %ecx,(%esp)
c0012fb7:	89 83 a0 01 00 00    	mov    %eax,0x1a0(%ebx)
c0012fbd:	89 f8                	mov    %edi,%eax
c0012fbf:	e8 f8 e0 ff ff       	call   c00110bc <_ZN9Space_obj11insert_rootER5QuotaP7Kobject>
c0012fc4:	8b 0c 24             	mov    (%esp),%ecx
c0012fc7:	84 c0                	test   %al,%al
c0012fc9:	75 69                	jne    c0013034 <_ZN2Ec13sys_create_pdEv+0x18e>

class Sys_create_pd : public Sys_regs
{
    public:
        ALWAYS_INLINE
        inline unsigned long sel() const { return ARG_1 >> 8; }
c0012fcb:	8b 56 70             	mov    0x70(%esi),%edx
        trace (TRACE_ERROR, "%s: Non-NULL CAP (%#lx)", __func__, r->sel());
c0012fce:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
c0012fd4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0012fd9:	c1 ea 08             	shr    $0x8,%edx
c0012fdc:	81 f9 00 d0 ff cf    	cmp    $0xcfffd000,%ecx
c0012fe2:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0012fe9:	52                   	push   %edx
c0012fea:	68 90 9c 01 c0       	push   $0xc0019c90
c0012fef:	50                   	push   %eax
c0012ff0:	68 75 98 01 c0       	push   $0xc0019875
c0012ff5:	e8 e4 e9 fe ff       	call   c00019de <_ZN7Console5printEPKcz>
        delete pd;
c0012ffa:	89 d8                	mov    %ebx,%eax
c0012ffc:	e8 e7 99 ff ff       	call   c000c9e8 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c0013001:	8b 43 28             	mov    0x28(%ebx),%eax
c0013004:	83 c4 10             	add    $0x10,%esp
c0013007:	8d 88 78 fe ff ff    	lea    -0x188(%eax),%ecx
c001300d:	85 c0                	test   %eax,%eax
c001300f:	0f 45 e9             	cmovne %ecx,%ebp

            pd_del->quota.free_up(pd_to->quota);
c0013012:	89 f8                	mov    %edi,%eax
c0013014:	81 c5 90 01 00 00    	add    $0x190,%ebp
c001301a:	89 ea                	mov    %ebp,%edx
c001301c:	e8 ab f9 fe ff       	call   c00029cc <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
c0013021:	89 e9                	mov    %ebp,%ecx
c0013023:	89 da                	mov    %ebx,%edx
c0013025:	b8 64 b4 01 c0       	mov    $0xc001b464,%eax
c001302a:	e8 31 d3 ff ff       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
        sys_finish<Sys_regs::BAD_CAP>();
c001302f:	e8 bc f0 ff ff       	call   c00120f0 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>
    }

    Crd crd = r->crd();
c0013034:	8b 46 58             	mov    0x58(%esi),%eax
    pd->del_crd (Pd::current, Crd (Crd::OBJ), crd);
c0013037:	b9 ff 0f 00 00       	mov    $0xfff,%ecx
c001303c:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
        trace (TRACE_ERROR, "%s: Non-NULL CAP (%#lx)", __func__, r->sel());
        delete pd;
        sys_finish<Sys_regs::BAD_CAP>();
    }

    Crd crd = r->crd();
c0013042:	89 44 24 08          	mov    %eax,0x8(%esp)
    pd->del_crd (Pd::current, Crd (Crd::OBJ), crd);
c0013046:	6a 00                	push   $0x0
c0013048:	6a 00                	push   $0x0
c001304a:	8d 44 24 10          	lea    0x10(%esp),%eax
c001304e:	50                   	push   %eax
c001304f:	89 d8                	mov    %ebx,%eax
c0013051:	e8 9a a4 ff ff       	call   c000d4f0 <_ZN2Pd7del_crdEPS_3CrdRS1_mm>

    sys_finish<Sys_regs::SUCCESS>();
c0013056:	e8 77 e4 ff ff       	call   c00114d2 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb0EEEvv>
    }

    Pd *pd = new (Pd::current->quota) Pd (Pd::current, r->sel(), cap.prm());

    if (!pd->quota.set_limit(r->limit_lower(), r->limit_upper(), pd_src->quota)) {
        trace (0, "Insufficient kernel memory for creating new PD");
c001305b:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
c0013061:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0013066:	81 f9 00 d0 ff cf    	cmp    $0xcfffd000,%ecx
c001306c:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0013073:	50                   	push   %eax
c0013074:	68 a6 99 01 c0       	push   $0xc00199a6
c0013079:	e8 60 e9 fe ff       	call   c00019de <_ZN7Console5printEPKcz>
        delete pd;
c001307e:	85 db                	test   %ebx,%ebx
c0013080:	58                   	pop    %eax
c0013081:	5a                   	pop    %edx
c0013082:	0f 84 ad fe ff ff    	je     c0012f35 <_ZN2Ec13sys_create_pdEv+0x8f>
c0013088:	89 d8                	mov    %ebx,%eax
c001308a:	e8 59 99 ff ff       	call   c000c9e8 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c001308f:	8b 43 28             	mov    0x28(%ebx),%eax
c0013092:	85 c0                	test   %eax,%eax
c0013094:	8d 88 78 fe ff ff    	lea    -0x188(%eax),%ecx

            pd_del->quota.free_up(pd_to->quota);
c001309a:	89 f8                	mov    %edi,%eax

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c001309c:	0f 45 e9             	cmovne %ecx,%ebp

            pd_del->quota.free_up(pd_to->quota);
c001309f:	81 c5 90 01 00 00    	add    $0x190,%ebp
c00130a5:	89 ea                	mov    %ebp,%edx
c00130a7:	e8 20 f9 fe ff       	call   c00029cc <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
c00130ac:	89 e9                	mov    %ebp,%ecx
c00130ae:	89 da                	mov    %ebx,%edx
c00130b0:	b8 64 b4 01 c0       	mov    $0xc001b464,%eax
c00130b5:	e8 a6 d2 ff ff       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
c00130ba:	e9 76 fe ff ff       	jmp    c0012f35 <_ZN2Ec13sys_create_pdEv+0x8f>
c00130bf:	90                   	nop

c00130c0 <_ZN2Ec11sys_pd_ctrlEv>:

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_pd_ctrl()
{
c00130c0:	53                   	push   %ebx
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
c00130c1:	ba 01 00 00 00       	mov    $0x1,%edx

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_pd_ctrl()
{
c00130c6:	51                   	push   %ecx
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
c00130c7:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c00130cc:	05 90 01 00 00       	add    $0x190,%eax
c00130d1:	e8 e8 e3 ff ff       	call   c00114be <_ZN5Quota9hit_limitEm>
c00130d6:	84 c0                	test   %al,%al
c00130d8:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c00130dd:	74 21                	je     c0013100 <_ZN2Ec11sys_pd_ctrlEv+0x40>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu (%lu)", __func__, __LINE__, Pd::current->quota.usage(), Pd::current->quota.limit(), r);

        if (Ec::current->pt_oom && call)
c00130df:	8b 90 f8 00 00 00    	mov    0xf8(%eax),%edx
c00130e5:	85 d2                	test   %edx,%edx
c00130e7:	74 12                	je     c00130fb <_ZN2Ec11sys_pd_ctrlEv+0x3b>
            Ec::current->oom_call_cpu (Ec::current->pt_oom, Ec::current->pt_oom->id, C, C);
c00130e9:	8b 4a 58             	mov    0x58(%edx),%ecx
c00130ec:	68 c0 30 01 c0       	push   $0xc00130c0
c00130f1:	68 c0 30 01 c0       	push   $0xc00130c0
c00130f6:	e8 95 87 ff ff       	call   c000b890 <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_>

        sys_finish<Sys_regs::QUO_OOM>();
c00130fb:	e8 b4 f2 ff ff       	call   c00123b4 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE9ELb0EEEvv>
c0013100:	8b 48 70             	mov    0x70(%eax),%ecx

class Sys_pd_ctrl : public Sys_regs
{
    public:
        ALWAYS_INLINE
        inline unsigned long src() const { return ARG_1 >> 8; }
c0013103:	89 ca                	mov    %ecx,%edx
c0013105:	c1 ea 08             	shr    $0x8,%edx
c0013108:	8b 1c 95 00 00 00 e0 	mov    -0x20000000(,%edx,4),%ebx
c001310f:	83 e3 e0             	and    $0xffffffe0,%ebx
c0013112:	74 06                	je     c001311a <_ZN2Ec11sys_pd_ctrlEv+0x5a>
    check<sys_pd_ctrl>(1);

    Sys_pd_ctrl *r = static_cast<Sys_pd_ctrl *>(current->sys_regs());

    Capability cap = Space_obj::lookup (r->src());
    if (EXPECT_FALSE (cap.obj()->type() != Kobject::PD)) {
c0013114:	80 7b 44 00          	cmpb   $0x0,0x44(%ebx)
c0013118:	74 28                	je     c0013142 <_ZN2Ec11sys_pd_ctrlEv+0x82>
        trace (TRACE_ERROR, "%s: Bad src PD CAP (%#lx)", __func__, r->src());
c001311a:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c001311e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0013123:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c0013128:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c001312d:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0013134:	52                   	push   %edx
c0013135:	68 14 9c 01 c0       	push   $0xc0019c14
c001313a:	50                   	push   %eax
c001313b:	68 dc 99 01 c0       	push   $0xc00199dc
c0013140:	eb 5f                	jmp    c00131a1 <_ZN2Ec11sys_pd_ctrlEv+0xe1>
        sys_finish<Sys_regs::BAD_CAP>();
    }
    Pd *src = static_cast<Pd *>(cap.obj());

    if (r->dbg()) {
c0013142:	f6 c1 20             	test   $0x20,%cl
c0013145:	74 17                	je     c001315e <_ZN2Ec11sys_pd_ctrlEv+0x9e>
c0013147:	8b 93 94 01 00 00    	mov    0x194(%ebx),%edx
c001314d:	8b 8b 9c 01 00 00    	mov    0x19c(%ebx),%ecx

        ALWAYS_INLINE
        inline void dump (mword l, mword u)
        {
            ARG_2 = l;
            ARG_3 = u;
c0013153:	89 50 58             	mov    %edx,0x58(%eax)
        inline unsigned long tra() const { return ARG_3; }

        ALWAYS_INLINE
        inline void dump (mword l, mword u)
        {
            ARG_2 = l;
c0013156:	89 48 54             	mov    %ecx,0x54(%eax)
c0013159:	e9 98 00 00 00       	jmp    c00131f6 <_ZN2Ec11sys_pd_ctrlEv+0x136>
c001315e:	8b 48 54             	mov    0x54(%eax),%ecx
{
    private:
        ALWAYS_INLINE
        static inline mword idx_to_virt (unsigned long idx)
        {
            return SPC_LOCAL_OBJ + (idx % caps) * sizeof (Capability);
c0013161:	89 ca                	mov    %ecx,%edx
c0013163:	81 e2 ff ff ff 07    	and    $0x7ffffff,%edx
        Capability() : val (0) {}

        Capability (Kobject *o, mword a) : val (a ? reinterpret_cast<mword>(o) | (a & perm) : 0) {}

        ALWAYS_INLINE
        inline Kobject *obj() const { return reinterpret_cast<Kobject *>(val & ~perm); }
c0013169:	8b 14 95 00 00 00 e0 	mov    -0x20000000(,%edx,4),%edx
c0013170:	83 e2 e0             	and    $0xffffffe0,%edx
c0013173:	74 06                	je     c001317b <_ZN2Ec11sys_pd_ctrlEv+0xbb>
        r->dump(src->quota.limit(), src->quota.usage());
        sys_finish<Sys_regs::SUCCESS>();
    }

    Capability cap_pd = Space_obj::lookup (r->dst());
    if (EXPECT_FALSE (cap_pd.obj()->type() != Kobject::PD)) {
c0013175:	80 7a 44 00          	cmpb   $0x0,0x44(%edx)
c0013179:	74 30                	je     c00131ab <_ZN2Ec11sys_pd_ctrlEv+0xeb>
        trace (TRACE_ERROR, "%s: Bad dst PD CAP (%#lx)", __func__, r->dst());
c001317b:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c001317f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0013184:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c0013189:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c001318e:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0013195:	51                   	push   %ecx
c0013196:	68 14 9c 01 c0       	push   $0xc0019c14
c001319b:	50                   	push   %eax
c001319c:	68 fd 99 01 c0       	push   $0xc00199fd
c00131a1:	e8 38 e8 fe ff       	call   c00019de <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_CAP>();
c00131a6:	e8 45 ef ff ff       	call   c00120f0 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>
    }
    Pd *dst = static_cast<Pd *>(cap_pd.obj());

    if (!src->quota.transfer_to(dst->quota, r->tra())) {
c00131ab:	8b 48 58             	mov    0x58(%eax),%ecx
c00131ae:	81 c2 90 01 00 00    	add    $0x190,%edx
c00131b4:	6a 01                	push   $0x1
c00131b6:	8d 83 90 01 00 00    	lea    0x190(%ebx),%eax
c00131bc:	e8 2b f9 fe ff       	call   c0002aec <_ZN5Quota11transfer_toERS_mb>
c00131c1:	5a                   	pop    %edx
c00131c2:	84 c0                	test   %al,%al
c00131c4:	75 30                	jne    c00131f6 <_ZN2Ec11sys_pd_ctrlEv+0x136>
        trace (TRACE_ERROR, "%s: PD %p has insufficient kernel memory quota", __func__, src);
c00131c6:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c00131ca:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c00131cf:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c00131d4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00131d9:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c00131e0:	53                   	push   %ebx
c00131e1:	68 14 9c 01 c0       	push   $0xc0019c14
c00131e6:	50                   	push   %eax
c00131e7:	68 1e 9a 01 c0       	push   $0xc0019a1e
c00131ec:	e8 ed e7 fe ff       	call   c00019de <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_PAR>();
c00131f1:	e8 42 fc ff ff       	call   c0012e38 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE5ELb0EEEvv>
    }

    sys_finish<Sys_regs::SUCCESS>();
c00131f6:	e8 d7 e2 ff ff       	call   c00114d2 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb0EEEvv>
c00131fb:	90                   	nop

c00131fc <_ZN2Ec13sys_create_scEv>:

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_create_sc()
{
c00131fc:	55                   	push   %ebp
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
c00131fd:	31 d2                	xor    %edx,%edx

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_create_sc()
{
c00131ff:	57                   	push   %edi
c0013200:	56                   	push   %esi
c0013201:	53                   	push   %ebx
c0013202:	83 ec 10             	sub    $0x10,%esp
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
c0013205:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c001320a:	05 90 01 00 00       	add    $0x190,%eax
c001320f:	e8 aa e2 ff ff       	call   c00114be <_ZN5Quota9hit_limitEm>
c0013214:	84 c0                	test   %al,%al
c0013216:	74 05                	je     c001321d <_ZN2Ec13sys_create_scEv+0x21>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu (%lu)", __func__, __LINE__, Pd::current->quota.usage(), Pd::current->quota.limit(), r);

        if (Ec::current->pt_oom && call)
            Ec::current->oom_call_cpu (Ec::current->pt_oom, Ec::current->pt_oom->id, C, C);

        sys_finish<Sys_regs::QUO_OOM>();
c0013218:	e8 97 f1 ff ff       	call   c00123b4 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE9ELb0EEEvv>

void Ec::sys_create_sc()
{
    check<sys_create_sc>(0, false);

    Sys_create_sc *r = static_cast<Sys_create_sc *>(current->sys_regs());
c001321d:	8b 3d 08 f0 ff cf    	mov    0xcffff008,%edi
c0013223:	8d 5c 24 0b          	lea    0xb(%esp),%ebx
c0013227:	8b 4f 54             	mov    0x54(%edi),%ecx
c001322a:	89 c8                	mov    %ecx,%eax
c001322c:	25 ff ff ff 07       	and    $0x7ffffff,%eax
        static unsigned const caps = (END_SPACE_LIM - SPC_LOCAL_OBJ) / sizeof (Capability);

        ALWAYS_INLINE
        static inline Capability lookup (unsigned long idx)
        {
            return *reinterpret_cast<Capability *>(idx_to_virt (idx));
c0013231:	8b 04 85 00 00 00 e0 	mov    -0x20000000(,%eax,4),%eax
c0013238:	89 c2                	mov    %eax,%edx
c001323a:	83 e2 e0             	and    $0xffffffe0,%edx
c001323d:	74 0a                	je     c0013249 <_ZN2Ec13sys_create_scEv+0x4d>

    trace (TRACE_SYSCALL, "EC:%p SYS_CREATE SC:%#lx EC:%#lx P:%#x Q:%#x", current, r->sel(), r->ec(), r->qpd().prio(), r->qpd().quantum());

    Capability cap = Space_obj::lookup (r->pd());
    if (EXPECT_FALSE (cap.obj()->type() != Kobject::PD) || !(cap.prm() & 1UL << Kobject::SC)) {
c001323f:	80 7a 44 00          	cmpb   $0x0,0x44(%edx)
c0013243:	75 04                	jne    c0013249 <_ZN2Ec13sys_create_scEv+0x4d>
c0013245:	a8 04                	test   $0x4,%al
c0013247:	75 26                	jne    c001326f <_ZN2Ec13sys_create_scEv+0x73>
        trace (TRACE_ERROR, "%s: Non-PD CAP (%#lx)", __func__, r->pd());
c0013249:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
c001324f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0013254:	81 fb 00 d0 ff cf    	cmp    $0xcfffd000,%ebx
c001325a:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0013261:	51                   	push   %ecx
c0013262:	68 70 9c 01 c0       	push   $0xc0019c70
c0013267:	50                   	push   %eax
c0013268:	68 21 98 01 c0       	push   $0xc0019821
c001326d:	eb 5d                	jmp    c00132cc <_ZN2Ec13sys_create_scEv+0xd0>
        sys_finish<Sys_regs::BAD_CAP>();
    }
    Pd *pd = static_cast<Pd *>(cap.obj());

    if (pd->quota.hit_limit(2)) {
c001326f:	8d 82 90 01 00 00    	lea    0x190(%edx),%eax
c0013275:	ba 02 00 00 00       	mov    $0x2,%edx
c001327a:	89 04 24             	mov    %eax,(%esp)
c001327d:	e8 3c e2 ff ff       	call   c00114be <_ZN5Quota9hit_limitEm>
c0013282:	84 c0                	test   %al,%al
c0013284:	75 92                	jne    c0013218 <_ZN2Ec13sys_create_scEv+0x1c>
c0013286:	8b 57 58             	mov    0x58(%edi),%edx
{
    private:
        ALWAYS_INLINE
        static inline mword idx_to_virt (unsigned long idx)
        {
            return SPC_LOCAL_OBJ + (idx % caps) * sizeof (Capability);
c0013289:	89 d0                	mov    %edx,%eax
c001328b:	25 ff ff ff 07       	and    $0x7ffffff,%eax
        static unsigned const caps = (END_SPACE_LIM - SPC_LOCAL_OBJ) / sizeof (Capability);

        ALWAYS_INLINE
        static inline Capability lookup (unsigned long idx)
        {
            return *reinterpret_cast<Capability *>(idx_to_virt (idx));
c0013290:	8b 04 85 00 00 00 e0 	mov    -0x20000000(,%eax,4),%eax
c0013297:	89 c5                	mov    %eax,%ebp
c0013299:	83 e5 e0             	and    $0xffffffe0,%ebp
c001329c:	74 0a                	je     c00132a8 <_ZN2Ec13sys_create_scEv+0xac>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu", __func__, __LINE__, pd->quota.usage(), pd->quota.limit());
        sys_finish<Sys_regs::QUO_OOM>();
    }

    Capability cap_sc = Space_obj::lookup (r->ec());
    if (EXPECT_FALSE (cap_sc.obj()->type() != Kobject::EC) || !(cap_sc.prm() & 1UL << Kobject::SC)) {
c001329e:	80 7d 44 01          	cmpb   $0x1,0x44(%ebp)
c00132a2:	75 04                	jne    c00132a8 <_ZN2Ec13sys_create_scEv+0xac>
c00132a4:	a8 04                	test   $0x4,%al
c00132a6:	75 2e                	jne    c00132d6 <_ZN2Ec13sys_create_scEv+0xda>
        trace (TRACE_ERROR, "%s: Non-EC CAP (%#lx)", __func__, r->ec());
c00132a8:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
c00132ae:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00132b3:	81 fb 00 d0 ff cf    	cmp    $0xcfffd000,%ebx
c00132b9:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c00132c0:	52                   	push   %edx
c00132c1:	68 70 9c 01 c0       	push   $0xc0019c70
c00132c6:	50                   	push   %eax
c00132c7:	68 3e 98 01 c0       	push   $0xc001983e
c00132cc:	e8 0d e7 fe ff       	call   c00019de <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_CAP>();
c00132d1:	e8 1a ee ff ff       	call   c00120f0 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>
    }
    Ec *ec = static_cast<Ec *>(cap_sc.obj());

    if (EXPECT_FALSE (!ec->glb)) {
c00132d6:	66 83 bd ce 00 00 00 	cmpw   $0x0,0xce(%ebp)
c00132dd:	00 
c00132de:	75 2d                	jne    c001330d <_ZN2Ec13sys_create_scEv+0x111>
        trace (TRACE_ERROR, "%s: Cannot bind SC", __func__);
c00132e0:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
c00132e6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00132eb:	81 fb 00 d0 ff cf    	cmp    $0xcfffd000,%ebx
c00132f1:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c00132f8:	68 70 9c 01 c0       	push   $0xc0019c70
c00132fd:	50                   	push   %eax
c00132fe:	68 54 9a 01 c0       	push   $0xc0019a54
c0013303:	e8 d6 e6 fe ff       	call   c00019de <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_CAP>();
c0013308:	e8 e3 ed ff ff       	call   c00120f0 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>
c001330d:	8b 47 64             	mov    0x64(%edi),%eax
        }

        ALWAYS_INLINE
        inline unsigned prio() const
        {
            return static_cast<unsigned>(val & 0xff);
c0013310:	0f b6 c8             	movzbl %al,%ecx
    }

    if (EXPECT_FALSE (!r->qpd().prio() || !r->qpd().quantum() | (r->qpd().prio() >= Sc::priorities))) {
c0013313:	85 c9                	test   %ecx,%ecx
c0013315:	0f 84 bc 00 00 00    	je     c00133d7 <_ZN2Ec13sys_create_scEv+0x1db>
        inline explicit Qpd (mword v) : val (v) {}

        ALWAYS_INLINE
        inline unsigned quantum() const
        {
            return static_cast<unsigned>(val >> 12);
c001331b:	c1 e8 0c             	shr    $0xc,%eax
c001331e:	83 f9 7f             	cmp    $0x7f,%ecx
c0013321:	89 c6                	mov    %eax,%esi
c0013323:	0f 87 ae 00 00 00    	ja     c00133d7 <_ZN2Ec13sys_create_scEv+0x1db>
c0013329:	85 c0                	test   %eax,%eax
c001332b:	0f 84 a6 00 00 00    	je     c00133d7 <_ZN2Ec13sys_create_scEv+0x1db>

class Sys_create_sc : public Sys_regs
{
    public:
        ALWAYS_INLINE
        inline unsigned long sel() const { return ARG_1 >> 8; }
c0013331:	8b 47 70             	mov    0x70(%edi),%eax

        NORETURN
        static void schedule (bool = false, bool = true);

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
c0013334:	8b 14 24             	mov    (%esp),%edx
c0013337:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c001333b:	c1 e8 08             	shr    $0x8,%eax
c001333e:	89 44 24 04          	mov    %eax,0x4(%esp)
c0013342:	b8 98 b4 01 c0       	mov    $0xc001b498,%eax
c0013347:	e8 2a cf ff ff       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
        trace (TRACE_ERROR, "%s: Invalid QPD", __func__);
        sys_finish<Sys_regs::BAD_PAR>();
    }

    Sc *sc = new (pd->quota) Sc (Pd::current, r->sel(), ec, ec->cpu, r->qpd().prio(), r->qpd().quantum());
c001334c:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c0013352:	56                   	push   %esi
c0013353:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c0013357:	51                   	push   %ecx
c0013358:	89 c3                	mov    %eax,%ebx
c001335a:	0f b7 85 cc 00 00 00 	movzwl 0xcc(%ebp),%eax
c0013361:	50                   	push   %eax
c0013362:	89 d8                	mov    %ebx,%eax
c0013364:	55                   	push   %ebp
c0013365:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c0013369:	e8 7e c0 ff ff       	call   c000f3ec <_ZN2ScC1EP2PdmP2Ecjjj>
    if (!Space_obj::insert_root (pd->quota, sc)) {
c001336e:	8b 44 24 10          	mov    0x10(%esp),%eax
c0013372:	89 da                	mov    %ebx,%edx
c0013374:	e8 43 dd ff ff       	call   c00110bc <_ZN9Space_obj11insert_rootER5QuotaP7Kobject>
c0013379:	83 c4 10             	add    $0x10,%esp
c001337c:	84 c0                	test   %al,%al
c001337e:	75 4b                	jne    c00133cb <_ZN2Ec13sys_create_scEv+0x1cf>
c0013380:	8b 57 70             	mov    0x70(%edi),%edx
        trace (TRACE_ERROR, "%s: Non-NULL CAP (%#lx)", __func__, r->sel());
c0013383:	8d 44 24 0b          	lea    0xb(%esp),%eax
c0013387:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c001338c:	c1 ea 08             	shr    $0x8,%edx
c001338f:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c0013394:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0013399:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c00133a0:	52                   	push   %edx
c00133a1:	68 70 9c 01 c0       	push   $0xc0019c70
c00133a6:	50                   	push   %eax
c00133a7:	68 75 98 01 c0       	push   $0xc0019875
c00133ac:	e8 2d e6 fe ff       	call   c00019de <_ZN7Console5printEPKcz>
        delete sc;
c00133b1:	83 c4 10             	add    $0x10,%esp
c00133b4:	85 db                	test   %ebx,%ebx
c00133b6:	74 0e                	je     c00133c6 <_ZN2Ec13sys_create_scEv+0x1ca>
c00133b8:	89 d8                	mov    %ebx,%eax
c00133ba:	e8 bb 2f ff ff       	call   c000637a <_ZN2ScD1Ev>
c00133bf:	89 d8                	mov    %ebx,%eax
c00133c1:	e8 7f c5 ff ff       	call   c000f945 <_ZN2ScdlEPv>
        sys_finish<Sys_regs::BAD_CAP>();
c00133c6:	e8 25 ed ff ff       	call   c00120f0 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>
    }

    sc->remote_enqueue();
c00133cb:	89 d8                	mov    %ebx,%eax
c00133cd:	e8 6a c3 ff ff       	call   c000f73c <_ZN2Sc14remote_enqueueEv>

    sys_finish<Sys_regs::SUCCESS>();
c00133d2:	e8 fb e0 ff ff       	call   c00114d2 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb0EEEvv>
        trace (TRACE_ERROR, "%s: Cannot bind SC", __func__);
        sys_finish<Sys_regs::BAD_CAP>();
    }

    if (EXPECT_FALSE (!r->qpd().prio() || !r->qpd().quantum() | (r->qpd().prio() >= Sc::priorities))) {
        trace (TRACE_ERROR, "%s: Invalid QPD", __func__);
c00133d7:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
c00133dd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00133e2:	81 fb 00 d0 ff cf    	cmp    $0xcfffd000,%ebx
c00133e8:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c00133ef:	68 70 9c 01 c0       	push   $0xc0019c70
c00133f4:	50                   	push   %eax
c00133f5:	68 6e 9a 01 c0       	push   $0xc0019a6e
c00133fa:	e8 df e5 fe ff       	call   c00019de <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_PAR>();
c00133ff:	e8 34 fa ff ff       	call   c0012e38 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE5ELb0EEEvv>

c0013404 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE7ELb0EEEvv>:
#include "syscall.hpp"
#include "utcb.hpp"
#include "vectors.hpp"

template <Sys_regs::Status S, bool T>
void Ec::sys_finish()
c0013404:	53                   	push   %ebx
c0013405:	50                   	push   %eax
{
    if (T)
        current->clr_timeout();

    current->regs.set_status (S);
c0013406:	a1 08 f0 ff cf       	mov    0xcffff008,%eax

    if (current->xcpu_sm)
c001340b:	83 b8 f4 00 00 00 00 	cmpl   $0x0,0xf4(%eax)
c0013412:	c7 40 70 07 00 00 00 	movl   $0x7,0x70(%eax)
c0013419:	74 05                	je     c0013420 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE7ELb0EEEvv+0x1c>
        xcpu_return();
c001341b:	e8 6e 0c ff ff       	call   c000408e <_ZN2Ec11xcpu_returnEv>

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
c0013420:	8b 1d 0c f0 ff cf    	mov    0xcffff00c,%ebx
c0013426:	31 d2                	xor    %edx,%edx
c0013428:	8d 83 90 01 00 00    	lea    0x190(%ebx),%eax
c001342e:	e8 8b e0 ff ff       	call   c00114be <_ZN5Quota9hit_limitEm>
c0013433:	84 c0                	test   %al,%al
c0013435:	75 05                	jne    c001343c <_ZN2Ec10sys_finishILN8Sys_regs6StatusE7ELb0EEEvv+0x38>
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());

    ret_user_sysexit();
c0013437:	e8 c4 cb fe ff       	call   c0000000 <_ZN2Ec16ret_user_sysexitEv>

    if (current->xcpu_sm)
        xcpu_return();

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());
c001343c:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c0013440:	ff b3 9c 01 00 00    	pushl  0x19c(%ebx)
c0013446:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c001344b:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c0013450:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0013455:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c001345c:	ff b3 94 01 00 00    	pushl  0x194(%ebx)
c0013462:	50                   	push   %eax
c0013463:	68 4c 97 01 c0       	push   $0xc001974c
c0013468:	e8 71 e5 fe ff       	call   c00019de <_ZN7Console5printEPKcz>
c001346d:	83 c4 10             	add    $0x10,%esp
c0013470:	eb c5                	jmp    c0013437 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE7ELb0EEEvv+0x33>

c0013472 <_ZN2Ec11sys_ec_ctrlEv>:

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_ec_ctrl()
{
c0013472:	55                   	push   %ebp
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
c0013473:	ba 01 00 00 00       	mov    $0x1,%edx

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_ec_ctrl()
{
c0013478:	57                   	push   %edi
c0013479:	56                   	push   %esi
c001347a:	53                   	push   %ebx
c001347b:	83 ec 5c             	sub    $0x5c,%esp
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
c001347e:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c0013483:	05 90 01 00 00       	add    $0x190,%eax
c0013488:	e8 31 e0 ff ff       	call   c00114be <_ZN5Quota9hit_limitEm>
c001348d:	8b 35 08 f0 ff cf    	mov    0xcffff008,%esi
c0013493:	84 c0                	test   %al,%al
c0013495:	74 23                	je     c00134ba <_ZN2Ec11sys_ec_ctrlEv+0x48>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu (%lu)", __func__, __LINE__, Pd::current->quota.usage(), Pd::current->quota.limit(), r);

        if (Ec::current->pt_oom && call)
c0013497:	8b 96 f8 00 00 00    	mov    0xf8(%esi),%edx
c001349d:	85 d2                	test   %edx,%edx
c001349f:	74 14                	je     c00134b5 <_ZN2Ec11sys_ec_ctrlEv+0x43>
            Ec::current->oom_call_cpu (Ec::current->pt_oom, Ec::current->pt_oom->id, C, C);
c00134a1:	8b 4a 58             	mov    0x58(%edx),%ecx
c00134a4:	89 f0                	mov    %esi,%eax
c00134a6:	68 72 34 01 c0       	push   $0xc0013472
c00134ab:	68 72 34 01 c0       	push   $0xc0013472
c00134b0:	e8 db 83 ff ff       	call   c000b890 <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_>

        sys_finish<Sys_regs::QUO_OOM>();
c00134b5:	e8 fa ee ff ff       	call   c00123b4 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE9ELb0EEEvv>
c00134ba:	8b 46 70             	mov    0x70(%esi),%eax
            BAD_DEV,
            QUO_OOM,
        };

        ALWAYS_INLINE
        inline unsigned flags() const { return ARG_1 >> 4 & 0xf; }
c00134bd:	89 c2                	mov    %eax,%edx
c00134bf:	c1 ea 04             	shr    $0x4,%edx

        ALWAYS_INLINE
        inline unsigned long cnt() const { return ARG_2; }

        ALWAYS_INLINE
        inline unsigned op() const { return flags() & 0x3; }
c00134c2:	83 e2 03             	and    $0x3,%edx
{
    check<sys_ec_ctrl>(1);

    Sys_ec_ctrl *r = static_cast<Sys_ec_ctrl *>(current->sys_regs());

    switch (r->op()) {
c00134c5:	83 fa 02             	cmp    $0x2,%edx
c00134c8:	0f 84 13 01 00 00    	je     c00135e1 <_ZN2Ec11sys_ec_ctrlEv+0x16f>
c00134ce:	83 fa 03             	cmp    $0x3,%edx
c00134d1:	0f 84 6d 01 00 00    	je     c0013644 <_ZN2Ec11sys_ec_ctrlEv+0x1d2>
c00134d7:	4a                   	dec    %edx
c00134d8:	0f 84 f8 00 00 00    	je     c00135d6 <_ZN2Ec11sys_ec_ctrlEv+0x164>

class Sys_ec_ctrl : public Sys_regs
{
    public:
        ALWAYS_INLINE
        inline unsigned long ec() const { return ARG_1 >> 8; }
c00134de:	c1 e8 08             	shr    $0x8,%eax
c00134e1:	8b 14 85 00 00 00 e0 	mov    -0x20000000(,%eax,4),%edx
c00134e8:	89 d3                	mov    %edx,%ebx
c00134ea:	83 e3 e0             	and    $0xffffffe0,%ebx
c00134ed:	74 0b                	je     c00134fa <_ZN2Ec11sys_ec_ctrlEv+0x88>
        case 0:
        {
            Capability cap = Space_obj::lookup (r->ec());
            if (EXPECT_FALSE (cap.obj()->type() != Kobject::EC || !(cap.prm() & 1UL << 0))) {
c00134ef:	80 7b 44 01          	cmpb   $0x1,0x44(%ebx)
c00134f3:	75 05                	jne    c00134fa <_ZN2Ec11sys_ec_ctrlEv+0x88>
c00134f5:	f6 c2 01             	test   $0x1,%dl
c00134f8:	75 32                	jne    c001352c <_ZN2Ec11sys_ec_ctrlEv+0xba>
               trace (TRACE_ERROR, "%s: Bad EC CAP (%#lx)", __func__, r->ec());
c00134fa:	8d 54 24 ff          	lea    -0x1(%esp),%edx
c00134fe:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c0013504:	81 fa 00 d0 ff cf    	cmp    $0xcfffd000,%edx
c001350a:	ba ff ff ff ff       	mov    $0xffffffff,%edx
c001350f:	0f 44 15 04 f0 ff cf 	cmove  0xcffff004,%edx
c0013516:	50                   	push   %eax
c0013517:	68 38 9c 01 c0       	push   $0xc0019c38
c001351c:	52                   	push   %edx
c001351d:	68 85 9a 01 c0       	push   $0xc0019a85
c0013522:	e8 b7 e4 fe ff       	call   c00019de <_ZN7Console5printEPKcz>
               sys_finish<Sys_regs::BAD_CAP>();
c0013527:	e8 c4 eb ff ff       	call   c00120f0 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>
            }

            Ec *ec = static_cast<Ec *>(cap.obj());

            if (!(ec->regs.hazard() & HZD_RECALL)) {
c001352c:	83 bb a0 00 00 00 00 	cmpl   $0x0,0xa0(%ebx)
c0013533:	78 2d                	js     c0013562 <_ZN2Ec11sys_ec_ctrlEv+0xf0>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }
c0013535:	f0 81 8b a0 00 00 00 	lock orl $0x80000000,0xa0(%ebx)
c001353c:	00 00 00 80 

                ec->regs.set_hazard (HZD_RECALL);

                if (Cpu::id != ec->cpu && Ec::remote (ec->cpu) == ec) {
c0013540:	0f b7 83 cc 00 00 00 	movzwl 0xcc(%ebx),%eax
c0013547:	39 05 04 f0 ff cf    	cmp    %eax,0xcffff004
c001354d:	74 13                	je     c0013562 <_ZN2Ec11sys_ec_ctrlEv+0xf0>
        }

        ALWAYS_INLINE
        static inline Ec *remote (unsigned c)
        {
            return *reinterpret_cast<volatile typeof current *>(reinterpret_cast<mword>(&current) - CPU_LOCAL_DATA + HV_GLOBAL_CPUS + c * PAGE_SIZE);
c001354f:	89 c2                	mov    %eax,%edx
c0013551:	c1 e2 0c             	shl    $0xc,%edx
c0013554:	8b 92 08 00 c0 ce    	mov    -0x313ffff8(%edx),%edx
c001355a:	39 da                	cmp    %ebx,%edx
c001355c:	0f 84 f5 00 00 00    	je     c0013657 <_ZN2Ec11sys_ec_ctrlEv+0x1e5>
                    if (r->state())
                        sys_finish<Sys_regs::COM_TIM>();
                }
            }

            if (!(r->state() && current->utcb))
c0013562:	83 7e 54 01          	cmpl   $0x1,0x54(%esi)
c0013566:	75 69                	jne    c00135d1 <_ZN2Ec11sys_ec_ctrlEv+0x15f>
c0013568:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c001356d:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
c0013573:	85 c0                	test   %eax,%eax
c0013575:	74 5a                	je     c00135d1 <_ZN2Ec11sys_ec_ctrlEv+0x15f>
                break;

            Cpu_regs regs(ec->regs);
c0013577:	89 e7                	mov    %esp,%edi
c0013579:	b9 17 00 00 00       	mov    $0x17,%ecx
c001357e:	8d 73 54             	lea    0x54(%ebx),%esi
c0013581:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
                       Mtd::GPR_R8_R15 |
#endif
                       Mtd::RSP |
                       Mtd::RIP_LEN |
                       Mtd::RFLAGS |
                       Mtd::QUAL;
c0013583:	c7 44 24 58 1f 80 00 	movl   $0x801f,0x58(%esp)
c001358a:	00 

            if (((ec->cont != ret_user_iret) && (ec->cont != recv_kern))) {
c001358b:	8b 53 50             	mov    0x50(%ebx),%edx
c001358e:	81 fa 2e 00 00 c0    	cmp    $0xc000002e,%edx
c0013594:	0f 85 db 00 00 00    	jne    c0013675 <_ZN2Ec11sys_ec_ctrlEv+0x203>
             * numbers in the comparison are the ones handled as exception in
             * 'entry.S'. Page fault exceptions are not of interest for GDB,
             * which is currently the only user of this status information.
             */
            if ((ec->cont == ret_user_iret) &&
                (ec->partner != nullptr) && (ec->partner->cont == recv_kern) &&
c001359a:	8b 93 bc 00 00 00    	mov    0xbc(%ebx),%edx
             * case if it has called an exception handler portal. The exception
             * numbers in the comparison are the ones handled as exception in
             * 'entry.S'. Page fault exceptions are not of interest for GDB,
             * which is currently the only user of this status information.
             */
            if ((ec->cont == ret_user_iret) &&
c00135a0:	85 d2                	test   %edx,%edx
c00135a2:	0f 84 09 01 00 00    	je     c00136b1 <_ZN2Ec11sys_ec_ctrlEv+0x23f>
                (ec->partner != nullptr) && (ec->partner->cont == recv_kern) &&
c00135a8:	81 7a 50 8c 00 00 c0 	cmpl   $0xc000008c,0x50(%edx)
c00135af:	0f 85 fc 00 00 00    	jne    c00136b1 <_ZN2Ec11sys_ec_ctrlEv+0x23f>
                ((regs.dst_portal <= 0x01) ||
c00135b5:	8b 54 24 34          	mov    0x34(%esp),%edx
             * numbers in the comparison are the ones handled as exception in
             * 'entry.S'. Page fault exceptions are not of interest for GDB,
             * which is currently the only user of this status information.
             */
            if ((ec->cont == ret_user_iret) &&
                (ec->partner != nullptr) && (ec->partner->cont == recv_kern) &&
c00135b9:	83 fa 01             	cmp    $0x1,%edx
c00135bc:	0f 87 cb 00 00 00    	ja     c001368d <_ZN2Ec11sys_ec_ctrlEv+0x21b>
                ((regs.dst_portal <= 0x01) ||
                 ((regs.dst_portal >= 0x03) && (regs.dst_portal <= 0x07)) ||
                 ((regs.dst_portal >= 0x0a) && (regs.dst_portal <= 0x0d)) ||
                 ((regs.dst_portal >= 0x10) && (regs.dst_portal <= 0x13)))) {
                /* 'regs.err' will be transferred into utcb->qual[0] */
                regs.err = 1;
c00135c2:	c7 44 24 30 01 00 00 	movl   $0x1,0x30(%esp)
c00135c9:	00 
            } else
                regs.err = 0;

            bool fpu = current->utcb->load_exc (&regs);
c00135ca:	89 e2                	mov    %esp,%edx
c00135cc:	e8 87 10 00 00       	call   c0014658 <_ZN4Utcb8load_excEP8Cpu_regs>

        default:
            sys_finish<Sys_regs::BAD_PAR>();
    }

    sys_finish<Sys_regs::SUCCESS>();
c00135d1:	e8 fc de ff ff       	call   c00114d2 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb0EEEvv>
            (void)fpu;
            break;
        }

        case 1: /* yield */
            current->cont = sys_finish<Sys_regs::SUCCESS>;
c00135d6:	c7 46 50 d2 14 01 c0 	movl   $0xc00114d2,0x50(%esi)
            Sc::schedule (false, false);
c00135dd:	31 d2                	xor    %edx,%edx
c00135df:	eb 6f                	jmp    c0013650 <_ZN2Ec11sys_ec_ctrlEv+0x1de>
c00135e1:	c1 e8 08             	shr    $0x8,%eax
c00135e4:	8b 1c 85 00 00 00 e0 	mov    -0x20000000(,%eax,4),%ebx
c00135eb:	83 e3 e0             	and    $0xffffffe0,%ebx
c00135ee:	74 06                	je     c00135f6 <_ZN2Ec11sys_ec_ctrlEv+0x184>

        case 2: /* helping */
        {
            Kobject *obj = Space_obj::lookup (r->ec()).obj();

            if (EXPECT_FALSE (obj->type() != Kobject::EC))
c00135f0:	80 7b 44 01          	cmpb   $0x1,0x44(%ebx)
c00135f4:	74 05                	je     c00135fb <_ZN2Ec11sys_ec_ctrlEv+0x189>
                sys_finish<Sys_regs::BAD_CAP>();
c00135f6:	e8 f5 ea ff ff       	call   c00120f0 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>

            Ec *ec = static_cast<Ec *>(obj);

            if (EXPECT_FALSE(ec->cpu != current->cpu))
c00135fb:	8b 83 cc 00 00 00    	mov    0xcc(%ebx),%eax
c0013601:	66 39 86 cc 00 00 00 	cmp    %ax,0xcc(%esi)
c0013608:	74 05                	je     c001360f <_ZN2Ec11sys_ec_ctrlEv+0x19d>
                sys_finish<Sys_regs::BAD_CPU>();
c001360a:	e8 f5 fd ff ff       	call   c0013404 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE7ELb0EEEvv>

            if (EXPECT_FALSE(!ec->utcb || ec->blocked() || ec->partner || ec->pd != Ec::current->pd || (r->cnt() != ec->utcb->tls)))
c001360f:	8b 83 b4 00 00 00    	mov    0xb4(%ebx),%eax
c0013615:	85 c0                	test   %eax,%eax
c0013617:	74 26                	je     c001363f <_ZN2Ec11sys_ec_ctrlEv+0x1cd>
        {
            regs.add_tsc_offset (tsc);
        }

        ALWAYS_INLINE
        inline bool blocked() const { return next || !cont; }
c0013619:	83 bb c4 00 00 00 00 	cmpl   $0x0,0xc4(%ebx)
c0013620:	75 1d                	jne    c001363f <_ZN2Ec11sys_ec_ctrlEv+0x1cd>
c0013622:	83 7b 50 00          	cmpl   $0x0,0x50(%ebx)
c0013626:	74 17                	je     c001363f <_ZN2Ec11sys_ec_ctrlEv+0x1cd>
c0013628:	83 bb bc 00 00 00 00 	cmpl   $0x0,0xbc(%ebx)
c001362f:	75 0e                	jne    c001363f <_ZN2Ec11sys_ec_ctrlEv+0x1cd>
c0013631:	8b be b8 00 00 00    	mov    0xb8(%esi),%edi
c0013637:	39 bb b8 00 00 00    	cmp    %edi,0xb8(%ebx)
c001363d:	74 7f                	je     c00136be <_ZN2Ec11sys_ec_ctrlEv+0x24c>
                sys_finish<Sys_regs::BAD_PAR>();
c001363f:	e8 f4 f7 ff ff       	call   c0012e38 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE5ELb0EEEvv>

            break;
        }

        case 3: /* re-schedule */
            current->cont = sys_finish<Sys_regs::SUCCESS>;
c0013644:	c7 46 50 d2 14 01 c0 	movl   $0xc00114d2,0x50(%esi)
            Sc::schedule (false, true);
c001364b:	ba 01 00 00 00       	mov    $0x1,%edx
c0013650:	31 c0                	xor    %eax,%eax
c0013652:	e8 5b c3 ff ff       	call   c000f9b2 <_ZN2Sc8scheduleEbb>
            if (!(ec->regs.hazard() & HZD_RECALL)) {

                ec->regs.set_hazard (HZD_RECALL);

                if (Cpu::id != ec->cpu && Ec::remote (ec->cpu) == ec) {
                    Lapic::send_ipi (ec->cpu, VEC_IPI_RKE);
c0013657:	6a 00                	push   $0x0
c0013659:	31 c9                	xor    %ecx,%ecx
c001365b:	ba a8 00 00 00       	mov    $0xa8,%edx
c0013660:	e8 ef 26 ff ff       	call   c0005d54 <_ZN5Lapic8send_ipiEjjNS_13Delivery_modeENS_9ShorthandE>
                    if (r->state())
c0013665:	83 7e 54 01          	cmpl   $0x1,0x54(%esi)
c0013669:	58                   	pop    %eax
c001366a:	0f 85 f2 fe ff ff    	jne    c0013562 <_ZN2Ec11sys_ec_ctrlEv+0xf0>
                        sys_finish<Sys_regs::COM_TIM>();
c0013670:	e8 0d ea ff ff       	call   c0012082 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE1ELb0EEEvv>
                       Mtd::RSP |
                       Mtd::RIP_LEN |
                       Mtd::RFLAGS |
                       Mtd::QUAL;

            if (((ec->cont != ret_user_iret) && (ec->cont != recv_kern))) {
c0013675:	81 fa 8c 00 00 c0    	cmp    $0xc000008c,%edx
c001367b:	74 34                	je     c00136b1 <_ZN2Ec11sys_ec_ctrlEv+0x23f>
                /* in syscall */
                regs.REG(ip) = ec->regs.ARG_IP;
c001367d:	8b 53 68             	mov    0x68(%ebx),%edx
c0013680:	89 54 24 38          	mov    %edx,0x38(%esp)
                regs.REG(sp) = ec->regs.ARG_SP;
c0013684:	8b 53 6c             	mov    0x6c(%ebx),%edx
c0013687:	89 54 24 44          	mov    %edx,0x44(%esp)
c001368b:	eb 24                	jmp    c00136b1 <_ZN2Ec11sys_ec_ctrlEv+0x23f>
             * 'entry.S'. Page fault exceptions are not of interest for GDB,
             * which is currently the only user of this status information.
             */
            if ((ec->cont == ret_user_iret) &&
                (ec->partner != nullptr) && (ec->partner->cont == recv_kern) &&
                ((regs.dst_portal <= 0x01) ||
c001368d:	8d 4a fd             	lea    -0x3(%edx),%ecx
             * numbers in the comparison are the ones handled as exception in
             * 'entry.S'. Page fault exceptions are not of interest for GDB,
             * which is currently the only user of this status information.
             */
            if ((ec->cont == ret_user_iret) &&
                (ec->partner != nullptr) && (ec->partner->cont == recv_kern) &&
c0013690:	83 f9 04             	cmp    $0x4,%ecx
c0013693:	0f 86 29 ff ff ff    	jbe    c00135c2 <_ZN2Ec11sys_ec_ctrlEv+0x150>
                ((regs.dst_portal <= 0x01) ||
                 ((regs.dst_portal >= 0x03) && (regs.dst_portal <= 0x07)) ||
                 ((regs.dst_portal >= 0x0a) && (regs.dst_portal <= 0x0d)) ||
c0013699:	8d 4a f6             	lea    -0xa(%edx),%ecx
             * which is currently the only user of this status information.
             */
            if ((ec->cont == ret_user_iret) &&
                (ec->partner != nullptr) && (ec->partner->cont == recv_kern) &&
                ((regs.dst_portal <= 0x01) ||
                 ((regs.dst_portal >= 0x03) && (regs.dst_portal <= 0x07)) ||
c001369c:	83 f9 03             	cmp    $0x3,%ecx
c001369f:	0f 86 1d ff ff ff    	jbe    c00135c2 <_ZN2Ec11sys_ec_ctrlEv+0x150>
                 ((regs.dst_portal >= 0x0a) && (regs.dst_portal <= 0x0d)) ||
                 ((regs.dst_portal >= 0x10) && (regs.dst_portal <= 0x13)))) {
c00136a5:	83 ea 10             	sub    $0x10,%edx
             */
            if ((ec->cont == ret_user_iret) &&
                (ec->partner != nullptr) && (ec->partner->cont == recv_kern) &&
                ((regs.dst_portal <= 0x01) ||
                 ((regs.dst_portal >= 0x03) && (regs.dst_portal <= 0x07)) ||
                 ((regs.dst_portal >= 0x0a) && (regs.dst_portal <= 0x0d)) ||
c00136a8:	83 fa 03             	cmp    $0x3,%edx
c00136ab:	0f 86 11 ff ff ff    	jbe    c00135c2 <_ZN2Ec11sys_ec_ctrlEv+0x150>
                 ((regs.dst_portal >= 0x10) && (regs.dst_portal <= 0x13)))) {
                /* 'regs.err' will be transferred into utcb->qual[0] */
                regs.err = 1;
            } else
                regs.err = 0;
c00136b1:	c7 44 24 30 00 00 00 	movl   $0x0,0x30(%esp)
c00136b8:	00 
c00136b9:	e9 0c ff ff ff       	jmp    c00135ca <_ZN2Ec11sys_ec_ctrlEv+0x158>
            Ec *ec = static_cast<Ec *>(obj);

            if (EXPECT_FALSE(ec->cpu != current->cpu))
                sys_finish<Sys_regs::BAD_CPU>();

            if (EXPECT_FALSE(!ec->utcb || ec->blocked() || ec->partner || ec->pd != Ec::current->pd || (r->cnt() != ec->utcb->tls)))
c00136be:	8b 40 0c             	mov    0xc(%eax),%eax
c00136c1:	39 46 54             	cmp    %eax,0x54(%esi)
c00136c4:	0f 85 75 ff ff ff    	jne    c001363f <_ZN2Ec11sys_ec_ctrlEv+0x1cd>
                sys_finish<Sys_regs::BAD_PAR>();

            current->cont = sys_finish<Sys_regs::SUCCESS>;
c00136ca:	c7 46 50 d2 14 01 c0 	movl   $0xc00114d2,0x50(%esi)
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c00136d1:	83 c8 ff             	or     $0xffffffff,%eax
c00136d4:	f0 0f c1 46 48       	lock xadd %eax,0x48(%esi)
        }

        ALWAYS_INLINE NORETURN
        inline void make_current()
        {
            if (EXPECT_FALSE(current->del_ref())) {
c00136d9:	48                   	dec    %eax
c00136da:	75 29                	jne    c0013705 <_ZN2Ec11sys_ec_ctrlEv+0x293>
                delete current;
c00136dc:	8b 35 08 f0 ff cf    	mov    0xcffff008,%esi
c00136e2:	85 f6                	test   %esi,%esi
c00136e4:	74 1f                	je     c0013705 <_ZN2Ec11sys_ec_ctrlEv+0x293>
c00136e6:	89 f0                	mov    %esi,%eax
c00136e8:	e8 21 fe fe ff       	call   c000350e <_ZN2EcD1Ev>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c00136ed:	8b 86 b8 00 00 00    	mov    0xb8(%esi),%eax
c00136f3:	89 f2                	mov    %esi,%edx
c00136f5:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c00136fb:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c0013700:	e8 5b cc ff ff       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
        {
            if (EXPECT_FALSE(current->del_ref())) {
                delete current;
            }

            current = this;
c0013705:	89 1d 08 f0 ff cf    	mov    %ebx,0xcffff008
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c001370b:	8b 43 48             	mov    0x48(%ebx),%eax
c001370e:	85 c0                	test   %eax,%eax
c0013710:	74 0a                	je     c001371c <_ZN2Ec11sys_ec_ctrlEv+0x2aa>
                if (Atomic::cmp_swap (ref, r, r + 1))
c0013712:	8d 50 01             	lea    0x1(%eax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c0013715:	f0 0f b1 53 48       	lock cmpxchg %edx,0x48(%ebx)
c001371a:	75 ef                	jne    c001370b <_ZN2Ec11sys_ec_ctrlEv+0x299>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
c001371c:	8b b3 b8 00 00 00    	mov    0xb8(%ebx),%esi

            current->add_ref();

            Tss::run.sp0 = reinterpret_cast<mword>(exc_regs() + 1);
c0013722:	8d 83 a0 00 00 00    	lea    0xa0(%ebx),%eax
c0013728:	a3 c4 fa ff cf       	mov    %eax,0xcffffac4
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
c001372d:	8b 0d 04 f0 ff cf    	mov    0xcffff004,%ecx
c0013733:	8b 86 70 01 00 00    	mov    0x170(%esi),%eax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
c0013739:	8b 96 68 01 00 00    	mov    0x168(%esi),%edx

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
c001373f:	0f a3 c8             	bt     %ecx,%eax
c0013742:	73 10                	jae    c0013754 <_ZN2Ec11sys_ec_ctrlEv+0x2e2>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
c0013744:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
c0013749:	d3 c0                	rol    %cl,%eax
c001374b:	f0 21 86 70 01 00 00 	lock and %eax,0x170(%esi)
c0013752:	eb 0c                	jmp    c0013760 <_ZN2Ec11sys_ec_ctrlEv+0x2ee>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
c0013754:	39 35 0c f0 ff cf    	cmp    %esi,0xcffff00c
c001375a:	0f 84 a2 00 00 00    	je     c0013802 <_ZN2Ec11sys_ec_ctrlEv+0x390>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c0013760:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c0013765:	83 c9 ff             	or     $0xffffffff,%ecx
c0013768:	f0 0f c1 48 48       	lock xadd %ecx,0x48(%eax)
                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
c001376d:	49                   	dec    %ecx
c001376e:	75 25                	jne    c0013795 <_ZN2Ec11sys_ec_ctrlEv+0x323>
                assert (current != this);
c0013770:	8b 3d 0c f0 ff cf    	mov    0xcffff00c,%edi
c0013776:	39 f7                	cmp    %esi,%edi
c0013778:	75 1d                	jne    c0013797 <_ZN2Ec11sys_ec_ctrlEv+0x325>
c001377a:	68 5c 9d 01 c0       	push   $0xc0019d5c
c001377f:	6a 5e                	push   $0x5e
c0013781:	68 18 73 01 c0       	push   $0xc0017318
c0013786:	68 87 73 01 c0       	push   $0xc0017387
c001378b:	68 69 60 01 c0       	push   $0xc0016069
c0013790:	e8 b1 e1 fe ff       	call   c0001946 <_ZN7Console5panicEPKcz>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
c0013795:	31 ff                	xor    %edi,%edi
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
c0013797:	89 35 0c f0 ff cf    	mov    %esi,0xcffff00c
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c001379d:	8b 46 48             	mov    0x48(%esi),%eax
c00137a0:	85 c0                	test   %eax,%eax
c00137a2:	74 0a                	je     c00137ae <_ZN2Ec11sys_ec_ctrlEv+0x33c>
                if (Atomic::cmp_swap (ref, r, r + 1))
c00137a4:	8d 48 01             	lea    0x1(%eax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
c00137a7:	f0 0f b1 4e 48       	lock cmpxchg %ecx,0x48(%esi)
c00137ac:	75 ef                	jne    c001379d <_ZN2Ec11sys_ec_ctrlEv+0x32b>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
c00137ae:	31 ed                	xor    %ebp,%ebp
c00137b0:	a1 04 f0 ff cf       	mov    0xcffff004,%eax
c00137b5:	f6 05 0a f7 ff cf 02 	testb  $0x2,0xcffff70a
c00137bc:	0f 44 d5             	cmove  %ebp,%edx
c00137bf:	0b 54 86 54          	or     0x54(%esi,%eax,4),%edx
c00137c3:	0f 22 da             	mov    %edx,%cr3

            if (del_pd)
c00137c6:	85 ff                	test   %edi,%edi
c00137c8:	74 38                	je     c0013802 <_ZN2Ec11sys_ec_ctrlEv+0x390>
                delete del_pd;
c00137ca:	89 f8                	mov    %edi,%eax

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c00137cc:	89 ee                	mov    %ebp,%esi
            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);

            if (del_pd)
                delete del_pd;
c00137ce:	e8 15 92 ff ff       	call   c000c9e8 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
c00137d3:	8b 57 28             	mov    0x28(%edi),%edx
c00137d6:	85 d2                	test   %edx,%edx
c00137d8:	8d 82 78 fe ff ff    	lea    -0x188(%edx),%eax
c00137de:	0f 45 f0             	cmovne %eax,%esi

            pd_del->quota.free_up(pd_to->quota);
c00137e1:	81 c6 90 01 00 00    	add    $0x190,%esi
c00137e7:	8d 87 90 01 00 00    	lea    0x190(%edi),%eax
c00137ed:	89 f2                	mov    %esi,%edx
c00137ef:	e8 d8 f1 fe ff       	call   c00029cc <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
c00137f4:	89 f1                	mov    %esi,%ecx
c00137f6:	89 fa                	mov    %edi,%edx
c00137f8:	b8 64 b4 01 c0       	mov    $0xc001b464,%eax
c00137fd:	e8 5e cb ff ff       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>

            pd->make_current();

            asm volatile ("mov %0," EXPAND (PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory"); UNREACHED;
c0013802:	8b 43 50             	mov    0x50(%ebx),%eax
c0013805:	bc 00 e0 ff cf       	mov    $0xcfffe000,%esp
c001380a:	ff e0                	jmp    *%eax

c001380c <_ZN2Ec13sys_xcpu_callEv>:

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_xcpu_call()
{
c001380c:	57                   	push   %edi
c001380d:	56                   	push   %esi
c001380e:	53                   	push   %ebx
c001380f:	83 ec 08             	sub    $0x8,%esp
    Sys_call *s = static_cast<Sys_call *>(current->sys_regs());
c0013812:	8b 0d 08 f0 ff cf    	mov    0xcffff008,%ecx
            DISABLE_DONATION    = 1ul << 1,
            DISABLE_REPLYCAP    = 1ul << 2
        };

        ALWAYS_INLINE
        inline unsigned long pt() const { return ARG_1 >> 8; }
c0013818:	8b 51 70             	mov    0x70(%ecx),%edx
c001381b:	c1 ea 08             	shr    $0x8,%edx
c001381e:	8b 04 95 00 00 00 e0 	mov    -0x20000000(,%edx,4),%eax
c0013825:	83 e0 e0             	and    $0xffffffe0,%eax
c0013828:	74 06                	je     c0013830 <_ZN2Ec13sys_xcpu_callEv+0x24>

    Kobject *obj = Space_obj::lookup (s->pt()).obj();
    if (EXPECT_FALSE (obj->type() != Kobject::PT)) {
c001382a:	80 78 44 03          	cmpb   $0x3,0x44(%eax)
c001382e:	74 30                	je     c0013860 <_ZN2Ec13sys_xcpu_callEv+0x54>
        trace (TRACE_ERROR, "%s: Bad PT CAP (%#lx)", __func__, s->pt());
c0013830:	8d 44 24 03          	lea    0x3(%esp),%eax
c0013834:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0013839:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c001383e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0013843:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c001384a:	52                   	push   %edx
c001384b:	68 e4 9b 01 c0       	push   $0xc0019be4
c0013850:	50                   	push   %eax
c0013851:	68 f1 98 01 c0       	push   $0xc00198f1
c0013856:	e8 83 e1 fe ff       	call   c00019de <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_CAP>();
c001385b:	e8 90 e8 ff ff       	call   c00120f0 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>
{
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
c0013860:	8b 70 4c             	mov    0x4c(%eax),%esi
    }

    Pt *pt = static_cast<Pt *>(obj);
    Ec *ec = pt->ec;

    if (EXPECT_FALSE (current->cpu == ec->cpu)) {
c0013863:	8b 81 cc 00 00 00    	mov    0xcc(%ecx),%eax
c0013869:	66 39 86 cc 00 00 00 	cmp    %ax,0xcc(%esi)
c0013870:	75 2f                	jne    c00138a1 <_ZN2Ec13sys_xcpu_callEv+0x95>
        trace (TRACE_ERROR, "%s: Bad CPU", __func__);
c0013872:	8d 44 24 03          	lea    0x3(%esp),%eax
c0013876:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c001387b:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c0013880:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0013885:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c001388c:	68 e4 9b 01 c0       	push   $0xc0019be4
c0013891:	50                   	push   %eax
c0013892:	68 a2 9a 01 c0       	push   $0xc0019aa2
c0013897:	e8 42 e1 fe ff       	call   c00019de <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_CPU>();
c001389c:	e8 63 fb ff ff       	call   c0013404 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE7ELb0EEEvv>
    }

    enum { UNUSED = 0, CNT = 0 };

    current->xcpu_sm = new (Pd::current->quota) Sm (Pd::current, UNUSED, CNT);
c00138a1:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c00138a6:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx

            call_rcu(true);
        }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
c00138ac:	b8 b4 b4 01 c0       	mov    $0xc001b4b4,%eax
c00138b1:	e8 c0 c9 ff ff       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c00138b6:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c00138bc:	31 c9                	xor    %ecx,%ecx
c00138be:	6a 00                	push   $0x0
c00138c0:	6a 00                	push   $0x0
c00138c2:	6a 00                	push   $0x0
c00138c4:	89 c3                	mov    %eax,%ebx
c00138c6:	e8 4f ce ff ff       	call   c001071a <_ZN2SmC1EP2PdmmPS_m>
c00138cb:	a1 08 f0 ff cf       	mov    0xcffff008,%eax
c00138d0:	89 98 f4 00 00 00    	mov    %ebx,0xf4(%eax)

    Ec *xcpu_ec = new (Pd::current->quota) Ec (Pd::current, Pd::current, Ec::sys_call, ec->cpu, current);
c00138d6:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c00138db:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx
        static void die (char const *, Exc_regs * = &current->regs);

        static void idl_handler();

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
c00138e1:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c00138e6:	e8 8b c9 ff ff       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c00138eb:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c00138f1:	ff 35 08 f0 ff cf    	pushl  0xcffff008
c00138f7:	89 d1                	mov    %edx,%ecx
c00138f9:	89 c3                	mov    %eax,%ebx
c00138fb:	0f b7 86 cc 00 00 00 	movzwl 0xcc(%esi),%eax
c0013902:	50                   	push   %eax
c0013903:	89 d8                	mov    %ebx,%eax
c0013905:	68 70 06 00 c0       	push   $0xc0000670
c001390a:	e8 7b fa fe ff       	call   c000338a <_ZN2EcC1EP2PdS1_PFvvEjPS_>
    Sc *xcpu_sc = new (Pd::current->quota) Sc (Pd::current, xcpu_ec, xcpu_ec->cpu, Sc::current);
c001390f:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c0013914:	8d 90 90 01 00 00    	lea    0x190(%eax),%edx
c001391a:	b8 98 b4 01 c0       	mov    $0xc001b498,%eax
c001391f:	e8 52 c9 ff ff       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c0013924:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c001392a:	89 d9                	mov    %ebx,%ecx
c001392c:	ff 35 10 f0 ff cf    	pushl  0xcffff010
c0013932:	89 c6                	mov    %eax,%esi
c0013934:	0f b7 83 cc 00 00 00 	movzwl 0xcc(%ebx),%eax
c001393b:	50                   	push   %eax
c001393c:	89 f0                	mov    %esi,%eax
c001393e:	e8 4b bb ff ff       	call   c000f48e <_ZN2ScC1EP2PdP2EcjPS_>

    xcpu_sc->remote_enqueue();
c0013943:	89 f0                	mov    %esi,%eax
c0013945:	83 c4 20             	add    $0x20,%esp
c0013948:	e8 ef bd ff ff       	call   c000f73c <_ZN2Sc14remote_enqueueEv>
    current->xcpu_sm->dn (false, 0);
c001394d:	8b 1d 08 f0 ff cf    	mov    0xcffff008,%ebx
c0013953:	8b b3 f4 00 00 00    	mov    0xf4(%ebx),%esi
        }

        ALWAYS_INLINE
        inline void dn (bool zero, uint64 t, Ec *ec = Ec::current, bool block = true)
        {
            {   Lock_guard <Spinlock> guard (lock);
c0013959:	8d 46 46             	lea    0x46(%esi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c001395c:	9c                   	pushf  
c001395d:	5a                   	pop    %edx
            return flags & 0x200;
c001395e:	c1 ea 09             	shr    $0x9,%edx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c0013961:	80 e2 01             	and    $0x1,%dl
c0013964:	74 2a                	je     c0013990 <_ZN2Ec13sys_xcpu_callEv+0x184>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0013966:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c001396d:	75 19                	jne    c0013988 <_ZN2Ec13sys_xcpu_callEv+0x17c>
c001396f:	68 c0 9d 01 c0       	push   $0xc0019dc0
c0013974:	68 b7 00 00 00       	push   $0xb7
c0013979:	68 12 61 01 c0       	push   $0xc0016112
c001397e:	68 83 61 01 c0       	push   $0xc0016183
c0013983:	e9 f9 00 00 00       	jmp    c0013a81 <_ZN2Ec13sys_xcpu_callEv+0x275>

            asm volatile ("cli" : : : "memory");
c0013988:	fa                   	cli    
            preemption = false;
c0013989:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
c0013990:	88 54 24 03          	mov    %dl,0x3(%esp)
                Cpu::preempt_disable();

            _lock.lock();
c0013994:	e8 93 d1 fe ff       	call   c0000b2c <_ZN8Spinlock4lockEv>

                if (counter) {
c0013999:	8b 46 64             	mov    0x64(%esi),%eax
c001399c:	8a 54 24 03          	mov    0x3(%esp),%dl
c00139a0:	85 c0                	test   %eax,%eax
c00139a2:	74 79                	je     c0013a1d <_ZN2Ec13sys_xcpu_callEv+0x211>
                    counter = zero ? 0 : counter - 1;
c00139a4:	48                   	dec    %eax
c00139a5:	89 46 64             	mov    %eax,0x64(%esi)
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c00139a8:	8b 46 50             	mov    0x50(%esi),%eax
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c00139ab:	85 c0                	test   %eax,%eax
c00139ad:	0f 84 e2 00 00 00    	je     c0013a95 <_ZN2Ec13sys_xcpu_callEv+0x289>
c00139b3:	8b 48 08             	mov    0x8(%eax),%ecx
c00139b6:	85 c9                	test   %ecx,%ecx
c00139b8:	0f 84 d7 00 00 00    	je     c0013a95 <_ZN2Ec13sys_xcpu_callEv+0x289>
c00139be:	8b 78 04             	mov    0x4(%eax),%edi
c00139c1:	85 ff                	test   %edi,%edi
c00139c3:	0f 84 cc 00 00 00    	je     c0013a95 <_ZN2Ec13sys_xcpu_callEv+0x289>
                return false;

            if (t == t->next)
c00139c9:	39 c8                	cmp    %ecx,%eax
c00139cb:	75 09                	jne    c00139d6 <_ZN2Ec13sys_xcpu_callEv+0x1ca>
                headptr = nullptr;
c00139cd:	c7 46 50 00 00 00 00 	movl   $0x0,0x50(%esi)
c00139d4:	eb 17                	jmp    c00139ed <_ZN2Ec13sys_xcpu_callEv+0x1e1>

            else {
                t->next->prev = t->prev;
c00139d6:	89 79 04             	mov    %edi,0x4(%ecx)
                t->prev->next = t->next;
c00139d9:	8b 48 04             	mov    0x4(%eax),%ecx
c00139dc:	8b 78 08             	mov    0x8(%eax),%edi
c00139df:	89 79 08             	mov    %edi,0x8(%ecx)
                if (t == headptr)
c00139e2:	3b 46 50             	cmp    0x50(%esi),%eax
c00139e5:	75 06                	jne    c00139ed <_ZN2Ec13sys_xcpu_callEv+0x1e1>
                    headptr = t->next;
c00139e7:	8b 48 08             	mov    0x8(%eax),%ecx
c00139ea:	89 4e 50             	mov    %ecx,0x50(%esi)

    public:

        mword reset(bool l = false) {
            if (l) lock.lock();
            mword c = counter;
c00139ed:	8b 48 10             	mov    0x10(%eax),%ecx
            }

            t->next = t->prev = nullptr;
c00139f0:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
c00139f7:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
            counter = 0;
c00139fe:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
                if (counter) {
                    counter = zero ? 0 : counter - 1;

                    Si * si;
                    if (Queue<Si>::dequeue(si = Queue<Si>::head()))
                        ec->set_si_regs(si->value, static_cast <Sm *>(si)->reset());
c0013a05:	8b 40 0c             	mov    0xc(%eax),%eax

        ALWAYS_INLINE
        inline void set_si_regs(mword sig, mword cnt)
        {
            regs.ARG_2 = sig;
            regs.ARG_3 = cnt;
c0013a08:	89 4b 58             	mov    %ecx,0x58(%ebx)
        }

        ALWAYS_INLINE
        inline void set_si_regs(mword sig, mword cnt)
        {
            regs.ARG_2 = sig;
c0013a0b:	89 43 54             	mov    %eax,0x54(%ebx)
c0013a0e:	e9 82 00 00 00       	jmp    c0013a95 <_ZN2Ec13sys_xcpu_callEv+0x289>

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
                if (Atomic::cmp_swap (ref, r, r + 1))
c0013a13:	8d 48 01             	lea    0x1(%eax),%ecx
c0013a16:	f0 0f b1 4b 48       	lock cmpxchg %ecx,0x48(%ebx)
c0013a1b:	74 07                	je     c0013a24 <_ZN2Ec13sys_xcpu_callEv+0x218>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
c0013a1d:	8b 43 48             	mov    0x48(%ebx),%eax
c0013a20:	85 c0                	test   %eax,%eax
c0013a22:	75 ef                	jne    c0013a13 <_ZN2Ec13sys_xcpu_callEv+0x207>
        inline T *head() const { return headptr; }

        ALWAYS_INLINE
        inline void enqueue (T *t)
        {
            if (!headptr)
c0013a24:	8b 46 4c             	mov    0x4c(%esi),%eax
c0013a27:	85 c0                	test   %eax,%eax
c0013a29:	75 11                	jne    c0013a3c <_ZN2Ec13sys_xcpu_callEv+0x230>
                headptr = t->prev = t->next = t;
c0013a2b:	89 9b c4 00 00 00    	mov    %ebx,0xc4(%ebx)
c0013a31:	89 9b c0 00 00 00    	mov    %ebx,0xc0(%ebx)
c0013a37:	89 5e 4c             	mov    %ebx,0x4c(%esi)
c0013a3a:	eb 21                	jmp    c0013a5d <_ZN2Ec13sys_xcpu_callEv+0x251>
            else {
                t->next = headptr;
c0013a3c:	89 83 c4 00 00 00    	mov    %eax,0xc4(%ebx)
                t->prev = headptr->prev;
c0013a42:	8b 4e 4c             	mov    0x4c(%esi),%ecx
c0013a45:	8b 89 c0 00 00 00    	mov    0xc0(%ecx),%ecx
c0013a4b:	89 8b c0 00 00 00    	mov    %ecx,0xc0(%ebx)
                t->next->prev = t->prev->next = t;
c0013a51:	89 99 c4 00 00 00    	mov    %ebx,0xc4(%ecx)
c0013a57:	89 98 c0 00 00 00    	mov    %ebx,0xc0(%eax)
c0013a5d:	fe 46 46             	incb   0x46(%esi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c0013a60:	84 d2                	test   %dl,%dl
c0013a62:	74 4b                	je     c0013aaf <_ZN2Ec13sys_xcpu_callEv+0x2a3>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0013a64:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0013a6b:	74 1e                	je     c0013a8b <_ZN2Ec13sys_xcpu_callEv+0x27f>
c0013a6d:	68 80 9d 01 c0       	push   $0xc0019d80
c0013a72:	68 c0 00 00 00       	push   $0xc0
c0013a77:	68 12 61 01 c0       	push   $0xc0016112
c0013a7c:	68 82 61 01 c0       	push   $0xc0016182
c0013a81:	68 69 60 01 c0       	push   $0xc0016069
c0013a86:	e8 bb de fe ff       	call   c0001946 <_ZN7Console5panicEPKcz>

            preemption = true;
c0013a8b:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c0013a92:	fb                   	sti    
c0013a93:	eb 1a                	jmp    c0013aaf <_ZN2Ec13sys_xcpu_callEv+0x2a3>
c0013a95:	fe 46 46             	incb   0x46(%esi)
c0013a98:	84 d2                	test   %dl,%dl
c0013a9a:	74 1a                	je     c0013ab6 <_ZN2Ec13sys_xcpu_callEv+0x2aa>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c0013a9c:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0013aa3:	75 c8                	jne    c0013a6d <_ZN2Ec13sys_xcpu_callEv+0x261>

            preemption = true;
c0013aa5:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c0013aac:	fb                   	sti    
c0013aad:	eb 07                	jmp    c0013ab6 <_ZN2Ec13sys_xcpu_callEv+0x2aa>
            if (!block)
                Sc::schedule (false);

            ec->set_timeout (t, this);

            ec->block_sc();
c0013aaf:	89 d8                	mov    %ebx,%eax
c0013ab1:	e8 5a 4a ff ff       	call   c0008510 <_ZN2Ec8block_scEv>

    ret_xcpu_reply();
c0013ab6:	e8 a9 db ff ff       	call   c0011664 <_ZN2Ec14ret_xcpu_replyEv>
c0013abb:	90                   	nop

c0013abc <_ZN2Ec10sys_finishILN8Sys_regs6StatusE6ELb0EEEvv>:
#include "syscall.hpp"
#include "utcb.hpp"
#include "vectors.hpp"

template <Sys_regs::Status S, bool T>
void Ec::sys_finish()
c0013abc:	53                   	push   %ebx
c0013abd:	50                   	push   %eax
{
    if (T)
        current->clr_timeout();

    current->regs.set_status (S);
c0013abe:	a1 08 f0 ff cf       	mov    0xcffff008,%eax

    if (current->xcpu_sm)
c0013ac3:	83 b8 f4 00 00 00 00 	cmpl   $0x0,0xf4(%eax)

        ALWAYS_INLINE
        inline void set_status (Status s, bool c = true)
        {
            if (c)
                ARG_1 = s;
c0013aca:	c7 40 70 06 00 00 00 	movl   $0x6,0x70(%eax)
c0013ad1:	74 05                	je     c0013ad8 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE6ELb0EEEvv+0x1c>
        xcpu_return();
c0013ad3:	e8 b6 05 ff ff       	call   c000408e <_ZN2Ec11xcpu_returnEv>

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
c0013ad8:	8b 1d 0c f0 ff cf    	mov    0xcffff00c,%ebx
c0013ade:	31 d2                	xor    %edx,%edx
c0013ae0:	8d 83 90 01 00 00    	lea    0x190(%ebx),%eax
c0013ae6:	e8 d3 d9 ff ff       	call   c00114be <_ZN5Quota9hit_limitEm>
c0013aeb:	84 c0                	test   %al,%al
c0013aed:	75 05                	jne    c0013af4 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE6ELb0EEEvv+0x38>
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());

    ret_user_sysexit();
c0013aef:	e8 0c c5 fe ff       	call   c0000000 <_ZN2Ec16ret_user_sysexitEv>

    if (current->xcpu_sm)
        xcpu_return();

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());
c0013af4:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c0013af8:	ff b3 9c 01 00 00    	pushl  0x19c(%ebx)
c0013afe:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0013b03:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c0013b08:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0013b0d:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0013b14:	ff b3 94 01 00 00    	pushl  0x194(%ebx)
c0013b1a:	50                   	push   %eax
c0013b1b:	68 4c 97 01 c0       	push   $0xc001974c
c0013b20:	e8 b9 de fe ff       	call   c00019de <_ZN7Console5printEPKcz>
c0013b25:	83 c4 10             	add    $0x10,%esp
c0013b28:	eb c5                	jmp    c0013aef <_ZN2Ec10sys_finishILN8Sys_regs6StatusE6ELb0EEEvv+0x33>

c0013b2a <_ZN2Ec13sys_create_ecEv>:

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_create_ec()
{
c0013b2a:	55                   	push   %ebp
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
c0013b2b:	31 d2                	xor    %edx,%edx

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_create_ec()
{
c0013b2d:	57                   	push   %edi
c0013b2e:	56                   	push   %esi
c0013b2f:	53                   	push   %ebx
c0013b30:	83 ec 1c             	sub    $0x1c,%esp
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
c0013b33:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c0013b38:	05 90 01 00 00       	add    $0x190,%eax
c0013b3d:	e8 7c d9 ff ff       	call   c00114be <_ZN5Quota9hit_limitEm>
c0013b42:	84 c0                	test   %al,%al
c0013b44:	74 05                	je     c0013b4b <_ZN2Ec13sys_create_ecEv+0x21>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu (%lu)", __func__, __LINE__, Pd::current->quota.usage(), Pd::current->quota.limit(), r);

        if (Ec::current->pt_oom && call)
            Ec::current->oom_call_cpu (Ec::current->pt_oom, Ec::current->pt_oom->id, C, C);

        sys_finish<Sys_regs::QUO_OOM>();
c0013b46:	e8 69 e8 ff ff       	call   c00123b4 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE9ELb0EEEvv>

void Ec::sys_create_ec()
{
    check<sys_create_ec>(0, false);

    Sys_create_ec *r = static_cast<Sys_create_ec *>(current->sys_regs());
c0013b4b:	8b 1d 08 f0 ff cf    	mov    0xcffff008,%ebx
c0013b51:	8d 7c 24 17          	lea    0x17(%esp),%edi
c0013b55:	8b 4b 58             	mov    0x58(%ebx),%ecx

        ALWAYS_INLINE
        inline unsigned long pd() const { return ARG_2; }

        ALWAYS_INLINE
        inline unsigned cpu() const { return ARG_3 & 0xfff; }
c0013b58:	89 ca                	mov    %ecx,%edx
c0013b5a:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
c0013b60:	83 fa 3f             	cmp    $0x3f,%edx
c0013b63:	77 0a                	ja     c0013b6f <_ZN2Ec13sys_create_ecEv+0x45>
c0013b65:	f6 04 d5 38 e0 01 c0 	testb  $0x1,-0x3ffe1fc8(,%edx,8)
c0013b6c:	01 
c0013b6d:	75 2e                	jne    c0013b9d <_ZN2Ec13sys_create_ecEv+0x73>

    trace (TRACE_SYSCALL, "EC:%p SYS_CREATE EC:%#lx CPU:%#x UTCB:%#lx ESP:%#lx EVT:%#x", current, r->sel(), r->cpu(), r->utcb(), r->esp(), r->evt());

    if (EXPECT_FALSE (!Hip::cpu_online (r->cpu()))) {
        trace (TRACE_ERROR, "%s: Invalid CPU (%#x)", __func__, r->cpu());
c0013b6f:	81 e7 00 f0 ff ff    	and    $0xfffff000,%edi
c0013b75:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0013b7a:	81 ff 00 d0 ff cf    	cmp    $0xcfffd000,%edi
c0013b80:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0013b87:	52                   	push   %edx
c0013b88:	68 80 9c 01 c0       	push   $0xc0019c80
c0013b8d:	50                   	push   %eax
c0013b8e:	68 b5 9a 01 c0       	push   $0xc0019ab5
c0013b93:	e8 46 de fe ff       	call   c00019de <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_CPU>();
c0013b98:	e8 67 f8 ff ff       	call   c0013404 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE7ELb0EEEvv>
    }

    if (EXPECT_FALSE (!r->utcb() && !(Hip::feature() & (Hip::FEAT_VMX | Hip::FEAT_SVM)))) {
c0013b9d:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
c0013ba3:	75 36                	jne    c0013bdb <_ZN2Ec13sys_create_ecEv+0xb1>
c0013ba5:	f6 05 10 e0 01 c0 06 	testb  $0x6,0xc001e010
c0013bac:	75 2d                	jne    c0013bdb <_ZN2Ec13sys_create_ecEv+0xb1>
        trace (TRACE_ERROR, "%s: VCPUs not supported", __func__);
c0013bae:	81 e7 00 f0 ff ff    	and    $0xfffff000,%edi
c0013bb4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0013bb9:	81 ff 00 d0 ff cf    	cmp    $0xcfffd000,%edi
c0013bbf:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0013bc6:	68 80 9c 01 c0       	push   $0xc0019c80
c0013bcb:	50                   	push   %eax
c0013bcc:	68 d2 9a 01 c0       	push   $0xc0019ad2
c0013bd1:	e8 08 de fe ff       	call   c00019de <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_FTR>();
c0013bd6:	e8 e1 fe ff ff       	call   c0013abc <_ZN2Ec10sys_finishILN8Sys_regs6StatusE6ELb0EEEvv>
c0013bdb:	8b 53 54             	mov    0x54(%ebx),%edx
{
    private:
        ALWAYS_INLINE
        static inline mword idx_to_virt (unsigned long idx)
        {
            return SPC_LOCAL_OBJ + (idx % caps) * sizeof (Capability);
c0013bde:	89 d0                	mov    %edx,%eax
c0013be0:	25 ff ff ff 07       	and    $0x7ffffff,%eax
        static unsigned const caps = (END_SPACE_LIM - SPC_LOCAL_OBJ) / sizeof (Capability);

        ALWAYS_INLINE
        static inline Capability lookup (unsigned long idx)
        {
            return *reinterpret_cast<Capability *>(idx_to_virt (idx));
c0013be5:	8b 04 85 00 00 00 e0 	mov    -0x20000000(,%eax,4),%eax
c0013bec:	89 c5                	mov    %eax,%ebp
c0013bee:	83 e5 e0             	and    $0xffffffe0,%ebp
c0013bf1:	74 0c                	je     c0013bff <_ZN2Ec13sys_create_ecEv+0xd5>
c0013bf3:	0f b6 75 44          	movzbl 0x44(%ebp),%esi
    }

    Capability cap_pd = Space_obj::lookup (r->pd());
    if (EXPECT_FALSE (cap_pd.obj()->type() != Kobject::PD) || !(cap_pd.prm() & 1UL << Kobject::EC)) {
c0013bf7:	85 f6                	test   %esi,%esi
c0013bf9:	75 04                	jne    c0013bff <_ZN2Ec13sys_create_ecEv+0xd5>
c0013bfb:	a8 02                	test   $0x2,%al
c0013bfd:	75 2e                	jne    c0013c2d <_ZN2Ec13sys_create_ecEv+0x103>
        trace (TRACE_ERROR, "%s: Non-PD CAP (%#lx)", __func__, r->pd());
c0013bff:	81 e7 00 f0 ff ff    	and    $0xfffff000,%edi
c0013c05:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0013c0a:	81 ff 00 d0 ff cf    	cmp    $0xcfffd000,%edi
c0013c10:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0013c17:	52                   	push   %edx
c0013c18:	68 80 9c 01 c0       	push   $0xc0019c80
c0013c1d:	50                   	push   %eax
c0013c1e:	68 21 98 01 c0       	push   $0xc0019821
c0013c23:	e8 b6 dd fe ff       	call   c00019de <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_CAP>();
c0013c28:	e8 c3 e4 ff ff       	call   c00120f0 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>
    }
    Pd *pd = static_cast<Pd *>(cap_pd.obj());

    if (pd->quota.hit_limit(7)) {
c0013c2d:	8d 85 90 01 00 00    	lea    0x190(%ebp),%eax
c0013c33:	ba 07 00 00 00       	mov    $0x7,%edx
c0013c38:	89 4c 24 04          	mov    %ecx,0x4(%esp)
c0013c3c:	89 04 24             	mov    %eax,(%esp)
c0013c3f:	e8 7a d8 ff ff       	call   c00114be <_ZN5Quota9hit_limitEm>
c0013c44:	84 c0                	test   %al,%al
c0013c46:	0f 85 fa fe ff ff    	jne    c0013b46 <_ZN2Ec13sys_create_ecEv+0x1c>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu", __func__, __LINE__, pd->quota.usage(), pd->quota.limit());
        sys_finish<Sys_regs::QUO_OOM>();
    }

    if (EXPECT_FALSE (r->utcb() >= USER_ADDR || r->utcb() & PAGE_MASK || !pd->insert_utcb (pd->quota, r->utcb()))) {
c0013c4c:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c0013c50:	81 f9 ff ff ff bf    	cmp    $0xbfffffff,%ecx
c0013c56:	0f 87 1e 01 00 00    	ja     c0013d7a <_ZN2Ec13sys_create_ecEv+0x250>
c0013c5c:	6a 00                	push   $0x0
c0013c5e:	8b 54 24 04          	mov    0x4(%esp),%edx
c0013c62:	8d 45 4c             	lea    0x4c(%ebp),%eax
c0013c65:	e8 aa d1 ff ff       	call   c0010e14 <_ZN9Space_mem11insert_utcbER5Quotamm>
c0013c6a:	5a                   	pop    %edx
c0013c6b:	84 c0                	test   %al,%al
c0013c6d:	0f 84 07 01 00 00    	je     c0013d7a <_ZN2Ec13sys_create_ecEv+0x250>
c0013c73:	8b 43 70             	mov    0x70(%ebx),%eax

class Sys_create_ec : public Sys_regs
{
    public:
        ALWAYS_INLINE
        inline unsigned long sel() const { return ARG_1 >> 8; }
c0013c76:	89 c1                	mov    %eax,%ecx
c0013c78:	c1 e9 08             	shr    $0x8,%ecx
c0013c7b:	8b 3c 8d 04 00 00 e0 	mov    -0x1ffffffc(,%ecx,4),%edi
c0013c82:	83 e7 e0             	and    $0xffffffe0,%edi
c0013c85:	0f 84 e8 00 00 00    	je     c0013d73 <_ZN2Ec13sys_create_ecEv+0x249>
        trace (TRACE_ERROR, "%s: Invalid UTCB address (%#lx)", __func__, r->utcb());
        sys_finish<Sys_regs::BAD_PAR>();
    }

    Capability cap_pt = Space_obj::lookup (r->sel() + 1);
    Pt *pt = cap_pt.obj()->type() == Kobject::PT ? static_cast<Pt *>(cap_pt.obj()) : nullptr;
c0013c8b:	80 7f 44 03          	cmpb   $0x3,0x44(%edi)
c0013c8f:	0f 45 fe             	cmovne %esi,%edi

    Ec *ec = new (pd->quota) Ec (Pd::current, r->sel(), pd, r->flags() & 1 ? static_cast<void (*)()>(send_msg<ret_user_iret>) : nullptr, r->cpu(), r->evt(), r->utcb(), r->esp(), pt);
c0013c92:	a8 10                	test   $0x10,%al
c0013c94:	ba ec 1d 01 c0       	mov    $0xc0011dec,%edx
c0013c99:	b8 00 00 00 00       	mov    $0x0,%eax
c0013c9e:	0f 45 c2             	cmovne %edx,%eax
        static void die (char const *, Exc_regs * = &current->regs);

        static void idl_handler();

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
c0013ca1:	8b 14 24             	mov    (%esp),%edx
c0013ca4:	89 44 24 08          	mov    %eax,0x8(%esp)
c0013ca8:	8b 43 58             	mov    0x58(%ebx),%eax
c0013cab:	89 4c 24 14          	mov    %ecx,0x14(%esp)
c0013caf:	89 44 24 04          	mov    %eax,0x4(%esp)
c0013cb3:	8b 43 5c             	mov    0x5c(%ebx),%eax
c0013cb6:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0013cba:	8b 43 64             	mov    0x64(%ebx),%eax
c0013cbd:	89 44 24 10          	mov    %eax,0x10(%esp)
c0013cc1:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c0013cc6:	e8 ab c5 ff ff       	call   c0010276 <_ZN10Slab_cache5allocER5Quota>
c0013ccb:	8b 15 0c f0 ff cf    	mov    0xcffff00c,%edx
c0013cd1:	57                   	push   %edi
c0013cd2:	ff 74 24 14          	pushl  0x14(%esp)
c0013cd6:	89 c6                	mov    %eax,%esi

        ALWAYS_INLINE
        inline unsigned cpu() const { return ARG_3 & 0xfff; }

        ALWAYS_INLINE
        inline mword utcb() const { return ARG_3 & ~0xfff; }
c0013cd8:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0013cdc:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0013ce1:	50                   	push   %eax
c0013ce2:	ff 74 24 18          	pushl  0x18(%esp)

        ALWAYS_INLINE
        inline unsigned long pd() const { return ARG_2; }

        ALWAYS_INLINE
        inline unsigned cpu() const { return ARG_3 & 0xfff; }
c0013ce6:	8b 44 24 14          	mov    0x14(%esp),%eax
c0013cea:	25 ff 0f 00 00       	and    $0xfff,%eax
c0013cef:	50                   	push   %eax
c0013cf0:	89 f0                	mov    %esi,%eax
c0013cf2:	ff 74 24 1c          	pushl  0x1c(%esp)
c0013cf6:	55                   	push   %ebp
c0013cf7:	8b 4c 24 30          	mov    0x30(%esp),%ecx
c0013cfb:	e8 d8 f0 fe ff       	call   c0002dd8 <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt>

    if (!Space_obj::insert_root (pd->quota, ec)) {
c0013d00:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0013d04:	89 f2                	mov    %esi,%edx
c0013d06:	e8 b1 d3 ff ff       	call   c00110bc <_ZN9Space_obj11insert_rootER5QuotaP7Kobject>
c0013d0b:	83 c4 1c             	add    $0x1c,%esp
c0013d0e:	84 c0                	test   %al,%al
c0013d10:	75 5c                	jne    c0013d6e <_ZN2Ec13sys_create_ecEv+0x244>

class Sys_create_ec : public Sys_regs
{
    public:
        ALWAYS_INLINE
        inline unsigned long sel() const { return ARG_1 >> 8; }
c0013d12:	8b 53 70             	mov    0x70(%ebx),%edx
        trace (TRACE_ERROR, "%s: Non-NULL CAP (%#lx)", __func__, r->sel());
c0013d15:	8d 44 24 17          	lea    0x17(%esp),%eax
c0013d19:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0013d1e:	c1 ea 08             	shr    $0x8,%edx
c0013d21:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c0013d26:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0013d2b:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0013d32:	52                   	push   %edx
c0013d33:	68 80 9c 01 c0       	push   $0xc0019c80
c0013d38:	50                   	push   %eax
c0013d39:	68 75 98 01 c0       	push   $0xc0019875
c0013d3e:	e8 9b dc fe ff       	call   c00019de <_ZN7Console5printEPKcz>
        delete ec;
c0013d43:	83 c4 10             	add    $0x10,%esp
c0013d46:	85 f6                	test   %esi,%esi
c0013d48:	74 1f                	je     c0013d69 <_ZN2Ec13sys_create_ecEv+0x23f>
c0013d4a:	89 f0                	mov    %esi,%eax
c0013d4c:	e8 bd f7 fe ff       	call   c000350e <_ZN2EcD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c0013d51:	8b 86 b8 00 00 00    	mov    0xb8(%esi),%eax
c0013d57:	89 f2                	mov    %esi,%edx
c0013d59:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c0013d5f:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c0013d64:	e8 f7 c5 ff ff       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>
        sys_finish<Sys_regs::BAD_CAP>();
c0013d69:	e8 82 e3 ff ff       	call   c00120f0 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>
    }

    sys_finish<Sys_regs::SUCCESS>();
c0013d6e:	e8 5f d7 ff ff       	call   c00114d2 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb0EEEvv>
        trace (TRACE_ERROR, "%s: Invalid UTCB address (%#lx)", __func__, r->utcb());
        sys_finish<Sys_regs::BAD_PAR>();
    }

    Capability cap_pt = Space_obj::lookup (r->sel() + 1);
    Pt *pt = cap_pt.obj()->type() == Kobject::PT ? static_cast<Pt *>(cap_pt.obj()) : nullptr;
c0013d73:	31 ff                	xor    %edi,%edi
c0013d75:	e9 18 ff ff ff       	jmp    c0013c92 <_ZN2Ec13sys_create_ecEv+0x168>
c0013d7a:	8b 53 58             	mov    0x58(%ebx),%edx
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu", __func__, __LINE__, pd->quota.usage(), pd->quota.limit());
        sys_finish<Sys_regs::QUO_OOM>();
    }

    if (EXPECT_FALSE (r->utcb() >= USER_ADDR || r->utcb() & PAGE_MASK || !pd->insert_utcb (pd->quota, r->utcb()))) {
        trace (TRACE_ERROR, "%s: Invalid UTCB address (%#lx)", __func__, r->utcb());
c0013d7d:	81 e7 00 f0 ff ff    	and    $0xfffff000,%edi
c0013d83:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0013d88:	81 ff 00 d0 ff cf    	cmp    $0xcfffd000,%edi
c0013d8e:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax

        ALWAYS_INLINE
        inline unsigned cpu() const { return ARG_3 & 0xfff; }

        ALWAYS_INLINE
        inline mword utcb() const { return ARG_3 & ~0xfff; }
c0013d95:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c0013d9b:	52                   	push   %edx
c0013d9c:	68 80 9c 01 c0       	push   $0xc0019c80
c0013da1:	50                   	push   %eax
c0013da2:	68 f1 9a 01 c0       	push   $0xc0019af1
c0013da7:	e8 32 dc fe ff       	call   c00019de <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_PAR>();
c0013dac:	e8 87 f0 ff ff       	call   c0012e38 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE5ELb0EEEvv>
c0013db1:	90                   	nop

c0013db2 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE8ELb0EEEvv>:
#include "syscall.hpp"
#include "utcb.hpp"
#include "vectors.hpp"

template <Sys_regs::Status S, bool T>
void Ec::sys_finish()
c0013db2:	53                   	push   %ebx
c0013db3:	50                   	push   %eax
{
    if (T)
        current->clr_timeout();

    current->regs.set_status (S);
c0013db4:	a1 08 f0 ff cf       	mov    0xcffff008,%eax

    if (current->xcpu_sm)
c0013db9:	83 b8 f4 00 00 00 00 	cmpl   $0x0,0xf4(%eax)
c0013dc0:	c7 40 70 08 00 00 00 	movl   $0x8,0x70(%eax)
c0013dc7:	74 05                	je     c0013dce <_ZN2Ec10sys_finishILN8Sys_regs6StatusE8ELb0EEEvv+0x1c>
        xcpu_return();
c0013dc9:	e8 c0 02 ff ff       	call   c000408e <_ZN2Ec11xcpu_returnEv>

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
c0013dce:	8b 1d 0c f0 ff cf    	mov    0xcffff00c,%ebx
c0013dd4:	31 d2                	xor    %edx,%edx
c0013dd6:	8d 83 90 01 00 00    	lea    0x190(%ebx),%eax
c0013ddc:	e8 dd d6 ff ff       	call   c00114be <_ZN5Quota9hit_limitEm>
c0013de1:	84 c0                	test   %al,%al
c0013de3:	75 05                	jne    c0013dea <_ZN2Ec10sys_finishILN8Sys_regs6StatusE8ELb0EEEvv+0x38>
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());

    ret_user_sysexit();
c0013de5:	e8 16 c2 fe ff       	call   c0000000 <_ZN2Ec16ret_user_sysexitEv>

    if (current->xcpu_sm)
        xcpu_return();

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());
c0013dea:	8d 44 24 ff          	lea    -0x1(%esp),%eax
c0013dee:	ff b3 9c 01 00 00    	pushl  0x19c(%ebx)
c0013df4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0013df9:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c0013dfe:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0013e03:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0013e0a:	ff b3 94 01 00 00    	pushl  0x194(%ebx)
c0013e10:	50                   	push   %eax
c0013e11:	68 4c 97 01 c0       	push   $0xc001974c
c0013e16:	e8 c3 db fe ff       	call   c00019de <_ZN7Console5printEPKcz>
c0013e1b:	83 c4 10             	add    $0x10,%esp
c0013e1e:	eb c5                	jmp    c0013de5 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE8ELb0EEEvv+0x33>

c0013e20 <_ZN2Ec14sys_assign_pciEv>:

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_assign_pci()
{
c0013e20:	56                   	push   %esi
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
c0013e21:	ba 04 00 00 00       	mov    $0x4,%edx

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_assign_pci()
{
c0013e26:	53                   	push   %ebx
c0013e27:	83 ec 08             	sub    $0x8,%esp
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
c0013e2a:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c0013e2f:	05 90 01 00 00       	add    $0x190,%eax
c0013e34:	e8 85 d6 ff ff       	call   c00114be <_ZN5Quota9hit_limitEm>
c0013e39:	8b 35 08 f0 ff cf    	mov    0xcffff008,%esi
c0013e3f:	84 c0                	test   %al,%al
c0013e41:	74 1e                	je     c0013e61 <_ZN2Ec14sys_assign_pciEv+0x41>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu (%lu)", __func__, __LINE__, Pd::current->quota.usage(), Pd::current->quota.limit(), r);

        if (Ec::current->pt_oom && call)
c0013e43:	8b 96 f8 00 00 00    	mov    0xf8(%esi),%edx
c0013e49:	85 d2                	test   %edx,%edx
c0013e4b:	74 40                	je     c0013e8d <_ZN2Ec14sys_assign_pciEv+0x6d>
            Ec::current->oom_call_cpu (Ec::current->pt_oom, Ec::current->pt_oom->id, C, C);
c0013e4d:	8b 4a 58             	mov    0x58(%edx),%ecx
c0013e50:	89 f0                	mov    %esi,%eax
c0013e52:	68 20 3e 01 c0       	push   $0xc0013e20
c0013e57:	68 20 3e 01 c0       	push   $0xc0013e20
c0013e5c:	e8 2f 7a ff ff       	call   c000b890 <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_>

class Sys_assign_pci : public Sys_regs
{
    public:
        ALWAYS_INLINE
        inline unsigned long pd() const { return ARG_1 >> 8; }
c0013e61:	8b 46 70             	mov    0x70(%esi),%eax
c0013e64:	c1 e8 08             	shr    $0x8,%eax
c0013e67:	8b 1c 85 00 00 00 e0 	mov    -0x20000000(,%eax,4),%ebx
c0013e6e:	83 e3 e0             	and    $0xffffffe0,%ebx
c0013e71:	74 1f                	je     c0013e92 <_ZN2Ec14sys_assign_pciEv+0x72>
    check<sys_assign_pci>(4);

    Sys_assign_pci *r = static_cast<Sys_assign_pci *>(current->sys_regs());

    Kobject *obj = Space_obj::lookup (r->pd()).obj();
    if (EXPECT_FALSE (obj->type() != Kobject::PD)) {
c0013e73:	80 7b 44 00          	cmpb   $0x0,0x44(%ebx)
c0013e77:	75 19                	jne    c0013e92 <_ZN2Ec14sys_assign_pciEv+0x72>
        sys_finish<Sys_regs::BAD_CAP>();
    }

    Pd * pd = static_cast<Pd *>(obj);

    if (pd->quota.hit_limit(4)) {
c0013e79:	8d 83 90 01 00 00    	lea    0x190(%ebx),%eax
c0013e7f:	ba 04 00 00 00       	mov    $0x4,%edx
c0013e84:	e8 35 d6 ff ff       	call   c00114be <_ZN5Quota9hit_limitEm>
c0013e89:	84 c0                	test   %al,%al
c0013e8b:	74 37                	je     c0013ec4 <_ZN2Ec14sys_assign_pciEv+0xa4>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu (%lu)", __func__, __LINE__, Pd::current->quota.usage(), Pd::current->quota.limit(), r);

        if (Ec::current->pt_oom && call)
            Ec::current->oom_call_cpu (Ec::current->pt_oom, Ec::current->pt_oom->id, C, C);

        sys_finish<Sys_regs::QUO_OOM>();
c0013e8d:	e8 22 e5 ff ff       	call   c00123b4 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE9ELb0EEEvv>

    Sys_assign_pci *r = static_cast<Sys_assign_pci *>(current->sys_regs());

    Kobject *obj = Space_obj::lookup (r->pd()).obj();
    if (EXPECT_FALSE (obj->type() != Kobject::PD)) {
        trace (TRACE_ERROR, "%s: Non-PD CAP (%#lx)", __func__, r->pd());
c0013e92:	8d 54 24 03          	lea    0x3(%esp),%edx
c0013e96:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c0013e9c:	81 fa 00 d0 ff cf    	cmp    $0xcfffd000,%edx
c0013ea2:	ba ff ff ff ff       	mov    $0xffffffff,%edx
c0013ea7:	0f 44 15 04 f0 ff cf 	cmove  0xcffff004,%edx
c0013eae:	50                   	push   %eax
c0013eaf:	68 04 9c 01 c0       	push   $0xc0019c04
c0013eb4:	52                   	push   %edx
c0013eb5:	68 21 98 01 c0       	push   $0xc0019821
c0013eba:	e8 1f db fe ff       	call   c00019de <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_CAP>();
c0013ebf:	e8 2c e2 ff ff       	call   c00120f0 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>

        ALWAYS_INLINE
        inline size_t lookup (mword virt, Paddr &phys)
        {
            mword attr;
            return hpt.lookup (virt, phys, attr);
c0013ec4:	8b 56 54             	mov    0x54(%esi),%edx
c0013ec7:	8d 4c 24 04          	lea    0x4(%esp),%ecx
c0013ecb:	51                   	push   %ecx
c0013ecc:	8d 4c 24 04          	lea    0x4(%esp),%ecx
c0013ed0:	8d 83 54 01 00 00    	lea    0x154(%ebx),%eax
c0013ed6:	e8 51 a1 ff ff       	call   c000e02c <_ZN3PteI3HptmLj2ELj10ELb0EE6lookupEmRmS2_>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu", __func__, __LINE__, pd->quota.usage(), pd->quota.limit());
        sys_finish<Sys_regs::QUO_OOM>();
    }

    Paddr phys; unsigned rid;
    if (EXPECT_FALSE (!pd->Space_mem::lookup (r->dev(), phys) || (rid = Pci::phys_to_rid (phys)) == ~0U)) {
c0013edb:	5a                   	pop    %edx
c0013edc:	85 c0                	test   %eax,%eax
c0013ede:	74 78                	je     c0013f58 <_ZN2Ec14sys_assign_pciEv+0x138>
        static void init (unsigned = 0, unsigned = 0);

        ALWAYS_INLINE
        static inline unsigned phys_to_rid (Paddr p)
        {
            return p - cfg_base < cfg_size ? static_cast<unsigned>((bus_base << 8) + (p - cfg_base) / PAGE_SIZE) : ~0U;
c0013ee0:	8b 14 24             	mov    (%esp),%edx
c0013ee3:	2b 15 c4 b0 01 c0    	sub    0xc001b0c4,%edx
c0013ee9:	3b 15 c0 b0 01 c0    	cmp    0xc001b0c0,%edx
c0013eef:	73 67                	jae    c0013f58 <_ZN2Ec14sys_assign_pciEv+0x138>
c0013ef1:	a1 c8 b0 01 c0       	mov    0xc001b0c8,%eax
c0013ef6:	c1 ea 0c             	shr    $0xc,%edx
c0013ef9:	c1 e0 08             	shl    $0x8,%eax
c0013efc:	01 c2                	add    %eax,%edx
c0013efe:	83 fa ff             	cmp    $0xffffffff,%edx
c0013f01:	74 55                	je     c0013f58 <_ZN2Ec14sys_assign_pciEv+0x138>
c0013f03:	8b 4e 58             	mov    0x58(%esi),%ecx
        inline void write (Register r, T v) { *reinterpret_cast<T volatile *>(reg_base + r) = v; }

        ALWAYS_INLINE
        static inline Pci *find_dev (unsigned long r)
        {
            for (Pci *pci = list; pci; pci = pci->next)
c0013f06:	a1 bc b0 01 c0       	mov    0xc001b0bc,%eax
c0013f0b:	85 c0                	test   %eax,%eax
c0013f0d:	74 15                	je     c0013f24 <_ZN2Ec14sys_assign_pciEv+0x104>
                if (pci->rid == r)
c0013f0f:	0f b7 70 08          	movzwl 0x8(%eax),%esi
c0013f13:	39 ce                	cmp    %ecx,%esi
c0013f15:	75 09                	jne    c0013f20 <_ZN2Ec14sys_assign_pciEv+0x100>
        ALWAYS_INLINE
        static inline Dmar *find_dmar (unsigned long r)
        {
            Pci *pci = find_dev (r);

            return pci ? pci->dmar : nullptr;
c0013f17:	8b 40 0c             	mov    0xc(%eax),%eax
        trace (TRACE_ERROR, "%s: Non-DEV CAP (%#lx)", __func__, r->dev());
        sys_finish<Sys_regs::BAD_DEV>();
    }

    Dmar *dmar = Pci::find_dmar (r->hnt());
    if (EXPECT_FALSE (!dmar)) {
c0013f1a:	85 c0                	test   %eax,%eax
c0013f1c:	75 2e                	jne    c0013f4c <_ZN2Ec14sys_assign_pciEv+0x12c>
c0013f1e:	eb 04                	jmp    c0013f24 <_ZN2Ec14sys_assign_pciEv+0x104>
        inline void write (Register r, T v) { *reinterpret_cast<T volatile *>(reg_base + r) = v; }

        ALWAYS_INLINE
        static inline Pci *find_dev (unsigned long r)
        {
            for (Pci *pci = list; pci; pci = pci->next)
c0013f20:	8b 00                	mov    (%eax),%eax
c0013f22:	eb e7                	jmp    c0013f0b <_ZN2Ec14sys_assign_pciEv+0xeb>
        trace (TRACE_ERROR, "%s: Invalid Hint (%#lx)", __func__, r->hnt());
c0013f24:	8d 44 24 03          	lea    0x3(%esp),%eax
c0013f28:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0013f2d:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c0013f32:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0013f37:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0013f3e:	51                   	push   %ecx
c0013f3f:	68 04 9c 01 c0       	push   $0xc0019c04
c0013f44:	50                   	push   %eax
c0013f45:	68 36 9b 01 c0       	push   $0xc0019b36
c0013f4a:	eb 34                	jmp    c0013f80 <_ZN2Ec14sys_assign_pciEv+0x160>
        sys_finish<Sys_regs::BAD_DEV>();
    }

    dmar->assign (rid, static_cast<Pd *>(obj));
c0013f4c:	89 d9                	mov    %ebx,%ecx
c0013f4e:	e8 e7 e5 fe ff       	call   c000253a <_ZN4Dmar6assignEmP2Pd>

    sys_finish<Sys_regs::SUCCESS>();
c0013f53:	e8 7a d5 ff ff       	call   c00114d2 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb0EEEvv>
        sys_finish<Sys_regs::QUO_OOM>();
    }

    Paddr phys; unsigned rid;
    if (EXPECT_FALSE (!pd->Space_mem::lookup (r->dev(), phys) || (rid = Pci::phys_to_rid (phys)) == ~0U)) {
        trace (TRACE_ERROR, "%s: Non-DEV CAP (%#lx)", __func__, r->dev());
c0013f58:	8d 44 24 03          	lea    0x3(%esp),%eax
c0013f5c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0013f61:	ff 76 54             	pushl  0x54(%esi)
c0013f64:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c0013f69:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0013f6e:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0013f75:	68 04 9c 01 c0       	push   $0xc0019c04
c0013f7a:	50                   	push   %eax
c0013f7b:	68 18 9b 01 c0       	push   $0xc0019b18
c0013f80:	e8 59 da fe ff       	call   c00019de <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_DEV>();
c0013f85:	e8 28 fe ff ff       	call   c0013db2 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE8ELb0EEEvv>

c0013f8a <_ZN2Ec14sys_assign_gsiEv>:

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_assign_gsi()
{
c0013f8a:	57                   	push   %edi
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
c0013f8b:	ba 02 00 00 00       	mov    $0x2,%edx

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_assign_gsi()
{
c0013f90:	56                   	push   %esi
c0013f91:	53                   	push   %ebx
c0013f92:	83 ec 08             	sub    $0x8,%esp
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
c0013f95:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c0013f9a:	05 90 01 00 00       	add    $0x190,%eax
c0013f9f:	e8 1a d5 ff ff       	call   c00114be <_ZN5Quota9hit_limitEm>
c0013fa4:	8b 1d 08 f0 ff cf    	mov    0xcffff008,%ebx
c0013faa:	84 c0                	test   %al,%al
c0013fac:	74 23                	je     c0013fd1 <_ZN2Ec14sys_assign_gsiEv+0x47>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu (%lu)", __func__, __LINE__, Pd::current->quota.usage(), Pd::current->quota.limit(), r);

        if (Ec::current->pt_oom && call)
c0013fae:	8b 93 f8 00 00 00    	mov    0xf8(%ebx),%edx
c0013fb4:	85 d2                	test   %edx,%edx
c0013fb6:	74 14                	je     c0013fcc <_ZN2Ec14sys_assign_gsiEv+0x42>
            Ec::current->oom_call_cpu (Ec::current->pt_oom, Ec::current->pt_oom->id, C, C);
c0013fb8:	8b 4a 58             	mov    0x58(%edx),%ecx
c0013fbb:	89 d8                	mov    %ebx,%eax
c0013fbd:	68 8a 3f 01 c0       	push   $0xc0013f8a
c0013fc2:	68 8a 3f 01 c0       	push   $0xc0013f8a
c0013fc7:	e8 c4 78 ff ff       	call   c000b890 <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_>

        sys_finish<Sys_regs::QUO_OOM>();
c0013fcc:	e8 e3 e3 ff ff       	call   c00123b4 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE9ELb0EEEvv>
c0013fd1:	8b 53 58             	mov    0x58(%ebx),%edx
c0013fd4:	83 fa 3f             	cmp    $0x3f,%edx
c0013fd7:	77 0a                	ja     c0013fe3 <_ZN2Ec14sys_assign_gsiEv+0x59>
c0013fd9:	f6 04 d5 38 e0 01 c0 	testb  $0x1,-0x3ffe1fc8(,%edx,8)
c0013fe0:	01 
c0013fe1:	75 30                	jne    c0014013 <_ZN2Ec14sys_assign_gsiEv+0x89>
    check<sys_assign_gsi>(2);

    Sys_assign_gsi *r = static_cast<Sys_assign_gsi *>(current->sys_regs());

    if (EXPECT_FALSE (!Hip::cpu_online (r->cpu()))) {
        trace (TRACE_ERROR, "%s: Invalid CPU (%#x)", __func__, r->cpu());
c0013fe3:	8d 44 24 03          	lea    0x3(%esp),%eax
c0013fe7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0013fec:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c0013ff1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0013ff6:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c0013ffd:	52                   	push   %edx
c0013ffe:	68 f4 9b 01 c0       	push   $0xc0019bf4
c0014003:	50                   	push   %eax
c0014004:	68 b5 9a 01 c0       	push   $0xc0019ab5
c0014009:	e8 d0 d9 fe ff       	call   c00019de <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_CPU>();
c001400e:	e8 f1 f3 ff ff       	call   c0013404 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE7ELb0EEEvv>

class Sys_assign_gsi : public Sys_regs
{
    public:
        ALWAYS_INLINE
        inline unsigned long sm() const { return ARG_1 >> 8; }
c0014013:	8b 43 70             	mov    0x70(%ebx),%eax
c0014016:	c1 e8 08             	shr    $0x8,%eax
c0014019:	8b 34 85 00 00 00 e0 	mov    -0x20000000(,%eax,4),%esi
c0014020:	83 e6 e0             	and    $0xffffffe0,%esi
c0014023:	74 06                	je     c001402b <_ZN2Ec14sys_assign_gsiEv+0xa1>
    }

    Kobject *obj = Space_obj::lookup (r->sm()).obj();
    if (EXPECT_FALSE (obj->type() != Kobject::SM)) {
c0014025:	80 7e 44 04          	cmpb   $0x4,0x44(%esi)
c0014029:	74 2a                	je     c0014055 <_ZN2Ec14sys_assign_gsiEv+0xcb>
        trace (TRACE_ERROR, "%s: Non-SM CAP (%#lx)", __func__, r->sm());
c001402b:	8d 54 24 03          	lea    0x3(%esp),%edx
c001402f:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c0014035:	81 fa 00 d0 ff cf    	cmp    $0xcfffd000,%edx
c001403b:	ba ff ff ff ff       	mov    $0xffffffff,%edx
c0014040:	0f 44 15 04 f0 ff cf 	cmove  0xcffff004,%edx
c0014047:	50                   	push   %eax
c0014048:	68 f4 9b 01 c0       	push   $0xc0019bf4
c001404d:	52                   	push   %edx
c001404e:	68 94 98 01 c0       	push   $0xc0019894
c0014053:	eb 31                	jmp    c0014086 <_ZN2Ec14sys_assign_gsiEv+0xfc>
        sys_finish<Sys_regs::BAD_CAP>();
    }

    Sm *sm = static_cast<Sm *>(obj);

    if (EXPECT_FALSE (sm->space != static_cast<Space_obj *>(&Pd::kern))) {
c0014055:	81 7e 28 48 b4 01 c0 	cmpl   $0xc001b448,0x28(%esi)
c001405c:	74 32                	je     c0014090 <_ZN2Ec14sys_assign_gsiEv+0x106>
        trace (TRACE_ERROR, "%s: Non-GSI SM (%#lx)", __func__, r->sm());
c001405e:	8d 54 24 03          	lea    0x3(%esp),%edx
c0014062:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c0014068:	81 fa 00 d0 ff cf    	cmp    $0xcfffd000,%edx
c001406e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
c0014073:	0f 44 15 04 f0 ff cf 	cmove  0xcffff004,%edx
c001407a:	50                   	push   %eax
c001407b:	68 f4 9b 01 c0       	push   $0xc0019bf4
c0014080:	52                   	push   %edx
c0014081:	68 55 9b 01 c0       	push   $0xc0019b55
c0014086:	e8 53 d9 fe ff       	call   c00019de <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_CAP>();
c001408b:	e8 60 e0 ff ff       	call   c00120f0 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>
c0014090:	8b 43 64             	mov    0x64(%ebx),%eax
    }

    if (r->si() != ~0UL) {
c0014093:	83 f8 ff             	cmp    $0xffffffff,%eax
c0014096:	0f 84 95 00 00 00    	je     c0014131 <_ZN2Ec14sys_assign_gsiEv+0x1a7>
{
    private:
        ALWAYS_INLINE
        static inline mword idx_to_virt (unsigned long idx)
        {
            return SPC_LOCAL_OBJ + (idx % caps) * sizeof (Capability);
c001409c:	89 c2                	mov    %eax,%edx
c001409e:	81 e2 ff ff ff 07    	and    $0x7ffffff,%edx
c00140a4:	8b 14 95 00 00 00 e0 	mov    -0x20000000(,%edx,4),%edx
c00140ab:	83 e2 e0             	and    $0xffffffe0,%edx
c00140ae:	74 06                	je     c00140b6 <_ZN2Ec14sys_assign_gsiEv+0x12c>
        Kobject *obj_si = Space_obj::lookup (r->si()).obj();
        if (EXPECT_FALSE (obj_si->type() != Kobject::SM)) {
c00140b0:	80 7a 44 04          	cmpb   $0x4,0x44(%edx)
c00140b4:	74 2a                	je     c00140e0 <_ZN2Ec14sys_assign_gsiEv+0x156>
            trace (TRACE_ERROR, "%s: Non-SI CAP (%#lx)", __func__, r->si());
c00140b6:	8d 54 24 03          	lea    0x3(%esp),%edx
c00140ba:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c00140c0:	81 fa 00 d0 ff cf    	cmp    $0xcfffd000,%edx
c00140c6:	ba ff ff ff ff       	mov    $0xffffffff,%edx
c00140cb:	0f 44 15 04 f0 ff cf 	cmove  0xcffff004,%edx
c00140d2:	50                   	push   %eax
c00140d3:	68 f4 9b 01 c0       	push   $0xc0019bf4
c00140d8:	52                   	push   %edx
c00140d9:	68 72 9b 01 c0       	push   $0xc0019b72
c00140de:	eb a6                	jmp    c0014086 <_ZN2Ec14sys_assign_gsiEv+0xfc>
            sys_finish<Sys_regs::BAD_CAP>();
        }

        Sm *si = static_cast<Sm *>(obj_si);

        if (si == sm) {
c00140e0:	39 f2                	cmp    %esi,%edx
c00140e2:	75 0f                	jne    c00140f3 <_ZN2Ec14sys_assign_gsiEv+0x169>
            sm->chain(nullptr);
c00140e4:	8d 42 54             	lea    0x54(%edx),%eax
c00140e7:	31 d2                	xor    %edx,%edx
c00140e9:	e8 30 bf ff ff       	call   c001001e <_ZN2Si5chainEP2Sm>
c00140ee:	e9 f6 00 00 00       	jmp    c00141e9 <_ZN2Ec14sys_assign_gsiEv+0x25f>
            sys_finish<Sys_regs::SUCCESS>();
        }

        if (EXPECT_FALSE (si->space == static_cast<Space_obj *>(&Pd::kern))) {
c00140f3:	81 7a 28 48 b4 01 c0 	cmpl   $0xc001b448,0x28(%edx)
c00140fa:	75 2d                	jne    c0014129 <_ZN2Ec14sys_assign_gsiEv+0x19f>
            trace (TRACE_ERROR, "%s: Invalid-SM CAP (%#lx)", __func__, r->si());
c00140fc:	8d 54 24 03          	lea    0x3(%esp),%edx
c0014100:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c0014106:	81 fa 00 d0 ff cf    	cmp    $0xcfffd000,%edx
c001410c:	ba ff ff ff ff       	mov    $0xffffffff,%edx
c0014111:	0f 44 15 04 f0 ff cf 	cmove  0xcffff004,%edx
c0014118:	50                   	push   %eax
c0014119:	68 f4 9b 01 c0       	push   $0xc0019bf4
c001411e:	52                   	push   %edx
c001411f:	68 8f 9b 01 c0       	push   $0xc0019b8f
c0014124:	e9 5d ff ff ff       	jmp    c0014086 <_ZN2Ec14sys_assign_gsiEv+0xfc>
            sys_finish<Sys_regs::BAD_CAP>();
        }

        sm->chain(si);
c0014129:	8d 46 54             	lea    0x54(%esi),%eax
c001412c:	e8 ed be ff ff       	call   c001001e <_ZN2Si5chainEP2Sm>
    }

    Paddr phys; unsigned rid = 0, gsi = static_cast<unsigned>(sm->node_base - NUM_CPU);
c0014131:	8b 76 30             	mov    0x30(%esi),%esi
c0014134:	31 c9                	xor    %ecx,%ecx
c0014136:	83 ee 40             	sub    $0x40,%esi
    if (EXPECT_FALSE (!Gsi::gsi_table[gsi].ioapic && (!Pd::current->Space_mem::lookup (r->dev(), phys) || ((rid = Pci::phys_to_rid (phys)) == ~0U && (rid = Hpet::phys_to_rid (phys)) == ~0U)))) {
c0014139:	6b c6 0c             	imul   $0xc,%esi,%eax
c001413c:	83 b8 e4 a4 01 c0 00 	cmpl   $0x0,-0x3ffe5b1c(%eax)
c0014143:	0f 85 90 00 00 00    	jne    c00141d9 <_ZN2Ec14sys_assign_gsiEv+0x24f>
c0014149:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
c001414e:	8d 4c 24 04          	lea    0x4(%esp),%ecx
c0014152:	8b 53 54             	mov    0x54(%ebx),%edx
c0014155:	51                   	push   %ecx
c0014156:	8d 4c 24 04          	lea    0x4(%esp),%ecx
c001415a:	05 54 01 00 00       	add    $0x154,%eax
c001415f:	e8 c8 9e ff ff       	call   c000e02c <_ZN3PteI3HptmLj2ELj10ELb0EE6lookupEmRmS2_>
c0014164:	5a                   	pop    %edx
c0014165:	85 c0                	test   %eax,%eax
c0014167:	74 3e                	je     c00141a7 <_ZN2Ec14sys_assign_gsiEv+0x21d>
c0014169:	8b 3c 24             	mov    (%esp),%edi
        static void init (unsigned = 0, unsigned = 0);

        ALWAYS_INLINE
        static inline unsigned phys_to_rid (Paddr p)
        {
            return p - cfg_base < cfg_size ? static_cast<unsigned>((bus_base << 8) + (p - cfg_base) / PAGE_SIZE) : ~0U;
c001416c:	89 f9                	mov    %edi,%ecx
c001416e:	2b 0d c4 b0 01 c0    	sub    0xc001b0c4,%ecx
c0014174:	3b 0d c0 b0 01 c0    	cmp    0xc001b0c0,%ecx
c001417a:	73 13                	jae    c001418f <_ZN2Ec14sys_assign_gsiEv+0x205>
c001417c:	8b 15 c8 b0 01 c0    	mov    0xc001b0c8,%edx
c0014182:	c1 e9 0c             	shr    $0xc,%ecx
c0014185:	c1 e2 08             	shl    $0x8,%edx
c0014188:	01 d1                	add    %edx,%ecx
c001418a:	83 f9 ff             	cmp    $0xffffffff,%ecx
c001418d:	75 4a                	jne    c00141d9 <_ZN2Ec14sys_assign_gsiEv+0x24f>
        }

        ALWAYS_INLINE
        static inline unsigned phys_to_rid (Paddr p)
        {
            for (Hpet *hpet = list; hpet; hpet = hpet->next)
c001418f:	a1 e8 aa 01 c0       	mov    0xc001aae8,%eax
c0014194:	85 c0                	test   %eax,%eax
c0014196:	74 0f                	je     c00141a7 <_ZN2Ec14sys_assign_gsiEv+0x21d>
                if (hpet->phys == p)
c0014198:	39 78 04             	cmp    %edi,0x4(%eax)
c001419b:	75 06                	jne    c00141a3 <_ZN2Ec14sys_assign_gsiEv+0x219>
                    return hpet->rid;
c001419d:	0f b7 48 0c          	movzwl 0xc(%eax),%ecx
c00141a1:	eb 36                	jmp    c00141d9 <_ZN2Ec14sys_assign_gsiEv+0x24f>
        }

        ALWAYS_INLINE
        static inline unsigned phys_to_rid (Paddr p)
        {
            for (Hpet *hpet = list; hpet; hpet = hpet->next)
c00141a3:	8b 00                	mov    (%eax),%eax
c00141a5:	eb ed                	jmp    c0014194 <_ZN2Ec14sys_assign_gsiEv+0x20a>
        trace (TRACE_ERROR, "%s: Non-DEV CAP (%#lx)", __func__, r->dev());
c00141a7:	8d 44 24 03          	lea    0x3(%esp),%eax
c00141ab:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c00141b0:	ff 73 54             	pushl  0x54(%ebx)
c00141b3:	3d 00 d0 ff cf       	cmp    $0xcfffd000,%eax
c00141b8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00141bd:	0f 44 05 04 f0 ff cf 	cmove  0xcffff004,%eax
c00141c4:	68 f4 9b 01 c0       	push   $0xc0019bf4
c00141c9:	50                   	push   %eax
c00141ca:	68 18 9b 01 c0       	push   $0xc0019b18
c00141cf:	e8 0a d8 fe ff       	call   c00019de <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_DEV>();
c00141d4:	e8 d9 fb ff ff       	call   c0013db2 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE8ELb0EEEvv>
    }

    r->set_msi (Gsi::set (gsi, r->cpu(), rid));
c00141d9:	8b 53 58             	mov    0x58(%ebx),%edx
c00141dc:	89 f0                	mov    %esi,%eax
c00141de:	e8 9d 14 ff ff       	call   c0005680 <_ZN3Gsi3setEjjj>
        inline mword si() const { return ARG_4; }

        ALWAYS_INLINE
        inline void set_msi (uint64 val)
        {
            ARG_2 = static_cast<mword>(val >> 32);
c00141e3:	89 53 54             	mov    %edx,0x54(%ebx)
            ARG_3 = static_cast<mword>(val);
c00141e6:	89 43 58             	mov    %eax,0x58(%ebx)

    sys_finish<Sys_regs::SUCCESS>();
c00141e9:	e8 e4 d2 ff ff       	call   c00114d2 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb0EEEvv>

c00141ee <_ZN7Timeout7enqueueEy>:
#include "x86.hpp"

Timeout *Timeout::list;

void Timeout::enqueue (uint64 t)
{
c00141ee:	57                   	push   %edi
c00141ef:	89 cf                	mov    %ecx,%edi
c00141f1:	56                   	push   %esi
c00141f2:	89 c6                	mov    %eax,%esi
c00141f4:	53                   	push   %ebx
c00141f5:	89 d3                	mov    %edx,%ebx
    time = t;
c00141f7:	89 4e 10             	mov    %ecx,0x10(%esi)

    Timeout *p = nullptr;

    for (Timeout *n = list; n; p = n, n = n->next)
c00141fa:	8b 0d 40 fa ff cf    	mov    0xcffffa40,%ecx

Timeout *Timeout::list;

void Timeout::enqueue (uint64 t)
{
    time = t;
c0014200:	89 56 0c             	mov    %edx,0xc(%esi)

    Timeout *p = nullptr;
c0014203:	31 d2                	xor    %edx,%edx

    for (Timeout *n = list; n; p = n, n = n->next)
c0014205:	89 c8                	mov    %ecx,%eax
c0014207:	85 c0                	test   %eax,%eax
c0014209:	74 0c                	je     c0014217 <_ZN7Timeout7enqueueEy+0x29>
        if (n->time >= time)
c001420b:	39 78 10             	cmp    %edi,0x10(%eax)
c001420e:	72 10                	jb     c0014220 <_ZN7Timeout7enqueueEy+0x32>
c0014210:	77 05                	ja     c0014217 <_ZN7Timeout7enqueueEy+0x29>
c0014212:	39 58 0c             	cmp    %ebx,0xc(%eax)
c0014215:	72 09                	jb     c0014220 <_ZN7Timeout7enqueueEy+0x32>
            break;

    prev = p;

    if (!p) {
c0014217:	85 d2                	test   %edx,%edx

    for (Timeout *n = list; n; p = n, n = n->next)
        if (n->time >= time)
            break;

    prev = p;
c0014219:	89 56 04             	mov    %edx,0x4(%esi)

    if (!p) {
c001421c:	75 63                	jne    c0014281 <_ZN7Timeout7enqueueEy+0x93>
c001421e:	eb 07                	jmp    c0014227 <_ZN7Timeout7enqueueEy+0x39>
{
    time = t;

    Timeout *p = nullptr;

    for (Timeout *n = list; n; p = n, n = n->next)
c0014220:	89 c2                	mov    %eax,%edx
c0014222:	8b 40 08             	mov    0x8(%eax),%eax
c0014225:	eb e0                	jmp    c0014207 <_ZN7Timeout7enqueueEy+0x19>
            break;

    prev = p;

    if (!p) {
        next = list;
c0014227:	89 4e 08             	mov    %ecx,0x8(%esi)
        }

        ALWAYS_INLINE
        static inline void set_timer (uint64 tsc)
        {
            if (freq_bus) {
c001422a:	8b 0d 74 b0 01 c0    	mov    0xc001b074,%ecx
        list = this;
c0014230:	89 35 40 fa ff cf    	mov    %esi,0xcffffa40
c0014236:	85 c9                	test   %ecx,%ecx
c0014238:	74 3a                	je     c0014274 <_ZN7Timeout7enqueueEy+0x86>

ALWAYS_INLINE
static inline uint64 rdtsc()
{
    mword h, l;
    asm volatile ("rdtsc" : "=a" (l), "=d" (h));
c001423a:	0f 31                	rdtsc  
                uint64 now = rdtsc();
                uint32 icr;
                write (LAPIC_TMR_ICR, tsc > now && (icr = static_cast<uint32>(tsc - now) / (freq_tsc / freq_bus)) > 0 ? icr : 1);
c001423c:	39 d7                	cmp    %edx,%edi
c001423e:	72 27                	jb     c0014267 <_ZN7Timeout7enqueueEy+0x79>
c0014240:	77 04                	ja     c0014246 <_ZN7Timeout7enqueueEy+0x58>
c0014242:	39 c3                	cmp    %eax,%ebx
c0014244:	76 21                	jbe    c0014267 <_ZN7Timeout7enqueueEy+0x79>
c0014246:	29 c3                	sub    %eax,%ebx
c0014248:	a1 78 b0 01 c0       	mov    0xc001b078,%eax
c001424d:	31 d2                	xor    %edx,%edx
c001424f:	f7 f1                	div    %ecx
c0014251:	31 d2                	xor    %edx,%edx
c0014253:	89 c1                	mov    %eax,%ecx
c0014255:	89 d8                	mov    %ebx,%eax
c0014257:	f7 f1                	div    %ecx
c0014259:	89 c3                	mov    %eax,%ebx
c001425b:	85 c0                	test   %eax,%eax
c001425d:	b8 01 00 00 00       	mov    $0x1,%eax
c0014262:	0f 44 d8             	cmove  %eax,%ebx
c0014265:	eb 05                	jmp    c001426c <_ZN7Timeout7enqueueEy+0x7e>
c0014267:	bb 01 00 00 00       	mov    $0x1,%ebx
        }

        ALWAYS_INLINE
        static inline void write (Register reg, uint32 val)
        {
            *reinterpret_cast<uint32 volatile *>(CPU_LOCAL_APIC + (reg << 4)) = val;
c001426c:	89 1d 80 e3 ff cf    	mov    %ebx,0xcfffe380
c0014272:	eb 16                	jmp    c001428a <_ZN7Timeout7enqueueEy+0x9c>
c0014274:	b9 e0 06 00 00       	mov    $0x6e0,%ecx
c0014279:	89 d8                	mov    %ebx,%eax
c001427b:	89 fa                	mov    %edi,%edx
c001427d:	0f 30                	wrmsr  
c001427f:	eb 09                	jmp    c001428a <_ZN7Timeout7enqueueEy+0x9c>
        Lapic::set_timer (time);
    } else {
        next = p->next;
c0014281:	8b 42 08             	mov    0x8(%edx),%eax
c0014284:	89 46 08             	mov    %eax,0x8(%esi)
        p->next = this;
c0014287:	89 72 08             	mov    %esi,0x8(%edx)
    }

    if (next)
c001428a:	8b 46 08             	mov    0x8(%esi),%eax
c001428d:	85 c0                	test   %eax,%eax
c001428f:	74 03                	je     c0014294 <_ZN7Timeout7enqueueEy+0xa6>
        next->prev = this;
c0014291:	89 70 04             	mov    %esi,0x4(%eax)
}
c0014294:	5b                   	pop    %ebx
c0014295:	5e                   	pop    %esi
c0014296:	5f                   	pop    %edi
c0014297:	c3                   	ret    

c0014298 <_ZN7Timeout7dequeueEv>:

uint64 Timeout::dequeue()
{
c0014298:	55                   	push   %ebp
c0014299:	89 e5                	mov    %esp,%ebp
c001429b:	57                   	push   %edi
c001429c:	56                   	push   %esi
c001429d:	89 c6                	mov    %eax,%esi
c001429f:	53                   	push   %ebx
c00142a0:	8b 50 04             	mov    0x4(%eax),%edx
c00142a3:	85 d2                	test   %edx,%edx
c00142a5:	75 08                	jne    c00142af <_ZN7Timeout7dequeueEv+0x17>
c00142a7:	39 05 40 fa ff cf    	cmp    %eax,0xcffffa40
c00142ad:	75 77                	jne    c0014326 <_ZN7Timeout7dequeueEv+0x8e>
    if (active()) {

        if (next)
c00142af:	8b 46 08             	mov    0x8(%esi),%eax
c00142b2:	85 c0                	test   %eax,%eax
c00142b4:	74 03                	je     c00142b9 <_ZN7Timeout7dequeueEv+0x21>
            next->prev = prev;
c00142b6:	89 50 04             	mov    %edx,0x4(%eax)

        if (prev)
c00142b9:	8b 56 04             	mov    0x4(%esi),%edx
c00142bc:	8b 46 08             	mov    0x8(%esi),%eax
c00142bf:	85 d2                	test   %edx,%edx
c00142c1:	74 05                	je     c00142c8 <_ZN7Timeout7dequeueEv+0x30>
            prev->next = next;
c00142c3:	89 42 08             	mov    %eax,0x8(%edx)
c00142c6:	eb 5e                	jmp    c0014326 <_ZN7Timeout7dequeueEv+0x8e>

        else if ((list = next))
c00142c8:	85 c0                	test   %eax,%eax
c00142ca:	a3 40 fa ff cf       	mov    %eax,0xcffffa40
c00142cf:	74 55                	je     c0014326 <_ZN7Timeout7dequeueEv+0x8e>
        }

        ALWAYS_INLINE
        static inline void set_timer (uint64 tsc)
        {
            if (freq_bus) {
c00142d1:	8b 0d 74 b0 01 c0    	mov    0xc001b074,%ecx
            Lapic::set_timer (list->time);
c00142d7:	8b 58 0c             	mov    0xc(%eax),%ebx
c00142da:	8b 78 10             	mov    0x10(%eax),%edi
c00142dd:	85 c9                	test   %ecx,%ecx
c00142df:	74 3a                	je     c001431b <_ZN7Timeout7dequeueEv+0x83>
c00142e1:	0f 31                	rdtsc  
                uint64 now = rdtsc();
                uint32 icr;
                write (LAPIC_TMR_ICR, tsc > now && (icr = static_cast<uint32>(tsc - now) / (freq_tsc / freq_bus)) > 0 ? icr : 1);
c00142e3:	39 d7                	cmp    %edx,%edi
c00142e5:	72 27                	jb     c001430e <_ZN7Timeout7dequeueEv+0x76>
c00142e7:	77 04                	ja     c00142ed <_ZN7Timeout7dequeueEv+0x55>
c00142e9:	39 c3                	cmp    %eax,%ebx
c00142eb:	76 21                	jbe    c001430e <_ZN7Timeout7dequeueEv+0x76>
c00142ed:	29 c3                	sub    %eax,%ebx
c00142ef:	a1 78 b0 01 c0       	mov    0xc001b078,%eax
c00142f4:	31 d2                	xor    %edx,%edx
c00142f6:	f7 f1                	div    %ecx
c00142f8:	31 d2                	xor    %edx,%edx
c00142fa:	89 c1                	mov    %eax,%ecx
c00142fc:	89 d8                	mov    %ebx,%eax
c00142fe:	f7 f1                	div    %ecx
c0014300:	89 c3                	mov    %eax,%ebx
c0014302:	85 c0                	test   %eax,%eax
c0014304:	b8 01 00 00 00       	mov    $0x1,%eax
c0014309:	0f 44 d8             	cmove  %eax,%ebx
c001430c:	eb 05                	jmp    c0014313 <_ZN7Timeout7dequeueEv+0x7b>
c001430e:	bb 01 00 00 00       	mov    $0x1,%ebx
        }

        ALWAYS_INLINE
        static inline void write (Register reg, uint32 val)
        {
            *reinterpret_cast<uint32 volatile *>(CPU_LOCAL_APIC + (reg << 4)) = val;
c0014313:	89 1d 80 e3 ff cf    	mov    %ebx,0xcfffe380
c0014319:	eb 0b                	jmp    c0014326 <_ZN7Timeout7dequeueEv+0x8e>
c001431b:	b9 e0 06 00 00       	mov    $0x6e0,%ecx
c0014320:	89 d8                	mov    %ebx,%eax
c0014322:	89 fa                	mov    %edi,%edx
c0014324:	0f 30                	wrmsr  
    }

    prev = next = nullptr;

    return time;
}
c0014326:	5b                   	pop    %ebx
            Lapic::set_timer (list->time);
    }

    prev = next = nullptr;

    return time;
c0014327:	8b 46 0c             	mov    0xc(%esi),%eax
c001432a:	8b 56 10             	mov    0x10(%esi),%edx

        else if ((list = next))
            Lapic::set_timer (list->time);
    }

    prev = next = nullptr;
c001432d:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
c0014334:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)

    return time;
}
c001433b:	5e                   	pop    %esi
c001433c:	5f                   	pop    %edi
c001433d:	5d                   	pop    %ebp
c001433e:	c3                   	ret    
c001433f:	90                   	nop

c0014340 <_ZN7Timeout5checkEv>:

void Timeout::check()
{
c0014340:	56                   	push   %esi
c0014341:	53                   	push   %ebx
    Timeout *prev_list = list;
c0014342:	8b 1d 40 fa ff cf    	mov    0xcffffa40,%ebx

    while (list && list->time <= rdtsc()) {
c0014348:	8b 35 40 fa ff cf    	mov    0xcffffa40,%esi
c001434e:	85 f6                	test   %esi,%esi
c0014350:	74 76                	je     c00143c8 <_ZN7Timeout5checkEv+0x88>
c0014352:	0f 31                	rdtsc  
c0014354:	39 56 10             	cmp    %edx,0x10(%esi)
c0014357:	73 0f                	jae    c0014368 <_ZN7Timeout5checkEv+0x28>
        Timeout *t = list;
        t->dequeue();
c0014359:	89 f0                	mov    %esi,%eax
c001435b:	e8 38 ff ff ff       	call   c0014298 <_ZN7Timeout7dequeueEv>
        t->trigger();
c0014360:	8b 16                	mov    (%esi),%edx
c0014362:	89 f0                	mov    %esi,%eax
c0014364:	ff 12                	call   *(%edx)
c0014366:	eb e0                	jmp    c0014348 <_ZN7Timeout5checkEv+0x8>

void Timeout::check()
{
    Timeout *prev_list = list;

    while (list && list->time <= rdtsc()) {
c0014368:	77 05                	ja     c001436f <_ZN7Timeout5checkEv+0x2f>
c001436a:	39 46 0c             	cmp    %eax,0xc(%esi)
c001436d:	76 ea                	jbe    c0014359 <_ZN7Timeout5checkEv+0x19>
        Timeout *t = list;
        t->dequeue();
        t->trigger();
    }

    if (list && (list == prev_list)) {
c001436f:	39 de                	cmp    %ebx,%esi
c0014371:	75 55                	jne    c00143c8 <_ZN7Timeout5checkEv+0x88>
        }

        ALWAYS_INLINE
        static inline void set_timer (uint64 tsc)
        {
            if (freq_bus) {
c0014373:	8b 0d 74 b0 01 c0    	mov    0xc001b074,%ecx
        /*
         * No timeout was dequeued, which can happen if the TSC stops in CPU
         * sleep states (non-invariant TSC). In that case, we program the
         * LAPIC again for the next timeout.
         */
         Lapic::set_timer(list->time);
c0014379:	8b 5e 0c             	mov    0xc(%esi),%ebx
c001437c:	8b 76 10             	mov    0x10(%esi),%esi
c001437f:	85 c9                	test   %ecx,%ecx
c0014381:	74 3a                	je     c00143bd <_ZN7Timeout5checkEv+0x7d>
c0014383:	0f 31                	rdtsc  
                uint64 now = rdtsc();
                uint32 icr;
                write (LAPIC_TMR_ICR, tsc > now && (icr = static_cast<uint32>(tsc - now) / (freq_tsc / freq_bus)) > 0 ? icr : 1);
c0014385:	39 d6                	cmp    %edx,%esi
c0014387:	72 27                	jb     c00143b0 <_ZN7Timeout5checkEv+0x70>
c0014389:	77 04                	ja     c001438f <_ZN7Timeout5checkEv+0x4f>
c001438b:	39 c3                	cmp    %eax,%ebx
c001438d:	76 21                	jbe    c00143b0 <_ZN7Timeout5checkEv+0x70>
c001438f:	29 c3                	sub    %eax,%ebx
c0014391:	a1 78 b0 01 c0       	mov    0xc001b078,%eax
c0014396:	31 d2                	xor    %edx,%edx
c0014398:	f7 f1                	div    %ecx
c001439a:	31 d2                	xor    %edx,%edx
c001439c:	89 c1                	mov    %eax,%ecx
c001439e:	89 d8                	mov    %ebx,%eax
c00143a0:	f7 f1                	div    %ecx
c00143a2:	89 c3                	mov    %eax,%ebx
c00143a4:	85 c0                	test   %eax,%eax
c00143a6:	b8 01 00 00 00       	mov    $0x1,%eax
c00143ab:	0f 44 d8             	cmove  %eax,%ebx
c00143ae:	eb 05                	jmp    c00143b5 <_ZN7Timeout5checkEv+0x75>
c00143b0:	bb 01 00 00 00       	mov    $0x1,%ebx
        }

        ALWAYS_INLINE
        static inline void write (Register reg, uint32 val)
        {
            *reinterpret_cast<uint32 volatile *>(CPU_LOCAL_APIC + (reg << 4)) = val;
c00143b5:	89 1d 80 e3 ff cf    	mov    %ebx,0xcfffe380
c00143bb:	eb 0b                	jmp    c00143c8 <_ZN7Timeout5checkEv+0x88>
c00143bd:	b9 e0 06 00 00       	mov    $0x6e0,%ecx
c00143c2:	89 d8                	mov    %ebx,%eax
c00143c4:	89 f2                	mov    %esi,%edx
c00143c6:	0f 30                	wrmsr  
    }
}
c00143c8:	5b                   	pop    %ebx
c00143c9:	5e                   	pop    %esi
c00143ca:	c3                   	ret    
c00143cb:	90                   	nop

c00143cc <_ZN14Timeout_budget7triggerEv>:
INIT_PRIORITY (PRIO_LOCAL)
Timeout_budget Timeout_budget::budget;

void Timeout_budget::trigger()
{
    Cpu::hazard |= HZD_SCHED;
c00143cc:	83 0d 00 f0 ff cf 01 	orl    $0x1,0xcffff000
c00143d3:	c3                   	ret    

c00143d4 <_GLOBAL__sub_I.65534__ZN14Timeout_budget6budgetE>:

    public:
        static Timeout *list CPULOCAL;

        ALWAYS_INLINE
        inline Timeout() : prev (nullptr), next (nullptr), time (0) {}
c00143d4:	c7 05 48 fa ff cf 00 	movl   $0x0,0xcffffa48
c00143db:	00 00 00 
c00143de:	c7 05 4c fa ff cf 00 	movl   $0x0,0xcffffa4c
c00143e5:	00 00 00 
c00143e8:	c7 05 50 fa ff cf 00 	movl   $0x0,0xcffffa50
c00143ef:	00 00 00 
c00143f2:	c7 05 54 fa ff cf 00 	movl   $0x0,0xcffffa54
c00143f9:	00 00 00 

#pragma once

#include "timeout.hpp"

class Timeout_budget : public Timeout
c00143fc:	c7 05 44 fa ff cf 48 	movl   $0xc0019e48,0xcffffa44
c0014403:	9e 01 c0 
c0014406:	c3                   	ret    
c0014407:	90                   	nop

c0014408 <_ZN17Timeout_hypercall7triggerEv>:

#include "sm.hpp"
#include "timeout_hypercall.hpp"

void Timeout_hypercall::trigger()
{
c0014408:	57                   	push   %edi
c0014409:	56                   	push   %esi
c001440a:	53                   	push   %ebx
    sm->timeout (ec);
c001440b:	8b 78 18             	mov    0x18(%eax),%edi
c001440e:	8b 70 14             	mov    0x14(%eax),%esi
        }

        ALWAYS_INLINE
        inline void timeout (Ec *ec)
        {
            {   Lock_guard <Spinlock> guard (lock);
c0014411:	8d 47 46             	lea    0x46(%edi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c0014414:	9c                   	pushf  
c0014415:	5b                   	pop    %ebx
            return flags & 0x200;
c0014416:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c0014419:	80 e3 01             	and    $0x1,%bl
c001441c:	74 2a                	je     c0014448 <_ZN17Timeout_hypercall7triggerEv+0x40>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c001441e:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0014425:	75 19                	jne    c0014440 <_ZN17Timeout_hypercall7triggerEv+0x38>
c0014427:	68 a0 9e 01 c0       	push   $0xc0019ea0
c001442c:	68 b7 00 00 00       	push   $0xb7
c0014431:	68 12 61 01 c0       	push   $0xc0016112
c0014436:	68 83 61 01 c0       	push   $0xc0016183
c001443b:	e9 9c 00 00 00       	jmp    c00144dc <_ZN17Timeout_hypercall7triggerEv+0xd4>

            asm volatile ("cli" : : : "memory");
c0014440:	fa                   	cli    
            preemption = false;
c0014441:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c0014448:	e8 df c6 fe ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c001444d:	85 f6                	test   %esi,%esi
c001444f:	0f 84 66 01 00 00    	je     c00145bb <_ZN17Timeout_hypercall7triggerEv+0x1b3>
c0014455:	8b 86 c4 00 00 00    	mov    0xc4(%esi),%eax
c001445b:	85 c0                	test   %eax,%eax
c001445d:	0f 84 58 01 00 00    	je     c00145bb <_ZN17Timeout_hypercall7triggerEv+0x1b3>
c0014463:	8b 96 c0 00 00 00    	mov    0xc0(%esi),%edx
c0014469:	85 d2                	test   %edx,%edx
c001446b:	0f 84 4a 01 00 00    	je     c00145bb <_ZN17Timeout_hypercall7triggerEv+0x1b3>
                return false;

            if (t == t->next)
c0014471:	39 c6                	cmp    %eax,%esi
c0014473:	75 09                	jne    c001447e <_ZN17Timeout_hypercall7triggerEv+0x76>
                headptr = nullptr;
c0014475:	c7 47 4c 00 00 00 00 	movl   $0x0,0x4c(%edi)
c001447c:	eb 26                	jmp    c00144a4 <_ZN17Timeout_hypercall7triggerEv+0x9c>

            else {
                t->next->prev = t->prev;
c001447e:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
                t->prev->next = t->next;
c0014484:	8b 86 c0 00 00 00    	mov    0xc0(%esi),%eax
c001448a:	8b 96 c4 00 00 00    	mov    0xc4(%esi),%edx
c0014490:	89 90 c4 00 00 00    	mov    %edx,0xc4(%eax)
                if (t == headptr)
c0014496:	3b 77 4c             	cmp    0x4c(%edi),%esi
c0014499:	75 09                	jne    c00144a4 <_ZN17Timeout_hypercall7triggerEv+0x9c>
                    headptr = t->next;
c001449b:	8b 86 c4 00 00 00    	mov    0xc4(%esi),%eax
c00144a1:	89 47 4c             	mov    %eax,0x4c(%edi)
            }

            t->next = t->prev = nullptr;
c00144a4:	c7 86 c0 00 00 00 00 	movl   $0x0,0xc0(%esi)
c00144ab:	00 00 00 
c00144ae:	c7 86 c4 00 00 00 00 	movl   $0x0,0xc4(%esi)
c00144b5:	00 00 00 
c00144b8:	fe 47 46             	incb   0x46(%edi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c00144bb:	84 db                	test   %bl,%bl
c00144bd:	74 2f                	je     c00144ee <_ZN17Timeout_hypercall7triggerEv+0xe6>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c00144bf:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c00144c6:	74 1e                	je     c00144e6 <_ZN17Timeout_hypercall7triggerEv+0xde>
c00144c8:	68 60 9e 01 c0       	push   $0xc0019e60
c00144cd:	68 c0 00 00 00       	push   $0xc0
c00144d2:	68 12 61 01 c0       	push   $0xc0016112
c00144d7:	68 82 61 01 c0       	push   $0xc0016182
c00144dc:	68 69 60 01 c0       	push   $0xc0016069
c00144e1:	e8 60 d4 fe ff       	call   c0001946 <_ZN7Console5panicEPKcz>

            preemption = true;
c00144e6:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c00144ed:	fb                   	sti    

        ALWAYS_INLINE
        inline void release (void (*c)())
        {
            if (c)
                cont = c;
c00144ee:	c7 46 50 82 20 01 c0 	movl   $0xc0012082,0x50(%esi)

            Lock_guard <Spinlock> guard (lock);
c00144f5:	8d 46 46             	lea    0x46(%esi),%eax

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
c00144f8:	9c                   	pushf  
c00144f9:	5b                   	pop    %ebx
            return flags & 0x200;
c00144fa:	c1 eb 09             	shr    $0x9,%ebx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
c00144fd:	80 e3 01             	and    $0x1,%bl
c0014500:	74 15                	je     c0014517 <_ZN17Timeout_hypercall7triggerEv+0x10f>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
c0014502:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c0014509:	0f 84 18 ff ff ff    	je     c0014427 <_ZN17Timeout_hypercall7triggerEv+0x1f>

            asm volatile ("cli" : : : "memory");
c001450f:	fa                   	cli    
            preemption = false;
c0014510:	c6 05 00 f7 ff cf 00 	movb   $0x0,0xcffff700
                Cpu::preempt_disable();

            _lock.lock();
c0014517:	e8 10 c6 fe ff       	call   c0000b2c <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
c001451c:	8b 7e 4c             	mov    0x4c(%esi),%edi
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
c001451f:	85 ff                	test   %edi,%edi
c0014521:	0f 84 a5 00 00 00    	je     c00145cc <_ZN17Timeout_hypercall7triggerEv+0x1c4>
c0014527:	8b 47 74             	mov    0x74(%edi),%eax
c001452a:	85 c0                	test   %eax,%eax
c001452c:	0f 84 9a 00 00 00    	je     c00145cc <_ZN17Timeout_hypercall7triggerEv+0x1c4>
c0014532:	8b 57 70             	mov    0x70(%edi),%edx
c0014535:	85 d2                	test   %edx,%edx
c0014537:	0f 84 8f 00 00 00    	je     c00145cc <_ZN17Timeout_hypercall7triggerEv+0x1c4>
                return false;

            if (t == t->next)
c001453d:	39 c7                	cmp    %eax,%edi
c001453f:	75 09                	jne    c001454a <_ZN17Timeout_hypercall7triggerEv+0x142>
                headptr = nullptr;
c0014541:	c7 46 4c 00 00 00 00 	movl   $0x0,0x4c(%esi)
c0014548:	eb 17                	jmp    c0014561 <_ZN17Timeout_hypercall7triggerEv+0x159>

            else {
                t->next->prev = t->prev;
c001454a:	89 50 70             	mov    %edx,0x70(%eax)
                t->prev->next = t->next;
c001454d:	8b 47 70             	mov    0x70(%edi),%eax
c0014550:	8b 57 74             	mov    0x74(%edi),%edx
c0014553:	89 50 74             	mov    %edx,0x74(%eax)
                if (t == headptr)
c0014556:	3b 7e 4c             	cmp    0x4c(%esi),%edi
c0014559:	75 06                	jne    c0014561 <_ZN17Timeout_hypercall7triggerEv+0x159>
                    headptr = t->next;
c001455b:	8b 47 74             	mov    0x74(%edi),%eax
c001455e:	89 46 4c             	mov    %eax,0x4c(%esi)
            }

            t->next = t->prev = nullptr;
c0014561:	c7 47 70 00 00 00 00 	movl   $0x0,0x70(%edi)
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
c0014568:	83 c8 ff             	or     $0xffffffff,%eax
c001456b:	c7 47 74 00 00 00 00 	movl   $0x0,0x74(%edi)
c0014572:	f0 0f c1 47 48       	lock xadd %eax,0x48(%edi)

            for (Sc *s; dequeue (s = head()); ) {
                if (EXPECT_FALSE(s->del_ref()) && (this == s->ec)) {
c0014577:	48                   	dec    %eax
c0014578:	75 46                	jne    c00145c0 <_ZN17Timeout_hypercall7triggerEv+0x1b8>
c001457a:	3b 77 4c             	cmp    0x4c(%edi),%esi
c001457d:	75 41                	jne    c00145c0 <_ZN17Timeout_hypercall7triggerEv+0x1b8>
c001457f:	83 c8 ff             	or     $0xffffffff,%eax
c0014582:	f0 0f c1 46 48       	lock xadd %eax,0x48(%esi)
        inline Refptr (T *p) : ptr (p->add_ref() ? p : nullptr) {}

        ALWAYS_INLINE
        inline ~Refptr()
        {
            if (ptr && ptr->del_ref())
c0014587:	48                   	dec    %eax
c0014588:	75 25                	jne    c00145af <_ZN17Timeout_hypercall7triggerEv+0x1a7>
                delete ptr;
c001458a:	8b 47 4c             	mov    0x4c(%edi),%eax
c001458d:	85 c0                	test   %eax,%eax
c001458f:	74 1e                	je     c00145af <_ZN17Timeout_hypercall7triggerEv+0x1a7>
c0014591:	e8 78 ef fe ff       	call   c000350e <_ZN2EcD1Ev>
c0014596:	8b 57 4c             	mov    0x4c(%edi),%edx

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void operator delete (void *ptr) { cache.free (ptr, static_cast<Ec *>(ptr)->pd->quota); }
c0014599:	8b 82 b8 00 00 00    	mov    0xb8(%edx),%eax
c001459f:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c00145a5:	b8 6c a4 01 c0       	mov    $0xc001a46c,%eax
c00145aa:	e8 b1 bd ff ff       	call   c0010360 <_ZN10Slab_cache4freeEPvR5Quota>

            Lock_guard <Spinlock> guard (lock);

            for (Sc *s; dequeue (s = head()); ) {
                if (EXPECT_FALSE(s->del_ref()) && (this == s->ec)) {
                    delete s;
c00145af:	89 f8                	mov    %edi,%eax
c00145b1:	e8 8f b3 ff ff       	call   c000f945 <_ZN2ScdlEPv>
c00145b6:	e9 61 ff ff ff       	jmp    c001451c <_ZN17Timeout_hypercall7triggerEv+0x114>
c00145bb:	fe 47 46             	incb   0x46(%edi)
c00145be:	eb 0f                	jmp    c00145cf <_ZN17Timeout_hypercall7triggerEv+0x1c7>
                    continue;
                }
                s->remote_enqueue();
c00145c0:	89 f8                	mov    %edi,%eax
c00145c2:	e8 75 b1 ff ff       	call   c000f73c <_ZN2Sc14remote_enqueueEv>
c00145c7:	e9 50 ff ff ff       	jmp    c001451c <_ZN17Timeout_hypercall7triggerEv+0x114>
c00145cc:	fe 46 46             	incb   0x46(%esi)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
c00145cf:	84 db                	test   %bl,%bl
c00145d1:	74 15                	je     c00145e8 <_ZN17Timeout_hypercall7triggerEv+0x1e0>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
c00145d3:	80 3d 00 f7 ff cf 00 	cmpb   $0x0,0xcffff700
c00145da:	0f 85 e8 fe ff ff    	jne    c00144c8 <_ZN17Timeout_hypercall7triggerEv+0xc0>

            preemption = true;
c00145e0:	c6 05 00 f7 ff cf 01 	movb   $0x1,0xcffff700
            asm volatile ("sti" : : : "memory");
c00145e7:	fb                   	sti    
}
c00145e8:	5b                   	pop    %ebx
c00145e9:	5e                   	pop    %esi
c00145ea:	5f                   	pop    %edi
c00145eb:	c3                   	ret    

c00145ec <_ZN3Tss5buildEv>:

        ALWAYS_INLINE
        static inline mword current()
        {
            mword addr;
            asm volatile ("mov %%cr3, %0" : "=r" (addr));
c00145ec:	0f 20 d8             	mov    %cr3,%eax

void Tss::build()
{
#ifdef __i386__
    extern char tss_handler;
    dbf.cr3     = Hpt::current();
c00145ef:	a3 74 fa ff cf       	mov    %eax,0xcffffa74
    dbf.ss      = SEL_KERN_DATA;
    run.ss0     = SEL_KERN_DATA;
#endif

    run.sp0     = CPU_LOCAL_STCK + PAGE_SIZE;
    run.iobm    = static_cast<uint16>(SPC_LOCAL_IOP - reinterpret_cast<mword>(&run));
c00145f4:	b8 c0 fa ff cf       	mov    $0xcffffac0,%eax
c00145f9:	f7 d8                	neg    %eax
void Tss::build()
{
#ifdef __i386__
    extern char tss_handler;
    dbf.cr3     = Hpt::current();
    dbf.eip     = reinterpret_cast<mword>(&tss_handler);
c00145fb:	c7 05 78 fa ff cf de 	movl   $0xc0003ade,0xcffffa78
c0014602:	3a 00 c0 
    dbf.esp     = CPU_LOCAL_STCK + PAGE_SIZE;
c0014605:	c7 05 90 fa ff cf 00 	movl   $0xcfffe000,0xcffffa90
c001460c:	e0 ff cf 
    dbf.eflags  = 2;
c001460f:	c7 05 7c fa ff cf 02 	movl   $0x2,0xcffffa7c
c0014616:	00 00 00 
    dbf.cs      = SEL_KERN_CODE;
c0014619:	66 c7 05 a4 fa ff cf 	movw   $0x8,0xcffffaa4
c0014620:	08 00 
    dbf.ds      = SEL_KERN_DATA;
c0014622:	66 c7 05 ac fa ff cf 	movw   $0x10,0xcffffaac
c0014629:	10 00 
    dbf.es      = SEL_KERN_DATA;
c001462b:	66 c7 05 a0 fa ff cf 	movw   $0x10,0xcffffaa0
c0014632:	10 00 
    dbf.ss      = SEL_KERN_DATA;
c0014634:	66 c7 05 a8 fa ff cf 	movw   $0x10,0xcffffaa8
c001463b:	10 00 
    run.ss0     = SEL_KERN_DATA;
c001463d:	66 c7 05 c8 fa ff cf 	movw   $0x10,0xcffffac8
c0014644:	10 00 
#endif

    run.sp0     = CPU_LOCAL_STCK + PAGE_SIZE;
c0014646:	c7 05 c4 fa ff cf 00 	movl   $0xcfffe000,0xcffffac4
c001464d:	e0 ff cf 
    run.iobm    = static_cast<uint16>(SPC_LOCAL_IOP - reinterpret_cast<mword>(&run));
c0014650:	66 a3 26 fb ff cf    	mov    %ax,0xcffffb26
c0014656:	c3                   	ret    
c0014657:	90                   	nop

c0014658 <_ZN4Utcb8load_excEP8Cpu_regs>:
#include "svm.hpp"
#include "vmx.hpp"
#include "x86.hpp"

bool Utcb::load_exc (Cpu_regs *regs)
{
c0014658:	53                   	push   %ebx
    mword m = regs->mtd;
c0014659:	8b 4a 58             	mov    0x58(%edx),%ecx

    if (m & Mtd::GPR_ACDB) {
c001465c:	f6 c1 01             	test   $0x1,%cl
c001465f:	74 18                	je     c0014679 <_ZN4Utcb8load_excEP8Cpu_regs+0x21>
        rax = regs->REG(ax);
c0014661:	8b 5a 1c             	mov    0x1c(%edx),%ebx
c0014664:	89 58 30             	mov    %ebx,0x30(%eax)
        rcx = regs->REG(cx);
c0014667:	8b 5a 18             	mov    0x18(%edx),%ebx
c001466a:	89 58 34             	mov    %ebx,0x34(%eax)
        rdx = regs->REG(dx);
c001466d:	8b 5a 14             	mov    0x14(%edx),%ebx
c0014670:	89 58 38             	mov    %ebx,0x38(%eax)
        rbx = regs->REG(bx);
c0014673:	8b 5a 10             	mov    0x10(%edx),%ebx
c0014676:	89 58 3c             	mov    %ebx,0x3c(%eax)
    }

    if (m & Mtd::GPR_BSD) {
c0014679:	f6 c1 02             	test   $0x2,%cl
c001467c:	74 11                	je     c001468f <_ZN4Utcb8load_excEP8Cpu_regs+0x37>
        rbp = regs->REG(bp);
c001467e:	8b 5a 08             	mov    0x8(%edx),%ebx
c0014681:	89 58 44             	mov    %ebx,0x44(%eax)
        rsi = regs->REG(si);
c0014684:	8b 5a 04             	mov    0x4(%edx),%ebx
c0014687:	89 58 48             	mov    %ebx,0x48(%eax)
        rdi = regs->REG(di);
c001468a:	8b 1a                	mov    (%edx),%ebx
c001468c:	89 58 4c             	mov    %ebx,0x4c(%eax)
        r14 = regs->r14;
        r15 = regs->r15;
    }
#endif

    if (m & Mtd::RSP)
c001468f:	f6 c1 04             	test   $0x4,%cl
c0014692:	74 06                	je     c001469a <_ZN4Utcb8load_excEP8Cpu_regs+0x42>
        rsp = regs->REG(sp);
c0014694:	8b 5a 44             	mov    0x44(%edx),%ebx
c0014697:	89 58 40             	mov    %ebx,0x40(%eax)

    if (m & Mtd::RIP_LEN)
c001469a:	f6 c1 08             	test   $0x8,%cl
c001469d:	74 06                	je     c00146a5 <_ZN4Utcb8load_excEP8Cpu_regs+0x4d>
        rip = regs->REG(ip);
c001469f:	8b 5a 38             	mov    0x38(%edx),%ebx
c00146a2:	89 58 18             	mov    %ebx,0x18(%eax)

    if (m & Mtd::RFLAGS)
c00146a5:	f6 c1 10             	test   $0x10,%cl
c00146a8:	74 06                	je     c00146b0 <_ZN4Utcb8load_excEP8Cpu_regs+0x58>
        rflags = regs->REG(fl);
c00146aa:	8b 5a 40             	mov    0x40(%edx),%ebx
c00146ad:	89 58 1c             	mov    %ebx,0x1c(%eax)

    if (m & Mtd::QUAL) {
c00146b0:	f6 c5 80             	test   $0x80,%ch
c00146b3:	74 1a                	je     c00146cf <_ZN4Utcb8load_excEP8Cpu_regs+0x77>
        qual[0] = regs->err;
c00146b5:	8b 5a 30             	mov    0x30(%edx),%ebx
c00146b8:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
c00146bf:	89 58 50             	mov    %ebx,0x50(%eax)
        qual[1] = regs->cr2;
c00146c2:	8b 52 0c             	mov    0xc(%edx),%edx
c00146c5:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
c00146cc:	89 50 58             	mov    %edx,0x58(%eax)
    }

    barrier();
    mtd = m;
c00146cf:	89 48 10             	mov    %ecx,0x10(%eax)
    items = sizeof (Utcb_data) / sizeof (mword);
c00146d2:	c7 00 50 00 00 00    	movl   $0x50,(%eax)

    return m & Mtd::FPU;
c00146d8:	89 c8                	mov    %ecx,%eax
c00146da:	c1 e8 1f             	shr    $0x1f,%eax
}
c00146dd:	5b                   	pop    %ebx
c00146de:	c3                   	ret    
c00146df:	90                   	nop

c00146e0 <_ZN4Utcb8save_excEP8Cpu_regs>:

bool Utcb::save_exc (Cpu_regs *regs)
{
    if (mtd & Mtd::GPR_ACDB) {
c00146e0:	f6 40 10 01          	testb  $0x1,0x10(%eax)
c00146e4:	74 18                	je     c00146fe <_ZN4Utcb8save_excEP8Cpu_regs+0x1e>
        regs->REG(ax) = rax;
c00146e6:	8b 48 30             	mov    0x30(%eax),%ecx
c00146e9:	89 4a 1c             	mov    %ecx,0x1c(%edx)
        regs->REG(cx) = rcx;
c00146ec:	8b 48 34             	mov    0x34(%eax),%ecx
c00146ef:	89 4a 18             	mov    %ecx,0x18(%edx)
        regs->REG(dx) = rdx;
c00146f2:	8b 48 38             	mov    0x38(%eax),%ecx
c00146f5:	89 4a 14             	mov    %ecx,0x14(%edx)
        regs->REG(bx) = rbx;
c00146f8:	8b 48 3c             	mov    0x3c(%eax),%ecx
c00146fb:	89 4a 10             	mov    %ecx,0x10(%edx)
    }

    if (mtd & Mtd::GPR_BSD) {
c00146fe:	f6 40 10 02          	testb  $0x2,0x10(%eax)
c0014702:	74 11                	je     c0014715 <_ZN4Utcb8save_excEP8Cpu_regs+0x35>
        regs->REG(bp) = rbp;
c0014704:	8b 48 44             	mov    0x44(%eax),%ecx
c0014707:	89 4a 08             	mov    %ecx,0x8(%edx)
        regs->REG(si) = rsi;
c001470a:	8b 48 48             	mov    0x48(%eax),%ecx
c001470d:	89 4a 04             	mov    %ecx,0x4(%edx)
        regs->REG(di) = rdi;
c0014710:	8b 48 4c             	mov    0x4c(%eax),%ecx
c0014713:	89 0a                	mov    %ecx,(%edx)
        regs->r14     = r14;
        regs->r15     = r15;
    }
#endif

    if (mtd & Mtd::RSP)
c0014715:	f6 40 10 04          	testb  $0x4,0x10(%eax)
c0014719:	74 06                	je     c0014721 <_ZN4Utcb8save_excEP8Cpu_regs+0x41>
        regs->REG(sp) = rsp;
c001471b:	8b 48 40             	mov    0x40(%eax),%ecx
c001471e:	89 4a 44             	mov    %ecx,0x44(%edx)

    if (mtd & Mtd::RIP_LEN)
c0014721:	f6 40 10 08          	testb  $0x8,0x10(%eax)
c0014725:	74 06                	je     c001472d <_ZN4Utcb8save_excEP8Cpu_regs+0x4d>
        regs->REG(ip) = rip;
c0014727:	8b 48 18             	mov    0x18(%eax),%ecx
c001472a:	89 4a 38             	mov    %ecx,0x38(%edx)

    if (mtd & Mtd::RFLAGS)
c001472d:	f6 40 10 10          	testb  $0x10,0x10(%eax)
c0014731:	74 0f                	je     c0014742 <_ZN4Utcb8save_excEP8Cpu_regs+0x62>
        regs->REG(fl) = (rflags & ~(Cpu::EFL_VIP | Cpu::EFL_VIF | Cpu::EFL_VM | Cpu::EFL_RF | Cpu::EFL_IOPL)) | Cpu::EFL_IF;
c0014733:	8b 48 1c             	mov    0x1c(%eax),%ecx
c0014736:	81 e1 ff cd e4 ff    	and    $0xffe4cdff,%ecx
c001473c:	80 cd 02             	or     $0x2,%ch
c001473f:	89 4a 40             	mov    %ecx,0x40(%edx)

    return mtd & Mtd::FPU;
c0014742:	8b 40 10             	mov    0x10(%eax),%eax
c0014745:	c1 e8 1f             	shr    $0x1f,%eax
}
c0014748:	c3                   	ret    
c0014749:	90                   	nop

c001474a <_ZN4Utcb8load_vmxEP8Cpu_regs>:

bool Utcb::load_vmx (Cpu_regs *regs)
{
c001474a:	55                   	push   %ebp
c001474b:	57                   	push   %edi
c001474c:	89 d7                	mov    %edx,%edi
c001474e:	56                   	push   %esi
c001474f:	53                   	push   %ebx
c0014750:	89 c3                	mov    %eax,%ebx
c0014752:	83 ec 08             	sub    $0x8,%esp
    mword m = regs->mtd;
c0014755:	8b 72 58             	mov    0x58(%edx),%esi

    if (m & Mtd::GPR_ACDB) {
c0014758:	f7 c6 01 00 00 00    	test   $0x1,%esi
c001475e:	74 18                	je     c0014778 <_ZN4Utcb8load_vmxEP8Cpu_regs+0x2e>
        rax = regs->REG(ax);
c0014760:	8b 42 1c             	mov    0x1c(%edx),%eax
c0014763:	89 43 30             	mov    %eax,0x30(%ebx)
        rcx = regs->REG(cx);
c0014766:	8b 42 18             	mov    0x18(%edx),%eax
c0014769:	89 43 34             	mov    %eax,0x34(%ebx)
        rdx = regs->REG(dx);
c001476c:	8b 42 14             	mov    0x14(%edx),%eax
c001476f:	89 43 38             	mov    %eax,0x38(%ebx)
        rbx = regs->REG(bx);
c0014772:	8b 42 10             	mov    0x10(%edx),%eax
c0014775:	89 43 3c             	mov    %eax,0x3c(%ebx)
    }

    if (m & Mtd::GPR_BSD) {
c0014778:	f7 c6 02 00 00 00    	test   $0x2,%esi
c001477e:	74 11                	je     c0014791 <_ZN4Utcb8load_vmxEP8Cpu_regs+0x47>
        rbp = regs->REG(bp);
c0014780:	8b 47 08             	mov    0x8(%edi),%eax
c0014783:	89 43 44             	mov    %eax,0x44(%ebx)
        rsi = regs->REG(si);
c0014786:	8b 47 04             	mov    0x4(%edi),%eax
c0014789:	89 43 48             	mov    %eax,0x48(%ebx)
        rdi = regs->REG(di);
c001478c:	8b 07                	mov    (%edi),%eax
c001478e:	89 43 4c             	mov    %eax,0x4c(%ebx)
        r14 = regs->r14;
        r15 = regs->r15;
    }
#endif

    regs->vmcs->make_current();
c0014791:	8b 47 20             	mov    0x20(%edi),%eax
        }

        ALWAYS_INLINE
        inline void make_current()
        {
            if (EXPECT_TRUE (current == this))
c0014794:	39 05 14 f0 ff cf    	cmp    %eax,0xcffff014
c001479a:	74 3e                	je     c00147da <_ZN4Utcb8load_vmxEP8Cpu_regs+0x90>
                return;

            uint64 phys = Buddy::ptr_to_phys (current = this);
c001479c:	a3 14 f0 ff cf       	mov    %eax,0xcffff014
c00147a1:	2d 00 00 c0 bf       	sub    $0xbfc00000,%eax
c00147a6:	89 04 24             	mov    %eax,(%esp)
c00147a9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c00147b0:	00 

            bool ret;
            asm volatile ("vmptrld %1; seta %0" : "=q" (ret) : "m" (phys) : "cc");
c00147b1:	0f c7 34 24          	vmptrld (%esp)
c00147b5:	0f 97 c0             	seta   %al
            assert (ret);
c00147b8:	84 c0                	test   %al,%al
c00147ba:	75 1e                	jne    c00147da <_ZN4Utcb8load_vmxEP8Cpu_regs+0x90>
c00147bc:	68 d4 9e 01 c0       	push   $0xc0019ed4
c00147c1:	68 96 01 00 00       	push   $0x196
c00147c6:	68 13 69 01 c0       	push   $0xc0016913
c00147cb:	68 83 69 01 c0       	push   $0xc0016983
c00147d0:	68 69 60 01 c0       	push   $0xc0016069
c00147d5:	e8 6c d1 fe ff       	call   c0001946 <_ZN7Console5panicEPKcz>

    if (m & Mtd::RSP)
c00147da:	f7 c6 04 00 00 00    	test   $0x4,%esi
c00147e0:	74 09                	je     c00147eb <_ZN4Utcb8load_vmxEP8Cpu_regs+0xa1>
        rsp = Vmcs::read (Vmcs::GUEST_RSP);
c00147e2:	b8 1c 68 00 00       	mov    $0x681c,%eax
c00147e7:	0f 78 43 40          	vmread %eax,0x40(%ebx)

    if (m & Mtd::RIP_LEN) {
c00147eb:	f7 c6 08 00 00 00    	test   $0x8,%esi
c00147f1:	74 11                	je     c0014804 <_ZN4Utcb8load_vmxEP8Cpu_regs+0xba>
        rip      = Vmcs::read (Vmcs::GUEST_RIP);
c00147f3:	b8 1e 68 00 00       	mov    $0x681e,%eax
c00147f8:	0f 78 43 18          	vmread %eax,0x18(%ebx)
        inst_len = Vmcs::read (Vmcs::EXI_INST_LEN);
c00147fc:	66 b8 0c 44          	mov    $0x440c,%ax
c0014800:	0f 78 43 14          	vmread %eax,0x14(%ebx)
    }

    if (m & Mtd::RFLAGS)
c0014804:	f7 c6 10 00 00 00    	test   $0x10,%esi
c001480a:	74 09                	je     c0014815 <_ZN4Utcb8load_vmxEP8Cpu_regs+0xcb>
        rflags = Vmcs::read (Vmcs::GUEST_RFLAGS);
c001480c:	b8 20 68 00 00       	mov    $0x6820,%eax
c0014811:	0f 78 43 1c          	vmread %eax,0x1c(%ebx)

    if (m & Mtd::DS_ES) {
c0014815:	f7 c6 20 00 00 00    	test   $0x20,%esi
c001481b:	0f 84 a8 00 00 00    	je     c00148c9 <_ZN4Utcb8load_vmxEP8Cpu_regs+0x17f>

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
c0014821:	b8 1a 48 00 00       	mov    $0x481a,%eax
c0014826:	0f 78 c0             	vmread %eax,%eax
c0014829:	b9 06 48 00 00       	mov    $0x4806,%ecx
c001482e:	0f 78 c9             	vmread %ecx,%ecx
c0014831:	ba 0c 68 00 00       	mov    $0x680c,%edx
c0014836:	0f 78 d2             	vmread %edx,%edx
c0014839:	bd 06 08 00 00       	mov    $0x806,%ebp
c001483e:	0f 78 ed             	vmread %ebp,%ebp
        uint64  base;

        ALWAYS_INLINE
        inline void set_vmx (mword s, mword b, mword l, mword a)
        {
            sel   = static_cast<uint16>(s);
c0014841:	66 89 ab d0 00 00 00 	mov    %bp,0xd0(%ebx)
            ar    = static_cast<uint16>((a >> 4 & 0x1f00) | (a & 0xff));
c0014848:	89 c5                	mov    %eax,%ebp
c001484a:	0f b6 c0             	movzbl %al,%eax
c001484d:	c1 ed 04             	shr    $0x4,%ebp
c0014850:	81 e5 00 1f 00 00    	and    $0x1f00,%ebp
c0014856:	09 e8                	or     %ebp,%eax
c0014858:	66 89 83 d2 00 00 00 	mov    %ax,0xd2(%ebx)
c001485f:	b8 14 48 00 00       	mov    $0x4814,%eax
            limit = static_cast<uint32>(l);
c0014864:	89 8b d4 00 00 00    	mov    %ecx,0xd4(%ebx)
            base  = b;
c001486a:	89 93 d8 00 00 00    	mov    %edx,0xd8(%ebx)
c0014870:	c7 83 dc 00 00 00 00 	movl   $0x0,0xdc(%ebx)
c0014877:	00 00 00 
c001487a:	0f 78 c0             	vmread %eax,%eax
c001487d:	b9 00 48 00 00       	mov    $0x4800,%ecx
c0014882:	0f 78 c9             	vmread %ecx,%ecx
c0014885:	ba 06 68 00 00       	mov    $0x6806,%edx
c001488a:	0f 78 d2             	vmread %edx,%edx
c001488d:	bd 00 08 00 00       	mov    $0x800,%ebp
c0014892:	0f 78 ed             	vmread %ebp,%ebp
        uint64  base;

        ALWAYS_INLINE
        inline void set_vmx (mword s, mword b, mword l, mword a)
        {
            sel   = static_cast<uint16>(s);
c0014895:	66 89 ab a0 00 00 00 	mov    %bp,0xa0(%ebx)
            ar    = static_cast<uint16>((a >> 4 & 0x1f00) | (a & 0xff));
c001489c:	89 c5                	mov    %eax,%ebp
c001489e:	0f b6 c0             	movzbl %al,%eax
c00148a1:	c1 ed 04             	shr    $0x4,%ebp
c00148a4:	81 e5 00 1f 00 00    	and    $0x1f00,%ebp
c00148aa:	09 e8                	or     %ebp,%eax
c00148ac:	66 89 83 a2 00 00 00 	mov    %ax,0xa2(%ebx)
            limit = static_cast<uint32>(l);
c00148b3:	89 8b a4 00 00 00    	mov    %ecx,0xa4(%ebx)
            base  = b;
c00148b9:	89 93 a8 00 00 00    	mov    %edx,0xa8(%ebx)
c00148bf:	c7 83 ac 00 00 00 00 	movl   $0x0,0xac(%ebx)
c00148c6:	00 00 00 
        ds.set_vmx (Vmcs::read (Vmcs::GUEST_SEL_DS), Vmcs::read (Vmcs::GUEST_BASE_DS), Vmcs::read (Vmcs::GUEST_LIMIT_DS), Vmcs::read (Vmcs::GUEST_AR_DS));
        es.set_vmx (Vmcs::read (Vmcs::GUEST_SEL_ES), Vmcs::read (Vmcs::GUEST_BASE_ES), Vmcs::read (Vmcs::GUEST_LIMIT_ES), Vmcs::read (Vmcs::GUEST_AR_ES));
    }

    if (m & Mtd::FS_GS) {
c00148c9:	f7 c6 40 00 00 00    	test   $0x40,%esi
c00148cf:	0f 84 a8 00 00 00    	je     c001497d <_ZN4Utcb8load_vmxEP8Cpu_regs+0x233>
c00148d5:	b8 1c 48 00 00       	mov    $0x481c,%eax
c00148da:	0f 78 c0             	vmread %eax,%eax
c00148dd:	b9 08 48 00 00       	mov    $0x4808,%ecx
c00148e2:	0f 78 c9             	vmread %ecx,%ecx
c00148e5:	ba 0e 68 00 00       	mov    $0x680e,%edx
c00148ea:	0f 78 d2             	vmread %edx,%edx
c00148ed:	bd 08 08 00 00       	mov    $0x808,%ebp
c00148f2:	0f 78 ed             	vmread %ebp,%ebp
        uint64  base;

        ALWAYS_INLINE
        inline void set_vmx (mword s, mword b, mword l, mword a)
        {
            sel   = static_cast<uint16>(s);
c00148f5:	66 89 ab e0 00 00 00 	mov    %bp,0xe0(%ebx)
            ar    = static_cast<uint16>((a >> 4 & 0x1f00) | (a & 0xff));
c00148fc:	89 c5                	mov    %eax,%ebp
c00148fe:	0f b6 c0             	movzbl %al,%eax
c0014901:	c1 ed 04             	shr    $0x4,%ebp
c0014904:	81 e5 00 1f 00 00    	and    $0x1f00,%ebp
c001490a:	09 e8                	or     %ebp,%eax
c001490c:	66 89 83 e2 00 00 00 	mov    %ax,0xe2(%ebx)
c0014913:	b8 1e 48 00 00       	mov    $0x481e,%eax
            limit = static_cast<uint32>(l);
c0014918:	89 8b e4 00 00 00    	mov    %ecx,0xe4(%ebx)
            base  = b;
c001491e:	89 93 e8 00 00 00    	mov    %edx,0xe8(%ebx)
c0014924:	c7 83 ec 00 00 00 00 	movl   $0x0,0xec(%ebx)
c001492b:	00 00 00 
c001492e:	0f 78 c0             	vmread %eax,%eax
c0014931:	b9 0a 48 00 00       	mov    $0x480a,%ecx
c0014936:	0f 78 c9             	vmread %ecx,%ecx
c0014939:	ba 10 68 00 00       	mov    $0x6810,%edx
c001493e:	0f 78 d2             	vmread %edx,%edx
c0014941:	bd 0a 08 00 00       	mov    $0x80a,%ebp
c0014946:	0f 78 ed             	vmread %ebp,%ebp
        uint64  base;

        ALWAYS_INLINE
        inline void set_vmx (mword s, mword b, mword l, mword a)
        {
            sel   = static_cast<uint16>(s);
c0014949:	66 89 ab f0 00 00 00 	mov    %bp,0xf0(%ebx)
            ar    = static_cast<uint16>((a >> 4 & 0x1f00) | (a & 0xff));
c0014950:	89 c5                	mov    %eax,%ebp
c0014952:	0f b6 c0             	movzbl %al,%eax
c0014955:	c1 ed 04             	shr    $0x4,%ebp
c0014958:	81 e5 00 1f 00 00    	and    $0x1f00,%ebp
c001495e:	09 e8                	or     %ebp,%eax
c0014960:	66 89 83 f2 00 00 00 	mov    %ax,0xf2(%ebx)
            limit = static_cast<uint32>(l);
c0014967:	89 8b f4 00 00 00    	mov    %ecx,0xf4(%ebx)
            base  = b;
c001496d:	89 93 f8 00 00 00    	mov    %edx,0xf8(%ebx)
c0014973:	c7 83 fc 00 00 00 00 	movl   $0x0,0xfc(%ebx)
c001497a:	00 00 00 
        fs.set_vmx (Vmcs::read (Vmcs::GUEST_SEL_FS), Vmcs::read (Vmcs::GUEST_BASE_FS), Vmcs::read (Vmcs::GUEST_LIMIT_FS), Vmcs::read (Vmcs::GUEST_AR_FS));
        gs.set_vmx (Vmcs::read (Vmcs::GUEST_SEL_GS), Vmcs::read (Vmcs::GUEST_BASE_GS), Vmcs::read (Vmcs::GUEST_LIMIT_GS), Vmcs::read (Vmcs::GUEST_AR_GS));
    }

    if (m & Mtd::CS_SS) {
c001497d:	f7 c6 80 00 00 00    	test   $0x80,%esi
c0014983:	0f 84 a8 00 00 00    	je     c0014a31 <_ZN4Utcb8load_vmxEP8Cpu_regs+0x2e7>
c0014989:	b8 16 48 00 00       	mov    $0x4816,%eax
c001498e:	0f 78 c0             	vmread %eax,%eax
c0014991:	b9 02 48 00 00       	mov    $0x4802,%ecx
c0014996:	0f 78 c9             	vmread %ecx,%ecx
c0014999:	ba 08 68 00 00       	mov    $0x6808,%edx
c001499e:	0f 78 d2             	vmread %edx,%edx
c00149a1:	bd 02 08 00 00       	mov    $0x802,%ebp
c00149a6:	0f 78 ed             	vmread %ebp,%ebp
        uint64  base;

        ALWAYS_INLINE
        inline void set_vmx (mword s, mword b, mword l, mword a)
        {
            sel   = static_cast<uint16>(s);
c00149a9:	66 89 ab b0 00 00 00 	mov    %bp,0xb0(%ebx)
            ar    = static_cast<uint16>((a >> 4 & 0x1f00) | (a & 0xff));
c00149b0:	89 c5                	mov    %eax,%ebp
c00149b2:	0f b6 c0             	movzbl %al,%eax
c00149b5:	c1 ed 04             	shr    $0x4,%ebp
c00149b8:	81 e5 00 1f 00 00    	and    $0x1f00,%ebp
c00149be:	09 e8                	or     %ebp,%eax
c00149c0:	66 89 83 b2 00 00 00 	mov    %ax,0xb2(%ebx)
c00149c7:	b8 18 48 00 00       	mov    $0x4818,%eax
            limit = static_cast<uint32>(l);
c00149cc:	89 8b b4 00 00 00    	mov    %ecx,0xb4(%ebx)
            base  = b;
c00149d2:	89 93 b8 00 00 00    	mov    %edx,0xb8(%ebx)
c00149d8:	c7 83 bc 00 00 00 00 	movl   $0x0,0xbc(%ebx)
c00149df:	00 00 00 
c00149e2:	0f 78 c0             	vmread %eax,%eax
c00149e5:	b9 04 48 00 00       	mov    $0x4804,%ecx
c00149ea:	0f 78 c9             	vmread %ecx,%ecx
c00149ed:	ba 0a 68 00 00       	mov    $0x680a,%edx
c00149f2:	0f 78 d2             	vmread %edx,%edx
c00149f5:	bd 04 08 00 00       	mov    $0x804,%ebp
c00149fa:	0f 78 ed             	vmread %ebp,%ebp
        uint64  base;

        ALWAYS_INLINE
        inline void set_vmx (mword s, mword b, mword l, mword a)
        {
            sel   = static_cast<uint16>(s);
c00149fd:	66 89 ab c0 00 00 00 	mov    %bp,0xc0(%ebx)
            ar    = static_cast<uint16>((a >> 4 & 0x1f00) | (a & 0xff));
c0014a04:	89 c5                	mov    %eax,%ebp
c0014a06:	0f b6 c0             	movzbl %al,%eax
c0014a09:	c1 ed 04             	shr    $0x4,%ebp
c0014a0c:	81 e5 00 1f 00 00    	and    $0x1f00,%ebp
c0014a12:	09 e8                	or     %ebp,%eax
c0014a14:	66 89 83 c2 00 00 00 	mov    %ax,0xc2(%ebx)
            limit = static_cast<uint32>(l);
c0014a1b:	89 8b c4 00 00 00    	mov    %ecx,0xc4(%ebx)
            base  = b;
c0014a21:	89 93 c8 00 00 00    	mov    %edx,0xc8(%ebx)
c0014a27:	c7 83 cc 00 00 00 00 	movl   $0x0,0xcc(%ebx)
c0014a2e:	00 00 00 
        cs.set_vmx (Vmcs::read (Vmcs::GUEST_SEL_CS), Vmcs::read (Vmcs::GUEST_BASE_CS), Vmcs::read (Vmcs::GUEST_LIMIT_CS), Vmcs::read (Vmcs::GUEST_AR_CS));
        ss.set_vmx (Vmcs::read (Vmcs::GUEST_SEL_SS), Vmcs::read (Vmcs::GUEST_BASE_SS), Vmcs::read (Vmcs::GUEST_LIMIT_SS), Vmcs::read (Vmcs::GUEST_AR_SS));
    }

    if (m & Mtd::TR)
c0014a31:	f7 c6 00 01 00 00    	test   $0x100,%esi
c0014a37:	74 54                	je     c0014a8d <_ZN4Utcb8load_vmxEP8Cpu_regs+0x343>
c0014a39:	b8 22 48 00 00       	mov    $0x4822,%eax
c0014a3e:	0f 78 c0             	vmread %eax,%eax
c0014a41:	b9 0e 48 00 00       	mov    $0x480e,%ecx
c0014a46:	0f 78 c9             	vmread %ecx,%ecx
c0014a49:	ba 14 68 00 00       	mov    $0x6814,%edx
c0014a4e:	0f 78 d2             	vmread %edx,%edx
c0014a51:	bd 0e 08 00 00       	mov    $0x80e,%ebp
c0014a56:	0f 78 ed             	vmread %ebp,%ebp
        uint64  base;

        ALWAYS_INLINE
        inline void set_vmx (mword s, mword b, mword l, mword a)
        {
            sel   = static_cast<uint16>(s);
c0014a59:	66 89 ab 10 01 00 00 	mov    %bp,0x110(%ebx)
            ar    = static_cast<uint16>((a >> 4 & 0x1f00) | (a & 0xff));
c0014a60:	89 c5                	mov    %eax,%ebp
c0014a62:	0f b6 c0             	movzbl %al,%eax
c0014a65:	c1 ed 04             	shr    $0x4,%ebp
c0014a68:	81 e5 00 1f 00 00    	and    $0x1f00,%ebp
c0014a6e:	09 e8                	or     %ebp,%eax
c0014a70:	66 89 83 12 01 00 00 	mov    %ax,0x112(%ebx)
            limit = static_cast<uint32>(l);
c0014a77:	89 8b 14 01 00 00    	mov    %ecx,0x114(%ebx)
            base  = b;
c0014a7d:	89 93 18 01 00 00    	mov    %edx,0x118(%ebx)
c0014a83:	c7 83 1c 01 00 00 00 	movl   $0x0,0x11c(%ebx)
c0014a8a:	00 00 00 
        tr.set_vmx (Vmcs::read (Vmcs::GUEST_SEL_TR), Vmcs::read (Vmcs::GUEST_BASE_TR), Vmcs::read (Vmcs::GUEST_LIMIT_TR), Vmcs::read (Vmcs::GUEST_AR_TR));

    if (m & Mtd::LDTR)
c0014a8d:	f7 c6 00 02 00 00    	test   $0x200,%esi
c0014a93:	74 54                	je     c0014ae9 <_ZN4Utcb8load_vmxEP8Cpu_regs+0x39f>
c0014a95:	b8 20 48 00 00       	mov    $0x4820,%eax
c0014a9a:	0f 78 c0             	vmread %eax,%eax
c0014a9d:	b9 0c 48 00 00       	mov    $0x480c,%ecx
c0014aa2:	0f 78 c9             	vmread %ecx,%ecx
c0014aa5:	ba 12 68 00 00       	mov    $0x6812,%edx
c0014aaa:	0f 78 d2             	vmread %edx,%edx
c0014aad:	bd 0c 08 00 00       	mov    $0x80c,%ebp
c0014ab2:	0f 78 ed             	vmread %ebp,%ebp
        uint64  base;

        ALWAYS_INLINE
        inline void set_vmx (mword s, mword b, mword l, mword a)
        {
            sel   = static_cast<uint16>(s);
c0014ab5:	66 89 ab 00 01 00 00 	mov    %bp,0x100(%ebx)
            ar    = static_cast<uint16>((a >> 4 & 0x1f00) | (a & 0xff));
c0014abc:	89 c5                	mov    %eax,%ebp
c0014abe:	0f b6 c0             	movzbl %al,%eax
c0014ac1:	c1 ed 04             	shr    $0x4,%ebp
c0014ac4:	81 e5 00 1f 00 00    	and    $0x1f00,%ebp
c0014aca:	09 e8                	or     %ebp,%eax
c0014acc:	66 89 83 02 01 00 00 	mov    %ax,0x102(%ebx)
            limit = static_cast<uint32>(l);
c0014ad3:	89 8b 04 01 00 00    	mov    %ecx,0x104(%ebx)
            base  = b;
c0014ad9:	89 93 08 01 00 00    	mov    %edx,0x108(%ebx)
c0014adf:	c7 83 0c 01 00 00 00 	movl   $0x0,0x10c(%ebx)
c0014ae6:	00 00 00 
        ld.set_vmx (Vmcs::read (Vmcs::GUEST_SEL_LDTR), Vmcs::read (Vmcs::GUEST_BASE_LDTR), Vmcs::read (Vmcs::GUEST_LIMIT_LDTR), Vmcs::read (Vmcs::GUEST_AR_LDTR));

    if (m & Mtd::GDTR)
c0014ae9:	f7 c6 00 04 00 00    	test   $0x400,%esi
c0014aef:	74 38                	je     c0014b29 <_ZN4Utcb8load_vmxEP8Cpu_regs+0x3df>
c0014af1:	ba 10 48 00 00       	mov    $0x4810,%edx
c0014af6:	0f 78 d2             	vmread %edx,%edx
c0014af9:	b8 16 68 00 00       	mov    $0x6816,%eax
c0014afe:	0f 78 c0             	vmread %eax,%eax
        uint64  base;

        ALWAYS_INLINE
        inline void set_vmx (mword s, mword b, mword l, mword a)
        {
            sel   = static_cast<uint16>(s);
c0014b01:	66 c7 83 20 01 00 00 	movw   $0x0,0x120(%ebx)
c0014b08:	00 00 
            ar    = static_cast<uint16>((a >> 4 & 0x1f00) | (a & 0xff));
c0014b0a:	66 c7 83 22 01 00 00 	movw   $0x0,0x122(%ebx)
c0014b11:	00 00 
            limit = static_cast<uint32>(l);
c0014b13:	89 93 24 01 00 00    	mov    %edx,0x124(%ebx)
            base  = b;
c0014b19:	89 83 28 01 00 00    	mov    %eax,0x128(%ebx)
c0014b1f:	c7 83 2c 01 00 00 00 	movl   $0x0,0x12c(%ebx)
c0014b26:	00 00 00 
        gd.set_vmx (0, Vmcs::read (Vmcs::GUEST_BASE_GDTR), Vmcs::read (Vmcs::GUEST_LIMIT_GDTR), 0);

    if (m & Mtd::IDTR)
c0014b29:	f7 c6 00 08 00 00    	test   $0x800,%esi
c0014b2f:	74 38                	je     c0014b69 <_ZN4Utcb8load_vmxEP8Cpu_regs+0x41f>
c0014b31:	ba 12 48 00 00       	mov    $0x4812,%edx
c0014b36:	0f 78 d2             	vmread %edx,%edx
c0014b39:	b8 18 68 00 00       	mov    $0x6818,%eax
c0014b3e:	0f 78 c0             	vmread %eax,%eax
        uint64  base;

        ALWAYS_INLINE
        inline void set_vmx (mword s, mword b, mword l, mword a)
        {
            sel   = static_cast<uint16>(s);
c0014b41:	66 c7 83 30 01 00 00 	movw   $0x0,0x130(%ebx)
c0014b48:	00 00 
            ar    = static_cast<uint16>((a >> 4 & 0x1f00) | (a & 0xff));
c0014b4a:	66 c7 83 32 01 00 00 	movw   $0x0,0x132(%ebx)
c0014b51:	00 00 
            limit = static_cast<uint32>(l);
c0014b53:	89 93 34 01 00 00    	mov    %edx,0x134(%ebx)
            base  = b;
c0014b59:	89 83 38 01 00 00    	mov    %eax,0x138(%ebx)
c0014b5f:	c7 83 3c 01 00 00 00 	movl   $0x0,0x13c(%ebx)
c0014b66:	00 00 00 
        id.set_vmx (0, Vmcs::read (Vmcs::GUEST_BASE_IDTR), Vmcs::read (Vmcs::GUEST_LIMIT_IDTR), 0);

    if (m & Mtd::CR) {
c0014b69:	f7 c6 00 10 00 00    	test   $0x1000,%esi
c0014b6f:	74 39                	je     c0014baa <_ZN4Utcb8load_vmxEP8Cpu_regs+0x460>
        cr0 = regs->read_cr<Vmcs> (0);
c0014b71:	31 d2                	xor    %edx,%edx
c0014b73:	89 f8                	mov    %edi,%eax
c0014b75:	e8 7c a3 ff ff       	call   c000eef6 <_ZNK8Exc_regs7read_crI4VmcsEEmj>
        cr2 = regs->read_cr<Vmcs> (2);
c0014b7a:	ba 02 00 00 00       	mov    $0x2,%edx

    if (m & Mtd::IDTR)
        id.set_vmx (0, Vmcs::read (Vmcs::GUEST_BASE_IDTR), Vmcs::read (Vmcs::GUEST_LIMIT_IDTR), 0);

    if (m & Mtd::CR) {
        cr0 = regs->read_cr<Vmcs> (0);
c0014b7f:	89 43 70             	mov    %eax,0x70(%ebx)
        cr2 = regs->read_cr<Vmcs> (2);
c0014b82:	89 f8                	mov    %edi,%eax
c0014b84:	e8 6d a3 ff ff       	call   c000eef6 <_ZNK8Exc_regs7read_crI4VmcsEEmj>
        cr3 = regs->read_cr<Vmcs> (3);
c0014b89:	ba 03 00 00 00       	mov    $0x3,%edx
    if (m & Mtd::IDTR)
        id.set_vmx (0, Vmcs::read (Vmcs::GUEST_BASE_IDTR), Vmcs::read (Vmcs::GUEST_LIMIT_IDTR), 0);

    if (m & Mtd::CR) {
        cr0 = regs->read_cr<Vmcs> (0);
        cr2 = regs->read_cr<Vmcs> (2);
c0014b8e:	89 43 74             	mov    %eax,0x74(%ebx)
        cr3 = regs->read_cr<Vmcs> (3);
c0014b91:	89 f8                	mov    %edi,%eax
c0014b93:	e8 5e a3 ff ff       	call   c000eef6 <_ZNK8Exc_regs7read_crI4VmcsEEmj>
        cr4 = regs->read_cr<Vmcs> (4);
c0014b98:	ba 04 00 00 00       	mov    $0x4,%edx
        id.set_vmx (0, Vmcs::read (Vmcs::GUEST_BASE_IDTR), Vmcs::read (Vmcs::GUEST_LIMIT_IDTR), 0);

    if (m & Mtd::CR) {
        cr0 = regs->read_cr<Vmcs> (0);
        cr2 = regs->read_cr<Vmcs> (2);
        cr3 = regs->read_cr<Vmcs> (3);
c0014b9d:	89 43 78             	mov    %eax,0x78(%ebx)
        cr4 = regs->read_cr<Vmcs> (4);
c0014ba0:	89 f8                	mov    %edi,%eax
c0014ba2:	e8 4f a3 ff ff       	call   c000eef6 <_ZNK8Exc_regs7read_crI4VmcsEEmj>
c0014ba7:	89 43 7c             	mov    %eax,0x7c(%ebx)
    }

    if (m & Mtd::DR)
c0014baa:	f7 c6 00 20 00 00    	test   $0x2000,%esi
c0014bb0:	74 0c                	je     c0014bbe <_ZN4Utcb8load_vmxEP8Cpu_regs+0x474>
        dr7 = Vmcs::read (Vmcs::GUEST_DR7);
c0014bb2:	b8 1a 68 00 00       	mov    $0x681a,%eax
c0014bb7:	0f 78 83 90 00 00 00 	vmread %eax,0x90(%ebx)

    if (m & Mtd::SYSENTER) {
c0014bbe:	f7 c6 00 40 00 00    	test   $0x4000,%esi
c0014bc4:	74 20                	je     c0014be6 <_ZN4Utcb8load_vmxEP8Cpu_regs+0x49c>
        sysenter_cs  = Vmcs::read (Vmcs::GUEST_SYSENTER_CS);
c0014bc6:	b8 2a 48 00 00       	mov    $0x482a,%eax
c0014bcb:	0f 78 83 94 00 00 00 	vmread %eax,0x94(%ebx)
        sysenter_rsp = Vmcs::read (Vmcs::GUEST_SYSENTER_ESP);
c0014bd2:	66 b8 24 68          	mov    $0x6824,%ax
c0014bd6:	0f 78 83 98 00 00 00 	vmread %eax,0x98(%ebx)
        sysenter_rip = Vmcs::read (Vmcs::GUEST_SYSENTER_EIP);
c0014bdd:	b0 26                	mov    $0x26,%al
c0014bdf:	0f 78 83 9c 00 00 00 	vmread %eax,0x9c(%ebx)
    }

    if (m & Mtd::QUAL) {
c0014be6:	f7 c6 00 80 00 00    	test   $0x8000,%esi
c0014bec:	74 3c                	je     c0014c2a <_ZN4Utcb8load_vmxEP8Cpu_regs+0x4e0>
        if (regs->dst_portal == 48) {
c0014bee:	83 7f 34 30          	cmpl   $0x30,0x34(%edi)
c0014bf2:	75 12                	jne    c0014c06 <_ZN4Utcb8load_vmxEP8Cpu_regs+0x4bc>
            qual[0] = regs->nst_error;
c0014bf4:	8b 47 3c             	mov    0x3c(%edi),%eax
c0014bf7:	c7 43 54 00 00 00 00 	movl   $0x0,0x54(%ebx)
c0014bfe:	89 43 50             	mov    %eax,0x50(%ebx)
            qual[1] = regs->nst_fault;
c0014c01:	8b 47 38             	mov    0x38(%edi),%eax
c0014c04:	eb 1a                	jmp    c0014c20 <_ZN4Utcb8load_vmxEP8Cpu_regs+0x4d6>
c0014c06:	b8 00 64 00 00       	mov    $0x6400,%eax
c0014c0b:	0f 78 c0             	vmread %eax,%eax
        } else {
            qual[0] = Vmcs::read (Vmcs::EXI_QUALIFICATION);
c0014c0e:	89 43 50             	mov    %eax,0x50(%ebx)
c0014c11:	b8 00 24 00 00       	mov    $0x2400,%eax
c0014c16:	c7 43 54 00 00 00 00 	movl   $0x0,0x54(%ebx)
c0014c1d:	0f 78 c0             	vmread %eax,%eax
            qual[1] = Vmcs::read (Vmcs::INFO_PHYS_ADDR);
c0014c20:	89 43 58             	mov    %eax,0x58(%ebx)
c0014c23:	c7 43 5c 00 00 00 00 	movl   $0x0,0x5c(%ebx)
        }
    }

    if (m & Mtd::INJ) {
c0014c2a:	f7 c6 00 00 02 00    	test   $0x20000,%esi
c0014c30:	74 2b                	je     c0014c5d <_ZN4Utcb8load_vmxEP8Cpu_regs+0x513>
        if (regs->dst_portal == 33 || regs->dst_portal == NUM_VMI - 1) {
c0014c32:	8b 47 34             	mov    0x34(%edi),%eax
c0014c35:	3d ff 00 00 00       	cmp    $0xff,%eax
c0014c3a:	74 05                	je     c0014c41 <_ZN4Utcb8load_vmxEP8Cpu_regs+0x4f7>
c0014c3c:	83 f8 21             	cmp    $0x21,%eax
c0014c3f:	75 0d                	jne    c0014c4e <_ZN4Utcb8load_vmxEP8Cpu_regs+0x504>
            intr_info  = static_cast<uint32>(Vmcs::read (Vmcs::ENT_INTR_INFO));
c0014c41:	b8 16 40 00 00       	mov    $0x4016,%eax
c0014c46:	0f 78 43 28          	vmread %eax,0x28(%ebx)
            intr_error = static_cast<uint32>(Vmcs::read (Vmcs::ENT_INTR_ERROR));
c0014c4a:	b0 18                	mov    $0x18,%al
c0014c4c:	eb 0b                	jmp    c0014c59 <_ZN4Utcb8load_vmxEP8Cpu_regs+0x50f>
        } else {
            intr_info  = static_cast<uint32>(Vmcs::read (Vmcs::IDT_VECT_INFO));
c0014c4e:	b8 08 44 00 00       	mov    $0x4408,%eax
c0014c53:	0f 78 43 28          	vmread %eax,0x28(%ebx)
            intr_error = static_cast<uint32>(Vmcs::read (Vmcs::IDT_VECT_ERROR));
c0014c57:	b0 0a                	mov    $0xa,%al
c0014c59:	0f 78 43 2c          	vmread %eax,0x2c(%ebx)
        }
    }

    if (m & Mtd::STA) {
c0014c5d:	f7 c6 00 00 04 00    	test   $0x40000,%esi
c0014c63:	74 0f                	je     c0014c74 <_ZN4Utcb8load_vmxEP8Cpu_regs+0x52a>
        intr_state = static_cast<uint32>(Vmcs::read (Vmcs::GUEST_INTR_STATE));
c0014c65:	b8 24 48 00 00       	mov    $0x4824,%eax
c0014c6a:	0f 78 43 20          	vmread %eax,0x20(%ebx)
        actv_state = static_cast<uint32>(Vmcs::read (Vmcs::GUEST_ACTV_STATE));
c0014c6e:	b0 26                	mov    $0x26,%al
c0014c70:	0f 78 43 24          	vmread %eax,0x24(%ebx)
    }

    if (m & Mtd::TSC) {
c0014c74:	f7 c6 00 00 08 00    	test   $0x80000,%esi
c0014c7a:	74 20                	je     c0014c9c <_ZN4Utcb8load_vmxEP8Cpu_regs+0x552>
c0014c7c:	0f 31                	rdtsc  
    return static_cast<uint64>(h) << 32 | l;
c0014c7e:	89 83 40 01 00 00    	mov    %eax,0x140(%ebx)
c0014c84:	89 93 44 01 00 00    	mov    %edx,0x144(%ebx)
        tsc_val = rdtsc();
        tsc_off = regs->tsc_offset;
c0014c8a:	8b 47 50             	mov    0x50(%edi),%eax
c0014c8d:	8b 57 54             	mov    0x54(%edi),%edx
c0014c90:	89 83 48 01 00 00    	mov    %eax,0x148(%ebx)
c0014c96:	89 93 4c 01 00 00    	mov    %edx,0x14c(%ebx)
        tpr = virtual_apic_page->vtpr();
        tpr_threshold = static_cast<uint32>(Vmcs::read(Vmcs::TPR_THRESHOLD));
    }
#endif

    if (m & Mtd::PDPTE) {
c0014c9c:	f7 c6 00 00 20 00    	test   $0x200000,%esi
c0014ca2:	74 27                	je     c0014ccb <_ZN4Utcb8load_vmxEP8Cpu_regs+0x581>
        pdpte[0] = Vmcs::read (Vmcs::GUEST_PDPTE0);
c0014ca4:	b8 0a 28 00 00       	mov    $0x280a,%eax
c0014ca9:	0f 78 83 80 00 00 00 	vmread %eax,0x80(%ebx)
        pdpte[1] = Vmcs::read (Vmcs::GUEST_PDPTE1);
c0014cb0:	b0 0c                	mov    $0xc,%al
c0014cb2:	0f 78 83 84 00 00 00 	vmread %eax,0x84(%ebx)
        pdpte[2] = Vmcs::read (Vmcs::GUEST_PDPTE2);
c0014cb9:	b0 0e                	mov    $0xe,%al
c0014cbb:	0f 78 83 88 00 00 00 	vmread %eax,0x88(%ebx)
        pdpte[3] = Vmcs::read (Vmcs::GUEST_PDPTE3);
c0014cc2:	b0 10                	mov    $0x10,%al
c0014cc4:	0f 78 83 8c 00 00 00 	vmread %eax,0x8c(%ebx)
    }

    barrier();
    mtd = m;
c0014ccb:	89 73 10             	mov    %esi,0x10(%ebx)
    items = sizeof (Utcb_data) / sizeof (mword);

    return m & Mtd::FPU;
c0014cce:	89 f0                	mov    %esi,%eax
        pdpte[3] = Vmcs::read (Vmcs::GUEST_PDPTE3);
    }

    barrier();
    mtd = m;
    items = sizeof (Utcb_data) / sizeof (mword);
c0014cd0:	c7 03 50 00 00 00    	movl   $0x50,(%ebx)

    return m & Mtd::FPU;
}
c0014cd6:	83 c4 08             	add    $0x8,%esp
c0014cd9:	5b                   	pop    %ebx

    barrier();
    mtd = m;
    items = sizeof (Utcb_data) / sizeof (mword);

    return m & Mtd::FPU;
c0014cda:	c1 e8 1f             	shr    $0x1f,%eax
}
c0014cdd:	5e                   	pop    %esi
c0014cde:	5f                   	pop    %edi
c0014cdf:	5d                   	pop    %ebp
c0014ce0:	c3                   	ret    
c0014ce1:	90                   	nop

c0014ce2 <_ZN4Utcb8save_vmxEP8Cpu_regs>:

bool Utcb::save_vmx (Cpu_regs *regs)
{
c0014ce2:	56                   	push   %esi
c0014ce3:	89 d6                	mov    %edx,%esi
c0014ce5:	53                   	push   %ebx
c0014ce6:	89 c3                	mov    %eax,%ebx
c0014ce8:	83 ec 08             	sub    $0x8,%esp
    if (mtd & Mtd::GPR_ACDB) {
c0014ceb:	f6 40 10 01          	testb  $0x1,0x10(%eax)
c0014cef:	74 18                	je     c0014d09 <_ZN4Utcb8save_vmxEP8Cpu_regs+0x27>
        regs->REG(ax) = rax;
c0014cf1:	8b 40 30             	mov    0x30(%eax),%eax
c0014cf4:	89 42 1c             	mov    %eax,0x1c(%edx)
        regs->REG(cx) = rcx;
c0014cf7:	8b 43 34             	mov    0x34(%ebx),%eax
c0014cfa:	89 42 18             	mov    %eax,0x18(%edx)
        regs->REG(dx) = rdx;
c0014cfd:	8b 43 38             	mov    0x38(%ebx),%eax
c0014d00:	89 42 14             	mov    %eax,0x14(%edx)
        regs->REG(bx) = rbx;
c0014d03:	8b 43 3c             	mov    0x3c(%ebx),%eax
c0014d06:	89 42 10             	mov    %eax,0x10(%edx)
    }

    if (mtd & Mtd::GPR_BSD) {
c0014d09:	f6 43 10 02          	testb  $0x2,0x10(%ebx)
c0014d0d:	74 11                	je     c0014d20 <_ZN4Utcb8save_vmxEP8Cpu_regs+0x3e>
        regs->REG(bp) = rbp;
c0014d0f:	8b 43 44             	mov    0x44(%ebx),%eax
c0014d12:	89 46 08             	mov    %eax,0x8(%esi)
        regs->REG(si) = rsi;
c0014d15:	8b 43 48             	mov    0x48(%ebx),%eax
c0014d18:	89 46 04             	mov    %eax,0x4(%esi)
        regs->REG(di) = rdi;
c0014d1b:	8b 43 4c             	mov    0x4c(%ebx),%eax
c0014d1e:	89 06                	mov    %eax,(%esi)
        regs->r14     = r14;
        regs->r15     = r15;
    }
#endif

    regs->vmcs->make_current();
c0014d20:	8b 46 20             	mov    0x20(%esi),%eax
        }

        ALWAYS_INLINE
        inline void make_current()
        {
            if (EXPECT_TRUE (current == this))
c0014d23:	39 05 14 f0 ff cf    	cmp    %eax,0xcffff014
c0014d29:	74 3e                	je     c0014d69 <_ZN4Utcb8save_vmxEP8Cpu_regs+0x87>
                return;

            uint64 phys = Buddy::ptr_to_phys (current = this);
c0014d2b:	a3 14 f0 ff cf       	mov    %eax,0xcffff014
c0014d30:	2d 00 00 c0 bf       	sub    $0xbfc00000,%eax
c0014d35:	89 04 24             	mov    %eax,(%esp)
c0014d38:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0014d3f:	00 

            bool ret;
            asm volatile ("vmptrld %1; seta %0" : "=q" (ret) : "m" (phys) : "cc");
c0014d40:	0f c7 34 24          	vmptrld (%esp)
c0014d44:	0f 97 c0             	seta   %al
            assert (ret);
c0014d47:	84 c0                	test   %al,%al
c0014d49:	75 1e                	jne    c0014d69 <_ZN4Utcb8save_vmxEP8Cpu_regs+0x87>
c0014d4b:	68 d4 9e 01 c0       	push   $0xc0019ed4
c0014d50:	68 96 01 00 00       	push   $0x196
c0014d55:	68 13 69 01 c0       	push   $0xc0016913
c0014d5a:	68 83 69 01 c0       	push   $0xc0016983
c0014d5f:	68 69 60 01 c0       	push   $0xc0016069
c0014d64:	e8 dd cb fe ff       	call   c0001946 <_ZN7Console5panicEPKcz>

    if (mtd & Mtd::RSP)
c0014d69:	8b 43 10             	mov    0x10(%ebx),%eax
c0014d6c:	a8 04                	test   $0x4,%al
c0014d6e:	74 09                	je     c0014d79 <_ZN4Utcb8save_vmxEP8Cpu_regs+0x97>
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
c0014d70:	ba 1c 68 00 00       	mov    $0x681c,%edx
c0014d75:	0f 79 53 40          	vmwrite 0x40(%ebx),%edx
        Vmcs::write (Vmcs::GUEST_RSP, rsp);

    if (mtd & Mtd::RIP_LEN) {
c0014d79:	a8 08                	test   $0x8,%al
c0014d7b:	74 11                	je     c0014d8e <_ZN4Utcb8save_vmxEP8Cpu_regs+0xac>
c0014d7d:	ba 1e 68 00 00       	mov    $0x681e,%edx
c0014d82:	0f 79 53 18          	vmwrite 0x18(%ebx),%edx
c0014d86:	66 ba 1a 40          	mov    $0x401a,%dx
c0014d8a:	0f 79 53 14          	vmwrite 0x14(%ebx),%edx
        Vmcs::write (Vmcs::GUEST_RIP, rip);
        Vmcs::write (Vmcs::ENT_INST_LEN, inst_len);
    }

    if (mtd & Mtd::RFLAGS)
c0014d8e:	a8 10                	test   $0x10,%al
c0014d90:	74 09                	je     c0014d9b <_ZN4Utcb8save_vmxEP8Cpu_regs+0xb9>
c0014d92:	ba 20 68 00 00       	mov    $0x6820,%edx
c0014d97:	0f 79 53 1c          	vmwrite 0x1c(%ebx),%edx
        Vmcs::write (Vmcs::GUEST_RFLAGS, rflags);

    if (mtd & Mtd::DS_ES) {
c0014d9b:	a8 20                	test   $0x20,%al
c0014d9d:	0f 84 89 00 00 00    	je     c0014e2c <_ZN4Utcb8save_vmxEP8Cpu_regs+0x14a>
        Vmcs::write (Vmcs::GUEST_SEL_DS,   ds.sel);
c0014da3:	0f b7 93 d0 00 00 00 	movzwl 0xd0(%ebx),%edx
c0014daa:	b9 06 08 00 00       	mov    $0x806,%ecx
c0014daf:	0f 79 ca             	vmwrite %edx,%ecx
c0014db2:	ba 0c 68 00 00       	mov    $0x680c,%edx
c0014db7:	0f 79 93 d8 00 00 00 	vmwrite 0xd8(%ebx),%edx
c0014dbe:	66 ba 06 48          	mov    $0x4806,%dx
c0014dc2:	0f 79 93 d4 00 00 00 	vmwrite 0xd4(%ebx),%edx
        Vmcs::write (Vmcs::GUEST_BASE_DS,  static_cast<mword>(ds.base));
        Vmcs::write (Vmcs::GUEST_LIMIT_DS, ds.limit);
        Vmcs::write (Vmcs::GUEST_AR_DS,   (ds.ar << 4 & 0x1f000) | (ds.ar & 0xff));
c0014dc9:	0f b7 93 d2 00 00 00 	movzwl 0xd2(%ebx),%edx
c0014dd0:	89 d1                	mov    %edx,%ecx
c0014dd2:	0f b6 d2             	movzbl %dl,%edx
c0014dd5:	c1 e1 04             	shl    $0x4,%ecx
c0014dd8:	81 e1 00 f0 01 00    	and    $0x1f000,%ecx
c0014dde:	09 ca                	or     %ecx,%edx
c0014de0:	b9 1a 48 00 00       	mov    $0x481a,%ecx
c0014de5:	0f 79 ca             	vmwrite %edx,%ecx
        Vmcs::write (Vmcs::GUEST_SEL_ES,   es.sel);
c0014de8:	0f b7 93 a0 00 00 00 	movzwl 0xa0(%ebx),%edx
c0014def:	66 b9 00 08          	mov    $0x800,%cx
c0014df3:	0f 79 ca             	vmwrite %edx,%ecx
c0014df6:	ba 06 68 00 00       	mov    $0x6806,%edx
c0014dfb:	0f 79 93 a8 00 00 00 	vmwrite 0xa8(%ebx),%edx
c0014e02:	66 ba 00 48          	mov    $0x4800,%dx
c0014e06:	0f 79 93 a4 00 00 00 	vmwrite 0xa4(%ebx),%edx
        Vmcs::write (Vmcs::GUEST_BASE_ES,  static_cast<mword>(es.base));
        Vmcs::write (Vmcs::GUEST_LIMIT_ES, es.limit);
        Vmcs::write (Vmcs::GUEST_AR_ES,   (es.ar << 4 & 0x1f000) | (es.ar & 0xff));
c0014e0d:	0f b7 93 a2 00 00 00 	movzwl 0xa2(%ebx),%edx
c0014e14:	89 d1                	mov    %edx,%ecx
c0014e16:	0f b6 d2             	movzbl %dl,%edx
c0014e19:	c1 e1 04             	shl    $0x4,%ecx
c0014e1c:	81 e1 00 f0 01 00    	and    $0x1f000,%ecx
c0014e22:	09 ca                	or     %ecx,%edx
c0014e24:	b9 14 48 00 00       	mov    $0x4814,%ecx
c0014e29:	0f 79 ca             	vmwrite %edx,%ecx
    }

    if (mtd & Mtd::FS_GS) {
c0014e2c:	a8 40                	test   $0x40,%al
c0014e2e:	0f 84 89 00 00 00    	je     c0014ebd <_ZN4Utcb8save_vmxEP8Cpu_regs+0x1db>
        Vmcs::write (Vmcs::GUEST_SEL_FS,   fs.sel);
c0014e34:	0f b7 93 e0 00 00 00 	movzwl 0xe0(%ebx),%edx
c0014e3b:	b9 08 08 00 00       	mov    $0x808,%ecx
c0014e40:	0f 79 ca             	vmwrite %edx,%ecx
c0014e43:	ba 0e 68 00 00       	mov    $0x680e,%edx
c0014e48:	0f 79 93 e8 00 00 00 	vmwrite 0xe8(%ebx),%edx
c0014e4f:	66 ba 08 48          	mov    $0x4808,%dx
c0014e53:	0f 79 93 e4 00 00 00 	vmwrite 0xe4(%ebx),%edx
        Vmcs::write (Vmcs::GUEST_BASE_FS,  static_cast<mword>(fs.base));
        Vmcs::write (Vmcs::GUEST_LIMIT_FS, fs.limit);
        Vmcs::write (Vmcs::GUEST_AR_FS,   (fs.ar << 4 & 0x1f000) | (fs.ar & 0xff));
c0014e5a:	0f b7 93 e2 00 00 00 	movzwl 0xe2(%ebx),%edx
c0014e61:	89 d1                	mov    %edx,%ecx
c0014e63:	0f b6 d2             	movzbl %dl,%edx
c0014e66:	c1 e1 04             	shl    $0x4,%ecx
c0014e69:	81 e1 00 f0 01 00    	and    $0x1f000,%ecx
c0014e6f:	09 ca                	or     %ecx,%edx
c0014e71:	b9 1c 48 00 00       	mov    $0x481c,%ecx
c0014e76:	0f 79 ca             	vmwrite %edx,%ecx
        Vmcs::write (Vmcs::GUEST_SEL_GS,   gs.sel);
c0014e79:	0f b7 93 f0 00 00 00 	movzwl 0xf0(%ebx),%edx
c0014e80:	66 b9 0a 08          	mov    $0x80a,%cx
c0014e84:	0f 79 ca             	vmwrite %edx,%ecx
c0014e87:	ba 10 68 00 00       	mov    $0x6810,%edx
c0014e8c:	0f 79 93 f8 00 00 00 	vmwrite 0xf8(%ebx),%edx
c0014e93:	66 ba 0a 48          	mov    $0x480a,%dx
c0014e97:	0f 79 93 f4 00 00 00 	vmwrite 0xf4(%ebx),%edx
        Vmcs::write (Vmcs::GUEST_BASE_GS,  static_cast<mword>(gs.base));
        Vmcs::write (Vmcs::GUEST_LIMIT_GS, gs.limit);
        Vmcs::write (Vmcs::GUEST_AR_GS,   (gs.ar << 4 & 0x1f000) | (gs.ar & 0xff));
c0014e9e:	0f b7 93 f2 00 00 00 	movzwl 0xf2(%ebx),%edx
c0014ea5:	89 d1                	mov    %edx,%ecx
c0014ea7:	0f b6 d2             	movzbl %dl,%edx
c0014eaa:	c1 e1 04             	shl    $0x4,%ecx
c0014ead:	81 e1 00 f0 01 00    	and    $0x1f000,%ecx
c0014eb3:	09 ca                	or     %ecx,%edx
c0014eb5:	b9 1e 48 00 00       	mov    $0x481e,%ecx
c0014eba:	0f 79 ca             	vmwrite %edx,%ecx
    }

    if (mtd & Mtd::CS_SS) {
c0014ebd:	a8 80                	test   $0x80,%al
c0014ebf:	0f 84 89 00 00 00    	je     c0014f4e <_ZN4Utcb8save_vmxEP8Cpu_regs+0x26c>
        Vmcs::write (Vmcs::GUEST_SEL_CS,   cs.sel);
c0014ec5:	0f b7 93 b0 00 00 00 	movzwl 0xb0(%ebx),%edx
c0014ecc:	b9 02 08 00 00       	mov    $0x802,%ecx
c0014ed1:	0f 79 ca             	vmwrite %edx,%ecx
c0014ed4:	ba 08 68 00 00       	mov    $0x6808,%edx
c0014ed9:	0f 79 93 b8 00 00 00 	vmwrite 0xb8(%ebx),%edx
c0014ee0:	66 ba 02 48          	mov    $0x4802,%dx
c0014ee4:	0f 79 93 b4 00 00 00 	vmwrite 0xb4(%ebx),%edx
        Vmcs::write (Vmcs::GUEST_BASE_CS,  static_cast<mword>(cs.base));
        Vmcs::write (Vmcs::GUEST_LIMIT_CS, cs.limit);
        Vmcs::write (Vmcs::GUEST_AR_CS,   (cs.ar << 4 & 0x1f000) | (cs.ar & 0xff));
c0014eeb:	0f b7 93 b2 00 00 00 	movzwl 0xb2(%ebx),%edx
c0014ef2:	89 d1                	mov    %edx,%ecx
c0014ef4:	0f b6 d2             	movzbl %dl,%edx
c0014ef7:	c1 e1 04             	shl    $0x4,%ecx
c0014efa:	81 e1 00 f0 01 00    	and    $0x1f000,%ecx
c0014f00:	09 ca                	or     %ecx,%edx
c0014f02:	b9 16 48 00 00       	mov    $0x4816,%ecx
c0014f07:	0f 79 ca             	vmwrite %edx,%ecx
        Vmcs::write (Vmcs::GUEST_SEL_SS,   ss.sel);
c0014f0a:	0f b7 93 c0 00 00 00 	movzwl 0xc0(%ebx),%edx
c0014f11:	66 b9 04 08          	mov    $0x804,%cx
c0014f15:	0f 79 ca             	vmwrite %edx,%ecx
c0014f18:	ba 0a 68 00 00       	mov    $0x680a,%edx
c0014f1d:	0f 79 93 c8 00 00 00 	vmwrite 0xc8(%ebx),%edx
c0014f24:	66 ba 04 48          	mov    $0x4804,%dx
c0014f28:	0f 79 93 c4 00 00 00 	vmwrite 0xc4(%ebx),%edx
        Vmcs::write (Vmcs::GUEST_BASE_SS,  static_cast<mword>(ss.base));
        Vmcs::write (Vmcs::GUEST_LIMIT_SS, ss.limit);
        Vmcs::write (Vmcs::GUEST_AR_SS,   (ss.ar << 4 & 0x1f000) | (ss.ar & 0xff));
c0014f2f:	0f b7 93 c2 00 00 00 	movzwl 0xc2(%ebx),%edx
c0014f36:	89 d1                	mov    %edx,%ecx
c0014f38:	0f b6 d2             	movzbl %dl,%edx
c0014f3b:	c1 e1 04             	shl    $0x4,%ecx
c0014f3e:	81 e1 00 f0 01 00    	and    $0x1f000,%ecx
c0014f44:	09 ca                	or     %ecx,%edx
c0014f46:	b9 18 48 00 00       	mov    $0x4818,%ecx
c0014f4b:	0f 79 ca             	vmwrite %edx,%ecx
    }

    if (mtd & Mtd::TR) {
c0014f4e:	f6 c4 01             	test   $0x1,%ah
c0014f51:	74 45                	je     c0014f98 <_ZN4Utcb8save_vmxEP8Cpu_regs+0x2b6>
        Vmcs::write (Vmcs::GUEST_SEL_TR,     tr.sel);
c0014f53:	0f b7 93 10 01 00 00 	movzwl 0x110(%ebx),%edx
c0014f5a:	b9 0e 08 00 00       	mov    $0x80e,%ecx
c0014f5f:	0f 79 ca             	vmwrite %edx,%ecx
c0014f62:	ba 14 68 00 00       	mov    $0x6814,%edx
c0014f67:	0f 79 93 18 01 00 00 	vmwrite 0x118(%ebx),%edx
c0014f6e:	66 ba 0e 48          	mov    $0x480e,%dx
c0014f72:	0f 79 93 14 01 00 00 	vmwrite 0x114(%ebx),%edx
        Vmcs::write (Vmcs::GUEST_BASE_TR,    static_cast<mword>(tr.base));
        Vmcs::write (Vmcs::GUEST_LIMIT_TR,   tr.limit);
        Vmcs::write (Vmcs::GUEST_AR_TR,     (tr.ar << 4 & 0x1f000) | (tr.ar & 0xff));
c0014f79:	0f b7 93 12 01 00 00 	movzwl 0x112(%ebx),%edx
c0014f80:	89 d1                	mov    %edx,%ecx
c0014f82:	0f b6 d2             	movzbl %dl,%edx
c0014f85:	c1 e1 04             	shl    $0x4,%ecx
c0014f88:	81 e1 00 f0 01 00    	and    $0x1f000,%ecx
c0014f8e:	09 ca                	or     %ecx,%edx
c0014f90:	b9 22 48 00 00       	mov    $0x4822,%ecx
c0014f95:	0f 79 ca             	vmwrite %edx,%ecx
    }

    if (mtd & Mtd::LDTR) {
c0014f98:	f6 c4 02             	test   $0x2,%ah
c0014f9b:	74 45                	je     c0014fe2 <_ZN4Utcb8save_vmxEP8Cpu_regs+0x300>
        Vmcs::write (Vmcs::GUEST_SEL_LDTR,   ld.sel);
c0014f9d:	0f b7 93 00 01 00 00 	movzwl 0x100(%ebx),%edx
c0014fa4:	b9 0c 08 00 00       	mov    $0x80c,%ecx
c0014fa9:	0f 79 ca             	vmwrite %edx,%ecx
c0014fac:	ba 12 68 00 00       	mov    $0x6812,%edx
c0014fb1:	0f 79 93 08 01 00 00 	vmwrite 0x108(%ebx),%edx
c0014fb8:	66 ba 0c 48          	mov    $0x480c,%dx
c0014fbc:	0f 79 93 04 01 00 00 	vmwrite 0x104(%ebx),%edx
        Vmcs::write (Vmcs::GUEST_BASE_LDTR,  static_cast<mword>(ld.base));
        Vmcs::write (Vmcs::GUEST_LIMIT_LDTR, ld.limit);
        Vmcs::write (Vmcs::GUEST_AR_LDTR,   (ld.ar << 4 & 0x1f000) | (ld.ar & 0xff));
c0014fc3:	0f b7 93 02 01 00 00 	movzwl 0x102(%ebx),%edx
c0014fca:	89 d1                	mov    %edx,%ecx
c0014fcc:	0f b6 d2             	movzbl %dl,%edx
c0014fcf:	c1 e1 04             	shl    $0x4,%ecx
c0014fd2:	81 e1 00 f0 01 00    	and    $0x1f000,%ecx
c0014fd8:	09 ca                	or     %ecx,%edx
c0014fda:	b9 20 48 00 00       	mov    $0x4820,%ecx
c0014fdf:	0f 79 ca             	vmwrite %edx,%ecx
    }

    if (mtd & Mtd::GDTR) {
c0014fe2:	f6 c4 04             	test   $0x4,%ah
c0014fe5:	74 17                	je     c0014ffe <_ZN4Utcb8save_vmxEP8Cpu_regs+0x31c>
c0014fe7:	ba 16 68 00 00       	mov    $0x6816,%edx
c0014fec:	0f 79 93 28 01 00 00 	vmwrite 0x128(%ebx),%edx
c0014ff3:	66 ba 10 48          	mov    $0x4810,%dx
c0014ff7:	0f 79 93 24 01 00 00 	vmwrite 0x124(%ebx),%edx
        Vmcs::write (Vmcs::GUEST_BASE_GDTR,  static_cast<mword>(gd.base));
        Vmcs::write (Vmcs::GUEST_LIMIT_GDTR, gd.limit);
    }

    if (mtd & Mtd::IDTR) {
c0014ffe:	f6 c4 08             	test   $0x8,%ah
c0015001:	74 17                	je     c001501a <_ZN4Utcb8save_vmxEP8Cpu_regs+0x338>
c0015003:	ba 18 68 00 00       	mov    $0x6818,%edx
c0015008:	0f 79 93 38 01 00 00 	vmwrite 0x138(%ebx),%edx
c001500f:	66 ba 12 48          	mov    $0x4812,%dx
c0015013:	0f 79 93 34 01 00 00 	vmwrite 0x134(%ebx),%edx
        Vmcs::write (Vmcs::GUEST_BASE_IDTR,  static_cast<mword>(id.base));
        Vmcs::write (Vmcs::GUEST_LIMIT_IDTR, id.limit);
    }

    if (mtd & Mtd::CR) {
c001501a:	f6 c4 10             	test   $0x10,%ah
c001501d:	74 39                	je     c0015058 <_ZN4Utcb8save_vmxEP8Cpu_regs+0x376>
        regs->write_cr<Vmcs> (0, cr0);
c001501f:	8b 4b 70             	mov    0x70(%ebx),%ecx
c0015022:	31 d2                	xor    %edx,%edx
c0015024:	89 f0                	mov    %esi,%eax
c0015026:	e8 39 a1 ff ff       	call   c000f164 <_ZN8Exc_regs8write_crI4VmcsEEvjm>
        regs->write_cr<Vmcs> (2, cr2);
c001502b:	8b 4b 74             	mov    0x74(%ebx),%ecx
c001502e:	ba 02 00 00 00       	mov    $0x2,%edx
c0015033:	89 f0                	mov    %esi,%eax
c0015035:	e8 2a a1 ff ff       	call   c000f164 <_ZN8Exc_regs8write_crI4VmcsEEvjm>
        regs->write_cr<Vmcs> (3, cr3);
c001503a:	8b 4b 78             	mov    0x78(%ebx),%ecx
c001503d:	ba 03 00 00 00       	mov    $0x3,%edx
c0015042:	89 f0                	mov    %esi,%eax
c0015044:	e8 1b a1 ff ff       	call   c000f164 <_ZN8Exc_regs8write_crI4VmcsEEvjm>
        regs->write_cr<Vmcs> (4, cr4);
c0015049:	8b 4b 7c             	mov    0x7c(%ebx),%ecx
c001504c:	ba 04 00 00 00       	mov    $0x4,%edx
c0015051:	89 f0                	mov    %esi,%eax
c0015053:	e8 0c a1 ff ff       	call   c000f164 <_ZN8Exc_regs8write_crI4VmcsEEvjm>
    }

    if (mtd & Mtd::DR)
c0015058:	8b 43 10             	mov    0x10(%ebx),%eax
c001505b:	f6 c4 20             	test   $0x20,%ah
c001505e:	74 0c                	je     c001506c <_ZN4Utcb8save_vmxEP8Cpu_regs+0x38a>
c0015060:	ba 1a 68 00 00       	mov    $0x681a,%edx
c0015065:	0f 79 93 90 00 00 00 	vmwrite 0x90(%ebx),%edx
        Vmcs::write (Vmcs::GUEST_DR7, dr7);

    if (mtd & Mtd::SYSENTER) {
c001506c:	f6 c4 40             	test   $0x40,%ah
c001506f:	74 20                	je     c0015091 <_ZN4Utcb8save_vmxEP8Cpu_regs+0x3af>
c0015071:	ba 2a 48 00 00       	mov    $0x482a,%edx
c0015076:	0f 79 93 94 00 00 00 	vmwrite 0x94(%ebx),%edx
c001507d:	66 ba 24 68          	mov    $0x6824,%dx
c0015081:	0f 79 93 98 00 00 00 	vmwrite 0x98(%ebx),%edx
c0015088:	b2 26                	mov    $0x26,%dl
c001508a:	0f 79 93 9c 00 00 00 	vmwrite 0x9c(%ebx),%edx
        Vmcs::write (Vmcs::GUEST_SYSENTER_CS,  sysenter_cs);
        Vmcs::write (Vmcs::GUEST_SYSENTER_ESP, sysenter_rsp);
        Vmcs::write (Vmcs::GUEST_SYSENTER_EIP, sysenter_rip);
    }

    if (mtd & Mtd::CTRL) {
c0015091:	a9 00 00 01 00       	test   $0x10000,%eax
c0015096:	74 14                	je     c00150ac <_ZN4Utcb8save_vmxEP8Cpu_regs+0x3ca>
        regs->vmx_set_cpu_ctrl0 (ctrl[0]);
c0015098:	8b 53 60             	mov    0x60(%ebx),%edx
c001509b:	89 f0                	mov    %esi,%eax
c001509d:	e8 96 95 ff ff       	call   c000e638 <_ZN8Exc_regs17vmx_set_cpu_ctrl0Em>
        regs->vmx_set_cpu_ctrl1 (ctrl[1]);
c00150a2:	8b 53 64             	mov    0x64(%ebx),%edx
c00150a5:	89 f0                	mov    %esi,%eax
c00150a7:	e8 b6 95 ff ff       	call   c000e662 <_ZN8Exc_regs17vmx_set_cpu_ctrl1Em>
    }

    if (mtd & Mtd::INJ) {
c00150ac:	f6 43 12 02          	testb  $0x2,0x12(%ebx)
c00150b0:	74 4b                	je     c00150fd <_ZN4Utcb8save_vmxEP8Cpu_regs+0x41b>

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
c00150b2:	ba 02 40 00 00       	mov    $0x4002,%edx
c00150b7:	0f 78 d2             	vmread %edx,%edx

        uint32 val = static_cast<uint32>(Vmcs::read (Vmcs::CPU_EXEC_CTRL0));

        if (intr_info & 0x1000)
c00150ba:	8b 43 28             	mov    0x28(%ebx),%eax
            val |=  Vmcs::CPU_INTR_WINDOW;
c00150bd:	89 d1                	mov    %edx,%ecx
c00150bf:	83 e2 fb             	and    $0xfffffffb,%edx
c00150c2:	83 c9 04             	or     $0x4,%ecx
c00150c5:	f6 c4 10             	test   $0x10,%ah
c00150c8:	0f 45 d1             	cmovne %ecx,%edx
        else
            val &= ~Vmcs::CPU_INTR_WINDOW;

        if (intr_info & 0x2000)
            val |=  Vmcs::CPU_NMI_WINDOW;
c00150cb:	89 d1                	mov    %edx,%ecx
c00150cd:	81 e2 ff ff bf ff    	and    $0xffbfffff,%edx
c00150d3:	81 c9 00 00 40 00    	or     $0x400000,%ecx
c00150d9:	f6 c4 20             	test   $0x20,%ah
c00150dc:	0f 45 d1             	cmovne %ecx,%edx
        else
            val &= ~Vmcs::CPU_NMI_WINDOW;

        regs->vmx_set_cpu_ctrl0 (val);
c00150df:	89 f0                	mov    %esi,%eax
c00150e1:	e8 52 95 ff ff       	call   c000e638 <_ZN8Exc_regs17vmx_set_cpu_ctrl0Em>

        Vmcs::write (Vmcs::ENT_INTR_INFO,  intr_info & ~0x3000);
c00150e6:	8b 43 28             	mov    0x28(%ebx),%eax
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
c00150e9:	ba 16 40 00 00       	mov    $0x4016,%edx
c00150ee:	80 e4 cf             	and    $0xcf,%ah
c00150f1:	0f 79 d0             	vmwrite %eax,%edx
c00150f4:	b8 18 40 00 00       	mov    $0x4018,%eax
c00150f9:	0f 79 43 2c          	vmwrite 0x2c(%ebx),%eax
        Vmcs::write (Vmcs::ENT_INTR_ERROR, intr_error);
    }

    if (mtd & Mtd::STA) {
c00150fd:	8b 43 10             	mov    0x10(%ebx),%eax
c0015100:	a9 00 00 04 00       	test   $0x40000,%eax
c0015105:	74 0f                	je     c0015116 <_ZN4Utcb8save_vmxEP8Cpu_regs+0x434>
c0015107:	ba 24 48 00 00       	mov    $0x4824,%edx
c001510c:	0f 79 53 20          	vmwrite 0x20(%ebx),%edx
c0015110:	b2 26                	mov    $0x26,%dl
c0015112:	0f 79 53 24          	vmwrite 0x24(%ebx),%edx
        Vmcs::write (Vmcs::GUEST_INTR_STATE, intr_state);
        Vmcs::write (Vmcs::GUEST_ACTV_STATE, actv_state);
    }

    if (mtd & Mtd::TSC)
c0015116:	a9 00 00 08 00       	test   $0x80000,%eax
c001511b:	74 1a                	je     c0015137 <_ZN4Utcb8save_vmxEP8Cpu_regs+0x455>
        inline void clr_hazard (mword h) { Atomic::clr_mask (hzd, h); }

        ALWAYS_INLINE
        inline void add_tsc_offset (uint64 tsc)
        {
            tsc_offset += tsc;
c001511d:	8b 83 48 01 00 00    	mov    0x148(%ebx),%eax
c0015123:	8b 93 4c 01 00 00    	mov    0x14c(%ebx),%edx
c0015129:	01 46 50             	add    %eax,0x50(%esi)
c001512c:	11 56 54             	adc    %edx,0x54(%esi)

        template <typename T>
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }
c001512f:	f0 81 4e 4c 00 00 00 	lock orl $0x20000000,0x4c(%esi)
c0015136:	20 
        virtual_apic_page->vtpr(tpr);
        Vmcs::write(Vmcs::TPR_THRESHOLD, tpr_threshold);
    }
#endif

    if (mtd & Mtd::PDPTE) {
c0015137:	8b 43 10             	mov    0x10(%ebx),%eax
c001513a:	a9 00 00 20 00       	test   $0x200000,%eax
c001513f:	74 27                	je     c0015168 <_ZN4Utcb8save_vmxEP8Cpu_regs+0x486>
c0015141:	ba 0a 28 00 00       	mov    $0x280a,%edx
c0015146:	0f 79 93 80 00 00 00 	vmwrite 0x80(%ebx),%edx
c001514d:	b2 0c                	mov    $0xc,%dl
c001514f:	0f 79 93 84 00 00 00 	vmwrite 0x84(%ebx),%edx
c0015156:	b2 0e                	mov    $0xe,%dl
c0015158:	0f 79 93 88 00 00 00 	vmwrite 0x88(%ebx),%edx
c001515f:	b2 10                	mov    $0x10,%dl
c0015161:	0f 79 93 8c 00 00 00 	vmwrite 0x8c(%ebx),%edx
        Vmcs::write (Vmcs::GUEST_PDPTE2, pdpte[2]);
        Vmcs::write (Vmcs::GUEST_PDPTE3, pdpte[3]);
    }

    return mtd & Mtd::FPU;
}
c0015168:	83 c4 08             	add    $0x8,%esp
c001516b:	5b                   	pop    %ebx
        Vmcs::write (Vmcs::GUEST_PDPTE1, pdpte[1]);
        Vmcs::write (Vmcs::GUEST_PDPTE2, pdpte[2]);
        Vmcs::write (Vmcs::GUEST_PDPTE3, pdpte[3]);
    }

    return mtd & Mtd::FPU;
c001516c:	c1 e8 1f             	shr    $0x1f,%eax
}
c001516f:	5e                   	pop    %esi
c0015170:	c3                   	ret    
c0015171:	90                   	nop

c0015172 <_ZN4Utcb8load_svmEP8Cpu_regs>:

bool Utcb::load_svm (Cpu_regs *regs)
{
c0015172:	55                   	push   %ebp
c0015173:	57                   	push   %edi
c0015174:	56                   	push   %esi
c0015175:	53                   	push   %ebx
c0015176:	89 c3                	mov    %eax,%ebx
c0015178:	83 ec 0c             	sub    $0xc,%esp
    Vmcb *const vmcb = regs->vmcb;

    mword m = regs->mtd;
c001517b:	8b 42 58             	mov    0x58(%edx),%eax

    return mtd & Mtd::FPU;
}

bool Utcb::load_svm (Cpu_regs *regs)
{
c001517e:	89 54 24 04          	mov    %edx,0x4(%esp)
    Vmcb *const vmcb = regs->vmcb;
c0015182:	8b 6a 20             	mov    0x20(%edx),%ebp

    mword m = regs->mtd;

    if (m & Mtd::GPR_ACDB) {
c0015185:	a8 01                	test   $0x1,%al

bool Utcb::load_svm (Cpu_regs *regs)
{
    Vmcb *const vmcb = regs->vmcb;

    mword m = regs->mtd;
c0015187:	89 04 24             	mov    %eax,(%esp)

    if (m & Mtd::GPR_ACDB) {
c001518a:	74 1b                	je     c00151a7 <_ZN4Utcb8load_svmEP8Cpu_regs+0x35>
        rax = static_cast<mword>(vmcb->rax);
c001518c:	8b 85 f8 05 00 00    	mov    0x5f8(%ebp),%eax
c0015192:	89 43 30             	mov    %eax,0x30(%ebx)
        rcx = regs->REG(cx);
c0015195:	8b 42 18             	mov    0x18(%edx),%eax
c0015198:	89 43 34             	mov    %eax,0x34(%ebx)
        rdx = regs->REG(dx);
c001519b:	8b 42 14             	mov    0x14(%edx),%eax
c001519e:	89 43 38             	mov    %eax,0x38(%ebx)
        rbx = regs->REG(bx);
c00151a1:	8b 42 10             	mov    0x10(%edx),%eax
c00151a4:	89 43 3c             	mov    %eax,0x3c(%ebx)
    }

    if (m & Mtd::GPR_BSD) {
c00151a7:	f6 04 24 02          	testb  $0x2,(%esp)
c00151ab:	74 1d                	je     c00151ca <_ZN4Utcb8load_svmEP8Cpu_regs+0x58>
        rbp = regs->REG(bp);
c00151ad:	8b 44 24 04          	mov    0x4(%esp),%eax
c00151b1:	8b 40 08             	mov    0x8(%eax),%eax
c00151b4:	89 43 44             	mov    %eax,0x44(%ebx)
        rsi = regs->REG(si);
c00151b7:	8b 44 24 04          	mov    0x4(%esp),%eax
c00151bb:	8b 40 04             	mov    0x4(%eax),%eax
c00151be:	89 43 48             	mov    %eax,0x48(%ebx)
        rdi = regs->REG(di);
c00151c1:	8b 44 24 04          	mov    0x4(%esp),%eax
c00151c5:	8b 00                	mov    (%eax),%eax
c00151c7:	89 43 4c             	mov    %eax,0x4c(%ebx)
        r14 = regs->r14;
        r15 = regs->r15;
    }
#endif

    if (m & Mtd::RSP)
c00151ca:	f6 04 24 04          	testb  $0x4,(%esp)
c00151ce:	74 09                	je     c00151d9 <_ZN4Utcb8load_svmEP8Cpu_regs+0x67>
        rsp = static_cast<mword>(vmcb->rsp);
c00151d0:	8b 85 d8 05 00 00    	mov    0x5d8(%ebp),%eax
c00151d6:	89 43 40             	mov    %eax,0x40(%ebx)

    if (m & Mtd::RIP_LEN)
c00151d9:	f6 04 24 08          	testb  $0x8,(%esp)
c00151dd:	74 09                	je     c00151e8 <_ZN4Utcb8load_svmEP8Cpu_regs+0x76>
        rip = static_cast<mword>(vmcb->rip);
c00151df:	8b 85 78 05 00 00    	mov    0x578(%ebp),%eax
c00151e5:	89 43 18             	mov    %eax,0x18(%ebx)

    if (m & Mtd::RFLAGS)
c00151e8:	f6 04 24 10          	testb  $0x10,(%esp)
c00151ec:	74 09                	je     c00151f7 <_ZN4Utcb8load_svmEP8Cpu_regs+0x85>
        rflags = static_cast<mword>(vmcb->rflags);
c00151ee:	8b 85 70 05 00 00    	mov    0x570(%ebp),%eax
c00151f4:	89 43 1c             	mov    %eax,0x1c(%ebx)

    if (m & Mtd::DS_ES) {
c00151f7:	f6 04 24 20          	testb  $0x20,(%esp)
c00151fb:	74 23                	je     c0015220 <_ZN4Utcb8load_svmEP8Cpu_regs+0xae>
        ds = vmcb->ds;
c00151fd:	8d bb d0 00 00 00    	lea    0xd0(%ebx),%edi
c0015203:	b9 04 00 00 00       	mov    $0x4,%ecx
c0015208:	8d b5 30 04 00 00    	lea    0x430(%ebp),%esi
c001520e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
        es = vmcb->es;
c0015210:	8d bb a0 00 00 00    	lea    0xa0(%ebx),%edi
c0015216:	8d b5 00 04 00 00    	lea    0x400(%ebp),%esi
c001521c:	b1 04                	mov    $0x4,%cl
c001521e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    }

    if (m & Mtd::FS_GS) {
c0015220:	f6 04 24 40          	testb  $0x40,(%esp)
c0015224:	74 23                	je     c0015249 <_ZN4Utcb8load_svmEP8Cpu_regs+0xd7>
        fs = vmcb->fs;
c0015226:	8d bb e0 00 00 00    	lea    0xe0(%ebx),%edi
c001522c:	b9 04 00 00 00       	mov    $0x4,%ecx
c0015231:	8d b5 40 04 00 00    	lea    0x440(%ebp),%esi
c0015237:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
        gs = vmcb->gs;
c0015239:	8d bb f0 00 00 00    	lea    0xf0(%ebx),%edi
c001523f:	8d b5 50 04 00 00    	lea    0x450(%ebp),%esi
c0015245:	b1 04                	mov    $0x4,%cl
c0015247:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    }

    if (m & Mtd::CS_SS) {
c0015249:	f6 04 24 80          	testb  $0x80,(%esp)
c001524d:	74 23                	je     c0015272 <_ZN4Utcb8load_svmEP8Cpu_regs+0x100>
        cs = vmcb->cs;
c001524f:	8d bb b0 00 00 00    	lea    0xb0(%ebx),%edi
c0015255:	b9 04 00 00 00       	mov    $0x4,%ecx
c001525a:	8d b5 10 04 00 00    	lea    0x410(%ebp),%esi
c0015260:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
        ss = vmcb->ss;
c0015262:	8d bb c0 00 00 00    	lea    0xc0(%ebx),%edi
c0015268:	8d b5 20 04 00 00    	lea    0x420(%ebp),%esi
c001526e:	b1 04                	mov    $0x4,%cl
c0015270:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    }

    if (m & Mtd::TR)
c0015272:	f7 04 24 00 01 00 00 	testl  $0x100,(%esp)
c0015279:	74 13                	je     c001528e <_ZN4Utcb8load_svmEP8Cpu_regs+0x11c>
        tr = vmcb->tr;
c001527b:	8d bb 10 01 00 00    	lea    0x110(%ebx),%edi
c0015281:	b9 04 00 00 00       	mov    $0x4,%ecx
c0015286:	8d b5 90 04 00 00    	lea    0x490(%ebp),%esi
c001528c:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)

    if (m & Mtd::LDTR)
c001528e:	f7 04 24 00 02 00 00 	testl  $0x200,(%esp)
c0015295:	74 13                	je     c00152aa <_ZN4Utcb8load_svmEP8Cpu_regs+0x138>
        ld = vmcb->ldtr;
c0015297:	8d bb 00 01 00 00    	lea    0x100(%ebx),%edi
c001529d:	b9 04 00 00 00       	mov    $0x4,%ecx
c00152a2:	8d b5 70 04 00 00    	lea    0x470(%ebp),%esi
c00152a8:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)

    if (m & Mtd::GDTR)
c00152aa:	f7 04 24 00 04 00 00 	testl  $0x400,(%esp)
c00152b1:	74 13                	je     c00152c6 <_ZN4Utcb8load_svmEP8Cpu_regs+0x154>
        gd = vmcb->gdtr;
c00152b3:	8d bb 20 01 00 00    	lea    0x120(%ebx),%edi
c00152b9:	b9 04 00 00 00       	mov    $0x4,%ecx
c00152be:	8d b5 60 04 00 00    	lea    0x460(%ebp),%esi
c00152c4:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)

    if (m & Mtd::IDTR)
c00152c6:	f7 04 24 00 08 00 00 	testl  $0x800,(%esp)
c00152cd:	74 13                	je     c00152e2 <_ZN4Utcb8load_svmEP8Cpu_regs+0x170>
        id = vmcb->idtr;
c00152cf:	8d bb 30 01 00 00    	lea    0x130(%ebx),%edi
c00152d5:	b9 04 00 00 00       	mov    $0x4,%ecx
c00152da:	8d b5 80 04 00 00    	lea    0x480(%ebp),%esi
c00152e0:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)

    if (m & Mtd::CR) {
c00152e2:	f7 04 24 00 10 00 00 	testl  $0x1000,(%esp)
c00152e9:	74 41                	je     c001532c <_ZN4Utcb8load_svmEP8Cpu_regs+0x1ba>
        cr0 = regs->read_cr<Vmcb> (0);
c00152eb:	8b 44 24 04          	mov    0x4(%esp),%eax
c00152ef:	31 d2                	xor    %edx,%edx
c00152f1:	e8 6a 9b ff ff       	call   c000ee60 <_ZNK8Exc_regs7read_crI4VmcbEEmj>
        cr2 = regs->read_cr<Vmcb> (2);
c00152f6:	ba 02 00 00 00       	mov    $0x2,%edx

    if (m & Mtd::IDTR)
        id = vmcb->idtr;

    if (m & Mtd::CR) {
        cr0 = regs->read_cr<Vmcb> (0);
c00152fb:	89 43 70             	mov    %eax,0x70(%ebx)
        cr2 = regs->read_cr<Vmcb> (2);
c00152fe:	8b 44 24 04          	mov    0x4(%esp),%eax
c0015302:	e8 59 9b ff ff       	call   c000ee60 <_ZNK8Exc_regs7read_crI4VmcbEEmj>
        cr3 = regs->read_cr<Vmcb> (3);
c0015307:	ba 03 00 00 00       	mov    $0x3,%edx
    if (m & Mtd::IDTR)
        id = vmcb->idtr;

    if (m & Mtd::CR) {
        cr0 = regs->read_cr<Vmcb> (0);
        cr2 = regs->read_cr<Vmcb> (2);
c001530c:	89 43 74             	mov    %eax,0x74(%ebx)
        cr3 = regs->read_cr<Vmcb> (3);
c001530f:	8b 44 24 04          	mov    0x4(%esp),%eax
c0015313:	e8 48 9b ff ff       	call   c000ee60 <_ZNK8Exc_regs7read_crI4VmcbEEmj>
        cr4 = regs->read_cr<Vmcb> (4);
c0015318:	ba 04 00 00 00       	mov    $0x4,%edx
        id = vmcb->idtr;

    if (m & Mtd::CR) {
        cr0 = regs->read_cr<Vmcb> (0);
        cr2 = regs->read_cr<Vmcb> (2);
        cr3 = regs->read_cr<Vmcb> (3);
c001531d:	89 43 78             	mov    %eax,0x78(%ebx)
        cr4 = regs->read_cr<Vmcb> (4);
c0015320:	8b 44 24 04          	mov    0x4(%esp),%eax
c0015324:	e8 37 9b ff ff       	call   c000ee60 <_ZNK8Exc_regs7read_crI4VmcbEEmj>
c0015329:	89 43 7c             	mov    %eax,0x7c(%ebx)
    }

    if (m & Mtd::DR)
c001532c:	f7 04 24 00 20 00 00 	testl  $0x2000,(%esp)
c0015333:	74 0c                	je     c0015341 <_ZN4Utcb8load_svmEP8Cpu_regs+0x1cf>
        dr7 = static_cast<mword>(vmcb->dr7);
c0015335:	8b 85 60 05 00 00    	mov    0x560(%ebp),%eax
c001533b:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)

    if (m & Mtd::SYSENTER) {
c0015341:	f7 04 24 00 40 00 00 	testl  $0x4000,(%esp)
c0015348:	74 24                	je     c001536e <_ZN4Utcb8load_svmEP8Cpu_regs+0x1fc>
        sysenter_cs  = static_cast<mword>(vmcb->sysenter_cs);
c001534a:	8b 85 28 06 00 00    	mov    0x628(%ebp),%eax
c0015350:	89 83 94 00 00 00    	mov    %eax,0x94(%ebx)
        sysenter_rsp = static_cast<mword>(vmcb->sysenter_esp);
c0015356:	8b 85 30 06 00 00    	mov    0x630(%ebp),%eax
c001535c:	89 83 98 00 00 00    	mov    %eax,0x98(%ebx)
        sysenter_rip = static_cast<mword>(vmcb->sysenter_eip);
c0015362:	8b 85 38 06 00 00    	mov    0x638(%ebp),%eax
c0015368:	89 83 9c 00 00 00    	mov    %eax,0x9c(%ebx)
    }

    if (m & Mtd::QUAL) {
c001536e:	f7 04 24 00 80 00 00 	testl  $0x8000,(%esp)
c0015375:	74 4b                	je     c00153c2 <_ZN4Utcb8load_svmEP8Cpu_regs+0x250>
        if (regs->dst_portal == NUM_VMI - 4) {
c0015377:	8b 44 24 04          	mov    0x4(%esp),%eax
c001537b:	81 78 34 fc 00 00 00 	cmpl   $0xfc,0x34(%eax)
c0015382:	75 20                	jne    c00153a4 <_ZN4Utcb8load_svmEP8Cpu_regs+0x232>
            qual[0] = regs->nst_error;
c0015384:	8b 40 3c             	mov    0x3c(%eax),%eax
c0015387:	c7 43 54 00 00 00 00 	movl   $0x0,0x54(%ebx)
c001538e:	89 43 50             	mov    %eax,0x50(%ebx)
            qual[1] = regs->nst_fault;
c0015391:	8b 44 24 04          	mov    0x4(%esp),%eax
c0015395:	8b 40 38             	mov    0x38(%eax),%eax
c0015398:	c7 43 5c 00 00 00 00 	movl   $0x0,0x5c(%ebx)
c001539f:	89 43 58             	mov    %eax,0x58(%ebx)
c00153a2:	eb 1e                	jmp    c00153c2 <_ZN4Utcb8load_svmEP8Cpu_regs+0x250>
        } else {
            qual[0] = vmcb->exitinfo1;
c00153a4:	8b 45 78             	mov    0x78(%ebp),%eax
c00153a7:	8b 55 7c             	mov    0x7c(%ebp),%edx
c00153aa:	89 43 50             	mov    %eax,0x50(%ebx)
c00153ad:	89 53 54             	mov    %edx,0x54(%ebx)
            qual[1] = vmcb->exitinfo2;
c00153b0:	8b 85 80 00 00 00    	mov    0x80(%ebp),%eax
c00153b6:	8b 95 84 00 00 00    	mov    0x84(%ebp),%edx
c00153bc:	89 43 58             	mov    %eax,0x58(%ebx)
c00153bf:	89 53 5c             	mov    %edx,0x5c(%ebx)
        }
    }

    if (m & Mtd::INJ) {
c00153c2:	f7 04 24 00 00 02 00 	testl  $0x20000,(%esp)
c00153c9:	74 35                	je     c0015400 <_ZN4Utcb8load_svmEP8Cpu_regs+0x28e>
        if (regs->dst_portal == NUM_VMI - 3 || regs->dst_portal == NUM_VMI - 1)
c00153cb:	8b 44 24 04          	mov    0x4(%esp),%eax
c00153cf:	8b 40 34             	mov    0x34(%eax),%eax
c00153d2:	89 44 24 08          	mov    %eax,0x8(%esp)
c00153d6:	83 e0 fd             	and    $0xfffffffd,%eax
c00153d9:	3d fd 00 00 00       	cmp    $0xfd,%eax
c00153de:	75 0e                	jne    c00153ee <_ZN4Utcb8load_svmEP8Cpu_regs+0x27c>
            inj = vmcb->inj_control;
c00153e0:	8b 85 a8 00 00 00    	mov    0xa8(%ebp),%eax
c00153e6:	8b 95 ac 00 00 00    	mov    0xac(%ebp),%edx
c00153ec:	eb 0c                	jmp    c00153fa <_ZN4Utcb8load_svmEP8Cpu_regs+0x288>
        else
            inj = vmcb->exitintinfo;
c00153ee:	8b 85 88 00 00 00    	mov    0x88(%ebp),%eax
c00153f4:	8b 95 8c 00 00 00    	mov    0x8c(%ebp),%edx
c00153fa:	89 43 28             	mov    %eax,0x28(%ebx)
c00153fd:	89 53 2c             	mov    %edx,0x2c(%ebx)
    }

    if (m & Mtd::STA) {
c0015400:	f7 04 24 00 00 04 00 	testl  $0x40000,(%esp)
c0015407:	74 0d                	je     c0015416 <_ZN4Utcb8load_svmEP8Cpu_regs+0x2a4>
        intr_state = static_cast<uint32>(vmcb->int_shadow);
c0015409:	8b 45 68             	mov    0x68(%ebp),%eax
        actv_state = 0;
c001540c:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
        else
            inj = vmcb->exitintinfo;
    }

    if (m & Mtd::STA) {
        intr_state = static_cast<uint32>(vmcb->int_shadow);
c0015413:	89 43 20             	mov    %eax,0x20(%ebx)
        actv_state = 0;
    }

    if (m & Mtd::TSC) {
c0015416:	f7 04 24 00 00 08 00 	testl  $0x80000,(%esp)
c001541d:	74 24                	je     c0015443 <_ZN4Utcb8load_svmEP8Cpu_regs+0x2d1>

ALWAYS_INLINE
static inline uint64 rdtsc()
{
    mword h, l;
    asm volatile ("rdtsc" : "=a" (l), "=d" (h));
c001541f:	0f 31                	rdtsc  
    return static_cast<uint64>(h) << 32 | l;
c0015421:	89 83 40 01 00 00    	mov    %eax,0x140(%ebx)
        tsc_val = rdtsc();
        tsc_off = regs->tsc_offset;
c0015427:	8b 44 24 04          	mov    0x4(%esp),%eax
c001542b:	89 93 44 01 00 00    	mov    %edx,0x144(%ebx)
c0015431:	8b 50 54             	mov    0x54(%eax),%edx
c0015434:	8b 40 50             	mov    0x50(%eax),%eax
c0015437:	89 93 4c 01 00 00    	mov    %edx,0x14c(%ebx)
c001543d:	89 83 48 01 00 00    	mov    %eax,0x148(%ebx)
    if (m & Mtd::EFER)
        efer = vmcb->efer;
#endif

    barrier();
    mtd = m;
c0015443:	8b 04 24             	mov    (%esp),%eax
    items = sizeof (Utcb_data) / sizeof (mword);
c0015446:	c7 03 50 00 00 00    	movl   $0x50,(%ebx)
    if (m & Mtd::EFER)
        efer = vmcb->efer;
#endif

    barrier();
    mtd = m;
c001544c:	89 43 10             	mov    %eax,0x10(%ebx)
    items = sizeof (Utcb_data) / sizeof (mword);

    return m & Mtd::FPU;
}
c001544f:	83 c4 0c             	add    $0xc,%esp
c0015452:	5b                   	pop    %ebx

    barrier();
    mtd = m;
    items = sizeof (Utcb_data) / sizeof (mword);

    return m & Mtd::FPU;
c0015453:	c1 e8 1f             	shr    $0x1f,%eax
}
c0015456:	5e                   	pop    %esi
c0015457:	5f                   	pop    %edi
c0015458:	5d                   	pop    %ebp
c0015459:	c3                   	ret    

c001545a <_ZN4Utcb8save_svmEP8Cpu_regs>:

bool Utcb::save_svm (Cpu_regs *regs)
{
c001545a:	55                   	push   %ebp
c001545b:	57                   	push   %edi
c001545c:	56                   	push   %esi
c001545d:	53                   	push   %ebx
c001545e:	89 c3                	mov    %eax,%ebx
c0015460:	51                   	push   %ecx
    Vmcb * const vmcb = regs->vmcb;

    if (mtd & Mtd::GPR_ACDB) {
c0015461:	f6 43 10 01          	testb  $0x1,0x10(%ebx)

    return m & Mtd::FPU;
}

bool Utcb::save_svm (Cpu_regs *regs)
{
c0015465:	89 14 24             	mov    %edx,(%esp)
    Vmcb * const vmcb = regs->vmcb;
c0015468:	8b 6a 20             	mov    0x20(%edx),%ebp

    if (mtd & Mtd::GPR_ACDB) {
c001546b:	74 25                	je     c0015492 <_ZN4Utcb8save_svmEP8Cpu_regs+0x38>
        vmcb->rax = rax;
c001546d:	8b 43 30             	mov    0x30(%ebx),%eax
c0015470:	c7 85 fc 05 00 00 00 	movl   $0x0,0x5fc(%ebp)
c0015477:	00 00 00 
c001547a:	89 85 f8 05 00 00    	mov    %eax,0x5f8(%ebp)
        regs->REG(cx) = rcx;
c0015480:	8b 43 34             	mov    0x34(%ebx),%eax
c0015483:	89 42 18             	mov    %eax,0x18(%edx)
        regs->REG(dx) = rdx;
c0015486:	8b 43 38             	mov    0x38(%ebx),%eax
c0015489:	89 42 14             	mov    %eax,0x14(%edx)
        regs->REG(bx) = rbx;
c001548c:	8b 43 3c             	mov    0x3c(%ebx),%eax
c001548f:	89 42 10             	mov    %eax,0x10(%edx)
    }

    if (mtd & Mtd::GPR_BSD) {
c0015492:	f6 43 10 02          	testb  $0x2,0x10(%ebx)
c0015496:	74 14                	je     c00154ac <_ZN4Utcb8save_svmEP8Cpu_regs+0x52>
        regs->REG(bp) = rbp;
c0015498:	8b 43 44             	mov    0x44(%ebx),%eax
c001549b:	8b 14 24             	mov    (%esp),%edx
c001549e:	89 42 08             	mov    %eax,0x8(%edx)
        regs->REG(si) = rsi;
c00154a1:	8b 43 48             	mov    0x48(%ebx),%eax
c00154a4:	89 42 04             	mov    %eax,0x4(%edx)
        regs->REG(di) = rdi;
c00154a7:	8b 43 4c             	mov    0x4c(%ebx),%eax
c00154aa:	89 02                	mov    %eax,(%edx)
        regs->r14     = r14;
        regs->r15     = r15;
    }
#endif

    if (mtd & Mtd::RSP)
c00154ac:	f6 43 10 04          	testb  $0x4,0x10(%ebx)
c00154b0:	74 13                	je     c00154c5 <_ZN4Utcb8save_svmEP8Cpu_regs+0x6b>
        vmcb->rsp = rsp;
c00154b2:	8b 43 40             	mov    0x40(%ebx),%eax
c00154b5:	c7 85 dc 05 00 00 00 	movl   $0x0,0x5dc(%ebp)
c00154bc:	00 00 00 
c00154bf:	89 85 d8 05 00 00    	mov    %eax,0x5d8(%ebp)

    if (mtd & Mtd::RIP_LEN)
c00154c5:	f6 43 10 08          	testb  $0x8,0x10(%ebx)
c00154c9:	74 13                	je     c00154de <_ZN4Utcb8save_svmEP8Cpu_regs+0x84>
        vmcb->rip = rip;
c00154cb:	8b 43 18             	mov    0x18(%ebx),%eax
c00154ce:	c7 85 7c 05 00 00 00 	movl   $0x0,0x57c(%ebp)
c00154d5:	00 00 00 
c00154d8:	89 85 78 05 00 00    	mov    %eax,0x578(%ebp)

    if (mtd & Mtd::RFLAGS)
c00154de:	f6 43 10 10          	testb  $0x10,0x10(%ebx)
c00154e2:	74 13                	je     c00154f7 <_ZN4Utcb8save_svmEP8Cpu_regs+0x9d>
        vmcb->rflags = rflags;
c00154e4:	8b 43 1c             	mov    0x1c(%ebx),%eax
c00154e7:	c7 85 74 05 00 00 00 	movl   $0x0,0x574(%ebp)
c00154ee:	00 00 00 
c00154f1:	89 85 70 05 00 00    	mov    %eax,0x570(%ebp)

    if (mtd & Mtd::DS_ES) {
c00154f7:	f6 43 10 20          	testb  $0x20,0x10(%ebx)
c00154fb:	74 23                	je     c0015520 <_ZN4Utcb8save_svmEP8Cpu_regs+0xc6>
        vmcb->ds = ds;
c00154fd:	8d bd 30 04 00 00    	lea    0x430(%ebp),%edi
c0015503:	b9 04 00 00 00       	mov    $0x4,%ecx
c0015508:	8d b3 d0 00 00 00    	lea    0xd0(%ebx),%esi
c001550e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
        vmcb->es = es;
c0015510:	8d bd 00 04 00 00    	lea    0x400(%ebp),%edi
c0015516:	8d b3 a0 00 00 00    	lea    0xa0(%ebx),%esi
c001551c:	b1 04                	mov    $0x4,%cl
c001551e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    }

    if (mtd & Mtd::FS_GS) {
c0015520:	f6 43 10 40          	testb  $0x40,0x10(%ebx)
c0015524:	74 23                	je     c0015549 <_ZN4Utcb8save_svmEP8Cpu_regs+0xef>
        vmcb->fs = fs;
c0015526:	8d bd 40 04 00 00    	lea    0x440(%ebp),%edi
c001552c:	b9 04 00 00 00       	mov    $0x4,%ecx
c0015531:	8d b3 e0 00 00 00    	lea    0xe0(%ebx),%esi
c0015537:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
        vmcb->gs = gs;
c0015539:	8d bd 50 04 00 00    	lea    0x450(%ebp),%edi
c001553f:	8d b3 f0 00 00 00    	lea    0xf0(%ebx),%esi
c0015545:	b1 04                	mov    $0x4,%cl
c0015547:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    }

    if (mtd & Mtd::CS_SS) {
c0015549:	f6 43 10 80          	testb  $0x80,0x10(%ebx)
c001554d:	74 23                	je     c0015572 <_ZN4Utcb8save_svmEP8Cpu_regs+0x118>
        vmcb->cs = cs;
c001554f:	8d bd 10 04 00 00    	lea    0x410(%ebp),%edi
c0015555:	b9 04 00 00 00       	mov    $0x4,%ecx
c001555a:	8d b3 b0 00 00 00    	lea    0xb0(%ebx),%esi
c0015560:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
        vmcb->ss = ss;
c0015562:	8d bd 20 04 00 00    	lea    0x420(%ebp),%edi
c0015568:	8d b3 c0 00 00 00    	lea    0xc0(%ebx),%esi
c001556e:	b1 04                	mov    $0x4,%cl
c0015570:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    }

    if (mtd & Mtd::TR)
c0015572:	f6 43 11 01          	testb  $0x1,0x11(%ebx)
c0015576:	74 13                	je     c001558b <_ZN4Utcb8save_svmEP8Cpu_regs+0x131>
        vmcb->tr = tr;
c0015578:	8d bd 90 04 00 00    	lea    0x490(%ebp),%edi
c001557e:	b9 04 00 00 00       	mov    $0x4,%ecx
c0015583:	8d b3 10 01 00 00    	lea    0x110(%ebx),%esi
c0015589:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)

    if (mtd & Mtd::LDTR)
c001558b:	f6 43 11 02          	testb  $0x2,0x11(%ebx)
c001558f:	74 13                	je     c00155a4 <_ZN4Utcb8save_svmEP8Cpu_regs+0x14a>
        vmcb->ldtr = ld;
c0015591:	8d bd 70 04 00 00    	lea    0x470(%ebp),%edi
c0015597:	b9 04 00 00 00       	mov    $0x4,%ecx
c001559c:	8d b3 00 01 00 00    	lea    0x100(%ebx),%esi
c00155a2:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)

    if (mtd & Mtd::GDTR)
c00155a4:	f6 43 11 04          	testb  $0x4,0x11(%ebx)
c00155a8:	74 13                	je     c00155bd <_ZN4Utcb8save_svmEP8Cpu_regs+0x163>
        vmcb->gdtr = gd;
c00155aa:	8d bd 60 04 00 00    	lea    0x460(%ebp),%edi
c00155b0:	b9 04 00 00 00       	mov    $0x4,%ecx
c00155b5:	8d b3 20 01 00 00    	lea    0x120(%ebx),%esi
c00155bb:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)

    if (mtd & Mtd::IDTR)
c00155bd:	f6 43 11 08          	testb  $0x8,0x11(%ebx)
c00155c1:	74 13                	je     c00155d6 <_ZN4Utcb8save_svmEP8Cpu_regs+0x17c>
        vmcb->idtr = id;
c00155c3:	8d bd 80 04 00 00    	lea    0x480(%ebp),%edi
c00155c9:	b9 04 00 00 00       	mov    $0x4,%ecx
c00155ce:	8d b3 30 01 00 00    	lea    0x130(%ebx),%esi
c00155d4:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)

    if (mtd & Mtd::CR) {
c00155d6:	f6 43 11 10          	testb  $0x10,0x11(%ebx)
c00155da:	74 3d                	je     c0015619 <_ZN4Utcb8save_svmEP8Cpu_regs+0x1bf>
        regs->write_cr<Vmcb> (0, cr0);
c00155dc:	8b 4b 70             	mov    0x70(%ebx),%ecx
c00155df:	31 d2                	xor    %edx,%edx
c00155e1:	8b 04 24             	mov    (%esp),%eax
c00155e4:	e8 bb 99 ff ff       	call   c000efa4 <_ZN8Exc_regs8write_crI4VmcbEEvjm>
        regs->write_cr<Vmcb> (2, cr2);
c00155e9:	8b 4b 74             	mov    0x74(%ebx),%ecx
c00155ec:	ba 02 00 00 00       	mov    $0x2,%edx
c00155f1:	8b 04 24             	mov    (%esp),%eax
c00155f4:	e8 ab 99 ff ff       	call   c000efa4 <_ZN8Exc_regs8write_crI4VmcbEEvjm>
        regs->write_cr<Vmcb> (3, cr3);
c00155f9:	8b 4b 78             	mov    0x78(%ebx),%ecx
c00155fc:	ba 03 00 00 00       	mov    $0x3,%edx
c0015601:	8b 04 24             	mov    (%esp),%eax
c0015604:	e8 9b 99 ff ff       	call   c000efa4 <_ZN8Exc_regs8write_crI4VmcbEEvjm>
        regs->write_cr<Vmcb> (4, cr4);
c0015609:	8b 4b 7c             	mov    0x7c(%ebx),%ecx
c001560c:	ba 04 00 00 00       	mov    $0x4,%edx
c0015611:	8b 04 24             	mov    (%esp),%eax
c0015614:	e8 8b 99 ff ff       	call   c000efa4 <_ZN8Exc_regs8write_crI4VmcbEEvjm>
    }

    if (mtd & Mtd::DR)
c0015619:	f6 43 11 20          	testb  $0x20,0x11(%ebx)
c001561d:	74 16                	je     c0015635 <_ZN4Utcb8save_svmEP8Cpu_regs+0x1db>
        vmcb->dr7 = dr7;
c001561f:	8b 83 90 00 00 00    	mov    0x90(%ebx),%eax
c0015625:	c7 85 64 05 00 00 00 	movl   $0x0,0x564(%ebp)
c001562c:	00 00 00 
c001562f:	89 85 60 05 00 00    	mov    %eax,0x560(%ebp)

    if (mtd & Mtd::SYSENTER) {
c0015635:	f6 43 11 40          	testb  $0x40,0x11(%ebx)
c0015639:	74 42                	je     c001567d <_ZN4Utcb8save_svmEP8Cpu_regs+0x223>
        vmcb->sysenter_cs  = sysenter_cs;
c001563b:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
c0015641:	c7 85 2c 06 00 00 00 	movl   $0x0,0x62c(%ebp)
c0015648:	00 00 00 
c001564b:	89 85 28 06 00 00    	mov    %eax,0x628(%ebp)
        vmcb->sysenter_esp = sysenter_rsp;
c0015651:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
c0015657:	c7 85 34 06 00 00 00 	movl   $0x0,0x634(%ebp)
c001565e:	00 00 00 
c0015661:	89 85 30 06 00 00    	mov    %eax,0x630(%ebp)
        vmcb->sysenter_eip = sysenter_rip;
c0015667:	8b 83 9c 00 00 00    	mov    0x9c(%ebx),%eax
c001566d:	c7 85 3c 06 00 00 00 	movl   $0x0,0x63c(%ebp)
c0015674:	00 00 00 
c0015677:	89 85 38 06 00 00    	mov    %eax,0x638(%ebp)
    }

    if (mtd & Mtd::CTRL) {
c001567d:	f6 43 12 01          	testb  $0x1,0x12(%ebx)
c0015681:	74 16                	je     c0015699 <_ZN4Utcb8save_svmEP8Cpu_regs+0x23f>
        regs->svm_set_cpu_ctrl0 (ctrl[0]);
c0015683:	8b 53 60             	mov    0x60(%ebx),%edx
c0015686:	8b 04 24             	mov    (%esp),%eax
c0015689:	e8 0c 8f ff ff       	call   c000e59a <_ZN8Exc_regs17svm_set_cpu_ctrl0Em>
        regs->svm_set_cpu_ctrl1 (ctrl[1]);
c001568e:	8b 53 64             	mov    0x64(%ebx),%edx
c0015691:	8b 04 24             	mov    (%esp),%eax
c0015694:	e8 95 8f ff ff       	call   c000e62e <_ZN8Exc_regs17svm_set_cpu_ctrl1Em>
    }

    if (mtd & Mtd::INJ) {
c0015699:	f6 43 12 02          	testb  $0x2,0x12(%ebx)
c001569d:	74 3e                	je     c00156dd <_ZN4Utcb8save_svmEP8Cpu_regs+0x283>

        if (intr_info & 0x1000) {
c001569f:	f6 43 29 10          	testb  $0x10,0x29(%ebx)
c00156a3:	74 11                	je     c00156b6 <_ZN4Utcb8save_svmEP8Cpu_regs+0x25c>
            vmcb->int_control      |=  (1ul << 8 | 1ul << 20);
c00156a5:	81 4d 60 00 01 10 00 	orl    $0x100100,0x60(%ebp)
c00156ac:	83 4d 64 00          	orl    $0x0,0x64(%ebp)
            vmcb->intercept_cpu[0] |=  Vmcb::CPU_VINTR;
c00156b0:	83 4d 0c 10          	orl    $0x10,0xc(%ebp)
c00156b4:	eb 12                	jmp    c00156c8 <_ZN4Utcb8save_svmEP8Cpu_regs+0x26e>
        } else {
            vmcb->int_control      &= ~(1ul << 8 | 1ul << 20);
c00156b6:	81 65 60 ff fe ef ff 	andl   $0xffeffeff,0x60(%ebp)
            vmcb->intercept_cpu[0] &= ~Vmcb::CPU_VINTR;
c00156bd:	83 65 0c ef          	andl   $0xffffffef,0xc(%ebp)

        if (intr_info & 0x1000) {
            vmcb->int_control      |=  (1ul << 8 | 1ul << 20);
            vmcb->intercept_cpu[0] |=  Vmcb::CPU_VINTR;
        } else {
            vmcb->int_control      &= ~(1ul << 8 | 1ul << 20);
c00156c1:	c7 45 64 00 00 00 00 	movl   $0x0,0x64(%ebp)
            vmcb->intercept_cpu[0] &= ~Vmcb::CPU_VINTR;
        }

        vmcb->inj_control = inj & ~0x3000;
c00156c8:	8b 43 28             	mov    0x28(%ebx),%eax
c00156cb:	80 e4 cf             	and    $0xcf,%ah
c00156ce:	89 85 a8 00 00 00    	mov    %eax,0xa8(%ebp)
c00156d4:	8b 43 2c             	mov    0x2c(%ebx),%eax
c00156d7:	89 85 ac 00 00 00    	mov    %eax,0xac(%ebp)
    }

    if (mtd & Mtd::STA)
c00156dd:	f6 43 12 04          	testb  $0x4,0x12(%ebx)
c00156e1:	74 0d                	je     c00156f0 <_ZN4Utcb8save_svmEP8Cpu_regs+0x296>
        vmcb->int_shadow = intr_state;
c00156e3:	8b 43 20             	mov    0x20(%ebx),%eax
c00156e6:	c7 45 6c 00 00 00 00 	movl   $0x0,0x6c(%ebp)
c00156ed:	89 45 68             	mov    %eax,0x68(%ebp)

    if (mtd & Mtd::TSC)
c00156f0:	f6 43 12 08          	testb  $0x8,0x12(%ebx)
c00156f4:	74 1d                	je     c0015713 <_ZN4Utcb8save_svmEP8Cpu_regs+0x2b9>
c00156f6:	8b 3c 24             	mov    (%esp),%edi
c00156f9:	8b 83 48 01 00 00    	mov    0x148(%ebx),%eax
c00156ff:	8b 93 4c 01 00 00    	mov    0x14c(%ebx),%edx
c0015705:	01 47 50             	add    %eax,0x50(%edi)
c0015708:	11 57 54             	adc    %edx,0x54(%edi)
c001570b:	f0 81 4f 4c 00 00 00 	lock orl $0x20000000,0x4c(%edi)
c0015712:	20 
#ifdef __x86_64__
    if (mtd & Mtd::EFER)
        regs->write_efer<Vmcb> (efer);
#endif

    return mtd & Mtd::FPU;
c0015713:	8b 43 10             	mov    0x10(%ebx),%eax
}
c0015716:	5a                   	pop    %edx
c0015717:	5b                   	pop    %ebx
#ifdef __x86_64__
    if (mtd & Mtd::EFER)
        regs->write_efer<Vmcb> (efer);
#endif

    return mtd & Mtd::FPU;
c0015718:	c1 e8 1f             	shr    $0x1f,%eax
}
c001571b:	5e                   	pop    %esi
c001571c:	5f                   	pop    %edi
c001571d:	5d                   	pop    %ebp
c001571e:	c3                   	ret    
c001571f:	90                   	nop

c0015720 <_ZN4VmcsC1Emmmy>:
Vmcs::vmx_ctrl_exi  Vmcs::ctrl_exi;
Vmcs::vmx_ctrl_ent  Vmcs::ctrl_ent;
mword               Vmcs::fix_cr0_set, Vmcs::fix_cr0_clr;
mword               Vmcs::fix_cr4_set, Vmcs::fix_cr4_clr;

Vmcs::Vmcs (mword esp, mword bmp, mword cr3, uint64 eptp) : rev (basic.revision)
c0015720:	55                   	push   %ebp
c0015721:	57                   	push   %edi
c0015722:	56                   	push   %esi
c0015723:	53                   	push   %ebx
c0015724:	83 ec 08             	sub    $0x8,%esp
c0015727:	8b 3d 68 fb ff cf    	mov    0xcffffb68,%edi
c001572d:	8b 5c 24 20          	mov    0x20(%esp),%ebx
c0015731:	8b 74 24 24          	mov    0x24(%esp),%esi
c0015735:	89 38                	mov    %edi,(%eax)
        }

        ALWAYS_INLINE
        inline void make_current()
        {
            if (EXPECT_TRUE (current == this))
c0015737:	39 05 14 f0 ff cf    	cmp    %eax,0xcffff014
c001573d:	74 3e                	je     c001577d <_ZN4VmcsC1Emmmy+0x5d>
                return;

            uint64 phys = Buddy::ptr_to_phys (current = this);
c001573f:	a3 14 f0 ff cf       	mov    %eax,0xcffff014
c0015744:	2d 00 00 c0 bf       	sub    $0xbfc00000,%eax
c0015749:	89 04 24             	mov    %eax,(%esp)
c001574c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0015753:	00 

            bool ret;
            asm volatile ("vmptrld %1; seta %0" : "=q" (ret) : "m" (phys) : "cc");
c0015754:	0f c7 34 24          	vmptrld (%esp)
c0015758:	0f 97 c0             	seta   %al
            assert (ret);
c001575b:	84 c0                	test   %al,%al
c001575d:	75 1e                	jne    c001577d <_ZN4VmcsC1Emmmy+0x5d>
c001575f:	68 00 9f 01 c0       	push   $0xc0019f00
c0015764:	68 96 01 00 00       	push   $0x196
c0015769:	68 13 69 01 c0       	push   $0xc0016913
c001576e:	68 83 69 01 c0       	push   $0xc0016983
c0015773:	68 69 60 01 c0       	push   $0xc0016069
c0015778:	e8 c9 c1 fe ff       	call   c0001946 <_ZN7Console5panicEPKcz>
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
c001577d:	31 ff                	xor    %edi,%edi
c001577f:	b8 06 40 00 00       	mov    $0x4006,%eax
c0015784:	0f 79 c7             	vmwrite %edi,%eax
c0015787:	b0 08                	mov    $0x8,%al
c0015789:	0f 79 c7             	vmwrite %edi,%eax
c001578c:	b0 0a                	mov    $0xa,%al
c001578e:	0f 79 c7             	vmwrite %edi,%eax
c0015791:	83 c8 ff             	or     $0xffffffff,%eax
c0015794:	bd 00 28 00 00       	mov    $0x2800,%ebp
c0015799:	0f 79 e8             	vmwrite %eax,%ebp
c001579c:	66 bd 01 28          	mov    $0x2801,%bp
c00157a0:	0f 79 e8             	vmwrite %eax,%ebp
    write (CR3_TARGET_COUNT, 0);

    write (VMCS_LINK_PTR,    ~0ul);
    write (VMCS_LINK_PTR_HI, ~0ul);

    write (VPID, ++vpid_ctr);
c00157a3:	a1 70 fb ff cf       	mov    0xcffffb70,%eax
c00157a8:	40                   	inc    %eax
c00157a9:	a3 70 fb ff cf       	mov    %eax,0xcffffb70
c00157ae:	0f 79 f8             	vmwrite %eax,%edi
c00157b1:	b8 1a 20 00 00       	mov    $0x201a,%eax

    write (EPTP,    static_cast<mword>(eptp) | (Ept::max() - 1) << 3 | 6);
c00157b6:	83 cb 1e             	or     $0x1e,%ebx
c00157b9:	0f 79 c3             	vmwrite %ebx,%eax
c00157bc:	b0 1b                	mov    $0x1b,%al
c00157be:	0f 79 c6             	vmwrite %esi,%eax
c00157c1:	30 c0                	xor    %al,%al
c00157c3:	0f 79 c1             	vmwrite %ecx,%eax
    write (EPTP_HI, static_cast<mword>(eptp >> 32));

    write (IO_BITMAP_A, bmp);
    write (IO_BITMAP_B, bmp + PAGE_SIZE);
c00157c6:	81 c1 00 10 00 00    	add    $0x1000,%ecx
c00157cc:	b0 02                	mov    $0x2,%al
c00157ce:	0f 79 c1             	vmwrite %ecx,%eax
c00157d1:	b9 08 00 00 00       	mov    $0x8,%ecx
c00157d6:	66 b8 02 0c          	mov    $0xc02,%ax
c00157da:	0f 79 c1             	vmwrite %ecx,%eax
c00157dd:	bb 04 0c 00 00       	mov    $0xc04,%ebx
c00157e2:	66 b8 10 00          	mov    $0x10,%ax
c00157e6:	0f 79 d8             	vmwrite %eax,%ebx
c00157e9:	b3 06                	mov    $0x6,%bl
c00157eb:	0f 79 d8             	vmwrite %eax,%ebx
c00157ee:	30 db                	xor    %bl,%bl
c00157f0:	0f 79 d8             	vmwrite %eax,%ebx
c00157f3:	b3 0c                	mov    $0xc,%bl
c00157f5:	b0 30                	mov    $0x30,%al
c00157f7:	0f 79 d8             	vmwrite %eax,%ebx
    write (HOST_EFER, Msr::read<uint64>(Msr::IA32_EFER));
    exi |= EXI_SAVE_EFER | EXI_LOAD_EFER | EXI_HOST_64;
    ent |= ENT_LOAD_EFER;
#endif

    write (PIN_CONTROLS, (pin | ctrl_pin.set) & ctrl_pin.clr);
c00157fa:	a1 58 fb ff cf       	mov    0xcffffb58,%eax
c00157ff:	66 bb 00 40          	mov    $0x4000,%bx
c0015803:	83 c8 29             	or     $0x29,%eax
c0015806:	23 05 5c fb ff cf    	and    0xcffffb5c,%eax
c001580c:	0f 79 d8             	vmwrite %eax,%ebx
    write (EXI_CONTROLS, (exi | ctrl_exi.set) & ctrl_exi.clr);
c001580f:	a1 40 fb ff cf       	mov    0xcffffb40,%eax
c0015814:	b3 0c                	mov    $0xc,%bl
c0015816:	80 cc 80             	or     $0x80,%ah
c0015819:	23 05 44 fb ff cf    	and    0xcffffb44,%eax
c001581f:	0f 79 d8             	vmwrite %eax,%ebx
    write (ENT_CONTROLS, (ent | ctrl_ent.set) & ctrl_ent.clr);
c0015822:	a1 3c fb ff cf       	mov    0xcffffb3c,%eax
c0015827:	b3 12                	mov    $0x12,%bl
c0015829:	23 05 38 fb ff cf    	and    0xcffffb38,%eax
c001582f:	0f 79 d8             	vmwrite %eax,%ebx
c0015832:	b8 02 6c 00 00       	mov    $0x6c02,%eax
c0015837:	0f 79 44 24 1c       	vmwrite 0x1c(%esp),%eax

ALWAYS_INLINE
static inline mword get_cr0()
{
    mword cr0;
    asm volatile ("mov %%cr0, %0" : "=r" (cr0));
c001583c:	0f 20 c0             	mov    %cr0,%eax

    write (HOST_CR3, cr3);
    write (HOST_CR0, get_cr0() | Cpu::CR0_TS);
c001583f:	83 c8 08             	or     $0x8,%eax
c0015842:	66 bb 00 6c          	mov    $0x6c00,%bx
c0015846:	0f 79 d8             	vmwrite %eax,%ebx

ALWAYS_INLINE
static inline mword get_cr4()
{
    mword cr4;
    asm volatile ("mov %%cr4, %0" : "=r" (cr4));
c0015849:	0f 20 e0             	mov    %cr4,%eax
c001584c:	b3 04                	mov    $0x4,%bl
c001584e:	0f 79 d8             	vmwrite %eax,%ebx
c0015851:	b8 c0 fa ff cf       	mov    $0xcffffac0,%eax
c0015856:	b3 0a                	mov    $0xa,%bl
c0015858:	0f 79 d8             	vmwrite %eax,%ebx
c001585b:	b8 80 f7 ff cf       	mov    $0xcffff780,%eax
c0015860:	b3 0c                	mov    $0xc,%bl
c0015862:	0f 79 d8             	vmwrite %eax,%ebx
c0015865:	b8 08 ab 01 c0       	mov    $0xc001ab08,%eax
c001586a:	b3 0e                	mov    $0xe,%bl
c001586c:	0f 79 d8             	vmwrite %eax,%ebx
c001586f:	b8 00 4c 00 00       	mov    $0x4c00,%eax
c0015874:	0f 79 c1             	vmwrite %ecx,%eax
c0015877:	b8 c4 fa ff cf       	mov    $0xcffffac4,%eax
c001587c:	66 b9 10 6c          	mov    $0x6c10,%cx
c0015880:	0f 79 c8             	vmwrite %eax,%ecx
c0015883:	b8 74 55 00 c0       	mov    $0xc0005574,%eax
c0015888:	b1 12                	mov    $0x12,%cl
c001588a:	0f 79 c8             	vmwrite %eax,%ecx
c001588d:	b8 14 6c 00 00       	mov    $0x6c14,%eax
c0015892:	0f 79 c2             	vmwrite %edx,%eax
c0015895:	ba 16 6c 00 00       	mov    $0x6c16,%edx
c001589a:	b8 8c 55 00 c0       	mov    $0xc000558c,%eax
c001589f:	0f 79 d0             	vmwrite %eax,%edx
    write (HOST_SYSENTER_ESP, reinterpret_cast<mword>(&Tss::run.sp0));
    write (HOST_SYSENTER_EIP, reinterpret_cast<mword>(&entry_sysenter));

    write (HOST_RSP, esp);
    write (HOST_RIP, reinterpret_cast<mword>(&entry_vmx));
}
c00158a2:	83 c4 08             	add    $0x8,%esp
c00158a5:	5b                   	pop    %ebx
c00158a6:	5e                   	pop    %esi
c00158a7:	5f                   	pop    %edi
c00158a8:	5d                   	pop    %ebp
c00158a9:	c3                   	ret    

c00158aa <_ZN4Vmcs4initEv>:

void Vmcs::init()
{
    if (!Cpu::feature (Cpu::FEAT_VMX) || (Msr::read<uint32>(Msr::IA32_FEATURE_CONTROL) & 0x5) != 0x5) {
c00158aa:	f6 05 08 f7 ff cf 20 	testb  $0x20,0xcffff708
c00158b1:	0f 84 02 02 00 00    	je     c0015ab9 <_ZN4Vmcs4initEv+0x20f>
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
c00158b7:	b9 3a 00 00 00       	mov    $0x3a,%ecx
c00158bc:	0f 32                	rdmsr  
c00158be:	83 e0 05             	and    $0x5,%eax
c00158c1:	83 f8 05             	cmp    $0x5,%eax
c00158c4:	0f 85 ef 01 00 00    	jne    c0015ab9 <_ZN4Vmcs4initEv+0x20f>
    write (HOST_RSP, esp);
    write (HOST_RIP, reinterpret_cast<mword>(&entry_vmx));
}

void Vmcs::init()
{
c00158ca:	55                   	push   %ebp
c00158cb:	b9 86 04 00 00       	mov    $0x486,%ecx
c00158d0:	57                   	push   %edi
c00158d1:	56                   	push   %esi
c00158d2:	53                   	push   %ebx
c00158d3:	83 ec 10             	sub    $0x10,%esp
c00158d6:	0f 32                	rdmsr  
c00158d8:	89 c6                	mov    %eax,%esi
c00158da:	b1 87                	mov    $0x87,%cl
    if (!Cpu::feature (Cpu::FEAT_VMX) || (Msr::read<uint32>(Msr::IA32_FEATURE_CONTROL) & 0x5) != 0x5) {
        Hip::clr_feature (Hip::FEAT_VMX);
        return;
    }

    fix_cr0_set =  Msr::read<mword>(Msr::IA32_VMX_CR0_FIXED0);
c00158dc:	a3 34 fb ff cf       	mov    %eax,0xcffffb34
c00158e1:	0f 32                	rdmsr  
    fix_cr0_clr = ~Msr::read<mword>(Msr::IA32_VMX_CR0_FIXED1);
c00158e3:	f7 d0                	not    %eax
c00158e5:	b1 88                	mov    $0x88,%cl
c00158e7:	89 44 24 04          	mov    %eax,0x4(%esp)
c00158eb:	0f 32                	rdmsr  
c00158ed:	89 c7                	mov    %eax,%edi
c00158ef:	b1 89                	mov    $0x89,%cl
    fix_cr4_set =  Msr::read<mword>(Msr::IA32_VMX_CR4_FIXED0);
c00158f1:	a3 2c fb ff cf       	mov    %eax,0xcffffb2c
c00158f6:	0f 32                	rdmsr  
c00158f8:	89 04 24             	mov    %eax,(%esp)
    fix_cr4_clr = ~Msr::read<mword>(Msr::IA32_VMX_CR4_FIXED1);
c00158fb:	f7 d0                	not    %eax
c00158fd:	b1 80                	mov    $0x80,%cl
c00158ff:	a3 28 fb ff cf       	mov    %eax,0xcffffb28
c0015904:	0f 32                	rdmsr  
            return static_cast<T>(static_cast<uint64>(h) << 32 | l);
c0015906:	89 15 6c fb ff cf    	mov    %edx,0xcffffb6c

    basic.val       = Msr::read<uint64>(Msr::IA32_VMX_BASIC);
    ctrl_exi.val    = Msr::read<uint64>(basic.ctrl ? Msr::IA32_VMX_TRUE_EXIT  : Msr::IA32_VMX_CTRL_EXIT);
c001590c:	8a 1d 6e fb ff cf    	mov    0xcffffb6e,%bl
c0015912:	a3 68 fb ff cf       	mov    %eax,0xcffffb68
c0015917:	80 e3 80             	and    $0x80,%bl
c001591a:	80 fb 01             	cmp    $0x1,%bl
c001591d:	19 c9                	sbb    %ecx,%ecx
c001591f:	83 e1 f4             	and    $0xfffffff4,%ecx
c0015922:	81 c1 8f 04 00 00    	add    $0x48f,%ecx
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
c0015928:	0f 32                	rdmsr  
    ctrl_ent.val    = Msr::read<uint64>(basic.ctrl ? Msr::IA32_VMX_TRUE_ENTRY : Msr::IA32_VMX_CTRL_ENTRY);
c001592a:	80 fb 01             	cmp    $0x1,%bl
c001592d:	19 c9                	sbb    %ecx,%ecx
c001592f:	83 e1 f4             	and    $0xfffffff4,%ecx
            return static_cast<T>(static_cast<uint64>(h) << 32 | l);
c0015932:	a3 40 fb ff cf       	mov    %eax,0xcffffb40
c0015937:	81 c1 90 04 00 00    	add    $0x490,%ecx
c001593d:	89 15 44 fb ff cf    	mov    %edx,0xcffffb44
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
c0015943:	0f 32                	rdmsr  
    ctrl_pin.val    = Msr::read<uint64>(basic.ctrl ? Msr::IA32_VMX_TRUE_PIN   : Msr::IA32_VMX_CTRL_PIN);
c0015945:	80 fb 01             	cmp    $0x1,%bl
c0015948:	19 c9                	sbb    %ecx,%ecx
c001594a:	83 e1 f4             	and    $0xfffffff4,%ecx
            return static_cast<T>(static_cast<uint64>(h) << 32 | l);
c001594d:	a3 38 fb ff cf       	mov    %eax,0xcffffb38
c0015952:	81 c1 8d 04 00 00    	add    $0x48d,%ecx
c0015958:	89 15 3c fb ff cf    	mov    %edx,0xcffffb3c
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
c001595e:	0f 32                	rdmsr  
    ctrl_cpu[0].val = Msr::read<uint64>(basic.ctrl ? Msr::IA32_VMX_TRUE_CPU0  : Msr::IA32_VMX_CTRL_CPU0);
c0015960:	80 fb 01             	cmp    $0x1,%bl
c0015963:	19 c9                	sbb    %ecx,%ecx
c0015965:	83 e1 f4             	and    $0xfffffff4,%ecx
            return static_cast<T>(static_cast<uint64>(h) << 32 | l);
c0015968:	a3 58 fb ff cf       	mov    %eax,0xcffffb58
c001596d:	81 c1 8e 04 00 00    	add    $0x48e,%ecx
c0015973:	89 15 5c fb ff cf    	mov    %edx,0xcffffb5c
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
c0015979:	0f 32                	rdmsr  

    if (has_secondary())
c001597b:	85 d2                	test   %edx,%edx
            return static_cast<T>(static_cast<uint64>(h) << 32 | l);
c001597d:	a3 48 fb ff cf       	mov    %eax,0xcffffb48
c0015982:	89 15 4c fb ff cf    	mov    %edx,0xcffffb4c
c0015988:	79 12                	jns    c001599c <_ZN4Vmcs4initEv+0xf2>
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
c001598a:	b9 8b 04 00 00       	mov    $0x48b,%ecx
c001598f:	0f 32                	rdmsr  
            return static_cast<T>(static_cast<uint64>(h) << 32 | l);
c0015991:	a3 50 fb ff cf       	mov    %eax,0xcffffb50
c0015996:	89 15 54 fb ff cf    	mov    %edx,0xcffffb54
        {
            return has_vpid() ? read (VPID) : 0;
        }

        static bool has_secondary() { return ctrl_cpu[0].clr & CPU_SECONDARY; }
        static bool has_ept()       { return ctrl_cpu[1].clr & CPU_EPT; }
c001599c:	8b 1d 54 fb ff cf    	mov    0xcffffb54,%ebx
c00159a2:	89 dd                	mov    %ebx,%ebp
c00159a4:	83 e5 02             	and    $0x2,%ebp
        ctrl_cpu[1].val = Msr::read<uint64>(Msr::IA32_VMX_CTRL_CPU1);
    if (has_ept() || has_vpid())
c00159a7:	f6 c3 22             	test   $0x22,%bl
c00159aa:	0f 85 12 01 00 00    	jne    c0015ac2 <_ZN4Vmcs4initEv+0x218>
        ept_vpid.val = Msr::read<uint64>(Msr::IA32_VMX_EPT_VPID);
    if (has_ept())
c00159b0:	85 ed                	test   %ebp,%ebp
c00159b2:	74 29                	je     c00159dd <_ZN4Vmcs4initEv+0x133>
        Ept::ord = min (Ept::ord, static_cast<mword>(bit_scan_reverse (static_cast<mword>(ept_vpid.super)) + 2) * Ept::bpl() - 1);
c00159b4:	0f b6 15 62 fb ff cf 	movzbl 0xcffffb62,%edx

ALWAYS_INLINE
inline long int bit_scan_reverse (mword val)
{
    if (EXPECT_FALSE (!val))
        return -1;
c00159bb:	83 c8 ff             	or     $0xffffffff,%eax
#include "util.hpp"

ALWAYS_INLINE
inline long int bit_scan_reverse (mword val)
{
    if (EXPECT_FALSE (!val))
c00159be:	83 e2 03             	and    $0x3,%edx
c00159c1:	74 03                	je     c00159c6 <_ZN4Vmcs4initEv+0x11c>
        return -1;

    asm volatile ("bsr %1, %0" : "=r" (val) : "rm" (val));

    return val;
c00159c3:	0f bd c2             	bsr    %edx,%eax
c00159c6:	8b 15 60 a2 01 c0    	mov    0xc001a260,%edx
c00159cc:	83 c0 02             	add    $0x2,%eax
c00159cf:	8d 04 c0             	lea    (%eax,%eax,8),%eax
c00159d2:	48                   	dec    %eax
c00159d3:	39 d0                	cmp    %edx,%eax
c00159d5:	0f 47 c2             	cmova  %edx,%eax
c00159d8:	a3 60 a2 01 c0       	mov    %eax,0xc001a260
    if (has_urg())
c00159dd:	f6 c3 80             	test   $0x80,%bl
c00159e0:	74 0c                	je     c00159ee <_ZN4Vmcs4initEv+0x144>
        fix_cr0_set &= ~(Cpu::CR0_PG | Cpu::CR0_PE);
c00159e2:	81 e6 fe ff ff 7f    	and    $0x7ffffffe,%esi
c00159e8:	89 35 34 fb ff cf    	mov    %esi,0xcffffb34

    fix_cr0_clr |= Cpu::CR0_CD | Cpu::CR0_NW;
c00159ee:	8b 44 24 04          	mov    0x4(%esp),%eax

    ctrl_cpu[0].set |= CPU_HLT | CPU_IO | CPU_IO_BITMAP | CPU_SECONDARY;
c00159f2:	81 0d 48 fb ff cf 80 	orl    $0x83000080,0xcffffb48
c00159f9:	00 00 83 
    ctrl_cpu[1].set |= CPU_VPID | CPU_URG;
c00159fc:	81 0d 50 fb ff cf a0 	orl    $0xa0,0xcffffb50
c0015a03:	00 00 00 
    if (has_ept())
        Ept::ord = min (Ept::ord, static_cast<mword>(bit_scan_reverse (static_cast<mword>(ept_vpid.super)) + 2) * Ept::bpl() - 1);
    if (has_urg())
        fix_cr0_set &= ~(Cpu::CR0_PG | Cpu::CR0_PE);

    fix_cr0_clr |= Cpu::CR0_CD | Cpu::CR0_NW;
c0015a06:	0d 00 00 00 60       	or     $0x60000000,%eax

    ctrl_cpu[0].set |= CPU_HLT | CPU_IO | CPU_IO_BITMAP | CPU_SECONDARY;
    ctrl_cpu[1].set |= CPU_VPID | CPU_URG;

    if (Cmdline::vtlb || !ept_vpid.invept)
c0015a0b:	80 3d 88 a3 01 c0 00 	cmpb   $0x0,0xc001a388
    if (has_ept())
        Ept::ord = min (Ept::ord, static_cast<mword>(bit_scan_reverse (static_cast<mword>(ept_vpid.super)) + 2) * Ept::bpl() - 1);
    if (has_urg())
        fix_cr0_set &= ~(Cpu::CR0_PG | Cpu::CR0_PE);

    fix_cr0_clr |= Cpu::CR0_CD | Cpu::CR0_NW;
c0015a12:	a3 30 fb ff cf       	mov    %eax,0xcffffb30

    ctrl_cpu[0].set |= CPU_HLT | CPU_IO | CPU_IO_BITMAP | CPU_SECONDARY;
    ctrl_cpu[1].set |= CPU_VPID | CPU_URG;

    if (Cmdline::vtlb || !ept_vpid.invept)
c0015a17:	75 09                	jne    c0015a22 <_ZN4Vmcs4initEv+0x178>
c0015a19:	f6 05 62 fb ff cf 10 	testb  $0x10,0xcffffb62
c0015a20:	75 09                	jne    c0015a2b <_ZN4Vmcs4initEv+0x181>
        ctrl_cpu[1].clr &= ~(CPU_EPT | CPU_URG);
c0015a22:	80 e3 7d             	and    $0x7d,%bl
c0015a25:	89 1d 54 fb ff cf    	mov    %ebx,0xcffffb54
    if (Cmdline::novpid || !ept_vpid.invvpid)
c0015a2b:	80 3d 84 a3 01 c0 00 	cmpb   $0x0,0xc001a384
c0015a32:	75 09                	jne    c0015a3d <_ZN4Vmcs4initEv+0x193>
c0015a34:	f6 05 64 fb ff cf 01 	testb  $0x1,0xcffffb64
c0015a3b:	75 07                	jne    c0015a44 <_ZN4Vmcs4initEv+0x19a>
        ctrl_cpu[1].clr &= ~CPU_VPID;
c0015a3d:	83 25 54 fb ff cf df 	andl   $0xffffffdf,0xcffffb54

ALWAYS_INLINE
static inline mword get_cr0()
{
    mword cr0;
    asm volatile ("mov %%cr0, %0" : "=r" (cr0));
c0015a44:	0f 20 c1             	mov    %cr0,%ecx

    set_cr0 ((get_cr0() & ~fix_cr0_clr) | fix_cr0_set);
c0015a47:	f7 d0                	not    %eax
c0015a49:	21 c8                	and    %ecx,%eax
c0015a4b:	0b 05 34 fb ff cf    	or     0xcffffb34,%eax
}

ALWAYS_INLINE
static inline void set_cr0 (mword cr0)
{
    asm volatile ("mov %0, %%cr0" : : "r" (cr0));
c0015a51:	0f 22 c0             	mov    %eax,%cr0

ALWAYS_INLINE
static inline mword get_cr4()
{
    mword cr4;
    asm volatile ("mov %%cr4, %0" : "=r" (cr4));
c0015a54:	0f 20 e1             	mov    %cr4,%ecx
    set_cr4 ((get_cr4() & ~fix_cr4_clr) | fix_cr4_set);
c0015a57:	8b 2c 24             	mov    (%esp),%ebp
c0015a5a:	21 cd                	and    %ecx,%ebp
c0015a5c:	09 ef                	or     %ebp,%edi
}

ALWAYS_INLINE
static inline void set_cr4 (mword cr4)
{
    asm volatile ("mov %0, %%cr4" : : "r" (cr4));
c0015a5e:	0f 22 e7             	mov    %edi,%cr4
        };

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota)
        {
            return Buddy::allocator.alloc (0, quota, Buddy::FILL_0);
c0015a61:	31 d2                	xor    %edx,%edx
c0015a63:	b9 50 b4 01 c0       	mov    $0xc001b450,%ecx
c0015a68:	6a 01                	push   $0x1
c0015a6a:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c0015a6f:	e8 98 b9 fe ff       	call   c000140c <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
        }

        Vmcs (mword, mword, mword, uint64);

        ALWAYS_INLINE
        inline Vmcs() : rev (basic.revision)
c0015a74:	8b 15 68 fb ff cf    	mov    0xcffffb68,%edx
c0015a7a:	89 10                	mov    %edx,(%eax)
c0015a7c:	2d 00 00 c0 bf       	sub    $0xbfc00000,%eax
        {
            uint64 phys = Buddy::ptr_to_phys (this);
c0015a81:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0015a85:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c0015a8c:	00 

            bool ret;
            asm volatile ("vmxon %1; seta %0" : "=q" (ret) : "m" (phys) : "cc");
c0015a8d:	f3 0f c7 74 24 0c    	vmxon  0xc(%esp)
c0015a93:	0f 97 c0             	seta   %al
            assert (ret);
c0015a96:	84 c0                	test   %al,%al
c0015a98:	5a                   	pop    %edx
c0015a99:	75 3e                	jne    c0015ad9 <_ZN4Vmcs4initEv+0x22f>
c0015a9b:	68 f0 9e 01 c0       	push   $0xc0019ef0
c0015aa0:	68 7c 01 00 00       	push   $0x17c
c0015aa5:	68 13 69 01 c0       	push   $0xc0016913
c0015aaa:	68 83 69 01 c0       	push   $0xc0016983
c0015aaf:	68 69 60 01 c0       	push   $0xc0016069
c0015ab4:	e8 8d be fe ff       	call   c0001946 <_ZN7Console5panicEPKcz>

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
c0015ab9:	f0 83 25 10 e0 01 c0 	lock andl $0xfffffffd,0xc001e010
c0015ac0:	fd 
c0015ac1:	c3                   	ret    
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
c0015ac2:	b9 8c 04 00 00       	mov    $0x48c,%ecx
c0015ac7:	0f 32                	rdmsr  
            return static_cast<T>(static_cast<uint64>(h) << 32 | l);
c0015ac9:	a3 60 fb ff cf       	mov    %eax,0xcffffb60
c0015ace:	89 15 64 fb ff cf    	mov    %edx,0xcffffb64
c0015ad4:	e9 d7 fe ff ff       	jmp    c00159b0 <_ZN4Vmcs4initEv+0x106>

    Vmcs *root = new (Pd::kern.quota) Vmcs;

    trace (TRACE_VMX, "VMCS:%#010lx REV:%#x EPT:%d URG:%d VNMI:%d VPID:%d", Buddy::ptr_to_phys (root), basic.revision, has_ept(), has_urg(), has_vnmi(), has_vpid());
}
c0015ad9:	83 c4 10             	add    $0x10,%esp
c0015adc:	5b                   	pop    %ebx
c0015add:	5e                   	pop    %esi
c0015ade:	5f                   	pop    %edi
c0015adf:	5d                   	pop    %ebp
c0015ae0:	c3                   	ret    
c0015ae1:	90                   	nop

c0015ae2 <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_>:
#include "regs.hpp"
#include "stdio.hpp"
#include "vtlb.hpp"

size_t Vtlb::gwalk (Exc_regs *regs, mword gla, mword &gpa, mword &attr, mword &error)
{
c0015ae2:	55                   	push   %ebp
c0015ae3:	57                   	push   %edi
c0015ae4:	56                   	push   %esi
c0015ae5:	53                   	push   %ebx
c0015ae6:	83 ec 10             	sub    $0x10,%esp
    if (EXPECT_FALSE (!(regs->cr0_shadow & Cpu::CR0_PG))) {
c0015ae9:	8b 68 28             	mov    0x28(%eax),%ebp
#include "regs.hpp"
#include "stdio.hpp"
#include "vtlb.hpp"

size_t Vtlb::gwalk (Exc_regs *regs, mword gla, mword &gpa, mword &attr, mword &error)
{
c0015aec:	89 14 24             	mov    %edx,(%esp)
c0015aef:	8b 74 24 24          	mov    0x24(%esp),%esi
c0015af3:	89 4c 24 04          	mov    %ecx,0x4(%esp)
    if (EXPECT_FALSE (!(regs->cr0_shadow & Cpu::CR0_PG))) {
c0015af7:	85 ed                	test   %ebp,%ebp
c0015af9:	78 09                	js     c0015b04 <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0x22>
        gpa = gla;
c0015afb:	89 c8                	mov    %ecx,%eax
c0015afd:	89 10                	mov    %edx,(%eax)
c0015aff:	e9 81 00 00 00       	jmp    c0015b85 <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0xa3>
        return ~0UL;
    }

    bool pse = regs->cr4_shadow & (Cpu::CR4_PSE | Cpu::CR4_PAE);
c0015b04:	8b 48 30             	mov    0x30(%eax),%ecx
    bool pge = regs->cr4_shadow &  Cpu::CR4_PGE;
    bool wp  = regs->cr0_shadow &  Cpu::CR0_WP;
c0015b07:	81 e5 00 00 01 00    	and    $0x10000,%ebp

    unsigned lev = 2;

    for (uint32 e, *pte= reinterpret_cast<uint32 *>(regs->cr3_shadow & ~PAGE_MASK);; pte = reinterpret_cast<uint32 *>(e & ~PAGE_MASK)) {
c0015b0d:	8b 40 2c             	mov    0x2c(%eax),%eax

        unsigned shift = --lev * 10 + PAGE_BITS;
        pte += gla >> shift & ((1UL << 10) - 1);
c0015b10:	8b 14 24             	mov    (%esp),%edx
    if (EXPECT_FALSE (!(regs->cr0_shadow & Cpu::CR0_PG))) {
        gpa = gla;
        return ~0UL;
    }

    bool pse = regs->cr4_shadow & (Cpu::CR4_PSE | Cpu::CR4_PAE);
c0015b13:	89 cf                	mov    %ecx,%edi
    bool pge = regs->cr4_shadow &  Cpu::CR4_PGE;
    bool wp  = regs->cr0_shadow &  Cpu::CR0_WP;

    unsigned lev = 2;

    for (uint32 e, *pte= reinterpret_cast<uint32 *>(regs->cr3_shadow & ~PAGE_MASK);; pte = reinterpret_cast<uint32 *>(e & ~PAGE_MASK)) {
c0015b15:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    if (EXPECT_FALSE (!(regs->cr0_shadow & Cpu::CR0_PG))) {
        gpa = gla;
        return ~0UL;
    }

    bool pse = regs->cr4_shadow & (Cpu::CR4_PSE | Cpu::CR4_PAE);
c0015b1a:	83 e7 30             	and    $0x30,%edi
    unsigned lev = 2;

    for (uint32 e, *pte= reinterpret_cast<uint32 *>(regs->cr3_shadow & ~PAGE_MASK);; pte = reinterpret_cast<uint32 *>(e & ~PAGE_MASK)) {

        unsigned shift = --lev * 10 + PAGE_BITS;
        pte += gla >> shift & ((1UL << 10) - 1);
c0015b1d:	c1 ea 16             	shr    $0x16,%edx
    if (EXPECT_FALSE (!(regs->cr0_shadow & Cpu::CR0_PG))) {
        gpa = gla;
        return ~0UL;
    }

    bool pse = regs->cr4_shadow & (Cpu::CR4_PSE | Cpu::CR4_PAE);
c0015b20:	89 4c 24 08          	mov    %ecx,0x8(%esp)
    unsigned lev = 2;

    for (uint32 e, *pte= reinterpret_cast<uint32 *>(regs->cr3_shadow & ~PAGE_MASK);; pte = reinterpret_cast<uint32 *>(e & ~PAGE_MASK)) {

        unsigned shift = --lev * 10 + PAGE_BITS;
        pte += gla >> shift & ((1UL << 10) - 1);
c0015b24:	8d 14 90             	lea    (%eax,%edx,4),%edx
c0015b27:	8b 0a                	mov    (%edx),%ecx
c0015b29:	83 c8 ff             	or     $0xffffffff,%eax

        if (User::peek (pte, e) != ~0UL) {
c0015b2c:	40                   	inc    %eax
c0015b2d:	89 cb                	mov    %ecx,%ebx
c0015b2f:	75 4e                	jne    c0015b7f <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0x9d>
            gpa = reinterpret_cast<Paddr>(pte);
            return ~0UL;
        }

        if (EXPECT_FALSE (!(e & TLB_P)))
c0015b31:	f6 c1 01             	test   $0x1,%cl
c0015b34:	0f 84 9f 00 00 00    	je     c0015bd9 <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0xf7>
c0015b3a:	8b 06                	mov    (%esi),%eax
c0015b3c:	21 c8                	and    %ecx,%eax
            return 0;

        attr &= e & PAGE_MASK;
c0015b3e:	25 ff 0f 00 00       	and    $0xfff,%eax

        if (lev && (!pse || !(e & TLB_S))) {
c0015b43:	85 ff                	test   %edi,%edi
        }

        if (EXPECT_FALSE (!(e & TLB_P)))
            return 0;

        attr &= e & PAGE_MASK;
c0015b45:	89 06                	mov    %eax,(%esi)

        if (lev && (!pse || !(e & TLB_S))) {
c0015b47:	74 05                	je     c0015b4e <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0x6c>
c0015b49:	f6 c1 80             	test   $0x80,%cl
c0015b4c:	75 59                	jne    c0015ba7 <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0xc5>
        inline bool frag() const { return val & TLB_F; }

        ALWAYS_INLINE
        static inline bool mark_pte (uint32 *pte, uint32 old, uint32 bits)
        {
            return EXPECT_TRUE ((old & bits) == bits) || User::cmp_swap (pte, old, old | bits) == ~0UL;
c0015b4e:	f6 c1 20             	test   $0x20,%cl
c0015b51:	75 0e                	jne    c0015b61 <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0x7f>
c0015b53:	89 cb                	mov    %ecx,%ebx
        static inline mword cmp_swap (T *addr, T o, T n)
        {
            mword ret;
            asm volatile ("1: lock; cmpxchg %3, %1; or $-1, %0; 2:"
                          ".section .fixup,\"a\"; .align 8;" EXPAND (WORD) " 1b,2b; .previous"
                          : "=a" (ret), "+m" (*addr) : "a" (o), "q" (n));
c0015b55:	89 c8                	mov    %ecx,%eax
c0015b57:	83 cb 20             	or     $0x20,%ebx
c0015b5a:	f0 0f b1 1a          	lock cmpxchg %ebx,(%edx)
c0015b5e:	83 c8 ff             	or     $0xffffffff,%eax
    unsigned lev = 2;

    for (uint32 e, *pte= reinterpret_cast<uint32 *>(regs->cr3_shadow & ~PAGE_MASK);; pte = reinterpret_cast<uint32 *>(e & ~PAGE_MASK)) {

        unsigned shift = --lev * 10 + PAGE_BITS;
        pte += gla >> shift & ((1UL << 10) - 1);
c0015b61:	8b 14 24             	mov    (%esp),%edx
    bool pge = regs->cr4_shadow &  Cpu::CR4_PGE;
    bool wp  = regs->cr0_shadow &  Cpu::CR0_WP;

    unsigned lev = 2;

    for (uint32 e, *pte= reinterpret_cast<uint32 *>(regs->cr3_shadow & ~PAGE_MASK);; pte = reinterpret_cast<uint32 *>(e & ~PAGE_MASK)) {
c0015b64:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx

        unsigned shift = --lev * 10 + PAGE_BITS;
        pte += gla >> shift & ((1UL << 10) - 1);
c0015b6a:	c1 ea 0a             	shr    $0xa,%edx
c0015b6d:	89 d0                	mov    %edx,%eax
c0015b6f:	25 fc 0f 00 00       	and    $0xffc,%eax
c0015b74:	8d 14 01             	lea    (%ecx,%eax,1),%edx
        static inline mword peek (T *addr, T &val)
        {
            mword ret;
            asm volatile ("1: mov %2, %1; or $-1, %0; 2:"
                          ".section .fixup,\"a\"; .align 8;" EXPAND (WORD) " 1b,2b; .previous"
                          : "=a" (ret), "=q" (val) : "m" (*addr));
c0015b77:	8b 1a                	mov    (%edx),%ebx
c0015b79:	83 c8 ff             	or     $0xffffffff,%eax

        if (User::peek (pte, e) != ~0UL) {
c0015b7c:	40                   	inc    %eax
c0015b7d:	74 0e                	je     c0015b8d <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0xab>
            gpa = reinterpret_cast<Paddr>(pte);
c0015b7f:	8b 44 24 04          	mov    0x4(%esp),%eax
c0015b83:	89 10                	mov    %edx,(%eax)
            return ~0UL;
c0015b85:	83 c8 ff             	or     $0xffffffff,%eax
c0015b88:	e9 c4 00 00 00       	jmp    c0015c51 <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0x16f>
        }

        if (EXPECT_FALSE (!(e & TLB_P)))
c0015b8d:	f6 c3 01             	test   $0x1,%bl
c0015b90:	74 47                	je     c0015bd9 <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0xf7>
c0015b92:	8b 06                	mov    (%esi),%eax
    unsigned lev = 2;

    for (uint32 e, *pte= reinterpret_cast<uint32 *>(regs->cr3_shadow & ~PAGE_MASK);; pte = reinterpret_cast<uint32 *>(e & ~PAGE_MASK)) {

        unsigned shift = --lev * 10 + PAGE_BITS;
        pte += gla >> shift & ((1UL << 10) - 1);
c0015b94:	c7 44 24 0c 0c 00 00 	movl   $0xc,0xc(%esp)
c0015b9b:	00 
c0015b9c:	21 d8                	and    %ebx,%eax
        }

        if (EXPECT_FALSE (!(e & TLB_P)))
            return 0;

        attr &= e & PAGE_MASK;
c0015b9e:	25 ff 0f 00 00       	and    $0xfff,%eax
c0015ba3:	89 06                	mov    %eax,(%esi)
c0015ba5:	eb 08                	jmp    c0015baf <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0xcd>
    unsigned lev = 2;

    for (uint32 e, *pte= reinterpret_cast<uint32 *>(regs->cr3_shadow & ~PAGE_MASK);; pte = reinterpret_cast<uint32 *>(e & ~PAGE_MASK)) {

        unsigned shift = --lev * 10 + PAGE_BITS;
        pte += gla >> shift & ((1UL << 10) - 1);
c0015ba7:	c7 44 24 0c 16 00 00 	movl   $0x16,0xc(%esp)
c0015bae:	00 
        if (lev && (!pse || !(e & TLB_S))) {
            mark_pte (pte, e, TLB_A);
            continue;
        }

        if (EXPECT_FALSE (!wp && error == ERR_W))
c0015baf:	85 ed                	test   %ebp,%ebp
c0015bb1:	75 0d                	jne    c0015bc0 <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0xde>
c0015bb3:	8b 4c 24 28          	mov    0x28(%esp),%ecx
c0015bb7:	83 39 02             	cmpl   $0x2,(%ecx)
c0015bba:	0f 84 84 00 00 00    	je     c0015c44 <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0x162>
            attr = (attr & ~TLB_U) | TLB_W;

        if (EXPECT_FALSE ((attr & error) != error)) {
c0015bc0:	8b 44 24 28          	mov    0x28(%esp),%eax
c0015bc4:	8b 3e                	mov    (%esi),%edi
c0015bc6:	8b 00                	mov    (%eax),%eax
c0015bc8:	89 fd                	mov    %edi,%ebp
c0015bca:	21 c5                	and    %eax,%ebp
c0015bcc:	39 c5                	cmp    %eax,%ebp
c0015bce:	74 0d                	je     c0015bdd <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0xfb>
            error |= ERR_P;
c0015bd0:	8b 74 24 28          	mov    0x28(%esp),%esi
c0015bd4:	83 c8 01             	or     $0x1,%eax
c0015bd7:	89 06                	mov    %eax,(%esi)
            return 0;
c0015bd9:	31 c0                	xor    %eax,%eax
c0015bdb:	eb 74                	jmp    c0015c51 <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0x16f>
        }

        if (!(error & ERR_W) && !(e & TLB_D))
c0015bdd:	83 e5 02             	and    $0x2,%ebp
c0015be0:	75 0a                	jne    c0015bec <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0x10a>
c0015be2:	f6 c3 40             	test   $0x40,%bl
c0015be5:	75 05                	jne    c0015bec <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0x10a>
            attr &= ~TLB_W;
c0015be7:	83 e7 fd             	and    $0xfffffffd,%edi
c0015bea:	89 3e                	mov    %edi,(%esi)

        mark_pte (pte, e, static_cast<uint32>((attr & 3) << 5));
c0015bec:	8b 06                	mov    (%esi),%eax
c0015bee:	89 df                	mov    %ebx,%edi
c0015bf0:	83 e0 03             	and    $0x3,%eax
c0015bf3:	c1 e0 05             	shl    $0x5,%eax
c0015bf6:	21 c7                	and    %eax,%edi
c0015bf8:	39 c7                	cmp    %eax,%edi
c0015bfa:	74 0f                	je     c0015c0b <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0x129>
c0015bfc:	09 d8                	or     %ebx,%eax
c0015bfe:	89 c7                	mov    %eax,%edi
        static inline mword cmp_swap (T *addr, T o, T n)
        {
            mword ret;
            asm volatile ("1: lock; cmpxchg %3, %1; or $-1, %0; 2:"
                          ".section .fixup,\"a\"; .align 8;" EXPAND (WORD) " 1b,2b; .previous"
                          : "=a" (ret), "+m" (*addr) : "a" (o), "q" (n));
c0015c00:	89 d8                	mov    %ebx,%eax
c0015c02:	89 f9                	mov    %edi,%ecx
c0015c04:	f0 0f b1 0a          	lock cmpxchg %ecx,(%edx)
c0015c08:	83 c8 ff             	or     $0xffffffff,%eax

        attr |= e & TLB_UC;
c0015c0b:	89 d8                	mov    %ebx,%eax
c0015c0d:	83 e0 10             	and    $0x10,%eax
c0015c10:	0b 06                	or     (%esi),%eax

        if (EXPECT_TRUE (pge) && (e & TLB_G))
c0015c12:	f6 44 24 08 80       	testb  $0x80,0x8(%esp)
c0015c17:	74 08                	je     c0015c21 <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0x13f>
c0015c19:	f6 c7 01             	test   $0x1,%bh
c0015c1c:	74 03                	je     c0015c21 <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0x13f>
            attr |= TLB_M;
c0015c1e:	80 cc 04             	or     $0x4,%ah

        size_t size = 1UL << shift;
c0015c21:	8a 4c 24 0c          	mov    0xc(%esp),%cl

        gpa = (e & ~PAGE_MASK) | (gla & (size - 1));
c0015c25:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
        mark_pte (pte, e, static_cast<uint32>((attr & 3) << 5));

        attr |= e & TLB_UC;

        if (EXPECT_TRUE (pge) && (e & TLB_G))
            attr |= TLB_M;
c0015c2b:	89 06                	mov    %eax,(%esi)

        size_t size = 1UL << shift;
c0015c2d:	b8 01 00 00 00       	mov    $0x1,%eax

        gpa = (e & ~PAGE_MASK) | (gla & (size - 1));
c0015c32:	8b 74 24 04          	mov    0x4(%esp),%esi
        attr |= e & TLB_UC;

        if (EXPECT_TRUE (pge) && (e & TLB_G))
            attr |= TLB_M;

        size_t size = 1UL << shift;
c0015c36:	d3 e0                	shl    %cl,%eax

        gpa = (e & ~PAGE_MASK) | (gla & (size - 1));
c0015c38:	8d 50 ff             	lea    -0x1(%eax),%edx
c0015c3b:	23 14 24             	and    (%esp),%edx
c0015c3e:	09 d3                	or     %edx,%ebx
c0015c40:	89 1e                	mov    %ebx,(%esi)

        return size;
c0015c42:	eb 0d                	jmp    c0015c51 <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0x16f>
            mark_pte (pte, e, TLB_A);
            continue;
        }

        if (EXPECT_FALSE (!wp && error == ERR_W))
            attr = (attr & ~TLB_U) | TLB_W;
c0015c44:	83 e0 f9             	and    $0xfffffff9,%eax
c0015c47:	83 c8 02             	or     $0x2,%eax
c0015c4a:	89 06                	mov    %eax,(%esi)
c0015c4c:	e9 6f ff ff ff       	jmp    c0015bc0 <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0xde>

        gpa = (e & ~PAGE_MASK) | (gla & (size - 1));

        return size;
    }
}
c0015c51:	83 c4 10             	add    $0x10,%esp
c0015c54:	5b                   	pop    %ebx
c0015c55:	5e                   	pop    %esi
c0015c56:	5f                   	pop    %edi
c0015c57:	5d                   	pop    %ebp
c0015c58:	c3                   	ret    
c0015c59:	90                   	nop

c0015c5a <_ZN4Vtlb5hwalkEmRmS0_S0_>:

size_t Vtlb::hwalk (mword gpa, mword &hpa, mword &attr, mword &error)
{
c0015c5a:	57                   	push   %edi
c0015c5b:	89 cf                	mov    %ecx,%edi
c0015c5d:	56                   	push   %esi
c0015c5e:	89 d6                	mov    %edx,%esi
c0015c60:	53                   	push   %ebx
    mword ept_attr;

    size_t size = Pd::current->ept.lookup (gpa, hpa, ept_attr);
c0015c61:	89 c2                	mov    %eax,%edx
        return size;
    }
}

size_t Vtlb::hwalk (mword gpa, mword &hpa, mword &attr, mword &error)
{
c0015c63:	53                   	push   %ebx
    mword ept_attr;

    size_t size = Pd::current->ept.lookup (gpa, hpa, ept_attr);
c0015c64:	31 c9                	xor    %ecx,%ecx
c0015c66:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
        return size;
    }
}

size_t Vtlb::hwalk (mword gpa, mword &hpa, mword &attr, mword &error)
{
c0015c6b:	8b 5c 24 14          	mov    0x14(%esp),%ebx
    mword ept_attr;

    size_t size = Pd::current->ept.lookup (gpa, hpa, ept_attr);
c0015c6f:	54                   	push   %esp
c0015c70:	56                   	push   %esi
c0015c71:	05 60 01 00 00       	add    $0x160,%eax
c0015c76:	e8 6b 80 ff ff       	call   c000dce6 <_ZN3PteI3EptyLj4ELj9ELb0EE6lookupEyRmS2_>

    if (size) {
c0015c7b:	5e                   	pop    %esi
c0015c7c:	5a                   	pop    %edx
c0015c7d:	85 c0                	test   %eax,%eax
c0015c7f:	74 2a                	je     c0015cab <_ZN4Vtlb5hwalkEmRmS0_S0_+0x51>

        if (EXPECT_FALSE (!(ept_attr & Ept::EPT_W)))
c0015c81:	8b 14 24             	mov    (%esp),%edx
c0015c84:	f6 c2 02             	test   $0x2,%dl
c0015c87:	75 03                	jne    c0015c8c <_ZN4Vtlb5hwalkEmRmS0_S0_+0x32>
            attr &= ~TLB_W;
c0015c89:	83 27 fd             	andl   $0xfffffffd,(%edi)

        if (EXPECT_FALSE ((attr & error) != error)) {
c0015c8c:	8b 33                	mov    (%ebx),%esi
c0015c8e:	8b 0f                	mov    (%edi),%ecx
c0015c90:	21 f1                	and    %esi,%ecx
c0015c92:	39 f1                	cmp    %esi,%ecx
c0015c94:	74 17                	je     c0015cad <_ZN4Vtlb5hwalkEmRmS0_S0_+0x53>
            error = (ept_attr & 7) << 3 | 1UL << !!(error & ERR_W);
c0015c96:	83 e2 07             	and    $0x7,%edx
c0015c99:	83 e6 02             	and    $0x2,%esi
c0015c9c:	c1 e2 03             	shl    $0x3,%edx
c0015c9f:	83 fe 01             	cmp    $0x1,%esi
c0015ca2:	19 c0                	sbb    %eax,%eax
c0015ca4:	83 c0 02             	add    $0x2,%eax
c0015ca7:	09 c2                	or     %eax,%edx
c0015ca9:	89 13                	mov    %edx,(%ebx)
c0015cab:	31 c0                	xor    %eax,%eax
            return 0;
        }
    }

    return size;
}
c0015cad:	5a                   	pop    %edx
c0015cae:	5b                   	pop    %ebx
c0015caf:	5e                   	pop    %esi
c0015cb0:	5f                   	pop    %edi
c0015cb1:	c3                   	ret    

c0015cb2 <_ZN4Vtlb10flush_ptabEb>:
        return SUCCESS;
    }
}

void Vtlb::flush_ptab (bool full)
{
c0015cb2:	53                   	push   %ebx
c0015cb3:	8d 98 00 10 00 00    	lea    0x1000(%eax),%ebx
    for (Vtlb *e = this; e < this + (1UL << bpl()); e++) {
c0015cb9:	39 d8                	cmp    %ebx,%eax
c0015cbb:	74 1f                	je     c0015cdc <_ZN4Vtlb10flush_ptabEb+0x2a>
        E val;

        P *walk (Quota &quota, E, unsigned long, bool = true);

        ALWAYS_INLINE
        inline bool present() const { return val & P::PTE_P; }
c0015cbd:	8b 08                	mov    (%eax),%ecx

        if (EXPECT_TRUE (!e->present()))
c0015cbf:	f6 c1 01             	test   $0x1,%cl
c0015cc2:	74 13                	je     c0015cd7 <_ZN4Vtlb10flush_ptabEb+0x25>
            continue;

        if (EXPECT_FALSE (full))
c0015cc4:	84 d2                	test   %dl,%dl
c0015cc6:	74 07                	je     c0015ccf <_ZN4Vtlb10flush_ptabEb+0x1d>
            e->val |= TLB_M;
c0015cc8:	80 cd 04             	or     $0x4,%ch
c0015ccb:	89 08                	mov    %ecx,(%eax)
c0015ccd:	eb 05                	jmp    c0015cd4 <_ZN4Vtlb10flush_ptabEb+0x22>

        else if (EXPECT_FALSE (e->mark()))
c0015ccf:	f6 c5 04             	test   $0x4,%ch
c0015cd2:	75 03                	jne    c0015cd7 <_ZN4Vtlb10flush_ptabEb+0x25>
            continue;

        e->val &= ~TLB_P;
c0015cd4:	83 20 fe             	andl   $0xfffffffe,(%eax)
    }
}

void Vtlb::flush_ptab (bool full)
{
    for (Vtlb *e = this; e < this + (1UL << bpl()); e++) {
c0015cd7:	83 c0 04             	add    $0x4,%eax
c0015cda:	eb dd                	jmp    c0015cb9 <_ZN4Vtlb10flush_ptabEb+0x7>
        else if (EXPECT_FALSE (e->mark()))
            continue;

        e->val &= ~TLB_P;
    }
}
c0015cdc:	5b                   	pop    %ebx
c0015cdd:	c3                   	ret    

c0015cde <_ZN7Counter5printILj1ELj16EEEvmN11Console_vga5ColorEj>:
        }

        template <unsigned D, unsigned B>
        static void print (mword val, Console_vga::Color c, unsigned col)
c0015cde:	53                   	push   %ebx
        {
            if (EXPECT_FALSE (Cpu::row))
c0015cdf:	8b 1d 50 f7 ff cf    	mov    0xcffff750,%ebx
c0015ce5:	85 db                	test   %ebx,%ebx
c0015ce7:	74 21                	je     c0015d0a <_ZN7Counter5printILj1ELj16EEEvmN11Console_vga5ColorEj+0x2c>
                for (unsigned i = 0; i < D; i++, val /= B)
                    Console_vga::con.put (Cpu::row, col - i, c, !i || val ? (val % B)["0123456789ABCDEF"] : ' ');
c0015ce9:	83 e0 0f             	and    $0xf,%eax
c0015cec:	66 0f be 80 14 66 01 	movsbw -0x3ffe99ec(%eax),%ax
c0015cf3:	c0 
c0015cf4:	6b db 50             	imul   $0x50,%ebx,%ebx
c0015cf7:	c1 e2 08             	shl    $0x8,%edx
c0015cfa:	09 c2                	or     %eax,%edx
c0015cfc:	8d 8c 19 00 f8 df 67 	lea    0x67dff800(%ecx,%ebx,1),%ecx
c0015d03:	0f b7 d2             	movzwl %dx,%edx
c0015d06:	66 89 14 09          	mov    %dx,(%ecx,%ecx,1)
        }
c0015d0a:	5b                   	pop    %ebx
c0015d0b:	c3                   	ret    

c0015d0c <_ZN4Vtlb5flushEb>:
    }
}

void Vtlb::flush (bool full)
{
    flush_ptab (full);
c0015d0c:	0f b6 d2             	movzbl %dl,%edx
c0015d0f:	e8 9e ff ff ff       	call   c0015cb2 <_ZN4Vtlb10flush_ptabEb>

    Counter::print<1,16> (++Counter::vtlb_flush, Console_vga::COLOR_LIGHT_RED, SPN_VFL);
c0015d14:	a1 30 f0 ff cf       	mov    0xcffff030,%eax
c0015d19:	b9 05 00 00 00       	mov    $0x5,%ecx
c0015d1e:	ba 0c 00 00 00       	mov    $0xc,%edx
c0015d23:	40                   	inc    %eax
c0015d24:	a3 30 f0 ff cf       	mov    %eax,0xcffff030
c0015d29:	e9 b0 ff ff ff       	jmp    c0015cde <_ZN7Counter5printILj1ELj16EEEvmN11Console_vga5ColorEj>

c0015d2e <_ZN4Vtlb4missEP8Exc_regsmRm>:

    return size;
}

Vtlb::Reason Vtlb::miss (Exc_regs *regs, mword virt, mword &error)
{
c0015d2e:	55                   	push   %ebp
c0015d2f:	57                   	push   %edi
c0015d30:	56                   	push   %esi
c0015d31:	89 c6                	mov    %eax,%esi
c0015d33:	53                   	push   %ebx
c0015d34:	89 cb                	mov    %ecx,%ebx
c0015d36:	83 ec 10             	sub    $0x10,%esp
c0015d39:	89 14 24             	mov    %edx,(%esp)
    mword phys, attr = TLB_U | TLB_W | TLB_P;
c0015d3c:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
c0015d43:	00 
    Paddr host;

    trace (TRACE_VTLB, "VTLB Miss CR3:%#010lx A:%#010lx E:%#lx", regs->cr3_shadow, virt, error);

    error &= ERR_U | ERR_W;
c0015d44:	83 21 06             	andl   $0x6,(%ecx)

    size_t gsize = gwalk (regs, virt, phys, attr, error);
c0015d47:	51                   	push   %ecx
c0015d48:	8d 6c 24 0c          	lea    0xc(%esp),%ebp
c0015d4c:	55                   	push   %ebp
c0015d4d:	8b 54 24 08          	mov    0x8(%esp),%edx
c0015d51:	8d 4c 24 0c          	lea    0xc(%esp),%ecx
c0015d55:	e8 88 fd ff ff       	call   c0015ae2 <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_>
c0015d5a:	89 c7                	mov    %eax,%edi

    if (EXPECT_FALSE (!gsize)) {
c0015d5c:	58                   	pop    %eax
c0015d5d:	85 ff                	test   %edi,%edi
c0015d5f:	5a                   	pop    %edx
c0015d60:	75 10                	jne    c0015d72 <_ZN4Vtlb4missEP8Exc_regsmRm+0x44>
        Counter::vtlb_gpf++;
c0015d62:	ff 05 3c f0 ff cf    	incl   0xcffff03c
        return GLA_GPA;
c0015d68:	b8 01 00 00 00       	mov    $0x1,%eax
c0015d6d:	e9 61 01 00 00       	jmp    c0015ed3 <_ZN4Vtlb4missEP8Exc_regsmRm+0x1a5>
    }

    size_t hsize = hwalk (phys, host, attr, error);
c0015d72:	53                   	push   %ebx
c0015d73:	89 e9                	mov    %ebp,%ecx
c0015d75:	8b 44 24 08          	mov    0x8(%esp),%eax
c0015d79:	8d 54 24 10          	lea    0x10(%esp),%edx
c0015d7d:	e8 d8 fe ff ff       	call   c0015c5a <_ZN4Vtlb5hwalkEmRmS0_S0_>

    if (EXPECT_FALSE (!hsize)) {
c0015d82:	5d                   	pop    %ebp
c0015d83:	85 c0                	test   %eax,%eax
c0015d85:	75 1c                	jne    c0015da3 <_ZN4Vtlb4missEP8Exc_regsmRm+0x75>
        regs->nst_fault = phys;
c0015d87:	8b 44 24 04          	mov    0x4(%esp),%eax
c0015d8b:	89 46 38             	mov    %eax,0x38(%esi)
        regs->nst_error = error;
c0015d8e:	8b 03                	mov    (%ebx),%eax
        Counter::vtlb_hpf++;
c0015d90:	ff 05 38 f0 ff cf    	incl   0xcffff038

    size_t hsize = hwalk (phys, host, attr, error);

    if (EXPECT_FALSE (!hsize)) {
        regs->nst_fault = phys;
        regs->nst_error = error;
c0015d96:	89 46 3c             	mov    %eax,0x3c(%esi)
        Counter::vtlb_hpf++;
        return GPA_HPA;
c0015d99:	b8 02 00 00 00       	mov    $0x2,%eax
c0015d9e:	e9 30 01 00 00       	jmp    c0015ed3 <_ZN4Vtlb4missEP8Exc_regsmRm+0x1a5>
c0015da3:	39 f8                	cmp    %edi,%eax
c0015da5:	89 fb                	mov    %edi,%ebx
c0015da7:	0f 46 d8             	cmovbe %eax,%ebx
    }

    size_t size = min (gsize, hsize);

    if (gsize > hsize)
c0015daa:	39 c7                	cmp    %eax,%edi
c0015dac:	76 08                	jbe    c0015db6 <_ZN4Vtlb4missEP8Exc_regsmRm+0x88>
        attr |= TLB_F;
c0015dae:	81 4c 24 08 00 02 00 	orl    $0x200,0x8(%esp)
c0015db5:	00 

    Counter::print<1,16> (++Counter::vtlb_fill, Console_vga::COLOR_LIGHT_MAGENTA, SPN_VFI);
c0015db6:	a1 34 f0 ff cf       	mov    0xcffff034,%eax
c0015dbb:	b9 04 00 00 00       	mov    $0x4,%ecx
c0015dc0:	ba 0d 00 00 00       	mov    $0xd,%edx
c0015dc5:	40                   	inc    %eax
c0015dc6:	a3 34 f0 ff cf       	mov    %eax,0xcffff034
c0015dcb:	e8 0e ff ff ff       	call   c0015cde <_ZN7Counter5printILj1ELj16EEEvmN11Console_vga5ColorEj>
    unsigned lev = max();

    for (Vtlb *tlb = regs->vtlb;; tlb = static_cast<Vtlb *>(Buddy::phys_to_ptr (tlb->addr()))) {

        unsigned shift = --lev * bpl() + PAGE_BITS;
        tlb += virt >> shift & ((1UL << bpl()) - 1);
c0015dd0:	8b 04 24             	mov    (%esp),%eax
c0015dd3:	8b 4e 24             	mov    0x24(%esi),%ecx
c0015dd6:	c1 e8 16             	shr    $0x16,%eax
c0015dd9:	8d 04 81             	lea    (%ecx,%eax,4),%eax

        if (lev) {

            if (lev == 2 || size < 1UL << shift) {
c0015ddc:	c1 eb 16             	shr    $0x16,%ebx
    unsigned lev = max();

    for (Vtlb *tlb = regs->vtlb;; tlb = static_cast<Vtlb *>(Buddy::phys_to_ptr (tlb->addr()))) {

        unsigned shift = --lev * bpl() + PAGE_BITS;
        tlb += virt >> shift & ((1UL << bpl()) - 1);
c0015ddf:	89 c6                	mov    %eax,%esi
c0015de1:	8b 00                	mov    (%eax),%eax

        if (lev) {

            if (lev == 2 || size < 1UL << shift) {
c0015de3:	0f 85 a2 00 00 00    	jne    c0015e8b <_ZN4Vtlb4missEP8Exc_regsmRm+0x15d>

                if (tlb->super())
c0015de9:	a8 80                	test   $0x80,%al
c0015deb:	75 23                	jne    c0015e10 <_ZN4Vtlb4missEP8Exc_regsmRm+0xe2>
                    tlb->val = static_cast<typeof tlb->val>(Buddy::ptr_to_phys (new (Pd::current->quota) Vtlb) | (lev == 2 ? 0 : TLB_A | TLB_U | TLB_W) | TLB_M | TLB_P);

                else if (!tlb->present()) {
c0015ded:	a8 01                	test   $0x1,%al
c0015def:	75 60                	jne    c0015e51 <_ZN4Vtlb4missEP8Exc_regsmRm+0x123>
class Vtlb : public Pte<Vtlb, uint64, 3,  9, false>
#endif
{
    private:
        ALWAYS_INLINE
        inline bool mark() const { return val & TLB_M; }
c0015df1:	89 c2                	mov    %eax,%edx

        ALWAYS_INLINE
        inline mword attr() const { return static_cast<mword>(val) & PAGE_MASK; }

        ALWAYS_INLINE
        inline Paddr addr() const { return static_cast<Paddr>(val) & ~((1UL << order()) - 1); }
c0015df3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0015df8:	c1 ea 0a             	shr    $0xa,%edx
        }

        ALWAYS_INLINE
        inline mword phys_to_virt (mword phys)
        {
            return phys + reinterpret_cast<mword>(&OFFSET);
c0015dfb:	05 00 00 c0 bf       	add    $0xbfc00000,%eax
c0015e00:	83 e2 01             	and    $0x1,%edx
                    static_cast<Vtlb *>(Buddy::phys_to_ptr (tlb->addr()))->flush_ptab (tlb->mark());
c0015e03:	e8 aa fe ff ff       	call   c0015cb2 <_ZN4Vtlb10flush_ptabEb>
                    tlb->val |= TLB_M | TLB_P;
c0015e08:	81 0e 01 04 00 00    	orl    $0x401,(%esi)
c0015e0e:	eb 41                	jmp    c0015e51 <_ZN4Vtlb4missEP8Exc_regsmRm+0x123>
        if (lev) {

            if (lev == 2 || size < 1UL << shift) {

                if (tlb->super())
                    tlb->val = static_cast<typeof tlb->val>(Buddy::ptr_to_phys (new (Pd::current->quota) Vtlb) | (lev == 2 ? 0 : TLB_A | TLB_U | TLB_W) | TLB_M | TLB_P);
c0015e10:	a1 0c f0 ff cf       	mov    0xcffff00c,%eax
        void flush (bool);

        static Reason miss (Exc_regs *, mword, mword &);

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return Buddy::allocator.alloc (0, quota, Buddy::NOFILL); }
c0015e15:	31 d2                	xor    %edx,%edx
c0015e17:	6a 00                	push   $0x0
c0015e19:	8d 88 90 01 00 00    	lea    0x190(%eax),%ecx
c0015e1f:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c0015e24:	e8 e3 b5 fe ff       	call   c000140c <_ZN5Buddy5allocEtR5QuotaNS_4FillE>

        void free_up (Quota &quota, unsigned l, P *, mword, bool (*) (Paddr, mword, unsigned), bool (*) (unsigned, mword));

    public:

        Pte() : val(0) {}
c0015e29:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c0015e2f:	5a                   	pop    %edx
        };

        ALWAYS_INLINE
        inline Vtlb()
        {
            for (unsigned i = 0; i < 1UL << bpl(); i++)
c0015e30:	31 d2                	xor    %edx,%edx
c0015e32:	89 d7                	mov    %edx,%edi
c0015e34:	c1 ef 0a             	shr    $0xa,%edi
c0015e37:	74 0e                	je     c0015e47 <_ZN4Vtlb4missEP8Exc_regsmRm+0x119>
        }

        ALWAYS_INLINE
        inline mword virt_to_phys (mword virt)
        {
            return virt - reinterpret_cast<mword>(&OFFSET);
c0015e39:	2d 00 00 c0 bf       	sub    $0xbfc00000,%eax
c0015e3e:	0d 27 04 00 00       	or     $0x427,%eax
c0015e43:	89 06                	mov    %eax,(%esi)
c0015e45:	eb 0a                	jmp    c0015e51 <_ZN4Vtlb4missEP8Exc_regsmRm+0x123>
                this[i].val = TLB_S;
c0015e47:	c7 04 90 80 00 00 00 	movl   $0x80,(%eax,%edx,4)
        };

        ALWAYS_INLINE
        inline Vtlb()
        {
            for (unsigned i = 0; i < 1UL << bpl(); i++)
c0015e4e:	42                   	inc    %edx
c0015e4f:	eb e1                	jmp    c0015e32 <_ZN4Vtlb4missEP8Exc_regsmRm+0x104>
                else if (!tlb->present()) {
                    static_cast<Vtlb *>(Buddy::phys_to_ptr (tlb->addr()))->flush_ptab (tlb->mark());
                    tlb->val |= TLB_M | TLB_P;
                }

                tlb->val &= static_cast<typeof tlb->val>(attr | ~TLB_M);
c0015e51:	8b 44 24 08          	mov    0x8(%esp),%eax
    unsigned lev = max();

    for (Vtlb *tlb = regs->vtlb;; tlb = static_cast<Vtlb *>(Buddy::phys_to_ptr (tlb->addr()))) {

        unsigned shift = --lev * bpl() + PAGE_BITS;
        tlb += virt >> shift & ((1UL << bpl()) - 1);
c0015e55:	b9 0c 00 00 00       	mov    $0xc,%ecx
                else if (!tlb->present()) {
                    static_cast<Vtlb *>(Buddy::phys_to_ptr (tlb->addr()))->flush_ptab (tlb->mark());
                    tlb->val |= TLB_M | TLB_P;
                }

                tlb->val &= static_cast<typeof tlb->val>(attr | ~TLB_M);
c0015e5a:	0d ff fb ff ff       	or     $0xfffffbff,%eax
c0015e5f:	23 06                	and    (%esi),%eax
c0015e61:	89 06                	mov    %eax,(%esi)
                tlb->val |= static_cast<typeof tlb->val>(attr & TLB_F);
c0015e63:	8b 54 24 08          	mov    0x8(%esp),%edx
c0015e67:	81 e2 00 02 00 00    	and    $0x200,%edx
c0015e6d:	09 d0                	or     %edx,%eax
    unsigned lev = max();

    for (Vtlb *tlb = regs->vtlb;; tlb = static_cast<Vtlb *>(Buddy::phys_to_ptr (tlb->addr()))) {

        unsigned shift = --lev * bpl() + PAGE_BITS;
        tlb += virt >> shift & ((1UL << bpl()) - 1);
c0015e6f:	8b 14 24             	mov    (%esp),%edx
                    static_cast<Vtlb *>(Buddy::phys_to_ptr (tlb->addr()))->flush_ptab (tlb->mark());
                    tlb->val |= TLB_M | TLB_P;
                }

                tlb->val &= static_cast<typeof tlb->val>(attr | ~TLB_M);
                tlb->val |= static_cast<typeof tlb->val>(attr & TLB_F);
c0015e72:	89 06                	mov    %eax,(%esi)

        ALWAYS_INLINE
        inline mword attr() const { return static_cast<mword>(val) & PAGE_MASK; }

        ALWAYS_INLINE
        inline Paddr addr() const { return static_cast<Paddr>(val) & ~((1UL << order()) - 1); }
c0015e74:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    unsigned lev = max();

    for (Vtlb *tlb = regs->vtlb;; tlb = static_cast<Vtlb *>(Buddy::phys_to_ptr (tlb->addr()))) {

        unsigned shift = --lev * bpl() + PAGE_BITS;
        tlb += virt >> shift & ((1UL << bpl()) - 1);
c0015e79:	c1 ea 0a             	shr    $0xa,%edx
c0015e7c:	81 e2 fc 0f 00 00    	and    $0xffc,%edx
c0015e82:	8d b4 10 00 00 c0 bf 	lea    -0x40400000(%eax,%edx,1),%esi
c0015e89:	eb 32                	jmp    c0015ebd <_ZN4Vtlb4missEP8Exc_regsmRm+0x18f>
                tlb->val |= static_cast<typeof tlb->val>(attr & TLB_F);

                continue;
            }

            if (!tlb->super())
c0015e8b:	a8 80                	test   $0x80,%al
c0015e8d:	75 21                	jne    c0015eb0 <_ZN4Vtlb4missEP8Exc_regsmRm+0x182>
                Vtlb::destroy(static_cast<Vtlb *>(Buddy::phys_to_ptr (tlb->addr())), Pd::current->quota);
c0015e8f:	8b 3d 0c f0 ff cf    	mov    0xcffff00c,%edi
c0015e95:	25 00 f0 ff ff       	and    $0xfffff000,%eax
        }

        ALWAYS_INLINE
        inline mword phys_to_virt (mword phys)
        {
            return phys + reinterpret_cast<mword>(&OFFSET);
c0015e9a:	8d 90 00 00 c0 bf    	lea    -0x40400000(%eax),%edx

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return Buddy::allocator.alloc (0, quota, Buddy::NOFILL); }

        ALWAYS_INLINE
        static inline void destroy(Vtlb *obj, Quota &quota) { obj->~Vtlb(); Buddy::allocator.free (reinterpret_cast<mword>(obj), quota); }
c0015ea0:	b8 54 a3 01 c0       	mov    $0xc001a354,%eax
c0015ea5:	8d 8f 90 01 00 00    	lea    0x190(%edi),%ecx
c0015eab:	e8 b8 b2 fe ff       	call   c0001168 <_ZN5Buddy4freeEmR5Quota>

            attr |= TLB_S;
c0015eb0:	81 4c 24 08 80 00 00 	orl    $0x80,0x8(%esp)
c0015eb7:	00 
c0015eb8:	b9 16 00 00 00       	mov    $0x16,%ecx
c0015ebd:	8b 54 24 08          	mov    0x8(%esp),%edx
        }

        tlb->val = static_cast<typeof tlb->val>((host & ~((1UL << shift) - 1)) | attr | TLB_D | TLB_A);
c0015ec1:	83 c8 ff             	or     $0xffffffff,%eax
c0015ec4:	d3 e0                	shl    %cl,%eax
c0015ec6:	23 44 24 0c          	and    0xc(%esp),%eax
c0015eca:	83 ca 60             	or     $0x60,%edx
c0015ecd:	09 d0                	or     %edx,%eax
c0015ecf:	89 06                	mov    %eax,(%esi)

        return SUCCESS;
c0015ed1:	31 c0                	xor    %eax,%eax
    }
}
c0015ed3:	83 c4 10             	add    $0x10,%esp
c0015ed6:	5b                   	pop    %ebx
c0015ed7:	5e                   	pop    %esi
c0015ed8:	5f                   	pop    %edi
c0015ed9:	5d                   	pop    %ebp
c0015eda:	c3                   	ret    
c0015edb:	90                   	nop

c0015edc <_ZN4Vtlb5flushEm>:
    unsigned l = max();

    for (Vtlb *e = this;; e = static_cast<Vtlb *>(Buddy::phys_to_ptr (e->addr()))) {

        unsigned shift = --l * bpl() + PAGE_BITS;
        e += virt >> shift & ((1UL << bpl()) - 1);
c0015edc:	89 d1                	mov    %edx,%ecx
c0015ede:	c1 e9 16             	shr    $0x16,%ecx
c0015ee1:	8d 0c 88             	lea    (%eax,%ecx,4),%ecx
        E val;

        P *walk (Quota &quota, E, unsigned long, bool = true);

        ALWAYS_INLINE
        inline bool present() const { return val & P::PTE_P; }
c0015ee4:	8b 01                	mov    (%ecx),%eax

        if (!e->present())
c0015ee6:	a8 01                	test   $0x1,%al
c0015ee8:	74 44                	je     c0015f2e <_ZN4Vtlb5flushEm+0x52>
            return;

        if (l && !e->super() && !e->frag())
c0015eea:	a9 80 02 00 00       	test   $0x280,%eax
c0015eef:	75 1b                	jne    c0015f0c <_ZN4Vtlb5flushEm+0x30>
    unsigned l = max();

    for (Vtlb *e = this;; e = static_cast<Vtlb *>(Buddy::phys_to_ptr (e->addr()))) {

        unsigned shift = --l * bpl() + PAGE_BITS;
        e += virt >> shift & ((1UL << bpl()) - 1);
c0015ef1:	c1 ea 0a             	shr    $0xa,%edx

        ALWAYS_INLINE
        inline mword attr() const { return static_cast<mword>(val) & PAGE_MASK; }

        ALWAYS_INLINE
        inline Paddr addr() const { return static_cast<Paddr>(val) & ~((1UL << order()) - 1); }
c0015ef4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0015ef9:	81 e2 fc 0f 00 00    	and    $0xffc,%edx
c0015eff:	8d 8c 10 00 00 c0 bf 	lea    -0x40400000(%eax,%edx,1),%ecx
        E val;

        P *walk (Quota &quota, E, unsigned long, bool = true);

        ALWAYS_INLINE
        inline bool present() const { return val & P::PTE_P; }
c0015f06:	8b 01                	mov    (%ecx),%eax

        if (!e->present())
c0015f08:	a8 01                	test   $0x1,%al
c0015f0a:	74 22                	je     c0015f2e <_ZN4Vtlb5flushEm+0x52>

        if (l && !e->super() && !e->frag())
            continue;

        e->val |=  TLB_M;
        e->val &= ~TLB_P;
c0015f0c:	83 e0 fe             	and    $0xfffffffe,%eax

        Counter::print<1,16> (++Counter::vtlb_flush, Console_vga::COLOR_LIGHT_RED, SPN_VFL);
c0015f0f:	ba 0c 00 00 00       	mov    $0xc,%edx

        if (l && !e->super() && !e->frag())
            continue;

        e->val |=  TLB_M;
        e->val &= ~TLB_P;
c0015f14:	80 cc 04             	or     $0x4,%ah
c0015f17:	89 01                	mov    %eax,(%ecx)

        Counter::print<1,16> (++Counter::vtlb_flush, Console_vga::COLOR_LIGHT_RED, SPN_VFL);
c0015f19:	b9 05 00 00 00       	mov    $0x5,%ecx
c0015f1e:	a1 30 f0 ff cf       	mov    0xcffff030,%eax
c0015f23:	40                   	inc    %eax
c0015f24:	a3 30 f0 ff cf       	mov    %eax,0xcffff030
c0015f29:	e9 b0 fd ff ff       	jmp    c0015cde <_ZN7Counter5printILj1ELj16EEEvmN11Console_vga5ColorEj>
c0015f2e:	c3                   	ret    
