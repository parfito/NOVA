
bin/hypervisor:     file format elf64-x86-64


Disassembly of section .init:

0000000000200000 <_ZN4Acpi5setupEv>:
{
    write (RESET, reset_val);
}

void Acpi::setup()
{
  200000:	53                   	push   %rbx
  200001:	48 83 ec 10          	sub    $0x10,%rsp
    Acpi_rsdp::parse();
  200005:	e8 cc 09 00 00       	callq  2009d6 <_ZN9Acpi_rsdp5parseEv>

    if (xsdt)
  20000a:	48 8b 1d d7 1c e2 80 	mov    -0x7f1de329(%rip),%rbx        # ffffffff81021ce8 <_ZN4Acpi4xsdtE>
  200011:	48 85 db             	test   %rbx,%rbx
  200014:	74 16                	je     20002c <_ZN4Acpi5setupEv+0x2c>
        static_cast<Acpi_table_rsdt *>(Hpt::remap (Pd::kern.quota, xsdt))->parse (xsdt, sizeof (uint64));
  200016:	48 89 de             	mov    %rbx,%rsi
  200019:	48 c7 c7 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rdi
  200020:	e8 ed 80 e0 80       	callq  ffffffff81008112 <_ZN3Hpt5remapER5Quotam>
  200025:	ba 08 00 00 00       	mov    $0x8,%edx
  20002a:	eb 20                	jmp    20004c <_ZN4Acpi5setupEv+0x4c>
    else if (rsdt)
  20002c:	48 8b 1d bd 1c e2 80 	mov    -0x7f1de343(%rip),%rbx        # ffffffff81021cf0 <_ZN4Acpi4rsdtE>
  200033:	48 85 db             	test   %rbx,%rbx
  200036:	74 1f                	je     200057 <_ZN4Acpi5setupEv+0x57>
        static_cast<Acpi_table_rsdt *>(Hpt::remap (Pd::kern.quota, rsdt))->parse (rsdt, sizeof (uint32));
  200038:	48 89 de             	mov    %rbx,%rsi
  20003b:	48 c7 c7 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rdi
  200042:	e8 cb 80 e0 80       	callq  ffffffff81008112 <_ZN3Hpt5remapER5Quotam>
  200047:	ba 04 00 00 00       	mov    $0x4,%edx
  20004c:	48 89 de             	mov    %rbx,%rsi
  20004f:	48 89 c7             	mov    %rax,%rdi
  200052:	e8 ff 09 00 00       	callq  200a56 <_ZNK15Acpi_table_rsdt5parseEmm>

    if (fadt)
  200057:	48 8b 35 b2 1c e2 80 	mov    -0x7f1de34e(%rip),%rsi        # ffffffff81021d10 <_ZN4Acpi4fadtE>
  20005e:	48 85 f6             	test   %rsi,%rsi
  200061:	74 14                	je     200077 <_ZN4Acpi5setupEv+0x77>
        static_cast<Acpi_table_fadt *>(Hpt::remap (Pd::kern.quota, fadt))->parse();
  200063:	48 c7 c7 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rdi
  20006a:	e8 a3 80 e0 80       	callq  ffffffff81008112 <_ZN3Hpt5remapER5Quotam>
  20006f:	48 89 c7             	mov    %rax,%rdi
  200072:	e8 25 04 00 00       	callq  20049c <_ZNK15Acpi_table_fadt5parseEv>
    if (hpet)
  200077:	48 8b 35 8a 1c e2 80 	mov    -0x7f1de376(%rip),%rsi        # ffffffff81021d08 <_ZN4Acpi4hpetE>
  20007e:	48 85 f6             	test   %rsi,%rsi
  200081:	74 14                	je     200097 <_ZN4Acpi5setupEv+0x97>
        static_cast<Acpi_table_hpet *>(Hpt::remap (Pd::kern.quota, hpet))->parse();
  200083:	48 c7 c7 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rdi
  20008a:	e8 83 80 e0 80       	callq  ffffffff81008112 <_ZN3Hpt5remapER5Quotam>
  20008f:	48 89 c7             	mov    %rax,%rdi
  200092:	e8 f1 05 00 00       	callq  200688 <_ZNK15Acpi_table_hpet5parseEv>
    if (madt)
  200097:	48 8b 35 62 1c e2 80 	mov    -0x7f1de39e(%rip),%rsi        # ffffffff81021d00 <_ZN4Acpi4madtE>
  20009e:	48 85 f6             	test   %rsi,%rsi
  2000a1:	74 14                	je     2000b7 <_ZN4Acpi5setupEv+0xb7>
        static_cast<Acpi_table_madt *>(Hpt::remap (Pd::kern.quota, madt))->parse();
  2000a3:	48 c7 c7 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rdi
  2000aa:	e8 63 80 e0 80       	callq  ffffffff81008112 <_ZN3Hpt5remapER5Quotam>
  2000af:	48 89 c7             	mov    %rax,%rdi
  2000b2:	e8 3b 08 00 00       	callq  2008f2 <_ZNK15Acpi_table_madt5parseEv>
    if (mcfg)
  2000b7:	48 8b 35 3a 1c e2 80 	mov    -0x7f1de3c6(%rip),%rsi        # ffffffff81021cf8 <_ZN4Acpi4mcfgE>
  2000be:	48 85 f6             	test   %rsi,%rsi
  2000c1:	74 14                	je     2000d7 <_ZN4Acpi5setupEv+0xd7>
        static_cast<Acpi_table_mcfg *>(Hpt::remap (Pd::kern.quota, mcfg))->parse();
  2000c3:	48 c7 c7 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rdi
  2000ca:	e8 43 80 e0 80       	callq  ffffffff81008112 <_ZN3Hpt5remapER5Quotam>
  2000cf:	48 89 c7             	mov    %rax,%rdi
  2000d2:	e8 71 08 00 00       	callq  200948 <_ZNK15Acpi_table_mcfg5parseEv>
    if (dmar)
  2000d7:	48 8b 35 3a 1c e2 80 	mov    -0x7f1de3c6(%rip),%rsi        # ffffffff81021d18 <_ZN4Acpi4dmarE>
  2000de:	48 85 f6             	test   %rsi,%rsi
  2000e1:	74 14                	je     2000f7 <_ZN4Acpi5setupEv+0xf7>
        static_cast<Acpi_table_dmar *>(Hpt::remap (Pd::kern.quota, dmar))->parse();
  2000e3:	48 c7 c7 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rdi
  2000ea:	e8 23 80 e0 80       	callq  ffffffff81008112 <_ZN3Hpt5remapER5Quotam>
  2000ef:	48 89 c7             	mov    %rax,%rdi
  2000f2:	e8 0f 03 00 00       	callq  200406 <_ZNK15Acpi_table_dmar5parseEv>

    if (!Acpi_table_madt::sci_overridden) {
  2000f7:	80 3d 02 1b e2 80 00 	cmpb   $0x0,-0x7f1de4fe(%rip)        # ffffffff81021c00 <_ZN15Acpi_table_madt14sci_overriddenE>
  2000fe:	75 22                	jne    200122 <_ZN4Acpi5setupEv+0x122>
        Acpi_intr sci_override;
        sci_override.bus = 0;
        sci_override.irq = static_cast<uint8>(irq);
  200100:	8b 05 02 1b e2 80    	mov    -0x7f1de4fe(%rip),%eax        # ffffffff81021c08 <_ZN4Acpi3irqE>
        sci_override.gsi = irq;
        sci_override.flags.pol = Acpi_inti::POL_CONFORMING;
        sci_override.flags.trg = Acpi_inti::TRG_CONFORMING;
        Acpi_table_madt::parse_intr (&sci_override);
  200106:	48 8d 7c 24 06       	lea    0x6(%rsp),%rdi
    if (dmar)
        static_cast<Acpi_table_dmar *>(Hpt::remap (Pd::kern.quota, dmar))->parse();

    if (!Acpi_table_madt::sci_overridden) {
        Acpi_intr sci_override;
        sci_override.bus = 0;
  20010b:	c6 44 24 08 00       	movb   $0x0,0x8(%rsp)
        sci_override.irq = static_cast<uint8>(irq);
        sci_override.gsi = irq;
        sci_override.flags.pol = Acpi_inti::POL_CONFORMING;
        sci_override.flags.trg = Acpi_inti::TRG_CONFORMING;
  200110:	80 64 24 0e f0       	andb   $0xf0,0xe(%rsp)
        static_cast<Acpi_table_dmar *>(Hpt::remap (Pd::kern.quota, dmar))->parse();

    if (!Acpi_table_madt::sci_overridden) {
        Acpi_intr sci_override;
        sci_override.bus = 0;
        sci_override.irq = static_cast<uint8>(irq);
  200115:	88 44 24 09          	mov    %al,0x9(%rsp)
        sci_override.gsi = irq;
  200119:	89 44 24 0a          	mov    %eax,0xa(%rsp)
        sci_override.flags.pol = Acpi_inti::POL_CONFORMING;
        sci_override.flags.trg = Acpi_inti::TRG_CONFORMING;
        Acpi_table_madt::parse_intr (&sci_override);
  20011d:	e8 c0 05 00 00       	callq  2006e2 <_ZN15Acpi_table_madt10parse_intrEPK9Acpi_apic>
    }

    Gsi::set (gsi = Gsi::irq_to_gsi (irq));
  200122:	8b 05 e0 1a e2 80    	mov    -0x7f1de520(%rip),%eax        # ffffffff81021c08 <_ZN4Acpi3irqE>
        static void unmask (unsigned);

        ALWAYS_INLINE
        static inline unsigned irq_to_gsi (unsigned irq)
        {
            assert (irq < NUM_IRQ);
  200128:	83 f8 0f             	cmp    $0xf,%eax
  20012b:	76 28                	jbe    200155 <_ZN4Acpi5setupEv+0x155>
  20012d:	49 c7 c0 f0 d2 01 81 	mov    $0xffffffff8101d2f0,%r8
  200134:	b9 38 00 00 00       	mov    $0x38,%ecx
  200139:	48 c7 c2 ab d1 01 81 	mov    $0xffffffff8101d1ab,%rdx
  200140:	48 c7 c6 1a d2 01 81 	mov    $0xffffffff8101d21a,%rsi
  200147:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
  20014e:	31 c0                	xor    %eax,%eax
  200150:	e8 fb 1d e0 80       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
            return irq_table[irq];
  200155:	8b 3c 85 00 21 16 81 	mov    -0x7ee9df00(,%rax,4),%edi
  20015c:	31 d2                	xor    %edx,%edx
  20015e:	31 f6                	xor    %esi,%esi
  200160:	89 3d 9e 1a e2 80    	mov    %edi,-0x7f1de562(%rip)        # ffffffff81021c04 <_ZN4Acpi3gsiE>
  200166:	e8 23 79 e0 80       	callq  ffffffff81007a8e <_ZN3Gsi3setEjjj>

    write (PM1_ENA, PM1_ENA_TMR);
  20016b:	be 01 00 00 00       	mov    $0x1,%esi
  200170:	bf 01 00 00 00       	mov    $0x1,%edi
  200175:	e8 36 0c e0 80       	callq  ffffffff81000db0 <_ZN4Acpi5writeENS_8RegisterEj>

    clear (GPE0_ENA, 0);
  20017a:	31 f6                	xor    %esi,%esi
  20017c:	bf 05 00 00 00       	mov    $0x5,%edi
  200181:	e8 f2 0b e0 80       	callq  ffffffff81000d78 <_ZN4Acpi5clearENS_8RegisterEj>
    clear (GPE1_ENA, 0);
  200186:	31 f6                	xor    %esi,%esi
  200188:	bf 07 00 00 00       	mov    $0x7,%edi
  20018d:	e8 e6 0b e0 80       	callq  ffffffff81000d78 <_ZN4Acpi5clearENS_8RegisterEj>

    for (; tmr_ovf = read (PM_TMR) >> tmr_msb(), read (PM1_STS) & PM1_STS_TMR; write (PM1_STS, PM1_STS_TMR)) ;
  200192:	bf 08 00 00 00       	mov    $0x8,%edi
  200197:	e8 90 0a e0 80       	callq  ffffffff81000c2c <_ZN4Acpi4readENS_8RegisterE>
        static void hw_write (Acpi_gas *, unsigned, bool = false);
        static void write (Register, unsigned);
        static void clear (Register, unsigned);

        ALWAYS_INLINE
        static inline mword tmr_msb() { return feature & 0x100 ? 31 : 23; }
  20019c:	8b 15 6e 1a e2 80    	mov    -0x7f1de592(%rip),%edx        # ffffffff81021c10 <_ZN4Acpi7featureE>
  2001a2:	81 e2 00 01 00 00    	and    $0x100,%edx
  2001a8:	83 fa 01             	cmp    $0x1,%edx
  2001ab:	48 19 c9             	sbb    %rcx,%rcx
  2001ae:	31 ff                	xor    %edi,%edi
  2001b0:	48 83 e1 f8          	and    $0xfffffffffffffff8,%rcx
  2001b4:	48 83 c1 1f          	add    $0x1f,%rcx
  2001b8:	d3 e8                	shr    %cl,%eax
  2001ba:	89 05 54 1a e2 80    	mov    %eax,-0x7f1de5ac(%rip)        # ffffffff81021c14 <_ZN4Acpi7tmr_ovfE>
  2001c0:	e8 67 0a e0 80       	callq  ffffffff81000c2c <_ZN4Acpi4readENS_8RegisterE>
  2001c5:	a8 01                	test   $0x1,%al
  2001c7:	74 0e                	je     2001d7 <_ZN4Acpi5setupEv+0x1d7>
  2001c9:	be 01 00 00 00       	mov    $0x1,%esi
  2001ce:	31 ff                	xor    %edi,%edi
  2001d0:	e8 db 0b e0 80       	callq  ffffffff81000db0 <_ZN4Acpi5writeENS_8RegisterEj>
  2001d5:	eb bb                	jmp    200192 <_ZN4Acpi5setupEv+0x192>

    trace (TRACE_ACPI, "ACPI: GSI:%#x TMR:%lu", gsi, tmr_msb() + 1);
}
  2001d7:	48 83 c4 10          	add    $0x10,%rsp
  2001db:	5b                   	pop    %rbx
  2001dc:	c3                   	retq   
  2001dd:	90                   	nop

00000000002001de <_ZNK9Acpi_dmar5parseEv>:
#include "ioapic.hpp"
#include "pci.hpp"
#include "pd.hpp"

void Acpi_dmar::parse() const
{
  2001de:	55                   	push   %rbp
  2001df:	53                   	push   %rbx
    public:
        INIT
        Dmar (Paddr);

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
  2001e0:	48 c7 c6 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rsi
  2001e7:	52                   	push   %rdx
  2001e8:	48 89 fb             	mov    %rdi,%rbx
  2001eb:	48 c7 c7 70 20 16 81 	mov    $0xffffffff81162070,%rdi
  2001f2:	e8 37 57 e1 80       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
    Dmar *dmar = new (Pd::kern.quota) Dmar (static_cast<Paddr>(phys));
  2001f7:	48 8b 73 08          	mov    0x8(%rbx),%rsi
  2001fb:	48 89 c7             	mov    %rax,%rdi
  2001fe:	48 89 c5             	mov    %rax,%rbp
  200201:	e8 a6 0c 00 00       	callq  200eac <_ZN4DmarC1Em>

    if (flags & 1)
  200206:	f6 43 04 01          	testb  $0x1,0x4(%rbx)
  20020a:	48 8b 05 df 36 f6 80 	mov    -0x7f09c921(%rip),%rax        # ffffffff811638f0 <_ZN3Pci4listE>
  200211:	75 14                	jne    200227 <_ZNK9Acpi_dmar5parseEv+0x49>
        Pci::claim_all (dmar);

    for (Acpi_scope const *s = scope; s < reinterpret_cast<Acpi_scope *>(reinterpret_cast<mword>(this) + length); s = reinterpret_cast<Acpi_scope *>(reinterpret_cast<mword>(s) + s->length)) {
  200213:	48 8d 53 10          	lea    0x10(%rbx),%rdx
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline bool claim_dev (unsigned r, unsigned i)
        {
            for (Ioapic *ioapic = list; ioapic; ioapic = ioapic->next)
  200217:	48 8b 35 12 36 f6 80 	mov    -0x7f09c9ee(%rip),%rsi        # ffffffff81163830 <_ZN6Ioapic4listE>
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline bool claim_dev (unsigned r, unsigned i)
        {
            for (Hpet *hpet = list; hpet; hpet = hpet->next)
  20021e:	48 8b 3d 2b 2b f6 80 	mov    -0x7f09d4d5(%rip),%rdi        # ffffffff81162d50 <_ZN4Hpet4listE>
  200225:	eb 56                	jmp    20027d <_ZNK9Acpi_dmar5parseEv+0x9f>
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void claim_all (Dmar *d)
        {
            for (Pci *pci = list; pci; pci = pci->next)
  200227:	48 89 c2             	mov    %rax,%rdx
  20022a:	48 85 d2             	test   %rdx,%rdx
  20022d:	74 e4                	je     200213 <_ZNK9Acpi_dmar5parseEv+0x35>
                if (!pci->dmar)
  20022f:	48 83 7a 18 00       	cmpq   $0x0,0x18(%rdx)
  200234:	75 04                	jne    20023a <_ZNK9Acpi_dmar5parseEv+0x5c>
                    pci->dmar = d;
  200236:	48 89 6a 18          	mov    %rbp,0x18(%rdx)
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void claim_all (Dmar *d)
        {
            for (Pci *pci = list; pci; pci = pci->next)
  20023a:	48 8b 12             	mov    (%rdx),%rdx
  20023d:	eb eb                	jmp    20022a <_ZNK9Acpi_dmar5parseEv+0x4c>

        switch (s->type) {
  20023f:	8a 0a                	mov    (%rdx),%cl
  200241:	80 f9 03             	cmp    $0x3,%cl
  200244:	0f 84 8c 00 00 00    	je     2002d6 <_ZNK9Acpi_dmar5parseEv+0xf8>
  20024a:	77 42                	ja     20028e <_ZNK9Acpi_dmar5parseEv+0xb0>
  20024c:	80 f9 01             	cmp    $0x1,%cl
  20024f:	72 25                	jb     200276 <_ZNK9Acpi_dmar5parseEv+0x98>
        uint8       length;
        uint16      reserved;
        uint8       id, b, d, f;

        ALWAYS_INLINE
        inline unsigned rid() const { return b << 8 | d << 3 | f; }
  200251:	44 0f b6 42 05       	movzbl 0x5(%rdx),%r8d
  200256:	0f b6 4a 06          	movzbl 0x6(%rdx),%ecx
  20025a:	41 c1 e0 08          	shl    $0x8,%r8d
  20025e:	c1 e1 03             	shl    $0x3,%ecx
  200261:	41 09 c8             	or     %ecx,%r8d
  200264:	0f b6 4a 07          	movzbl 0x7(%rdx),%ecx
  200268:	41 09 c8             	or     %ecx,%r8d
        inline void write (Register r, T v) { *reinterpret_cast<T volatile *>(reg_base + r) = v; }

        ALWAYS_INLINE
        static inline Pci *find_dev (unsigned long r)
        {
            for (Pci *pci = list; pci; pci = pci->next)
  20026b:	48 89 c1             	mov    %rax,%rcx
        }

        ALWAYS_INLINE
        static inline bool claim_dev (Dmar *d, unsigned r)
        {
            Pci *pci = find_dev (r);
  20026e:	4d 63 c0             	movslq %r8d,%r8
        inline void write (Register r, T v) { *reinterpret_cast<T volatile *>(reg_base + r) = v; }

        ALWAYS_INLINE
        static inline Pci *find_dev (unsigned long r)
        {
            for (Pci *pci = list; pci; pci = pci->next)
  200271:	48 85 c9             	test   %rcx,%rcx
  200274:	75 35                	jne    2002ab <_ZNK9Acpi_dmar5parseEv+0xcd>
    Dmar *dmar = new (Pd::kern.quota) Dmar (static_cast<Paddr>(phys));

    if (flags & 1)
        Pci::claim_all (dmar);

    for (Acpi_scope const *s = scope; s < reinterpret_cast<Acpi_scope *>(reinterpret_cast<mword>(this) + length); s = reinterpret_cast<Acpi_scope *>(reinterpret_cast<mword>(s) + s->length)) {
  200276:	0f b6 4a 01          	movzbl 0x1(%rdx),%ecx
  20027a:	48 01 ca             	add    %rcx,%rdx
  20027d:	0f b7 4b 02          	movzwl 0x2(%rbx),%ecx
  200281:	48 01 d9             	add    %rbx,%rcx
  200284:	48 39 ca             	cmp    %rcx,%rdx
  200287:	72 b6                	jb     20023f <_ZNK9Acpi_dmar5parseEv+0x61>
  200289:	e9 bf 00 00 00       	jmpq   20034d <_ZNK9Acpi_dmar5parseEv+0x16f>

        switch (s->type) {
  20028e:	80 f9 04             	cmp    $0x4,%cl
  200291:	75 e3                	jne    200276 <_ZNK9Acpi_dmar5parseEv+0x98>
                break;
            case 3:
                Ioapic::claim_dev (s->rid(), s->id);
                break;
            case 4:
                Hpet::claim_dev (s->rid(), s->id);
  200293:	44 0f b6 5a 04       	movzbl 0x4(%rdx),%r11d
  200298:	0f b6 4a 05          	movzbl 0x5(%rdx),%ecx
  20029c:	49 89 f8             	mov    %rdi,%r8
  20029f:	44 0f b6 52 06       	movzbl 0x6(%rdx),%r10d
  2002a4:	44 0f b6 4a 07       	movzbl 0x7(%rdx),%r9d
  2002a9:	eb 7b                	jmp    200326 <_ZNK9Acpi_dmar5parseEv+0x148>
                if (pci->rid == r)
  2002ab:	44 0f b7 49 10       	movzwl 0x10(%rcx),%r9d
  2002b0:	4d 39 c1             	cmp    %r8,%r9
  2002b3:	75 07                	jne    2002bc <_ZNK9Acpi_dmar5parseEv+0xde>
            Pci *pci = find_dev (r);

            if (!pci)
                return false;

            unsigned l = pci->lev;
  2002b5:	66 44 8b 41 12       	mov    0x12(%rcx),%r8w
  2002ba:	eb 0c                	jmp    2002c8 <_ZNK9Acpi_dmar5parseEv+0xea>
        inline void write (Register r, T v) { *reinterpret_cast<T volatile *>(reg_base + r) = v; }

        ALWAYS_INLINE
        static inline Pci *find_dev (unsigned long r)
        {
            for (Pci *pci = list; pci; pci = pci->next)
  2002bc:	48 8b 09             	mov    (%rcx),%rcx
  2002bf:	eb b0                	jmp    200271 <_ZNK9Acpi_dmar5parseEv+0x93>

            if (!pci)
                return false;

            unsigned l = pci->lev;
            do pci->dmar = d; while ((pci = pci->next) && pci->lev > l);
  2002c1:	66 44 39 41 12       	cmp    %r8w,0x12(%rcx)
  2002c6:	76 ae                	jbe    200276 <_ZNK9Acpi_dmar5parseEv+0x98>
  2002c8:	48 89 69 18          	mov    %rbp,0x18(%rcx)
  2002cc:	48 8b 09             	mov    (%rcx),%rcx
  2002cf:	48 85 c9             	test   %rcx,%rcx
  2002d2:	75 ed                	jne    2002c1 <_ZNK9Acpi_dmar5parseEv+0xe3>
  2002d4:	eb a0                	jmp    200276 <_ZNK9Acpi_dmar5parseEv+0x98>
        switch (s->type) {
            case 1 ... 2:
                Pci::claim_dev (dmar, s->rid());
                break;
            case 3:
                Ioapic::claim_dev (s->rid(), s->id);
  2002d6:	44 0f b6 5a 04       	movzbl 0x4(%rdx),%r11d
  2002db:	0f b6 4a 05          	movzbl 0x5(%rdx),%ecx
  2002df:	49 89 f0             	mov    %rsi,%r8
  2002e2:	44 0f b6 52 06       	movzbl 0x6(%rdx),%r10d
  2002e7:	44 0f b6 4a 07       	movzbl 0x7(%rdx),%r9d
  2002ec:	4d 85 c0             	test   %r8,%r8
  2002ef:	74 85                	je     200276 <_ZNK9Acpi_dmar5parseEv+0x98>
                if (ioapic->rid == 0 && ioapic->id == i) {
  2002f1:	66 41 83 78 18 00    	cmpw   $0x0,0x18(%r8)
  2002f7:	75 1d                	jne    200316 <_ZNK9Acpi_dmar5parseEv+0x138>
  2002f9:	45 39 58 14          	cmp    %r11d,0x14(%r8)
  2002fd:	75 17                	jne    200316 <_ZNK9Acpi_dmar5parseEv+0x138>
  2002ff:	41 c1 e2 03          	shl    $0x3,%r10d
  200303:	c1 e1 08             	shl    $0x8,%ecx
  200306:	44 09 d1             	or     %r10d,%ecx
  200309:	44 09 c9             	or     %r9d,%ecx
                    ioapic->rid  = static_cast<uint16>(r);
  20030c:	66 41 89 48 18       	mov    %cx,0x18(%r8)
  200311:	e9 60 ff ff ff       	jmpq   200276 <_ZNK9Acpi_dmar5parseEv+0x98>
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline bool claim_dev (unsigned r, unsigned i)
        {
            for (Ioapic *ioapic = list; ioapic; ioapic = ioapic->next)
  200316:	4d 8b 00             	mov    (%r8),%r8
  200319:	eb d1                	jmp    2002ec <_ZNK9Acpi_dmar5parseEv+0x10e>
                if (hpet->rid == 0 && hpet->id == i) {
  20031b:	66 41 83 78 14 00    	cmpw   $0x0,0x14(%r8)
  200321:	74 0d                	je     200330 <_ZNK9Acpi_dmar5parseEv+0x152>
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline bool claim_dev (unsigned r, unsigned i)
        {
            for (Hpet *hpet = list; hpet; hpet = hpet->next)
  200323:	4d 8b 00             	mov    (%r8),%r8
  200326:	4d 85 c0             	test   %r8,%r8
  200329:	75 f0                	jne    20031b <_ZNK9Acpi_dmar5parseEv+0x13d>
  20032b:	e9 46 ff ff ff       	jmpq   200276 <_ZNK9Acpi_dmar5parseEv+0x98>
                if (hpet->rid == 0 && hpet->id == i) {
  200330:	45 39 58 10          	cmp    %r11d,0x10(%r8)
  200334:	75 ed                	jne    200323 <_ZNK9Acpi_dmar5parseEv+0x145>
  200336:	41 c1 e2 03          	shl    $0x3,%r10d
  20033a:	c1 e1 08             	shl    $0x8,%ecx
  20033d:	44 09 d1             	or     %r10d,%ecx
  200340:	44 09 c9             	or     %r9d,%ecx
                    hpet->rid = static_cast<uint16>(r);
  200343:	66 41 89 48 14       	mov    %cx,0x14(%r8)
  200348:	e9 29 ff ff ff       	jmpq   200276 <_ZNK9Acpi_dmar5parseEv+0x98>
            case 4:
                Hpet::claim_dev (s->rid(), s->id);
                break;
        }
    }
}
  20034d:	58                   	pop    %rax
  20034e:	5b                   	pop    %rbx
  20034f:	5d                   	pop    %rbp
  200350:	c3                   	retq   
  200351:	90                   	nop

0000000000200352 <_ZNK9Acpi_rmrr5parseEv>:

void Acpi_rmrr::parse() const
{
  200352:	55                   	push   %rbp
  200353:	53                   	push   %rbx
  200354:	48 89 fd             	mov    %rdi,%rbp
  200357:	56                   	push   %rsi
    for (uint64 hpa = base & ~PAGE_MASK; hpa < limit; hpa += PAGE_SIZE)
  200358:	48 8b 5f 08          	mov    0x8(%rdi),%rbx
  20035c:	48 81 e3 00 f0 ff ff 	and    $0xfffffffffffff000,%rbx
  200363:	48 3b 5d 10          	cmp    0x10(%rbp),%rbx
  200367:	73 30                	jae    200399 <_ZNK9Acpi_rmrr5parseEv+0x47>
        Pd::kern.dpt.update (Pd::kern.quota, hpa, 0, hpa, Dpt::DPT_R | Dpt::DPT_W);
  200369:	6a 00                	pushq  $0x0
  20036b:	6a 00                	pushq  $0x0
  20036d:	48 89 da             	mov    %rbx,%rdx
  200370:	49 89 d8             	mov    %rbx,%r8
  200373:	31 c9                	xor    %ecx,%ecx
  200375:	41 b9 03 00 00 00    	mov    $0x3,%r9d
  20037b:	48 c7 c6 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rsi
  200382:	48 c7 c7 48 3f 16 81 	mov    $0xffffffff81163f48,%rdi
    }
}

void Acpi_rmrr::parse() const
{
    for (uint64 hpa = base & ~PAGE_MASK; hpa < limit; hpa += PAGE_SIZE)
  200389:	48 81 c3 00 10 00 00 	add    $0x1000,%rbx
        Pd::kern.dpt.update (Pd::kern.quota, hpa, 0, hpa, Dpt::DPT_R | Dpt::DPT_W);
  200390:	e8 db 21 e1 80       	callq  ffffffff81012570 <_ZN3PteI3DptyLj4ELj9ELb1EE6updateER5QuotaymymNS1_4TypeEb>
    }
}

void Acpi_rmrr::parse() const
{
    for (uint64 hpa = base & ~PAGE_MASK; hpa < limit; hpa += PAGE_SIZE)
  200395:	5a                   	pop    %rdx
  200396:	59                   	pop    %rcx
  200397:	eb ca                	jmp    200363 <_ZNK9Acpi_rmrr5parseEv+0x11>
        Pd::kern.dpt.update (Pd::kern.quota, hpa, 0, hpa, Dpt::DPT_R | Dpt::DPT_W);

    for (Acpi_scope const *s = scope; s < reinterpret_cast<Acpi_scope *>(reinterpret_cast<mword>(this) + length); s = reinterpret_cast<Acpi_scope *>(reinterpret_cast<mword>(s) + s->length)) {
  200399:	48 8d 5d 18          	lea    0x18(%rbp),%rbx
  20039d:	0f b7 45 02          	movzwl 0x2(%rbp),%eax
  2003a1:	48 01 e8             	add    %rbp,%rax
  2003a4:	48 39 c3             	cmp    %rax,%rbx
  2003a7:	73 58                	jae    200401 <_ZNK9Acpi_rmrr5parseEv+0xaf>

        Dmar *dmar = nullptr;

        switch (s->type) {
  2003a9:	80 3b 01             	cmpb   $0x1,(%rbx)
  2003ac:	75 4a                	jne    2003f8 <_ZNK9Acpi_rmrr5parseEv+0xa6>
  2003ae:	0f b6 73 05          	movzbl 0x5(%rbx),%esi
  2003b2:	0f b6 43 06          	movzbl 0x6(%rbx),%eax
  2003b6:	c1 e6 08             	shl    $0x8,%esi
  2003b9:	c1 e0 03             	shl    $0x3,%eax
  2003bc:	09 c6                	or     %eax,%esi
  2003be:	0f b6 43 07          	movzbl 0x7(%rbx),%eax
  2003c2:	09 c6                	or     %eax,%esi
        inline void write (Register r, T v) { *reinterpret_cast<T volatile *>(reg_base + r) = v; }

        ALWAYS_INLINE
        static inline Pci *find_dev (unsigned long r)
        {
            for (Pci *pci = list; pci; pci = pci->next)
  2003c4:	48 8b 05 25 35 f6 80 	mov    -0x7f09cadb(%rip),%rax        # ffffffff811638f0 <_ZN3Pci4listE>
            case 1:
                dmar = Pci::find_dmar (s->rid());
  2003cb:	48 63 f6             	movslq %esi,%rsi
  2003ce:	48 85 c0             	test   %rax,%rax
  2003d1:	74 25                	je     2003f8 <_ZNK9Acpi_rmrr5parseEv+0xa6>
                if (pci->rid == r)
  2003d3:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  2003d7:	48 39 f2             	cmp    %rsi,%rdx
  2003da:	75 17                	jne    2003f3 <_ZNK9Acpi_rmrr5parseEv+0xa1>
        ALWAYS_INLINE
        static inline Dmar *find_dmar (unsigned long r)
        {
            Pci *pci = find_dev (r);

            return pci ? pci->dmar : nullptr;
  2003dc:	48 8b 78 18          	mov    0x18(%rax),%rdi
                break;
        }

        if (dmar)
  2003e0:	48 85 ff             	test   %rdi,%rdi
  2003e3:	74 13                	je     2003f8 <_ZNK9Acpi_rmrr5parseEv+0xa6>
            dmar->assign (s->rid(), &Pd::kern);
  2003e5:	48 c7 c2 a0 3c 16 81 	mov    $0xffffffff81163ca0,%rdx
  2003ec:	e8 13 2d e0 80       	callq  ffffffff81003104 <_ZN4Dmar6assignEmP2Pd>
  2003f1:	eb 05                	jmp    2003f8 <_ZNK9Acpi_rmrr5parseEv+0xa6>
        inline void write (Register r, T v) { *reinterpret_cast<T volatile *>(reg_base + r) = v; }

        ALWAYS_INLINE
        static inline Pci *find_dev (unsigned long r)
        {
            for (Pci *pci = list; pci; pci = pci->next)
  2003f3:	48 8b 00             	mov    (%rax),%rax
  2003f6:	eb d6                	jmp    2003ce <_ZNK9Acpi_rmrr5parseEv+0x7c>
void Acpi_rmrr::parse() const
{
    for (uint64 hpa = base & ~PAGE_MASK; hpa < limit; hpa += PAGE_SIZE)
        Pd::kern.dpt.update (Pd::kern.quota, hpa, 0, hpa, Dpt::DPT_R | Dpt::DPT_W);

    for (Acpi_scope const *s = scope; s < reinterpret_cast<Acpi_scope *>(reinterpret_cast<mword>(this) + length); s = reinterpret_cast<Acpi_scope *>(reinterpret_cast<mword>(s) + s->length)) {
  2003f8:	0f b6 43 01          	movzbl 0x1(%rbx),%eax
  2003fc:	48 01 c3             	add    %rax,%rbx
  2003ff:	eb 9c                	jmp    20039d <_ZNK9Acpi_rmrr5parseEv+0x4b>
        }

        if (dmar)
            dmar->assign (s->rid(), &Pd::kern);
    }
}
  200401:	58                   	pop    %rax
  200402:	5b                   	pop    %rbx
  200403:	5d                   	pop    %rbp
  200404:	c3                   	retq   
  200405:	90                   	nop

0000000000200406 <_ZNK15Acpi_table_dmar5parseEv>:

void Acpi_table_dmar::parse() const
{
    if (!Cmdline::iommu)
  200406:	80 3d 93 19 e2 80 00 	cmpb   $0x0,-0x7f1de66d(%rip)        # ffffffff81021da0 <_ZN7Cmdline5iommuE>
  20040d:	0f 84 87 00 00 00    	je     20049a <_ZNK15Acpi_table_dmar5parseEv+0x94>
            dmar->assign (s->rid(), &Pd::kern);
    }
}

void Acpi_table_dmar::parse() const
{
  200413:	55                   	push   %rbp
  200414:	53                   	push   %rbx
    if (!Cmdline::iommu)
        return;

    for (Acpi_remap const *r = remap; r < reinterpret_cast<Acpi_remap *>(reinterpret_cast<mword>(this) + length); r = reinterpret_cast<Acpi_remap *>(reinterpret_cast<mword>(r) + r->length)) {
  200415:	48 8d 5f 30          	lea    0x30(%rdi),%rbx
            dmar->assign (s->rid(), &Pd::kern);
    }
}

void Acpi_table_dmar::parse() const
{
  200419:	52                   	push   %rdx
  20041a:	48 89 fd             	mov    %rdi,%rbp
    if (!Cmdline::iommu)
        return;

    for (Acpi_remap const *r = remap; r < reinterpret_cast<Acpi_remap *>(reinterpret_cast<mword>(this) + length); r = reinterpret_cast<Acpi_remap *>(reinterpret_cast<mword>(r) + r->length)) {
  20041d:	8b 45 04             	mov    0x4(%rbp),%eax
  200420:	48 01 e8             	add    %rbp,%rax
  200423:	48 39 c3             	cmp    %rax,%rbx
  200426:	73 28                	jae    200450 <_ZNK15Acpi_table_dmar5parseEv+0x4a>
        switch (r->type) {
  200428:	66 8b 03             	mov    (%rbx),%ax
  20042b:	66 85 c0             	test   %ax,%ax
  20042e:	74 0f                	je     20043f <_ZNK15Acpi_table_dmar5parseEv+0x39>
  200430:	66 ff c8             	dec    %ax
  200433:	75 12                	jne    200447 <_ZNK15Acpi_table_dmar5parseEv+0x41>
            case Acpi_remap::DMAR:
                static_cast<Acpi_dmar const *>(r)->parse();
                break;
            case Acpi_remap::RMRR:
                static_cast<Acpi_rmrr const *>(r)->parse();
  200435:	48 89 df             	mov    %rbx,%rdi
  200438:	e8 15 ff ff ff       	callq  200352 <_ZNK9Acpi_rmrr5parseEv>
                break;
  20043d:	eb 08                	jmp    200447 <_ZNK15Acpi_table_dmar5parseEv+0x41>
        return;

    for (Acpi_remap const *r = remap; r < reinterpret_cast<Acpi_remap *>(reinterpret_cast<mword>(this) + length); r = reinterpret_cast<Acpi_remap *>(reinterpret_cast<mword>(r) + r->length)) {
        switch (r->type) {
            case Acpi_remap::DMAR:
                static_cast<Acpi_dmar const *>(r)->parse();
  20043f:	48 89 df             	mov    %rbx,%rdi
  200442:	e8 97 fd ff ff       	callq  2001de <_ZNK9Acpi_dmar5parseEv>
void Acpi_table_dmar::parse() const
{
    if (!Cmdline::iommu)
        return;

    for (Acpi_remap const *r = remap; r < reinterpret_cast<Acpi_remap *>(reinterpret_cast<mword>(this) + length); r = reinterpret_cast<Acpi_remap *>(reinterpret_cast<mword>(r) + r->length)) {
  200447:	0f b7 43 02          	movzwl 0x2(%rbx),%eax
  20044b:	48 01 c3             	add    %rax,%rbx
  20044e:	eb cd                	jmp    20041d <_ZNK15Acpi_table_dmar5parseEv+0x17>

        ALWAYS_INLINE
        static inline void enable (unsigned flags)
        {
            if (!(flags & 1))
  200450:	f6 45 25 01          	testb  $0x1,0x25(%rbp)
  200454:	75 0a                	jne    200460 <_ZNK15Acpi_table_dmar5parseEv+0x5a>
                gcmd &= ~GCMD_IRE;
  200456:	81 25 18 12 e2 80 ff 	andl   $0xfdffffff,-0x7f1dede8(%rip)        # ffffffff81021678 <CTORS_E>
  20045d:	ff ff fd 

            for (Dmar *dmar = list; dmar; dmar = dmar->next)
  200460:	48 8b 05 f9 1b f6 80 	mov    -0x7f09e407(%rip),%rax        # ffffffff81162060 <_ZN4Dmar4listE>
  200467:	48 85 c0             	test   %rax,%rax
  20046a:	74 23                	je     20048f <_ZNK15Acpi_table_dmar5parseEv+0x89>
                dmar->command (gcmd);
  20046c:	8b 15 06 12 e2 80    	mov    -0x7f1dedfa(%rip),%edx        # ffffffff81021678 <CTORS_E>

        template <typename T>
        ALWAYS_INLINE
        inline void write (Reg reg, T val)
        {
            *reinterpret_cast<T volatile *>(reg_base + reg) = val;
  200472:	48 8b 48 08          	mov    0x8(%rax),%rcx
  200476:	89 51 18             	mov    %edx,0x18(%rcx)

        template <typename T>
        ALWAYS_INLINE
        inline T read (Reg reg)
        {
            return *reinterpret_cast<T volatile *>(reg_base + reg);
  200479:	48 8b 48 08          	mov    0x8(%rax),%rcx
  20047d:	8b 49 1c             	mov    0x1c(%rcx),%ecx

        ALWAYS_INLINE
        inline void command (uint32 val)
        {
            write<uint32>(REG_GCMD, val);
            while ((read<uint32>(REG_GSTS) & val) != val)
  200480:	21 d1                	and    %edx,%ecx
  200482:	39 d1                	cmp    %edx,%ecx
  200484:	74 04                	je     20048a <_ZNK15Acpi_table_dmar5parseEv+0x84>
}

ALWAYS_INLINE
static inline void pause()
{
    asm volatile ("pause" : : : "memory");
  200486:	f3 90                	pause  
  200488:	eb ef                	jmp    200479 <_ZNK15Acpi_table_dmar5parseEv+0x73>
        static inline void enable (unsigned flags)
        {
            if (!(flags & 1))
                gcmd &= ~GCMD_IRE;

            for (Dmar *dmar = list; dmar; dmar = dmar->next)
  20048a:	48 8b 00             	mov    (%rax),%rax
  20048d:	eb d8                	jmp    200467 <_ZNK15Acpi_table_dmar5parseEv+0x61>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }
  20048f:	f0 83 0d 79 6b f6 80 	lock orl $0x1,-0x7f099487(%rip)        # ffffffff81167010 <PAGE_H+0x10>
  200496:	01 
    }

    Dmar::enable (flags);

    Hip::set_feature (Hip::FEAT_IOMMU);
}
  200497:	58                   	pop    %rax
  200498:	5b                   	pop    %rbx
  200499:	5d                   	pop    %rbp
  20049a:	c3                   	retq   
  20049b:	90                   	nop

000000000020049c <_ZNK15Acpi_table_fadt5parseEv>:
#include "io.hpp"
#include "x86.hpp"

void Acpi_table_fadt::parse() const
{
    Acpi::irq     = sci_irq;
  20049c:	0f b7 47 2e          	movzwl 0x2e(%rdi),%eax
  2004a0:	89 05 62 17 e2 80    	mov    %eax,-0x7f1de89e(%rip)        # ffffffff81021c08 <_ZN4Acpi3irqE>
    Acpi::feature = flags;
  2004a6:	8b 47 70             	mov    0x70(%rdi),%eax
  2004a9:	89 05 61 17 e2 80    	mov    %eax,-0x7f1de89f(%rip)        # ffffffff81021c10 <_ZN4Acpi7featureE>

    // XXX: Use x_pm blocks if they exist

    if (pm1a_evt_blk) {
  2004af:	8b 47 38             	mov    0x38(%rdi),%eax
  2004b2:	85 c0                	test   %eax,%eax
  2004b4:	74 39                	je     2004ef <_ZNK15Acpi_table_fadt5parseEv+0x53>
        Acpi::pm1a_sts.init (Acpi_gas::IO, pm1_evt_len >> 1, pm1a_evt_blk);
  2004b6:	0f b6 57 58          	movzbl 0x58(%rdi),%edx
  2004ba:	89 c6                	mov    %eax,%esi
            FIXED       = 0x7f
        };

        void init (Asid reg_asid, unsigned reg_bytes, uint64 reg_addr)
        {
            asid = reg_asid;
  2004bc:	c6 05 15 18 e2 80 01 	movb   $0x1,-0x7f1de7eb(%rip)        # ffffffff81021cd8 <_ZN4Acpi8pm1a_stsE>
  2004c3:	48 89 35 12 18 e2 80 	mov    %rsi,-0x7f1de7ee(%rip)        # ffffffff81021cdc <_ZN4Acpi8pm1a_stsE+0x4>
  2004ca:	c6 05 e7 17 e2 80 01 	movb   $0x1,-0x7f1de819(%rip)        # ffffffff81021cb8 <_ZN4Acpi8pm1a_enaE>
  2004d1:	d1 fa                	sar    %edx
            bits = static_cast<uint8>(reg_bytes * 8);
  2004d3:	8d 0c d5 00 00 00 00 	lea    0x0(,%rdx,8),%ecx
        Acpi::pm1a_ena.init (Acpi_gas::IO, pm1_evt_len >> 1, pm1a_evt_blk + (pm1_evt_len >> 1));
  2004da:	01 d0                	add    %edx,%eax
  2004dc:	48 89 05 d9 17 e2 80 	mov    %rax,-0x7f1de827(%rip)        # ffffffff81021cbc <_ZN4Acpi8pm1a_enaE+0x4>
  2004e3:	88 0d f0 17 e2 80    	mov    %cl,-0x7f1de810(%rip)        # ffffffff81021cd9 <_ZN4Acpi8pm1a_stsE+0x1>
  2004e9:	88 0d ca 17 e2 80    	mov    %cl,-0x7f1de836(%rip)        # ffffffff81021cb9 <_ZN4Acpi8pm1a_enaE+0x1>
    }
    if (pm1b_evt_blk) {
  2004ef:	8b 47 3c             	mov    0x3c(%rdi),%eax
  2004f2:	85 c0                	test   %eax,%eax
  2004f4:	74 39                	je     20052f <_ZNK15Acpi_table_fadt5parseEv+0x93>
        Acpi::pm1b_sts.init (Acpi_gas::IO, pm1_evt_len >> 1, pm1b_evt_blk);
  2004f6:	0f b6 57 58          	movzbl 0x58(%rdi),%edx
  2004fa:	89 c6                	mov    %eax,%esi
            FIXED       = 0x7f
        };

        void init (Asid reg_asid, unsigned reg_bytes, uint64 reg_addr)
        {
            asid = reg_asid;
  2004fc:	c6 05 c5 17 e2 80 01 	movb   $0x1,-0x7f1de83b(%rip)        # ffffffff81021cc8 <_ZN4Acpi8pm1b_stsE>
  200503:	48 89 35 c2 17 e2 80 	mov    %rsi,-0x7f1de83e(%rip)        # ffffffff81021ccc <_ZN4Acpi8pm1b_stsE+0x4>
  20050a:	c6 05 97 17 e2 80 01 	movb   $0x1,-0x7f1de869(%rip)        # ffffffff81021ca8 <_ZN4Acpi8pm1b_enaE>
  200511:	d1 fa                	sar    %edx
            bits = static_cast<uint8>(reg_bytes * 8);
  200513:	8d 0c d5 00 00 00 00 	lea    0x0(,%rdx,8),%ecx
        Acpi::pm1b_ena.init (Acpi_gas::IO, pm1_evt_len >> 1, pm1b_evt_blk + (pm1_evt_len >> 1));
  20051a:	01 d0                	add    %edx,%eax
  20051c:	48 89 05 89 17 e2 80 	mov    %rax,-0x7f1de877(%rip)        # ffffffff81021cac <_ZN4Acpi8pm1b_enaE+0x4>
  200523:	88 0d a0 17 e2 80    	mov    %cl,-0x7f1de860(%rip)        # ffffffff81021cc9 <_ZN4Acpi8pm1b_stsE+0x1>
  200529:	88 0d 7a 17 e2 80    	mov    %cl,-0x7f1de886(%rip)        # ffffffff81021ca9 <_ZN4Acpi8pm1b_enaE+0x1>
    }

    if (pm1a_cnt_blk)
  20052f:	8b 57 40             	mov    0x40(%rdi),%edx
  200532:	85 d2                	test   %edx,%edx
  200534:	74 1c                	je     200552 <_ZNK15Acpi_table_fadt5parseEv+0xb6>
  200536:	8a 47 59             	mov    0x59(%rdi),%al
            FIXED       = 0x7f
        };

        void init (Asid reg_asid, unsigned reg_bytes, uint64 reg_addr)
        {
            asid = reg_asid;
  200539:	c6 05 58 17 e2 80 01 	movb   $0x1,-0x7f1de8a8(%rip)        # ffffffff81021c98 <_ZN4Acpi8pm1a_cntE>
            bits = static_cast<uint8>(reg_bytes * 8);
  200540:	c1 e0 03             	shl    $0x3,%eax
  200543:	88 05 50 17 e2 80    	mov    %al,-0x7f1de8b0(%rip)        # ffffffff81021c99 <_ZN4Acpi8pm1a_cntE+0x1>
        Acpi::pm1a_cnt.init (Acpi_gas::IO, pm1_cnt_len, pm1a_cnt_blk);
  200549:	89 d0                	mov    %edx,%eax
  20054b:	48 89 05 4a 17 e2 80 	mov    %rax,-0x7f1de8b6(%rip)        # ffffffff81021c9c <_ZN4Acpi8pm1a_cntE+0x4>

    if (pm1b_cnt_blk)
  200552:	8b 57 44             	mov    0x44(%rdi),%edx
  200555:	85 d2                	test   %edx,%edx
  200557:	74 1c                	je     200575 <_ZNK15Acpi_table_fadt5parseEv+0xd9>
  200559:	8a 47 59             	mov    0x59(%rdi),%al
            FIXED       = 0x7f
        };

        void init (Asid reg_asid, unsigned reg_bytes, uint64 reg_addr)
        {
            asid = reg_asid;
  20055c:	c6 05 25 17 e2 80 01 	movb   $0x1,-0x7f1de8db(%rip)        # ffffffff81021c88 <_ZN4Acpi8pm1b_cntE>
            bits = static_cast<uint8>(reg_bytes * 8);
  200563:	c1 e0 03             	shl    $0x3,%eax
  200566:	88 05 1d 17 e2 80    	mov    %al,-0x7f1de8e3(%rip)        # ffffffff81021c89 <_ZN4Acpi8pm1b_cntE+0x1>
        Acpi::pm1b_cnt.init (Acpi_gas::IO, pm1_cnt_len, pm1b_cnt_blk);
  20056c:	89 d0                	mov    %edx,%eax
  20056e:	48 89 05 17 17 e2 80 	mov    %rax,-0x7f1de8e9(%rip)        # ffffffff81021c8c <_ZN4Acpi8pm1b_cntE+0x4>

    if (pm2_cnt_blk)
  200575:	8b 57 48             	mov    0x48(%rdi),%edx
  200578:	85 d2                	test   %edx,%edx
  20057a:	74 1c                	je     200598 <_ZNK15Acpi_table_fadt5parseEv+0xfc>
  20057c:	8a 47 5a             	mov    0x5a(%rdi),%al
            FIXED       = 0x7f
        };

        void init (Asid reg_asid, unsigned reg_bytes, uint64 reg_addr)
        {
            asid = reg_asid;
  20057f:	c6 05 f2 16 e2 80 01 	movb   $0x1,-0x7f1de90e(%rip)        # ffffffff81021c78 <_ZN4Acpi7pm2_cntE>
            bits = static_cast<uint8>(reg_bytes * 8);
  200586:	c1 e0 03             	shl    $0x3,%eax
  200589:	88 05 ea 16 e2 80    	mov    %al,-0x7f1de916(%rip)        # ffffffff81021c79 <_ZN4Acpi7pm2_cntE+0x1>
        Acpi::pm2_cnt.init (Acpi_gas::IO, pm2_cnt_len, pm2_cnt_blk);
  20058f:	89 d0                	mov    %edx,%eax
  200591:	48 89 05 e4 16 e2 80 	mov    %rax,-0x7f1de91c(%rip)        # ffffffff81021c7c <_ZN4Acpi7pm2_cntE+0x4>

    if (pm_tmr_blk)
  200598:	8b 57 4c             	mov    0x4c(%rdi),%edx
  20059b:	85 d2                	test   %edx,%edx
  20059d:	74 1c                	je     2005bb <_ZNK15Acpi_table_fadt5parseEv+0x11f>
  20059f:	8a 47 5b             	mov    0x5b(%rdi),%al
            FIXED       = 0x7f
        };

        void init (Asid reg_asid, unsigned reg_bytes, uint64 reg_addr)
        {
            asid = reg_asid;
  2005a2:	c6 05 bf 16 e2 80 01 	movb   $0x1,-0x7f1de941(%rip)        # ffffffff81021c68 <_ZN4Acpi6pm_tmrE>
            bits = static_cast<uint8>(reg_bytes * 8);
  2005a9:	c1 e0 03             	shl    $0x3,%eax
  2005ac:	88 05 b7 16 e2 80    	mov    %al,-0x7f1de949(%rip)        # ffffffff81021c69 <_ZN4Acpi6pm_tmrE+0x1>
        Acpi::pm_tmr.init (Acpi_gas::IO, pm_tmr_len, pm_tmr_blk);
  2005b2:	89 d0                	mov    %edx,%eax
  2005b4:	48 89 05 b1 16 e2 80 	mov    %rax,-0x7f1de94f(%rip)        # ffffffff81021c6c <_ZN4Acpi6pm_tmrE+0x4>

    if (gpe0_blk) {
  2005bb:	8b 47 50             	mov    0x50(%rdi),%eax
  2005be:	85 c0                	test   %eax,%eax
  2005c0:	74 39                	je     2005fb <_ZNK15Acpi_table_fadt5parseEv+0x15f>
        Acpi::gpe0_sts.init (Acpi_gas::IO, gpe0_blk_len >> 1, gpe0_blk);
  2005c2:	0f b6 57 5c          	movzbl 0x5c(%rdi),%edx
  2005c6:	89 c6                	mov    %eax,%esi
            FIXED       = 0x7f
        };

        void init (Asid reg_asid, unsigned reg_bytes, uint64 reg_addr)
        {
            asid = reg_asid;
  2005c8:	c6 05 79 16 e2 80 01 	movb   $0x1,-0x7f1de987(%rip)        # ffffffff81021c48 <_ZN4Acpi8gpe0_stsE>
  2005cf:	48 89 35 76 16 e2 80 	mov    %rsi,-0x7f1de98a(%rip)        # ffffffff81021c4c <_ZN4Acpi8gpe0_stsE+0x4>
  2005d6:	c6 05 4b 16 e2 80 01 	movb   $0x1,-0x7f1de9b5(%rip)        # ffffffff81021c28 <_ZN4Acpi8gpe0_enaE>
  2005dd:	d1 fa                	sar    %edx
            bits = static_cast<uint8>(reg_bytes * 8);
  2005df:	8d 0c d5 00 00 00 00 	lea    0x0(,%rdx,8),%ecx
        Acpi::gpe0_ena.init (Acpi_gas::IO, gpe0_blk_len >> 1, gpe0_blk + (gpe0_blk_len >> 1));
  2005e6:	01 d0                	add    %edx,%eax
  2005e8:	48 89 05 3d 16 e2 80 	mov    %rax,-0x7f1de9c3(%rip)        # ffffffff81021c2c <_ZN4Acpi8gpe0_enaE+0x4>
  2005ef:	88 0d 54 16 e2 80    	mov    %cl,-0x7f1de9ac(%rip)        # ffffffff81021c49 <_ZN4Acpi8gpe0_stsE+0x1>
  2005f5:	88 0d 2e 16 e2 80    	mov    %cl,-0x7f1de9d2(%rip)        # ffffffff81021c29 <_ZN4Acpi8gpe0_enaE+0x1>
    }

    if (gpe1_blk) {
  2005fb:	8b 47 54             	mov    0x54(%rdi),%eax
  2005fe:	85 c0                	test   %eax,%eax
  200600:	74 39                	je     20063b <_ZNK15Acpi_table_fadt5parseEv+0x19f>
        Acpi::gpe1_sts.init (Acpi_gas::IO, gpe1_blk_len >> 1, gpe1_blk);
  200602:	0f b6 57 5d          	movzbl 0x5d(%rdi),%edx
  200606:	89 c6                	mov    %eax,%esi
            FIXED       = 0x7f
        };

        void init (Asid reg_asid, unsigned reg_bytes, uint64 reg_addr)
        {
            asid = reg_asid;
  200608:	c6 05 29 16 e2 80 01 	movb   $0x1,-0x7f1de9d7(%rip)        # ffffffff81021c38 <_ZN4Acpi8gpe1_stsE>
  20060f:	48 89 35 26 16 e2 80 	mov    %rsi,-0x7f1de9da(%rip)        # ffffffff81021c3c <_ZN4Acpi8gpe1_stsE+0x4>
  200616:	c6 05 fb 15 e2 80 01 	movb   $0x1,-0x7f1dea05(%rip)        # ffffffff81021c18 <_ZN4Acpi8gpe1_enaE>
  20061d:	d1 fa                	sar    %edx
            bits = static_cast<uint8>(reg_bytes * 8);
  20061f:	8d 0c d5 00 00 00 00 	lea    0x0(,%rdx,8),%ecx
        Acpi::gpe1_ena.init (Acpi_gas::IO, gpe1_blk_len >> 1, gpe1_blk + (gpe1_blk_len >> 1));
  200626:	01 d0                	add    %edx,%eax
  200628:	48 89 05 ed 15 e2 80 	mov    %rax,-0x7f1dea13(%rip)        # ffffffff81021c1c <_ZN4Acpi8gpe1_enaE+0x4>
  20062f:	88 0d 04 16 e2 80    	mov    %cl,-0x7f1de9fc(%rip)        # ffffffff81021c39 <_ZN4Acpi8gpe1_stsE+0x1>
  200635:	88 0d de 15 e2 80    	mov    %cl,-0x7f1dea22(%rip)        # ffffffff81021c19 <_ZN4Acpi8gpe1_enaE+0x1>
    }

    if (length >= 129) {
  20063b:	81 7f 04 80 00 00 00 	cmpl   $0x80,0x4(%rdi)
  200642:	76 20                	jbe    200664 <_ZNK15Acpi_table_fadt5parseEv+0x1c8>
        Acpi::reset_reg = reset_reg;
  200644:	48 8b 47 74          	mov    0x74(%rdi),%rax
  200648:	48 89 05 09 16 e2 80 	mov    %rax,-0x7f1de9f7(%rip)        # ffffffff81021c58 <_ZN4Acpi9reset_regE>
  20064f:	8b 47 7c             	mov    0x7c(%rdi),%eax
  200652:	89 05 08 16 e2 80    	mov    %eax,-0x7f1de9f8(%rip)        # ffffffff81021c60 <_ZN4Acpi9reset_regE+0x8>
        Acpi::reset_val = reset_value;
  200658:	8a 87 80 00 00 00    	mov    0x80(%rdi),%al
  20065e:	88 05 a8 15 e2 80    	mov    %al,-0x7f1dea58(%rip)        # ffffffff81021c0c <_ZN4Acpi9reset_valE>
    }

    if (smi_cmd && acpi_enable) {
  200664:	8b 57 30             	mov    0x30(%rdi),%edx
  200667:	85 d2                	test   %edx,%edx
  200669:	74 1c                	je     200687 <_ZNK15Acpi_table_fadt5parseEv+0x1eb>
  20066b:	8a 47 34             	mov    0x34(%rdi),%al
  20066e:	84 c0                	test   %al,%al
  200670:	74 15                	je     200687 <_ZNK15Acpi_table_fadt5parseEv+0x1eb>
#include "acpi_fadt.hpp"
#include "io.hpp"
#include "x86.hpp"

void Acpi_table_fadt::parse() const
{
  200672:	51                   	push   %rcx

        template <typename T>
        ALWAYS_INLINE
        static inline void out (unsigned port, T val)
        {
            asm volatile ("out %0, %w1" : : "a" (val), "Nd" (port));
  200673:	ee                   	out    %al,(%dx)
        Acpi::reset_val = reset_value;
    }

    if (smi_cmd && acpi_enable) {
        Io::out (smi_cmd, acpi_enable);
        while (!(Acpi::read (Acpi::PM1_CNT) & Acpi::PM1_CNT_SCI_EN))
  200674:	bf 02 00 00 00       	mov    $0x2,%edi
  200679:	e8 ae 05 e0 80       	callq  ffffffff81000c2c <_ZN4Acpi4readENS_8RegisterE>
  20067e:	a8 01                	test   $0x1,%al
  200680:	75 04                	jne    200686 <_ZNK15Acpi_table_fadt5parseEv+0x1ea>
  200682:	f3 90                	pause  
  200684:	eb ee                	jmp    200674 <_ZNK15Acpi_table_fadt5parseEv+0x1d8>
            pause();
    }
}
  200686:	58                   	pop    %rax
  200687:	c3                   	retq   

0000000000200688 <_ZNK15Acpi_table_hpet5parseEv>:
#include "hpet.hpp"
#include "pd.hpp"

void Acpi_table_hpet::parse() const
{
    if (hpet.asid == Acpi_gas::MEMORY)
  200688:	80 7f 28 00          	cmpb   $0x0,0x28(%rdi)
  20068c:	75 52                	jne    2006e0 <_ZNK15Acpi_table_hpet5parseEv+0x58>
#include "acpi_hpet.hpp"
#include "hpet.hpp"
#include "pd.hpp"

void Acpi_table_hpet::parse() const
{
  20068e:	53                   	push   %rbx
    public:
        ALWAYS_INLINE
        explicit inline Hpet (Paddr p, unsigned i) : List<Hpet> (list), phys (p), id (i), rid (0) {}

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
  20068f:	48 c7 c6 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rsi
  200696:	48 89 fb             	mov    %rdi,%rbx
  200699:	48 c7 c7 60 2d 16 81 	mov    $0xffffffff81162d60,%rdi
  2006a0:	e8 89 52 e1 80       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
    if (hpet.asid == Acpi_gas::MEMORY)
        new (Pd::kern.quota) Hpet (static_cast<Paddr>(hpet.addr), id);
  2006a5:	0f b6 73 34          	movzbl 0x34(%rbx),%esi
  2006a9:	48 8b 7b 2c          	mov    0x2c(%rbx),%rdi

    public:
        ALWAYS_INLINE
        explicit inline List (T *&list) : next (nullptr)
        {
            T **ptr; for (ptr = &list; *ptr; ptr = &(*ptr)->next) ; *ptr = static_cast<T *>(this);
  2006ad:	48 c7 c1 50 2d 16 81 	mov    $0xffffffff81162d50,%rcx
    protected:
        T *next;

    public:
        ALWAYS_INLINE
        explicit inline List (T *&list) : next (nullptr)
  2006b4:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
        {
            T **ptr; for (ptr = &list; *ptr; ptr = &(*ptr)->next) ; *ptr = static_cast<T *>(this);
  2006bb:	48 8b 15 8e 26 f6 80 	mov    -0x7f09d972(%rip),%rdx        # ffffffff81162d50 <_ZN4Hpet4listE>
  2006c2:	48 85 d2             	test   %rdx,%rdx
  2006c5:	74 08                	je     2006cf <_ZNK15Acpi_table_hpet5parseEv+0x47>
  2006c7:	48 89 d1             	mov    %rdx,%rcx
  2006ca:	48 8b 12             	mov    (%rdx),%rdx
  2006cd:	eb f3                	jmp    2006c2 <_ZNK15Acpi_table_hpet5parseEv+0x3a>
  2006cf:	48 89 01             	mov    %rax,(%rcx)
        static Hpet *       list;
        static Slab_cache   cache;

    public:
        ALWAYS_INLINE
        explicit inline Hpet (Paddr p, unsigned i) : List<Hpet> (list), phys (p), id (i), rid (0) {}
  2006d2:	48 89 78 08          	mov    %rdi,0x8(%rax)
  2006d6:	89 70 10             	mov    %esi,0x10(%rax)
  2006d9:	66 c7 40 14 00 00    	movw   $0x0,0x14(%rax)
}
  2006df:	5b                   	pop    %rbx
  2006e0:	c3                   	retq   
  2006e1:	90                   	nop

00000000002006e2 <_ZN15Acpi_table_madt10parse_intrEPK9Acpi_apic>:

void Acpi_table_madt::parse_intr (Acpi_apic const *ptr)
{
    Acpi_intr const *p = static_cast<Acpi_intr const *>(ptr);

    unsigned irq = p->irq;
  2006e2:	0f b6 77 03          	movzbl 0x3(%rdi),%esi
    unsigned gsi = p->gsi;
  2006e6:	8b 47 04             	mov    0x4(%rdi),%eax

    if (EXPECT_FALSE (gsi >= NUM_GSI || irq >= NUM_IRQ || p->bus))
  2006e9:	83 fe 0f             	cmp    $0xf,%esi
  2006ec:	0f 97 c1             	seta   %cl
  2006ef:	83 f8 7f             	cmp    $0x7f,%eax
  2006f2:	0f 97 c2             	seta   %dl
  2006f5:	08 ca                	or     %cl,%dl
  2006f7:	0f 85 93 00 00 00    	jne    200790 <_ZN15Acpi_table_madt10parse_intrEPK9Acpi_apic+0xae>
  2006fd:	80 7f 02 00          	cmpb   $0x0,0x2(%rdi)
  200701:	0f 85 89 00 00 00    	jne    200790 <_ZN15Acpi_table_madt10parse_intrEPK9Acpi_apic+0xae>
        return;

    Gsi::irq_table[irq] = gsi;
  200707:	89 f1                	mov    %esi,%ecx
  200709:	89 04 8d 00 21 16 81 	mov    %eax,-0x7ee9df00(,%rcx,4)

    Gsi::gsi_table[gsi].pol = p->flags.pol == Acpi_inti::POL_LOW   || (p->flags.pol == Acpi_inti::POL_CONFORMING && irq == Acpi::irq);
  200710:	44 8a 47 08          	mov    0x8(%rdi),%r8b
  200714:	b1 01                	mov    $0x1,%cl
  200716:	41 83 e0 03          	and    $0x3,%r8d
  20071a:	41 80 f8 03          	cmp    $0x3,%r8b
  20071e:	74 10                	je     200730 <_ZN15Acpi_table_madt10parse_intrEPK9Acpi_apic+0x4e>
  200720:	31 c9                	xor    %ecx,%ecx
  200722:	45 84 c0             	test   %r8b,%r8b
  200725:	75 09                	jne    200730 <_ZN15Acpi_table_madt10parse_intrEPK9Acpi_apic+0x4e>
  200727:	3b 35 db 14 e2 80    	cmp    -0x7f1deb25(%rip),%esi        # ffffffff81021c08 <_ZN4Acpi3irqE>
  20072d:	0f 94 c1             	sete   %cl
  200730:	4c 6b c0 18          	imul   $0x18,%rax,%r8
  200734:	c1 e1 05             	shl    $0x5,%ecx
  200737:	45 8a 88 51 21 16 81 	mov    -0x7ee9deaf(%r8),%r9b
  20073e:	41 83 e1 df          	and    $0xffffffdf,%r9d
  200742:	44 09 c9             	or     %r9d,%ecx
  200745:	41 88 88 51 21 16 81 	mov    %cl,-0x7ee9deaf(%r8)
    Gsi::gsi_table[gsi].trg = p->flags.trg == Acpi_inti::TRG_LEVEL || (p->flags.trg == Acpi_inti::TRG_CONFORMING && irq == Acpi::irq);
  20074c:	8a 4f 08             	mov    0x8(%rdi),%cl
  20074f:	83 e1 0c             	and    $0xc,%ecx
  200752:	80 f9 0c             	cmp    $0xc,%cl
  200755:	74 0f                	je     200766 <_ZN15Acpi_table_madt10parse_intrEPK9Acpi_apic+0x84>
  200757:	84 c9                	test   %cl,%cl
  200759:	75 0d                	jne    200768 <_ZN15Acpi_table_madt10parse_intrEPK9Acpi_apic+0x86>
  20075b:	3b 35 a7 14 e2 80    	cmp    -0x7f1deb59(%rip),%esi        # ffffffff81021c08 <_ZN4Acpi3irqE>
  200761:	0f 94 c2             	sete   %dl
  200764:	eb 02                	jmp    200768 <_ZN15Acpi_table_madt10parse_intrEPK9Acpi_apic+0x86>
  200766:	b2 01                	mov    $0x1,%dl
  200768:	48 6b c0 18          	imul   $0x18,%rax,%rax
  20076c:	c1 e2 07             	shl    $0x7,%edx
  20076f:	8a 88 51 21 16 81    	mov    -0x7ee9deaf(%rax),%cl
  200775:	83 e1 7f             	and    $0x7f,%ecx
  200778:	09 ca                	or     %ecx,%edx

    if (irq == Acpi::irq)
  20077a:	3b 35 88 14 e2 80    	cmp    -0x7f1deb78(%rip),%esi        # ffffffff81021c08 <_ZN4Acpi3irqE>
        return;

    Gsi::irq_table[irq] = gsi;

    Gsi::gsi_table[gsi].pol = p->flags.pol == Acpi_inti::POL_LOW   || (p->flags.pol == Acpi_inti::POL_CONFORMING && irq == Acpi::irq);
    Gsi::gsi_table[gsi].trg = p->flags.trg == Acpi_inti::TRG_LEVEL || (p->flags.trg == Acpi_inti::TRG_CONFORMING && irq == Acpi::irq);
  200780:	88 90 51 21 16 81    	mov    %dl,-0x7ee9deaf(%rax)

    if (irq == Acpi::irq)
  200786:	75 08                	jne    200790 <_ZN15Acpi_table_madt10parse_intrEPK9Acpi_apic+0xae>
        sci_overridden = true;
  200788:	c6 05 71 14 e2 80 01 	movb   $0x1,-0x7f1deb8f(%rip)        # ffffffff81021c00 <_ZN15Acpi_table_madt14sci_overriddenE>
  20078f:	c3                   	retq   
  200790:	c3                   	retq   
  200791:	90                   	nop

0000000000200792 <_ZN15Acpi_table_madt11parse_lapicEPK9Acpi_apic>:

void Acpi_table_madt::parse_lapic (Acpi_apic const *ptr)
{
    Acpi_lapic const *p = static_cast<Acpi_lapic const *>(ptr);

    if (p->flags & 1 && Cpu::online < NUM_CPU) {
  200792:	f6 47 04 01          	testb  $0x1,0x4(%rdi)
  200796:	74 27                	je     2007bf <_ZN15Acpi_table_madt11parse_lapicEPK9Acpi_apic+0x2d>
  200798:	8b 05 a2 18 f6 80    	mov    -0x7f09e75e(%rip),%eax        # ffffffff81162040 <_ZN3Cpu6onlineE>
  20079e:	83 f8 3f             	cmp    $0x3f,%eax
  2007a1:	77 1c                	ja     2007bf <_ZN15Acpi_table_madt11parse_lapicEPK9Acpi_apic+0x2d>
        Cpu::acpi_id[Cpu::online]   = p->acpi_id;
  2007a3:	8a 4f 02             	mov    0x2(%rdi),%cl
  2007a6:	89 c2                	mov    %eax,%edx
        Cpu::apic_id[Cpu::online++] = p->apic_id;
  2007a8:	ff c0                	inc    %eax
  2007aa:	89 05 90 18 f6 80    	mov    %eax,-0x7f09e770(%rip)        # ffffffff81162040 <_ZN3Cpu6onlineE>
void Acpi_table_madt::parse_lapic (Acpi_apic const *ptr)
{
    Acpi_lapic const *p = static_cast<Acpi_lapic const *>(ptr);

    if (p->flags & 1 && Cpu::online < NUM_CPU) {
        Cpu::acpi_id[Cpu::online]   = p->acpi_id;
  2007b0:	88 8a 00 20 16 81    	mov    %cl,-0x7ee9e000(%rdx)
        Cpu::apic_id[Cpu::online++] = p->apic_id;
  2007b6:	8a 47 03             	mov    0x3(%rdi),%al
  2007b9:	88 82 c0 1f 16 81    	mov    %al,-0x7ee9e040(%rdx)
  2007bf:	c3                   	retq   

00000000002007c0 <_ZN15Acpi_table_madt12parse_ioapicEPK9Acpi_apic>:
    }
}

void Acpi_table_madt::parse_ioapic (Acpi_apic const *ptr)
{
  2007c0:	41 54                	push   %r12
  2007c2:	55                   	push   %rbp
    public:
        INIT
        Ioapic (Paddr, unsigned, unsigned);

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
  2007c3:	48 c7 c6 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rsi
  2007ca:	53                   	push   %rbx
  2007cb:	48 89 fd             	mov    %rdi,%rbp
  2007ce:	48 c7 c7 40 38 16 81 	mov    $0xffffffff81163840,%rdi
  2007d5:	e8 54 51 e1 80       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
    Acpi_ioapic const *p = static_cast<Acpi_ioapic const *>(ptr);

    Ioapic *ioapic = new (Pd::kern.quota) Ioapic (p->phys, p->id, p->gsi);
  2007da:	0f b6 55 02          	movzbl 0x2(%rbp),%edx
  2007de:	8b 75 04             	mov    0x4(%rbp),%esi
  2007e1:	48 89 c3             	mov    %rax,%rbx
  2007e4:	8b 4d 08             	mov    0x8(%rbp),%ecx
  2007e7:	48 89 c7             	mov    %rax,%rdi
  2007ea:	e8 71 0d 00 00       	callq  201560 <_ZN6IoapicC1Emjj>

    unsigned gsi = p->gsi;
  2007ef:	44 8b 65 08          	mov    0x8(%rbp),%r12d
        }

        ALWAYS_INLINE
        inline uint32 read (Register reg)
        {
            Lock_guard <Spinlock> guard (lock);
  2007f3:	48 8d 7b 1a          	lea    0x1a(%rbx),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
  2007f7:	9c                   	pushfq 
  2007f8:	58                   	pop    %rax
            return flags & 0x200;
  2007f9:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
  2007fd:	40 88 c5             	mov    %al,%bpl
  200800:	40 80 e5 01          	and    $0x1,%bpl
  200804:	74 2d                	je     200833 <_ZN15Acpi_table_madt12parse_ioapicEPK9Acpi_apic+0x73>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
  200806:	80 3d 23 ef df bf 00 	cmpb   $0x0,-0x402010dd(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
  20080d:	75 1c                	jne    20082b <_ZN15Acpi_table_madt12parse_ioapicEPK9Acpi_apic+0x6b>
  20080f:	49 c7 c0 d0 d3 01 81 	mov    $0xffffffff8101d3d0,%r8
  200816:	b9 b7 00 00 00       	mov    $0xb7,%ecx
  20081b:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
  200822:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
  200829:	eb 46                	jmp    200871 <_ZN15Acpi_table_madt12parse_ioapicEPK9Acpi_apic+0xb1>

            asm volatile ("cli" : : : "memory");
  20082b:	fa                   	cli    
            preemption = false;
  20082c:	c6 05 fd ee df bf 00 	movb   $0x0,-0x40201103(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
  200833:	e8 56 06 e0 80       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
        };

        ALWAYS_INLINE
        inline void index (Register reg)
        {
            *reinterpret_cast<uint8 volatile *>(reg_base + IOAPIC_IDX) = reg;
  200838:	48 8b 43 08          	mov    0x8(%rbx),%rax
  20083c:	c6 00 01             	movb   $0x1,(%rax)
        ALWAYS_INLINE
        inline uint32 read (Register reg)
        {
            Lock_guard <Spinlock> guard (lock);
            index (reg);
            return *reinterpret_cast<uint32 volatile *>(reg_base + IOAPIC_WND);
  20083f:	48 8b 43 08          	mov    0x8(%rbx),%rax
  200843:	8b 50 10             	mov    0x10(%rax),%edx
        }

        ALWAYS_INLINE
        inline void unlock()
        {
            asm volatile ("incb %0" : "=m" (val) : : "memory");
  200846:	fe 43 1a             	incb   0x1a(%rbx)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
  200849:	40 84 ed             	test   %bpl,%bpl
  20084c:	74 39                	je     200887 <_ZN15Acpi_table_madt12parse_ioapicEPK9Acpi_apic+0xc7>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
  20084e:	80 3d db ee df bf 00 	cmpb   $0x0,-0x40201125(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
  200855:	74 28                	je     20087f <_ZN15Acpi_table_madt12parse_ioapicEPK9Acpi_apic+0xbf>
  200857:	49 c7 c0 a0 d3 01 81 	mov    $0xffffffff8101d3a0,%r8
  20085e:	b9 c0 00 00 00       	mov    $0xc0,%ecx
  200863:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
  20086a:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
  200871:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
  200878:	31 c0                	xor    %eax,%eax
  20087a:	e8 d1 16 e0 80       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            preemption = true;
  20087f:	c6 05 aa ee df bf 01 	movb   $0x1,-0x40201156(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
  200886:	fb                   	sti    

        ALWAYS_INLINE
        inline unsigned prq() { return read (IOAPIC_VER) >> 15 & 0x1; }

        ALWAYS_INLINE
        inline unsigned irt_max() { return read (IOAPIC_VER) >> 16 & 0xff; }
  200887:	c1 ea 10             	shr    $0x10,%edx
  20088a:	44 89 e0             	mov    %r12d,%eax
  20088d:	0f b6 d2             	movzbl %dl,%edx
  200890:	89 c1                	mov    %eax,%ecx
  200892:	44 29 e1             	sub    %r12d,%ecx
    unsigned max = ioapic->irt_max();

    for (unsigned short i = 0; i <= max && gsi < NUM_GSI; i++, gsi++)
  200895:	39 d1                	cmp    %edx,%ecx
  200897:	77 16                	ja     2008af <_ZN15Acpi_table_madt12parse_ioapicEPK9Acpi_apic+0xef>
  200899:	83 f8 7f             	cmp    $0x7f,%eax
  20089c:	77 11                	ja     2008af <_ZN15Acpi_table_madt12parse_ioapicEPK9Acpi_apic+0xef>
        Gsi::gsi_table[gsi].ioapic = ioapic;
  20089e:	89 c1                	mov    %eax,%ecx
    Ioapic *ioapic = new (Pd::kern.quota) Ioapic (p->phys, p->id, p->gsi);

    unsigned gsi = p->gsi;
    unsigned max = ioapic->irt_max();

    for (unsigned short i = 0; i <= max && gsi < NUM_GSI; i++, gsi++)
  2008a0:	ff c0                	inc    %eax
        Gsi::gsi_table[gsi].ioapic = ioapic;
  2008a2:	48 6b c9 18          	imul   $0x18,%rcx,%rcx
  2008a6:	48 89 99 48 21 16 81 	mov    %rbx,-0x7ee9deb8(%rcx)
  2008ad:	eb e1                	jmp    200890 <_ZN15Acpi_table_madt12parse_ioapicEPK9Acpi_apic+0xd0>
}
  2008af:	5b                   	pop    %rbx
  2008b0:	5d                   	pop    %rbp
  2008b1:	41 5c                	pop    %r12
  2008b3:	c3                   	retq   

00000000002008b4 <_ZNK15Acpi_table_madt11parse_entryEN9Acpi_apic4TypeEPFvPKS0_E>:
        Io::out<uint8>(0x21, 0xff);
    }
}

void Acpi_table_madt::parse_entry (Acpi_apic::Type type, void (*handler)(Acpi_apic const *)) const
{
  2008b4:	41 55                	push   %r13
  2008b6:	41 54                	push   %r12
  2008b8:	49 89 d5             	mov    %rdx,%r13
  2008bb:	55                   	push   %rbp
  2008bc:	53                   	push   %rbx
    for (Acpi_apic const *ptr = apic; ptr < reinterpret_cast<Acpi_apic *>(reinterpret_cast<mword>(this) + length); ptr = reinterpret_cast<Acpi_apic *>(reinterpret_cast<mword>(ptr) + ptr->length))
  2008bd:	48 8d 5f 2c          	lea    0x2c(%rdi),%rbx
        Io::out<uint8>(0x21, 0xff);
    }
}

void Acpi_table_madt::parse_entry (Acpi_apic::Type type, void (*handler)(Acpi_apic const *)) const
{
  2008c1:	51                   	push   %rcx
  2008c2:	48 89 fd             	mov    %rdi,%rbp
  2008c5:	41 89 f4             	mov    %esi,%r12d
    for (Acpi_apic const *ptr = apic; ptr < reinterpret_cast<Acpi_apic *>(reinterpret_cast<mword>(this) + length); ptr = reinterpret_cast<Acpi_apic *>(reinterpret_cast<mword>(ptr) + ptr->length))
  2008c8:	8b 45 04             	mov    0x4(%rbp),%eax
  2008cb:	48 01 e8             	add    %rbp,%rax
  2008ce:	48 39 c3             	cmp    %rax,%rbx
  2008d1:	73 17                	jae    2008ea <_ZNK15Acpi_table_madt11parse_entryEN9Acpi_apic4TypeEPFvPKS0_E+0x36>
        if (ptr->type == type)
  2008d3:	0f b6 03             	movzbl (%rbx),%eax
  2008d6:	44 39 e0             	cmp    %r12d,%eax
  2008d9:	75 06                	jne    2008e1 <_ZNK15Acpi_table_madt11parse_entryEN9Acpi_apic4TypeEPFvPKS0_E+0x2d>
            (*handler)(ptr);
  2008db:	48 89 df             	mov    %rbx,%rdi
  2008de:	41 ff d5             	callq  *%r13
    }
}

void Acpi_table_madt::parse_entry (Acpi_apic::Type type, void (*handler)(Acpi_apic const *)) const
{
    for (Acpi_apic const *ptr = apic; ptr < reinterpret_cast<Acpi_apic *>(reinterpret_cast<mword>(this) + length); ptr = reinterpret_cast<Acpi_apic *>(reinterpret_cast<mword>(ptr) + ptr->length))
  2008e1:	0f b6 43 01          	movzbl 0x1(%rbx),%eax
  2008e5:	48 01 c3             	add    %rax,%rbx
  2008e8:	eb de                	jmp    2008c8 <_ZNK15Acpi_table_madt11parse_entryEN9Acpi_apic4TypeEPFvPKS0_E+0x14>
        if (ptr->type == type)
            (*handler)(ptr);
}
  2008ea:	58                   	pop    %rax
  2008eb:	5b                   	pop    %rbx
  2008ec:	5d                   	pop    %rbp
  2008ed:	41 5c                	pop    %r12
  2008ef:	41 5d                	pop    %r13
  2008f1:	c3                   	retq   

00000000002008f2 <_ZNK15Acpi_table_madt5parseEv>:
#include "lapic.hpp"
#include "vectors.hpp"
#include "pd.hpp"

void Acpi_table_madt::parse() const
{
  2008f2:	53                   	push   %rbx
    parse_entry (Acpi_apic::LAPIC,  &parse_lapic);
  2008f3:	31 f6                	xor    %esi,%esi
#include "lapic.hpp"
#include "vectors.hpp"
#include "pd.hpp"

void Acpi_table_madt::parse() const
{
  2008f5:	48 89 fb             	mov    %rdi,%rbx
    parse_entry (Acpi_apic::LAPIC,  &parse_lapic);
  2008f8:	48 c7 c2 92 07 20 00 	mov    $0x200792,%rdx
  2008ff:	e8 b0 ff ff ff       	callq  2008b4 <_ZNK15Acpi_table_madt11parse_entryEN9Acpi_apic4TypeEPFvPKS0_E>
    parse_entry (Acpi_apic::IOAPIC, &parse_ioapic);
  200904:	48 c7 c2 c0 07 20 00 	mov    $0x2007c0,%rdx
  20090b:	be 01 00 00 00       	mov    $0x1,%esi
  200910:	48 89 df             	mov    %rbx,%rdi
  200913:	e8 9c ff ff ff       	callq  2008b4 <_ZNK15Acpi_table_madt11parse_entryEN9Acpi_apic4TypeEPFvPKS0_E>
    parse_entry (Acpi_apic::INTR,   &parse_intr);
  200918:	48 c7 c2 e2 06 20 00 	mov    $0x2006e2,%rdx
  20091f:	be 02 00 00 00       	mov    $0x2,%esi
  200924:	48 89 df             	mov    %rbx,%rdi
  200927:	e8 88 ff ff ff       	callq  2008b4 <_ZNK15Acpi_table_madt11parse_entryEN9Acpi_apic4TypeEPFvPKS0_E>

    if (flags & 1) {
  20092c:	f6 43 28 01          	testb  $0x1,0x28(%rbx)
  200930:	74 14                	je     200946 <_ZNK15Acpi_table_madt5parseEv+0x54>
  200932:	b0 11                	mov    $0x11,%al
  200934:	e6 20                	out    %al,$0x20
  200936:	b0 20                	mov    $0x20,%al
  200938:	e6 21                	out    %al,$0x21
  20093a:	b0 04                	mov    $0x4,%al
  20093c:	e6 21                	out    %al,$0x21
  20093e:	b0 01                	mov    $0x1,%al
  200940:	e6 21                	out    %al,$0x21
  200942:	b0 ff                	mov    $0xff,%al
  200944:	e6 21                	out    %al,$0x21
        Io::out<uint8>(0x21, VEC_GSI);
        Io::out<uint8>(0x21, 0x4);
        Io::out<uint8>(0x21, 0x1);
        Io::out<uint8>(0x21, 0xff);
    }
}
  200946:	5b                   	pop    %rbx
  200947:	c3                   	retq   

0000000000200948 <_ZNK15Acpi_table_mcfg5parseEv>:
#include "acpi_mcfg.hpp"
#include "pci.hpp"

void Acpi_table_mcfg::parse() const
{
    for (Acpi_mcfg const *x = mcfg; x + 1 <= reinterpret_cast<Acpi_mcfg *>(reinterpret_cast<mword>(this) + length); x++)
  200948:	48 8d 57 2c          	lea    0x2c(%rdi),%rdx
  20094c:	8b 47 04             	mov    0x4(%rdi),%eax
  20094f:	48 83 c2 10          	add    $0x10,%rdx
  200953:	48 01 f8             	add    %rdi,%rax
  200956:	48 39 c2             	cmp    %rax,%rdx
  200959:	77 32                	ja     20098d <_ZNK15Acpi_table_mcfg5parseEv+0x45>
        if (!x->seg) {
  20095b:	66 83 7a f8 00       	cmpw   $0x0,-0x8(%rdx)
  200960:	75 ea                	jne    20094c <_ZNK15Acpi_table_mcfg5parseEv+0x4>
            Pci::bus_base = x->bus_s;
  200962:	0f b6 4a fa          	movzbl -0x6(%rdx),%ecx
  200966:	89 0d 9c 2f f6 80    	mov    %ecx,-0x7f09d064(%rip)        # ffffffff81163908 <_ZN3Pci8bus_baseE>
            Pci::cfg_base = static_cast<Paddr>(x->addr);
  20096c:	48 8b 42 f0          	mov    -0x10(%rdx),%rax
  200970:	48 89 05 89 2f f6 80 	mov    %rax,-0x7f09d077(%rip)        # ffffffff81163900 <_ZN3Pci8cfg_baseE>
            Pci::cfg_size = ((x->bus_e - x->bus_s + 1) << 8) * PAGE_SIZE;
  200977:	0f b6 42 fb          	movzbl -0x5(%rdx),%eax
  20097b:	29 c8                	sub    %ecx,%eax
  20097d:	ff c0                	inc    %eax
  20097f:	c1 e0 14             	shl    $0x14,%eax
  200982:	48 98                	cltq   
  200984:	48 89 05 6d 2f f6 80 	mov    %rax,-0x7f09d093(%rip)        # ffffffff811638f8 <_ZN3Pci8cfg_sizeE>
  20098b:	eb bf                	jmp    20094c <_ZNK15Acpi_table_mcfg5parseEv+0x4>
        }

    Pci::init();
  20098d:	31 f6                	xor    %esi,%esi
  20098f:	31 ff                	xor    %edi,%edi
  200991:	e9 12 0f 00 00       	jmpq   2018a8 <_ZN3Pci4initEjj>

0000000000200996 <_ZN9Acpi_rsdp4findEmj>:
#include "hpt.hpp"
#include "pd.hpp"

Acpi_rsdp *Acpi_rsdp::find (mword start, unsigned len)
{
    for (mword addr = start; addr < start + len; addr += 16) {
  200996:	89 f6                	mov    %esi,%esi
        Acpi_rsdp *rsdp = reinterpret_cast<Acpi_rsdp *>(addr);
        if (rsdp->good_signature() && rsdp->good_checksum())
  200998:	48 b9 52 53 44 20 50 	movabs $0x2052545020445352,%rcx
  20099f:	54 52 20 
#include "hpt.hpp"
#include "pd.hpp"

Acpi_rsdp *Acpi_rsdp::find (mword start, unsigned len)
{
    for (mword addr = start; addr < start + len; addr += 16) {
  2009a2:	48 01 fe             	add    %rdi,%rsi
  2009a5:	48 39 f7             	cmp    %rsi,%rdi
  2009a8:	73 25                	jae    2009cf <_ZN9Acpi_rsdp4findEmj+0x39>
        Acpi_rsdp *rsdp = reinterpret_cast<Acpi_rsdp *>(addr);
        if (rsdp->good_signature() && rsdp->good_checksum())
  2009aa:	48 39 0f             	cmp    %rcx,(%rdi)
  2009ad:	75 1a                	jne    2009c9 <_ZN9Acpi_rsdp4findEmj+0x33>
        ALWAYS_INLINE
        bool good_checksum (unsigned len = 20) const
        {
            uint8 check = 0;
            for (uint8 const *ptr = reinterpret_cast<uint8 const *>(this);
                              ptr < reinterpret_cast<uint8 const *>(this) + len;
  2009af:	4c 8d 47 14          	lea    0x14(%rdi),%r8
  2009b3:	48 89 f8             	mov    %rdi,%rax
  2009b6:	31 d2                	xor    %edx,%edx

        ALWAYS_INLINE
        bool good_checksum (unsigned len = 20) const
        {
            uint8 check = 0;
            for (uint8 const *ptr = reinterpret_cast<uint8 const *>(this);
  2009b8:	4c 39 c0             	cmp    %r8,%rax
  2009bb:	73 08                	jae    2009c5 <_ZN9Acpi_rsdp4findEmj+0x2f>
  2009bd:	48 ff c0             	inc    %rax
  2009c0:	02 50 ff             	add    -0x1(%rax),%dl
  2009c3:	eb f3                	jmp    2009b8 <_ZN9Acpi_rsdp4findEmj+0x22>
  2009c5:	84 d2                	test   %dl,%dl
  2009c7:	74 09                	je     2009d2 <_ZN9Acpi_rsdp4findEmj+0x3c>
#include "hpt.hpp"
#include "pd.hpp"

Acpi_rsdp *Acpi_rsdp::find (mword start, unsigned len)
{
    for (mword addr = start; addr < start + len; addr += 16) {
  2009c9:	48 83 c7 10          	add    $0x10,%rdi
  2009cd:	eb d6                	jmp    2009a5 <_ZN9Acpi_rsdp4findEmj+0xf>
        Acpi_rsdp *rsdp = reinterpret_cast<Acpi_rsdp *>(addr);
        if (rsdp->good_signature() && rsdp->good_checksum())
            return rsdp;
    }

    return nullptr;
  2009cf:	31 c0                	xor    %eax,%eax
  2009d1:	c3                   	retq   
  2009d2:	48 89 f8             	mov    %rdi,%rax
}
  2009d5:	c3                   	retq   

00000000002009d6 <_ZN9Acpi_rsdp5parseEv>:

void Acpi_rsdp::parse()
{
  2009d6:	53                   	push   %rbx
    Acpi_rsdp *rsdp;

    mword map = reinterpret_cast<mword>(Hpt::remap (Pd::kern.quota, 0));
  2009d7:	31 f6                	xor    %esi,%esi
  2009d9:	48 c7 c7 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rdi
  2009e0:	e8 2d 77 e0 80       	callq  ffffffff81008112 <_ZN3Hpt5remapER5Quotam>

    if (!(rsdp = Acpi_rsdp::find (map + (*reinterpret_cast<uint16 *>(map + 0x40e) << 4), 0x400)) &&
  2009e5:	0f b7 b8 0e 04 00 00 	movzwl 0x40e(%rax),%edi
  2009ec:	be 00 04 00 00       	mov    $0x400,%esi

void Acpi_rsdp::parse()
{
    Acpi_rsdp *rsdp;

    mword map = reinterpret_cast<mword>(Hpt::remap (Pd::kern.quota, 0));
  2009f1:	48 89 c3             	mov    %rax,%rbx

    if (!(rsdp = Acpi_rsdp::find (map + (*reinterpret_cast<uint16 *>(map + 0x40e) << 4), 0x400)) &&
  2009f4:	c1 e7 04             	shl    $0x4,%edi
  2009f7:	48 63 ff             	movslq %edi,%rdi
  2009fa:	48 01 c7             	add    %rax,%rdi
  2009fd:	e8 94 ff ff ff       	callq  200996 <_ZN9Acpi_rsdp4findEmj>
  200a02:	48 85 c0             	test   %rax,%rax
  200a05:	75 16                	jne    200a1d <_ZN9Acpi_rsdp5parseEv+0x47>
        !(rsdp = Acpi_rsdp::find (map + 0xe0000, 0x20000)))
  200a07:	48 8d bb 00 00 0e 00 	lea    0xe0000(%rbx),%rdi
{
    Acpi_rsdp *rsdp;

    mword map = reinterpret_cast<mword>(Hpt::remap (Pd::kern.quota, 0));

    if (!(rsdp = Acpi_rsdp::find (map + (*reinterpret_cast<uint16 *>(map + 0x40e) << 4), 0x400)) &&
  200a0e:	be 00 00 02 00       	mov    $0x20000,%esi
  200a13:	e8 7e ff ff ff       	callq  200996 <_ZN9Acpi_rsdp4findEmj>
  200a18:	48 85 c0             	test   %rax,%rax
  200a1b:	74 37                	je     200a54 <_ZN9Acpi_rsdp5parseEv+0x7e>
        !(rsdp = Acpi_rsdp::find (map + 0xe0000, 0x20000)))
        return;

    Acpi::rsdt = rsdp->rsdt_addr;
  200a1d:	8b 48 10             	mov    0x10(%rax),%ecx

    if (rsdp->revision > 1 && rsdp->good_checksum (rsdp->length))
  200a20:	80 78 0f 01          	cmpb   $0x1,0xf(%rax)

    if (!(rsdp = Acpi_rsdp::find (map + (*reinterpret_cast<uint16 *>(map + 0x40e) << 4), 0x400)) &&
        !(rsdp = Acpi_rsdp::find (map + 0xe0000, 0x20000)))
        return;

    Acpi::rsdt = rsdp->rsdt_addr;
  200a24:	48 89 0d c5 12 e2 80 	mov    %rcx,-0x7f1ded3b(%rip)        # ffffffff81021cf0 <_ZN4Acpi4rsdtE>

    if (rsdp->revision > 1 && rsdp->good_checksum (rsdp->length))
  200a2b:	76 27                	jbe    200a54 <_ZN9Acpi_rsdp5parseEv+0x7e>
                              ptr < reinterpret_cast<uint8 const *>(this) + len;
  200a2d:	8b 70 14             	mov    0x14(%rax),%esi
  200a30:	48 89 c2             	mov    %rax,%rdx
        }

        ALWAYS_INLINE
        bool good_checksum (unsigned len = 20) const
        {
            uint8 check = 0;
  200a33:	31 c9                	xor    %ecx,%ecx
            for (uint8 const *ptr = reinterpret_cast<uint8 const *>(this);
                              ptr < reinterpret_cast<uint8 const *>(this) + len;
  200a35:	48 01 c6             	add    %rax,%rsi

        ALWAYS_INLINE
        bool good_checksum (unsigned len = 20) const
        {
            uint8 check = 0;
            for (uint8 const *ptr = reinterpret_cast<uint8 const *>(this);
  200a38:	48 39 f2             	cmp    %rsi,%rdx
  200a3b:	73 08                	jae    200a45 <_ZN9Acpi_rsdp5parseEv+0x6f>
  200a3d:	48 ff c2             	inc    %rdx
  200a40:	02 4a ff             	add    -0x1(%rdx),%cl
  200a43:	eb f3                	jmp    200a38 <_ZN9Acpi_rsdp5parseEv+0x62>
  200a45:	84 c9                	test   %cl,%cl
  200a47:	75 0b                	jne    200a54 <_ZN9Acpi_rsdp5parseEv+0x7e>
        Acpi::xsdt = static_cast<Paddr>(rsdp->xsdt_addr);
  200a49:	48 8b 40 18          	mov    0x18(%rax),%rax
  200a4d:	48 89 05 94 12 e2 80 	mov    %rax,-0x7f1ded6c(%rip)        # ffffffff81021ce8 <_ZN4Acpi4xsdtE>
}
  200a54:	5b                   	pop    %rbx
  200a55:	c3                   	retq   

0000000000200a56 <_ZNK15Acpi_table_rsdt5parseEmm>:
    { SIG ('H','P','E','T'),    &Acpi::hpet },
    { SIG ('M','C','F','G'),    &Acpi::mcfg },
};

void Acpi_table_rsdt::parse (Paddr addr, size_t size) const
{
  200a56:	55                   	push   %rbp
  200a57:	48 89 e5             	mov    %rsp,%rbp
  200a5a:	41 57                	push   %r15
  200a5c:	41 56                	push   %r14
  200a5e:	41 55                	push   %r13
  200a60:	41 54                	push   %r12
  200a62:	49 89 d6             	mov    %rdx,%r14
  200a65:	53                   	push   %rbx
  200a66:	49 89 fc             	mov    %rdi,%r12
  200a69:	48 83 ec 18          	sub    $0x18,%rsp
  200a6d:	48 89 65 c8          	mov    %rsp,-0x38(%rbp)
    if (!good_checksum (addr))
  200a71:	e8 b6 00 00 00       	callq  200b2c <_ZNK10Acpi_table13good_checksumEm>
  200a76:	84 c0                	test   %al,%al
  200a78:	0f 84 9f 00 00 00    	je     200b1d <_ZNK15Acpi_table_rsdt5parseEmm+0xc7>
            Paddr * const ptr;
        } map[];

        unsigned long entries (size_t size) const
        {
            return (length - sizeof (Acpi_table)) / size;
  200a7e:	41 8b 44 24 04       	mov    0x4(%r12),%eax
  200a83:	31 d2                	xor    %edx,%edx
  200a85:	48 83 e8 24          	sub    $0x24,%rax
  200a89:	49 f7 f6             	div    %r14
  200a8c:	49 89 c5             	mov    %rax,%r13
        return;

    unsigned long count = entries (size);

    Paddr table[count];
  200a8f:	48 8d 04 c5 16 00 00 	lea    0x16(,%rax,8),%rax
  200a96:	00 
  200a97:	48 83 e0 f0          	and    $0xfffffffffffffff0,%rax
  200a9b:	48 29 c4             	sub    %rax,%rsp
    for (unsigned i = 0; i < count; i++)
  200a9e:	31 c0                	xor    %eax,%eax
    if (!good_checksum (addr))
        return;

    unsigned long count = entries (size);

    Paddr table[count];
  200aa0:	49 89 e7             	mov    %rsp,%r15
    for (unsigned i = 0; i < count; i++)
  200aa3:	89 c1                	mov    %eax,%ecx
  200aa5:	4c 39 e9             	cmp    %r13,%rcx
  200aa8:	73 1a                	jae    200ac4 <_ZNK15Acpi_table_rsdt5parseEmm+0x6e>
        table[i] = static_cast<Paddr>(size == sizeof (*xsdt) ? xsdt[i] : rsdt[i]);
  200aaa:	49 83 fe 08          	cmp    $0x8,%r14
  200aae:	75 07                	jne    200ab7 <_ZNK15Acpi_table_rsdt5parseEmm+0x61>
  200ab0:	49 8b 54 cc 24       	mov    0x24(%r12,%rcx,8),%rdx
  200ab5:	eb 05                	jmp    200abc <_ZNK15Acpi_table_rsdt5parseEmm+0x66>
  200ab7:	41 8b 54 8c 24       	mov    0x24(%r12,%rcx,4),%edx
  200abc:	49 89 14 cf          	mov    %rdx,(%r15,%rcx,8)
        return;

    unsigned long count = entries (size);

    Paddr table[count];
    for (unsigned i = 0; i < count; i++)
  200ac0:	ff c0                	inc    %eax
  200ac2:	eb df                	jmp    200aa3 <_ZNK15Acpi_table_rsdt5parseEmm+0x4d>
  200ac4:	45 31 e4             	xor    %r12d,%r12d
        table[i] = static_cast<Paddr>(size == sizeof (*xsdt) ? xsdt[i] : rsdt[i]);

    for (unsigned i = 0; i < count; i++) {
  200ac7:	44 89 e0             	mov    %r12d,%eax
  200aca:	4c 39 e8             	cmp    %r13,%rax
  200acd:	73 4a                	jae    200b19 <_ZNK15Acpi_table_rsdt5parseEmm+0xc3>

        Acpi_table *acpi = static_cast<Acpi_table *>(Hpt::remap (Pd::kern.quota, table[i]));
  200acf:	4d 8b 34 c7          	mov    (%r15,%rax,8),%r14
  200ad3:	48 c7 c7 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rdi
  200ada:	4c 89 f6             	mov    %r14,%rsi
  200add:	e8 30 76 e0 80       	callq  ffffffff81008112 <_ZN3Hpt5remapER5Quotam>

        if (acpi->good_checksum (table[i]))
  200ae2:	4c 89 f6             	mov    %r14,%rsi
  200ae5:	48 89 c7             	mov    %rax,%rdi
    for (unsigned i = 0; i < count; i++)
        table[i] = static_cast<Paddr>(size == sizeof (*xsdt) ? xsdt[i] : rsdt[i]);

    for (unsigned i = 0; i < count; i++) {

        Acpi_table *acpi = static_cast<Acpi_table *>(Hpt::remap (Pd::kern.quota, table[i]));
  200ae8:	48 89 c3             	mov    %rax,%rbx

        if (acpi->good_checksum (table[i]))
  200aeb:	e8 3c 00 00 00       	callq  200b2c <_ZNK10Acpi_table13good_checksumEm>
  200af0:	84 c0                	test   %al,%al
  200af2:	74 20                	je     200b14 <_ZNK15Acpi_table_rsdt5parseEmm+0xbe>
  200af4:	31 c9                	xor    %ecx,%ecx
            for (unsigned j = 0; j < sizeof map / sizeof *map; j++)
                if (acpi->signature == map[j].sig)
  200af6:	8b 81 80 1d 20 00    	mov    0x201d80(%rcx),%eax
  200afc:	39 03                	cmp    %eax,(%rbx)
  200afe:	75 0a                	jne    200b0a <_ZNK15Acpi_table_rsdt5parseEmm+0xb4>
                    *map[j].ptr = table[i];
  200b00:	48 8b 81 84 1d 20 00 	mov    0x201d84(%rcx),%rax
  200b07:	4c 89 30             	mov    %r14,(%rax)
  200b0a:	48 83 c1 0c          	add    $0xc,%rcx
    for (unsigned i = 0; i < count; i++) {

        Acpi_table *acpi = static_cast<Acpi_table *>(Hpt::remap (Pd::kern.quota, table[i]));

        if (acpi->good_checksum (table[i]))
            for (unsigned j = 0; j < sizeof map / sizeof *map; j++)
  200b0e:	48 83 f9 3c          	cmp    $0x3c,%rcx
  200b12:	75 e2                	jne    200af6 <_ZNK15Acpi_table_rsdt5parseEmm+0xa0>

    Paddr table[count];
    for (unsigned i = 0; i < count; i++)
        table[i] = static_cast<Paddr>(size == sizeof (*xsdt) ? xsdt[i] : rsdt[i]);

    for (unsigned i = 0; i < count; i++) {
  200b14:	41 ff c4             	inc    %r12d
  200b17:	eb ae                	jmp    200ac7 <_ZNK15Acpi_table_rsdt5parseEmm+0x71>
  200b19:	48 8b 65 c8          	mov    -0x38(%rbp),%rsp
        if (acpi->good_checksum (table[i]))
            for (unsigned j = 0; j < sizeof map / sizeof *map; j++)
                if (acpi->signature == map[j].sig)
                    *map[j].ptr = table[i];
    }
}
  200b1d:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
  200b21:	5b                   	pop    %rbx
  200b22:	41 5c                	pop    %r12
  200b24:	41 5d                	pop    %r13
  200b26:	41 5e                	pop    %r14
  200b28:	41 5f                	pop    %r15
  200b2a:	5d                   	pop    %rbp
  200b2b:	c3                   	retq   

0000000000200b2c <_ZNK10Acpi_table13good_checksumEm>:
bool Acpi_table::good_checksum (Paddr addr) const
{
    uint8 check = 0;

    for (uint8 const *ptr = reinterpret_cast<uint8 const *>(this);
                      ptr < reinterpret_cast<uint8 const *>(this) + length;
  200b2c:	8b 57 04             	mov    0x4(%rdi),%edx
#include "acpi_table.hpp"
#include "stdio.hpp"

bool Acpi_table::good_checksum (Paddr addr) const
{
    uint8 check = 0;
  200b2f:	31 c0                	xor    %eax,%eax

    for (uint8 const *ptr = reinterpret_cast<uint8 const *>(this);
                      ptr < reinterpret_cast<uint8 const *>(this) + length;
  200b31:	48 01 fa             	add    %rdi,%rdx

bool Acpi_table::good_checksum (Paddr addr) const
{
    uint8 check = 0;

    for (uint8 const *ptr = reinterpret_cast<uint8 const *>(this);
  200b34:	48 39 d7             	cmp    %rdx,%rdi
  200b37:	73 08                	jae    200b41 <_ZNK10Acpi_table13good_checksumEm+0x15>
  200b39:	48 ff c7             	inc    %rdi
  200b3c:	02 47 ff             	add    -0x1(%rdi),%al
  200b3f:	eb f3                	jmp    200b34 <_ZNK10Acpi_table13good_checksumEm+0x8>
           oem_id,
           length,
           check ? "bad" : "ok",
           static_cast<unsigned int>(checksum));

    return !check;
  200b41:	84 c0                	test   %al,%al
  200b43:	0f 94 c0             	sete   %al
}
  200b46:	c3                   	retq   
  200b47:	90                   	nop

0000000000200b48 <_ZN5BuddyC1Emmmm>:
                        reinterpret_cast<mword>(&_mempool_l),
                        reinterpret_cast<mword>(&_mempool_f),
                        reinterpret_cast<mword>(&_mempool_e) -
                        reinterpret_cast<mword>(&_mempool_l));

Buddy::Buddy (mword phys, mword virt, mword f_addr, size_t size)
  200b48:	41 54                	push   %r12
  200b4a:	49 89 cc             	mov    %rcx,%r12

ALWAYS_INLINE
inline long int bit_scan_reverse (mword val)
{
    if (EXPECT_FALSE (!val))
        return -1;
  200b4d:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
#include "util.hpp"

ALWAYS_INLINE
inline long int bit_scan_reverse (mword val)
{
    if (EXPECT_FALSE (!val))
  200b51:	4d 85 c0             	test   %r8,%r8
  200b54:	55                   	push   %rbp
  200b55:	48 89 fd             	mov    %rdi,%rbp
  200b58:	53                   	push   %rbx
  200b59:	48 89 d3             	mov    %rdx,%rbx
    private:
        uint16 val;

    public:
        ALWAYS_INLINE
        inline Spinlock() : val (0) {}
  200b5c:	66 c7 07 00 00       	movw   $0x0,(%rdi)
  200b61:	74 04                	je     200b67 <_ZN5BuddyC1Emmmm+0x1f>
        return -1;

    asm volatile ("bsr %1, %0" : "=r" (val) : "rm" (val));

    return val;
  200b63:	49 0f bd c8          	bsr    %r8,%rcx
{
    // Compute maximum aligned block size
    unsigned long bit = bit_scan_reverse (size);

    // Compute maximum aligned physical block address (base)
    base = phys_to_virt (align_up (phys, 1ul << bit));
  200b67:	b8 01 00 00 00       	mov    $0x1,%eax
  200b6c:	48 d3 e0             	shl    %cl,%rax

    // Convert block size to page order
    order = bit + 1 - PAGE_BITS;
  200b6f:	48 83 e9 0b          	sub    $0xb,%rcx
  200b73:	48 89 4d 20          	mov    %rcx,0x20(%rbp)
}

ALWAYS_INLINE
static inline mword align_dn (mword val, mword align)
{
    val &= ~(align - 1);                // Expect power-of-2
  200b77:	48 89 c2             	mov    %rax,%rdx
}

ALWAYS_INLINE
static inline mword align_up (mword val, mword align)
{
    val += (align - 1);                 // Expect power-of-2
  200b7a:	48 8d 44 30 ff       	lea    -0x1(%rax,%rsi,1),%rax
           phys,
           phys + size,
           order);

    // Allocate block-list heads
    size -= order * sizeof *head;
  200b7f:	48 6b c9 18          	imul   $0x18,%rcx,%rcx
}

ALWAYS_INLINE
static inline mword align_dn (mword val, mword align)
{
    val &= ~(align - 1);                // Expect power-of-2
  200b83:	48 f7 da             	neg    %rdx
  200b86:	48 89 d6             	mov    %rdx,%rsi
    head = reinterpret_cast<Block *>(virt + size);

    // Allocate block-index storage
    size -= size / (PAGE_SIZE + sizeof *index) * sizeof *index;
  200b89:	31 d2                	xor    %edx,%edx
  200b8b:	48 21 c6             	and    %rax,%rsi
        }

        ALWAYS_INLINE
        inline mword phys_to_virt (mword phys)
        {
            return phys + reinterpret_cast<mword>(&OFFSET);
  200b8e:	48 81 c6 00 00 c0 80 	add    $0xffffffff80c00000,%rsi
           phys,
           phys + size,
           order);

    // Allocate block-list heads
    size -= order * sizeof *head;
  200b95:	49 29 c8             	sub    %rcx,%r8
    head = reinterpret_cast<Block *>(virt + size);

    // Allocate block-index storage
    size -= size / (PAGE_SIZE + sizeof *index) * sizeof *index;
  200b98:	b9 18 10 00 00       	mov    $0x1018,%ecx
{
    // Compute maximum aligned block size
    unsigned long bit = bit_scan_reverse (size);

    // Compute maximum aligned physical block address (base)
    base = phys_to_virt (align_up (phys, 1ul << bit));
  200b9d:	48 89 75 18          	mov    %rsi,0x18(%rbp)
           phys + size,
           order);

    // Allocate block-list heads
    size -= order * sizeof *head;
    head = reinterpret_cast<Block *>(virt + size);
  200ba1:	49 8d 04 18          	lea    (%r8,%rbx,1),%rax
        }

        ALWAYS_INLINE
        inline signed long page_to_index (mword l_addr)
        {
            return l_addr / PAGE_SIZE - base / PAGE_SIZE;
  200ba5:	48 c1 ee 0c          	shr    $0xc,%rsi
  200ba9:	48 89 45 30          	mov    %rax,0x30(%rbp)

    // Allocate block-index storage
    size -= size / (PAGE_SIZE + sizeof *index) * sizeof *index;
  200bad:	4c 89 c0             	mov    %r8,%rax
  200bb0:	48 f7 f1             	div    %rcx
  200bb3:	48 6b c0 18          	imul   $0x18,%rax,%rax
  200bb7:	49 29 c0             	sub    %rax,%r8
  200bba:	48 89 d8             	mov    %rbx,%rax
  200bbd:	48 c1 e8 0c          	shr    $0xc,%rax
    size &= ~PAGE_MASK;
  200bc1:	49 81 e0 00 f0 ff ff 	and    $0xfffffffffffff000,%r8
  200bc8:	48 29 f0             	sub    %rsi,%rax
    min_idx = page_to_index (virt);
    max_idx = page_to_index (virt + size);
  200bcb:	4c 01 c3             	add    %r8,%rbx
    head = reinterpret_cast<Block *>(virt + size);

    // Allocate block-index storage
    size -= size / (PAGE_SIZE + sizeof *index) * sizeof *index;
    size &= ~PAGE_MASK;
    min_idx = page_to_index (virt);
  200bce:	48 89 45 10          	mov    %rax,0x10(%rbp)
  200bd2:	48 89 da             	mov    %rbx,%rdx
    max_idx = page_to_index (virt + size);
    index = reinterpret_cast<Block *>(virt + size) - min_idx;
  200bd5:	48 89 df             	mov    %rbx,%rdi
  200bd8:	48 6b c0 18          	imul   $0x18,%rax,%rax
  200bdc:	48 c1 ea 0c          	shr    $0xc,%rdx
  200be0:	48 29 f2             	sub    %rsi,%rdx
  200be3:	48 89 55 08          	mov    %rdx,0x8(%rbp)

    for (unsigned i = 0; i < order; i++)
  200be7:	31 d2                	xor    %edx,%edx
    // Allocate block-index storage
    size -= size / (PAGE_SIZE + sizeof *index) * sizeof *index;
    size &= ~PAGE_MASK;
    min_idx = page_to_index (virt);
    max_idx = page_to_index (virt + size);
    index = reinterpret_cast<Block *>(virt + size) - min_idx;
  200be9:	48 29 c7             	sub    %rax,%rdi
  200bec:	48 89 7d 28          	mov    %rdi,0x28(%rbp)

    for (unsigned i = 0; i < order; i++)
  200bf0:	89 d0                	mov    %edx,%eax
  200bf2:	48 3b 45 20          	cmp    0x20(%rbp),%rax
  200bf6:	73 13                	jae    200c0b <_ZN5BuddyC1Emmmm+0xc3>
        head[i].next = head[i].prev = head + i;
  200bf8:	48 6b c0 18          	imul   $0x18,%rax,%rax
    size &= ~PAGE_MASK;
    min_idx = page_to_index (virt);
    max_idx = page_to_index (virt + size);
    index = reinterpret_cast<Block *>(virt + size) - min_idx;

    for (unsigned i = 0; i < order; i++)
  200bfc:	ff c2                	inc    %edx
        head[i].next = head[i].prev = head + i;
  200bfe:	48 03 45 30          	add    0x30(%rbp),%rax
  200c02:	48 89 00             	mov    %rax,(%rax)
  200c05:	48 89 40 08          	mov    %rax,0x8(%rax)
  200c09:	eb e5                	jmp    200bf0 <_ZN5BuddyC1Emmmm+0xa8>

    for (mword i = f_addr; i < virt + size; i += PAGE_SIZE)
  200c0b:	49 39 dc             	cmp    %rbx,%r12
  200c0e:	73 1b                	jae    200c2b <_ZN5BuddyC1Emmmm+0xe3>
        free (i, Quota::init);
  200c10:	4c 89 e6             	mov    %r12,%rsi
  200c13:	48 c7 c2 70 1d 02 81 	mov    $0xffffffff81021d70,%rdx
  200c1a:	48 89 ef             	mov    %rbp,%rdi
  200c1d:	e8 8c 09 e0 80       	callq  ffffffff810015ae <_ZN5Buddy4freeEmR5Quota>
    index = reinterpret_cast<Block *>(virt + size) - min_idx;

    for (unsigned i = 0; i < order; i++)
        head[i].next = head[i].prev = head + i;

    for (mword i = f_addr; i < virt + size; i += PAGE_SIZE)
  200c22:	49 81 c4 00 10 00 00 	add    $0x1000,%r12
  200c29:	eb e0                	jmp    200c0b <_ZN5BuddyC1Emmmm+0xc3>
        free (i, Quota::init);
}
  200c2b:	5b                   	pop    %rbx
  200c2c:	5d                   	pop    %rbp
  200c2d:	41 5c                	pop    %r12
  200c2f:	c3                   	retq   

0000000000200c30 <_ZN7Cmdline7get_argEPPc>:
    { "novpid",     &Cmdline::novpid    },
};

char *Cmdline::get_arg (char **line)
{
    for (; **line == ' '; ++*line) ;
  200c30:	48 8b 17             	mov    (%rdi),%rdx
  200c33:	8a 0a                	mov    (%rdx),%cl
  200c35:	80 f9 20             	cmp    $0x20,%cl
  200c38:	75 08                	jne    200c42 <_ZN7Cmdline7get_argEPPc+0x12>
  200c3a:	48 ff c2             	inc    %rdx
  200c3d:	48 89 17             	mov    %rdx,(%rdi)
  200c40:	eb ee                	jmp    200c30 <_ZN7Cmdline7get_argEPPc>

    if (!**line)
        return nullptr;
  200c42:	31 c0                	xor    %eax,%eax

char *Cmdline::get_arg (char **line)
{
    for (; **line == ' '; ++*line) ;

    if (!**line)
  200c44:	84 c9                	test   %cl,%cl
  200c46:	75 0b                	jne    200c53 <_ZN7Cmdline7get_argEPPc+0x23>
  200c48:	c3                   	retq   
        return nullptr;

    char *arg = *line;

    for (; **line != ' '; ++*line)
        if (!**line)
  200c49:	84 c9                	test   %cl,%cl
  200c4b:	74 1a                	je     200c67 <_ZN7Cmdline7get_argEPPc+0x37>
    if (!**line)
        return nullptr;

    char *arg = *line;

    for (; **line != ' '; ++*line)
  200c4d:	48 ff c0             	inc    %rax
  200c50:	48 89 07             	mov    %rax,(%rdi)
  200c53:	48 8b 07             	mov    (%rdi),%rax
  200c56:	8a 08                	mov    (%rax),%cl
  200c58:	80 f9 20             	cmp    $0x20,%cl
  200c5b:	75 ec                	jne    200c49 <_ZN7Cmdline7get_argEPPc+0x19>
        if (!**line)
            return arg;

    *(*line)++ = 0;
  200c5d:	48 8d 48 01          	lea    0x1(%rax),%rcx
  200c61:	48 89 0f             	mov    %rcx,(%rdi)
  200c64:	c6 00 00             	movb   $0x0,(%rax)
    { "novpid",     &Cmdline::novpid    },
};

char *Cmdline::get_arg (char **line)
{
    for (; **line == ' '; ++*line) ;
  200c67:	48 89 d0             	mov    %rdx,%rax
            return arg;

    *(*line)++ = 0;

    return arg;
}
  200c6a:	c3                   	retq   
  200c6b:	90                   	nop

0000000000200c6c <_ZN7Cmdline4initEm>:

void Cmdline::init (mword addr)
{
  200c6c:	48 83 ec 18          	sub    $0x18,%rsp
  200c70:	48 89 fe             	mov    %rdi,%rsi
    char *arg, *line = static_cast<char *>(Hpt::remap (Pd::kern.quota, addr));
  200c73:	48 c7 c7 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rdi
  200c7a:	e8 93 74 e0 80       	callq  ffffffff81008112 <_ZN3Hpt5remapER5Quotam>
  200c7f:	48 89 44 24 08       	mov    %rax,0x8(%rsp)

    while ((arg = get_arg (&line)))
  200c84:	48 8d 7c 24 08       	lea    0x8(%rsp),%rdi
  200c89:	e8 a2 ff ff ff       	callq  200c30 <_ZN7Cmdline7get_argEPPc>
  200c8e:	48 85 c0             	test   %rax,%rax
  200c91:	74 3f                	je     200cd2 <_ZN7Cmdline4initEm+0x66>
  200c93:	31 d2                	xor    %edx,%edx
        for (unsigned i = 0; i < sizeof map / sizeof *map; i++)
            if (!strcmp (map[i].arg, arg))
  200c95:	48 8b ba c0 1d 20 00 	mov    0x201dc0(%rdx),%rdi
  200c9c:	48 89 c1             	mov    %rax,%rcx
    return d;
}

extern "C" NONNULL
inline int strcmp(char const *s1, char const *s2) {
    while (*s1 && *s1 == *s2)
  200c9f:	40 8a 37             	mov    (%rdi),%sil
  200ca2:	40 84 f6             	test   %sil,%sil
  200ca5:	74 0d                	je     200cb4 <_ZN7Cmdline4initEm+0x48>
  200ca7:	40 3a 31             	cmp    (%rcx),%sil
  200caa:	75 08                	jne    200cb4 <_ZN7Cmdline4initEm+0x48>
        s1++, s2++;
  200cac:	48 ff c7             	inc    %rdi
  200caf:	48 ff c1             	inc    %rcx
  200cb2:	eb eb                	jmp    200c9f <_ZN7Cmdline4initEm+0x33>
  200cb4:	40 3a 31             	cmp    (%rcx),%sil
  200cb7:	75 0a                	jne    200cc3 <_ZN7Cmdline4initEm+0x57>
                *map[i].ptr = true;
  200cb9:	48 8b 8a c8 1d 20 00 	mov    0x201dc8(%rdx),%rcx
  200cc0:	c6 01 01             	movb   $0x1,(%rcx)
  200cc3:	48 83 c2 10          	add    $0x10,%rdx
void Cmdline::init (mword addr)
{
    char *arg, *line = static_cast<char *>(Hpt::remap (Pd::kern.quota, addr));

    while ((arg = get_arg (&line)))
        for (unsigned i = 0; i < sizeof map / sizeof *map; i++)
  200cc7:	48 81 fa 90 00 00 00 	cmp    $0x90,%rdx
  200cce:	75 c5                	jne    200c95 <_ZN7Cmdline4initEm+0x29>
  200cd0:	eb b2                	jmp    200c84 <_ZN7Cmdline4initEm+0x18>
            if (!strcmp (map[i].arg, arg))
                *map[i].ptr = true;
}
  200cd2:	48 83 c4 18          	add    $0x18,%rsp
  200cd6:	c3                   	retq   
  200cd7:	90                   	nop

0000000000200cd8 <_ZN14Console_serialC1Ev>:
#include "x86.hpp"
#include "pd.hpp"

INIT_PRIORITY (PRIO_CONSOLE) Console_serial Console_serial::con;

Console_serial::Console_serial()
  200cd8:	48 c7 07 d0 d7 01 81 	movq   $0xffffffff8101d7d0,(%rdi)
{
    if (!Cmdline::serial)
  200cdf:	80 3d b8 10 e2 80 00 	cmpb   $0x0,-0x7f1def48(%rip)        # ffffffff81021d9e <_ZN7Cmdline6serialE>
  200ce6:	74 75                	je     200d5d <_ZN14Console_serialC1Ev+0x85>
#include "x86.hpp"
#include "pd.hpp"

INIT_PRIORITY (PRIO_CONSOLE) Console_serial Console_serial::con;

Console_serial::Console_serial()
  200ce8:	53                   	push   %rbx
{
    if (!Cmdline::serial)
        return;

    char *mem = static_cast<char *>(Hpt::remap (Pd::kern.quota, 0));
  200ce9:	31 f6                	xor    %esi,%esi
  200ceb:	48 89 fb             	mov    %rdi,%rbx
  200cee:	48 c7 c7 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rdi
  200cf5:	e8 18 74 e0 80       	callq  ffffffff81008112 <_ZN3Hpt5remapER5Quotam>
    if (!(base = *reinterpret_cast<uint16 *>(mem + 0x400)) &&
  200cfa:	0f b7 90 00 04 00 00 	movzwl 0x400(%rax),%edx
  200d01:	85 d2                	test   %edx,%edx
  200d03:	89 53 10             	mov    %edx,0x10(%rbx)
  200d06:	75 0e                	jne    200d16 <_ZN14Console_serialC1Ev+0x3e>
        !(base = *reinterpret_cast<uint16 *>(mem + 0x402)))
  200d08:	0f b7 80 02 04 00 00 	movzwl 0x402(%rax),%eax
{
    if (!Cmdline::serial)
        return;

    char *mem = static_cast<char *>(Hpt::remap (Pd::kern.quota, 0));
    if (!(base = *reinterpret_cast<uint16 *>(mem + 0x400)) &&
  200d0f:	85 c0                	test   %eax,%eax
  200d11:	89 43 10             	mov    %eax,0x10(%rbx)
  200d14:	74 46                	je     200d5c <_ZN14Console_serialC1Ev+0x84>
  200d16:	8b 4b 10             	mov    0x10(%rbx),%ecx
  200d19:	b0 80                	mov    $0x80,%al

        ALWAYS_INLINE
        inline unsigned in (Register r) { return Io::in<uint8>(base + r); }

        ALWAYS_INLINE
        inline void out (Register r, unsigned v) { Io::out (base + r, static_cast<uint8>(v)); }
  200d1b:	44 8d 49 03          	lea    0x3(%rcx),%r9d
  200d1f:	44 89 ca             	mov    %r9d,%edx
  200d22:	ee                   	out    %al,(%dx)
  200d23:	b0 01                	mov    $0x1,%al
  200d25:	89 ca                	mov    %ecx,%edx
  200d27:	ee                   	out    %al,(%dx)
  200d28:	44 8d 41 01          	lea    0x1(%rcx),%r8d
  200d2c:	31 ff                	xor    %edi,%edi
  200d2e:	40 88 f8             	mov    %dil,%al
  200d31:	44 89 c2             	mov    %r8d,%edx
  200d34:	ee                   	out    %al,(%dx)
  200d35:	40 b6 03             	mov    $0x3,%sil
  200d38:	44 89 ca             	mov    %r9d,%edx
  200d3b:	40 88 f0             	mov    %sil,%al
  200d3e:	ee                   	out    %al,(%dx)
  200d3f:	40 88 f8             	mov    %dil,%al
  200d42:	44 89 c2             	mov    %r8d,%edx
  200d45:	ee                   	out    %al,(%dx)
  200d46:	b0 07                	mov    $0x7,%al
  200d48:	8d 51 02             	lea    0x2(%rcx),%edx
  200d4b:	ee                   	out    %al,(%dx)
  200d4c:	8d 51 04             	lea    0x4(%rcx),%edx
  200d4f:	40 88 f0             	mov    %sil,%al
  200d52:	ee                   	out    %al,(%dx)
    out (LCR, 3);
    out (IER, 0);
    out (FCR, 7);
    out (MCR, 3);

    enable();
  200d53:	48 89 df             	mov    %rbx,%rdi
}
  200d56:	5b                   	pop    %rbx
    out (LCR, 3);
    out (IER, 0);
    out (FCR, 7);
    out (MCR, 3);

    enable();
  200d57:	e9 ae 14 e0 80       	jmpq   ffffffff8100220a <_ZN7Console6enableEv>
}
  200d5c:	5b                   	pop    %rbx
  200d5d:	c3                   	retq   

0000000000200d5e <_ZN11Console_vgaC1Ev>:
#include "console_vga.hpp"
#include "pd.hpp"

INIT_PRIORITY (PRIO_CONSOLE) Console_vga Console_vga::con;

Console_vga::Console_vga() : num (25), row (0), col (0)
  200d5e:	48 c7 07 00 d8 01 81 	movq   $0xffffffff8101d800,(%rdi)
{
    if (Cmdline::novga)
  200d65:	80 3d 2d 10 e2 80 00 	cmpb   $0x0,-0x7f1defd3(%rip)        # ffffffff81021d99 <_ZN7Cmdline5novgaE>
#include "console_vga.hpp"
#include "pd.hpp"

INIT_PRIORITY (PRIO_CONSOLE) Console_vga Console_vga::con;

Console_vga::Console_vga() : num (25), row (0), col (0)
  200d6c:	c7 47 10 19 00 00 00 	movl   $0x19,0x10(%rdi)
  200d73:	c7 47 14 00 00 00 00 	movl   $0x0,0x14(%rdi)
  200d7a:	c7 47 18 00 00 00 00 	movl   $0x0,0x18(%rdi)
{
    if (Cmdline::novga)
  200d81:	75 59                	jne    200ddc <_ZN11Console_vgaC1Ev+0x7e>
#include "console_vga.hpp"
#include "pd.hpp"

INIT_PRIORITY (PRIO_CONSOLE) Console_vga Console_vga::con;

Console_vga::Console_vga() : num (25), row (0), col (0)
  200d83:	53                   	push   %rbx
        }

        ALWAYS_INLINE
        inline void insert (Quota &quota, mword virt, unsigned o, mword attr, Paddr phys)
        {
            hpt.update (quota, virt, o, phys, attr);
  200d84:	6a 00                	pushq  $0x0
  200d86:	48 89 fb             	mov    %rdi,%rbx
  200d89:	6a 00                	pushq  $0x0
  200d8b:	41 b9 13 01 00 00    	mov    $0x113,%r9d
  200d91:	41 b8 00 90 0b 00    	mov    $0xb9000,%r8d
  200d97:	31 c9                	xor    %ecx,%ecx
  200d99:	48 c7 c2 00 f0 df bf 	mov    $0xffffffffbfdff000,%rdx
  200da0:	48 c7 c6 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rsi
  200da7:	48 c7 c7 40 3f 16 81 	mov    $0xffffffff81163f40,%rdi
  200dae:	e8 63 1f e1 80       	callq  ffffffff81012d16 <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb>
  200db3:	be d4 03 00 00       	mov    $0x3d4,%esi
  200db8:	b0 0c                	mov    $0xc,%al
  200dba:	89 f2                	mov    %esi,%edx
  200dbc:	ee                   	out    %al,(%dx)
  200dbd:	b9 d5 03 00 00       	mov    $0x3d5,%ecx
  200dc2:	b0 08                	mov    $0x8,%al
  200dc4:	89 ca                	mov    %ecx,%edx
  200dc6:	ee                   	out    %al,(%dx)
  200dc7:	b0 0d                	mov    $0xd,%al
  200dc9:	89 f2                	mov    %esi,%edx
  200dcb:	ee                   	out    %al,(%dx)
  200dcc:	31 c0                	xor    %eax,%eax
  200dce:	89 ca                	mov    %ecx,%edx
  200dd0:	ee                   	out    %al,(%dx)

    Pd::kern.Space_mem::insert (Pd::kern.quota, HV_GLOBAL_FBUF, 0, Hpt::HPT_NX | Hpt::HPT_G | Hpt::HPT_UC | Hpt::HPT_W | Hpt::HPT_P, 0xb9000);

    set_page (1);

    enable();
  200dd1:	58                   	pop    %rax
  200dd2:	48 89 df             	mov    %rbx,%rdi
  200dd5:	5a                   	pop    %rdx
}
  200dd6:	5b                   	pop    %rbx

    Pd::kern.Space_mem::insert (Pd::kern.quota, HV_GLOBAL_FBUF, 0, Hpt::HPT_NX | Hpt::HPT_G | Hpt::HPT_UC | Hpt::HPT_W | Hpt::HPT_P, 0xb9000);

    set_page (1);

    enable();
  200dd7:	e9 2e 14 e0 80       	jmpq   ffffffff8100220a <_ZN7Console6enableEv>
  200ddc:	c3                   	retq   
  200ddd:	90                   	nop

0000000000200dde <_ZN11Console_vga5setupEv>:
}

void Console_vga::setup()
{
    if (Cmdline::novga || !Cmdline::spinner)
  200dde:	80 3d b4 0f e2 80 00 	cmpb   $0x0,-0x7f1df04c(%rip)        # ffffffff81021d99 <_ZN7Cmdline5novgaE>
  200de5:	0f 85 c0 00 00 00    	jne    200eab <_ZN11Console_vga5setupEv+0xcd>

    enable();
}

void Console_vga::setup()
{
  200deb:	41 55                	push   %r13
  200ded:	41 54                	push   %r12
  200def:	45 31 ed             	xor    %r13d,%r13d
  200df2:	55                   	push   %rbp
  200df3:	53                   	push   %rbx
  200df4:	49 89 fc             	mov    %rdi,%r12
  200df7:	52                   	push   %rdx
    if (Cmdline::novga || !Cmdline::spinner)
  200df8:	80 3d 9e 0f e2 80 00 	cmpb   $0x0,-0x7f1df062(%rip)        # ffffffff81021d9d <_ZN7Cmdline7spinnerE>

template <typename T>
ALWAYS_INLINE
static inline T min (T v1, T v2)
{
    return v1 < v2 ? v1 : v2;
  200dff:	bd 0c 00 00 00       	mov    $0xc,%ebp
  200e04:	0f 84 9a 00 00 00    	je     200ea4 <_ZN11Console_vga5setupEv+0xc6>
        return;

    for (unsigned c = 0; c < min (Cpu::online, 12U); c++) {
  200e0a:	8b 05 30 12 f6 80    	mov    -0x7f09edd0(%rip),%eax        # ffffffff81162040 <_ZN3Cpu6onlineE>
  200e10:	83 f8 0c             	cmp    $0xc,%eax
  200e13:	0f 43 c5             	cmovae %ebp,%eax
  200e16:	41 39 c5             	cmp    %eax,%r13d
  200e19:	0f 83 85 00 00 00    	jae    200ea4 <_ZN11Console_vga5setupEv+0xc6>

        if (row == --num)
  200e1f:	41 8b 44 24 10       	mov    0x10(%r12),%eax
  200e24:	41 8b 5c 24 14       	mov    0x14(%r12),%ebx
  200e29:	8d 50 ff             	lea    -0x1(%rax),%edx
  200e2c:	39 d3                	cmp    %edx,%ebx
  200e2e:	41 89 54 24 10       	mov    %edx,0x10(%r12)
  200e33:	75 34                	jne    200e69 <_ZN11Console_vga5setupEv+0x8b>
        }

        ALWAYS_INLINE
        inline void clear_row (unsigned r)
        {
            memcpy (reinterpret_cast<void *>(HV_GLOBAL_FBUF), reinterpret_cast<void *>(HV_GLOBAL_FBUF + 160), 160 * r);
  200e35:	69 db a0 00 00 00    	imul   $0xa0,%ebx,%ebx
            clear_row (row--);
  200e3b:	83 e8 02             	sub    $0x2,%eax
  200e3e:	48 c7 c6 a0 f0 df bf 	mov    $0xffffffffbfdff0a0,%rsi
  200e45:	41 89 44 24 14       	mov    %eax,0x14(%r12)
  200e4a:	48 c7 c7 00 f0 df bf 	mov    $0xffffffffbfdff000,%rdi
  200e51:	48 89 da             	mov    %rbx,%rdx
  200e54:	e8 09 60 e1 80       	callq  ffffffff81016e62 <memcpy>
            memset (reinterpret_cast<void *>(HV_GLOBAL_FBUF + 160 * r), 0, 160);
  200e59:	48 8d bb 00 f0 df bf 	lea    -0x40201000(%rbx),%rdi
inline void *memset(void *d, int c, size_t n) {
    mword dummy;
    asm volatile ("rep; stosb"
                : "=D" (dummy), "+c" (n)
                : "0" (d), "a" (c)
                : "memory");
  200e60:	b9 a0 00 00 00       	mov    $0xa0,%ecx
  200e65:	31 c0                	xor    %eax,%eax
  200e67:	f3 aa                	rep stos %al,%es:(%rdi)

    enable();
}

void Console_vga::setup()
{
  200e69:	ba 10 00 00 00       	mov    $0x10,%edx

        if (row == --num)
            clear_row (row--);

        for (unsigned i = SPN_GSI; i < 80; i++)
            put (num, i, COLOR_LIGHT_BLACK, ((i - SPN_GSI) & 0xf)["0123456789ABCDEF"]);
  200e6e:	41 8b 44 24 10       	mov    0x10(%r12),%eax
  200e73:	48 89 d1             	mov    %rdx,%rcx
  200e76:	83 e1 0f             	and    $0xf,%ecx
        inline unsigned spinner (unsigned id) { return id < 25 - num ? 24 - id : 0; }

        ALWAYS_INLINE
        inline void put (unsigned long r, unsigned long c, Color color, int x)
        {
            *reinterpret_cast<unsigned short volatile *>(HV_GLOBAL_FBUF + r * 160 + c * 2) = static_cast<unsigned short>(color << 8 | x);
  200e79:	66 0f be 89 d8 d7 01 	movsbw -0x7efe2828(%rcx),%cx
  200e80:	81 
  200e81:	48 6b c0 50          	imul   $0x50,%rax,%rax
  200e85:	80 cd 08             	or     $0x8,%ch
  200e88:	48 01 d0             	add    %rdx,%rax
  200e8b:	48 ff c2             	inc    %rdx
    for (unsigned c = 0; c < min (Cpu::online, 12U); c++) {

        if (row == --num)
            clear_row (row--);

        for (unsigned i = SPN_GSI; i < 80; i++)
  200e8e:	48 83 fa 50          	cmp    $0x50,%rdx
  200e92:	66 89 8c 00 00 f0 df 	mov    %cx,-0x40201000(%rax,%rax,1)
  200e99:	bf 
  200e9a:	75 d2                	jne    200e6e <_ZN11Console_vga5setupEv+0x90>
void Console_vga::setup()
{
    if (Cmdline::novga || !Cmdline::spinner)
        return;

    for (unsigned c = 0; c < min (Cpu::online, 12U); c++) {
  200e9c:	41 ff c5             	inc    %r13d
  200e9f:	e9 66 ff ff ff       	jmpq   200e0a <_ZN11Console_vga5setupEv+0x2c>
            clear_row (row--);

        for (unsigned i = SPN_GSI; i < 80; i++)
            put (num, i, COLOR_LIGHT_BLACK, ((i - SPN_GSI) & 0xf)["0123456789ABCDEF"]);
    }
}
  200ea4:	58                   	pop    %rax
  200ea5:	5b                   	pop    %rbx
  200ea6:	5d                   	pop    %rbp
  200ea7:	41 5c                	pop    %r12
  200ea9:	41 5d                	pop    %r13
  200eab:	c3                   	retq   

0000000000200eac <_ZN4DmarC1Em>:
Dmar *      Dmar::list;
Dmar_ctx *  Dmar::ctx = new (Pd::kern.quota) Dmar_ctx;
Dmar_irt *  Dmar::irt = new (Pd::kern.quota) Dmar_irt;
uint32      Dmar::gcmd = GCMD_TE;

Dmar::Dmar (Paddr p) : List<Dmar> (list), reg_base ((hwdev_addr -= PAGE_SIZE) | (p & PAGE_MASK)), invq (static_cast<Dmar_qi *>(Buddy::allocator.alloc (ord, Pd::kern.quota, Buddy::FILL_0))), invq_idx (0)
  200eac:	55                   	push   %rbp
  200ead:	53                   	push   %rbx
  200eae:	48 89 f5             	mov    %rsi,%rbp
  200eb1:	48 89 fb             	mov    %rdi,%rbx
  200eb4:	48 c7 c2 60 20 16 81 	mov    $0xffffffff81162060,%rdx
  200ebb:	48 83 ec 18          	sub    $0x18,%rsp
    protected:
        T *next;

    public:
        ALWAYS_INLINE
        explicit inline List (T *&list) : next (nullptr)
  200ebf:	48 c7 07 00 00 00 00 	movq   $0x0,(%rdi)
        {
            T **ptr; for (ptr = &list; *ptr; ptr = &(*ptr)->next) ; *ptr = static_cast<T *>(this);
  200ec6:	48 8b 05 93 11 f6 80 	mov    -0x7f09ee6d(%rip),%rax        # ffffffff81162060 <_ZN4Dmar4listE>
  200ecd:	48 85 c0             	test   %rax,%rax
  200ed0:	74 08                	je     200eda <_ZN4DmarC1Em+0x2e>
  200ed2:	48 89 c2             	mov    %rax,%rdx
  200ed5:	48 8b 00             	mov    (%rax),%rax
  200ed8:	eb f3                	jmp    200ecd <_ZN4DmarC1Em+0x21>
  200eda:	48 89 1a             	mov    %rbx,(%rdx)
  200edd:	48 8b 05 ec 0c e2 80 	mov    -0x7f1df314(%rip),%rax        # ffffffff81021bd0 <hwdev_addr>
  200ee4:	48 89 ea             	mov    %rbp,%rdx
  200ee7:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
  200eed:	b9 01 00 00 00       	mov    $0x1,%ecx
  200ef2:	31 f6                	xor    %esi,%esi
  200ef4:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
  200efb:	48 2d 00 10 00 00    	sub    $0x1000,%rax
  200f01:	48 89 05 c8 0c e2 80 	mov    %rax,-0x7f1df338(%rip)        # ffffffff81021bd0 <hwdev_addr>
  200f08:	48 09 d0             	or     %rdx,%rax
  200f0b:	48 c7 c2 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rdx
  200f12:	48 89 43 08          	mov    %rax,0x8(%rbx)
  200f16:	e8 d7 09 e0 80       	callq  ffffffff810018f2 <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
{
    Pd::kern.Space_mem::delreg (Pd::kern.quota, p & ~PAGE_MASK);
  200f1b:	49 89 e8             	mov    %rbp,%r8
Dmar *      Dmar::list;
Dmar_ctx *  Dmar::ctx = new (Pd::kern.quota) Dmar_ctx;
Dmar_irt *  Dmar::irt = new (Pd::kern.quota) Dmar_irt;
uint32      Dmar::gcmd = GCMD_TE;

Dmar::Dmar (Paddr p) : List<Dmar> (list), reg_base ((hwdev_addr -= PAGE_SIZE) | (p & PAGE_MASK)), invq (static_cast<Dmar_qi *>(Buddy::allocator.alloc (ord, Pd::kern.quota, Buddy::FILL_0))), invq_idx (0)
  200f1e:	48 89 43 20          	mov    %rax,0x20(%rbx)
{
    Pd::kern.Space_mem::delreg (Pd::kern.quota, p & ~PAGE_MASK);
  200f22:	48 c7 c6 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rsi
  200f29:	49 81 e0 00 f0 ff ff 	and    $0xfffffffffffff000,%r8
  200f30:	48 c7 c7 30 3d 16 81 	mov    $0xffffffff81163d30,%rdi
Dmar *      Dmar::list;
Dmar_ctx *  Dmar::ctx = new (Pd::kern.quota) Dmar_ctx;
Dmar_irt *  Dmar::irt = new (Pd::kern.quota) Dmar_irt;
uint32      Dmar::gcmd = GCMD_TE;

Dmar::Dmar (Paddr p) : List<Dmar> (list), reg_base ((hwdev_addr -= PAGE_SIZE) | (p & PAGE_MASK)), invq (static_cast<Dmar_qi *>(Buddy::allocator.alloc (ord, Pd::kern.quota, Buddy::FILL_0))), invq_idx (0)
  200f37:	c7 43 28 00 00 00 00 	movl   $0x0,0x28(%rbx)
{
    Pd::kern.Space_mem::delreg (Pd::kern.quota, p & ~PAGE_MASK);
  200f3e:	4c 89 c2             	mov    %r8,%rdx
  200f41:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  200f46:	e8 43 20 e0 80       	callq  ffffffff81002f8e <_ZN5Space6delregER5Quotam>
  200f4b:	6a 00                	pushq  $0x0
  200f4d:	48 8b 53 08          	mov    0x8(%rbx),%rdx
  200f51:	31 c9                	xor    %ecx,%ecx
  200f53:	6a 00                	pushq  $0x0
  200f55:	4c 8b 44 24 18       	mov    0x18(%rsp),%r8
  200f5a:	48 c7 c6 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rsi
  200f61:	41 b9 13 01 00 00    	mov    $0x113,%r9d
  200f67:	48 c7 c7 40 3f 16 81 	mov    $0xffffffff81163f40,%rdi
  200f6e:	e8 a3 1d e1 80       	callq  ffffffff81012d16 <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb>
  200f73:	48 8b 4b 08          	mov    0x8(%rbx),%rcx

        template <typename T>
        ALWAYS_INLINE
        inline T read (Reg reg)
        {
            return *reinterpret_cast<T volatile *>(reg_base + reg);
  200f77:	48 8b 51 08          	mov    0x8(%rcx),%rdx
    Pd::kern.Space_mem::insert (Pd::kern.quota, reg_base, 0, Hpt::HPT_NX | Hpt::HPT_G | Hpt::HPT_UC | Hpt::HPT_W | Hpt::HPT_P, p & ~PAGE_MASK);

    cap  = read<uint64>(REG_CAP);
  200f7b:	48 89 53 10          	mov    %rdx,0x10(%rbx)
  200f7f:	48 8b 41 10          	mov    0x10(%rcx),%rax
    ecap = read<uint64>(REG_ECAP);

    Dpt::ord = min (Dpt::ord, static_cast<mword>(bit_scan_reverse (static_cast<mword>(cap >> 34) & 0xf) + 2) * Dpt::bpl() - 1);
  200f83:	48 c1 ea 22          	shr    $0x22,%rdx
{
    Pd::kern.Space_mem::delreg (Pd::kern.quota, p & ~PAGE_MASK);
    Pd::kern.Space_mem::insert (Pd::kern.quota, reg_base, 0, Hpt::HPT_NX | Hpt::HPT_G | Hpt::HPT_UC | Hpt::HPT_W | Hpt::HPT_P, p & ~PAGE_MASK);

    cap  = read<uint64>(REG_CAP);
    ecap = read<uint64>(REG_ECAP);
  200f87:	48 89 43 18          	mov    %rax,0x18(%rbx)
#include "util.hpp"

ALWAYS_INLINE
inline long int bit_scan_reverse (mword val)
{
    if (EXPECT_FALSE (!val))
  200f8b:	58                   	pop    %rax
        return -1;
  200f8c:	48 83 c8 ff          	or     $0xffffffffffffffff,%rax
#include "util.hpp"

ALWAYS_INLINE
inline long int bit_scan_reverse (mword val)
{
    if (EXPECT_FALSE (!val))
  200f90:	83 e2 0f             	and    $0xf,%edx
  200f93:	5e                   	pop    %rsi
  200f94:	74 04                	je     200f9a <_ZN4DmarC1Em+0xee>
        return -1;

    asm volatile ("bsr %1, %0" : "=r" (val) : "rm" (val));

    return val;
  200f96:	48 0f bd c2          	bsr    %rdx,%rax

    Dpt::ord = min (Dpt::ord, static_cast<mword>(bit_scan_reverse (static_cast<mword>(cap >> 34) & 0xf) + 2) * Dpt::bpl() - 1);
  200f9a:	48 83 c0 02          	add    $0x2,%rax
  200f9e:	48 8b 15 43 0c e2 80 	mov    -0x7f1df3bd(%rip),%rdx        # ffffffff81021be8 <_ZN3Dpt3ordE>
  200fa5:	48 8d 04 c0          	lea    (%rax,%rax,8),%rax
  200fa9:	48 ff c8             	dec    %rax
  200fac:	48 39 d0             	cmp    %rdx,%rax
  200faf:	48 0f 47 c2          	cmova  %rdx,%rax
  200fb3:	48 89 05 2e 0c e2 80 	mov    %rax,-0x7f1df3d2(%rip)        # ffffffff81021be8 <_ZN3Dpt3ordE>

    write<uint32>(REG_FEADDR, 0xfee00000 | Cpu::apic_id[0] << 12);
  200fba:	0f b6 05 ff 0f f6 80 	movzbl -0x7f09f001(%rip),%eax        # ffffffff81161fc0 <_ZN3Cpu7apic_idE>
  200fc1:	c1 e0 0c             	shl    $0xc,%eax
  200fc4:	0d 00 00 e0 fe       	or     $0xfee00000,%eax

        template <typename T>
        ALWAYS_INLINE
        inline void write (Reg reg, T val)
        {
            *reinterpret_cast<T volatile *>(reg_base + reg) = val;
  200fc9:	89 41 40             	mov    %eax,0x40(%rcx)
  200fcc:	48 8b 43 08          	mov    0x8(%rbx),%rax
  200fd0:	c7 40 3c a6 00 00 00 	movl   $0xa6,0x3c(%rax)
  200fd7:	48 8b 43 08          	mov    0x8(%rbx),%rax
  200fdb:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%rax)
        }

        ALWAYS_INLINE
        inline mword virt_to_phys (mword virt)
        {
            return virt - reinterpret_cast<mword>(&OFFSET);
  200fe2:	48 8b 05 6f 10 f6 80 	mov    -0x7f09ef91(%rip),%rax        # ffffffff81162058 <_ZN4Dmar3ctxE>
  200fe9:	48 8b 53 08          	mov    0x8(%rbx),%rdx
  200fed:	48 2d 00 00 c0 80    	sub    $0xffffffff80c00000,%rax
  200ff3:	48 89 42 20          	mov    %rax,0x20(%rdx)
  200ff7:	48 8b 43 08          	mov    0x8(%rbx),%rax
  200ffb:	c7 40 18 00 00 00 40 	movl   $0x40000000,0x18(%rax)
  201002:	48 8b 53 08          	mov    0x8(%rbx),%rdx

        template <typename T>
        ALWAYS_INLINE
        inline T read (Reg reg)
        {
            return *reinterpret_cast<T volatile *>(reg_base + reg);
  201006:	8b 42 1c             	mov    0x1c(%rdx),%eax

        ALWAYS_INLINE
        inline void command (uint32 val)
        {
            write<uint32>(REG_GCMD, val);
            while ((read<uint32>(REG_GSTS) & val) != val)
  201009:	a9 00 00 00 40       	test   $0x40000000,%eax
  20100e:	75 04                	jne    201014 <_ZN4DmarC1Em+0x168>
  201010:	f3 90                	pause  
  201012:	eb ee                	jmp    201002 <_ZN4DmarC1Em+0x156>
    write<uint32>(REG_FECTL,  0);

    write<uint64>(REG_RTADDR, Buddy::ptr_to_phys (ctx));
    command (GCMD_SRTP);

    if (ir()) {
  201014:	f6 43 18 08          	testb  $0x8,0x18(%rbx)
  201018:	74 3f                	je     201059 <_ZN4DmarC1Em+0x1ad>
  20101a:	48 8b 05 2f 10 f6 80 	mov    -0x7f09efd1(%rip),%rax        # ffffffff81162050 <_ZN4Dmar3irtE>
  201021:	48 2d 00 00 c0 80    	sub    $0xffffffff80c00000,%rax
        write<uint64>(REG_IRTA, Buddy::ptr_to_phys (irt) | 7);
  201027:	48 83 c8 07          	or     $0x7,%rax

        template <typename T>
        ALWAYS_INLINE
        inline void write (Reg reg, T val)
        {
            *reinterpret_cast<T volatile *>(reg_base + reg) = val;
  20102b:	48 89 82 b8 00 00 00 	mov    %rax,0xb8(%rdx)
  201032:	48 8b 43 08          	mov    0x8(%rbx),%rax
  201036:	c7 40 18 00 00 00 01 	movl   $0x1000000,0x18(%rax)

        template <typename T>
        ALWAYS_INLINE
        inline T read (Reg reg)
        {
            return *reinterpret_cast<T volatile *>(reg_base + reg);
  20103d:	48 8b 43 08          	mov    0x8(%rbx),%rax
  201041:	8b 40 1c             	mov    0x1c(%rax),%eax

        ALWAYS_INLINE
        inline void command (uint32 val)
        {
            write<uint32>(REG_GCMD, val);
            while ((read<uint32>(REG_GSTS) & val) != val)
  201044:	a9 00 00 00 01       	test   $0x1000000,%eax
  201049:	75 04                	jne    20104f <_ZN4DmarC1Em+0x1a3>
  20104b:	f3 90                	pause  
  20104d:	eb ee                	jmp    20103d <_ZN4DmarC1Em+0x191>
        command (GCMD_SIRTP);
        gcmd |= GCMD_IRE;
  20104f:	81 0d 1f 06 e2 80 00 	orl    $0x2000000,-0x7f1df9e1(%rip)        # ffffffff81021678 <CTORS_E>
  201056:	00 00 02 
    }

    if (qi()) {
  201059:	f6 43 18 02          	testb  $0x2,0x18(%rbx)
  20105d:	74 4b                	je     2010aa <_ZN4DmarC1Em+0x1fe>

        template <typename T>
        ALWAYS_INLINE
        inline void write (Reg reg, T val)
        {
            *reinterpret_cast<T volatile *>(reg_base + reg) = val;
  20105f:	48 8b 43 08          	mov    0x8(%rbx),%rax
  201063:	48 c7 80 88 00 00 00 	movq   $0x0,0x88(%rax)
  20106a:	00 00 00 00 
  20106e:	48 8b 43 20          	mov    0x20(%rbx),%rax
  201072:	48 8b 53 08          	mov    0x8(%rbx),%rdx
  201076:	48 2d 00 00 c0 80    	sub    $0xffffffff80c00000,%rax
  20107c:	48 89 82 90 00 00 00 	mov    %rax,0x90(%rdx)
  201083:	48 8b 43 08          	mov    0x8(%rbx),%rax
  201087:	c7 40 18 00 00 00 04 	movl   $0x4000000,0x18(%rax)

        template <typename T>
        ALWAYS_INLINE
        inline T read (Reg reg)
        {
            return *reinterpret_cast<T volatile *>(reg_base + reg);
  20108e:	48 8b 43 08          	mov    0x8(%rbx),%rax
  201092:	8b 40 1c             	mov    0x1c(%rax),%eax

        ALWAYS_INLINE
        inline void command (uint32 val)
        {
            write<uint32>(REG_GCMD, val);
            while ((read<uint32>(REG_GSTS) & val) != val)
  201095:	a9 00 00 00 04       	test   $0x4000000,%eax
  20109a:	75 04                	jne    2010a0 <_ZN4DmarC1Em+0x1f4>
  20109c:	f3 90                	pause  
  20109e:	eb ee                	jmp    20108e <_ZN4DmarC1Em+0x1e2>
        write<uint64>(REG_IQT, 0);
        write<uint64>(REG_IQA, Buddy::ptr_to_phys (invq));
        command (GCMD_QIE);
        gcmd |= GCMD_QIE;
  2010a0:	81 0d ce 05 e2 80 00 	orl    $0x4000000,-0x7f1dfa32(%rip)        # ffffffff81021678 <CTORS_E>
  2010a7:	00 00 04 
    }
}
  2010aa:	48 83 c4 18          	add    $0x18,%rsp
  2010ae:	5b                   	pop    %rbx
  2010af:	5d                   	pop    %rbp
  2010b0:	c3                   	retq   
  2010b1:	90                   	nop

00000000002010b2 <_ZN3Gsi5setupEv>:

Gsi         Gsi::gsi_table[NUM_GSI];
unsigned    Gsi::irq_table[NUM_IRQ];

void Gsi::setup()
{
  2010b2:	41 54                	push   %r12
  2010b4:	55                   	push   %rbp
  2010b5:	48 c7 c5 40 21 16 81 	mov    $0xffffffff81162140,%rbp
  2010bc:	53                   	push   %rbx
  2010bd:	31 db                	xor    %ebx,%ebx

            call_rcu(true);
        }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
  2010bf:	48 c7 c6 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rsi
  2010c6:	48 c7 c7 80 40 16 81 	mov    $0xffffffff81164080,%rdi
  2010cd:	e8 5c 48 e1 80       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
  2010d2:	48 8d 53 40          	lea    0x40(%rbx),%rdx
  2010d6:	49 89 c4             	mov    %rax,%r12
    for (unsigned gsi = 0; gsi < NUM_GSI; gsi++) {

        Space_obj::insert_root (Pd::kern.quota, Gsi::gsi_table[gsi].sm = new (Pd::kern.quota) Sm (&Pd::kern, NUM_CPU + gsi));
  2010d9:	45 31 c9             	xor    %r9d,%r9d
  2010dc:	45 31 c0             	xor    %r8d,%r8d
  2010df:	31 c9                	xor    %ecx,%ecx
  2010e1:	48 89 c7             	mov    %rax,%rdi
  2010e4:	48 c7 c6 a0 3c 16 81 	mov    $0xffffffff81163ca0,%rsi
  2010eb:	e8 72 4e e1 80       	callq  ffffffff81015f62 <_ZN2SmC1EP2PdmmPS_m>
  2010f0:	4c 89 65 00          	mov    %r12,0x0(%rbp)
  2010f4:	4c 89 e6             	mov    %r12,%rsi
  2010f7:	48 c7 c7 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rdi
  2010fe:	e8 67 59 e1 80       	callq  ffffffff81016a6a <_ZN9Space_obj11insert_rootER5QuotaP7Kobject>
  201103:	8d 43 20             	lea    0x20(%rbx),%eax

        gsi_table[gsi].vec = static_cast<uint8>(VEC_GSI + gsi);

        if (gsi < NUM_IRQ) {
  201106:	48 83 fb 0f          	cmp    $0xf,%rbx
  20110a:	88 45 10             	mov    %al,0x10(%rbp)
  20110d:	89 d8                	mov    %ebx,%eax
  20110f:	77 14                	ja     201125 <_ZN3Gsi5setupEv+0x73>
            irq_table[gsi] = gsi;
            gsi_table[gsi].trg = 0;
  201111:	48 6b c0 18          	imul   $0x18,%rax,%rax
        Space_obj::insert_root (Pd::kern.quota, Gsi::gsi_table[gsi].sm = new (Pd::kern.quota) Sm (&Pd::kern, NUM_CPU + gsi));

        gsi_table[gsi].vec = static_cast<uint8>(VEC_GSI + gsi);

        if (gsi < NUM_IRQ) {
            irq_table[gsi] = gsi;
  201115:	89 1c 9d 00 21 16 81 	mov    %ebx,-0x7ee9df00(,%rbx,4)
            gsi_table[gsi].trg = 0;
            gsi_table[gsi].pol = 0;
  20111c:	80 a0 51 21 16 81 5f 	andb   $0x5f,-0x7ee9deaf(%rax)
  201123:	eb 0b                	jmp    201130 <_ZN3Gsi5setupEv+0x7e>
        } else {
            gsi_table[gsi].trg = 1;
  201125:	48 6b c0 18          	imul   $0x18,%rax,%rax
            gsi_table[gsi].pol = 1;
  201129:	80 88 51 21 16 81 a0 	orb    $0xa0,-0x7ee9deaf(%rax)
  201130:	48 ff c3             	inc    %rbx
  201133:	48 83 c5 18          	add    $0x18,%rbp
Gsi         Gsi::gsi_table[NUM_GSI];
unsigned    Gsi::irq_table[NUM_IRQ];

void Gsi::setup()
{
    for (unsigned gsi = 0; gsi < NUM_GSI; gsi++) {
  201137:	48 81 fb 80 00 00 00 	cmp    $0x80,%rbx
  20113e:	0f 85 7b ff ff ff    	jne    2010bf <_ZN3Gsi5setupEv+0xd>
        } else {
            gsi_table[gsi].trg = 1;
            gsi_table[gsi].pol = 1;
        }
    }
}
  201144:	5b                   	pop    %rbx
  201145:	5d                   	pop    %rbp
  201146:	41 5c                	pop    %r12
  201148:	c3                   	retq   
  201149:	90                   	nop

000000000020114a <_ZN3Hip7add_memERP7Hip_memmm>:

    h->length = static_cast<uint16>(reinterpret_cast<mword>(mem) - reinterpret_cast<mword>(h));
}

void Hip::add_mem (Hip_mem *&mem, mword addr, size_t len)
{
  20114a:	55                   	push   %rbp
  20114b:	53                   	push   %rbx
  20114c:	48 89 d5             	mov    %rdx,%rbp
  20114f:	51                   	push   %rcx
  201150:	48 89 fb             	mov    %rdi,%rbx
    char *mmap_addr = static_cast<char *>(Hpt::remap (Pd::kern.quota, addr));
  201153:	48 c7 c7 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rdi
  20115a:	e8 b3 6f e0 80       	callq  ffffffff81008112 <_ZN3Hpt5remapER5Quotam>

    for (char *ptr = mmap_addr; ptr < mmap_addr + len; mem++) {
  20115f:	48 01 c5             	add    %rax,%rbp
  201162:	48 39 e8             	cmp    %rbp,%rax
  201165:	73 36                	jae    20119d <_ZN3Hip7add_memERP7Hip_memmm+0x53>

        Multiboot_mmap *map = reinterpret_cast<Multiboot_mmap *>(ptr);

        mem->addr = map->addr;
  201167:	48 8b 48 04          	mov    0x4(%rax),%rcx
  20116b:	48 8b 13             	mov    (%rbx),%rdx
  20116e:	48 89 0a             	mov    %rcx,(%rdx)
        mem->size = map->len;
  201171:	48 8b 48 0c          	mov    0xc(%rax),%rcx
  201175:	48 8b 13             	mov    (%rbx),%rdx
  201178:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
        mem->type = map->type;
  20117c:	48 8b 13             	mov    (%rbx),%rdx
  20117f:	8b 48 14             	mov    0x14(%rax),%ecx
  201182:	89 4a 10             	mov    %ecx,0x10(%rdx)
        mem->aux  = 0;
  201185:	48 8b 13             	mov    (%rbx),%rdx
  201188:	c7 42 14 00 00 00 00 	movl   $0x0,0x14(%rdx)

        ptr += map->size + 4;
  20118f:	8b 10                	mov    (%rax),%edx

void Hip::add_mem (Hip_mem *&mem, mword addr, size_t len)
{
    char *mmap_addr = static_cast<char *>(Hpt::remap (Pd::kern.quota, addr));

    for (char *ptr = mmap_addr; ptr < mmap_addr + len; mem++) {
  201191:	48 83 03 18          	addq   $0x18,(%rbx)
        mem->addr = map->addr;
        mem->size = map->len;
        mem->type = map->type;
        mem->aux  = 0;

        ptr += map->size + 4;
  201195:	83 c2 04             	add    $0x4,%edx
  201198:	48 01 d0             	add    %rdx,%rax
  20119b:	eb c5                	jmp    201162 <_ZN3Hip7add_memERP7Hip_memmm+0x18>
    }
}
  20119d:	58                   	pop    %rax
  20119e:	5b                   	pop    %rbx
  20119f:	5d                   	pop    %rbp
  2011a0:	c3                   	retq   
  2011a1:	90                   	nop

00000000002011a2 <_ZN3Hip7add_modERP7Hip_memmm>:

void Hip::add_mod (Hip_mem *&mem, mword addr, size_t count)
{
  2011a2:	55                   	push   %rbp
  2011a3:	53                   	push   %rbx
  2011a4:	48 89 d5             	mov    %rdx,%rbp
  2011a7:	51                   	push   %rcx
  2011a8:	48 89 fb             	mov    %rdi,%rbx
    Multiboot_module *mod = static_cast<Multiboot_module *>(Hpt::remap (Pd::kern.quota, addr));
  2011ab:	48 c7 c7 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rdi
  2011b2:	e8 5b 6f e0 80       	callq  ffffffff81008112 <_ZN3Hpt5remapER5Quotam>

    if (count) {
  2011b7:	48 85 ed             	test   %rbp,%rbp
  2011ba:	74 17                	je     2011d3 <_ZN3Hip7add_modERP7Hip_memmm+0x31>
        root_addr = mod->s_addr;
  2011bc:	8b 38                	mov    (%rax),%edi
  2011be:	48 89 3d 83 1b f6 80 	mov    %rdi,-0x7f09e47d(%rip)        # ffffffff81162d48 <_ZN3Hip9root_addrE>
        root_size = mod->e_addr - mod->s_addr;
  2011c5:	8b 48 04             	mov    0x4(%rax),%ecx
  2011c8:	2b 08                	sub    (%rax),%ecx
  2011ca:	89 cf                	mov    %ecx,%edi
  2011cc:	48 89 3d 6d 1b f6 80 	mov    %rdi,-0x7f09e493(%rip)        # ffffffff81162d40 <_ZN3Hip9root_sizeE>
        ptr += map->size + 4;
    }
}

void Hip::add_mod (Hip_mem *&mem, mword addr, size_t count)
{
  2011d3:	31 c9                	xor    %ecx,%ecx
    if (count) {
        root_addr = mod->s_addr;
        root_size = mod->e_addr - mod->s_addr;
    }

    for (unsigned i = 0; i < count; i++, mod++, mem++) {
  2011d5:	89 ca                	mov    %ecx,%edx
  2011d7:	48 39 ea             	cmp    %rbp,%rdx
  2011da:	73 36                	jae    201212 <_ZN3Hip7add_modERP7Hip_memmm+0x70>
        mem->addr = mod->s_addr;
  2011dc:	8b 38                	mov    (%rax),%edi
  2011de:	48 8b 13             	mov    (%rbx),%rdx
    if (count) {
        root_addr = mod->s_addr;
        root_size = mod->e_addr - mod->s_addr;
    }

    for (unsigned i = 0; i < count; i++, mod++, mem++) {
  2011e1:	ff c1                	inc    %ecx
  2011e3:	48 83 c0 10          	add    $0x10,%rax
        mem->addr = mod->s_addr;
  2011e7:	48 89 3a             	mov    %rdi,(%rdx)
        mem->size = mod->e_addr - mod->s_addr;
  2011ea:	8b 70 f4             	mov    -0xc(%rax),%esi
  2011ed:	2b 70 f0             	sub    -0x10(%rax),%esi
  2011f0:	48 8b 13             	mov    (%rbx),%rdx
  2011f3:	89 f7                	mov    %esi,%edi
  2011f5:	48 89 7a 08          	mov    %rdi,0x8(%rdx)
        mem->type = Hip_mem::MB_MODULE;
  2011f9:	48 8b 13             	mov    (%rbx),%rdx
  2011fc:	c7 42 10 fe ff ff ff 	movl   $0xfffffffe,0x10(%rdx)
        mem->aux  = mod->cmdline;
  201203:	8b 70 f8             	mov    -0x8(%rax),%esi
  201206:	48 8b 13             	mov    (%rbx),%rdx
  201209:	89 72 14             	mov    %esi,0x14(%rdx)
    if (count) {
        root_addr = mod->s_addr;
        root_size = mod->e_addr - mod->s_addr;
    }

    for (unsigned i = 0; i < count; i++, mod++, mem++) {
  20120c:	48 83 03 18          	addq   $0x18,(%rbx)
  201210:	eb c3                	jmp    2011d5 <_ZN3Hip7add_modERP7Hip_memmm+0x33>
        mem->addr = mod->s_addr;
        mem->size = mod->e_addr - mod->s_addr;
        mem->type = Hip_mem::MB_MODULE;
        mem->aux  = mod->cmdline;
    }
}
  201212:	58                   	pop    %rax
  201213:	5b                   	pop    %rbx
  201214:	5d                   	pop    %rbp
  201215:	c3                   	retq   

0000000000201216 <_ZN3Hip7add_mhvERP7Hip_mem>:

void Hip::add_mhv (Hip_mem *&mem)
{
    mem->addr = reinterpret_cast<mword>(&LINK_P);
  201216:	48 8b 07             	mov    (%rdi),%rax
  201219:	48 c7 00 00 00 40 00 	movq   $0x400000,(%rax)
    mem->size = reinterpret_cast<mword>(&LINK_E) - mem->addr;
  201220:	48 8b 17             	mov    (%rdi),%rdx
  201223:	48 c7 c0 00 00 80 08 	mov    $0x8800000,%rax
  20122a:	48 2b 02             	sub    (%rdx),%rax
  20122d:	48 89 42 08          	mov    %rax,0x8(%rdx)
    mem->type = Hip_mem::HYPERVISOR;
  201231:	48 8b 07             	mov    (%rdi),%rax
  201234:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%rax)
    mem++;
  20123b:	48 83 07 18          	addq   $0x18,(%rdi)
  20123f:	c3                   	retq   

0000000000201240 <_ZN3Hip5buildEm>:

mword Hip::root_addr;
mword Hip::root_size;

void Hip::build (mword addr)
{
  201240:	41 56                	push   %r14
  201242:	41 55                	push   %r13
  201244:	48 89 fe             	mov    %rdi,%rsi
  201247:	41 54                	push   %r12
  201249:	55                   	push   %rbp
    h->sel_exc    = NUM_EXC;
    h->sel_vmi    = NUM_VMI;
    h->cfg_page   = PAGE_SIZE;
    h->cfg_utcb   = PAGE_SIZE;

    Multiboot *mbi = static_cast<Multiboot *>(Hpt::remap (Pd::kern.quota, addr));
  20124a:	48 c7 c7 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rdi

mword Hip::root_addr;
mword Hip::root_size;

void Hip::build (mword addr)
{
  201251:	53                   	push   %rbx
  201252:	48 83 ec 10          	sub    $0x10,%rsp
    Hip *h = hip();

    h->signature  = 0x41564f4e;
  201256:	c7 05 a0 5d f6 80 4e 	movl   $0x41564f4e,-0x7f09a260(%rip)        # ffffffff81167000 <PAGE_H>
  20125d:	4f 56 41 
    h->cpu_offs   = reinterpret_cast<mword>(h->cpu_desc) - reinterpret_cast<mword>(h);
  201260:	66 c7 05 9f 5d f6 80 	movw   $0x38,-0x7f09a261(%rip)        # ffffffff81167008 <PAGE_H+0x8>
  201267:	38 00 
    h->cpu_size   = static_cast<uint16>(sizeof (Hip_cpu));
  201269:	66 c7 05 98 5d f6 80 	movw   $0x8,-0x7f09a268(%rip)        # ffffffff8116700a <PAGE_H+0xa>
  201270:	08 00 
    h->mem_offs   = reinterpret_cast<mword>(h->mem_desc) - reinterpret_cast<mword>(h);
  201272:	66 c7 05 91 5d f6 80 	movw   $0x238,-0x7f09a26f(%rip)        # ffffffff8116700c <PAGE_H+0xc>
  201279:	38 02 
    h->mem_size   = static_cast<uint16>(sizeof (Hip_mem));
  20127b:	66 c7 05 8a 5d f6 80 	movw   $0x18,-0x7f09a276(%rip)        # ffffffff8116700e <PAGE_H+0xe>
  201282:	18 00 
    h->api_flg    = FEAT_VMX | FEAT_SVM;
  201284:	c7 05 82 5d f6 80 06 	movl   $0x6,-0x7f09a27e(%rip)        # ffffffff81167010 <PAGE_H+0x10>
  20128b:	00 00 00 
    h->api_ver    = CFG_VER;
  20128e:	c7 05 7c 5d f6 80 07 	movl   $0x7,-0x7f09a284(%rip)        # ffffffff81167014 <PAGE_H+0x14>
  201295:	00 00 00 
    h->sel_num    = Space_obj::caps;
  201298:	c7 05 76 5d f6 80 00 	movl   $0x4000000,-0x7f09a28a(%rip)        # ffffffff81167018 <PAGE_H+0x18>
  20129f:	00 00 04 
    h->sel_gsi    = NUM_GSI;
  2012a2:	c7 05 78 5d f6 80 80 	movl   $0x80,-0x7f09a288(%rip)        # ffffffff81167024 <PAGE_H+0x24>
  2012a9:	00 00 00 
    h->sel_exc    = NUM_EXC;
  2012ac:	c7 05 66 5d f6 80 20 	movl   $0x20,-0x7f09a29a(%rip)        # ffffffff8116701c <PAGE_H+0x1c>
  2012b3:	00 00 00 
    h->sel_vmi    = NUM_VMI;
  2012b6:	c7 05 60 5d f6 80 00 	movl   $0x100,-0x7f09a2a0(%rip)        # ffffffff81167020 <PAGE_H+0x20>
  2012bd:	01 00 00 
    h->cfg_page   = PAGE_SIZE;
  2012c0:	c7 05 5e 5d f6 80 00 	movl   $0x1000,-0x7f09a2a2(%rip)        # ffffffff81167028 <PAGE_H+0x28>
  2012c7:	10 00 00 
    h->cfg_utcb   = PAGE_SIZE;
  2012ca:	c7 05 58 5d f6 80 00 	movl   $0x1000,-0x7f09a2a8(%rip)        # ffffffff8116702c <PAGE_H+0x2c>
  2012d1:	10 00 00 

    Multiboot *mbi = static_cast<Multiboot *>(Hpt::remap (Pd::kern.quota, addr));
  2012d4:	e8 39 6e e0 80       	callq  ffffffff81008112 <_ZN3Hpt5remapER5Quotam>

    uint32 flags       = mbi->flags;
  2012d9:	44 8b 20             	mov    (%rax),%r12d
    uint32 cmdline     = mbi->cmdline;
  2012dc:	8b 78 10             	mov    0x10(%rax),%edi
    uint32 mmap_addr   = mbi->mmap_addr;
  2012df:	44 8b 68 30          	mov    0x30(%rax),%r13d
    uint32 mmap_len    = mbi->mmap_len;
  2012e3:	44 8b 70 2c          	mov    0x2c(%rax),%r14d
    uint32 mods_addr   = mbi->mods_addr;
  2012e7:	8b 58 18             	mov    0x18(%rax),%ebx
    uint32 mods_count  = mbi->mods_count;
  2012ea:	8b 68 14             	mov    0x14(%rax),%ebp

    if (flags & Multiboot::CMDLINE)
  2012ed:	41 f6 c4 04          	test   $0x4,%r12b
  2012f1:	74 05                	je     2012f8 <_ZN3Hip5buildEm+0xb8>
        Cmdline::init (cmdline);
  2012f3:	e8 74 f9 ff ff       	callq  200c6c <_ZN7Cmdline4initEm>

    Hip_mem *mem = h->mem_desc;

    if (flags & Multiboot::MEMORY_MAP)
  2012f8:	41 f6 c4 40          	test   $0x40,%r12b
    uint32 mods_count  = mbi->mods_count;

    if (flags & Multiboot::CMDLINE)
        Cmdline::init (cmdline);

    Hip_mem *mem = h->mem_desc;
  2012fc:	48 c7 44 24 08 38 72 	movq   $0xffffffff81167238,0x8(%rsp)
  201303:	16 81 

    if (flags & Multiboot::MEMORY_MAP)
  201305:	74 10                	je     201317 <_ZN3Hip5buildEm+0xd7>
        add_mem (mem, mmap_addr, mmap_len);
  201307:	48 8d 7c 24 08       	lea    0x8(%rsp),%rdi
  20130c:	44 89 f2             	mov    %r14d,%edx
  20130f:	44 89 ee             	mov    %r13d,%esi
  201312:	e8 33 fe ff ff       	callq  20114a <_ZN3Hip7add_memERP7Hip_memmm>

    if (flags & Multiboot::MODULES)
  201317:	41 80 e4 08          	and    $0x8,%r12b
  20131b:	74 0e                	je     20132b <_ZN3Hip5buildEm+0xeb>
        add_mod (mem, mods_addr, mods_count);
  20131d:	48 8d 7c 24 08       	lea    0x8(%rsp),%rdi
  201322:	89 ea                	mov    %ebp,%edx
  201324:	89 de                	mov    %ebx,%esi
  201326:	e8 77 fe ff ff       	callq  2011a2 <_ZN3Hip7add_modERP7Hip_memmm>

    add_mhv (mem);
  20132b:	48 8d 7c 24 08       	lea    0x8(%rsp),%rdi
  201330:	e8 e1 fe ff ff       	callq  201216 <_ZN3Hip7add_mhvERP7Hip_mem>

    h->length = static_cast<uint16>(reinterpret_cast<mword>(mem) - reinterpret_cast<mword>(h));
  201335:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  20133a:	48 2d 00 70 16 81    	sub    $0xffffffff81167000,%rax
  201340:	66 89 05 bf 5c f6 80 	mov    %ax,-0x7f09a341(%rip)        # ffffffff81167006 <PAGE_H+0x6>
}
  201347:	48 83 c4 10          	add    $0x10,%rsp
  20134b:	5b                   	pop    %rbx
  20134c:	5d                   	pop    %rbp
  20134d:	41 5c                	pop    %r12
  20134f:	41 5d                	pop    %r13
  201351:	41 5e                	pop    %r14
  201353:	c3                   	retq   

0000000000201354 <_ZN3Idt5buildEv>:
#include "selectors.hpp"

ALIGNED(8) Idt Idt::idt[VEC_MAX];

void Idt::build()
{
  201354:	31 d2                	xor    %edx,%edx
    mword *ptr = handlers;

    for (unsigned vector = 0; vector < VEC_MAX; vector++, ptr++)
        if (*ptr)
  201356:	48 8b 82 7c 16 02 81 	mov    -0x7efde984(%rdx),%rax
  20135d:	48 85 c0             	test   %rax,%rax
  201360:	74 3b                	je     20139d <_ZN3Idt5buildEv+0x49>
            idt[vector].set (SYS_INTR_GATE, *ptr & 3, SEL_KERN_CODE, *ptr & ~3);
  201362:	48 89 c1             	mov    %rax,%rcx
  201365:	83 e0 03             	and    $0x3,%eax
  201368:	48 83 e1 fc          	and    $0xfffffffffffffffc,%rcx

        ALWAYS_INLINE
        inline void set (Type type, unsigned dpl, unsigned selector, mword offset)
        {
            val[0] = static_cast<uint32>(selector << 16 | (offset & 0xffff));
            val[1] = static_cast<uint32>((offset & 0xffff0000) | 1u << 15 | dpl << 13 | type);
  20136c:	c1 e0 0d             	shl    $0xd,%eax
        uint32 val[sizeof (mword) / 2];

        ALWAYS_INLINE
        inline void set (Type type, unsigned dpl, unsigned selector, mword offset)
        {
            val[0] = static_cast<uint32>(selector << 16 | (offset & 0xffff));
  20136f:	0f b7 f1             	movzwl %cx,%esi
  201372:	81 ce 00 00 08 00    	or     $0x80000,%esi
  201378:	89 b4 12 90 2d 16 81 	mov    %esi,-0x7ee9d270(%rdx,%rdx,1)
            val[1] = static_cast<uint32>((offset & 0xffff0000) | 1u << 15 | dpl << 13 | type);
  20137f:	89 ce                	mov    %ecx,%esi
#ifdef __x86_64__
            val[2] = static_cast<uint32>(offset >> 32);
  201381:	48 c1 e9 20          	shr    $0x20,%rcx

        ALWAYS_INLINE
        inline void set (Type type, unsigned dpl, unsigned selector, mword offset)
        {
            val[0] = static_cast<uint32>(selector << 16 | (offset & 0xffff));
            val[1] = static_cast<uint32>((offset & 0xffff0000) | 1u << 15 | dpl << 13 | type);
  201385:	66 31 f6             	xor    %si,%si
#ifdef __x86_64__
            val[2] = static_cast<uint32>(offset >> 32);
  201388:	89 8c 12 98 2d 16 81 	mov    %ecx,-0x7ee9d268(%rdx,%rdx,1)

        ALWAYS_INLINE
        inline void set (Type type, unsigned dpl, unsigned selector, mword offset)
        {
            val[0] = static_cast<uint32>(selector << 16 | (offset & 0xffff));
            val[1] = static_cast<uint32>((offset & 0xffff0000) | 1u << 15 | dpl << 13 | type);
  20138f:	09 f0                	or     %esi,%eax
  201391:	80 cc 8e             	or     $0x8e,%ah
  201394:	89 84 12 94 2d 16 81 	mov    %eax,-0x7ee9d26c(%rdx,%rdx,1)
  20139b:	eb 21                	jmp    2013be <_ZN3Idt5buildEv+0x6a>
        uint32 val[sizeof (mword) / 2];

        ALWAYS_INLINE
        inline void set (Type type, unsigned dpl, unsigned selector, mword offset)
        {
            val[0] = static_cast<uint32>(selector << 16 | (offset & 0xffff));
  20139d:	c7 84 12 90 2d 16 81 	movl   $0x400000,-0x7ee9d270(%rdx,%rdx,1)
  2013a4:	00 00 40 00 
            val[1] = static_cast<uint32>((offset & 0xffff0000) | 1u << 15 | dpl << 13 | type);
  2013a8:	c7 84 12 94 2d 16 81 	movl   $0x8500,-0x7ee9d26c(%rdx,%rdx,1)
  2013af:	00 85 00 00 
#ifdef __x86_64__
            val[2] = static_cast<uint32>(offset >> 32);
  2013b3:	c7 84 12 98 2d 16 81 	movl   $0x0,-0x7ee9d268(%rdx,%rdx,1)
  2013ba:	00 00 00 00 
  2013be:	48 83 c2 08          	add    $0x8,%rdx

void Idt::build()
{
    mword *ptr = handlers;

    for (unsigned vector = 0; vector < VEC_MAX; vector++, ptr++)
  2013c2:	48 81 fa 50 05 00 00 	cmp    $0x550,%rdx
  2013c9:	75 8b                	jne    201356 <_ZN3Idt5buildEv+0x2>
        if (*ptr)
            idt[vector].set (SYS_INTR_GATE, *ptr & 3, SEL_KERN_CODE, *ptr & ~3);
        else
            idt[vector].set (SYS_TASK_GATE, 0, SEL_TSS_DBF, 0);
}
  2013cb:	c3                   	retq   

00000000002013cc <kern_ptab_setup>:
#include "pd.hpp"
#include "cow.hpp"

extern "C" INIT
mword kern_ptab_setup()
{
  2013cc:	53                   	push   %rbx
    Hptp hpt;

    // Allocate and map cpu page
    hpt.update (Pd::kern.quota, CPU_LOCAL_DATA, 0,
                Buddy::ptr_to_phys (Buddy::allocator.alloc (0, Pd::kern.quota, Buddy::FILL_0)),
                Hpt::HPT_NX | Hpt::HPT_G | Hpt::HPT_W | Hpt::HPT_P);
  2013cd:	b9 01 00 00 00       	mov    $0x1,%ecx
  2013d2:	48 c7 c2 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rdx
  2013d9:	31 f6                	xor    %esi,%esi
  2013db:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
  2013e2:	48 c7 c3 00 00 c0 80 	mov    $0xffffffff80c00000,%rbx
#include "pd.hpp"
#include "cow.hpp"

extern "C" INIT
mword kern_ptab_setup()
{
  2013e9:	48 83 ec 10          	sub    $0x10,%rsp

    void free_up(Quota &quota, unsigned l, P *, mword, bool (*) (Paddr, mword, unsigned), bool (*) (unsigned, mword));

public:

    Pte() : val(0) {
  2013ed:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
  2013f4:	00 00 
    Hptp hpt;

    // Allocate and map cpu page
    hpt.update (Pd::kern.quota, CPU_LOCAL_DATA, 0,
                Buddy::ptr_to_phys (Buddy::allocator.alloc (0, Pd::kern.quota, Buddy::FILL_0)),
                Hpt::HPT_NX | Hpt::HPT_G | Hpt::HPT_W | Hpt::HPT_P);
  2013f6:	e8 f7 04 e0 80       	callq  ffffffff810018f2 <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
  2013fb:	6a 00                	pushq  $0x0
  2013fd:	6a 00                	pushq  $0x0
  2013ff:	48 29 d8             	sub    %rbx,%rax
  201402:	41 b9 03 01 00 00    	mov    $0x103,%r9d
  201408:	49 89 c0             	mov    %rax,%r8
  20140b:	31 c9                	xor    %ecx,%ecx
  20140d:	48 8d 7c 24 18       	lea    0x18(%rsp),%rdi
  201412:	48 c7 c2 00 f0 ff bf 	mov    $0xffffffffbffff000,%rdx
  201419:	48 c7 c6 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rsi
  201420:	e8 f1 18 e1 80       	callq  ffffffff81012d16 <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb>

    // Allocate and map kernel stack
    hpt.update (Pd::kern.quota, CPU_LOCAL_STCK, 0,
                Buddy::ptr_to_phys (Buddy::allocator.alloc (0, Pd::kern.quota, Buddy::FILL_0)),
                Hpt::HPT_NX | Hpt::HPT_G | Hpt::HPT_W | Hpt::HPT_P);
  201425:	b9 01 00 00 00       	mov    $0x1,%ecx
  20142a:	48 c7 c2 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rdx
  201431:	31 f6                	xor    %esi,%esi
  201433:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
  20143a:	e8 b3 04 e0 80       	callq  ffffffff810018f2 <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
  20143f:	6a 00                	pushq  $0x0
  201441:	6a 00                	pushq  $0x0
  201443:	48 29 d8             	sub    %rbx,%rax
  201446:	41 b9 03 01 00 00    	mov    $0x103,%r9d
  20144c:	49 89 c0             	mov    %rax,%r8
  20144f:	31 c9                	xor    %ecx,%ecx
  201451:	48 8d 7c 24 28       	lea    0x28(%rsp),%rdi
  201456:	48 c7 c2 00 d0 ff bf 	mov    $0xffffffffbfffd000,%rdx
  20145d:	48 c7 c6 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rsi
  201464:	e8 ad 18 e1 80       	callq  ffffffff81012d16 <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb>

    // Sync kernel code and data
    hpt.sync_master_range (Pd::kern.quota, LINK_ADDR, CPU_LOCAL);
  201469:	48 83 c4 20          	add    $0x20,%rsp
  20146d:	48 c7 c1 00 00 e0 bf 	mov    $0xffffffffbfe00000,%rcx
  201474:	48 c7 c2 00 00 00 81 	mov    $0xffffffff81000000,%rdx
  20147b:	48 8d 7c 24 08       	lea    0x8(%rsp),%rdi
  201480:	48 c7 c6 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rsi
  201487:	e8 b2 6b e0 80       	callq  ffffffff8100803e <_ZN3Hpt17sync_master_rangeER5Quotamm>
        PTE_U = HPT_U,
    };

    ALWAYS_INLINE
    inline Paddr addr() const {
        return static_cast<Paddr> (val) & ~PAGE_MASK;
  20148c:	48 8b 44 24 08       	mov    0x8(%rsp),%rax

    return hpt.addr();
}
  201491:	48 83 c4 10          	add    $0x10,%rsp
  201495:	5b                   	pop    %rbx
  201496:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  20149c:	c3                   	retq   

000000000020149d <init>:

extern "C" INIT REGPARM (1)
void init (mword mbi)
{
  20149d:	55                   	push   %rbp
  20149e:	53                   	push   %rbx
  20149f:	48 89 fd             	mov    %rdi,%rbp
  2014a2:	52                   	push   %rdx
  2014a3:	ba 00 10 00 00       	mov    $0x1000,%edx
  2014a8:	48 c7 c7 00 50 16 81 	mov    $0xffffffff81165000,%rdi
  2014af:	48 89 d1             	mov    %rdx,%rcx
  2014b2:	31 c0                	xor    %eax,%eax
  2014b4:	f3 aa                	rep stos %al,%es:(%rdi)
  2014b6:	48 c7 c7 00 60 16 81 	mov    $0xffffffff81166000,%rdi
  2014bd:	48 89 d1             	mov    %rdx,%rcx
  2014c0:	83 c8 ff             	or     $0xffffffff,%eax
  2014c3:	f3 aa                	rep stos %al,%es:(%rdi)
    // Setup 0-page and 1-page
    memset (reinterpret_cast<void *>(&PAGE_0),  0,  PAGE_SIZE);
    memset (reinterpret_cast<void *>(&PAGE_1), ~0u, PAGE_SIZE);

    for (void (**func)() = &CTORS_G; func != &CTORS_E; (*func++)()) ;
  2014c5:	48 c7 c3 d8 15 02 81 	mov    $0xffffffff810215d8,%rbx
  2014cc:	48 81 fb 78 16 02 81 	cmp    $0xffffffff81021678,%rbx
  2014d3:	74 09                	je     2014de <init+0x41>
  2014d5:	48 83 c3 08          	add    $0x8,%rbx
  2014d9:	ff 53 f8             	callq  *-0x8(%rbx)
  2014dc:	eb ee                	jmp    2014cc <init+0x2f>

    Hip::build (mbi);
  2014de:	48 89 ef             	mov    %rbp,%rdi

    for (void (**func)() = &CTORS_C; func != &CTORS_G; (*func++)()) ;
  2014e1:	48 c7 c3 c8 15 02 81 	mov    $0xffffffff810215c8,%rbx
    memset (reinterpret_cast<void *>(&PAGE_0),  0,  PAGE_SIZE);
    memset (reinterpret_cast<void *>(&PAGE_1), ~0u, PAGE_SIZE);

    for (void (**func)() = &CTORS_G; func != &CTORS_E; (*func++)()) ;

    Hip::build (mbi);
  2014e8:	e8 53 fd ff ff       	callq  201240 <_ZN3Hip5buildEm>

    for (void (**func)() = &CTORS_C; func != &CTORS_G; (*func++)()) ;
  2014ed:	48 81 fb d8 15 02 81 	cmp    $0xffffffff810215d8,%rbx
  2014f4:	74 09                	je     2014ff <init+0x62>
  2014f6:	48 83 c3 08          	add    $0x8,%rbx
  2014fa:	ff 53 f8             	callq  *-0x8(%rbx)
  2014fd:	eb ee                	jmp    2014ed <init+0x50>

    // Now we're ready to talk to the world
    Console::print ("\fNOVA Microhypervisor v%d-%07lx (%s): %s %s [%s]\n", CFG_VER, reinterpret_cast<mword>(&GIT_VER), ARCH, __DATE__, __TIME__, COMPILER_STRING);
  2014ff:	50                   	push   %rax
  201500:	68 9d e5 01 81       	pushq  $0xffffffff8101e59d
  201505:	49 c7 c1 4f e5 01 81 	mov    $0xffffffff8101e54f,%r9
  20150c:	49 c7 c0 58 e5 01 81 	mov    $0xffffffff8101e558,%r8
  201513:	48 c7 c1 64 e5 01 81 	mov    $0xffffffff8101e564,%rcx
  20151a:	48 c7 c2 f2 c9 0b 04 	mov    $0x40bc9f2,%rdx
  201521:	be 07 00 00 00       	mov    $0x7,%esi
  201526:	31 c0                	xor    %eax,%eax
  201528:	48 c7 c7 6b e5 01 81 	mov    $0xffffffff8101e56b,%rdi
  20152f:	e8 58 0b e0 80       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>

    Idt::build();
  201534:	e8 1b fe ff ff       	callq  201354 <_ZN3Idt5buildEv>
    Gsi::setup();
  201539:	e8 74 fb ff ff       	callq  2010b2 <_ZN3Gsi5setupEv>
    Acpi::setup();
  20153e:	e8 bd ea ff ff       	callq  200000 <_ZN4Acpi5setupEv>

    Console_vga::con.setup();
  201543:	48 c7 c7 d0 1d 02 81 	mov    $0xffffffff81021dd0,%rdi
  20154a:	e8 8f f8 ff ff       	callq  200dde <_ZN11Console_vga5setupEv>

    Keyb::init();
  20154f:	e8 c0 00 00 00       	callq  201614 <_ZN4Keyb4initEv>
    Cow::initialize();
    
}
  201554:	48 83 c4 18          	add    $0x18,%rsp
  201558:	5b                   	pop    %rbx
  201559:	5d                   	pop    %rbp
    Acpi::setup();

    Console_vga::con.setup();

    Keyb::init();
    Cow::initialize();
  20155a:	e9 fd 6c e0 80       	jmpq   ffffffff8100825c <_ZN3Cow10initializeEv>
  20155f:	90                   	nop

0000000000201560 <_ZN6IoapicC1Emjj>:
INIT_PRIORITY (PRIO_SLAB)
Slab_cache Ioapic::cache (sizeof (Ioapic), 8);

Ioapic *Ioapic::list;

Ioapic::Ioapic (Paddr p, unsigned i, unsigned g) : List<Ioapic> (list), reg_base ((hwdev_addr -= PAGE_SIZE) | (p & PAGE_MASK)), gsi_base (g), id (i), rid (0)
  201560:	53                   	push   %rbx
  201561:	48 89 fb             	mov    %rdi,%rbx
  201564:	48 83 ec 10          	sub    $0x10,%rsp
    protected:
        T *next;

    public:
        ALWAYS_INLINE
        explicit inline List (T *&list) : next (nullptr)
  201568:	48 c7 07 00 00 00 00 	movq   $0x0,(%rdi)
        {
            T **ptr; for (ptr = &list; *ptr; ptr = &(*ptr)->next) ; *ptr = static_cast<T *>(this);
  20156f:	48 8b 05 ba 22 f6 80 	mov    -0x7f09dd46(%rip),%rax        # ffffffff81163830 <_ZN6Ioapic4listE>
  201576:	48 c7 c7 30 38 16 81 	mov    $0xffffffff81163830,%rdi
  20157d:	48 85 c0             	test   %rax,%rax
  201580:	74 08                	je     20158a <_ZN6IoapicC1Emjj+0x2a>
  201582:	48 89 c7             	mov    %rax,%rdi
  201585:	48 8b 00             	mov    (%rax),%rax
  201588:	eb f3                	jmp    20157d <_ZN6IoapicC1Emjj+0x1d>
  20158a:	48 89 1f             	mov    %rbx,(%rdi)
  20158d:	48 8b 05 3c 06 e2 80 	mov    -0x7f1df9c4(%rip),%rax        # ffffffff81021bd0 <hwdev_addr>
  201594:	48 89 f7             	mov    %rsi,%rdi
  201597:	81 e7 ff 0f 00 00    	and    $0xfff,%edi
{
    Pd::kern.Space_mem::delreg (Pd::kern.quota, p & ~PAGE_MASK);
  20159d:	48 81 e6 00 f0 ff ff 	and    $0xfffffffffffff000,%rsi
INIT_PRIORITY (PRIO_SLAB)
Slab_cache Ioapic::cache (sizeof (Ioapic), 8);

Ioapic *Ioapic::list;

Ioapic::Ioapic (Paddr p, unsigned i, unsigned g) : List<Ioapic> (list), reg_base ((hwdev_addr -= PAGE_SIZE) | (p & PAGE_MASK)), gsi_base (g), id (i), rid (0)
  2015a4:	89 4b 10             	mov    %ecx,0x10(%rbx)
{
    Pd::kern.Space_mem::delreg (Pd::kern.quota, p & ~PAGE_MASK);
  2015a7:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
INIT_PRIORITY (PRIO_SLAB)
Slab_cache Ioapic::cache (sizeof (Ioapic), 8);

Ioapic *Ioapic::list;

Ioapic::Ioapic (Paddr p, unsigned i, unsigned g) : List<Ioapic> (list), reg_base ((hwdev_addr -= PAGE_SIZE) | (p & PAGE_MASK)), gsi_base (g), id (i), rid (0)
  2015ac:	89 53 14             	mov    %edx,0x14(%rbx)
{
    Pd::kern.Space_mem::delreg (Pd::kern.quota, p & ~PAGE_MASK);
  2015af:	48 89 f2             	mov    %rsi,%rdx
INIT_PRIORITY (PRIO_SLAB)
Slab_cache Ioapic::cache (sizeof (Ioapic), 8);

Ioapic *Ioapic::list;

Ioapic::Ioapic (Paddr p, unsigned i, unsigned g) : List<Ioapic> (list), reg_base ((hwdev_addr -= PAGE_SIZE) | (p & PAGE_MASK)), gsi_base (g), id (i), rid (0)
  2015b2:	48 2d 00 10 00 00    	sub    $0x1000,%rax
  2015b8:	66 c7 43 18 00 00    	movw   $0x0,0x18(%rbx)
  2015be:	66 c7 43 1a 00 00    	movw   $0x0,0x1a(%rbx)
  2015c4:	48 89 05 05 06 e2 80 	mov    %rax,-0x7f1df9fb(%rip)        # ffffffff81021bd0 <hwdev_addr>
  2015cb:	48 09 f8             	or     %rdi,%rax
{
    Pd::kern.Space_mem::delreg (Pd::kern.quota, p & ~PAGE_MASK);
  2015ce:	48 c7 c6 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rsi
INIT_PRIORITY (PRIO_SLAB)
Slab_cache Ioapic::cache (sizeof (Ioapic), 8);

Ioapic *Ioapic::list;

Ioapic::Ioapic (Paddr p, unsigned i, unsigned g) : List<Ioapic> (list), reg_base ((hwdev_addr -= PAGE_SIZE) | (p & PAGE_MASK)), gsi_base (g), id (i), rid (0)
  2015d5:	48 89 43 08          	mov    %rax,0x8(%rbx)
{
    Pd::kern.Space_mem::delreg (Pd::kern.quota, p & ~PAGE_MASK);
  2015d9:	48 c7 c7 30 3d 16 81 	mov    $0xffffffff81163d30,%rdi
  2015e0:	e8 a9 19 e0 80       	callq  ffffffff81002f8e <_ZN5Space6delregER5Quotam>
  2015e5:	6a 00                	pushq  $0x0
  2015e7:	48 8b 53 08          	mov    0x8(%rbx),%rdx
  2015eb:	41 b9 13 01 00 00    	mov    $0x113,%r9d
  2015f1:	6a 00                	pushq  $0x0
  2015f3:	4c 8b 44 24 18       	mov    0x18(%rsp),%r8
  2015f8:	31 c9                	xor    %ecx,%ecx
  2015fa:	48 c7 c6 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rsi
  201601:	48 c7 c7 40 3f 16 81 	mov    $0xffffffff81163f40,%rdi
  201608:	e8 09 17 e1 80       	callq  ffffffff81012d16 <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb>
    Pd::kern.Space_mem::insert (Pd::kern.quota, reg_base, 0, Hpt::HPT_NX | Hpt::HPT_G | Hpt::HPT_UC | Hpt::HPT_W | Hpt::HPT_P, p & ~PAGE_MASK);

    trace (TRACE_APIC, "APIC:%#lx ID:%#x VER:%#x IRT:%#x PRQ:%u GSI:%u",
           p, i, version(), irt_max(), prq(), gsi_base);
}
  20160d:	48 83 c4 20          	add    $0x20,%rsp
  201611:	5b                   	pop    %rbx
  201612:	c3                   	retq   
  201613:	90                   	nop

0000000000201614 <_ZN4Keyb4initEv>:

unsigned Keyb::gsi = ~0u;

void Keyb::init()
{
    if (!Cmdline::keyb)
  201614:	80 3d 84 07 e2 80 00 	cmpb   $0x0,-0x7f1df87c(%rip)        # ffffffff81021d9f <_ZN7Cmdline4keybE>
  20161b:	75 01                	jne    20161e <_ZN4Keyb4initEv+0xa>
  20161d:	c3                   	retq   
        template <typename T>
        ALWAYS_INLINE
        static inline unsigned in (unsigned port)
        {
            T val;
            asm volatile ("in %w1, %0" : "=a" (val) : "Nd" (port));
  20161e:	e4 64                	in     $0x64,%al
        return;

    while (status() & STS_OUTB)
  201620:	a8 01                	test   $0x1,%al
  201622:	74 04                	je     201628 <_ZN4Keyb4initEv+0x14>
  201624:	e4 60                	in     $0x60,%al
  201626:	eb f6                	jmp    20161e <_ZN4Keyb4initEv+0xa>
  201628:	8b 3d d6 0a f6 80    	mov    -0x7f09f52a(%rip),%edi        # ffffffff81162104 <_ZN3Gsi9irq_tableE+0x4>

    gsi = Gsi::irq_to_gsi (irq);

    trace (TRACE_KEYB, "KEYB: GSI:%#x", gsi);

    Gsi::set (gsi);
  20162e:	31 d2                	xor    %edx,%edx
  201630:	31 f6                	xor    %esi,%esi
        return;

    while (status() & STS_OUTB)
        output();

    gsi = Gsi::irq_to_gsi (irq);
  201632:	89 3d 94 05 e2 80    	mov    %edi,-0x7f1dfa6c(%rip)        # ffffffff81021bcc <_ZN4Keyb3gsiE>

    trace (TRACE_KEYB, "KEYB: GSI:%#x", gsi);

    Gsi::set (gsi);
  201638:	e9 51 64 e0 80       	jmpq   ffffffff81007a8e <_ZN3Gsi3setEjjj>
  20163d:	90                   	nop

000000000020163e <_ZN4Mtrr4initEv>:

INIT_PRIORITY (PRIO_SLAB)
Slab_cache Mtrr::cache (sizeof (Mtrr), 8);

void Mtrr::init()
{
  20163e:	41 55                	push   %r13
  201640:	41 54                	push   %r12
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
  201642:	b9 fe 00 00 00       	mov    $0xfe,%ecx
  201647:	55                   	push   %rbp
  201648:	53                   	push   %rbx
  201649:	52                   	push   %rdx
  20164a:	0f 32                	rdmsr  
    count = Msr::read<uint32>(Msr::IA32_MTRR_CAP) & 0xff;
  20164c:	0f b6 c8             	movzbl %al,%ecx
  20164f:	89 0d 97 22 f6 80    	mov    %ecx,-0x7f09dd69(%rip)        # ffffffff811638ec <_ZN4Mtrr5countE>
  201655:	b9 ff 02 00 00       	mov    $0x2ff,%ecx
  20165a:	0f 32                	rdmsr  
    dtype = Msr::read<uint32>(Msr::IA32_MTRR_DEF_TYPE) & 0xff;
  20165c:	0f b6 c8             	movzbl %al,%ecx

    for (unsigned i = 0; i < count; i++)
  20165f:	41 bc 00 02 00 00    	mov    $0x200,%r12d
  201665:	45 31 ed             	xor    %r13d,%r13d
Slab_cache Mtrr::cache (sizeof (Mtrr), 8);

void Mtrr::init()
{
    count = Msr::read<uint32>(Msr::IA32_MTRR_CAP) & 0xff;
    dtype = Msr::read<uint32>(Msr::IA32_MTRR_DEF_TYPE) & 0xff;
  201668:	89 0d 7a 22 f6 80    	mov    %ecx,-0x7f09dd86(%rip)        # ffffffff811638e8 <_ZN4Mtrr5dtypeE>

    for (unsigned i = 0; i < count; i++)
  20166e:	44 3b 2d 77 22 f6 80 	cmp    -0x7f09dd89(%rip),%r13d        # ffffffff811638ec <_ZN4Mtrr5countE>
  201675:	73 6c                	jae    2016e3 <_ZN4Mtrr4initEv+0xa5>
  201677:	44 89 e1             	mov    %r12d,%ecx
  20167a:	0f 32                	rdmsr  
            return static_cast<T>(static_cast<uint64>(h) << 32 | l);
  20167c:	48 c1 e2 20          	shl    $0x20,%rdx
        new (Pd::kern.quota) Mtrr (Msr::read<uint64>(Msr::Register (Msr::IA32_MTRR_PHYS_BASE + 2 * i)),
                                   Msr::read<uint64>(Msr::Register (Msr::IA32_MTRR_PHYS_MASK + 2 * i)));
  201680:	41 8d 4c 24 01       	lea    0x1(%r12),%ecx
  201685:	48 09 c2             	or     %rax,%rdx
  201688:	48 89 d5             	mov    %rdx,%rbp
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
  20168b:	0f 32                	rdmsr  
            return static_cast<T>(static_cast<uint64>(h) << 32 | l);
  20168d:	48 89 d6             	mov    %rdx,%rsi
    public:
        ALWAYS_INLINE
        explicit inline Mtrr (uint64 b, uint64 m) : List<Mtrr> (list), base (b), mask (m) {}

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
  201690:	48 c7 c7 b0 38 16 81 	mov    $0xffffffff811638b0,%rdi
  201697:	48 c1 e6 20          	shl    $0x20,%rsi
  20169b:	48 89 f3             	mov    %rsi,%rbx
  20169e:	48 c7 c6 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rsi
  2016a5:	48 09 c3             	or     %rax,%rbx
  2016a8:	e8 81 42 e1 80       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
    protected:
        T *next;

    public:
        ALWAYS_INLINE
        explicit inline List (T *&list) : next (nullptr)
  2016ad:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
        {
            T **ptr; for (ptr = &list; *ptr; ptr = &(*ptr)->next) ; *ptr = static_cast<T *>(this);
  2016b4:	48 8b 35 25 22 f6 80 	mov    -0x7f09dddb(%rip),%rsi        # ffffffff811638e0 <_ZN4Mtrr4listE>
  2016bb:	48 c7 c2 e0 38 16 81 	mov    $0xffffffff811638e0,%rdx
  2016c2:	48 85 f6             	test   %rsi,%rsi
  2016c5:	74 08                	je     2016cf <_ZN4Mtrr4initEv+0x91>
  2016c7:	48 89 f2             	mov    %rsi,%rdx
  2016ca:	48 8b 36             	mov    (%rsi),%rsi
  2016cd:	eb f3                	jmp    2016c2 <_ZN4Mtrr4initEv+0x84>
  2016cf:	48 89 02             	mov    %rax,(%rdx)
void Mtrr::init()
{
    count = Msr::read<uint32>(Msr::IA32_MTRR_CAP) & 0xff;
    dtype = Msr::read<uint32>(Msr::IA32_MTRR_DEF_TYPE) & 0xff;

    for (unsigned i = 0; i < count; i++)
  2016d2:	41 ff c5             	inc    %r13d
                                                       bit_scan_forward (static_cast<mword>(mask >> 32)) + 32);
        }

    public:
        ALWAYS_INLINE
        explicit inline Mtrr (uint64 b, uint64 m) : List<Mtrr> (list), base (b), mask (m) {}
  2016d5:	48 89 68 08          	mov    %rbp,0x8(%rax)
  2016d9:	48 89 58 10          	mov    %rbx,0x10(%rax)
  2016dd:	41 83 c4 02          	add    $0x2,%r12d
  2016e1:	eb 8b                	jmp    20166e <_ZN4Mtrr4initEv+0x30>
        new (Pd::kern.quota) Mtrr (Msr::read<uint64>(Msr::Register (Msr::IA32_MTRR_PHYS_BASE + 2 * i)),
                                   Msr::read<uint64>(Msr::Register (Msr::IA32_MTRR_PHYS_MASK + 2 * i)));
}
  2016e3:	58                   	pop    %rax
  2016e4:	5b                   	pop    %rbx
  2016e5:	5d                   	pop    %rbp
  2016e6:	41 5c                	pop    %r12
  2016e8:	41 5d                	pop    %r13
  2016ea:	c3                   	retq   
  2016eb:	90                   	nop

00000000002016ec <_ZN4Mtrr7memtypeEyRy>:

unsigned Mtrr::memtype (uint64 phys, uint64 &next)
{
    if (phys < 0x80000) {
  2016ec:	48 81 ff ff ff 07 00 	cmp    $0x7ffff,%rdi
  2016f3:	77 23                	ja     201718 <_ZN4Mtrr7memtypeEyRy+0x2c>
        next = 1 + (phys | 0xffff);
  2016f5:	48 89 f8             	mov    %rdi,%rax
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
  2016f8:	b9 50 02 00 00       	mov    $0x250,%ecx
  2016fd:	48 0d ff ff 00 00    	or     $0xffff,%rax
  201703:	48 ff c0             	inc    %rax
  201706:	48 89 06             	mov    %rax,(%rsi)
  201709:	0f 32                	rdmsr  
            return static_cast<T>(static_cast<uint64>(h) << 32 | l);
  20170b:	48 c1 e2 20          	shl    $0x20,%rdx
        return static_cast<unsigned>(Msr::read<uint64>(Msr::IA32_MTRR_FIX64K_BASE) >>
                                    (phys >> 13 & 0x38)) & 0xff;
  20170f:	48 c1 ef 0d          	shr    $0xd,%rdi
  201713:	48 09 d0             	or     %rdx,%rax
  201716:	eb 35                	jmp    20174d <_ZN4Mtrr7memtypeEyRy+0x61>
    }

    if (phys < 0xc0000) {
  201718:	48 81 ff ff ff 0b 00 	cmp    $0xbffff,%rdi
  20171f:	77 38                	ja     201759 <_ZN4Mtrr7memtypeEyRy+0x6d>
        next = 1 + (phys | 0x3fff);
  201721:	48 89 f8             	mov    %rdi,%rax
        return static_cast<unsigned>(Msr::read<uint64>(Msr::Register (Msr::IA32_MTRR_FIX16K_BASE + (phys >> 17 & 0x1))) >>
  201724:	48 89 f9             	mov    %rdi,%rcx
        return static_cast<unsigned>(Msr::read<uint64>(Msr::IA32_MTRR_FIX64K_BASE) >>
                                    (phys >> 13 & 0x38)) & 0xff;
    }

    if (phys < 0xc0000) {
        next = 1 + (phys | 0x3fff);
  201727:	48 0d ff 3f 00 00    	or     $0x3fff,%rax
        return static_cast<unsigned>(Msr::read<uint64>(Msr::Register (Msr::IA32_MTRR_FIX16K_BASE + (phys >> 17 & 0x1))) >>
  20172d:	48 c1 e9 11          	shr    $0x11,%rcx
        return static_cast<unsigned>(Msr::read<uint64>(Msr::IA32_MTRR_FIX64K_BASE) >>
                                    (phys >> 13 & 0x38)) & 0xff;
    }

    if (phys < 0xc0000) {
        next = 1 + (phys | 0x3fff);
  201731:	48 ff c0             	inc    %rax
        return static_cast<unsigned>(Msr::read<uint64>(Msr::Register (Msr::IA32_MTRR_FIX16K_BASE + (phys >> 17 & 0x1))) >>
  201734:	83 e1 01             	and    $0x1,%ecx
        return static_cast<unsigned>(Msr::read<uint64>(Msr::IA32_MTRR_FIX64K_BASE) >>
                                    (phys >> 13 & 0x38)) & 0xff;
    }

    if (phys < 0xc0000) {
        next = 1 + (phys | 0x3fff);
  201737:	48 89 06             	mov    %rax,(%rsi)
        return static_cast<unsigned>(Msr::read<uint64>(Msr::Register (Msr::IA32_MTRR_FIX16K_BASE + (phys >> 17 & 0x1))) >>
  20173a:	81 c1 58 02 00 00    	add    $0x258,%ecx
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
  201740:	0f 32                	rdmsr  
            return static_cast<T>(static_cast<uint64>(h) << 32 | l);
  201742:	48 c1 e2 20          	shl    $0x20,%rdx
                                    (phys >> 11 & 0x38)) & 0xff;
  201746:	48 c1 ef 0b          	shr    $0xb,%rdi
  20174a:	48 09 d0             	or     %rdx,%rax
                                    (phys >> 13 & 0x38)) & 0xff;
    }

    if (phys < 0xc0000) {
        next = 1 + (phys | 0x3fff);
        return static_cast<unsigned>(Msr::read<uint64>(Msr::Register (Msr::IA32_MTRR_FIX16K_BASE + (phys >> 17 & 0x1))) >>
  20174d:	89 f9                	mov    %edi,%ecx
  20174f:	83 e1 38             	and    $0x38,%ecx
  201752:	48 d3 e8             	shr    %cl,%rax
                                    (phys >> 11 & 0x38)) & 0xff;
  201755:	0f b6 c0             	movzbl %al,%eax
  201758:	c3                   	retq   
    }

    if (phys < 0x100000) {
  201759:	48 81 ff ff ff 0f 00 	cmp    $0xfffff,%rdi
  201760:	77 2e                	ja     201790 <_ZN4Mtrr7memtypeEyRy+0xa4>
        next = 1 + (phys | 0xfff);
  201762:	48 89 f8             	mov    %rdi,%rax
        return static_cast<unsigned>(Msr::read<uint64>(Msr::Register (Msr::IA32_MTRR_FIX4K_BASE  + (phys >> 15 & 0x7))) >>
  201765:	48 89 f9             	mov    %rdi,%rcx
        return static_cast<unsigned>(Msr::read<uint64>(Msr::Register (Msr::IA32_MTRR_FIX16K_BASE + (phys >> 17 & 0x1))) >>
                                    (phys >> 11 & 0x38)) & 0xff;
    }

    if (phys < 0x100000) {
        next = 1 + (phys | 0xfff);
  201768:	48 0d ff 0f 00 00    	or     $0xfff,%rax
        return static_cast<unsigned>(Msr::read<uint64>(Msr::Register (Msr::IA32_MTRR_FIX4K_BASE  + (phys >> 15 & 0x7))) >>
  20176e:	48 c1 e9 0f          	shr    $0xf,%rcx
        return static_cast<unsigned>(Msr::read<uint64>(Msr::Register (Msr::IA32_MTRR_FIX16K_BASE + (phys >> 17 & 0x1))) >>
                                    (phys >> 11 & 0x38)) & 0xff;
    }

    if (phys < 0x100000) {
        next = 1 + (phys | 0xfff);
  201772:	48 ff c0             	inc    %rax
        return static_cast<unsigned>(Msr::read<uint64>(Msr::Register (Msr::IA32_MTRR_FIX4K_BASE  + (phys >> 15 & 0x7))) >>
  201775:	83 e1 07             	and    $0x7,%ecx
        return static_cast<unsigned>(Msr::read<uint64>(Msr::Register (Msr::IA32_MTRR_FIX16K_BASE + (phys >> 17 & 0x1))) >>
                                    (phys >> 11 & 0x38)) & 0xff;
    }

    if (phys < 0x100000) {
        next = 1 + (phys | 0xfff);
  201778:	48 89 06             	mov    %rax,(%rsi)
        return static_cast<unsigned>(Msr::read<uint64>(Msr::Register (Msr::IA32_MTRR_FIX4K_BASE  + (phys >> 15 & 0x7))) >>
  20177b:	81 c1 68 02 00 00    	add    $0x268,%ecx
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
  201781:	0f 32                	rdmsr  
            return static_cast<T>(static_cast<uint64>(h) << 32 | l);
  201783:	48 c1 e2 20          	shl    $0x20,%rdx
                                    (phys >>  9 & 0x38)) & 0xff;
  201787:	48 c1 ef 09          	shr    $0x9,%rdi
  20178b:	48 09 d0             	or     %rdx,%rax
  20178e:	eb bd                	jmp    20174d <_ZN4Mtrr7memtypeEyRy+0x61>
    }

    unsigned type = ~0U; next = ~0ULL;
  201790:	48 c7 06 ff ff ff ff 	movq   $0xffffffffffffffff,(%rsi)

    for (Mtrr *mtrr = list; mtrr; mtrr = mtrr->next) {
  201797:	4c 8b 05 42 21 f6 80 	mov    -0x7f09debe(%rip),%r8        # ffffffff811638e0 <_ZN4Mtrr4listE>
        next = 1 + (phys | 0xfff);
        return static_cast<unsigned>(Msr::read<uint64>(Msr::Register (Msr::IA32_MTRR_FIX4K_BASE  + (phys >> 15 & 0x7))) >>
                                    (phys >>  9 & 0x38)) & 0xff;
    }

    unsigned type = ~0U; next = ~0ULL;
  20179e:	83 c8 ff             	or     $0xffffffff,%eax
        static Mtrr *       list;
        static Slab_cache   cache;

        uint64 size() const
        {
            return 1ULL << (static_cast<mword>(mask) ? bit_scan_forward (static_cast<mword>(mask >> 12)) + 12 :
  2017a1:	41 ba 01 00 00 00    	mov    $0x1,%r10d

    for (Mtrr *mtrr = list; mtrr; mtrr = mtrr->next) {
  2017a7:	4d 85 c0             	test   %r8,%r8
  2017aa:	74 6e                	je     20181a <_ZN4Mtrr7memtypeEyRy+0x12e>

        if (!(mtrr->mask & 0x800))
  2017ac:	4d 8b 48 10          	mov    0x10(%r8),%r9
  2017b0:	41 f7 c1 00 08 00 00 	test   $0x800,%r9d
  2017b7:	74 5c                	je     201815 <_ZN4Mtrr7memtypeEyRy+0x129>
            continue;

        uint64 base = mtrr->base & ~PAGE_MASK;
  2017b9:	49 8b 48 08          	mov    0x8(%r8),%rcx
  2017bd:	48 89 ca             	mov    %rcx,%rdx
  2017c0:	48 81 e2 00 f0 ff ff 	and    $0xfffffffffffff000,%rdx

        if (phys < base)
  2017c7:	48 39 d7             	cmp    %rdx,%rdi
  2017ca:	73 0c                	jae    2017d8 <_ZN4Mtrr7memtypeEyRy+0xec>
  2017cc:	48 39 16             	cmp    %rdx,(%rsi)
  2017cf:	48 0f 46 16          	cmovbe (%rsi),%rdx
            next = min (next, base);
  2017d3:	48 89 16             	mov    %rdx,(%rsi)
  2017d6:	eb 3d                	jmp    201815 <_ZN4Mtrr7memtypeEyRy+0x129>

        else if (((phys ^ mtrr->base) & mtrr->mask) >> PAGE_BITS == 0) {
  2017d8:	48 31 f9             	xor    %rdi,%rcx
  2017db:	4c 21 c9             	and    %r9,%rcx
  2017de:	48 c1 e9 0c          	shr    $0xc,%rcx
  2017e2:	75 31                	jne    201815 <_ZN4Mtrr7memtypeEyRy+0x129>

ALWAYS_INLINE
inline long int bit_scan_forward (mword val)
{
    if (EXPECT_FALSE (!val))
        return -1;
  2017e4:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
}

ALWAYS_INLINE
inline long int bit_scan_forward (mword val)
{
    if (EXPECT_FALSE (!val))
  2017e8:	49 c1 e9 0c          	shr    $0xc,%r9
  2017ec:	74 04                	je     2017f2 <_ZN4Mtrr7memtypeEyRy+0x106>
        return -1;

    asm volatile ("bsf %1, %0" : "=r" (val) : "rm" (val));

    return val;
  2017ee:	49 0f bc c9          	bsf    %r9,%rcx
  2017f2:	83 c1 0c             	add    $0xc,%ecx
  2017f5:	4d 89 d3             	mov    %r10,%r11
  2017f8:	49 d3 e3             	shl    %cl,%r11
  2017fb:	48 8b 0e             	mov    (%rsi),%rcx
            next = min (next, base + mtrr->size());
  2017fe:	4c 01 da             	add    %r11,%rdx
  201801:	48 39 ca             	cmp    %rcx,%rdx
  201804:	48 0f 47 d1          	cmova  %rcx,%rdx
  201808:	48 89 16             	mov    %rdx,(%rsi)
            type = min (type, static_cast<unsigned>(mtrr->base) & 0xff);
  20180b:	41 0f b6 50 08       	movzbl 0x8(%r8),%edx
  201810:	39 d0                	cmp    %edx,%eax
  201812:	0f 47 c2             	cmova  %edx,%eax
                                    (phys >>  9 & 0x38)) & 0xff;
    }

    unsigned type = ~0U; next = ~0ULL;

    for (Mtrr *mtrr = list; mtrr; mtrr = mtrr->next) {
  201815:	4d 8b 00             	mov    (%r8),%r8
  201818:	eb 8d                	jmp    2017a7 <_ZN4Mtrr7memtypeEyRy+0xbb>
            next = min (next, base + mtrr->size());
            type = min (type, static_cast<unsigned>(mtrr->base) & 0xff);
        }
    }

    return type == ~0U ? dtype : type;
  20181a:	83 f8 ff             	cmp    $0xffffffff,%eax
  20181d:	0f 44 05 c4 20 f6 80 	cmove  -0x7f09df3c(%rip),%eax        # ffffffff811638e8 <_ZN4Mtrr5dtypeE>
}
  201824:	c3                   	retq   
  201825:	90                   	nop

0000000000201826 <_ZN3PciC1Ejj>:
    protected:
        T *next;

    public:
        ALWAYS_INLINE
        explicit inline List (T *&list) : next (nullptr)
  201826:	48 c7 07 00 00 00 00 	movq   $0x0,(%rdi)
        {
            T **ptr; for (ptr = &list; *ptr; ptr = &(*ptr)->next) ; *ptr = static_cast<T *>(this);
  20182d:	48 8b 05 bc 20 f6 80 	mov    -0x7f09df44(%rip),%rax        # ffffffff811638f0 <_ZN3Pci4listE>
  201834:	48 c7 c1 f0 38 16 81 	mov    $0xffffffff811638f0,%rcx
  20183b:	48 85 c0             	test   %rax,%rax
  20183e:	74 08                	je     201848 <_ZN3PciC1Ejj+0x22>
  201840:	48 89 c1             	mov    %rax,%rcx
  201843:	48 8b 00             	mov    (%rax),%rax
  201846:	eb f3                	jmp    20183b <_ZN3PciC1Ejj+0x15>

struct Pci::quirk_map Pci::map[] INITDATA =
{
};

Pci::Pci (unsigned r, unsigned l) : List<Pci> (list), reg_base (hwdev_addr -= PAGE_SIZE), rid (static_cast<uint16>(r)), lev (static_cast<uint16>(l))
  201848:	50                   	push   %rax
  201849:	48 89 39             	mov    %rdi,(%rcx)
  20184c:	41 b9 13 01 00 00    	mov    $0x113,%r9d
  201852:	66 89 77 10          	mov    %si,0x10(%rdi)
  201856:	48 8b 05 73 03 e2 80 	mov    -0x7f1dfc8d(%rip),%rax        # ffffffff81021bd0 <hwdev_addr>
{
    Pd::kern.Space_mem::insert (Pd::kern.quota, reg_base, 0, Hpt::HPT_NX | Hpt::HPT_G | Hpt::HPT_UC | Hpt::HPT_W | Hpt::HPT_P, cfg_base + (rid << PAGE_BITS));
  20185d:	48 c1 e6 0c          	shl    $0xc,%rsi
  201861:	81 e6 00 f0 ff 0f    	and    $0xffff000,%esi

struct Pci::quirk_map Pci::map[] INITDATA =
{
};

Pci::Pci (unsigned r, unsigned l) : List<Pci> (list), reg_base (hwdev_addr -= PAGE_SIZE), rid (static_cast<uint16>(r)), lev (static_cast<uint16>(l))
  201867:	66 89 57 12          	mov    %dx,0x12(%rdi)
  20186b:	31 c9                	xor    %ecx,%ecx
{
    Pd::kern.Space_mem::insert (Pd::kern.quota, reg_base, 0, Hpt::HPT_NX | Hpt::HPT_G | Hpt::HPT_UC | Hpt::HPT_W | Hpt::HPT_P, cfg_base + (rid << PAGE_BITS));
  20186d:	49 89 f0             	mov    %rsi,%r8
  201870:	4c 03 05 89 20 f6 80 	add    -0x7f09df77(%rip),%r8        # ffffffff81163900 <_ZN3Pci8cfg_baseE>
  201877:	48 c7 c6 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rsi

struct Pci::quirk_map Pci::map[] INITDATA =
{
};

Pci::Pci (unsigned r, unsigned l) : List<Pci> (list), reg_base (hwdev_addr -= PAGE_SIZE), rid (static_cast<uint16>(r)), lev (static_cast<uint16>(l))
  20187e:	48 2d 00 10 00 00    	sub    $0x1000,%rax
  201884:	48 89 47 08          	mov    %rax,0x8(%rdi)
  201888:	6a 00                	pushq  $0x0
  20188a:	48 89 c2             	mov    %rax,%rdx
  20188d:	6a 00                	pushq  $0x0
  20188f:	48 c7 c7 40 3f 16 81 	mov    $0xffffffff81163f40,%rdi
  201896:	48 89 05 33 03 e2 80 	mov    %rax,-0x7f1dfccd(%rip)        # ffffffff81021bd0 <hwdev_addr>
  20189d:	e8 74 14 e1 80       	callq  ffffffff81012d16 <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb>
    Pd::kern.Space_mem::insert (Pd::kern.quota, reg_base, 0, Hpt::HPT_NX | Hpt::HPT_G | Hpt::HPT_UC | Hpt::HPT_W | Hpt::HPT_P, cfg_base + (rid << PAGE_BITS));

    for (unsigned i = 0; i < sizeof map / sizeof *map; i++)
        if (read<uint16>(REG_VID) == map[i].vid && read<uint16>(REG_DID) == map[i].did)
            (this->*map[i].func)();
}
  2018a2:	48 83 c4 18          	add    $0x18,%rsp
  2018a6:	c3                   	retq   
  2018a7:	90                   	nop

00000000002018a8 <_ZN3Pci4initEjj>:

void Pci::init (unsigned b, unsigned l)
{
  2018a8:	41 56                	push   %r14
  2018aa:	41 55                	push   %r13
        Pci *p = new (Pd::kern.quota) Pci (r, l);

        unsigned h = p->read<uint8>(REG_HDR);

        if ((h & 0x7f) == 1)
            init (p->read<uint8>(REG_SBUSN), l + 1);
  2018ac:	44 8d 6e 01          	lea    0x1(%rsi),%r13d
        if (read<uint16>(REG_VID) == map[i].vid && read<uint16>(REG_DID) == map[i].did)
            (this->*map[i].func)();
}

void Pci::init (unsigned b, unsigned l)
{
  2018b0:	41 54                	push   %r12
  2018b2:	55                   	push   %rbp
    for (unsigned r = b << 8; r < (b + 1) << 8; r++) {
  2018b3:	8d 6f 01             	lea    0x1(%rdi),%ebp
        if (read<uint16>(REG_VID) == map[i].vid && read<uint16>(REG_DID) == map[i].did)
            (this->*map[i].func)();
}

void Pci::init (unsigned b, unsigned l)
{
  2018b6:	53                   	push   %rbx
    for (unsigned r = b << 8; r < (b + 1) << 8; r++) {
  2018b7:	89 fb                	mov    %edi,%ebx
        if (read<uint16>(REG_VID) == map[i].vid && read<uint16>(REG_DID) == map[i].did)
            (this->*map[i].func)();
}

void Pci::init (unsigned b, unsigned l)
{
  2018b9:	41 89 f4             	mov    %esi,%r12d
    for (unsigned r = b << 8; r < (b + 1) << 8; r++) {
  2018bc:	c1 e3 08             	shl    $0x8,%ebx
  2018bf:	c1 e5 08             	shl    $0x8,%ebp
  2018c2:	39 eb                	cmp    %ebp,%ebx
  2018c4:	73 73                	jae    201939 <_ZN3Pci4initEjj+0x91>

        if (*static_cast<uint32 *>(Hpt::remap (Pd::kern.quota, cfg_base + (r << PAGE_BITS))) == ~0U)
  2018c6:	89 d8                	mov    %ebx,%eax
  2018c8:	48 c7 c7 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rdi
  2018cf:	c1 e0 0c             	shl    $0xc,%eax
  2018d2:	48 03 05 27 20 f6 80 	add    -0x7f09dfd9(%rip),%rax        # ffffffff81163900 <_ZN3Pci8cfg_baseE>
  2018d9:	48 89 c6             	mov    %rax,%rsi
  2018dc:	e8 31 68 e0 80       	callq  ffffffff81008112 <_ZN3Hpt5remapER5Quotam>
  2018e1:	83 38 ff             	cmpl   $0xffffffff,(%rax)
  2018e4:	74 4f                	je     201935 <_ZN3Pci4initEjj+0x8d>
    public:
        INIT
        Pci (unsigned, unsigned);

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
  2018e6:	48 c7 c6 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rsi
  2018ed:	48 c7 c7 10 39 16 81 	mov    $0xffffffff81163910,%rdi
  2018f4:	e8 35 40 e1 80       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
            continue;

        Pci *p = new (Pd::kern.quota) Pci (r, l);
  2018f9:	44 89 e2             	mov    %r12d,%edx
  2018fc:	49 89 c6             	mov    %rax,%r14
  2018ff:	48 89 c7             	mov    %rax,%rdi
  201902:	89 de                	mov    %ebx,%esi
  201904:	e8 1d ff ff ff       	callq  201826 <_ZN3PciC1Ejj>
  201909:	49 8b 46 08          	mov    0x8(%r14),%rax
            REG_MAX         = 0xfff,
        };

        template <typename T>
        ALWAYS_INLINE
        inline unsigned read (Register r) { return *reinterpret_cast<T volatile *>(reg_base + r); }
  20190d:	44 8a 70 0e          	mov    0xe(%rax),%r14b

        unsigned h = p->read<uint8>(REG_HDR);

        if ((h & 0x7f) == 1)
  201911:	44 88 f2             	mov    %r14b,%dl
  201914:	83 e2 7f             	and    $0x7f,%edx
  201917:	fe ca                	dec    %dl
  201919:	75 0c                	jne    201927 <_ZN3Pci4initEjj+0x7f>
  20191b:	0f b6 78 19          	movzbl 0x19(%rax),%edi
            init (p->read<uint8>(REG_SBUSN), l + 1);
  20191f:	44 89 ee             	mov    %r13d,%esi
  201922:	e8 81 ff ff ff       	callq  2018a8 <_ZN3Pci4initEjj>

        if (!(r & 0x7) && !(h & 0x80))
  201927:	f6 c3 07             	test   $0x7,%bl
  20192a:	75 09                	jne    201935 <_ZN3Pci4initEjj+0x8d>
            r += 7;
  20192c:	8d 43 07             	lea    0x7(%rbx),%eax
  20192f:	45 84 f6             	test   %r14b,%r14b
  201932:	0f 49 d8             	cmovns %eax,%ebx
            (this->*map[i].func)();
}

void Pci::init (unsigned b, unsigned l)
{
    for (unsigned r = b << 8; r < (b + 1) << 8; r++) {
  201935:	ff c3                	inc    %ebx
  201937:	eb 89                	jmp    2018c2 <_ZN3Pci4initEjj+0x1a>
            init (p->read<uint8>(REG_SBUSN), l + 1);

        if (!(r & 0x7) && !(h & 0x80))
            r += 7;
    }
}
  201939:	5b                   	pop    %rbx
  20193a:	5d                   	pop    %rbp
  20193b:	41 5c                	pop    %r12
  20193d:	41 5d                	pop    %r13
  20193f:	41 5e                	pop    %r14
  201941:	c3                   	retq   

0000000000201942 <_ZN2PdC1EPS_>:

INIT_PRIORITY (PRIO_BUDDY)
ALIGNED(32) Pd Pd::kern (&Pd::kern);
ALIGNED(32) Pd Pd::root (&Pd::root, NUM_EXC, 0x1f);

Pd::Pd (Pd *own) : Kobject (PD, static_cast<Space_obj *>(own))
  201942:	48 8d 86 f8 02 00 00 	lea    0x2f8(%rsi),%rax
  201949:	41 54                	push   %r12
  20194b:	48 85 f6             	test   %rsi,%rsi
  20194e:	55                   	push   %rbp
  20194f:	48 89 f5             	mov    %rsi,%rbp
  201952:	be 00 00 00 00       	mov    $0x0,%esi
  201957:	53                   	push   %rbx
  201958:	48 0f 45 f0          	cmovne %rax,%rsi
            PT,
            SM,
            INVALID,
        };

        explicit Kobject (Type t, Space *s, mword b = 0, mword a = 0, void (*f)(Rcu_elem *) = free, void (*pref)(Rcu_elem *) = nullptr ) : Mdb (s, reinterpret_cast<mword>(this), b, a, f, pref), objtype (t) {}
  20195c:	50                   	push   %rax
  20195d:	6a 00                	pushq  $0x0
  20195f:	31 c9                	xor    %ecx,%ecx
  201961:	48 89 fa             	mov    %rdi,%rdx
  201964:	49 c7 c1 ae 34 00 81 	mov    $0xffffffff810034ae,%r9
  20196b:	45 31 c0             	xor    %r8d,%r8d
  20196e:	48 89 fb             	mov    %rdi,%rbx
  201971:	e8 36 1f e0 80       	callq  ffffffff810038ac <_ZN3MdbC1EP5SpacemmmPFvP8Rcu_elemES5_>
            bool res = !Atomic::test_set_bit (did_c[0], NO_PCID);
            assert (res);
        }

        ALWAYS_INLINE
        inline Space_mem() : cpus(0), htlb(~0UL), gtlb(~0UL)
  201976:	59                   	pop    %rcx
  201977:	5e                   	pop    %rsi
  201978:	48 8d 93 a0 00 00 00 	lea    0xa0(%rbx),%rdx
  20197f:	c6 83 88 00 00 00 00 	movb   $0x0,0x88(%rbx)
  201986:	66 c7 83 8a 00 00 00 	movw   $0x0,0x8a(%rbx)
  20198d:	00 00 
    private:
        uint32 ref;

    public:
        ALWAYS_INLINE
        inline Refex() : ref (1) {}
  20198f:	c7 83 8c 00 00 00 01 	movl   $0x1,0x8c(%rbx)
  201996:	00 00 00 
  201999:	66 c7 83 90 00 00 00 	movw   $0x0,0x90(%rbx)
  2019a0:	00 00 
  2019a2:	31 c0                	xor    %eax,%eax
    private:
        Spinlock    lock;
        Avl *       tree;

    public:
        Space() : tree (nullptr) {}
  2019a4:	48 c7 83 98 00 00 00 	movq   $0x0,0x98(%rbx)
  2019ab:	00 00 00 00 
  2019af:	48 c7 04 02 00 00 00 	movq   $0x0,(%rdx,%rax,1)
  2019b6:	00 
  2019b7:	48 83 c0 08          	add    $0x8,%rax
  2019bb:	48 3d 00 02 00 00    	cmp    $0x200,%rax
  2019c1:	75 ec                	jne    2019af <_ZN2PdC1EPS_+0x6d>
        {
            for (mword i = ACCESS_ONCE(did_f), j = 0; j <= LAST_PCID; i++, j++)
  2019c3:	48 8b 05 e6 26 f6 80 	mov    -0x7f09d91a(%rip),%rax        # ffffffff811640b0 <_ZN9Space_mem5did_fE>
  2019ca:	48 c7 83 a0 02 00 00 	movq   $0x0,0x2a0(%rbx)
  2019d1:	00 00 00 00 
  2019d5:	31 f6                	xor    %esi,%esi
  2019d7:	48 c7 83 a8 02 00 00 	movq   $0x0,0x2a8(%rbx)
  2019de:	00 00 00 00 
    private:
        mword val;

    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}
  2019e2:	48 c7 83 c0 02 00 00 	movq   $0x0,0x2c0(%rbx)
  2019e9:	00 00 00 00 
  2019ed:	48 c7 83 c8 02 00 00 	movq   $0xffffffffffffffff,0x2c8(%rbx)
  2019f4:	ff ff ff ff 
  2019f8:	48 c7 83 d0 02 00 00 	movq   $0xffffffffffffffff,0x2d0(%rbx)
  2019ff:	ff ff ff ff 
            {
                i %= (LAST_PCID + 1);
  201a03:	83 e0 3f             	and    $0x3f,%eax

                if (ACCESS_ONCE(did_c[i]) == ~0UL)
  201a06:	48 8b 14 c5 c0 40 16 	mov    -0x7ee9bf40(,%rax,8),%rdx
  201a0d:	81 
  201a0e:	48 ff c2             	inc    %rdx
  201a11:	74 63                	je     201a76 <_ZN2PdC1EPS_+0x134>
}

ALWAYS_INLINE
inline long int bit_scan_forward (mword val)
{
    if (EXPECT_FALSE (!val))
  201a13:	48 8b 0c c5 c0 40 16 	mov    -0x7ee9bf40(,%rax,8),%rcx
  201a1a:	81 
                    continue;

                long b = bit_scan_forward (~did_c[i]);
                if (b == -1) b = 0;
  201a1b:	31 d2                	xor    %edx,%edx
  201a1d:	48 83 f1 ff          	xor    $0xffffffffffffffff,%rcx
  201a21:	74 0c                	je     201a2f <_ZN2PdC1EPS_+0xed>
        return -1;

    asm volatile ("bsf %1, %0" : "=r" (val) : "rm" (val));
  201a23:	48 0f bc c9          	bsf    %rcx,%rcx
  201a27:	48 83 f9 ff          	cmp    $0xffffffffffffffff,%rcx
  201a2b:	48 0f 45 d1          	cmovne %rcx,%rdx
        template <typename T>
        ALWAYS_INLINE
        static inline bool test_set_bit (T &val, unsigned long bit)
        {
            bool ret;
            asm volatile ("lock; bts%z1 %2, %1; setc %0" : "=q" (ret), "+m" (val) : "ir" (bit) : "cc");
  201a2f:	f0 48 0f ab 14 c5 c0 	lock bts %rdx,-0x7ee9bf40(,%rax,8)
  201a36:	40 16 81 
  201a39:	0f 92 c1             	setb   %cl

                if (Atomic::test_set_bit (did_c[i], b)) {
  201a3c:	84 c9                	test   %cl,%cl
  201a3e:	74 08                	je     201a48 <_ZN2PdC1EPS_+0x106>
                    j--;
  201a40:	48 ff ce             	dec    %rsi
                    i--;
  201a43:	48 ff c8             	dec    %rax
  201a46:	eb 2e                	jmp    201a76 <_ZN2PdC1EPS_+0x134>
                    continue;
                }

                did = i * sizeof(did_c[0]) * 8 + b;
  201a48:	48 89 c1             	mov    %rax,%rcx
  201a4b:	48 c1 e1 06          	shl    $0x6,%rcx
  201a4f:	48 01 ca             	add    %rcx,%rdx

                if (did_c[i] != ~0UL && did_f != i)
  201a52:	48 83 3c c5 c0 40 16 	cmpq   $0xffffffffffffffff,-0x7ee9bf40(,%rax,8)
  201a59:	81 ff 
                    j--;
                    i--;
                    continue;
                }

                did = i * sizeof(did_c[0]) * 8 + b;
  201a5b:	48 89 93 b8 02 00 00 	mov    %rdx,0x2b8(%rbx)

                if (did_c[i] != ~0UL && did_f != i)
  201a62:	74 29                	je     201a8d <_ZN2PdC1EPS_+0x14b>
  201a64:	48 39 05 45 26 f6 80 	cmp    %rax,-0x7f09d9bb(%rip)        # ffffffff811640b0 <_ZN9Space_mem5did_fE>
  201a6b:	74 20                	je     201a8d <_ZN2PdC1EPS_+0x14b>
                    did_f = i;
  201a6d:	48 89 05 3c 26 f6 80 	mov    %rax,-0x7f09d9c4(%rip)        # ffffffff811640b0 <_ZN9Space_mem5did_fE>
  201a74:	eb 17                	jmp    201a8d <_ZN2PdC1EPS_+0x14b>
        }

        ALWAYS_INLINE
        inline Space_mem() : cpus(0), htlb(~0UL), gtlb(~0UL)
        {
            for (mword i = ACCESS_ONCE(did_f), j = 0; j <= LAST_PCID; i++, j++)
  201a76:	48 ff c6             	inc    %rsi
  201a79:	48 ff c0             	inc    %rax
  201a7c:	48 83 fe 3f          	cmp    $0x3f,%rsi
  201a80:	76 81                	jbe    201a03 <_ZN2PdC1EPS_+0xc1>
                    did_f = i;

                return;
            }

            did = NO_PCID;
  201a82:	48 c7 83 b8 02 00 00 	movq   $0x2,0x2b8(%rbx)
  201a89:	02 00 00 00 
  201a8d:	48 8d bb 08 03 00 00 	lea    0x308(%rbx),%rdi
{
    hpt = Hptp (reinterpret_cast<mword>(&PDBR));

    Mtrr::init();

    Space_mem::insert_root (own->quota, 0, reinterpret_cast<mword>(&LINK_P));
  201a94:	4c 8d a3 90 00 00 00 	lea    0x90(%rbx),%r12
  201a9b:	66 c7 83 d8 02 00 00 	movw   $0x0,0x2d8(%rbx)
  201aa2:	00 00 
  201aa4:	48 c7 83 e0 02 00 00 	movq   $0x0,0x2e0(%rbx)
  201aab:	00 00 00 00 

        void update (Quota &quota, bool, mword, mword);

    public:

        Space_pio() : hbmp(0), gbmp(0) {}
  201aaf:	48 c7 83 e8 02 00 00 	movq   $0x0,0x2e8(%rbx)
  201ab6:	00 00 00 00 
  201aba:	48 81 c5 08 03 00 00 	add    $0x308,%rbp
  201ac1:	48 c7 83 f0 02 00 00 	movq   $0x0,0x2f0(%rbx)
  201ac8:	00 00 00 00 
  201acc:	66 c7 83 f8 02 00 00 	movw   $0x0,0x2f8(%rbx)
  201ad3:	00 00 
  201ad5:	48 c7 83 00 03 00 00 	movq   $0x0,0x300(%rbx)
  201adc:	00 00 00 00 

INIT_PRIORITY (PRIO_BUDDY)
ALIGNED(32) Pd Pd::kern (&Pd::kern);
ALIGNED(32) Pd Pd::root (&Pd::root, NUM_EXC, 0x1f);

Pd::Pd (Pd *own) : Kobject (PD, static_cast<Space_obj *>(own))
  201ae0:	e8 0d e3 e0 80       	callq  ffffffff8100fdf2 <_ZN5QuotaC1Ev>
{
    hpt = Hptp (reinterpret_cast<mword>(&PDBR));
  201ae5:	48 c7 83 a0 02 00 00 	movq   $0x568000,0x2a0(%rbx)
  201aec:	00 80 56 00 

    Mtrr::init();
  201af0:	e8 49 fb ff ff       	callq  20163e <_ZN4Mtrr4initEv>

    Space_mem::insert_root (own->quota, 0, reinterpret_cast<mword>(&LINK_P));
  201af5:	48 89 ee             	mov    %rbp,%rsi
  201af8:	4c 89 e7             	mov    %r12,%rdi
  201afb:	41 b8 07 00 00 00    	mov    $0x7,%r8d
  201b01:	48 c7 c1 00 00 40 00 	mov    $0x400000,%rcx
  201b08:	31 d2                	xor    %edx,%edx
  201b0a:	e8 65 00 00 00       	callq  201b74 <_ZN9Space_mem11insert_rootER5Quotayym>
    Space_mem::insert_root (own->quota, reinterpret_cast<mword>(&LINK_E), 1ULL << 52);
  201b0f:	48 89 ee             	mov    %rbp,%rsi
  201b12:	4c 89 e7             	mov    %r12,%rdi
  201b15:	41 b8 07 00 00 00    	mov    $0x7,%r8d
  201b1b:	48 b9 00 00 00 00 00 	movabs $0x10000000000000,%rcx
  201b22:	00 10 00 
  201b25:	48 c7 c2 00 00 80 08 	mov    $0x8800000,%rdx
  201b2c:	e8 43 00 00 00       	callq  201b74 <_ZN9Space_mem11insert_rootER5Quotayym>

    // HIP
    Space_mem::insert_root (own->quota, reinterpret_cast<mword>(&FRAME_H), reinterpret_cast<mword>(&FRAME_H) + PAGE_SIZE, 1);
  201b31:	48 89 ee             	mov    %rbp,%rsi
  201b34:	4c 89 e7             	mov    %r12,%rdi
  201b37:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  201b3d:	48 c7 c1 00 80 56 00 	mov    $0x568000,%rcx
  201b44:	48 c7 c2 00 70 56 00 	mov    $0x567000,%rdx
  201b4b:	e8 24 00 00 00       	callq  201b74 <_ZN9Space_mem11insert_rootER5Quotayym>

    // I/O Ports
    Space_pio::addreg (own->quota, 0, 1UL << 16, 7);
  201b50:	48 8d bb d8 02 00 00 	lea    0x2d8(%rbx),%rdi
  201b57:	48 89 ee             	mov    %rbp,%rsi
  201b5a:	45 31 c9             	xor    %r9d,%r9d
}
  201b5d:	5b                   	pop    %rbx
  201b5e:	5d                   	pop    %rbp
  201b5f:	41 5c                	pop    %r12

    // HIP
    Space_mem::insert_root (own->quota, reinterpret_cast<mword>(&FRAME_H), reinterpret_cast<mword>(&FRAME_H) + PAGE_SIZE, 1);

    // I/O Ports
    Space_pio::addreg (own->quota, 0, 1UL << 16, 7);
  201b61:	41 b8 07 00 00 00    	mov    $0x7,%r8d
  201b67:	b9 00 00 01 00       	mov    $0x10000,%ecx
  201b6c:	31 d2                	xor    %edx,%edx
  201b6e:	e9 e3 12 e0 80       	jmpq   ffffffff81002e56 <_ZN5Space6addregER5Quotammmm>
  201b73:	90                   	nop

0000000000201b74 <_ZN9Space_mem11insert_rootER5Quotayym>:
            asm volatile ("cli" : : : "memory");
    }
}

void Space_mem::insert_root (Quota &quota, uint64 s, uint64 e, mword a)
{
  201b74:	41 57                	push   %r15
  201b76:	41 56                	push   %r14
  201b78:	49 89 d6             	mov    %rdx,%r14
  201b7b:	41 55                	push   %r13
  201b7d:	41 54                	push   %r12
  201b7f:	4d 89 c5             	mov    %r8,%r13
  201b82:	55                   	push   %rbp
  201b83:	53                   	push   %rbx
  201b84:	48 89 fd             	mov    %rdi,%rbp
  201b87:	49 89 f4             	mov    %rsi,%r12
  201b8a:	48 89 cb             	mov    %rcx,%rbx
  201b8d:	48 83 ec 18          	sub    $0x18,%rsp
    for (uint64 p = s; p < e; s = p) {
  201b91:	48 89 14 24          	mov    %rdx,(%rsp)
  201b95:	48 39 1c 24          	cmp    %rbx,(%rsp)
  201b99:	73 68                	jae    201c03 <_ZN9Space_mem11insert_rootER5Quotayym+0x8f>

        unsigned t = Mtrr::memtype (s, p);
  201b9b:	48 89 e6             	mov    %rsp,%rsi
  201b9e:	4c 89 f7             	mov    %r14,%rdi
  201ba1:	e8 46 fb ff ff       	callq  2016ec <_ZN4Mtrr7memtypeEyRy>
  201ba6:	41 89 c7             	mov    %eax,%r15d

        for (uint64 n; p < e; p = n)
  201ba9:	48 8b 3c 24          	mov    (%rsp),%rdi
  201bad:	48 39 df             	cmp    %rbx,%rdi
  201bb0:	73 0f                	jae    201bc1 <_ZN9Space_mem11insert_rootER5Quotayym+0x4d>
            if (Mtrr::memtype (p, n) != t)
  201bb2:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
  201bb7:	e8 30 fb ff ff       	callq  2016ec <_ZN4Mtrr7memtypeEyRy>
  201bbc:	44 39 f8             	cmp    %r15d,%eax
  201bbf:	74 37                	je     201bf8 <_ZN9Space_mem11insert_rootER5Quotayym+0x84>
  201bc1:	4c 8b 14 24          	mov    (%rsp),%r10
            break;

        if ((p = min (p, e)) > ~0UL)
            p = static_cast<uint64>(~0UL) + 1;

        addreg (quota, static_cast<mword>(s >> PAGE_BITS), static_cast<mword>(p - s) >> PAGE_BITS, a, t);
  201bc5:	4c 89 f2             	mov    %r14,%rdx
  201bc8:	45 89 f9             	mov    %r15d,%r9d
  201bcb:	4d 89 e8             	mov    %r13,%r8
  201bce:	4c 89 e6             	mov    %r12,%rsi
  201bd1:	48 89 ef             	mov    %rbp,%rdi
  201bd4:	4c 39 d3             	cmp    %r10,%rbx
  201bd7:	4c 0f 46 d3          	cmovbe %rbx,%r10
  201bdb:	48 c1 ea 0c          	shr    $0xc,%rdx
  201bdf:	4c 89 d1             	mov    %r10,%rcx
                break;

        if (s > ~0UL)
            break;

        if ((p = min (p, e)) > ~0UL)
  201be2:	4c 89 14 24          	mov    %r10,(%rsp)
            p = static_cast<uint64>(~0UL) + 1;

        addreg (quota, static_cast<mword>(s >> PAGE_BITS), static_cast<mword>(p - s) >> PAGE_BITS, a, t);
  201be6:	4c 29 f1             	sub    %r14,%rcx
  201be9:	48 c1 e9 0c          	shr    $0xc,%rcx
  201bed:	e8 64 12 e0 80       	callq  ffffffff81002e56 <_ZN5Space6addregER5Quotammmm>
    }
}

void Space_mem::insert_root (Quota &quota, uint64 s, uint64 e, mword a)
{
    for (uint64 p = s; p < e; s = p) {
  201bf2:	4c 8b 34 24          	mov    (%rsp),%r14
  201bf6:	eb 9d                	jmp    201b95 <_ZN9Space_mem11insert_rootER5Quotayym+0x21>

        unsigned t = Mtrr::memtype (s, p);

        for (uint64 n; p < e; p = n)
  201bf8:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  201bfd:	48 89 04 24          	mov    %rax,(%rsp)
  201c01:	eb a6                	jmp    201ba9 <_ZN9Space_mem11insert_rootER5Quotayym+0x35>
        if ((p = min (p, e)) > ~0UL)
            p = static_cast<uint64>(~0UL) + 1;

        addreg (quota, static_cast<mword>(s >> PAGE_BITS), static_cast<mword>(p - s) >> PAGE_BITS, a, t);
    }
}
  201c03:	48 83 c4 18          	add    $0x18,%rsp
  201c07:	5b                   	pop    %rbx
  201c08:	5d                   	pop    %rbp
  201c09:	41 5c                	pop    %r12
  201c0b:	41 5d                	pop    %r13
  201c0d:	41 5e                	pop    %r14
  201c0f:	41 5f                	pop    %r15
  201c11:	c3                   	retq   
  201c12:	90                   	nop
  201c13:	90                   	nop
  201c14:	90                   	nop
  201c15:	90                   	nop
  201c16:	90                   	nop
  201c17:	90                   	nop

0000000000201c18 <__boot_header>:
  201c18:	02 b0 ad 1b 00 00    	add    0x1bad(%rax),%dh
  201c1e:	00 00                	add    %al,(%rax)
  201c20:	fe 4f 52             	decb   0x52(%rdi)
  201c23:	e4 0f                	in     $0xf,%al
  201c25:	1f                   	(bad)  
  201c26:	40 00 00             	add    %al,(%rax)

0000000000201c28 <__boot_gdt>:
  201c28:	00 00                	add    %al,(%rax)
  201c2a:	27                   	(bad)  
  201c2b:	00 28                	add    %ch,(%rax)
  201c2d:	1c 20                	sbb    $0x20,%al
  201c2f:	00 00                	add    %al,(%rax)
  201c31:	00 00                	add    %al,(%rax)
  201c33:	00 00                	add    %al,(%rax)
  201c35:	9b                   	fwait
  201c36:	a0 00 00 00 00 00 00 	movabs 0xa093000000000000,%al
  201c3d:	93 a0 
  201c3f:	00 00                	add    %al,(%rax)
  201c41:	00 00                	add    %al,(%rax)
  201c43:	00 00                	add    %al,(%rax)
  201c45:	fb                   	sti    
  201c46:	a0 00 00 00 00 00 00 	movabs 0xa0f3000000000000,%al
  201c4d:	f3 a0 
	...

0000000000201c50 <__boot_gdt__>:
/*
 * AP Startup Code
 */
.code16

__start_ap:             INIT_PAGING
  201c50:	66 b9 80 00          	mov    $0x80,%cx
  201c54:	00 c0                	add    %al,%al
  201c56:	0f 32                	rdmsr  
  201c58:	66 0d 01 01          	or     $0x101,%ax
  201c5c:	00 00                	add    %al,(%rax)
  201c5e:	0f 30                	wrmsr  
  201c60:	66 ba b8 06          	mov    $0x6b8,%dx
  201c64:	00 00                	add    %al,(%rax)
  201c66:	0f 22 e2             	mov    %rdx,%cr4
  201c69:	66 ba 00 80          	mov    $0x8000,%dx
  201c6d:	56                   	push   %rsi
  201c6e:	00 0f                	add    %cl,(%rdi)
  201c70:	22 da                	and    %dl,%bl
  201c72:	66 ba 2b 00          	mov    $0x2b,%dx
  201c76:	01 80 0f 22 c2 2e    	add    %eax,0x2ec2220f(%rax)
                        lgdtl   %cs:__gdt_desc - __start_ap
  201c7c:	66                   	data16
  201c7d:	0f 01 16             	lgdt   (%rsi)
  201c80:	3a 00                	cmp    (%rax),%al
                        ljmpl   $SEL_KERN_CODE, $__start_all
  201c82:	66                   	data16
  201c83:	ea                   	(bad)  
  201c84:	3b 1d 20 00 08 00    	cmp    0x80020(%rip),%ebx        # 281caa <LOAD_E+0x7ecaa>

0000000000201c8a <__gdt_desc>:
  201c8a:	27                   	(bad)  
  201c8b:	00 28                	add    %ch,(%rax)
  201c8d:	1c 20                	sbb    $0x20,%al
	...

0000000000201c90 <__start_bsp>:
/*
 * BSP Startup Code
 */
.code32

__start_bsp:            mov     $(__start_bsp - __start_ap), %ecx
  201c90:	b9 40 00 00 00       	mov    $0x40,%ecx
                        mov     $__start_ap, %esi
  201c95:	be 50 1c 20 00       	mov    $0x201c50,%esi
                        mov     $0x1000, %edi
  201c9a:	bf 00 10 00 00       	mov    $0x1000,%edi
                        rep     movsb
  201c9f:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
#ifdef __x86_64__
                        mov     $(LVL3L + 0x27), %ecx
  201ca1:	b9 27 90 56 00       	mov    $0x569027,%ecx
                        mov     %ecx, LVL4  + SIZE * (LOAD_ADDR >> (3 * PTE_BPL + PAGE_BITS) & ((1 << PTE_BPL) - 1))
  201ca6:	89 0d 00 80 56 00    	mov    %ecx,0x568000(%rip)        # 769cac <LVL2H+0x1fdcac>
                        mov     $(LVL2L + 0x27), %ecx
  201cac:	b9 27 b0 56 00       	mov    $0x56b027,%ecx
                        mov     %ecx, LVL3L + SIZE * (LOAD_ADDR >> (2 * PTE_BPL + PAGE_BITS) & ((1 << PTE_BPL) - 1))
  201cb1:	89 0d 00 90 56 00    	mov    %ecx,0x569000(%rip)        # 76acb7 <LVL2H+0x1fecb7>

                        mov     $(LVL3H + 0x27), %ecx
  201cb7:	b9 27 a0 56 00       	mov    $0x56a027,%ecx
                        mov     %ecx, LVL4  + SIZE * (LINK_ADDR >> (3 * PTE_BPL + PAGE_BITS) & ((1 << PTE_BPL) - 1))
  201cbc:	89 0d f8 8f 56 00    	mov    %ecx,0x568ff8(%rip)        # 76acba <LVL2H+0x1fecba>
                        mov     $(LVL2H + 0x27), %ecx
  201cc2:	b9 27 c0 56 00       	mov    $0x56c027,%ecx
                        mov     %ecx, LVL3H + SIZE * (LINK_ADDR >> (2 * PTE_BPL + PAGE_BITS) & ((1 << PTE_BPL) - 1))
  201cc7:	89 0d f0 af 56 00    	mov    %ecx,0x56aff0(%rip)        # 76ccbd <LVL2H+0x200cbd>
#endif
                        mov     $0xe3, %ecx
  201ccd:	b9 e3 00 00 00       	mov    $0xe3,%ecx
                        mov     $LVL2L, %edi
  201cd2:	bf 00 b0 56 00       	mov    $0x56b000,%edi
1:                      mov     %ecx, (%edi)
  201cd7:	89 0f                	mov    %ecx,(%rdi)
                        add     $(1 << (PTE_BPL + PAGE_BITS)), %ecx
  201cd9:	81 c1 00 00 20 00    	add    $0x200000,%ecx
                        add     $SIZE, %edi
  201cdf:	83 c7 08             	add    $0x8,%edi
                        cmp     $LOAD_E, %ecx
  201ce2:	81 f9 00 30 20 00    	cmp    $0x203000,%ecx
                        jb      1b
  201ce8:	72 ed                	jb     201cd7 <__start_bsp+0x47>

                        mov     $(LINK_P + 0x1e3), %ecx
  201cea:	b9 e3 01 40 00       	mov    $0x4001e3,%ecx
                        mov     $(LVL2H + SIZE * (LINK_ADDR >> (PTE_BPL + PAGE_BITS) & ((1 << PTE_BPL) - 1))), %edi
  201cef:	bf 40 c0 56 00       	mov    $0x56c040,%edi
1:                      mov     %ecx, (%edi)
  201cf4:	89 0f                	mov    %ecx,(%rdi)
                        add     $(1 << (PTE_BPL + PAGE_BITS)), %ecx
  201cf6:	81 c1 00 00 20 00    	add    $0x200000,%ecx
                        add     $SIZE, %edi
  201cfc:	83 c7 08             	add    $0x8,%edi
                        cmp     $LINK_E, %ecx
  201cff:	81 f9 00 00 80 08    	cmp    $0x8800000,%ecx
                        jb      1b
  201d05:	72 ed                	jb     201cf4 <__start_bsp+0x64>

                        INIT_PAGING
  201d07:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
  201d0c:	0f 32                	rdmsr  
  201d0e:	0d 01 01 00 00       	or     $0x101,%eax
  201d13:	0f 30                	wrmsr  
  201d15:	ba b8 06 00 00       	mov    $0x6b8,%edx
  201d1a:	0f 22 e2             	mov    %rdx,%cr4
  201d1d:	ba 00 80 56 00       	mov    $0x568000,%edx
  201d22:	0f 22 da             	mov    %rdx,%cr3
  201d25:	ba 2b 00 01 80       	mov    $0x8001002b,%edx
  201d2a:	0f 22 c2             	mov    %rdx,%cr0
                        lgdt    __boot_gdt + 2
  201d2d:	0f 01 15 2a 1c 20 00 	lgdt   0x201c2a(%rip)        # 40395e <LINK_P+0x395e>
                        ljmp    $SEL_KERN_CODE, $__start_all
  201d34:	ea                   	(bad)  
  201d35:	3b 1d 20 00 08 00    	cmp    0x80020(%rip),%ebx        # 281d5b <LOAD_E+0x7ed5b>

0000000000201d3b <__start_all>:
 */
#ifdef __x86_64__
.code64
#endif

__start_all:            INIT_STATE
  201d3b:	b9 10 00 00 00       	mov    $0x10,%ecx
  201d40:	8e d1                	mov    %ecx,%ss
  201d42:	b9 23 00 00 00       	mov    $0x23,%ecx
  201d47:	8e d9                	mov    %ecx,%ds
  201d49:	8e c1                	mov    %ecx,%es
  201d4b:	8e e1                	mov    %ecx,%fs
  201d4d:	8e e9                	mov    %ecx,%gs
  201d4f:	bc 00 30 20 00       	mov    $0x203000,%esp
                        test    %REG(bx), %REG(bx)
  201d54:	48 85 db             	test   %rbx,%rbx
                        je      2f
  201d57:	74 0c                	je     201d65 <__start_all+0x2a>

                        mov     %REG(bx), %ARG_1
  201d59:	48 89 df             	mov    %rbx,%rdi
                        call    init
  201d5c:	e8 3c f7 ff ff       	callq  20149d <init>
                        jmp     3f
  201d61:	eb 0f                	jmp    201d72 <__start_all+0x37>

1:                      pause
  201d63:	f3 90                	pause  
2:                      xchg    %REG(bx), boot_lock
  201d65:	48 87 1c 25 48 20 16 	xchg   %rbx,0xffffffff81162048
  201d6c:	81 
                        test    %REG(bx), %REG(bx)
  201d6d:	48 85 db             	test   %rbx,%rbx
                        je      1b
  201d70:	74 f1                	je     201d63 <__start_all+0x28>

3:                      call    kern_ptab_setup
  201d72:	e8 55 f6 ff ff       	callq  2013cc <kern_ptab_setup>
                        jmp     1f
  201d77:	e9 d7 50 e1 80       	jmpq   ffffffff81016e53 <_ZN9Space_pio10page_faultEmm+0x93>
  201d7c:	90                   	nop
  201d7d:	90                   	nop
  201d7e:	90                   	nop
  201d7f:	90                   	nop

0000000000201d80 <_ZN15Acpi_table_rsdt3mapE>:
  201d80:	41 50 49 43 00 1d 02 81 ff ff ff ff 44 4d 41 52     APIC........DMAR
  201d90:	18 1d 02 81 ff ff ff ff 46 41 43 50 10 1d 02 81     ........FACP....
  201da0:	ff ff ff ff 48 50 45 54 08 1d 02 81 ff ff ff ff     ....HPET........
  201db0:	4d 43 46 47 f8 1c 02 81 ff ff ff ff 90 90 90 90     MCFG............

0000000000201dc0 <_ZN7Cmdline3mapE>:
  201dc0:	0c d7 01 81 ff ff ff ff a0 1d 02 81 ff ff ff ff     ................
  201dd0:	12 d7 01 81 ff ff ff ff 9f 1d 02 81 ff ff ff ff     ................
  201de0:	17 d7 01 81 ff ff ff ff 9e 1d 02 81 ff ff ff ff     ................
  201df0:	1e d7 01 81 ff ff ff ff 9d 1d 02 81 ff ff ff ff     ................
  201e00:	26 d7 01 81 ff ff ff ff 9c 1d 02 81 ff ff ff ff     &...............
  201e10:	2b d7 01 81 ff ff ff ff 9b 1d 02 81 ff ff ff ff     +...............
  201e20:	30 d7 01 81 ff ff ff ff 9a 1d 02 81 ff ff ff ff     0...............
  201e30:	37 d7 01 81 ff ff ff ff 99 1d 02 81 ff ff ff ff     7...............
  201e40:	3d d7 01 81 ff ff ff ff 98 1d 02 81 ff ff ff ff     =...............

Disassembly of section .text:

ffffffff81000000 <_ZN2Ec16ret_user_sysexitEv>:
    if (hzd & HZD_FPU)
        if (current != fpowner)
            Fpu::disable();
}

void Ec::ret_user_sysexit() {
ffffffff81000000:	50                   	push   %rax
    if (current->is_idle()) {
ffffffff81000001:	48 8b 05 00 f0 ff 3e 	mov    0x3efff000(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81000008:	83 b8 4c 03 00 00 00 	cmpl   $0x0,0x34c(%rax)
ffffffff8100000f:	75 47                	jne    ffffffff81000058 <_ZN2Ec16ret_user_sysexitEv+0x58>
        mword hzd = (Cpu::hazard | current->regs.hazard()) & (HZD_RECALL | HZD_STEP | HZD_RCU | HZD_FPU | HZD_DS_ES | HZD_SCHED);
ffffffff81000011:	8b 3d e9 ef ff 3e    	mov    0x3effefe9(%rip),%edi        # ffffffffbffff000 <_ZN3Cpu6hazardE>
ffffffff81000017:	48 0b b8 80 01 00 00 	or     0x180(%rax),%rdi
        if (EXPECT_FALSE(hzd))
ffffffff8100001e:	81 e7 1b 00 00 c0    	and    $0xc000001b,%edi
ffffffff81000024:	74 0c                	je     ffffffff81000032 <_ZN2Ec16ret_user_sysexitEv+0x32>
            handle_hazard(hzd, ret_user_sysexit);
ffffffff81000026:	48 c7 c6 00 00 00 81 	mov    $0xffffffff81000000,%rsi
ffffffff8100002d:	e8 f2 47 00 00       	callq  ffffffff81004824 <_ZN2Ec13handle_hazardEmPFvvE>

        current->save_state();
ffffffff81000032:	48 8b 05 cf ef ff 3e 	mov    0x3effefcf(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
    void restore_state();

    void rollback();

    void save_state() {
        regs_0 = regs;
ffffffff81000039:	b9 3c 00 00 00       	mov    $0x3c,%ecx
ffffffff8100003e:	48 8d b8 98 01 00 00 	lea    0x198(%rax),%rdi
ffffffff81000045:	48 8d b0 a8 00 00 00 	lea    0xa8(%rax),%rsi
ffffffff8100004c:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
        current->launch_state = Ec::sysexit;
ffffffff8100004e:	c7 80 4c 03 00 00 01 	movl   $0x1,0x34c(%rax)
ffffffff81000055:	00 00 00 
    }
    asm volatile ("lea %0," EXPAND(PREG(sp); LOAD_GPR RET_USER_HYP) : : "m" (current->regs) : "memory");
ffffffff81000058:	48 8b 05 a9 ef ff 3e 	mov    0x3effefa9(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100005f:	48 8d a0 a8 00 00 00 	lea    0xa8(%rax),%rsp
ffffffff81000066:	41 5f                	pop    %r15
ffffffff81000068:	41 5e                	pop    %r14
ffffffff8100006a:	41 5d                	pop    %r13
ffffffff8100006c:	41 5c                	pop    %r12
ffffffff8100006e:	41 5b                	pop    %r11
ffffffff81000070:	41 5a                	pop    %r10
ffffffff81000072:	41 59                	pop    %r9
ffffffff81000074:	41 58                	pop    %r8
ffffffff81000076:	5f                   	pop    %rdi
ffffffff81000077:	5e                   	pop    %rsi
ffffffff81000078:	5d                   	pop    %rbp
ffffffff81000079:	58                   	pop    %rax
ffffffff8100007a:	5b                   	pop    %rbx
ffffffff8100007b:	5a                   	pop    %rdx
ffffffff8100007c:	59                   	pop    %rcx
ffffffff8100007d:	58                   	pop    %rax
ffffffff8100007e:	4c 89 dc             	mov    %r11,%rsp
ffffffff81000081:	49 c7 c3 00 02 00 00 	mov    $0x200,%r11
ffffffff81000088:	48 0f 07             	sysretq 
ffffffff8100008b:	90                   	nop

ffffffff8100008c <ret_user_iret>:

    UNREACHED;
}

void Ec::ret_user_iret() {
ffffffff8100008c:	50                   	push   %rax
    if (current->is_idle()) {
ffffffff8100008d:	48 8b 05 74 ef ff 3e 	mov    0x3effef74(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81000094:	83 b8 4c 03 00 00 00 	cmpl   $0x0,0x34c(%rax)
ffffffff8100009b:	75 47                	jne    ffffffff810000e4 <ret_user_iret+0x58>
        // No need to check HZD_DS_ES because IRET will reload both anyway
        mword hzd = (Cpu::hazard | current->regs.hazard()) & (HZD_RECALL | HZD_STEP | HZD_RCU | HZD_FPU | HZD_SCHED);
ffffffff8100009d:	8b 3d 5d ef ff 3e    	mov    0x3effef5d(%rip),%edi        # ffffffffbffff000 <_ZN3Cpu6hazardE>
ffffffff810000a3:	48 0b b8 80 01 00 00 	or     0x180(%rax),%rdi
        if (EXPECT_FALSE(hzd))
ffffffff810000aa:	81 e7 19 00 00 c0    	and    $0xc0000019,%edi
ffffffff810000b0:	74 0c                	je     ffffffff810000be <ret_user_iret+0x32>
            handle_hazard(hzd, ret_user_iret);
ffffffff810000b2:	48 c7 c6 8c 00 00 81 	mov    $0xffffffff8100008c,%rsi
ffffffff810000b9:	e8 66 47 00 00       	callq  ffffffff81004824 <_ZN2Ec13handle_hazardEmPFvvE>

        current->save_state();
ffffffff810000be:	48 8b 05 43 ef ff 3e 	mov    0x3effef43(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff810000c5:	b9 3c 00 00 00       	mov    $0x3c,%ecx
ffffffff810000ca:	48 8d b8 98 01 00 00 	lea    0x198(%rax),%rdi
ffffffff810000d1:	48 8d b0 a8 00 00 00 	lea    0xa8(%rax),%rsi
ffffffff810000d8:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
        current->launch_state = Ec::iret;
ffffffff810000da:	c7 80 4c 03 00 00 02 	movl   $0x2,0x34c(%rax)
ffffffff810000e1:	00 00 00 
    }
    asm volatile ("lea %0," EXPAND(PREG(sp); LOAD_GPR LOAD_SEG RET_USER_EXC) : : "m" (current->regs) : "memory");
ffffffff810000e4:	48 8b 05 1d ef ff 3e 	mov    0x3effef1d(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff810000eb:	48 8d a0 a8 00 00 00 	lea    0xa8(%rax),%rsp
ffffffff810000f2:	41 5f                	pop    %r15
ffffffff810000f4:	41 5e                	pop    %r14
ffffffff810000f6:	41 5d                	pop    %r13
ffffffff810000f8:	41 5c                	pop    %r12
ffffffff810000fa:	41 5b                	pop    %r11
ffffffff810000fc:	41 5a                	pop    %r10
ffffffff810000fe:	41 59                	pop    %r9
ffffffff81000100:	41 58                	pop    %r8
ffffffff81000102:	5f                   	pop    %rdi
ffffffff81000103:	5e                   	pop    %rsi
ffffffff81000104:	5d                   	pop    %rbp
ffffffff81000105:	58                   	pop    %rax
ffffffff81000106:	5b                   	pop    %rbx
ffffffff81000107:	5a                   	pop    %rdx
ffffffff81000108:	59                   	pop    %rcx
ffffffff81000109:	58                   	pop    %rax
ffffffff8100010a:	48 83 c4 30          	add    $0x30,%rsp
ffffffff8100010e:	48 cf                	iretq  

ffffffff81000110 <chk_kern_preempt>:

    UNREACHED;
}

void Ec::chk_kern_preempt() {
    if (!Cpu::preemption)
ffffffff81000110:	80 3d 19 f6 ff 3e 00 	cmpb   $0x0,0x3efff619(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81000117:	74 2e                	je     ffffffff81000147 <chk_kern_preempt+0x37>
ffffffff81000119:	48 8b 05 e8 ee ff 3e 	mov    0x3effeee8(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
        return;

    if (Ec::current->is_idle() && Cpu::hazard & HZD_SCHED) { // this may leak from the kernel without terminating a double_running.
ffffffff81000120:	83 b8 4c 03 00 00 00 	cmpl   $0x0,0x34c(%rax)
ffffffff81000127:	75 1e                	jne    ffffffff81000147 <chk_kern_preempt+0x37>
ffffffff81000129:	f6 05 d0 ee ff 3e 01 	testb  $0x1,0x3effeed0(%rip)        # ffffffffbffff000 <_ZN3Cpu6hazardE>
ffffffff81000130:	74 15                	je     ffffffff81000147 <chk_kern_preempt+0x37>
    asm volatile ("lea %0," EXPAND(PREG(sp); LOAD_GPR LOAD_SEG RET_USER_EXC) : : "m" (current->regs) : "memory");

    UNREACHED;
}

void Ec::chk_kern_preempt() {
ffffffff81000132:	50                   	push   %rax
        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);

            asm volatile ("cli" : : : "memory");
ffffffff81000133:	fa                   	cli    
    if (!Cpu::preemption)
        return;

    if (Ec::current->is_idle() && Cpu::hazard & HZD_SCHED) { // this may leak from the kernel without terminating a double_running.
        Cpu::preempt_disable();
        Sc::schedule();
ffffffff81000134:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff81000139:	31 ff                	xor    %edi,%edi
            preemption = false;
ffffffff8100013b:	c6 05 ee f5 ff 3e 00 	movb   $0x0,0x3efff5ee(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81000142:	e8 6d 4c 01 00       	callq  ffffffff81014db4 <_ZN2Sc8scheduleEbb>
ffffffff81000147:	c3                   	retq   

ffffffff81000148 <_ZN2Ec9recv_kernEv>:
    sys_finish<Sys_regs::COM_TIM>();
}

void Ec::recv_kern()
{
    Ec *ec = current->rcap;
ffffffff81000148:	48 8b 05 b9 ee ff 3e 	mov    0x3effeeb9(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>

    sys_finish<Sys_regs::COM_TIM>();
}

void Ec::recv_kern()
{
ffffffff8100014f:	53                   	push   %rbx
    Ec *ec = current->rcap;
ffffffff81000150:	48 8b 98 88 02 00 00 	mov    0x288(%rax),%rbx

    bool fpu = false;

    if (ec->cont == ret_user_iret)
ffffffff81000157:	48 8b 93 a0 00 00 00 	mov    0xa0(%rbx),%rdx
ffffffff8100015e:	48 81 fa 8c 00 00 81 	cmp    $0xffffffff8100008c,%rdx
ffffffff81000165:	75 15                	jne    ffffffff8100017c <_ZN2Ec9recv_kernEv+0x34>
        fpu = current->utcb->load_exc (&ec->regs);
ffffffff81000167:	48 8b b8 90 02 00 00 	mov    0x290(%rax),%rdi
ffffffff8100016e:	48 8d b3 a8 00 00 00 	lea    0xa8(%rbx),%rsi
ffffffff81000175:	e8 a8 ac 01 00       	callq  ffffffff8101ae22 <_ZN4Utcb8load_excEP8Cpu_regs>
ffffffff8100017a:	eb 3a                	jmp    ffffffff810001b6 <_ZN2Ec9recv_kernEv+0x6e>
    else if (ec->cont == ret_user_vmresume)
ffffffff8100017c:	48 81 fa 52 51 00 81 	cmp    $0xffffffff81005152,%rdx
ffffffff81000183:	75 15                	jne    ffffffff8100019a <_ZN2Ec9recv_kernEv+0x52>
        fpu = current->utcb->load_vmx (&ec->regs);
ffffffff81000185:	48 8b b8 90 02 00 00 	mov    0x290(%rax),%rdi
ffffffff8100018c:	48 8d b3 a8 00 00 00 	lea    0xa8(%rbx),%rsi
ffffffff81000193:	e8 84 ae 01 00       	callq  ffffffff8101b01c <_ZN4Utcb8load_vmxEP8Cpu_regs>
ffffffff81000198:	eb 1c                	jmp    ffffffff810001b6 <_ZN2Ec9recv_kernEv+0x6e>
    else if (ec->cont == ret_user_vmrun)
ffffffff8100019a:	48 81 fa 8a 4a 00 81 	cmp    $0xffffffff81004a8a,%rdx
ffffffff810001a1:	75 26                	jne    ffffffff810001c9 <_ZN2Ec9recv_kernEv+0x81>
        fpu = current->utcb->load_svm (&ec->regs);
ffffffff810001a3:	48 8b b8 90 02 00 00 	mov    0x290(%rax),%rdi
ffffffff810001aa:	48 8d b3 a8 00 00 00 	lea    0xa8(%rbx),%rsi
ffffffff810001b1:	e8 40 bb 01 00       	callq  ffffffff8101bcf6 <_ZN4Utcb8load_svmEP8Cpu_regs>

    if (EXPECT_FALSE (fpu))
ffffffff810001b6:	84 c0                	test   %al,%al
ffffffff810001b8:	74 0f                	je     ffffffff810001c9 <_ZN2Ec9recv_kernEv+0x81>
        ec->transfer_fpu (current);
ffffffff810001ba:	48 8b 35 47 ee ff 3e 	mov    0x3effee47(%rip),%rsi        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff810001c1:	48 89 df             	mov    %rbx,%rdi
ffffffff810001c4:	e8 d9 60 00 00       	callq  ffffffff810062a2 <_ZN2Ec12transfer_fpuEPS_>

    ret_user_sysexit();
ffffffff810001c9:	e8 32 fe ff ff       	callq  ffffffff81000000 <_ZN2Ec16ret_user_sysexitEv>

ffffffff810001ce <_ZN2Ec5replyEPFvvEP2Sm>:

    ret_user_sysexit();
}

void Ec::reply (void (*c)(), Sm * sm)
{
ffffffff810001ce:	41 55                	push   %r13
ffffffff810001d0:	41 54                	push   %r12
ffffffff810001d2:	55                   	push   %rbp
ffffffff810001d3:	53                   	push   %rbx
ffffffff810001d4:	50                   	push   %rax
    current->cont = c;
ffffffff810001d5:	48 8b 05 2c ee ff 3e 	mov    0x3effee2c(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>

    if (EXPECT_FALSE (current->glb))
ffffffff810001dc:	66 83 b8 f2 02 00 00 	cmpw   $0x0,0x2f2(%rax)
ffffffff810001e3:	00 
    ret_user_sysexit();
}

void Ec::reply (void (*c)(), Sm * sm)
{
    current->cont = c;
ffffffff810001e4:	48 89 b8 a0 00 00 00 	mov    %rdi,0xa0(%rax)

    if (EXPECT_FALSE (current->glb))
ffffffff810001eb:	74 0f                	je     ffffffff810001fc <_ZN2Ec5replyEPFvvEP2Sm+0x2e>
        Sc::schedule (true);
ffffffff810001ed:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff810001f2:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff810001f7:	e9 4c 02 00 00       	jmpq   ffffffff81000448 <_ZN2Ec5replyEPFvvEP2Sm+0x27a>

    Ec *ec = current->rcap;
ffffffff810001fc:	48 8b 98 88 02 00 00 	mov    0x288(%rax),%rbx

    if (EXPECT_FALSE (!ec))
ffffffff81000203:	48 85 db             	test   %rbx,%rbx
ffffffff81000206:	0f 84 50 02 00 00    	je     ffffffff8100045c <_ZN2Ec5replyEPFvvEP2Sm+0x28e>
        Sc::ctr_link++;
    }

    ALWAYS_INLINE
    inline unsigned clr_partner() {
        assert(partner == current);
ffffffff8100020c:	48 39 83 a0 02 00 00 	cmp    %rax,0x2a0(%rbx)
ffffffff81000213:	74 1f                	je     ffffffff81000234 <_ZN2Ec5replyEPFvvEP2Sm+0x66>
ffffffff81000215:	49 c7 c0 40 12 02 81 	mov    $0xffffffff81021240,%r8
ffffffff8100021c:	b9 b6 00 00 00       	mov    $0xb6,%ecx
ffffffff81000221:	48 c7 c2 d3 da 01 81 	mov    $0xffffffff8101dad3,%rdx
ffffffff81000228:	48 c7 c6 07 e8 01 81 	mov    $0xffffffff8101e807,%rsi
ffffffff8100022f:	e9 3d 03 00 00       	jmpq   ffffffff81000571 <_ZN2Ec5replyEPFvvEP2Sm+0x3a3>
ffffffff81000234:	48 89 f5             	mov    %rsi,%rbp
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff81000237:	f0 ff 8b 8c 00 00 00 	lock decl 0x8c(%rbx)
        if (partner->rcap) {
            partner->rcap->del_ref();
            partner->rcap = nullptr;
ffffffff8100023e:	48 8b 83 a0 02 00 00 	mov    0x2a0(%rbx),%rax
ffffffff81000245:	48 c7 80 88 02 00 00 	movq   $0x0,0x288(%rax)
ffffffff8100024c:	00 00 00 00 
ffffffff81000250:	48 8b 83 a0 02 00 00 	mov    0x2a0(%rbx),%rax
ffffffff81000257:	f0 ff 88 8c 00 00 00 	lock decl 0x8c(%rax)
        }
        partner->del_ref();
        partner = nullptr;
        return Sc::ctr_link--;
ffffffff8100025e:	8b 05 a0 fa ff 3e    	mov    0x3efffaa0(%rip),%eax        # ffffffffbffffd04 <_ZN2Sc8ctr_linkE>
        if (partner->rcap) {
            partner->rcap->del_ref();
            partner->rcap = nullptr;
        }
        partner->del_ref();
        partner = nullptr;
ffffffff81000264:	48 c7 83 a0 02 00 00 	movq   $0x0,0x2a0(%rbx)
ffffffff8100026b:	00 00 00 00 
        Sc::current->ec->activate();

    bool clr = ec->clr_partner();
ffffffff8100026f:	85 c0                	test   %eax,%eax
        return Sc::ctr_link--;
ffffffff81000271:	8d 50 ff             	lea    -0x1(%rax),%edx
ffffffff81000274:	41 0f 95 c5          	setne  %r13b

    if (sm)
ffffffff81000278:	48 85 f6             	test   %rsi,%rsi
ffffffff8100027b:	89 15 83 fa ff 3e    	mov    %edx,0x3efffa83(%rip)        # ffffffffbffffd04 <_ZN2Sc8ctr_linkE>
ffffffff81000281:	0f 84 d0 01 00 00    	je     ffffffff81000457 <_ZN2Ec5replyEPFvvEP2Sm+0x289>
        }

        ALWAYS_INLINE
        inline void dn (bool zero, uint64 t, Ec *ec = Ec::current, bool block = true)
        {
            {   Lock_guard <Spinlock> guard (lock);
ffffffff81000287:	48 8d be 8a 00 00 00 	lea    0x8a(%rsi),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff8100028e:	9c                   	pushfq 
ffffffff8100028f:	41 5c                	pop    %r12
            return flags & 0x200;
ffffffff81000291:	49 c1 ec 09          	shr    $0x9,%r12

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff81000295:	41 80 e4 01          	and    $0x1,%r12b
ffffffff81000299:	74 30                	je     ffffffff810002cb <_ZN2Ec5replyEPFvvEP2Sm+0xfd>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff8100029b:	80 3d 8e f4 ff 3e 00 	cmpb   $0x0,0x3efff48e(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff810002a2:	75 1f                	jne    ffffffff810002c3 <_ZN2Ec5replyEPFvvEP2Sm+0xf5>
ffffffff810002a4:	49 c7 c0 f0 12 02 81 	mov    $0xffffffff810212f0,%r8
ffffffff810002ab:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff810002b0:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff810002b7:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff810002be:	e9 ae 02 00 00       	jmpq   ffffffff81000571 <_ZN2Ec5replyEPFvvEP2Sm+0x3a3>

            asm volatile ("cli" : : : "memory");
ffffffff810002c3:	fa                   	cli    
            preemption = false;
ffffffff810002c4:	c6 05 65 f4 ff 3e 00 	movb   $0x0,0x3efff465(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff810002cb:	e8 be 0b 00 00       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>

                if (counter) {
ffffffff810002d0:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff810002d7:	48 85 c0             	test   %rax,%rax
ffffffff810002da:	0f 84 aa 00 00 00    	je     ffffffff8100038a <_ZN2Ec5replyEPFvvEP2Sm+0x1bc>
                    counter = zero ? 0 : counter - 1;
ffffffff810002e0:	48 ff c8             	dec    %rax
ffffffff810002e3:	48 89 85 c0 00 00 00 	mov    %rax,0xc0(%rbp)
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff810002ea:	48 8b 85 98 00 00 00 	mov    0x98(%rbp),%rax
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff810002f1:	48 85 c0             	test   %rax,%rax
ffffffff810002f4:	0f 84 30 01 00 00    	je     ffffffff8100042a <_ZN2Ec5replyEPFvvEP2Sm+0x25c>
ffffffff810002fa:	48 8b 50 10          	mov    0x10(%rax),%rdx
ffffffff810002fe:	48 85 d2             	test   %rdx,%rdx
ffffffff81000301:	0f 84 23 01 00 00    	je     ffffffff8100042a <_ZN2Ec5replyEPFvvEP2Sm+0x25c>
ffffffff81000307:	48 8b 48 08          	mov    0x8(%rax),%rcx
ffffffff8100030b:	48 85 c9             	test   %rcx,%rcx
ffffffff8100030e:	0f 84 16 01 00 00    	je     ffffffff8100042a <_ZN2Ec5replyEPFvvEP2Sm+0x25c>
                return false;

            if (t == t->next)
ffffffff81000314:	48 39 d0             	cmp    %rdx,%rax
ffffffff81000317:	75 0d                	jne    ffffffff81000326 <_ZN2Ec5replyEPFvvEP2Sm+0x158>
                headptr = nullptr;
ffffffff81000319:	48 c7 85 98 00 00 00 	movq   $0x0,0x98(%rbp)
ffffffff81000320:	00 00 00 00 
ffffffff81000324:	eb 24                	jmp    ffffffff8100034a <_ZN2Ec5replyEPFvvEP2Sm+0x17c>

            else {
                t->next->prev = t->prev;
ffffffff81000326:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
                t->prev->next = t->next;
ffffffff8100032a:	48 8b 50 08          	mov    0x8(%rax),%rdx
ffffffff8100032e:	48 8b 48 10          	mov    0x10(%rax),%rcx
ffffffff81000332:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
                if (t == headptr)
ffffffff81000336:	48 3b 85 98 00 00 00 	cmp    0x98(%rbp),%rax
ffffffff8100033d:	75 0b                	jne    ffffffff8100034a <_ZN2Ec5replyEPFvvEP2Sm+0x17c>
                    headptr = t->next;
ffffffff8100033f:	48 8b 50 10          	mov    0x10(%rax),%rdx
ffffffff81000343:	48 89 95 98 00 00 00 	mov    %rdx,0x98(%rbp)

    public:

        mword reset(bool l = false) {
            if (l) lock.lock();
            mword c = counter;
ffffffff8100034a:	48 8b 50 20          	mov    0x20(%rax),%rdx
            }

            t->next = t->prev = nullptr;
ffffffff8100034e:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
ffffffff81000355:	00 
ffffffff81000356:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
ffffffff8100035d:	00 
            counter = 0;
ffffffff8100035e:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
ffffffff81000365:	00 
                if (counter) {
                    counter = zero ? 0 : counter - 1;

                    Si * si;
                    if (Queue<Si>::dequeue(si = Queue<Si>::head()))
                        ec->set_si_regs(si->value, static_cast <Sm *>(si)->reset());
ffffffff81000366:	48 8b 40 18          	mov    0x18(%rax),%rax
    }

    ALWAYS_INLINE
    inline void set_si_regs(mword sig, mword cnt) {
        regs.ARG_2 = sig;
        regs.ARG_3 = cnt;
ffffffff8100036a:	48 89 93 10 01 00 00 	mov    %rdx,0x110(%rbx)
            timeout.dequeue();
    }

    ALWAYS_INLINE
    inline void set_si_regs(mword sig, mword cnt) {
        regs.ARG_2 = sig;
ffffffff81000371:	48 89 83 f0 00 00 00 	mov    %rax,0xf0(%rbx)
ffffffff81000378:	e9 ad 00 00 00       	jmpq   ffffffff8100042a <_ZN2Ec5replyEPFvvEP2Sm+0x25c>

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8100037d:	8d 50 01             	lea    0x1(%rax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff81000380:	f0 0f b1 93 8c 00 00 	lock cmpxchg %edx,0x8c(%rbx)
ffffffff81000387:	00 
ffffffff81000388:	74 0a                	je     ffffffff81000394 <_ZN2Ec5replyEPFvvEP2Sm+0x1c6>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100038a:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff81000390:	85 c0                	test   %eax,%eax
ffffffff81000392:	75 e9                	jne    ffffffff8100037d <_ZN2Ec5replyEPFvvEP2Sm+0x1af>
        inline T *head() const { return headptr; }

        ALWAYS_INLINE
        inline void enqueue (T *t)
        {
            if (!headptr)
ffffffff81000394:	48 8b 85 90 00 00 00 	mov    0x90(%rbp),%rax
ffffffff8100039b:	48 85 c0             	test   %rax,%rax
ffffffff8100039e:	75 17                	jne    ffffffff810003b7 <_ZN2Ec5replyEPFvvEP2Sm+0x1e9>
                headptr = t->prev = t->next = t;
ffffffff810003a0:	48 89 9b b0 02 00 00 	mov    %rbx,0x2b0(%rbx)
ffffffff810003a7:	48 89 9b a8 02 00 00 	mov    %rbx,0x2a8(%rbx)
ffffffff810003ae:	48 89 9d 90 00 00 00 	mov    %rbx,0x90(%rbp)
ffffffff810003b5:	eb 2a                	jmp    ffffffff810003e1 <_ZN2Ec5replyEPFvvEP2Sm+0x213>
            else {
                t->next = headptr;
ffffffff810003b7:	48 89 83 b0 02 00 00 	mov    %rax,0x2b0(%rbx)
                t->prev = headptr->prev;
ffffffff810003be:	48 8b 95 90 00 00 00 	mov    0x90(%rbp),%rdx
ffffffff810003c5:	48 8b 92 a8 02 00 00 	mov    0x2a8(%rdx),%rdx
ffffffff810003cc:	48 89 93 a8 02 00 00 	mov    %rdx,0x2a8(%rbx)
                t->next->prev = t->prev->next = t;
ffffffff810003d3:	48 89 9a b0 02 00 00 	mov    %rbx,0x2b0(%rdx)
ffffffff810003da:	48 89 98 a8 02 00 00 	mov    %rbx,0x2a8(%rax)
        }

        ALWAYS_INLINE
        inline void unlock()
        {
            asm volatile ("incb %0" : "=m" (val) : : "memory");
ffffffff810003e1:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff810003e7:	45 84 e4             	test   %r12b,%r12b
ffffffff810003ea:	74 30                	je     ffffffff8100041c <_ZN2Ec5replyEPFvvEP2Sm+0x24e>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff810003ec:	80 3d 3d f3 ff 3e 00 	cmpb   $0x0,0x3efff33d(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff810003f3:	74 1f                	je     ffffffff81000414 <_ZN2Ec5replyEPFvvEP2Sm+0x246>
ffffffff810003f5:	49 c7 c0 c0 12 02 81 	mov    $0xffffffff810212c0,%r8
ffffffff810003fc:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff81000401:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81000408:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff8100040f:	e9 5d 01 00 00       	jmpq   ffffffff81000571 <_ZN2Ec5replyEPFvvEP2Sm+0x3a3>

            preemption = true;
ffffffff81000414:	c6 05 15 f3 ff 3e 01 	movb   $0x1,0x3efff315(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100041b:	fb                   	sti    
                ec->add_ref();

                Queue<Ec>::enqueue (ec);
            }

            if (!block)
ffffffff8100041c:	45 84 ed             	test   %r13b,%r13b
ffffffff8100041f:	75 2c                	jne    ffffffff8100044d <_ZN2Ec5replyEPFvvEP2Sm+0x27f>
                Sc::schedule (false);
ffffffff81000421:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff81000426:	31 ff                	xor    %edi,%edi
ffffffff81000428:	eb 1e                	jmp    ffffffff81000448 <_ZN2Ec5replyEPFvvEP2Sm+0x27a>
ffffffff8100042a:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
ffffffff81000430:	45 84 e4             	test   %r12b,%r12b
ffffffff81000433:	74 22                	je     ffffffff81000457 <_ZN2Ec5replyEPFvvEP2Sm+0x289>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81000435:	80 3d f4 f2 ff 3e 00 	cmpb   $0x0,0x3efff2f4(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100043c:	75 b7                	jne    ffffffff810003f5 <_ZN2Ec5replyEPFvvEP2Sm+0x227>

            preemption = true;
ffffffff8100043e:	c6 05 eb f2 ff 3e 01 	movb   $0x1,0x3efff2eb(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81000445:	fb                   	sti    
ffffffff81000446:	eb 0f                	jmp    ffffffff81000457 <_ZN2Ec5replyEPFvvEP2Sm+0x289>
ffffffff81000448:	e8 67 49 01 00       	callq  ffffffff81014db4 <_ZN2Sc8scheduleEbb>

            ec->set_timeout (t, this);

            ec->block_sc();
ffffffff8100044d:	48 89 df             	mov    %rbx,%rdi
ffffffff81000450:	e8 19 b3 00 00       	callq  ffffffff8100b76e <_ZN2Ec8block_scEv>
ffffffff81000455:	eb 18                	jmp    ffffffff8100046f <_ZN2Ec5replyEPFvvEP2Sm+0x2a1>
        sm->dn (false, 0, ec, clr);

    if (!clr)
ffffffff81000457:	45 84 ed             	test   %r13b,%r13b
ffffffff8100045a:	75 13                	jne    ffffffff8100046f <_ZN2Ec5replyEPFvvEP2Sm+0x2a1>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
ffffffff8100045c:	48 8b 05 b5 eb ff 3e 	mov    0x3effebb5(%rip),%rax        # ffffffffbffff018 <_ZN2Sc7currentE>
        Sc::current->ec->activate();
ffffffff81000463:	48 8b b8 90 00 00 00 	mov    0x90(%rax),%rdi
ffffffff8100046a:	e8 07 70 01 00       	callq  ffffffff81017476 <_ZN2Ec8activateEv>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff8100046f:	48 8b 05 92 eb ff 3e 	mov    0x3effeb92(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81000476:	83 ca ff             	or     $0xffffffff,%edx
ffffffff81000479:	f0 0f c1 90 8c 00 00 	lock xadd %edx,0x8c(%rax)
ffffffff81000480:	00 
        regs.ARG_3 = cnt;
    }

    ALWAYS_INLINE NORETURN
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
ffffffff81000481:	ff ca                	dec    %edx
ffffffff81000483:	75 31                	jne    ffffffff810004b6 <_ZN2Ec5replyEPFvvEP2Sm+0x2e8>
            delete current;
ffffffff81000485:	48 8b 2d 7c eb ff 3e 	mov    0x3effeb7c(%rip),%rbp        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100048c:	48 85 ed             	test   %rbp,%rbp
ffffffff8100048f:	74 25                	je     ffffffff810004b6 <_ZN2Ec5replyEPFvvEP2Sm+0x2e8>
ffffffff81000491:	48 89 ef             	mov    %rbp,%rdi
ffffffff81000494:	e8 a3 3f 00 00       	callq  ffffffff8100443c <_ZN2EcD1Ev>
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff81000499:	48 8b 85 98 02 00 00 	mov    0x298(%rbp),%rax
ffffffff810004a0:	48 89 ee             	mov    %rbp,%rsi
ffffffff810004a3:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff810004aa:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff810004b1:	e8 b4 55 01 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
            delete current;
        }

        current = this;
ffffffff810004b6:	48 89 1d 4b eb ff 3e 	mov    %rbx,0x3effeb4b(%rip)        # ffffffffbffff008 <_ZN2Ec7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff810004bd:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff810004c3:	85 c0                	test   %eax,%eax
ffffffff810004c5:	74 0d                	je     ffffffff810004d4 <_ZN2Ec5replyEPFvvEP2Sm+0x306>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff810004c7:	8d 50 01             	lea    0x1(%rax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff810004ca:	f0 0f b1 93 8c 00 00 	lock cmpxchg %edx,0x8c(%rbx)
ffffffff810004d1:	00 
ffffffff810004d2:	75 e9                	jne    ffffffff810004bd <_ZN2Ec5replyEPFvvEP2Sm+0x2ef>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
ffffffff810004d4:	48 8b 93 98 02 00 00 	mov    0x298(%rbx),%rdx

        current->add_ref();

        Tss::run.sp0 = reinterpret_cast<mword> (exc_regs() + 1);
ffffffff810004db:	48 8d 83 80 01 00 00 	lea    0x180(%rbx),%rax

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
ffffffff810004e2:	8b 0d 1c eb ff 3e    	mov    0x3effeb1c(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff810004e8:	48 89 05 dd f8 ff 3e 	mov    %rax,0x3efff8dd(%rip)        # ffffffffbffffdcc <tss_run+0x4>
ffffffff810004ef:	48 8b 82 c8 02 00 00 	mov    0x2c8(%rdx),%rax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
ffffffff810004f6:	48 8b b2 b8 02 00 00 	mov    0x2b8(%rdx),%rsi

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
ffffffff810004fd:	48 0f a3 c8          	bt     %rcx,%rax
ffffffff81000501:	73 14                	jae    ffffffff81000517 <_ZN2Ec5replyEPFvvEP2Sm+0x349>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
ffffffff81000503:	48 c7 c0 fe ff ff ff 	mov    $0xfffffffffffffffe,%rax
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
ffffffff8100050a:	48 d3 c0             	rol    %cl,%rax
ffffffff8100050d:	f0 48 21 82 c8 02 00 	lock and %rax,0x2c8(%rdx)
ffffffff81000514:	00 
ffffffff81000515:	eb 20                	jmp    ffffffff81000537 <_ZN2Ec5replyEPFvvEP2Sm+0x369>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
ffffffff81000517:	48 39 15 f2 ea ff 3e 	cmp    %rdx,0x3effeaf2(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100051e:	0f 84 e5 00 00 00    	je     ffffffff81000609 <_ZN2Ec5replyEPFvvEP2Sm+0x43b>
                    return;

                if (pcid != NO_PCID)
ffffffff81000524:	48 83 fe 02          	cmp    $0x2,%rsi
ffffffff81000528:	74 0d                	je     ffffffff81000537 <_ZN2Ec5replyEPFvvEP2Sm+0x369>
                    pcid |= static_cast<mword>(1ULL << 63);
ffffffff8100052a:	48 b8 00 00 00 00 00 	movabs $0x8000000000000000,%rax
ffffffff81000531:	00 00 80 
ffffffff81000534:	48 09 c6             	or     %rax,%rsi
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff81000537:	48 8b 05 d2 ea ff 3e 	mov    0x3effead2(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100053e:	83 c9 ff             	or     $0xffffffff,%ecx
ffffffff81000541:	f0 0f c1 88 8c 00 00 	lock xadd %ecx,0x8c(%rax)
ffffffff81000548:	00 
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
ffffffff81000549:	83 f9 01             	cmp    $0x1,%ecx
ffffffff8100054c:	75 31                	jne    ffffffff8100057f <_ZN2Ec5replyEPFvvEP2Sm+0x3b1>
                assert (current != this);
ffffffff8100054e:	48 8b 2d bb ea ff 3e 	mov    0x3effeabb(%rip),%rbp        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81000555:	48 39 d5             	cmp    %rdx,%rbp
ffffffff81000558:	75 27                	jne    ffffffff81000581 <_ZN2Ec5replyEPFvvEP2Sm+0x3b3>
ffffffff8100055a:	49 c7 c0 a0 12 02 81 	mov    $0xffffffff810212a0,%r8
ffffffff81000561:	b1 5e                	mov    $0x5e,%cl
ffffffff81000563:	48 c7 c2 c7 e6 01 81 	mov    $0xffffffff8101e6c7,%rdx
ffffffff8100056a:	48 c7 c6 35 e7 01 81 	mov    $0xffffffff8101e735,%rsi
ffffffff81000571:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81000578:	31 c0                	xor    %eax,%eax
ffffffff8100057a:	e8 d1 19 00 00       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
ffffffff8100057f:	31 ed                	xor    %ebp,%ebp
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
ffffffff81000581:	48 89 15 88 ea ff 3e 	mov    %rdx,0x3effea88(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff81000588:	8b 82 8c 00 00 00    	mov    0x8c(%rdx),%eax
ffffffff8100058e:	85 c0                	test   %eax,%eax
ffffffff81000590:	74 0d                	je     ffffffff8100059f <_ZN2Ec5replyEPFvvEP2Sm+0x3d1>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff81000592:	8d 48 01             	lea    0x1(%rax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff81000595:	f0 0f b1 8a 8c 00 00 	lock cmpxchg %ecx,0x8c(%rdx)
ffffffff8100059c:	00 
ffffffff8100059d:	75 e9                	jne    ffffffff81000588 <_ZN2Ec5replyEPFvvEP2Sm+0x3ba>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
ffffffff8100059f:	f6 05 a0 f1 ff 3e 02 	testb  $0x2,0x3efff1a0(%rip)        # ffffffffbffff746 <_ZN3Cpu8featuresE+0x6>
        return addr;
    }

    ALWAYS_INLINE
    inline void make_current(mword pcid) {
        asm volatile ("mov %0, %%cr3" : : "r" (val | pcid) : "memory");
ffffffff810005a6:	8b 0d 58 ea ff 3e    	mov    0x3effea58(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff810005ac:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff810005b1:	48 0f 45 c6          	cmovne %rsi,%rax
ffffffff810005b5:	48 0b 84 ca a0 00 00 	or     0xa0(%rdx,%rcx,8),%rax
ffffffff810005bc:	00 
ffffffff810005bd:	0f 22 d8             	mov    %rax,%cr3

            if (del_pd)
ffffffff810005c0:	48 85 ed             	test   %rbp,%rbp
ffffffff810005c3:	74 44                	je     ffffffff81000609 <_ZN2Ec5replyEPFvvEP2Sm+0x43b>
                delete del_pd;
ffffffff810005c5:	48 89 ef             	mov    %rbp,%rdi
ffffffff810005c8:	e8 5b 0a 01 00       	callq  ffffffff81011028 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff810005cd:	48 8b 45 50          	mov    0x50(%rbp),%rax
ffffffff810005d1:	31 d2                	xor    %edx,%edx

            pd_del->quota.free_up(pd_to->quota);
ffffffff810005d3:	48 8d bd 08 03 00 00 	lea    0x308(%rbp),%rdi

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff810005da:	48 8d 88 08 fd ff ff 	lea    -0x2f8(%rax),%rcx
ffffffff810005e1:	48 85 c0             	test   %rax,%rax
ffffffff810005e4:	48 0f 45 d1          	cmovne %rcx,%rdx

            pd_del->quota.free_up(pd_to->quota);
ffffffff810005e8:	4c 8d a2 08 03 00 00 	lea    0x308(%rdx),%r12
ffffffff810005ef:	4c 89 e6             	mov    %r12,%rsi
ffffffff810005f2:	e8 cd 2f 00 00       	callq  ffffffff810035c4 <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
ffffffff810005f7:	4c 89 e2             	mov    %r12,%rdx
ffffffff810005fa:	48 89 ee             	mov    %rbp,%rsi
ffffffff810005fd:	48 c7 c7 d0 3f 16 81 	mov    $0xffffffff81163fd0,%rdi
ffffffff81000604:	e8 61 54 01 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>

        pd->make_current();

        asm volatile ("mov %0," EXPAND(PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory");
ffffffff81000609:	48 8b 83 a0 00 00 00 	mov    0xa0(%rbx),%rax
ffffffff81000610:	48 c7 c4 00 e0 ff bf 	mov    $0xffffffffbfffe000,%rsp
ffffffff81000617:	ff e0                	jmpq   *%rax
ffffffff81000619:	90                   	nop

ffffffff8100061a <_ZN2Ec9recv_userEv>:
    ret_user_sysexit();
}

void Ec::recv_user()
{
    Ec *ec = current->rcap;
ffffffff8100061a:	48 8b 05 e7 e9 ff 3e 	mov    0x3effe9e7(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81000621:	41 b8 fc 01 00 00    	mov    $0x1fc,%r8d
ffffffff81000627:	48 8b 88 88 02 00 00 	mov    0x288(%rax),%rcx

    ec->utcb->save (current->utcb);
ffffffff8100062e:	48 8b b0 90 02 00 00 	mov    0x290(%rax),%rsi
ffffffff81000635:	48 8b b9 90 02 00 00 	mov    0x290(%rcx),%rdi
ffffffff8100063c:	48 8b 07             	mov    (%rdi),%rax
        WARN_UNUSED_RESULT bool load_svm (Cpu_regs *);
        WARN_UNUSED_RESULT bool save_exc (Cpu_regs *);
        WARN_UNUSED_RESULT bool save_vmx (Cpu_regs *);
        WARN_UNUSED_RESULT bool save_svm (Cpu_regs *);

        inline mword ucnt() const { return static_cast<uint16>(items); }
ffffffff8100063f:	0f b7 d0             	movzwl %ax,%edx
        ALWAYS_INLINE NONNULL
        inline void save (Utcb *dst)
        {
            register mword n = ui();

            dst->items = items;
ffffffff81000642:	48 89 06             	mov    %rax,(%rsi)
ffffffff81000645:	48 81 fa fc 01 00 00 	cmp    $0x1fc,%rdx
ffffffff8100064c:	49 0f 47 d0          	cmova  %r8,%rdx
#if 0
            mword *d = dst->mr, *s = mr;
            asm volatile ("rep; movsl" : "+D" (d), "+S" (s), "+c" (n) : : "memory");
#else
            for (unsigned long i = 0; i < n; i++)
ffffffff81000650:	31 c0                	xor    %eax,%eax
ffffffff81000652:	48 39 d0             	cmp    %rdx,%rax
ffffffff81000655:	74 0f                	je     ffffffff81000666 <_ZN2Ec9recv_userEv+0x4c>
                dst->mr[i] = mr[i];
ffffffff81000657:	4c 8b 44 c7 20       	mov    0x20(%rdi,%rax,8),%r8
ffffffff8100065c:	4c 89 44 c6 20       	mov    %r8,0x20(%rsi,%rax,8)
            dst->items = items;
#if 0
            mword *d = dst->mr, *s = mr;
            asm volatile ("rep; movsl" : "+D" (d), "+S" (s), "+c" (n) : : "memory");
#else
            for (unsigned long i = 0; i < n; i++)
ffffffff81000661:	48 ff c0             	inc    %rax
ffffffff81000664:	eb ec                	jmp    ffffffff81000652 <_ZN2Ec9recv_userEv+0x38>

    ret_user_sysexit();
}

void Ec::recv_user()
{
ffffffff81000666:	50                   	push   %rax
ffffffff81000667:	48 8b 81 90 02 00 00 	mov    0x290(%rcx),%rax
    Ec *ec = current->rcap;

    ec->utcb->save (current->utcb);

    if (EXPECT_FALSE (ec->utcb->tcnt()))
ffffffff8100066e:	66 83 78 02 00       	cmpw   $0x0,0x2(%rax)
ffffffff81000673:	74 05                	je     ffffffff8100067a <_ZN2Ec9recv_userEv+0x60>
        delegate<true>();
ffffffff81000675:	e8 80 87 01 00       	callq  ffffffff81018dfa <_ZN2Ec8delegateILb1EEEvv>

    ret_user_sysexit();
ffffffff8100067a:	e8 81 f9 ff ff       	callq  ffffffff81000000 <_ZN2Ec16ret_user_sysexitEv>
ffffffff8100067f:	90                   	nop

ffffffff81000680 <_ZN2Ec9sys_replyEv>:

    ec->make_current();
}

void Ec::sys_reply()
{
ffffffff81000680:	55                   	push   %rbp
ffffffff81000681:	53                   	push   %rbx
ffffffff81000682:	48 83 ec 18          	sub    $0x18,%rsp
    Ec *ec = current->rcap;
ffffffff81000686:	48 8b 05 7b e9 ff 3e 	mov    0x3effe97b(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100068d:	48 8b a8 88 02 00 00 	mov    0x288(%rax),%rbp
    Sm *sm = nullptr;

    if (EXPECT_TRUE (ec)) {
ffffffff81000694:	48 85 ed             	test   %rbp,%rbp
ffffffff81000697:	0f 84 65 01 00 00    	je     ffffffff81000802 <_ZN2Ec9sys_replyEv+0x182>

        enum { SYSCALL_REPLY = 1 };

        Sys_reply *r = static_cast<Sys_reply *>(current->sys_regs());

        if (EXPECT_FALSE (current->cont == sys_reply && current->regs.status() != SYSCALL_REPLY)) {
ffffffff8100069d:	48 81 b8 a0 00 00 00 	cmpq   $0xffffffff81000680,0xa0(%rax)
ffffffff810006a4:	80 06 00 81 
ffffffff810006a8:	0f 85 c5 00 00 00    	jne    ffffffff81000773 <_ZN2Ec9sys_replyEv+0xf3>
ffffffff810006ae:	48 8b 98 e8 00 00 00 	mov    0xe8(%rax),%rbx
ffffffff810006b5:	80 fb 01             	cmp    $0x1,%bl
ffffffff810006b8:	0f 84 b5 00 00 00    	je     ffffffff81000773 <_ZN2Ec9sys_replyEv+0xf3>
            else
                ARG_1 = (ARG_1 & ~0xfful) | s;
        }

        ALWAYS_INLINE
        inline void set_pt (mword pt) { ARG_1 = pt; }
ffffffff810006be:	48 c7 80 e8 00 00 00 	movq   $0x1,0xe8(%rax)
ffffffff810006c5:	01 00 00 00 
                if (EXPECT_TRUE (cap.obj()->type() == Kobject::SM && (cap.prm() & 2)))
                    sm = static_cast<Sm *>(cap.obj());
            }
        }

        if (EXPECT_FALSE (sm)) {
ffffffff810006c9:	48 85 db             	test   %rbx,%rbx
            sm = reinterpret_cast<Sm *>(r->sm_kern());
            current->regs.set_pt(SYSCALL_REPLY);
        } else {
            if (EXPECT_FALSE (r->sm())) {
                Capability cap = Space_obj::lookup (r->sm());
                if (EXPECT_TRUE (cap.obj()->type() == Kobject::SM && (cap.prm() & 2)))
ffffffff810006cc:	0f 84 c5 00 00 00    	je     ffffffff81000797 <_ZN2Ec9sys_replyEv+0x117>
                    sm = static_cast<Sm *>(cap.obj());
            }
        }

        if (EXPECT_FALSE (sm)) {
            if (ec->cont == ret_user_sysexit)
ffffffff810006d2:	48 8b 95 a0 00 00 00 	mov    0xa0(%rbp),%rdx
ffffffff810006d9:	48 81 fa 00 00 00 81 	cmp    $0xffffffff81000000,%rdx
ffffffff810006e0:	75 10                	jne    ffffffff810006f2 <_ZN2Ec9sys_replyEv+0x72>
                ec->cont = sys_call;
ffffffff810006e2:	48 c7 85 a0 00 00 00 	movq   $0xffffffff810008ae,0xa0(%rbp)
ffffffff810006e9:	ae 08 00 81 
ffffffff810006ed:	e9 a7 00 00 00       	jmpq   ffffffff81000799 <_ZN2Ec9sys_replyEv+0x119>
            else if (ec->cont == xcpu_return)
ffffffff810006f2:	48 81 fa 76 53 00 81 	cmp    $0xffffffff81005376,%rdx
ffffffff810006f9:	75 0c                	jne    ffffffff81000707 <_ZN2Ec9sys_replyEv+0x87>
        inline void set_status (Status s, bool c = true)
        {
            if (c)
                ARG_1 = s;
            else
                ARG_1 = (ARG_1 & ~0xfful) | s;
ffffffff810006fb:	c6 85 e8 00 00 00 03 	movb   $0x3,0xe8(%rbp)
ffffffff81000702:	e9 92 00 00 00       	jmpq   ffffffff81000799 <_ZN2Ec9sys_replyEv+0x119>
                ec->regs.set_status (Sys_regs::BAD_HYP, false);
            else if (ec->cont == sys_reply) {
ffffffff81000707:	48 81 fa 80 06 00 81 	cmp    $0xffffffff81000680,%rdx
ffffffff8100070e:	0f 85 85 00 00 00    	jne    ffffffff81000799 <_ZN2Ec9sys_replyEv+0x119>
                assert (ec->regs.status() == SYSCALL_REPLY);
ffffffff81000714:	80 bd e8 00 00 00 01 	cmpb   $0x1,0xe8(%rbp)
ffffffff8100071b:	74 1c                	je     ffffffff81000739 <_ZN2Ec9sys_replyEv+0xb9>
ffffffff8100071d:	49 c7 c0 20 12 02 81 	mov    $0xffffffff81021220,%r8
ffffffff81000724:	b9 fb 00 00 00       	mov    $0xfb,%ecx
ffffffff81000729:	48 c7 c2 ab 0c 02 81 	mov    $0xffffffff81020cab,%rdx
ffffffff81000730:	48 c7 c6 6f 0e 02 81 	mov    $0xffffffff81020e6f,%rsi
ffffffff81000737:	eb 25                	jmp    ffffffff8100075e <_ZN2Ec9sys_replyEv+0xde>
        }

        ALWAYS_INLINE
        inline void set_pt (mword pt) { ARG_1 = pt; }
ffffffff81000739:	48 89 9d e8 00 00 00 	mov    %rbx,0xe8(%rbp)
                ec->regs.set_pt(reinterpret_cast<mword>(sm));
                assert (ec->regs.status() != SYSCALL_REPLY);
ffffffff81000740:	fe cb                	dec    %bl
ffffffff81000742:	75 28                	jne    ffffffff8100076c <_ZN2Ec9sys_replyEv+0xec>
ffffffff81000744:	49 c7 c0 20 12 02 81 	mov    $0xffffffff81021220,%r8
ffffffff8100074b:	b9 fd 00 00 00       	mov    $0xfd,%ecx
ffffffff81000750:	48 c7 c2 ab 0c 02 81 	mov    $0xffffffff81020cab,%rdx
ffffffff81000757:	48 c7 c6 92 0e 02 81 	mov    $0xffffffff81020e92,%rsi
ffffffff8100075e:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81000765:	31 c0                	xor    %eax,%eax
ffffffff81000767:	e8 e4 17 00 00       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
                reply();
ffffffff8100076c:	31 f6                	xor    %esi,%esi
ffffffff8100076e:	e9 94 00 00 00       	jmpq   ffffffff81000807 <_ZN2Ec9sys_replyEv+0x187>

        if (EXPECT_FALSE (current->cont == sys_reply && current->regs.status() != SYSCALL_REPLY)) {
            sm = reinterpret_cast<Sm *>(r->sm_kern());
            current->regs.set_pt(SYSCALL_REPLY);
        } else {
            if (EXPECT_FALSE (r->sm())) {
ffffffff81000773:	48 8b 90 e8 00 00 00 	mov    0xe8(%rax),%rdx
ffffffff8100077a:	48 c1 ea 08          	shr    $0x8,%rdx
ffffffff8100077e:	74 17                	je     ffffffff81000797 <_ZN2Ec9sys_replyEv+0x117>
{
    private:
        ALWAYS_INLINE
        static inline mword idx_to_virt (unsigned long idx)
        {
            return SPC_LOCAL_OBJ + (idx % caps) * sizeof (Capability);
ffffffff81000780:	81 e2 ff ff ff 03    	and    $0x3ffffff,%edx
        static unsigned const caps = (END_SPACE_LIM - SPC_LOCAL_OBJ) / sizeof (Capability);

        ALWAYS_INLINE
        static inline Capability lookup (unsigned long idx)
        {
            return *reinterpret_cast<Capability *>(idx_to_virt (idx));
ffffffff81000786:	48 8b 14 d5 00 00 00 	mov    -0x20000000(,%rdx,8),%rdx
ffffffff8100078d:	e0 

    public:
        ALWAYS_INLINE
        inline Type type() const
        {
            return EXPECT_TRUE (this) ? Type (objtype) : INVALID;
ffffffff8100078e:	48 89 d3             	mov    %rdx,%rbx
ffffffff81000791:	48 83 e3 e0          	and    $0xffffffffffffffe0,%rbx
ffffffff81000795:	75 77                	jne    ffffffff8100080e <_ZN2Ec9sys_replyEv+0x18e>

    ec->make_current();
}

void Ec::sys_reply()
{
ffffffff81000797:	31 db                	xor    %ebx,%ebx
                assert (ec->regs.status() != SYSCALL_REPLY);
                reply();
            }
        }

        Utcb *src = current->utcb;
ffffffff81000799:	48 8b b8 90 02 00 00 	mov    0x290(%rax),%rdi

        if (EXPECT_FALSE (src->tcnt()))
ffffffff810007a0:	66 83 7f 02 00       	cmpw   $0x0,0x2(%rdi)
ffffffff810007a5:	74 0f                	je     ffffffff810007b6 <_ZN2Ec9sys_replyEv+0x136>
ffffffff810007a7:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
            delegate<false>();
ffffffff810007ac:	e8 6d 87 01 00       	callq  ffffffff81018f1e <_ZN2Ec8delegateILb0EEEvv>
ffffffff810007b1:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi

        bool fpu = false;

        assert (current->cont != ret_xcpu_reply);
ffffffff810007b6:	48 8b 05 4b e8 ff 3e 	mov    0x3effe84b(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff810007bd:	48 81 b8 a0 00 00 00 	cmpq   $0xffffffff81017234,0xa0(%rax)
ffffffff810007c4:	34 72 01 81 
ffffffff810007c8:	75 1f                	jne    ffffffff810007e9 <_ZN2Ec9sys_replyEv+0x169>
ffffffff810007ca:	49 c7 c0 20 12 02 81 	mov    $0xffffffff81021220,%r8
ffffffff810007d1:	b9 09 01 00 00       	mov    $0x109,%ecx
ffffffff810007d6:	48 c7 c2 ab 0c 02 81 	mov    $0xffffffff81020cab,%rdx
ffffffff810007dd:	48 c7 c6 b5 0e 02 81 	mov    $0xffffffff81020eb5,%rsi
ffffffff810007e4:	e9 75 ff ff ff       	jmpq   ffffffff8100075e <_ZN2Ec9sys_replyEv+0xde>

        if (EXPECT_TRUE ((ec->cont == ret_user_sysexit) || ec->cont == xcpu_return))
ffffffff810007e9:	48 8b 85 a0 00 00 00 	mov    0xa0(%rbp),%rax
ffffffff810007f0:	48 3d 00 00 00 81    	cmp    $0xffffffff81000000,%rax
ffffffff810007f6:	74 27                	je     ffffffff8100081f <_ZN2Ec9sys_replyEv+0x19f>
ffffffff810007f8:	48 3d 76 53 00 81    	cmp    $0xffffffff81005376,%rax
ffffffff810007fe:	75 55                	jne    ffffffff81000855 <_ZN2Ec9sys_replyEv+0x1d5>
ffffffff81000800:	eb 1d                	jmp    ffffffff8100081f <_ZN2Ec9sys_replyEv+0x19f>
}

void Ec::sys_reply()
{
    Ec *ec = current->rcap;
    Sm *sm = nullptr;
ffffffff81000802:	31 db                	xor    %ebx,%ebx

        if (EXPECT_FALSE (fpu))
            current->transfer_fpu (ec);
    }

    reply(nullptr, sm);
ffffffff81000804:	48 89 de             	mov    %rbx,%rsi
ffffffff81000807:	31 ff                	xor    %edi,%edi
ffffffff81000809:	e8 c0 f9 ff ff       	callq  ffffffff810001ce <_ZN2Ec5replyEPFvvEP2Sm>
            sm = reinterpret_cast<Sm *>(r->sm_kern());
            current->regs.set_pt(SYSCALL_REPLY);
        } else {
            if (EXPECT_FALSE (r->sm())) {
                Capability cap = Space_obj::lookup (r->sm());
                if (EXPECT_TRUE (cap.obj()->type() == Kobject::SM && (cap.prm() & 2)))
ffffffff8100080e:	80 bb 88 00 00 00 04 	cmpb   $0x4,0x88(%rbx)
ffffffff81000815:	75 80                	jne    ffffffff81000797 <_ZN2Ec9sys_replyEv+0x117>
ffffffff81000817:	80 e2 02             	and    $0x2,%dl
ffffffff8100081a:	e9 ad fe ff ff       	jmpq   ffffffff810006cc <_ZN2Ec9sys_replyEv+0x4c>
ffffffff8100081f:	48 8b 07             	mov    (%rdi),%rax
        bool fpu = false;

        assert (current->cont != ret_xcpu_reply);

        if (EXPECT_TRUE ((ec->cont == ret_user_sysexit) || ec->cont == xcpu_return))
            src->save (ec->utcb);
ffffffff81000822:	48 8b 8d 90 02 00 00 	mov    0x290(%rbp),%rcx
ffffffff81000829:	be fc 01 00 00       	mov    $0x1fc,%esi
        WARN_UNUSED_RESULT bool load_svm (Cpu_regs *);
        WARN_UNUSED_RESULT bool save_exc (Cpu_regs *);
        WARN_UNUSED_RESULT bool save_vmx (Cpu_regs *);
        WARN_UNUSED_RESULT bool save_svm (Cpu_regs *);

        inline mword ucnt() const { return static_cast<uint16>(items); }
ffffffff8100082e:	0f b7 d0             	movzwl %ax,%edx
        ALWAYS_INLINE NONNULL
        inline void save (Utcb *dst)
        {
            register mword n = ui();

            dst->items = items;
ffffffff81000831:	48 89 01             	mov    %rax,(%rcx)
ffffffff81000834:	48 81 fa fc 01 00 00 	cmp    $0x1fc,%rdx
ffffffff8100083b:	48 0f 47 d6          	cmova  %rsi,%rdx
#if 0
            mword *d = dst->mr, *s = mr;
            asm volatile ("rep; movsl" : "+D" (d), "+S" (s), "+c" (n) : : "memory");
#else
            for (unsigned long i = 0; i < n; i++)
ffffffff8100083f:	31 c0                	xor    %eax,%eax
ffffffff81000841:	48 39 d0             	cmp    %rdx,%rax
ffffffff81000844:	74 be                	je     ffffffff81000804 <_ZN2Ec9sys_replyEv+0x184>
                dst->mr[i] = mr[i];
ffffffff81000846:	48 8b 74 c7 20       	mov    0x20(%rdi,%rax,8),%rsi
ffffffff8100084b:	48 89 74 c1 20       	mov    %rsi,0x20(%rcx,%rax,8)
            dst->items = items;
#if 0
            mword *d = dst->mr, *s = mr;
            asm volatile ("rep; movsl" : "+D" (d), "+S" (s), "+c" (n) : : "memory");
#else
            for (unsigned long i = 0; i < n; i++)
ffffffff81000850:	48 ff c0             	inc    %rax
ffffffff81000853:	eb ec                	jmp    ffffffff81000841 <_ZN2Ec9sys_replyEv+0x1c1>
        else if (ec->cont == ret_user_iret)
ffffffff81000855:	48 3d 8c 00 00 81    	cmp    $0xffffffff8100008c,%rax
ffffffff8100085b:	75 0e                	jne    ffffffff8100086b <_ZN2Ec9sys_replyEv+0x1eb>
            fpu = src->save_exc (&ec->regs);
ffffffff8100085d:	48 8d b5 a8 00 00 00 	lea    0xa8(%rbp),%rsi
ffffffff81000864:	e8 c3 a6 01 00       	callq  ffffffff8101af2c <_ZN4Utcb8save_excEP8Cpu_regs>
ffffffff81000869:	eb 27                	jmp    ffffffff81000892 <_ZN2Ec9sys_replyEv+0x212>
        else if (ec->cont == ret_user_vmresume)
ffffffff8100086b:	48 3d 52 51 00 81    	cmp    $0xffffffff81005152,%rax
ffffffff81000871:	48 8d b5 a8 00 00 00 	lea    0xa8(%rbp),%rsi
ffffffff81000878:	75 07                	jne    ffffffff81000881 <_ZN2Ec9sys_replyEv+0x201>
            fpu = src->save_vmx (&ec->regs);
ffffffff8100087a:	e8 25 ae 01 00       	callq  ffffffff8101b6a4 <_ZN4Utcb8save_vmxEP8Cpu_regs>
ffffffff8100087f:	eb 11                	jmp    ffffffff81000892 <_ZN2Ec9sys_replyEv+0x212>
        else if (ec->cont == ret_user_vmrun)
ffffffff81000881:	48 3d 8a 4a 00 81    	cmp    $0xffffffff81004a8a,%rax
ffffffff81000887:	0f 85 77 ff ff ff    	jne    ffffffff81000804 <_ZN2Ec9sys_replyEv+0x184>
            fpu = src->save_svm (&ec->regs);
ffffffff8100088d:	e8 b6 b7 01 00       	callq  ffffffff8101c048 <_ZN4Utcb8save_svmEP8Cpu_regs>

        if (EXPECT_FALSE (fpu))
ffffffff81000892:	84 c0                	test   %al,%al
ffffffff81000894:	0f 84 6a ff ff ff    	je     ffffffff81000804 <_ZN2Ec9sys_replyEv+0x184>
            current->transfer_fpu (ec);
ffffffff8100089a:	48 8b 3d 67 e7 ff 3e 	mov    0x3effe767(%rip),%rdi        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff810008a1:	48 89 ee             	mov    %rbp,%rsi
ffffffff810008a4:	e8 f9 59 00 00       	callq  ffffffff810062a2 <_ZN2Ec12transfer_fpuEPS_>
ffffffff810008a9:	e9 56 ff ff ff       	jmpq   ffffffff81000804 <_ZN2Ec9sys_replyEv+0x184>

ffffffff810008ae <_ZN2Ec8sys_callEv>:

    die ("IPC Timeout");
}

void Ec::sys_call()
{
ffffffff810008ae:	41 55                	push   %r13
ffffffff810008b0:	41 54                	push   %r12
ffffffff810008b2:	55                   	push   %rbp
ffffffff810008b3:	53                   	push   %rbx
ffffffff810008b4:	50                   	push   %rax
    Sys_call *s = static_cast<Sys_call *>(current->sys_regs());
ffffffff810008b5:	48 8b 2d 4c e7 ff 3e 	mov    0x3effe74c(%rip),%rbp        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff810008bc:	4c 8b a5 e8 00 00 00 	mov    0xe8(%rbp),%r12
            DISABLE_DONATION    = 1ul << 1,
            DISABLE_REPLYCAP    = 1ul << 2
        };

        ALWAYS_INLINE
        inline unsigned long pt() const { return ARG_1 >> 8; }
ffffffff810008c3:	4c 89 e0             	mov    %r12,%rax
ffffffff810008c6:	48 c1 e8 08          	shr    $0x8,%rax
{
    private:
        ALWAYS_INLINE
        static inline mword idx_to_virt (unsigned long idx)
        {
            return SPC_LOCAL_OBJ + (idx % caps) * sizeof (Capability);
ffffffff810008ca:	25 ff ff ff 03       	and    $0x3ffffff,%eax
        Capability() : val (0) {}

        Capability (Kobject *o, mword a) : val (a ? reinterpret_cast<mword>(o) | (a & perm) : 0) {}

        ALWAYS_INLINE
        inline Kobject *obj() const { return reinterpret_cast<Kobject *>(val & ~perm); }
ffffffff810008cf:	4c 8b 2c c5 00 00 00 	mov    -0x20000000(,%rax,8),%r13
ffffffff810008d6:	e0 
ffffffff810008d7:	49 83 e5 e0          	and    $0xffffffffffffffe0,%r13
ffffffff810008db:	74 0a                	je     ffffffff810008e7 <_ZN2Ec8sys_callEv+0x39>

    Kobject *obj = Space_obj::lookup (s->pt()).obj();
    if (EXPECT_FALSE (obj->type() != Kobject::PT)) {
ffffffff810008dd:	41 80 bd 88 00 00 00 	cmpb   $0x3,0x88(%r13)
ffffffff810008e4:	03 
ffffffff810008e5:	74 05                	je     ffffffff810008ec <_ZN2Ec8sys_callEv+0x3e>
//        trace (TRACE_ERROR, "%s: Bad PT CAP (%#lx)", __func__, s->pt());
        sys_finish<Sys_regs::BAD_CAP>();
ffffffff810008e7:	e8 48 77 01 00       	callq  ffffffff81018034 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>
    }

    Pt *pt = static_cast<Pt *>(obj);
    Ec *ec = pt->ec;

    if (Pd::current->quota.hit_limit()) {
ffffffff810008ec:	48 8b 05 1d e7 ff 3e 	mov    0x3effe71d(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff810008f3:	31 f6                	xor    %esi,%esi
{
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
ffffffff810008f5:	49 8b 9d 90 00 00 00 	mov    0x90(%r13),%rbx
ffffffff810008fc:	48 8d b8 08 03 00 00 	lea    0x308(%rax),%rdi
ffffffff81000903:	e8 3a 67 01 00       	callq  ffffffff81017042 <_ZN5Quota9hit_limitEm>
ffffffff81000908:	84 c0                	test   %al,%al
ffffffff8100090a:	74 48                	je     ffffffff81000954 <_ZN2Ec8sys_callEv+0xa6>

        if (!current->pt_oom)
ffffffff8100090c:	48 8b b5 38 03 00 00 	mov    0x338(%rbp),%rsi
ffffffff81000913:	48 85 f6             	test   %rsi,%rsi
ffffffff81000916:	75 05                	jne    ffffffff8100091d <_ZN2Ec8sys_callEv+0x6f>
            sys_finish<Sys_regs::QUO_OOM>();
ffffffff81000918:	e8 af 7a 01 00       	callq  ffffffff810183cc <_ZN2Ec10sys_finishILN8Sys_regs6StatusE9ELb0EEEvv>

        if (current->xcpu_sm) {
ffffffff8100091d:	48 83 bd 30 03 00 00 	cmpq   $0x0,0x330(%rbp)
ffffffff81000924:	00 
ffffffff81000925:	74 14                	je     ffffffff8100093b <_ZN2Ec8sys_callEv+0x8d>
        inline void set_status (Status s, bool c = true)
        {
            if (c)
                ARG_1 = s;
            else
                ARG_1 = (ARG_1 & ~0xfful) | s;
ffffffff81000927:	41 80 e4 00          	and    $0x0,%r12b
ffffffff8100092b:	49 83 cc 09          	or     $0x9,%r12
ffffffff8100092f:	4c 89 a5 e8 00 00 00 	mov    %r12,0xe8(%rbp)
            current->regs.set_status (Sys_regs::QUO_OOM, false);
            xcpu_return();
ffffffff81000936:	e8 3b 4a 00 00       	callq  ffffffff81005376 <_ZN2Ec11xcpu_returnEv>
        }

        current->oom_call_cpu (current->pt_oom, current->pt_oom->id, sys_call, sys_call);
ffffffff8100093b:	48 8b 96 a8 00 00 00 	mov    0xa8(%rsi),%rdx
ffffffff81000942:	49 c7 c0 ae 08 00 81 	mov    $0xffffffff810008ae,%r8
ffffffff81000949:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100094c:	4c 89 c1             	mov    %r8,%rcx
ffffffff8100094f:	e8 46 f2 00 00       	callq  ffffffff8100fb9a <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_>
        sys_finish<Sys_regs::QUO_OOM>();
    }

    if (EXPECT_FALSE (current->cpu != ec->xcpu))
ffffffff81000954:	0f b7 85 f0 02 00 00 	movzwl 0x2f0(%rbp),%eax
ffffffff8100095b:	3b 83 f0 02 00 00    	cmp    0x2f0(%rbx),%eax
ffffffff81000961:	74 05                	je     ffffffff81000968 <_ZN2Ec8sys_callEv+0xba>
        Ec::sys_xcpu_call();
ffffffff81000963:	e8 92 93 01 00       	callq  ffffffff81019cfa <_ZN2Ec13sys_xcpu_callEv>

    if (EXPECT_TRUE (!ec->cont)) {
ffffffff81000968:	48 83 bb a0 00 00 00 	cmpq   $0x0,0xa0(%rbx)
ffffffff8100096f:	00 
ffffffff81000970:	0f 85 4b 02 00 00    	jne    ffffffff81000bc1 <_ZN2Ec8sys_callEv+0x313>
        current->cont = current->xcpu_sm ? xcpu_return : ret_user_sysexit;
ffffffff81000976:	48 83 bd 30 03 00 00 	cmpq   $0x0,0x330(%rbp)
ffffffff8100097d:	00 
ffffffff8100097e:	48 c7 c2 00 00 00 81 	mov    $0xffffffff81000000,%rdx
ffffffff81000985:	48 c7 c0 76 53 00 81 	mov    $0xffffffff81005376,%rax
        return &regs;
    }

    ALWAYS_INLINE
    inline void set_partner(Ec *p) {
        partner = p;
ffffffff8100098c:	48 89 9d a0 02 00 00 	mov    %rbx,0x2a0(%rbp)
ffffffff81000993:	48 0f 44 c2          	cmove  %rdx,%rax
ffffffff81000997:	48 89 85 a0 00 00 00 	mov    %rax,0xa0(%rbp)
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100099e:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff810009a4:	85 c0                	test   %eax,%eax
ffffffff810009a6:	74 0d                	je     ffffffff810009b5 <_ZN2Ec8sys_callEv+0x107>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff810009a8:	8d 50 01             	lea    0x1(%rax),%edx
ffffffff810009ab:	f0 0f b1 93 8c 00 00 	lock cmpxchg %edx,0x8c(%rbx)
ffffffff810009b2:	00 
ffffffff810009b3:	75 e9                	jne    ffffffff8100099e <_ZN2Ec8sys_callEv+0xf0>
        partner->add_ref();
        partner->rcap = this;
ffffffff810009b5:	48 8b 85 a0 02 00 00 	mov    0x2a0(%rbp),%rax
ffffffff810009bc:	48 89 a8 88 02 00 00 	mov    %rbp,0x288(%rax)
        partner->rcap->add_ref();
ffffffff810009c3:	48 8b 85 a0 02 00 00 	mov    0x2a0(%rbp),%rax
ffffffff810009ca:	48 8b 90 88 02 00 00 	mov    0x288(%rax),%rdx
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff810009d1:	8b 82 8c 00 00 00    	mov    0x8c(%rdx),%eax
ffffffff810009d7:	85 c0                	test   %eax,%eax
ffffffff810009d9:	74 0d                	je     ffffffff810009e8 <_ZN2Ec8sys_callEv+0x13a>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff810009db:	8d 48 01             	lea    0x1(%rax),%ecx
ffffffff810009de:	f0 0f b1 8a 8c 00 00 	lock cmpxchg %ecx,0x8c(%rdx)
ffffffff810009e5:	00 
ffffffff810009e6:	75 e9                	jne    ffffffff810009d1 <_ZN2Ec8sys_callEv+0x123>
        current->set_partner (ec);
        ec->cont = recv_user;
ffffffff810009e8:	48 c7 83 a0 00 00 00 	movq   $0xffffffff8100061a,0xa0(%rbx)
ffffffff810009ef:	1a 06 00 81 
        ec->regs.set_pt (pt->id);
ffffffff810009f3:	49 8b 85 a8 00 00 00 	mov    0xa8(%r13),%rax
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff810009fa:	83 ca ff             	or     $0xffffffff,%edx
        Sc::ctr_link++;
ffffffff810009fd:	ff 05 01 f3 ff 3e    	incl   0x3efff301(%rip)        # ffffffffbffffd04 <_ZN2Sc8ctr_linkE>
        }

        ALWAYS_INLINE
        inline void set_pt (mword pt) { ARG_1 = pt; }
ffffffff81000a03:	48 89 83 e8 00 00 00 	mov    %rax,0xe8(%rbx)
        ec->regs.set_ip (pt->ip);
ffffffff81000a0a:	49 8b 85 a0 00 00 00 	mov    0xa0(%r13),%rax

        ALWAYS_INLINE
        inline void set_pt (mword pt, mword pt2, mword s) { ARG_1 = pt; ARG_2 = pt2; ARG_3 = s; }

        ALWAYS_INLINE
        inline void set_ip (mword ip) { ARG_IP = ip; }
ffffffff81000a11:	48 89 83 18 01 00 00 	mov    %rax,0x118(%rbx)
ffffffff81000a18:	48 8b 05 e9 e5 ff 3e 	mov    0x3effe5e9(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81000a1f:	f0 0f c1 90 8c 00 00 	lock xadd %edx,0x8c(%rax)
ffffffff81000a26:	00 
        regs.ARG_3 = cnt;
    }

    ALWAYS_INLINE NORETURN
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
ffffffff81000a27:	ff ca                	dec    %edx
ffffffff81000a29:	75 31                	jne    ffffffff81000a5c <_ZN2Ec8sys_callEv+0x1ae>
            delete current;
ffffffff81000a2b:	48 8b 2d d6 e5 ff 3e 	mov    0x3effe5d6(%rip),%rbp        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81000a32:	48 85 ed             	test   %rbp,%rbp
ffffffff81000a35:	74 25                	je     ffffffff81000a5c <_ZN2Ec8sys_callEv+0x1ae>
ffffffff81000a37:	48 89 ef             	mov    %rbp,%rdi
ffffffff81000a3a:	e8 fd 39 00 00       	callq  ffffffff8100443c <_ZN2EcD1Ev>
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff81000a3f:	48 8b 85 98 02 00 00 	mov    0x298(%rbp),%rax
ffffffff81000a46:	48 89 ee             	mov    %rbp,%rsi
ffffffff81000a49:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff81000a50:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff81000a57:	e8 0e 50 01 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
            delete current;
        }

        current = this;
ffffffff81000a5c:	48 89 1d a5 e5 ff 3e 	mov    %rbx,0x3effe5a5(%rip)        # ffffffffbffff008 <_ZN2Ec7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff81000a63:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff81000a69:	85 c0                	test   %eax,%eax
ffffffff81000a6b:	74 0d                	je     ffffffff81000a7a <_ZN2Ec8sys_callEv+0x1cc>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff81000a6d:	8d 50 01             	lea    0x1(%rax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff81000a70:	f0 0f b1 93 8c 00 00 	lock cmpxchg %edx,0x8c(%rbx)
ffffffff81000a77:	00 
ffffffff81000a78:	75 e9                	jne    ffffffff81000a63 <_ZN2Ec8sys_callEv+0x1b5>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
ffffffff81000a7a:	48 8b 93 98 02 00 00 	mov    0x298(%rbx),%rdx

        current->add_ref();

        Tss::run.sp0 = reinterpret_cast<mword> (exc_regs() + 1);
ffffffff81000a81:	48 8d 83 80 01 00 00 	lea    0x180(%rbx),%rax
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
ffffffff81000a88:	8b 0d 76 e5 ff 3e    	mov    0x3effe576(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81000a8e:	48 89 05 37 f3 ff 3e 	mov    %rax,0x3efff337(%rip)        # ffffffffbffffdcc <tss_run+0x4>
ffffffff81000a95:	48 8b 82 c8 02 00 00 	mov    0x2c8(%rdx),%rax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
ffffffff81000a9c:	48 8b ba b8 02 00 00 	mov    0x2b8(%rdx),%rdi

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
ffffffff81000aa3:	48 0f a3 c8          	bt     %rcx,%rax
ffffffff81000aa7:	73 14                	jae    ffffffff81000abd <_ZN2Ec8sys_callEv+0x20f>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
ffffffff81000aa9:	48 c7 c6 fe ff ff ff 	mov    $0xfffffffffffffffe,%rsi
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
ffffffff81000ab0:	48 d3 c6             	rol    %cl,%rsi
ffffffff81000ab3:	f0 48 21 b2 c8 02 00 	lock and %rsi,0x2c8(%rdx)
ffffffff81000aba:	00 
ffffffff81000abb:	eb 20                	jmp    ffffffff81000add <_ZN2Ec8sys_callEv+0x22f>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
ffffffff81000abd:	48 39 15 4c e5 ff 3e 	cmp    %rdx,0x3effe54c(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81000ac4:	0f 84 e7 00 00 00    	je     ffffffff81000bb1 <_ZN2Ec8sys_callEv+0x303>
                    return;

                if (pcid != NO_PCID)
ffffffff81000aca:	48 83 ff 02          	cmp    $0x2,%rdi
ffffffff81000ace:	74 0d                	je     ffffffff81000add <_ZN2Ec8sys_callEv+0x22f>
                    pcid |= static_cast<mword>(1ULL << 63);
ffffffff81000ad0:	48 b8 00 00 00 00 00 	movabs $0x8000000000000000,%rax
ffffffff81000ad7:	00 00 80 
ffffffff81000ada:	48 09 c7             	or     %rax,%rdi
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff81000add:	48 8b 0d 2c e5 ff 3e 	mov    0x3effe52c(%rip),%rcx        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81000ae4:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff81000ae7:	f0 0f c1 81 8c 00 00 	lock xadd %eax,0x8c(%rcx)
ffffffff81000aee:	00 
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
ffffffff81000aef:	ff c8                	dec    %eax
ffffffff81000af1:	75 34                	jne    ffffffff81000b27 <_ZN2Ec8sys_callEv+0x279>
                assert (current != this);
ffffffff81000af3:	48 8b 2d 16 e5 ff 3e 	mov    0x3effe516(%rip),%rbp        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81000afa:	48 39 d5             	cmp    %rdx,%rbp
ffffffff81000afd:	75 2a                	jne    ffffffff81000b29 <_ZN2Ec8sys_callEv+0x27b>
ffffffff81000aff:	49 c7 c0 a0 12 02 81 	mov    $0xffffffff810212a0,%r8
ffffffff81000b06:	b9 5e 00 00 00       	mov    $0x5e,%ecx
ffffffff81000b0b:	48 c7 c2 c7 e6 01 81 	mov    $0xffffffff8101e6c7,%rdx
ffffffff81000b12:	48 c7 c6 35 e7 01 81 	mov    $0xffffffff8101e735,%rsi
ffffffff81000b19:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81000b20:	31 c0                	xor    %eax,%eax
ffffffff81000b22:	e8 29 14 00 00       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
ffffffff81000b27:	31 ed                	xor    %ebp,%ebp
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
ffffffff81000b29:	48 89 15 e0 e4 ff 3e 	mov    %rdx,0x3effe4e0(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff81000b30:	8b 82 8c 00 00 00    	mov    0x8c(%rdx),%eax
ffffffff81000b36:	85 c0                	test   %eax,%eax
ffffffff81000b38:	74 0d                	je     ffffffff81000b47 <_ZN2Ec8sys_callEv+0x299>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff81000b3a:	8d 48 01             	lea    0x1(%rax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff81000b3d:	f0 0f b1 8a 8c 00 00 	lock cmpxchg %ecx,0x8c(%rdx)
ffffffff81000b44:	00 
ffffffff81000b45:	75 e9                	jne    ffffffff81000b30 <_ZN2Ec8sys_callEv+0x282>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
ffffffff81000b47:	f6 05 f8 eb ff 3e 02 	testb  $0x2,0x3effebf8(%rip)        # ffffffffbffff746 <_ZN3Cpu8featuresE+0x6>
ffffffff81000b4e:	8b 0d b0 e4 ff 3e    	mov    0x3effe4b0(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81000b54:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff81000b59:	48 0f 45 c7          	cmovne %rdi,%rax
ffffffff81000b5d:	48 0b 84 ca a0 00 00 	or     0xa0(%rdx,%rcx,8),%rax
ffffffff81000b64:	00 
ffffffff81000b65:	0f 22 d8             	mov    %rax,%cr3

            if (del_pd)
ffffffff81000b68:	48 85 ed             	test   %rbp,%rbp
ffffffff81000b6b:	74 44                	je     ffffffff81000bb1 <_ZN2Ec8sys_callEv+0x303>
                delete del_pd;
ffffffff81000b6d:	48 89 ef             	mov    %rbp,%rdi
ffffffff81000b70:	e8 b3 04 01 00       	callq  ffffffff81011028 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff81000b75:	48 8b 45 50          	mov    0x50(%rbp),%rax
ffffffff81000b79:	31 d2                	xor    %edx,%edx

            pd_del->quota.free_up(pd_to->quota);
ffffffff81000b7b:	48 8d bd 08 03 00 00 	lea    0x308(%rbp),%rdi

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff81000b82:	48 8d 88 08 fd ff ff 	lea    -0x2f8(%rax),%rcx
ffffffff81000b89:	48 85 c0             	test   %rax,%rax
ffffffff81000b8c:	48 0f 45 d1          	cmovne %rcx,%rdx

            pd_del->quota.free_up(pd_to->quota);
ffffffff81000b90:	4c 8d a2 08 03 00 00 	lea    0x308(%rdx),%r12
ffffffff81000b97:	4c 89 e6             	mov    %r12,%rsi
ffffffff81000b9a:	e8 25 2a 00 00       	callq  ffffffff810035c4 <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
ffffffff81000b9f:	4c 89 e2             	mov    %r12,%rdx
ffffffff81000ba2:	48 89 ee             	mov    %rbp,%rsi
ffffffff81000ba5:	48 c7 c7 d0 3f 16 81 	mov    $0xffffffff81163fd0,%rdi
ffffffff81000bac:	e8 b9 4e 01 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>

        pd->make_current();

        asm volatile ("mov %0," EXPAND(PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory");
ffffffff81000bb1:	48 8b 83 a0 00 00 00 	mov    0xa0(%rbx),%rax
ffffffff81000bb8:	48 c7 c4 00 e0 ff bf 	mov    $0xffffffffbfffe000,%rsp
ffffffff81000bbf:	ff e0                	jmpq   *%rax
        ec->make_current();
    }

    if (EXPECT_TRUE (!(s->flags() & Sys_call::DISABLE_BLOCKING)))
ffffffff81000bc1:	41 80 e4 10          	and    $0x10,%r12b
ffffffff81000bc5:	75 0f                	jne    ffffffff81000bd6 <_ZN2Ec8sys_callEv+0x328>
        ec->help (sys_call);
ffffffff81000bc7:	48 c7 c6 ae 08 00 81 	mov    $0xffffffff810008ae,%rsi
ffffffff81000bce:	48 89 df             	mov    %rbx,%rdi
ffffffff81000bd1:	e8 16 ab 00 00       	callq  ffffffff8100b6ec <_ZN2Ec4helpEPFvvE>

    sys_finish<Sys_regs::COM_TIM>();
ffffffff81000bd6:	e8 d5 73 01 00       	callq  ffffffff81017fb0 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE1ELb0EEEvv>
ffffffff81000bdb:	90                   	nop

ffffffff81000bdc <_ZN4Acpi7hw_readEP8Acpi_gas>:
            break;
    }
}

unsigned Acpi::hw_read (Acpi_gas *gas)
{
ffffffff81000bdc:	51                   	push   %rcx
    if (!gas->bits)     // Register not implemented
ffffffff81000bdd:	0f b6 57 01          	movzbl 0x1(%rdi),%edx
ffffffff81000be1:	84 d2                	test   %dl,%dl
ffffffff81000be3:	74 42                	je     ffffffff81000c27 <_ZN4Acpi7hw_readEP8Acpi_gas+0x4b>
        return 0;

    if (gas->asid == Acpi_gas::IO) {
ffffffff81000be5:	0f b6 37             	movzbl (%rdi),%esi
ffffffff81000be8:	40 80 fe 01          	cmp    $0x1,%sil
ffffffff81000bec:	75 2b                	jne    ffffffff81000c19 <_ZN4Acpi7hw_readEP8Acpi_gas+0x3d>
        switch (gas->bits) {
ffffffff81000bee:	80 fa 10             	cmp    $0x10,%dl
ffffffff81000bf1:	74 14                	je     ffffffff81000c07 <_ZN4Acpi7hw_readEP8Acpi_gas+0x2b>
ffffffff81000bf3:	80 fa 20             	cmp    $0x20,%dl
ffffffff81000bf6:	74 1a                	je     ffffffff81000c12 <_ZN4Acpi7hw_readEP8Acpi_gas+0x36>
ffffffff81000bf8:	80 fa 08             	cmp    $0x8,%dl
ffffffff81000bfb:	75 1c                	jne    ffffffff81000c19 <_ZN4Acpi7hw_readEP8Acpi_gas+0x3d>
            case 8:
                return Io::in<uint8>(static_cast<unsigned>(gas->addr));
ffffffff81000bfd:	48 8b 57 04          	mov    0x4(%rdi),%rdx
ffffffff81000c01:	ec                   	in     (%dx),%al
            return val;
ffffffff81000c02:	0f b6 c0             	movzbl %al,%eax
ffffffff81000c05:	eb 22                	jmp    ffffffff81000c29 <_ZN4Acpi7hw_readEP8Acpi_gas+0x4d>
            case 16:
                return Io::in<uint16>(static_cast<unsigned>(gas->addr));
ffffffff81000c07:	48 8b 57 04          	mov    0x4(%rdi),%rdx
        template <typename T>
        ALWAYS_INLINE
        static inline unsigned in (unsigned port)
        {
            T val;
            asm volatile ("in %w1, %0" : "=a" (val) : "Nd" (port));
ffffffff81000c0b:	66 ed                	in     (%dx),%ax
            return val;
ffffffff81000c0d:	0f b7 c0             	movzwl %ax,%eax
ffffffff81000c10:	eb 17                	jmp    ffffffff81000c29 <_ZN4Acpi7hw_readEP8Acpi_gas+0x4d>
            case 32:
                return Io::in<uint32>(static_cast<unsigned>(gas->addr));
ffffffff81000c12:	48 8b 57 04          	mov    0x4(%rdi),%rdx
ffffffff81000c16:	ed                   	in     (%dx),%eax
ffffffff81000c17:	eb 10                	jmp    ffffffff81000c29 <_ZN4Acpi7hw_readEP8Acpi_gas+0x4d>
        }
    }

    Console::panic ("Unimplemented ASID %d bits=%d", gas->asid, gas->bits);
ffffffff81000c19:	48 c7 c7 00 d1 01 81 	mov    $0xffffffff8101d100,%rdi
ffffffff81000c20:	31 c0                	xor    %eax,%eax
ffffffff81000c22:	e8 29 13 00 00       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
}

unsigned Acpi::hw_read (Acpi_gas *gas)
{
    if (!gas->bits)     // Register not implemented
        return 0;
ffffffff81000c27:	31 c0                	xor    %eax,%eax
                return Io::in<uint32>(static_cast<unsigned>(gas->addr));
        }
    }

    Console::panic ("Unimplemented ASID %d bits=%d", gas->asid, gas->bits);
}
ffffffff81000c29:	5a                   	pop    %rdx
ffffffff81000c2a:	c3                   	retq   
ffffffff81000c2b:	90                   	nop

ffffffff81000c2c <_ZN4Acpi4readENS_8RegisterE>:
    trace (TRACE_ACPI, "ACPI: GSI:%#x TMR:%lu", gsi, tmr_msb() + 1);
}

unsigned Acpi::read (Register reg)
{
    switch (reg) {
ffffffff81000c2c:	83 ff 09             	cmp    $0x9,%edi

    trace (TRACE_ACPI, "ACPI: GSI:%#x TMR:%lu", gsi, tmr_msb() + 1);
}

unsigned Acpi::read (Register reg)
{
ffffffff81000c2f:	53                   	push   %rbx
    switch (reg) {
ffffffff81000c30:	77 6b                	ja     ffffffff81000c9d <_ZN4Acpi4readENS_8RegisterE+0x71>
ffffffff81000c32:	89 ff                	mov    %edi,%edi
ffffffff81000c34:	ff 24 fd 50 d2 01 81 	jmpq   *-0x7efe2db0(,%rdi,8)
        case PM1_STS:
            return hw_read (&pm1a_sts) | hw_read (&pm1b_sts);
ffffffff81000c3b:	48 c7 c7 d8 1c 02 81 	mov    $0xffffffff81021cd8,%rdi
ffffffff81000c42:	e8 95 ff ff ff       	callq  ffffffff81000bdc <_ZN4Acpi7hw_readEP8Acpi_gas>
ffffffff81000c47:	48 c7 c7 c8 1c 02 81 	mov    $0xffffffff81021cc8,%rdi
ffffffff81000c4e:	89 c3                	mov    %eax,%ebx
ffffffff81000c50:	eb 15                	jmp    ffffffff81000c67 <_ZN4Acpi4readENS_8RegisterE+0x3b>
        case PM1_ENA:
            return hw_read (&pm1a_ena) | hw_read (&pm1b_ena);
ffffffff81000c52:	48 c7 c7 b8 1c 02 81 	mov    $0xffffffff81021cb8,%rdi
ffffffff81000c59:	e8 7e ff ff ff       	callq  ffffffff81000bdc <_ZN4Acpi7hw_readEP8Acpi_gas>
ffffffff81000c5e:	48 c7 c7 a8 1c 02 81 	mov    $0xffffffff81021ca8,%rdi
ffffffff81000c65:	89 c3                	mov    %eax,%ebx
ffffffff81000c67:	e8 70 ff ff ff       	callq  ffffffff81000bdc <_ZN4Acpi7hw_readEP8Acpi_gas>
ffffffff81000c6c:	09 d8                	or     %ebx,%eax
ffffffff81000c6e:	eb 3d                	jmp    ffffffff81000cad <_ZN4Acpi4readENS_8RegisterE+0x81>
        case PM1_CNT:
            return hw_read (&pm1a_cnt) | hw_read (&pm1b_cnt);
ffffffff81000c70:	48 c7 c7 98 1c 02 81 	mov    $0xffffffff81021c98,%rdi
ffffffff81000c77:	e8 60 ff ff ff       	callq  ffffffff81000bdc <_ZN4Acpi7hw_readEP8Acpi_gas>
ffffffff81000c7c:	48 c7 c7 88 1c 02 81 	mov    $0xffffffff81021c88,%rdi
ffffffff81000c83:	89 c3                	mov    %eax,%ebx
ffffffff81000c85:	eb e0                	jmp    ffffffff81000c67 <_ZN4Acpi4readENS_8RegisterE+0x3b>
        case PM2_CNT:
            return hw_read (&pm2_cnt);
ffffffff81000c87:	48 c7 c7 78 1c 02 81 	mov    $0xffffffff81021c78,%rdi
ffffffff81000c8e:	eb 07                	jmp    ffffffff81000c97 <_ZN4Acpi4readENS_8RegisterE+0x6b>
        case PM_TMR:
            return hw_read (&pm_tmr);
ffffffff81000c90:	48 c7 c7 68 1c 02 81 	mov    $0xffffffff81021c68,%rdi
            Console::panic ("Unimplemented register Acpi::read");
            break;
    }

    return 0;
}
ffffffff81000c97:	5b                   	pop    %rbx
        case PM1_CNT:
            return hw_read (&pm1a_cnt) | hw_read (&pm1b_cnt);
        case PM2_CNT:
            return hw_read (&pm2_cnt);
        case PM_TMR:
            return hw_read (&pm_tmr);
ffffffff81000c98:	e9 3f ff ff ff       	jmpq   ffffffff81000bdc <_ZN4Acpi7hw_readEP8Acpi_gas>
        case RESET:
            break;
        default:
            Console::panic ("Unimplemented register Acpi::read");
ffffffff81000c9d:	48 c7 c7 1e d1 01 81 	mov    $0xffffffff8101d11e,%rdi
ffffffff81000ca4:	31 c0                	xor    %eax,%eax
ffffffff81000ca6:	e8 a5 12 00 00       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
            break;
    }

    return 0;
ffffffff81000cab:	31 c0                	xor    %eax,%eax
}
ffffffff81000cad:	5b                   	pop    %rbx
ffffffff81000cae:	c3                   	retq   
ffffffff81000caf:	90                   	nop

ffffffff81000cb0 <_ZN4Acpi5delayEj>:
unsigned    Acpi::irq, Acpi::gsi;
bool        Acpi_table_madt::sci_overridden = false;

void Acpi::delay (unsigned ms)
{
    unsigned cnt = timer_frequency * ms / 1000;
ffffffff81000cb0:	69 c7 99 9e 36 00    	imul   $0x369e99,%edi,%eax
uint8       Acpi::reset_val;
unsigned    Acpi::irq, Acpi::gsi;
bool        Acpi_table_madt::sci_overridden = false;

void Acpi::delay (unsigned ms)
{
ffffffff81000cb6:	55                   	push   %rbp
ffffffff81000cb7:	53                   	push   %rbx
    unsigned cnt = timer_frequency * ms / 1000;
ffffffff81000cb8:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
uint8       Acpi::reset_val;
unsigned    Acpi::irq, Acpi::gsi;
bool        Acpi_table_madt::sci_overridden = false;

void Acpi::delay (unsigned ms)
{
ffffffff81000cbd:	52                   	push   %rdx
    unsigned cnt = timer_frequency * ms / 1000;
ffffffff81000cbe:	31 d2                	xor    %edx,%edx
    unsigned val = read (PM_TMR);
ffffffff81000cc0:	bf 08 00 00 00       	mov    $0x8,%edi
unsigned    Acpi::irq, Acpi::gsi;
bool        Acpi_table_madt::sci_overridden = false;

void Acpi::delay (unsigned ms)
{
    unsigned cnt = timer_frequency * ms / 1000;
ffffffff81000cc5:	f7 f1                	div    %ecx
ffffffff81000cc7:	89 c3                	mov    %eax,%ebx
    unsigned val = read (PM_TMR);
ffffffff81000cc9:	e8 5e ff ff ff       	callq  ffffffff81000c2c <_ZN4Acpi4readENS_8RegisterE>
ffffffff81000cce:	89 c5                	mov    %eax,%ebp

    while ((read (PM_TMR) - val) % (1UL << 24) < cnt)
ffffffff81000cd0:	bf 08 00 00 00       	mov    $0x8,%edi
ffffffff81000cd5:	e8 52 ff ff ff       	callq  ffffffff81000c2c <_ZN4Acpi4readENS_8RegisterE>
ffffffff81000cda:	29 e8                	sub    %ebp,%eax
ffffffff81000cdc:	89 c2                	mov    %eax,%edx
ffffffff81000cde:	81 e2 ff ff ff 00    	and    $0xffffff,%edx
ffffffff81000ce4:	39 da                	cmp    %ebx,%edx
ffffffff81000ce6:	73 04                	jae    ffffffff81000cec <_ZN4Acpi5delayEj+0x3c>
ffffffff81000ce8:	f3 90                	pause  
ffffffff81000cea:	eb e4                	jmp    ffffffff81000cd0 <_ZN4Acpi5delayEj+0x20>
        pause();
}
ffffffff81000cec:	58                   	pop    %rax
ffffffff81000ced:	5b                   	pop    %rbx
ffffffff81000cee:	5d                   	pop    %rbp
ffffffff81000cef:	c3                   	retq   

ffffffff81000cf0 <_ZN4Acpi8hw_writeEP8Acpi_gasjb>:

    Console::panic ("Unimplemented ASID %d bits=%d", gas->asid, gas->bits);
}

void Acpi::hw_write (Acpi_gas *gas, unsigned val, bool prm)
{
ffffffff81000cf0:	51                   	push   %rcx
    if (!gas->bits)     // Register not implemented
ffffffff81000cf1:	44 8a 47 01          	mov    0x1(%rdi),%r8b
ffffffff81000cf5:	45 84 c0             	test   %r8b,%r8b
ffffffff81000cf8:	74 7b                	je     ffffffff81000d75 <_ZN4Acpi8hw_writeEP8Acpi_gasjb+0x85>
        return;

    if (gas->asid == Acpi_gas::IO) {
ffffffff81000cfa:	44 8a 0f             	mov    (%rdi),%r9b
ffffffff81000cfd:	41 80 f9 01          	cmp    $0x1,%r9b
ffffffff81000d01:	75 59                	jne    ffffffff81000d5c <_ZN4Acpi8hw_writeEP8Acpi_gasjb+0x6c>
        switch (gas->bits) {
ffffffff81000d03:	41 80 f8 20          	cmp    $0x20,%r8b
ffffffff81000d07:	89 f0                	mov    %esi,%eax
ffffffff81000d09:	74 2b                	je     ffffffff81000d36 <_ZN4Acpi8hw_writeEP8Acpi_gasjb+0x46>
ffffffff81000d0b:	77 14                	ja     ffffffff81000d21 <_ZN4Acpi8hw_writeEP8Acpi_gasjb+0x31>
ffffffff81000d0d:	41 80 f8 08          	cmp    $0x8,%r8b
ffffffff81000d11:	74 1c                	je     ffffffff81000d2f <_ZN4Acpi8hw_writeEP8Acpi_gasjb+0x3f>
ffffffff81000d13:	41 80 f8 10          	cmp    $0x10,%r8b
ffffffff81000d17:	75 43                	jne    ffffffff81000d5c <_ZN4Acpi8hw_writeEP8Acpi_gasjb+0x6c>
            case 8:
                Io::out (static_cast<unsigned>(gas->addr), static_cast<uint8>(val));
                return;
            case 16:
                Io::out (static_cast<unsigned>(gas->addr), static_cast<uint16>(val));
ffffffff81000d19:	48 8b 57 04          	mov    0x4(%rdi),%rdx

        template <typename T>
        ALWAYS_INLINE
        static inline void out (unsigned port, T val)
        {
            asm volatile ("out %0, %w1" : : "a" (val), "Nd" (port));
ffffffff81000d1d:	66 ef                	out    %ax,(%dx)
ffffffff81000d1f:	eb 54                	jmp    ffffffff81000d75 <_ZN4Acpi8hw_writeEP8Acpi_gasjb+0x85>
{
    if (!gas->bits)     // Register not implemented
        return;

    if (gas->asid == Acpi_gas::IO) {
        switch (gas->bits) {
ffffffff81000d21:	41 80 f8 40          	cmp    $0x40,%r8b
ffffffff81000d25:	74 16                	je     ffffffff81000d3d <_ZN4Acpi8hw_writeEP8Acpi_gasjb+0x4d>
ffffffff81000d27:	41 80 f8 80          	cmp    $0x80,%r8b
ffffffff81000d2b:	74 10                	je     ffffffff81000d3d <_ZN4Acpi8hw_writeEP8Acpi_gasjb+0x4d>
ffffffff81000d2d:	eb 2d                	jmp    ffffffff81000d5c <_ZN4Acpi8hw_writeEP8Acpi_gasjb+0x6c>
            case 8:
                Io::out (static_cast<unsigned>(gas->addr), static_cast<uint8>(val));
ffffffff81000d2f:	48 8b 57 04          	mov    0x4(%rdi),%rdx
ffffffff81000d33:	ee                   	out    %al,(%dx)
ffffffff81000d34:	eb 3f                	jmp    ffffffff81000d75 <_ZN4Acpi8hw_writeEP8Acpi_gasjb+0x85>
                return;
            case 16:
                Io::out (static_cast<unsigned>(gas->addr), static_cast<uint16>(val));
                return;
            case 32:
                Io::out (static_cast<unsigned>(gas->addr), static_cast<uint32>(val));
ffffffff81000d36:	48 8b 57 04          	mov    0x4(%rdi),%rdx
ffffffff81000d3a:	ef                   	out    %eax,(%dx)
ffffffff81000d3b:	eb 38                	jmp    ffffffff81000d75 <_ZN4Acpi8hw_writeEP8Acpi_gasjb+0x85>
                return;
            case 64:
            case 128:
               if (!prm)
ffffffff81000d3d:	84 d2                	test   %dl,%dl
ffffffff81000d3f:	74 1b                	je     ffffffff81000d5c <_ZN4Acpi8hw_writeEP8Acpi_gasjb+0x6c>
                   break;

               for (unsigned i = 0; i < gas->bits / 32; i++)
ffffffff81000d41:	41 c0 e8 05          	shr    $0x5,%r8b
ffffffff81000d45:	31 c9                	xor    %ecx,%ecx
ffffffff81000d47:	45 0f b6 c0          	movzbl %r8b,%r8d
                   Io::out (static_cast<unsigned>(gas->addr) + i * 4, static_cast<uint32>(val));
ffffffff81000d4b:	48 8b 57 04          	mov    0x4(%rdi),%rdx
ffffffff81000d4f:	8d 14 8a             	lea    (%rdx,%rcx,4),%edx
ffffffff81000d52:	ef                   	out    %eax,(%dx)
            case 64:
            case 128:
               if (!prm)
                   break;

               for (unsigned i = 0; i < gas->bits / 32; i++)
ffffffff81000d53:	ff c1                	inc    %ecx
ffffffff81000d55:	44 39 c1             	cmp    %r8d,%ecx
ffffffff81000d58:	72 f1                	jb     ffffffff81000d4b <_ZN4Acpi8hw_writeEP8Acpi_gasjb+0x5b>
ffffffff81000d5a:	eb 19                	jmp    ffffffff81000d75 <_ZN4Acpi8hw_writeEP8Acpi_gasjb+0x85>
                   Io::out (static_cast<unsigned>(gas->addr) + i * 4, static_cast<uint32>(val));
               return;
        }
    }

    Console::panic ("Unimplemented ASID %d bits=%d prm=%u", gas->asid, gas->bits, prm);
ffffffff81000d5c:	0f b6 ca             	movzbl %dl,%ecx
ffffffff81000d5f:	41 0f b6 f1          	movzbl %r9b,%esi
ffffffff81000d63:	41 0f b6 d0          	movzbl %r8b,%edx
ffffffff81000d67:	48 c7 c7 40 d1 01 81 	mov    $0xffffffff8101d140,%rdi
ffffffff81000d6e:	31 c0                	xor    %eax,%eax
ffffffff81000d70:	e8 db 11 00 00       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
}
ffffffff81000d75:	58                   	pop    %rax
ffffffff81000d76:	c3                   	retq   
ffffffff81000d77:	90                   	nop

ffffffff81000d78 <_ZN4Acpi5clearENS_8RegisterEj>:
    return 0;
}

void Acpi::clear (Register reg, unsigned val)
{
    switch (reg) {
ffffffff81000d78:	83 ff 05             	cmp    $0x5,%edi
ffffffff81000d7b:	74 14                	je     ffffffff81000d91 <_ZN4Acpi5clearENS_8RegisterEj+0x19>
ffffffff81000d7d:	83 ff 07             	cmp    $0x7,%edi
ffffffff81000d80:	74 1d                	je     ffffffff81000d9f <_ZN4Acpi5clearENS_8RegisterEj+0x27>

    return 0;
}

void Acpi::clear (Register reg, unsigned val)
{
ffffffff81000d82:	50                   	push   %rax
            break;
        case GPE1_ENA:
            hw_write (&gpe1_ena, val, true);
            break;
        default:
            Console::panic ("Unimplemented register Acpi::clear");
ffffffff81000d83:	48 c7 c7 65 d1 01 81 	mov    $0xffffffff8101d165,%rdi
ffffffff81000d8a:	31 c0                	xor    %eax,%eax
ffffffff81000d8c:	e8 bf 11 00 00       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

void Acpi::clear (Register reg, unsigned val)
{
    switch (reg) {
        case GPE0_ENA:
            hw_write (&gpe0_ena, val, true);
ffffffff81000d91:	ba 01 00 00 00       	mov    $0x1,%edx
ffffffff81000d96:	48 c7 c7 28 1c 02 81 	mov    $0xffffffff81021c28,%rdi
ffffffff81000d9d:	eb 0c                	jmp    ffffffff81000dab <_ZN4Acpi5clearENS_8RegisterEj+0x33>
            break;
        case GPE1_ENA:
            hw_write (&gpe1_ena, val, true);
ffffffff81000d9f:	ba 01 00 00 00       	mov    $0x1,%edx
ffffffff81000da4:	48 c7 c7 18 1c 02 81 	mov    $0xffffffff81021c18,%rdi
ffffffff81000dab:	e9 40 ff ff ff       	jmpq   ffffffff81000cf0 <_ZN4Acpi8hw_writeEP8Acpi_gasjb>

ffffffff81000db0 <_ZN4Acpi5writeENS_8RegisterEj>:

void Acpi::write (Register reg, unsigned val)
{
    // XXX: Spec requires that certain bits be preserved.

    switch (reg) {
ffffffff81000db0:	83 ff 09             	cmp    $0x9,%edi
            break;
    }
}

void Acpi::write (Register reg, unsigned val)
{
ffffffff81000db3:	53                   	push   %rbx
    // XXX: Spec requires that certain bits be preserved.

    switch (reg) {
ffffffff81000db4:	77 76                	ja     ffffffff81000e2c <_ZN4Acpi5writeENS_8RegisterEj+0x7c>
ffffffff81000db6:	89 ff                	mov    %edi,%edi
ffffffff81000db8:	89 f3                	mov    %esi,%ebx
ffffffff81000dba:	ff 24 fd a0 d2 01 81 	jmpq   *-0x7efe2d60(,%rdi,8)
        case PM1_STS:
            hw_write (&pm1a_sts, val);
ffffffff81000dc1:	31 d2                	xor    %edx,%edx
ffffffff81000dc3:	48 c7 c7 d8 1c 02 81 	mov    $0xffffffff81021cd8,%rdi
ffffffff81000dca:	e8 21 ff ff ff       	callq  ffffffff81000cf0 <_ZN4Acpi8hw_writeEP8Acpi_gasjb>
            hw_write (&pm1b_sts, val);
ffffffff81000dcf:	31 d2                	xor    %edx,%edx
ffffffff81000dd1:	89 de                	mov    %ebx,%esi
ffffffff81000dd3:	48 c7 c7 c8 1c 02 81 	mov    $0xffffffff81021cc8,%rdi
ffffffff81000dda:	eb 4a                	jmp    ffffffff81000e26 <_ZN4Acpi5writeENS_8RegisterEj+0x76>
            break;
        case PM1_ENA:
            hw_write (&pm1a_ena, val);
ffffffff81000ddc:	31 d2                	xor    %edx,%edx
ffffffff81000dde:	48 c7 c7 b8 1c 02 81 	mov    $0xffffffff81021cb8,%rdi
ffffffff81000de5:	e8 06 ff ff ff       	callq  ffffffff81000cf0 <_ZN4Acpi8hw_writeEP8Acpi_gasjb>
            hw_write (&pm1b_ena, val);
ffffffff81000dea:	31 d2                	xor    %edx,%edx
ffffffff81000dec:	89 de                	mov    %ebx,%esi
ffffffff81000dee:	48 c7 c7 a8 1c 02 81 	mov    $0xffffffff81021ca8,%rdi
ffffffff81000df5:	eb 2f                	jmp    ffffffff81000e26 <_ZN4Acpi5writeENS_8RegisterEj+0x76>
            break;
        case PM1_CNT:
            hw_write (&pm1a_cnt, val);
ffffffff81000df7:	31 d2                	xor    %edx,%edx
ffffffff81000df9:	48 c7 c7 98 1c 02 81 	mov    $0xffffffff81021c98,%rdi
ffffffff81000e00:	e8 eb fe ff ff       	callq  ffffffff81000cf0 <_ZN4Acpi8hw_writeEP8Acpi_gasjb>
            hw_write (&pm1b_cnt, val);
ffffffff81000e05:	31 d2                	xor    %edx,%edx
ffffffff81000e07:	89 de                	mov    %ebx,%esi
ffffffff81000e09:	48 c7 c7 88 1c 02 81 	mov    $0xffffffff81021c88,%rdi
ffffffff81000e10:	eb 14                	jmp    ffffffff81000e26 <_ZN4Acpi5writeENS_8RegisterEj+0x76>
            break;
        case PM2_CNT:
            hw_write (&pm2_cnt, val);
ffffffff81000e12:	31 d2                	xor    %edx,%edx
ffffffff81000e14:	48 c7 c7 78 1c 02 81 	mov    $0xffffffff81021c78,%rdi
ffffffff81000e1b:	eb 09                	jmp    ffffffff81000e26 <_ZN4Acpi5writeENS_8RegisterEj+0x76>
            break;
        case PM_TMR:                    // read-only
            break;
        case RESET:
            hw_write (&reset_reg, val);
ffffffff81000e1d:	31 d2                	xor    %edx,%edx
ffffffff81000e1f:	48 c7 c7 58 1c 02 81 	mov    $0xffffffff81021c58,%rdi
            break;
        default:
            Console::panic ("Unimplemented register Acpi::write");
            break;
    }
}
ffffffff81000e26:	5b                   	pop    %rbx
            hw_write (&pm2_cnt, val);
            break;
        case PM_TMR:                    // read-only
            break;
        case RESET:
            hw_write (&reset_reg, val);
ffffffff81000e27:	e9 c4 fe ff ff       	jmpq   ffffffff81000cf0 <_ZN4Acpi8hw_writeEP8Acpi_gasjb>
            break;
        default:
            Console::panic ("Unimplemented register Acpi::write");
ffffffff81000e2c:	48 c7 c7 88 d1 01 81 	mov    $0xffffffff8101d188,%rdi
ffffffff81000e33:	31 c0                	xor    %eax,%eax
ffffffff81000e35:	e8 16 11 00 00       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
            break;
    }
}
ffffffff81000e3a:	5b                   	pop    %rbx
ffffffff81000e3b:	c3                   	retq   

ffffffff81000e3c <_ZN4Acpi5resetEv>:
    return div64 (1000000 * ((tmr_ovf + ((c >> b ^ tmr_ovf) & 1)) * static_cast<uint64>(p) + (c & (p - 1))), timer_frequency, &dummy);
}

void Acpi::reset()
{
    write (RESET, reset_val);
ffffffff81000e3c:	0f b6 35 c9 0d 02 00 	movzbl 0x20dc9(%rip),%esi        # ffffffff81021c0c <_ZN4Acpi9reset_valE>
ffffffff81000e43:	bf 09 00 00 00       	mov    $0x9,%edi
ffffffff81000e48:	e9 63 ff ff ff       	jmpq   ffffffff81000db0 <_ZN4Acpi5writeENS_8RegisterEj>
ffffffff81000e4d:	90                   	nop

ffffffff81000e4e <_ZN4Acpi9interruptEv>:

    Console::panic ("Unimplemented ASID %d bits=%d prm=%u", gas->asid, gas->bits, prm);
}

void Acpi::interrupt()
{
ffffffff81000e4e:	53                   	push   %rbx
    unsigned sts = read (PM1_STS);
ffffffff81000e4f:	31 ff                	xor    %edi,%edi
ffffffff81000e51:	e8 d6 fd ff ff       	callq  ffffffff81000c2c <_ZN4Acpi4readENS_8RegisterE>
    unsigned ena = read (PM1_ENA);
ffffffff81000e56:	bf 01 00 00 00       	mov    $0x1,%edi
    Console::panic ("Unimplemented ASID %d bits=%d prm=%u", gas->asid, gas->bits, prm);
}

void Acpi::interrupt()
{
    unsigned sts = read (PM1_STS);
ffffffff81000e5b:	89 c3                	mov    %eax,%ebx
    unsigned ena = read (PM1_ENA);
ffffffff81000e5d:	e8 ca fd ff ff       	callq  ffffffff81000c2c <_ZN4Acpi4readENS_8RegisterE>

    if (sts & PM1_STS_TMR)
ffffffff81000e62:	f6 c3 01             	test   $0x1,%bl
ffffffff81000e65:	74 06                	je     ffffffff81000e6d <_ZN4Acpi9interruptEv+0x1f>
        tmr_ovf++;
ffffffff81000e67:	ff 05 a7 0d 02 00    	incl   0x20da7(%rip)        # ffffffff81021c14 <_ZN4Acpi7tmr_ovfE>

    unsigned dis = (sts & ena);
ffffffff81000e6d:	89 c1                	mov    %eax,%ecx
ffffffff81000e6f:	21 d9                	and    %ebx,%ecx
    if (dis & PM1_ENA_TMR)
        dis ^= PM1_ENA_TMR;

    if (dis)
ffffffff81000e71:	83 e1 fe             	and    $0xfffffffe,%ecx
ffffffff81000e74:	74 0e                	je     ffffffff81000e84 <_ZN4Acpi9interruptEv+0x36>
       write (PM1_ENA, ena ^ dis);
ffffffff81000e76:	89 ce                	mov    %ecx,%esi
ffffffff81000e78:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff81000e7d:	31 c6                	xor    %eax,%esi
ffffffff81000e7f:	e8 2c ff ff ff       	callq  ffffffff81000db0 <_ZN4Acpi5writeENS_8RegisterEj>

    write (PM1_STS, sts);
ffffffff81000e84:	89 de                	mov    %ebx,%esi
ffffffff81000e86:	31 ff                	xor    %edi,%edi
}
ffffffff81000e88:	5b                   	pop    %rbx
        dis ^= PM1_ENA_TMR;

    if (dis)
       write (PM1_ENA, ena ^ dis);

    write (PM1_STS, sts);
ffffffff81000e89:	e9 22 ff ff ff       	jmpq   ffffffff81000db0 <_ZN4Acpi5writeENS_8RegisterEj>

ffffffff81000e8e <_ZN8Spinlock4lockEv>:
                          "     je 2f;              "
                          "     pause;              "
                          "     movb %1, %b0;       "
                          "     jmp 1b;             "
                          "2:                       "
                          : "+Q" (tmp), "+m" (val) : : "memory");
ffffffff81000e8e:	b8 00 01 00 00       	mov    $0x100,%eax
ffffffff81000e93:	f0 66 0f c1 07       	lock xadd %ax,(%rdi)
ffffffff81000e98:	38 e0                	cmp    %ah,%al
ffffffff81000e9a:	74 06                	je     ffffffff81000ea2 <_ZN8Spinlock4lockEv+0x14>
ffffffff81000e9c:	f3 90                	pause  
ffffffff81000e9e:	8a 07                	mov    (%rdi),%al
ffffffff81000ea0:	eb f6                	jmp    ffffffff81000e98 <_ZN8Spinlock4lockEv+0xa>
ffffffff81000ea2:	c3                   	retq   
ffffffff81000ea3:	90                   	nop

ffffffff81000ea4 <_ZN3Avl6rotateERPS_b>:

Avl *Avl::rotate (Avl *&tree, bool d)
{
    Avl *node;

    node = tree;
ffffffff81000ea4:	48 8b 17             	mov    (%rdi),%rdx
ffffffff81000ea7:	40 0f b6 c6          	movzbl %sil,%eax
ffffffff81000eab:	48 8d 0c c2          	lea    (%rdx,%rax,8),%rcx
    tree = node->lnk[d];
    node->lnk[d] = tree->lnk[!d];
ffffffff81000eaf:	40 88 f0             	mov    %sil,%al
    tree->lnk[!d] = node;

    node->bal = tree->bal = 2;

    return tree->lnk[d];
ffffffff81000eb2:	40 0f b6 f6          	movzbl %sil,%esi
{
    Avl *node;

    node = tree;
    tree = node->lnk[d];
    node->lnk[d] = tree->lnk[!d];
ffffffff81000eb6:	83 f0 01             	xor    $0x1,%eax
Avl *Avl::rotate (Avl *&tree, bool d)
{
    Avl *node;

    node = tree;
    tree = node->lnk[d];
ffffffff81000eb9:	4c 8b 01             	mov    (%rcx),%r8
    node->lnk[d] = tree->lnk[!d];
ffffffff81000ebc:	0f b6 c0             	movzbl %al,%eax
Avl *Avl::rotate (Avl *&tree, bool d)
{
    Avl *node;

    node = tree;
    tree = node->lnk[d];
ffffffff81000ebf:	4c 89 07             	mov    %r8,(%rdi)
    node->lnk[d] = tree->lnk[!d];
ffffffff81000ec2:	4d 8b 04 c0          	mov    (%r8,%rax,8),%r8
ffffffff81000ec6:	4c 89 01             	mov    %r8,(%rcx)
    tree->lnk[!d] = node;
ffffffff81000ec9:	48 8b 0f             	mov    (%rdi),%rcx
ffffffff81000ecc:	48 89 14 c1          	mov    %rdx,(%rcx,%rax,8)

    node->bal = tree->bal = 2;
ffffffff81000ed0:	48 8b 07             	mov    (%rdi),%rax
ffffffff81000ed3:	66 c7 40 10 02 00    	movw   $0x2,0x10(%rax)
ffffffff81000ed9:	66 c7 42 10 02 00    	movw   $0x2,0x10(%rdx)

    return tree->lnk[d];
ffffffff81000edf:	48 8b 07             	mov    (%rdi),%rax
ffffffff81000ee2:	48 8b 04 f0          	mov    (%rax,%rsi,8),%rax
}
ffffffff81000ee6:	c3                   	retq   
ffffffff81000ee7:	90                   	nop

ffffffff81000ee8 <_ZN3Avl6rotateERPS_bj>:

Avl *Avl::rotate (Avl *&tree, bool d, unsigned b)
{
ffffffff81000ee8:	48 83 ec 10          	sub    $0x10,%rsp
    Avl *node[2];

    node[0] = tree;
ffffffff81000eec:	48 8b 07             	mov    (%rdi),%rax
ffffffff81000eef:	40 0f b6 ce          	movzbl %sil,%ecx
    node[1] = node[0]->lnk[d];
ffffffff81000ef3:	44 0f b6 c6          	movzbl %sil,%r8d
    tree = node[1]->lnk[!d];
ffffffff81000ef7:	83 f6 01             	xor    $0x1,%esi
ffffffff81000efa:	44 0f b6 d6          	movzbl %sil,%r10d

    node[0]->lnk[d] = tree->lnk[!d];
ffffffff81000efe:	40 0f b6 f6          	movzbl %sil,%esi
ffffffff81000f02:	4c 8d 0c c8          	lea    (%rax,%rcx,8),%r9

Avl *Avl::rotate (Avl *&tree, bool d, unsigned b)
{
    Avl *node[2];

    node[0] = tree;
ffffffff81000f06:	48 89 04 24          	mov    %rax,(%rsp)
    node[1] = node[0]->lnk[d];
ffffffff81000f0a:	49 8b 09             	mov    (%r9),%rcx
ffffffff81000f0d:	4e 8d 14 d1          	lea    (%rcx,%r10,8),%r10
ffffffff81000f11:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
    tree = node[1]->lnk[!d];
ffffffff81000f16:	4d 8b 1a             	mov    (%r10),%r11
ffffffff81000f19:	4c 89 1f             	mov    %r11,(%rdi)

    node[0]->lnk[d] = tree->lnk[!d];
ffffffff81000f1c:	4d 8b 1c f3          	mov    (%r11,%rsi,8),%r11
ffffffff81000f20:	4d 89 19             	mov    %r11,(%r9)
    node[1]->lnk[!d] = tree->lnk[d];
ffffffff81000f23:	4c 8b 1f             	mov    (%rdi),%r11
ffffffff81000f26:	4d 63 c8             	movslq %r8d,%r9
ffffffff81000f29:	4f 8b 1c cb          	mov    (%r11,%r9,8),%r11
ffffffff81000f2d:	4d 89 1a             	mov    %r11,(%r10)

    tree->lnk[d] = node[1];
ffffffff81000f30:	4c 8b 17             	mov    (%rdi),%r10
ffffffff81000f33:	4b 89 0c ca          	mov    %rcx,(%r10,%r9,8)
    tree->lnk[!d] = node[0];
ffffffff81000f37:	4c 8b 0f             	mov    (%rdi),%r9
ffffffff81000f3a:	49 89 04 f1          	mov    %rax,(%r9,%rsi,8)

    tree->bal = node[0]->bal = node[1]->bal = 2;
ffffffff81000f3e:	48 8b 37             	mov    (%rdi),%rsi
ffffffff81000f41:	66 c7 41 10 02 00    	movw   $0x2,0x10(%rcx)
ffffffff81000f47:	66 c7 40 10 02 00    	movw   $0x2,0x10(%rax)

    if (b == 2)
        return nullptr;
ffffffff81000f4d:	31 c0                	xor    %eax,%eax
    tree->lnk[d] = node[1];
    tree->lnk[!d] = node[0];

    tree->bal = node[0]->bal = node[1]->bal = 2;

    if (b == 2)
ffffffff81000f4f:	83 fa 02             	cmp    $0x2,%edx
    node[1]->lnk[!d] = tree->lnk[d];

    tree->lnk[d] = node[1];
    tree->lnk[!d] = node[0];

    tree->bal = node[0]->bal = node[1]->bal = 2;
ffffffff81000f52:	66 c7 46 10 02 00    	movw   $0x2,0x10(%rsi)

    if (b == 2)
ffffffff81000f58:	74 29                	je     ffffffff81000f83 <_ZN3Avl6rotateERPS_bj+0x9b>
        return nullptr;

    node[b != d]->bal = !b;
ffffffff81000f5a:	85 d2                	test   %edx,%edx
ffffffff81000f5c:	0f 94 c0             	sete   %al
ffffffff81000f5f:	31 c9                	xor    %ecx,%ecx
ffffffff81000f61:	44 39 c2             	cmp    %r8d,%edx

    return node[b == d]->lnk[!b];
ffffffff81000f64:	0f 94 c2             	sete   %dl
    tree->bal = node[0]->bal = node[1]->bal = 2;

    if (b == 2)
        return nullptr;

    node[b != d]->bal = !b;
ffffffff81000f67:	0f 95 c1             	setne  %cl
ffffffff81000f6a:	0f b6 f0             	movzbl %al,%esi

    return node[b == d]->lnk[!b];
ffffffff81000f6d:	0f b6 d2             	movzbl %dl,%edx
    tree->bal = node[0]->bal = node[1]->bal = 2;

    if (b == 2)
        return nullptr;

    node[b != d]->bal = !b;
ffffffff81000f70:	48 8b 0c cc          	mov    (%rsp,%rcx,8),%rcx

    return node[b == d]->lnk[!b];
ffffffff81000f74:	83 e0 01             	and    $0x1,%eax
ffffffff81000f77:	48 8b 14 d4          	mov    (%rsp,%rdx,8),%rdx
    tree->bal = node[0]->bal = node[1]->bal = 2;

    if (b == 2)
        return nullptr;

    node[b != d]->bal = !b;
ffffffff81000f7b:	66 89 71 10          	mov    %si,0x10(%rcx)

    return node[b == d]->lnk[!b];
ffffffff81000f7f:	48 8b 04 c2          	mov    (%rdx,%rax,8),%rax
}
ffffffff81000f83:	48 83 c4 10          	add    $0x10,%rsp
ffffffff81000f87:	c3                   	retq   

ffffffff81000f88 <_ZN3Avl6insertI3MdbEEbPPS_S2_>:

template <typename S>
bool Avl::insert (Avl **tree, Avl *node)
ffffffff81000f88:	53                   	push   %rbx
ffffffff81000f89:	48 89 f8             	mov    %rdi,%rax
ffffffff81000f8c:	48 89 f3             	mov    %rsi,%rbx
{
    Avl **p = tree;

    for (Avl *n; (n = *tree); tree = n->lnk + static_cast<S *>(node)->larger (static_cast<S *>(n))) {
ffffffff81000f8f:	48 8b 10             	mov    (%rax),%rdx
ffffffff81000f92:	48 85 d2             	test   %rdx,%rdx
ffffffff81000f95:	74 3e                	je     ffffffff81000fd5 <_ZN3Avl6insertI3MdbEEbPPS_S2_+0x4d>

        ALWAYS_INLINE
        inline bool larger (Mdb *x) const { return  node_base > x->node_base; }

        ALWAYS_INLINE
        inline bool equal  (Mdb *x) const { return (node_base ^ x->node_base) >> max (node_order, x->node_order) == 0; }
ffffffff81000f97:	4c 8b 42 60          	mov    0x60(%rdx),%r8
ffffffff81000f9b:	4c 8b 4b 60          	mov    0x60(%rbx),%r9
ffffffff81000f9f:	48 8b 4a 68          	mov    0x68(%rdx),%rcx
ffffffff81000fa3:	4c 89 c6             	mov    %r8,%rsi
ffffffff81000fa6:	4c 31 ce             	xor    %r9,%rsi
ffffffff81000fa9:	48 39 4b 68          	cmp    %rcx,0x68(%rbx)
ffffffff81000fad:	48 0f 43 4b 68       	cmovae 0x68(%rbx),%rcx
ffffffff81000fb2:	48 d3 ee             	shr    %cl,%rsi

        if (static_cast<S *>(node)->equal (static_cast<S *>(n)))
ffffffff81000fb5:	48 85 f6             	test   %rsi,%rsi
ffffffff81000fb8:	0f 84 c4 00 00 00    	je     ffffffff81001082 <_ZN3Avl6insertI3MdbEEbPPS_S2_+0xfa>
            return false;

        if (!n->balanced())
ffffffff81000fbe:	66 83 7a 10 02       	cmpw   $0x2,0x10(%rdx)
ffffffff81000fc3:	48 0f 45 f8          	cmovne %rax,%rdi
template <typename S>
bool Avl::insert (Avl **tree, Avl *node)
{
    Avl **p = tree;

    for (Avl *n; (n = *tree); tree = n->lnk + static_cast<S *>(node)->larger (static_cast<S *>(n))) {
ffffffff81000fc7:	31 c0                	xor    %eax,%eax
ffffffff81000fc9:	4d 39 c1             	cmp    %r8,%r9
ffffffff81000fcc:	0f 97 c0             	seta   %al
ffffffff81000fcf:	48 8d 04 c2          	lea    (%rdx,%rax,8),%rax
ffffffff81000fd3:	eb ba                	jmp    ffffffff81000f8f <_ZN3Avl6insertI3MdbEEbPPS_S2_+0x7>

        if (!n->balanced())
            p = tree;
    }

    *tree = node;
ffffffff81000fd5:	48 89 18             	mov    %rbx,(%rax)

    Avl *n = *p;
ffffffff81000fd8:	48 8b 07             	mov    (%rdi),%rax
ffffffff81000fdb:	66 8b 48 10          	mov    0x10(%rax),%cx

    if (!n->balanced()) {
ffffffff81000fdf:	66 83 f9 02          	cmp    $0x2,%cx
ffffffff81000fe3:	74 73                	je     ffffffff81001058 <_ZN3Avl6insertI3MdbEEbPPS_S2_+0xd0>
ffffffff81000fe5:	4c 8b 43 60          	mov    0x60(%rbx),%r8
        mword           node_attr;
        mword     const node_type;
        mword     const node_sub;

        ALWAYS_INLINE
        inline bool larger (Mdb *x) const { return  node_base > x->node_base; }
ffffffff81000fe9:	4c 3b 40 60          	cmp    0x60(%rax),%r8
ffffffff81000fed:	0f 97 c2             	seta   %dl

        bool d1, d2;

        if (n->bal != (d1 = static_cast<S *>(node)->larger (static_cast<S *>(n)))) {
ffffffff81000ff0:	0f b6 f2             	movzbl %dl,%esi
ffffffff81000ff3:	66 39 f1             	cmp    %si,%cx
ffffffff81000ff6:	0f b6 f2             	movzbl %dl,%esi
ffffffff81000ff9:	74 0c                	je     ffffffff81001007 <_ZN3Avl6insertI3MdbEEbPPS_S2_+0x7f>
            n->bal = 2;
ffffffff81000ffb:	66 c7 40 10 02 00    	movw   $0x2,0x10(%rax)
            n = n->lnk[d1];
ffffffff81001001:	48 8b 04 f0          	mov    (%rax,%rsi,8),%rax
ffffffff81001005:	eb 51                	jmp    ffffffff81001058 <_ZN3Avl6insertI3MdbEEbPPS_S2_+0xd0>
        } else if (d1 == (d2 = static_cast<S *>(node)->larger (static_cast<S *>(n->lnk[d1])))) {
ffffffff81001007:	48 63 ce             	movslq %esi,%rcx
ffffffff8100100a:	48 8b 0c c8          	mov    (%rax,%rcx,8),%rcx
ffffffff8100100e:	4c 3b 41 60          	cmp    0x60(%rcx),%r8
ffffffff81001012:	0f 97 c0             	seta   %al
ffffffff81001015:	38 c2                	cmp    %al,%dl
ffffffff81001017:	75 07                	jne    ffffffff81001020 <_ZN3Avl6insertI3MdbEEbPPS_S2_+0x98>
            n = rotate (*p, d1);
ffffffff81001019:	e8 86 fe ff ff       	callq  ffffffff81000ea4 <_ZN3Avl6rotateERPS_b>
ffffffff8100101e:	eb 38                	jmp    ffffffff81001058 <_ZN3Avl6insertI3MdbEEbPPS_S2_+0xd0>
        } else {
            n = n->lnk[d1]->lnk[d2];
ffffffff81001020:	83 e0 01             	and    $0x1,%eax
ffffffff81001023:	48 8b 14 c1          	mov    (%rcx,%rax,8),%rdx

        ALWAYS_INLINE
        inline bool equal  (Mdb *x) const { return (node_base ^ x->node_base) >> max (node_order, x->node_order) == 0; }
ffffffff81001027:	4c 89 c0             	mov    %r8,%rax
ffffffff8100102a:	4c 8b 4a 60          	mov    0x60(%rdx),%r9
ffffffff8100102e:	48 8b 4a 68          	mov    0x68(%rdx),%rcx
            n = rotate (*p, d1, static_cast<S *>(node)->equal (static_cast<S *>(n)) ? 2 : static_cast<S *>(node)->larger (static_cast<S *>(n)));
ffffffff81001032:	ba 02 00 00 00       	mov    $0x2,%edx
ffffffff81001037:	4c 31 c8             	xor    %r9,%rax
ffffffff8100103a:	48 39 4b 68          	cmp    %rcx,0x68(%rbx)
ffffffff8100103e:	48 0f 43 4b 68       	cmovae 0x68(%rbx),%rcx
ffffffff81001043:	48 d3 e8             	shr    %cl,%rax
ffffffff81001046:	48 85 c0             	test   %rax,%rax
ffffffff81001049:	74 08                	je     ffffffff81001053 <_ZN3Avl6insertI3MdbEEbPPS_S2_+0xcb>
        mword           node_attr;
        mword     const node_type;
        mword     const node_sub;

        ALWAYS_INLINE
        inline bool larger (Mdb *x) const { return  node_base > x->node_base; }
ffffffff8100104b:	31 d2                	xor    %edx,%edx
ffffffff8100104d:	4d 39 c8             	cmp    %r9,%r8
ffffffff81001050:	0f 97 c2             	seta   %dl
ffffffff81001053:	e8 90 fe ff ff       	callq  ffffffff81000ee8 <_ZN3Avl6rotateERPS_bj>
        }
    }

    for (bool d; n && !static_cast<S *>(node)->equal (static_cast<S *>(n)); n->bal = d, n = n->lnk[d])
ffffffff81001058:	48 85 c0             	test   %rax,%rax
ffffffff8100105b:	74 29                	je     ffffffff81001086 <_ZN3Avl6insertI3MdbEEbPPS_S2_+0xfe>

        ALWAYS_INLINE
        inline bool equal  (Mdb *x) const { return (node_base ^ x->node_base) >> max (node_order, x->node_order) == 0; }
ffffffff8100105d:	48 8b 70 60          	mov    0x60(%rax),%rsi
ffffffff81001061:	48 8b 7b 60          	mov    0x60(%rbx),%rdi
ffffffff81001065:	48 8b 48 68          	mov    0x68(%rax),%rcx
ffffffff81001069:	48 89 f2             	mov    %rsi,%rdx
ffffffff8100106c:	48 31 fa             	xor    %rdi,%rdx
ffffffff8100106f:	48 39 4b 68          	cmp    %rcx,0x68(%rbx)
ffffffff81001073:	48 0f 43 4b 68       	cmovae 0x68(%rbx),%rcx
ffffffff81001078:	48 d3 ea             	shr    %cl,%rdx
ffffffff8100107b:	48 85 d2             	test   %rdx,%rdx
ffffffff8100107e:	75 0a                	jne    ffffffff8100108a <_ZN3Avl6insertI3MdbEEbPPS_S2_+0x102>
ffffffff81001080:	eb 04                	jmp    ffffffff81001086 <_ZN3Avl6insertI3MdbEEbPPS_S2_+0xfe>
    Avl **p = tree;

    for (Avl *n; (n = *tree); tree = n->lnk + static_cast<S *>(node)->larger (static_cast<S *>(n))) {

        if (static_cast<S *>(node)->equal (static_cast<S *>(n)))
            return false;
ffffffff81001082:	31 c0                	xor    %eax,%eax
ffffffff81001084:	eb 1a                	jmp    ffffffff810010a0 <_ZN3Avl6insertI3MdbEEbPPS_S2_+0x118>
    }

    for (bool d; n && !static_cast<S *>(node)->equal (static_cast<S *>(n)); n->bal = d, n = n->lnk[d])
        d = static_cast<S *>(node)->larger (static_cast<S *>(n));

    return true;
ffffffff81001086:	b0 01                	mov    $0x1,%al
ffffffff81001088:	eb 16                	jmp    ffffffff810010a0 <_ZN3Avl6insertI3MdbEEbPPS_S2_+0x118>
        mword           node_attr;
        mword     const node_type;
        mword     const node_sub;

        ALWAYS_INLINE
        inline bool larger (Mdb *x) const { return  node_base > x->node_base; }
ffffffff8100108a:	48 39 f7             	cmp    %rsi,%rdi
ffffffff8100108d:	0f 97 c2             	seta   %dl
            n = n->lnk[d1]->lnk[d2];
            n = rotate (*p, d1, static_cast<S *>(node)->equal (static_cast<S *>(n)) ? 2 : static_cast<S *>(node)->larger (static_cast<S *>(n)));
        }
    }

    for (bool d; n && !static_cast<S *>(node)->equal (static_cast<S *>(n)); n->bal = d, n = n->lnk[d])
ffffffff81001090:	0f b6 ca             	movzbl %dl,%ecx
ffffffff81001093:	83 e2 01             	and    $0x1,%edx
ffffffff81001096:	66 89 48 10          	mov    %cx,0x10(%rax)
ffffffff8100109a:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
ffffffff8100109e:	eb b8                	jmp    ffffffff81001058 <_ZN3Avl6insertI3MdbEEbPPS_S2_+0xd0>
        d = static_cast<S *>(node)->larger (static_cast<S *>(n));

    return true;
}
ffffffff810010a0:	5b                   	pop    %rbx
ffffffff810010a1:	c3                   	retq   

ffffffff810010a2 <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE>:

template <typename S>
bool Avl::remove (Avl **tree, Avl *node, State state)
ffffffff810010a2:	41 57                	push   %r15
ffffffff810010a4:	41 56                	push   %r14
ffffffff810010a6:	41 55                	push   %r13
ffffffff810010a8:	41 54                	push   %r12
ffffffff810010aa:	55                   	push   %rbp
ffffffff810010ab:	53                   	push   %rbx
ffffffff810010ac:	48 89 f5             	mov    %rsi,%rbp
ffffffff810010af:	48 83 ec 18          	sub    $0x18,%rsp
{
    Avl **p = tree, **item = nullptr;
    bool d = false;

    if (node->sta == state)
ffffffff810010b3:	0f b7 46 12          	movzwl 0x12(%rsi),%eax

    return true;
}

template <typename S>
bool Avl::remove (Avl **tree, Avl *node, State state)
ffffffff810010b7:	89 54 24 08          	mov    %edx,0x8(%rsp)
{
    Avl **p = tree, **item = nullptr;
    bool d = false;

    if (node->sta == state)
ffffffff810010bb:	3b 44 24 08          	cmp    0x8(%rsp),%eax
ffffffff810010bf:	89 c2                	mov    %eax,%edx
ffffffff810010c1:	0f 94 c1             	sete   %cl
        return false;

    if (node->sta == STALE)
ffffffff810010c4:	66 83 f8 03          	cmp    $0x3,%ax
ffffffff810010c8:	0f 94 c0             	sete   %al
ffffffff810010cb:	08 c8                	or     %cl,%al
ffffffff810010cd:	0f 85 b7 01 00 00    	jne    ffffffff8100128a <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0x1e8>
        return false;

    if (node->sta == KIM) {
ffffffff810010d3:	66 83 fa 02          	cmp    $0x2,%dx
ffffffff810010d7:	74 0d                	je     ffffffff810010e6 <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0x44>
ffffffff810010d9:	49 89 fd             	mov    %rdi,%r13
ffffffff810010dc:	49 89 fe             	mov    %rdi,%r14
ffffffff810010df:	31 db                	xor    %ebx,%ebx
ffffffff810010e1:	45 31 ff             	xor    %r15d,%r15d
ffffffff810010e4:	eb 71                	jmp    ffffffff81001157 <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0xb5>
        node->sta = STALE;
ffffffff810010e6:	66 c7 46 12 03 00    	movw   $0x3,0x12(%rsi)
ffffffff810010ec:	e9 95 01 00 00       	jmpq   ffffffff81001286 <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0x1e4>

        ALWAYS_INLINE
        inline bool equal  (Mdb *x) const { return (node_base ^ x->node_base) >> max (node_order, x->node_order) == 0; }
ffffffff810010f1:	48 8b 7a 60          	mov    0x60(%rdx),%rdi
ffffffff810010f5:	4c 8b 55 60          	mov    0x60(%rbp),%r10
ffffffff810010f9:	48 8b 4a 68          	mov    0x68(%rdx),%rcx
ffffffff810010fd:	48 89 fe             	mov    %rdi,%rsi
ffffffff81001100:	4c 31 d6             	xor    %r10,%rsi
ffffffff81001103:	48 39 4d 68          	cmp    %rcx,0x68(%rbp)
ffffffff81001107:	48 0f 43 4d 68       	cmovae 0x68(%rbp),%rcx
ffffffff8100110c:	48 d3 ee             	shr    %cl,%rsi
        return true;
    }

    for (Avl *n; (n = *tree); tree = n->lnk + d) {

        if (static_cast<S *>(node)->equal (static_cast<S *>(n)))
ffffffff8100110f:	48 85 f6             	test   %rsi,%rsi
ffffffff81001112:	4d 0f 44 fd          	cmove  %r13,%r15
        mword           node_attr;
        mword     const node_type;
        mword     const node_sub;

        ALWAYS_INLINE
        inline bool larger (Mdb *x) const { return  node_base > x->node_base; }
ffffffff81001116:	49 39 fa             	cmp    %rdi,%r10
ffffffff81001119:	0f 97 c3             	seta   %bl
            item = tree;

        d = static_cast<S *>(node)->larger (static_cast<S *>(n));

        if (!n->lnk[d])
ffffffff8100111c:	48 89 d9             	mov    %rbx,%rcx
ffffffff8100111f:	83 e1 01             	and    $0x1,%ecx
ffffffff81001122:	48 83 3c ca 00       	cmpq   $0x0,(%rdx,%rcx,8)
ffffffff81001127:	74 3e                	je     ffffffff81001167 <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0xc5>
ffffffff81001129:	66 8b 72 10          	mov    0x10(%rdx),%si
            break;

        if (n->balanced() || (n->bal == !d && n->lnk[!d]->balanced()))
ffffffff8100112d:	66 83 fe 02          	cmp    $0x2,%si
ffffffff81001131:	74 2f                	je     ffffffff81001162 <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0xc0>
ffffffff81001133:	88 d9                	mov    %bl,%cl
ffffffff81001135:	83 f1 01             	xor    $0x1,%ecx
ffffffff81001138:	0f b6 f9             	movzbl %cl,%edi
ffffffff8100113b:	66 39 fe             	cmp    %di,%si
ffffffff8100113e:	75 10                	jne    ffffffff81001150 <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0xae>
ffffffff81001140:	83 e1 01             	and    $0x1,%ecx
ffffffff81001143:	48 8b 0c ca          	mov    (%rdx,%rcx,8),%rcx
ffffffff81001147:	66 83 79 10 02       	cmpw   $0x2,0x10(%rcx)
ffffffff8100114c:	4d 0f 44 f5          	cmove  %r13,%r14
    if (node->sta == KIM) {
        node->sta = STALE;
        return true;
    }

    for (Avl *n; (n = *tree); tree = n->lnk + d) {
ffffffff81001150:	0f b6 cb             	movzbl %bl,%ecx
ffffffff81001153:	4c 8d 2c ca          	lea    (%rdx,%rcx,8),%r13
ffffffff81001157:	49 8b 55 00          	mov    0x0(%r13),%rdx
ffffffff8100115b:	48 85 d2             	test   %rdx,%rdx
ffffffff8100115e:	75 91                	jne    ffffffff810010f1 <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0x4f>
ffffffff81001160:	eb 05                	jmp    ffffffff81001167 <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0xc5>
ffffffff81001162:	4d 89 ee             	mov    %r13,%r14
ffffffff81001165:	eb e9                	jmp    ffffffff81001150 <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0xae>

        if (n->balanced() || (n->bal == !d && n->lnk[!d]->balanced()))
            p = tree;
    }

    if (!item)
ffffffff81001167:	4d 85 ff             	test   %r15,%r15
ffffffff8100116a:	0f 84 1c 01 00 00    	je     ffffffff8100128c <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0x1ea>
        return false;

    for (Avl *n; (n = *p); p = n->lnk + d) {
ffffffff81001170:	4d 8b 26             	mov    (%r14),%r12
ffffffff81001173:	4d 85 e4             	test   %r12,%r12
ffffffff81001176:	0f 84 d7 00 00 00    	je     ffffffff81001253 <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0x1b1>
ffffffff8100117c:	49 8b 44 24 60       	mov    0x60(%r12),%rax
ffffffff81001181:	48 39 45 60          	cmp    %rax,0x60(%rbp)
ffffffff81001185:	0f 97 c3             	seta   %bl

        d = static_cast<S *>(node)->larger (static_cast <S *>(n));

        if (!n->lnk[d])
ffffffff81001188:	0f b6 fb             	movzbl %bl,%edi
ffffffff8100118b:	49 83 3c fc 00       	cmpq   $0x0,(%r12,%rdi,8)
ffffffff81001190:	0f 84 bd 00 00 00    	je     ffffffff81001253 <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0x1b1>
ffffffff81001196:	66 41 8b 44 24 10    	mov    0x10(%r12),%ax
ffffffff8100119c:	0f b6 f3             	movzbl %bl,%esi
ffffffff8100119f:	48 89 34 24          	mov    %rsi,(%rsp)
            break;

        if (n->balanced())
ffffffff810011a3:	66 83 f8 02          	cmp    $0x2,%ax
ffffffff810011a7:	75 13                	jne    ffffffff810011bc <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0x11a>
            n->bal = !d;
ffffffff810011a9:	88 d8                	mov    %bl,%al
ffffffff810011ab:	83 f0 01             	xor    $0x1,%eax
ffffffff810011ae:	0f b6 c0             	movzbl %al,%eax
ffffffff810011b1:	66 41 89 44 24 10    	mov    %ax,0x10(%r12)
ffffffff810011b7:	e9 8a 00 00 00       	jmpq   ffffffff81001246 <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0x1a4>

        else if (n->bal == d)
ffffffff810011bc:	0f b6 cb             	movzbl %bl,%ecx
ffffffff810011bf:	66 39 c8             	cmp    %cx,%ax
ffffffff810011c2:	75 0a                	jne    ffffffff810011ce <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0x12c>
            n->bal = 2;
ffffffff810011c4:	66 41 c7 44 24 10 02 	movw   $0x2,0x10(%r12)
ffffffff810011cb:	00 
ffffffff810011cc:	eb 78                	jmp    ffffffff81001246 <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0x1a4>

        else {
            unsigned b = n->lnk[!d]->bal;
ffffffff810011ce:	88 da                	mov    %bl,%dl
ffffffff810011d0:	83 f2 01             	xor    $0x1,%edx
ffffffff810011d3:	0f b6 c2             	movzbl %dl,%eax
ffffffff810011d6:	48 89 c6             	mov    %rax,%rsi
ffffffff810011d9:	49 8b 04 c4          	mov    (%r12,%rax,8),%rax
ffffffff810011dd:	44 0f b7 50 10       	movzwl 0x10(%rax),%r10d

            if (b == d)
ffffffff810011e2:	41 39 fa             	cmp    %edi,%r10d
ffffffff810011e5:	75 12                	jne    ffffffff810011f9 <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0x157>
                rotate (*p, !d, n->lnk[!d]->lnk[d]->bal);
ffffffff810011e7:	48 8b 04 f8          	mov    (%rax,%rdi,8),%rax
ffffffff810011eb:	4c 89 f7             	mov    %r14,%rdi
ffffffff810011ee:	0f b7 50 10          	movzwl 0x10(%rax),%edx
ffffffff810011f2:	e8 f1 fc ff ff       	callq  ffffffff81000ee8 <_ZN3Avl6rotateERPS_bj>
ffffffff810011f7:	eb 36                	jmp    ffffffff8100122f <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0x18d>
            else {
                rotate (*p, !d);
ffffffff810011f9:	4c 89 f7             	mov    %r14,%rdi
ffffffff810011fc:	44 89 54 24 14       	mov    %r10d,0x14(%rsp)
ffffffff81001201:	88 54 24 13          	mov    %dl,0x13(%rsp)
ffffffff81001205:	89 4c 24 0c          	mov    %ecx,0xc(%rsp)
ffffffff81001209:	e8 96 fc ff ff       	callq  ffffffff81000ea4 <_ZN3Avl6rotateERPS_b>

                if (b == 2) {
ffffffff8100120e:	44 8b 54 24 14       	mov    0x14(%rsp),%r10d
ffffffff81001213:	8b 4c 24 0c          	mov    0xc(%rsp),%ecx
ffffffff81001217:	0f b6 54 24 13       	movzbl 0x13(%rsp),%edx
ffffffff8100121c:	41 83 fa 02          	cmp    $0x2,%r10d
ffffffff81001220:	75 0d                	jne    ffffffff8100122f <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0x18d>
                   n->bal = !d;
ffffffff81001222:	66 41 89 54 24 10    	mov    %dx,0x10(%r12)
                   (*p)->bal = d;
ffffffff81001228:	49 8b 06             	mov    (%r14),%rax
ffffffff8100122b:	66 89 48 10          	mov    %cx,0x10(%rax)
                }
            }

            if (n == node)
ffffffff8100122f:	49 39 ec             	cmp    %rbp,%r12
ffffffff81001232:	75 12                	jne    ffffffff81001246 <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0x1a4>
                item = (*p)->lnk + d;
ffffffff81001234:	48 8b 04 24          	mov    (%rsp),%rax
ffffffff81001238:	4c 8d 0c c5 00 00 00 	lea    0x0(,%rax,8),%r9
ffffffff8100123f:	00 
ffffffff81001240:	4d 03 0e             	add    (%r14),%r9
ffffffff81001243:	4d 89 cf             	mov    %r9,%r15
    }

    if (!item)
        return false;

    for (Avl *n; (n = *p); p = n->lnk + d) {
ffffffff81001246:	48 8b 04 24          	mov    (%rsp),%rax
ffffffff8100124a:	4d 8d 34 c4          	lea    (%r12,%rax,8),%r14
ffffffff8100124e:	e9 1d ff ff ff       	jmpq   ffffffff81001170 <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0xce>
            if (n == node)
                item = (*p)->lnk + d;
        }
    }

    Avl *n = *tree;
ffffffff81001253:	49 8b 45 00          	mov    0x0(%r13),%rax

    *item = n;
    *tree = n->lnk[!d];
ffffffff81001257:	83 f3 01             	xor    $0x1,%ebx
ffffffff8100125a:	83 e3 01             	and    $0x1,%ebx
        }
    }

    Avl *n = *tree;

    *item = n;
ffffffff8100125d:	49 89 07             	mov    %rax,(%r15)
    *tree = n->lnk[!d];
ffffffff81001260:	48 8b 14 d8          	mov    (%rax,%rbx,8),%rdx
ffffffff81001264:	49 89 55 00          	mov    %rdx,0x0(%r13)
    n->lnk[0] = node->lnk[0];
ffffffff81001268:	48 8b 55 00          	mov    0x0(%rbp),%rdx
ffffffff8100126c:	48 89 10             	mov    %rdx,(%rax)
    n->lnk[1] = node->lnk[1];
ffffffff8100126f:	48 8b 55 08          	mov    0x8(%rbp),%rdx
ffffffff81001273:	48 89 50 08          	mov    %rdx,0x8(%rax)
    n->bal    = node->bal;
ffffffff81001277:	8b 55 10             	mov    0x10(%rbp),%edx
ffffffff8100127a:	66 89 50 10          	mov    %dx,0x10(%rax)

    node->sta = state;
ffffffff8100127e:	8b 44 24 08          	mov    0x8(%rsp),%eax
ffffffff81001282:	66 89 45 12          	mov    %ax,0x12(%rbp)

    return true;
ffffffff81001286:	b0 01                	mov    $0x1,%al
ffffffff81001288:	eb 02                	jmp    ffffffff8100128c <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE+0x1ea>

    if (node->sta == state)
        return false;

    if (node->sta == STALE)
        return false;
ffffffff8100128a:	31 c0                	xor    %eax,%eax
    n->bal    = node->bal;

    node->sta = state;

    return true;
}
ffffffff8100128c:	48 83 c4 18          	add    $0x18,%rsp
ffffffff81001290:	5b                   	pop    %rbx
ffffffff81001291:	5d                   	pop    %rbp
ffffffff81001292:	41 5c                	pop    %r12
ffffffff81001294:	41 5d                	pop    %r13
ffffffff81001296:	41 5e                	pop    %r14
ffffffff81001298:	41 5f                	pop    %r15
ffffffff8100129a:	c3                   	retq   

ffffffff8100129b <bootstrap>:
#include "hip.hpp"
#include "msr.hpp"

extern "C" NORETURN
void bootstrap()
{
ffffffff8100129b:	55                   	push   %rbp
ffffffff8100129c:	53                   	push   %rbx
ffffffff8100129d:	57                   	push   %rdi
    static mword barrier;

    Cpu::init();
ffffffff8100129e:	e8 37 16 00 00       	callq  ffffffff810028da <_ZN3Cpu4initEv>

    static void idl_handler();

    ALWAYS_INLINE
    static inline void *operator new (size_t, Quota &quota) {
        return cache.alloc(quota);
ffffffff810012a3:	48 c7 c6 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rsi
ffffffff810012aa:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi

    // Create idle EC
    Ec::current = new (Pd::kern.quota) Ec (Pd::current = &Pd::kern, Ec::idle, Cpu::id);
ffffffff810012b1:	48 c7 05 54 dd ff 3e 	movq   $0xffffffff81163ca0,0x3effdd54(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff810012b8:	a0 3c 16 81 
ffffffff810012bc:	e8 6d 46 01 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff810012c1:	8b 0d 3d dd ff 3e    	mov    0x3effdd3d(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff810012c7:	48 89 c3             	mov    %rax,%rbx
ffffffff810012ca:	48 c7 c2 4c 4a 00 81 	mov    $0xffffffff81004a4c,%rdx
ffffffff810012d1:	48 c7 c6 a0 3c 16 81 	mov    $0xffffffff81163ca0,%rsi
ffffffff810012d8:	48 89 c7             	mov    %rax,%rdi
ffffffff810012db:	e8 44 26 00 00       	callq  ffffffff81003924 <_ZN2EcC1EP2PdPFvvEj>
ffffffff810012e0:	48 89 1d 21 dd ff 3e 	mov    %rbx,0x3effdd21(%rip)        # ffffffffbffff008 <_ZN2Ec7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff810012e7:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff810012ed:	85 c0                	test   %eax,%eax
ffffffff810012ef:	74 0d                	je     ffffffff810012fe <bootstrap+0x63>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff810012f1:	8d 50 01             	lea    0x1(%rax),%edx
ffffffff810012f4:	f0 0f b1 93 8c 00 00 	lock cmpxchg %edx,0x8c(%rbx)
ffffffff810012fb:	00 
ffffffff810012fc:	75 e9                	jne    ffffffff810012e7 <bootstrap+0x4c>
    Ec::current->add_ref();
    Pd::current->add_ref();
ffffffff810012fe:	48 8b 15 0b dd ff 3e 	mov    0x3effdd0b(%rip),%rdx        # ffffffffbffff010 <_ZN2Pd7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff81001305:	8b 82 8c 00 00 00    	mov    0x8c(%rdx),%eax
ffffffff8100130b:	85 c0                	test   %eax,%eax
ffffffff8100130d:	74 0d                	je     ffffffff8100131c <bootstrap+0x81>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8100130f:	8d 48 01             	lea    0x1(%rax),%ecx
ffffffff81001312:	f0 0f b1 8a 8c 00 00 	lock cmpxchg %ecx,0x8c(%rdx)
ffffffff81001319:	00 
ffffffff8100131a:	75 e9                	jne    ffffffff81001305 <bootstrap+0x6a>

        NORETURN
        static void schedule (bool = false, bool = true);

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
ffffffff8100131c:	48 c7 c6 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rsi
ffffffff81001323:	48 c7 c7 40 40 16 81 	mov    $0xffffffff81164040,%rdi
ffffffff8100132a:	e8 ff 45 01 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
    Space_obj::insert_root (Pd::kern.quota, Sc::current = new (Pd::kern.quota) Sc (&Pd::kern, Cpu::id, Ec::current));
ffffffff8100132f:	8b 15 cf dc ff 3e    	mov    0x3effdccf(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81001335:	48 8b 0d cc dc ff 3e 	mov    0x3effdccc(%rip),%rcx        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100133c:	48 89 c3             	mov    %rax,%rbx
ffffffff8100133f:	48 89 c7             	mov    %rax,%rdi
ffffffff81001342:	48 c7 c6 a0 3c 16 81 	mov    $0xffffffff81163ca0,%rsi
ffffffff81001349:	e8 ee 31 01 00       	callq  ffffffff8101453c <_ZN2ScC1EP2PdmP2Ec>
ffffffff8100134e:	48 89 de             	mov    %rbx,%rsi
ffffffff81001351:	48 c7 c7 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rdi
ffffffff81001358:	48 89 1d b9 dc ff 3e 	mov    %rbx,0x3effdcb9(%rip)        # ffffffffbffff018 <_ZN2Sc7currentE>
ffffffff8100135f:	e8 06 57 01 00       	callq  ffffffff81016a6a <_ZN9Space_obj11insert_rootER5QuotaP7Kobject>
    Sc::current->add_ref();
ffffffff81001364:	48 8b 15 ad dc ff 3e 	mov    0x3effdcad(%rip),%rdx        # ffffffffbffff018 <_ZN2Sc7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100136b:	8b 82 8c 00 00 00    	mov    0x8c(%rdx),%eax
ffffffff81001371:	83 f8 ff             	cmp    $0xffffffff,%eax
ffffffff81001374:	74 0d                	je     ffffffff81001383 <bootstrap+0xe8>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff81001376:	8d 48 01             	lea    0x1(%rax),%ecx
ffffffff81001379:	f0 0f b1 8a 8c 00 00 	lock cmpxchg %ecx,0x8c(%rdx)
ffffffff81001380:	00 
ffffffff81001381:	75 e8                	jne    ffffffff8100136b <bootstrap+0xd0>

        template <typename T>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }
ffffffff81001383:	f0 48 ff 05 95 09 02 	lock incq 0x20995(%rip)        # ffffffff81021d20 <_ZZ9bootstrapE7barrier>
ffffffff8100138a:	00 

    // Barrier: wait for all ECs to arrive here
    for (Atomic::add (barrier, 1UL); barrier != Cpu::online; pause()) ;
ffffffff8100138b:	8b 05 af 0c 16 00    	mov    0x160caf(%rip),%eax        # ffffffff81162040 <_ZN3Cpu6onlineE>
ffffffff81001391:	48 39 05 88 09 02 00 	cmp    %rax,0x20988(%rip)        # ffffffff81021d20 <_ZZ9bootstrapE7barrier>
ffffffff81001398:	74 04                	je     ffffffff8100139e <bootstrap+0x103>
ffffffff8100139a:	f3 90                	pause  
ffffffff8100139c:	eb ed                	jmp    ffffffff8100138b <bootstrap+0xf0>

        template <typename T>
        ALWAYS_INLINE
        static inline void write (Register msr, T val)
        {
            asm volatile ("wrmsr" : : "a" (static_cast<mword>(val)), "d" (static_cast<mword>(static_cast<uint64>(val) >> 32)), "c" (msr));
ffffffff8100139e:	31 c0                	xor    %eax,%eax
ffffffff810013a0:	b9 10 00 00 00       	mov    $0x10,%ecx
ffffffff810013a5:	48 89 c2             	mov    %rax,%rdx
ffffffff810013a8:	0f 30                	wrmsr  

    Msr::write<uint64>(Msr::IA32_TSC, 0);

    // Create root task
    if (Cpu::bsp) {
ffffffff810013aa:	80 3d 80 e3 ff 3e 00 	cmpb   $0x0,0x3effe380(%rip)        # ffffffffbffff731 <_ZN3Cpu3bspE>
ffffffff810013b1:	0f 84 9f 00 00 00    	je     ffffffff81001456 <bootstrap+0x1bb>
        Hip::add_check();
ffffffff810013b7:	e8 76 6b 00 00       	callq  ffffffff81007f32 <_ZN3Hip9add_checkEv>
ffffffff810013bc:	48 c7 c6 68 3c 16 81 	mov    $0xffffffff81163c68,%rsi
ffffffff810013c3:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff810013ca:	e8 5f 45 01 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
        Ec *root_ec = new (Pd::root.quota) Ec (&Pd::root, NUM_EXC + 1, &Pd::root, Ec::root_invoke, Cpu::id, 0, USER_ADDR - 2 * PAGE_SIZE, 0, nullptr);
ffffffff810013cf:	44 8b 0d 2e dc ff 3e 	mov    0x3effdc2e(%rip),%r9d        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff810013d6:	48 89 c5             	mov    %rax,%rbp
ffffffff810013d9:	48 b8 00 d0 ff ff ff 	movabs $0x7fffffffd000,%rax
ffffffff810013e0:	7f 00 00 
ffffffff810013e3:	6a 00                	pushq  $0x0
ffffffff810013e5:	48 c7 c1 60 39 16 81 	mov    $0xffffffff81163960,%rcx
ffffffff810013ec:	6a 00                	pushq  $0x0
ffffffff810013ee:	50                   	push   %rax
ffffffff810013ef:	6a 00                	pushq  $0x0
ffffffff810013f1:	ba 21 00 00 00       	mov    $0x21,%edx
ffffffff810013f6:	48 89 ce             	mov    %rcx,%rsi
ffffffff810013f9:	49 c7 c0 4c 4d 00 81 	mov    $0xffffffff81004d4c,%r8
ffffffff81001400:	48 89 ef             	mov    %rbp,%rdi
ffffffff81001403:	e8 c2 26 00 00       	callq  ffffffff81003aca <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt>
ffffffff81001408:	48 83 c4 20          	add    $0x20,%rsp
ffffffff8100140c:	48 c7 c6 68 3c 16 81 	mov    $0xffffffff81163c68,%rsi
ffffffff81001413:	48 c7 c7 40 40 16 81 	mov    $0xffffffff81164040,%rdi
ffffffff8100141a:	e8 0f 45 01 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
        Sc *root_sc = new (Pd::root.quota) Sc (&Pd::root, NUM_EXC + 2, root_ec, Cpu::id, Sc::default_prio, Sc::default_quantum);
ffffffff8100141f:	44 8b 05 de db ff 3e 	mov    0x3effdbde(%rip),%r8d        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81001426:	52                   	push   %rdx
ffffffff81001427:	48 89 c3             	mov    %rax,%rbx
ffffffff8100142a:	68 10 27 00 00       	pushq  $0x2710
ffffffff8100142f:	48 89 e9             	mov    %rbp,%rcx
ffffffff81001432:	48 c7 c6 60 39 16 81 	mov    $0xffffffff81163960,%rsi
ffffffff81001439:	48 89 c7             	mov    %rax,%rdi
ffffffff8100143c:	41 b9 01 00 00 00    	mov    $0x1,%r9d
ffffffff81001442:	ba 22 00 00 00       	mov    $0x22,%edx
ffffffff81001447:	e8 b2 31 01 00       	callq  ffffffff810145fe <_ZN2ScC1EP2PdmP2Ecjjj>
        root_sc->remote_enqueue();
ffffffff8100144c:	48 89 df             	mov    %rbx,%rdi
ffffffff8100144f:	e8 0c 36 01 00       	callq  ffffffff81014a60 <_ZN2Sc14remote_enqueueEv>
ffffffff81001454:	59                   	pop    %rcx
ffffffff81001455:	5e                   	pop    %rsi
    }

    Sc::schedule();
ffffffff81001456:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff8100145b:	31 ff                	xor    %edi,%edi
ffffffff8100145d:	e8 52 39 01 00       	callq  ffffffff81014db4 <_ZN2Sc8scheduleEbb>

ffffffff81001462 <_ZN5Quota5allocEm>:

        static Quota init;

        Quota () : used(0), over(0), upli(0), notr(0) { }

        void alloc(mword p)
ffffffff81001462:	41 54                	push   %r12
ffffffff81001464:	49 89 f4             	mov    %rsi,%r12
ffffffff81001467:	55                   	push   %rbp
ffffffff81001468:	48 89 fd             	mov    %rdi,%rbp
ffffffff8100146b:	53                   	push   %rbx

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff8100146c:	9c                   	pushfq 
ffffffff8100146d:	58                   	pop    %rax
            return flags & 0x200;
ffffffff8100146e:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff81001472:	88 c3                	mov    %al,%bl
ffffffff81001474:	80 e3 01             	and    $0x1,%bl
ffffffff81001477:	74 2d                	je     ffffffff810014a6 <_ZN5Quota5allocEm+0x44>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81001479:	80 3d b0 e2 ff 3e 00 	cmpb   $0x0,0x3effe2b0(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81001480:	75 1c                	jne    ffffffff8100149e <_ZN5Quota5allocEm+0x3c>
ffffffff81001482:	49 c7 c0 a0 d6 01 81 	mov    $0xffffffff8101d6a0,%r8
ffffffff81001489:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff8100148e:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81001495:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff8100149c:	eb 3e                	jmp    ffffffff810014dc <_ZN5Quota5allocEm+0x7a>

            asm volatile ("cli" : : : "memory");
ffffffff8100149e:	fa                   	cli    
            preemption = false;
ffffffff8100149f:	c6 05 8a e2 ff 3e 00 	movb   $0x0,0x3effe28a(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff810014a6:	48 89 ef             	mov    %rbp,%rdi
ffffffff810014a9:	e8 e0 f9 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
        {
            Lock_guard <Spinlock> guard (lock);
            used += p;
ffffffff810014ae:	4c 01 65 08          	add    %r12,0x8(%rbp)
        }

        ALWAYS_INLINE
        inline void unlock()
        {
            asm volatile ("incb %0" : "=m" (val) : : "memory");
ffffffff810014b2:	fe 45 00             	incb   0x0(%rbp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff810014b5:	84 db                	test   %bl,%bl
ffffffff810014b7:	74 39                	je     ffffffff810014f2 <_ZN5Quota5allocEm+0x90>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff810014b9:	80 3d 70 e2 ff 3e 00 	cmpb   $0x0,0x3effe270(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff810014c0:	74 28                	je     ffffffff810014ea <_ZN5Quota5allocEm+0x88>
ffffffff810014c2:	49 c7 c0 70 d6 01 81 	mov    $0xffffffff8101d670,%r8
ffffffff810014c9:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff810014ce:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff810014d5:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff810014dc:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff810014e3:	31 c0                	xor    %eax,%eax
ffffffff810014e5:	e8 66 0a 00 00       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            preemption = true;
ffffffff810014ea:	c6 05 3f e2 ff 3e 01 	movb   $0x1,0x3effe23f(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff810014f1:	fb                   	sti    
        }
ffffffff810014f2:	5b                   	pop    %rbx
ffffffff810014f3:	5d                   	pop    %rbp
ffffffff810014f4:	41 5c                	pop    %r12
ffffffff810014f6:	c3                   	retq   
ffffffff810014f7:	90                   	nop

ffffffff810014f8 <_ZN5Quota4freeEm>:

        void free(mword p)
ffffffff810014f8:	41 54                	push   %r12
ffffffff810014fa:	49 89 f4             	mov    %rsi,%r12
ffffffff810014fd:	55                   	push   %rbp
ffffffff810014fe:	53                   	push   %rbx
ffffffff810014ff:	48 89 fb             	mov    %rdi,%rbx

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81001502:	9c                   	pushfq 
ffffffff81001503:	5d                   	pop    %rbp
            return flags & 0x200;
ffffffff81001504:	48 c1 ed 09          	shr    $0x9,%rbp

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff81001508:	40 80 e5 01          	and    $0x1,%bpl
ffffffff8100150c:	74 2d                	je     ffffffff8100153b <_ZN5Quota4freeEm+0x43>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff8100150e:	80 3d 1b e2 ff 3e 00 	cmpb   $0x0,0x3effe21b(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81001515:	75 1c                	jne    ffffffff81001533 <_ZN5Quota4freeEm+0x3b>
ffffffff81001517:	49 c7 c0 a0 d6 01 81 	mov    $0xffffffff8101d6a0,%r8
ffffffff8100151e:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff81001523:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100152a:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff81001531:	eb 4a                	jmp    ffffffff8100157d <_ZN5Quota4freeEm+0x85>

            asm volatile ("cli" : : : "memory");
ffffffff81001533:	fa                   	cli    
            preemption = false;
ffffffff81001534:	c6 05 f5 e1 ff 3e 00 	movb   $0x0,0x3effe1f5(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff8100153b:	48 89 df             	mov    %rbx,%rdi
ffffffff8100153e:	e8 4b f9 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
        {
            Lock_guard <Spinlock> guard (lock);

            if (p <= used) {
ffffffff81001543:	48 8b 43 08          	mov    0x8(%rbx),%rax
ffffffff81001547:	49 39 c4             	cmp    %rax,%r12
ffffffff8100154a:	77 3f                	ja     ffffffff8100158b <_ZN5Quota4freeEm+0x93>
                used -= p;
ffffffff8100154c:	4c 29 e0             	sub    %r12,%rax
ffffffff8100154f:	48 89 43 08          	mov    %rax,0x8(%rbx)
ffffffff81001553:	fe 03                	incb   (%rbx)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81001555:	40 84 ed             	test   %bpl,%bpl
ffffffff81001558:	74 4e                	je     ffffffff810015a8 <_ZN5Quota4freeEm+0xb0>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100155a:	80 3d cf e1 ff 3e 00 	cmpb   $0x0,0x3effe1cf(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81001561:	74 3d                	je     ffffffff810015a0 <_ZN5Quota4freeEm+0xa8>
ffffffff81001563:	49 c7 c0 70 d6 01 81 	mov    $0xffffffff8101d670,%r8
ffffffff8100156a:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff8100156f:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81001576:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff8100157d:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81001584:	31 c0                	xor    %eax,%eax
ffffffff81001586:	e8 c5 09 00 00       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
                return;
            }

            over += p - used;
ffffffff8100158b:	49 29 c4             	sub    %rax,%r12
            upli += p - used;
            used = 0;
ffffffff8100158e:	48 c7 43 08 00 00 00 	movq   $0x0,0x8(%rbx)
ffffffff81001595:	00 
            if (p <= used) {
                used -= p;
                return;
            }

            over += p - used;
ffffffff81001596:	4c 01 63 10          	add    %r12,0x10(%rbx)
            upli += p - used;
ffffffff8100159a:	4c 01 63 18          	add    %r12,0x18(%rbx)
ffffffff8100159e:	eb b3                	jmp    ffffffff81001553 <_ZN5Quota4freeEm+0x5b>

            preemption = true;
ffffffff810015a0:	c6 05 89 e1 ff 3e 01 	movb   $0x1,0x3effe189(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff810015a7:	fb                   	sti    
            used = 0;
        }
ffffffff810015a8:	5b                   	pop    %rbx
ffffffff810015a9:	5d                   	pop    %rbp
ffffffff810015aa:	41 5c                	pop    %r12
ffffffff810015ac:	c3                   	retq   
ffffffff810015ad:	90                   	nop

ffffffff810015ae <_ZN5Buddy4freeEmR5Quota>:
/*
 * Free physically contiguous memory region.
 * @param virt     Linear block base address
 */
void Buddy::free (mword virt, Quota &quota)
{
ffffffff810015ae:	41 54                	push   %r12
ffffffff810015b0:	55                   	push   %rbp
ffffffff810015b1:	49 89 fc             	mov    %rdi,%r12
ffffffff810015b4:	53                   	push   %rbx
        }

        ALWAYS_INLINE
        inline signed long page_to_index (mword l_addr)
        {
            return l_addr / PAGE_SIZE - base / PAGE_SIZE;
ffffffff810015b5:	48 8b 47 18          	mov    0x18(%rdi),%rax
ffffffff810015b9:	48 89 f3             	mov    %rsi,%rbx
ffffffff810015bc:	48 c1 eb 0c          	shr    $0xc,%rbx
ffffffff810015c0:	48 c1 e8 0c          	shr    $0xc,%rax
ffffffff810015c4:	48 29 c3             	sub    %rax,%rbx
    signed long idx = page_to_index (virt);

    // Ensure virt is within allocator range
    assert (idx >= min_idx && idx < max_idx);
ffffffff810015c7:	48 3b 5f 10          	cmp    0x10(%rdi),%rbx
ffffffff810015cb:	0f 8c bd 01 00 00    	jl     ffffffff8100178e <_ZN5Buddy4freeEmR5Quota+0x1e0>
ffffffff810015d1:	48 3b 5f 08          	cmp    0x8(%rdi),%rbx
ffffffff810015d5:	0f 8d b3 01 00 00    	jge    ffffffff8100178e <_ZN5Buddy4freeEmR5Quota+0x1e0>
        }

        ALWAYS_INLINE
        inline Block *index_to_block (signed long i)
        {
            return index + i;
ffffffff810015db:	48 6b db 18          	imul   $0x18,%rbx,%rbx
ffffffff810015df:	48 03 5f 28          	add    0x28(%rdi),%rbx

    Block *block = index_to_block (idx);

    // Ensure block is marked as used
    assert (block->tag == Block::Used);
ffffffff810015e3:	66 83 7b 12 00       	cmpw   $0x0,0x12(%rbx)
ffffffff810015e8:	74 1c                	je     ffffffff81001606 <_ZN5Buddy4freeEmR5Quota+0x58>
ffffffff810015ea:	49 c7 c0 50 d6 01 81 	mov    $0xffffffff8101d650,%r8
ffffffff810015f1:	b9 8c 00 00 00       	mov    $0x8c,%ecx
ffffffff810015f6:	48 c7 c2 f3 d3 01 81 	mov    $0xffffffff8101d3f3,%rdx
ffffffff810015fd:	48 c7 c6 60 d4 01 81 	mov    $0xffffffff8101d460,%rsi
ffffffff81001604:	eb 3b                	jmp    ffffffff81001641 <_ZN5Buddy4freeEmR5Quota+0x93>

    // Ensure corresponding physical block is order-aligned
    assert ((virt_to_phys (virt) & ((1ul << (block->ord + PAGE_BITS)) - 1)) == 0);
ffffffff81001606:	0f b7 7b 10          	movzwl 0x10(%rbx),%edi
ffffffff8100160a:	b8 01 00 00 00       	mov    $0x1,%eax
        }

        ALWAYS_INLINE
        inline mword virt_to_phys (mword virt)
        {
            return virt - reinterpret_cast<mword>(&OFFSET);
ffffffff8100160f:	48 81 ee 00 00 c0 80 	sub    $0xffffffff80c00000,%rsi
ffffffff81001616:	49 89 c0             	mov    %rax,%r8
ffffffff81001619:	8d 4f 0c             	lea    0xc(%rdi),%ecx
ffffffff8100161c:	49 d3 e0             	shl    %cl,%r8
ffffffff8100161f:	49 ff c8             	dec    %r8
ffffffff81001622:	49 85 f0             	test   %rsi,%r8
ffffffff81001625:	74 28                	je     ffffffff8100164f <_ZN5Buddy4freeEmR5Quota+0xa1>
ffffffff81001627:	49 c7 c0 50 d6 01 81 	mov    $0xffffffff8101d650,%r8
ffffffff8100162e:	b9 8f 00 00 00       	mov    $0x8f,%ecx
ffffffff81001633:	48 c7 c2 f3 d3 01 81 	mov    $0xffffffff8101d3f3,%rdx
ffffffff8100163a:	48 c7 c6 7a d4 01 81 	mov    $0xffffffff8101d47a,%rsi
ffffffff81001641:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81001648:	31 c0                	xor    %eax,%eax
ffffffff8100164a:	e8 01 09 00 00       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

    quota.free(1ul << block->ord);
ffffffff8100164f:	40 88 f9             	mov    %dil,%cl
ffffffff81001652:	48 89 d7             	mov    %rdx,%rdi
ffffffff81001655:	48 d3 e0             	shl    %cl,%rax
ffffffff81001658:	48 89 c6             	mov    %rax,%rsi
ffffffff8100165b:	e8 98 fe ff ff       	callq  ffffffff810014f8 <_ZN5Quota4freeEm>

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81001660:	9c                   	pushfq 
ffffffff81001661:	5d                   	pop    %rbp
            return flags & 0x200;
ffffffff81001662:	48 c1 ed 09          	shr    $0x9,%rbp

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff81001666:	40 80 e5 01          	and    $0x1,%bpl
ffffffff8100166a:	74 2d                	je     ffffffff81001699 <_ZN5Buddy4freeEmR5Quota+0xeb>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff8100166c:	80 3d bd e0 ff 3e 00 	cmpb   $0x0,0x3effe0bd(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81001673:	75 1c                	jne    ffffffff81001691 <_ZN5Buddy4freeEmR5Quota+0xe3>
ffffffff81001675:	49 c7 c0 a0 d6 01 81 	mov    $0xffffffff8101d6a0,%r8
ffffffff8100167c:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff81001681:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81001688:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff8100168f:	eb b0                	jmp    ffffffff81001641 <_ZN5Buddy4freeEmR5Quota+0x93>

            asm volatile ("cli" : : : "memory");
ffffffff81001691:	fa                   	cli    
            preemption = false;
ffffffff81001692:	c6 05 97 e0 ff 3e 00 	movb   $0x0,0x3effe097(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff81001699:	4c 89 e7             	mov    %r12,%rdi
ffffffff8100169c:	e8 ed f7 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>

    Lock_guard <Spinlock> guard (lock);

    unsigned short ord;
    for (ord = block->ord; ord < order - 1; ord++) {
ffffffff810016a1:	8b 4b 10             	mov    0x10(%rbx),%ecx
        Block *         head;

        ALWAYS_INLINE
        inline signed long block_to_index (Block *b)
        {
            return b - index;
ffffffff810016a4:	48 bf ab aa aa aa aa 	movabs $0xaaaaaaaaaaaaaaab,%rdi
ffffffff810016ab:	aa aa aa 

        // Compute block index and corresponding buddy index
        signed long block_idx = block_to_index (block);
        signed long buddy_idx = block_idx ^ (1ul << ord);
ffffffff810016ae:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    quota.free(1ul << block->ord);

    Lock_guard <Spinlock> guard (lock);

    unsigned short ord;
    for (ord = block->ord; ord < order - 1; ord++) {
ffffffff810016b4:	49 8b 44 24 20       	mov    0x20(%r12),%rax
ffffffff810016b9:	0f b7 f1             	movzwl %cx,%esi
ffffffff810016bc:	48 ff c8             	dec    %rax
ffffffff810016bf:	48 39 c6             	cmp    %rax,%rsi
ffffffff810016c2:	73 26                	jae    ffffffff810016ea <_ZN5Buddy4freeEmR5Quota+0x13c>
ffffffff810016c4:	4d 8b 4c 24 28       	mov    0x28(%r12),%r9
ffffffff810016c9:	48 89 da             	mov    %rbx,%rdx
ffffffff810016cc:	4c 29 ca             	sub    %r9,%rdx
ffffffff810016cf:	48 c1 fa 03          	sar    $0x3,%rdx
ffffffff810016d3:	48 89 d0             	mov    %rdx,%rax

        // Compute block index and corresponding buddy index
        signed long block_idx = block_to_index (block);
        signed long buddy_idx = block_idx ^ (1ul << ord);
ffffffff810016d6:	4c 89 c2             	mov    %r8,%rdx
ffffffff810016d9:	48 0f af c7          	imul   %rdi,%rax
ffffffff810016dd:	48 d3 e2             	shl    %cl,%rdx
ffffffff810016e0:	48 31 c2             	xor    %rax,%rdx

        // Buddy outside mempool
        if (buddy_idx < min_idx || buddy_idx >= max_idx)
ffffffff810016e3:	49 3b 54 24 10       	cmp    0x10(%r12),%rdx
ffffffff810016e8:	7d 33                	jge    ffffffff8100171d <_ZN5Buddy4freeEmR5Quota+0x16f>

    block->ord = ord;
    block->tag = Block::Free;

    // Enqueue final-size block
    Block *h = head + ord;
ffffffff810016ea:	48 6b c6 18          	imul   $0x18,%rsi,%rax
        // Merge block with buddy
        if (buddy < block)
            block = buddy;
    }

    block->ord = ord;
ffffffff810016ee:	66 89 4b 10          	mov    %cx,0x10(%rbx)
    block->tag = Block::Free;
ffffffff810016f2:	66 c7 43 12 01 00    	movw   $0x1,0x12(%rbx)

    // Enqueue final-size block
    Block *h = head + ord;
ffffffff810016f8:	49 03 44 24 30       	add    0x30(%r12),%rax
    block->prev = h;
ffffffff810016fd:	48 89 03             	mov    %rax,(%rbx)
    block->next = h->next;
ffffffff81001700:	48 8b 50 08          	mov    0x8(%rax),%rdx
ffffffff81001704:	48 89 53 08          	mov    %rdx,0x8(%rbx)
    block->next->prev = h->next = block;
ffffffff81001708:	48 89 58 08          	mov    %rbx,0x8(%rax)
ffffffff8100170c:	48 89 1a             	mov    %rbx,(%rdx)
ffffffff8100170f:	41 fe 04 24          	incb   (%r12)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81001713:	40 84 ed             	test   %bpl,%bpl
ffffffff81001716:	75 44                	jne    ffffffff8100175c <_ZN5Buddy4freeEmR5Quota+0x1ae>
ffffffff81001718:	e9 90 00 00 00       	jmpq   ffffffff810017ad <_ZN5Buddy4freeEmR5Quota+0x1ff>
        // Compute block index and corresponding buddy index
        signed long block_idx = block_to_index (block);
        signed long buddy_idx = block_idx ^ (1ul << ord);

        // Buddy outside mempool
        if (buddy_idx < min_idx || buddy_idx >= max_idx)
ffffffff8100171d:	49 3b 54 24 08       	cmp    0x8(%r12),%rdx
ffffffff81001722:	7d c6                	jge    ffffffff810016ea <_ZN5Buddy4freeEmR5Quota+0x13c>
        }

        ALWAYS_INLINE
        inline Block *index_to_block (signed long i)
        {
            return index + i;
ffffffff81001724:	48 6b d2 18          	imul   $0x18,%rdx,%rdx
ffffffff81001728:	49 8d 04 11          	lea    (%r9,%rdx,1),%rax
            break;

        Block *buddy = index_to_block (buddy_idx);

        // Buddy in use or fragmented
        if (buddy->tag == Block::Used || buddy->ord != ord)
ffffffff8100172c:	66 83 78 12 00       	cmpw   $0x0,0x12(%rax)
ffffffff81001731:	74 b7                	je     ffffffff810016ea <_ZN5Buddy4freeEmR5Quota+0x13c>
ffffffff81001733:	66 39 48 10          	cmp    %cx,0x10(%rax)
ffffffff81001737:	75 b1                	jne    ffffffff810016ea <_ZN5Buddy4freeEmR5Quota+0x13c>
            break;

        // Dequeue buddy from block list
        buddy->prev->next = buddy->next;
ffffffff81001739:	48 8b 10             	mov    (%rax),%rdx
ffffffff8100173c:	48 8b 70 08          	mov    0x8(%rax),%rsi
ffffffff81001740:	48 39 c3             	cmp    %rax,%rbx
ffffffff81001743:	48 0f 47 d8          	cmova  %rax,%rbx
    quota.free(1ul << block->ord);

    Lock_guard <Spinlock> guard (lock);

    unsigned short ord;
    for (ord = block->ord; ord < order - 1; ord++) {
ffffffff81001747:	ff c1                	inc    %ecx
        // Buddy in use or fragmented
        if (buddy->tag == Block::Used || buddy->ord != ord)
            break;

        // Dequeue buddy from block list
        buddy->prev->next = buddy->next;
ffffffff81001749:	48 89 72 08          	mov    %rsi,0x8(%rdx)
        buddy->next->prev = buddy->prev;
ffffffff8100174d:	48 8b 50 08          	mov    0x8(%rax),%rdx
ffffffff81001751:	48 8b 30             	mov    (%rax),%rsi
ffffffff81001754:	48 89 32             	mov    %rsi,(%rdx)
ffffffff81001757:	e9 58 ff ff ff       	jmpq   ffffffff810016b4 <_ZN5Buddy4freeEmR5Quota+0x106>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100175c:	80 3d cd df ff 3e 00 	cmpb   $0x0,0x3effdfcd(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81001763:	74 1f                	je     ffffffff81001784 <_ZN5Buddy4freeEmR5Quota+0x1d6>
ffffffff81001765:	49 c7 c0 70 d6 01 81 	mov    $0xffffffff8101d670,%r8
ffffffff8100176c:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff81001771:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81001778:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff8100177f:	e9 bd fe ff ff       	jmpq   ffffffff81001641 <_ZN5Buddy4freeEmR5Quota+0x93>

            preemption = true;
ffffffff81001784:	c6 05 a5 df ff 3e 01 	movb   $0x1,0x3effdfa5(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100178b:	fb                   	sti    
ffffffff8100178c:	eb 1f                	jmp    ffffffff810017ad <_ZN5Buddy4freeEmR5Quota+0x1ff>
void Buddy::free (mword virt, Quota &quota)
{
    signed long idx = page_to_index (virt);

    // Ensure virt is within allocator range
    assert (idx >= min_idx && idx < max_idx);
ffffffff8100178e:	49 c7 c0 50 d6 01 81 	mov    $0xffffffff8101d650,%r8
ffffffff81001795:	b9 87 00 00 00       	mov    $0x87,%ecx
ffffffff8100179a:	48 c7 c2 f3 d3 01 81 	mov    $0xffffffff8101d3f3,%rdx
ffffffff810017a1:	48 c7 c6 bf d4 01 81 	mov    $0xffffffff8101d4bf,%rsi
ffffffff810017a8:	e9 94 fe ff ff       	jmpq   ffffffff81001641 <_ZN5Buddy4freeEmR5Quota+0x93>
    // Enqueue final-size block
    Block *h = head + ord;
    block->prev = h;
    block->next = h->next;
    block->next->prev = h->next = block;
}
ffffffff810017ad:	5b                   	pop    %rbx
ffffffff810017ae:	5d                   	pop    %rbp
ffffffff810017af:	41 5c                	pop    %r12
ffffffff810017b1:	c3                   	retq   

ffffffff810017b2 <_ZN5Quota4dumpEPvb>:


void Quota::dump(void * pd, bool all)
{
ffffffff810017b2:	41 55                	push   %r13
ffffffff810017b4:	41 54                	push   %r12
ffffffff810017b6:	49 89 f5             	mov    %rsi,%r13
ffffffff810017b9:	55                   	push   %rbp
ffffffff810017ba:	53                   	push   %rbx
ffffffff810017bb:	48 89 fb             	mov    %rdi,%rbx
ffffffff810017be:	48 83 ec 18          	sub    $0x18,%rsp
    if (all) {
ffffffff810017c2:	84 d2                	test   %dl,%dl
ffffffff810017c4:	48 8d 6c 24 07       	lea    0x7(%rsp),%rbp
ffffffff810017c9:	0f 84 d5 00 00 00    	je     ffffffff810018a4 <_ZN5Quota4dumpEPvb+0xf2>
        trace(0, "quota after boot Quota:init - in_use=%lx limit %lx",
ffffffff810017cf:	8b 05 2f d8 ff 3e    	mov    0x3effd82f(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff810017d5:	49 89 ec             	mov    %rbp,%r12
ffffffff810017d8:	48 8b 0d a9 05 02 00 	mov    0x205a9(%rip),%rcx        # ffffffff81021d88 <_ZN5Quota4initE+0x18>
ffffffff810017df:	49 81 e4 00 f0 ff ff 	and    $0xfffffffffffff000,%r12
ffffffff810017e6:	48 8b 15 8b 05 02 00 	mov    0x2058b(%rip),%rdx        # ffffffff81021d78 <_ZN5Quota4initE+0x8>
ffffffff810017ed:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff810017f1:	49 81 fc 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%r12
ffffffff810017f8:	48 c7 c7 df d4 01 81 	mov    $0xffffffff8101d4df,%rdi
ffffffff810017ff:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff81001803:	31 c0                	xor    %eax,%eax
ffffffff81001805:	e8 82 08 00 00       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
              Quota::init.usage(), Quota::init.upli);

        trace(0, "Pd::kern=%12p quota=%12p - in_use=%012lx limit=%012lx not_for_transfer=%012lx overrun=%lx",
ffffffff8100180a:	8b 05 f4 d7 ff 3e    	mov    0x3effd7f4(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81001810:	4c 8b 0d 69 24 16 00 	mov    0x162469(%rip),%r9        # ffffffff81163c80 <_ZN2Pd4rootE+0x320>
ffffffff81001817:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff8100181b:	4c 8b 05 8e 27 16 00 	mov    0x16278e(%rip),%r8        # ffffffff81163fb0 <_ZN2Pd4kernE+0x310>
ffffffff81001822:	ff 35 90 27 16 00    	pushq  0x162790(%rip)        # ffffffff81163fb8 <_ZN2Pd4kernE+0x318>
ffffffff81001828:	49 81 fc 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%r12
ffffffff8100182f:	ff 35 93 27 16 00    	pushq  0x162793(%rip)        # ffffffff81163fc8 <_ZN2Pd4kernE+0x328>
ffffffff81001835:	48 c7 c1 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rcx
ffffffff8100183c:	48 c7 c2 a0 3c 16 81 	mov    $0xffffffff81163ca0,%rdx
ffffffff81001843:	48 c7 c7 19 d5 01 81 	mov    $0xffffffff8101d519,%rdi
ffffffff8100184a:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff8100184e:	31 c0                	xor    %eax,%eax
ffffffff81001850:	e8 37 08 00 00       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
              &Pd::kern, &Pd::kern.quota, Pd::kern.quota.usage(), Pd::root.quota.upli, Pd::kern.quota.notr, Pd::kern.quota.over);
        trace(0, "Pd::root=%12p quota=%12p - in_use=%012lx limit=%012lx not_for_transfer=%012lx overrun=%lx",
ffffffff81001855:	58                   	pop    %rax
ffffffff81001856:	8b 05 a8 d7 ff 3e    	mov    0x3effd7a8(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100185c:	4c 8b 0d 1d 24 16 00 	mov    0x16241d(%rip),%r9        # ffffffff81163c80 <_ZN2Pd4rootE+0x320>
ffffffff81001863:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81001867:	5a                   	pop    %rdx
ffffffff81001868:	4c 8b 05 01 24 16 00 	mov    0x162401(%rip),%r8        # ffffffff81163c70 <_ZN2Pd4rootE+0x310>
ffffffff8100186f:	ff 35 03 24 16 00    	pushq  0x162403(%rip)        # ffffffff81163c78 <_ZN2Pd4rootE+0x318>
ffffffff81001875:	49 81 fc 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%r12
ffffffff8100187c:	ff 35 06 24 16 00    	pushq  0x162406(%rip)        # ffffffff81163c88 <_ZN2Pd4rootE+0x328>
ffffffff81001882:	48 c7 c1 68 3c 16 81 	mov    $0xffffffff81163c68,%rcx
ffffffff81001889:	48 c7 c2 60 39 16 81 	mov    $0xffffffff81163960,%rdx
ffffffff81001890:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff81001894:	48 c7 c7 7a d5 01 81 	mov    $0xffffffff8101d57a,%rdi
ffffffff8100189b:	31 c0                	xor    %eax,%eax
ffffffff8100189d:	e8 ea 07 00 00       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff810018a2:	59                   	pop    %rcx
ffffffff810018a3:	5e                   	pop    %rsi
              &Pd::root, &Pd::root.quota, Pd::root.quota.usage(), Pd::root.quota.upli, Pd::root.quota.notr, Pd::root.quota.over);
    }

    trace(0, "Pd::this=%12p quota=%12p - in_use=%012lx limit=%012lx not_for_transfer=%012lx overrun=%lx",
ffffffff810018a4:	8b 05 5a d7 ff 3e    	mov    0x3effd75a(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff810018aa:	48 81 e5 00 f0 ff ff 	and    $0xfffffffffffff000,%rbp
ffffffff810018b1:	4c 8b 4b 18          	mov    0x18(%rbx),%r9
ffffffff810018b5:	4c 8b 43 08          	mov    0x8(%rbx),%r8
ffffffff810018b9:	ff 73 10             	pushq  0x10(%rbx)
ffffffff810018bc:	49 8d 8d 08 03 00 00 	lea    0x308(%r13),%rcx
ffffffff810018c3:	ff 73 20             	pushq  0x20(%rbx)
ffffffff810018c6:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff810018ca:	48 81 fd 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rbp
ffffffff810018d1:	4c 89 ea             	mov    %r13,%rdx
ffffffff810018d4:	48 c7 c7 db d5 01 81 	mov    $0xffffffff8101d5db,%rdi
ffffffff810018db:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff810018df:	31 c0                	xor    %eax,%eax
ffffffff810018e1:	e8 a6 07 00 00       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
          pd, &static_cast<Pd *>(pd)->quota, usage(), upli, notr, over);
}
ffffffff810018e6:	48 83 c4 28          	add    $0x28,%rsp
ffffffff810018ea:	5b                   	pop    %rbx
ffffffff810018eb:	5d                   	pop    %rbp
ffffffff810018ec:	41 5c                	pop    %r12
ffffffff810018ee:	41 5d                	pop    %r13
ffffffff810018f0:	c3                   	retq   
ffffffff810018f1:	90                   	nop

ffffffff810018f2 <_ZN5Buddy5allocEtR5QuotaNS_4FillE>:
 * @param ord       Block order (2^ord pages)
 * @param zero      Zero out block content if true
 * @return          Pointer to linear memory region
 */
void *Buddy::alloc (unsigned short ord, Quota &quota, Fill fill)
{
ffffffff810018f2:	41 57                	push   %r15
ffffffff810018f4:	41 56                	push   %r14
ffffffff810018f6:	41 89 cf             	mov    %ecx,%r15d
ffffffff810018f9:	41 55                	push   %r13
ffffffff810018fb:	41 89 f6             	mov    %esi,%r14d
ffffffff810018fe:	41 54                	push   %r12
ffffffff81001900:	49 89 d5             	mov    %rdx,%r13
ffffffff81001903:	55                   	push   %rbp
ffffffff81001904:	48 89 fd             	mov    %rdi,%rbp
ffffffff81001907:	53                   	push   %rbx
ffffffff81001908:	41 50                	push   %r8

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff8100190a:	9c                   	pushfq 
ffffffff8100190b:	41 5c                	pop    %r12
            return flags & 0x200;
ffffffff8100190d:	49 c1 ec 09          	shr    $0x9,%r12

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff81001911:	41 80 e4 01          	and    $0x1,%r12b
ffffffff81001915:	74 2d                	je     ffffffff81001944 <_ZN5Buddy5allocEtR5QuotaNS_4FillE+0x52>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81001917:	80 3d 12 de ff 3e 00 	cmpb   $0x0,0x3effde12(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100191e:	75 1c                	jne    ffffffff8100193c <_ZN5Buddy5allocEtR5QuotaNS_4FillE+0x4a>
ffffffff81001920:	49 c7 c0 a0 d6 01 81 	mov    $0xffffffff8101d6a0,%r8
ffffffff81001927:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff8100192c:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81001933:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff8100193a:	eb 7c                	jmp    ffffffff810019b8 <_ZN5Buddy5allocEtR5QuotaNS_4FillE+0xc6>

            asm volatile ("cli" : : : "memory");
ffffffff8100193c:	fa                   	cli    
            preemption = false;
ffffffff8100193d:	c6 05 ec dd ff 3e 00 	movb   $0x0,0x3effddec(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff81001944:	48 89 ef             	mov    %rbp,%rdi
ffffffff81001947:	e8 42 f5 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    Lock_guard <Spinlock> guard (lock);

    for (unsigned short j = ord; j < order; j++) {
ffffffff8100194c:	48 8b 4d 20          	mov    0x20(%rbp),%rcx
ffffffff81001950:	44 89 f0             	mov    %r14d,%eax
ffffffff81001953:	eb 73                	jmp    ffffffff810019c8 <_ZN5Buddy5allocEtR5QuotaNS_4FillE+0xd6>
        Block *         head;

        ALWAYS_INLINE
        inline signed long block_to_index (Block *b)
        {
            return b - index;
ffffffff81001955:	4c 89 c3             	mov    %r8,%rbx
ffffffff81001958:	48 2b 5d 28          	sub    0x28(%rbp),%rbx
ffffffff8100195c:	48 b8 ab aa aa aa aa 	movabs $0xaaaaaaaaaaaaaaab,%rax
ffffffff81001963:	aa aa aa 
        }

        mword virt = index_to_page (block_to_index (block));

        // Ensure corresponding physical block is order-aligned
        assert ((virt_to_phys (virt) & ((1ul << (block->ord + PAGE_BITS)) - 1)) == 0);
ffffffff81001966:	41 0f b7 48 10       	movzwl 0x10(%r8),%ecx
ffffffff8100196b:	41 b8 01 00 00 00    	mov    $0x1,%r8d
ffffffff81001971:	48 c1 fb 03          	sar    $0x3,%rbx
ffffffff81001975:	48 0f af d8          	imul   %rax,%rbx
ffffffff81001979:	83 c1 0c             	add    $0xc,%ecx
ffffffff8100197c:	49 d3 e0             	shl    %cl,%r8
ffffffff8100197f:	49 8d 40 ff          	lea    -0x1(%r8),%rax
        }

        ALWAYS_INLINE
        inline mword index_to_page (signed long i)
        {
            return base + i * PAGE_SIZE;
ffffffff81001983:	48 c1 e3 0c          	shl    $0xc,%rbx
ffffffff81001987:	48 03 5d 18          	add    0x18(%rbp),%rbx
        }

        ALWAYS_INLINE
        inline mword virt_to_phys (mword virt)
        {
            return virt - reinterpret_cast<mword>(&OFFSET);
ffffffff8100198b:	48 89 da             	mov    %rbx,%rdx
ffffffff8100198e:	48 81 ea 00 00 c0 80 	sub    $0xffffffff80c00000,%rdx
ffffffff81001995:	48 85 c2             	test   %rax,%rdx
ffffffff81001998:	0f 84 b5 00 00 00    	je     ffffffff81001a53 <_ZN5Buddy5allocEtR5QuotaNS_4FillE+0x161>
ffffffff8100199e:	49 c7 c0 d0 d6 01 81 	mov    $0xffffffff8101d6d0,%r8
ffffffff810019a5:	b9 6f 00 00 00       	mov    $0x6f,%ecx
ffffffff810019aa:	48 c7 c2 f3 d3 01 81 	mov    $0xffffffff8101d3f3,%rdx
ffffffff810019b1:	48 c7 c6 7a d4 01 81 	mov    $0xffffffff8101d47a,%rsi
ffffffff810019b8:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff810019bf:	31 c0                	xor    %eax,%eax
ffffffff810019c1:	e8 8a 05 00 00       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
 */
void *Buddy::alloc (unsigned short ord, Quota &quota, Fill fill)
{
    Lock_guard <Spinlock> guard (lock);

    for (unsigned short j = ord; j < order; j++) {
ffffffff810019c6:	ff c0                	inc    %eax
ffffffff810019c8:	0f b7 d0             	movzwl %ax,%edx
ffffffff810019cb:	48 39 ca             	cmp    %rcx,%rdx
ffffffff810019ce:	0f 83 e3 00 00 00    	jae    ffffffff81001ab7 <_ZN5Buddy5allocEtR5QuotaNS_4FillE+0x1c5>

        if (head[j].next == head + j)
ffffffff810019d4:	48 6b d2 18          	imul   $0x18,%rdx,%rdx
ffffffff810019d8:	48 03 55 30          	add    0x30(%rbp),%rdx
ffffffff810019dc:	4c 8b 42 08          	mov    0x8(%rdx),%r8
ffffffff810019e0:	49 39 d0             	cmp    %rdx,%r8
ffffffff810019e3:	74 e1                	je     ffffffff810019c6 <_ZN5Buddy5allocEtR5QuotaNS_4FillE+0xd4>
            continue;

        Block *block = head[j].next;
        block->prev->next = block->next;
ffffffff810019e5:	49 8b 10             	mov    (%r8),%rdx
ffffffff810019e8:	49 8b 48 08          	mov    0x8(%r8),%rcx
ffffffff810019ec:	41 8d 76 ff          	lea    -0x1(%r14),%esi
        block->next->prev = block->prev;
        block->ord = ord;
        block->tag = Block::Used;

        while (j-- != ord) {
            Block *buddy = block + (1ul << j);
ffffffff810019f0:	bf 18 00 00 00       	mov    $0x18,%edi

        if (head[j].next == head + j)
            continue;

        Block *block = head[j].next;
        block->prev->next = block->next;
ffffffff810019f5:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
        block->next->prev = block->prev;
ffffffff810019f9:	49 8b 50 08          	mov    0x8(%r8),%rdx
ffffffff810019fd:	49 8b 08             	mov    (%r8),%rcx
ffffffff81001a00:	48 89 0a             	mov    %rcx,(%rdx)
        block->ord = ord;
ffffffff81001a03:	66 45 89 70 10       	mov    %r14w,0x10(%r8)
        block->tag = Block::Used;
ffffffff81001a08:	66 41 c7 40 12 00 00 	movw   $0x0,0x12(%r8)

        while (j-- != ord) {
ffffffff81001a0f:	ff c8                	dec    %eax
ffffffff81001a11:	66 39 f0             	cmp    %si,%ax
ffffffff81001a14:	0f 84 3b ff ff ff    	je     ffffffff81001955 <_ZN5Buddy5allocEtR5QuotaNS_4FillE+0x63>
            Block *buddy = block + (1ul << j);
            buddy->prev = buddy->next = head + j;
ffffffff81001a1a:	0f b7 d0             	movzwl %ax,%edx
        block->next->prev = block->prev;
        block->ord = ord;
        block->tag = Block::Used;

        while (j-- != ord) {
            Block *buddy = block + (1ul << j);
ffffffff81001a1d:	88 c1                	mov    %al,%cl
ffffffff81001a1f:	49 89 f9             	mov    %rdi,%r9
            buddy->prev = buddy->next = head + j;
ffffffff81001a22:	48 6b d2 18          	imul   $0x18,%rdx,%rdx
        block->next->prev = block->prev;
        block->ord = ord;
        block->tag = Block::Used;

        while (j-- != ord) {
            Block *buddy = block + (1ul << j);
ffffffff81001a26:	49 d3 e1             	shl    %cl,%r9
ffffffff81001a29:	4d 01 c1             	add    %r8,%r9
            buddy->prev = buddy->next = head + j;
ffffffff81001a2c:	48 89 d1             	mov    %rdx,%rcx
ffffffff81001a2f:	48 03 4d 30          	add    0x30(%rbp),%rcx
            buddy->ord = j;
ffffffff81001a33:	66 41 89 41 10       	mov    %ax,0x10(%r9)
            buddy->tag = Block::Free;
ffffffff81001a38:	66 41 c7 41 12 01 00 	movw   $0x1,0x12(%r9)
        block->ord = ord;
        block->tag = Block::Used;

        while (j-- != ord) {
            Block *buddy = block + (1ul << j);
            buddy->prev = buddy->next = head + j;
ffffffff81001a3f:	49 89 49 08          	mov    %rcx,0x8(%r9)
ffffffff81001a43:	49 89 09             	mov    %rcx,(%r9)
            buddy->ord = j;
            buddy->tag = Block::Free;
            head[j].next = head[j].prev = buddy;
ffffffff81001a46:	48 03 55 30          	add    0x30(%rbp),%rdx
ffffffff81001a4a:	4c 89 0a             	mov    %r9,(%rdx)
ffffffff81001a4d:	4c 89 4a 08          	mov    %r9,0x8(%rdx)
ffffffff81001a51:	eb bc                	jmp    ffffffff81001a0f <_ZN5Buddy5allocEtR5QuotaNS_4FillE+0x11d>
        mword virt = index_to_page (block_to_index (block));

        // Ensure corresponding physical block is order-aligned
        assert ((virt_to_phys (virt) & ((1ul << (block->ord + PAGE_BITS)) - 1)) == 0);

        if (fill)
ffffffff81001a53:	45 85 ff             	test   %r15d,%r15d
ffffffff81001a56:	74 12                	je     ffffffff81001a6a <_ZN5Buddy5allocEtR5QuotaNS_4FillE+0x178>
            memset (reinterpret_cast<void *>(virt), fill == FILL_0 ? 0 : -1, 1ul << (block->ord + PAGE_BITS));
ffffffff81001a58:	31 c0                	xor    %eax,%eax
ffffffff81001a5a:	41 ff cf             	dec    %r15d
ffffffff81001a5d:	48 89 df             	mov    %rbx,%rdi
ffffffff81001a60:	0f 95 c0             	setne  %al
ffffffff81001a63:	4c 89 c1             	mov    %r8,%rcx
ffffffff81001a66:	f7 d8                	neg    %eax
ffffffff81001a68:	f3 aa                	rep stos %al,%es:(%rdi)

        quota.alloc(1ul << ord);
ffffffff81001a6a:	44 88 f1             	mov    %r14b,%cl
ffffffff81001a6d:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff81001a72:	4c 89 ef             	mov    %r13,%rdi
ffffffff81001a75:	48 d3 e6             	shl    %cl,%rsi
ffffffff81001a78:	e8 e5 f9 ff ff       	callq  ffffffff81001462 <_ZN5Quota5allocEm>
ffffffff81001a7d:	fe 45 00             	incb   0x0(%rbp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81001a80:	45 84 e4             	test   %r12b,%r12b
ffffffff81001a83:	74 54                	je     ffffffff81001ad9 <_ZN5Buddy5allocEtR5QuotaNS_4FillE+0x1e7>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81001a85:	80 3d a4 dc ff 3e 00 	cmpb   $0x0,0x3effdca4(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81001a8c:	74 1f                	je     ffffffff81001aad <_ZN5Buddy5allocEtR5QuotaNS_4FillE+0x1bb>
ffffffff81001a8e:	49 c7 c0 70 d6 01 81 	mov    $0xffffffff8101d670,%r8
ffffffff81001a95:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff81001a9a:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81001aa1:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff81001aa8:	e9 0b ff ff ff       	jmpq   ffffffff810019b8 <_ZN5Buddy5allocEtR5QuotaNS_4FillE+0xc6>

            preemption = true;
ffffffff81001aad:	c6 05 7c dc ff 3e 01 	movb   $0x1,0x3effdc7c(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81001ab4:	fb                   	sti    
ffffffff81001ab5:	eb 22                	jmp    ffffffff81001ad9 <_ZN5Buddy5allocEtR5QuotaNS_4FillE+0x1e7>

        return reinterpret_cast<void *>(virt);
    }

    quota.dump(Pd::current);
ffffffff81001ab7:	48 8b 35 52 d5 ff 3e 	mov    0x3effd552(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81001abe:	4c 89 ef             	mov    %r13,%rdi
ffffffff81001ac1:	ba 01 00 00 00       	mov    $0x1,%edx
ffffffff81001ac6:	e8 e7 fc ff ff       	callq  ffffffff810017b2 <_ZN5Quota4dumpEPvb>

    Console::panic ("Out of memory");
ffffffff81001acb:	48 c7 c7 3c d6 01 81 	mov    $0xffffffff8101d63c,%rdi
ffffffff81001ad2:	31 c0                	xor    %eax,%eax
ffffffff81001ad4:	e8 77 04 00 00       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
}
ffffffff81001ad9:	5a                   	pop    %rdx
ffffffff81001ada:	48 89 d8             	mov    %rbx,%rax
ffffffff81001add:	5b                   	pop    %rbx
ffffffff81001ade:	5d                   	pop    %rbp
ffffffff81001adf:	41 5c                	pop    %r12
ffffffff81001ae1:	41 5d                	pop    %r13
ffffffff81001ae3:	41 5e                	pop    %r14
ffffffff81001ae5:	41 5f                	pop    %r15
ffffffff81001ae7:	c3                   	retq   

ffffffff81001ae8 <_GLOBAL__sub_I.00101__ZN5Quota4initE>:
INIT_PRIORITY (PRIO_BUDDY)
Buddy Buddy::allocator (reinterpret_cast<mword>(&_mempool_p),
                        reinterpret_cast<mword>(&_mempool_l),
                        reinterpret_cast<mword>(&_mempool_f),
                        reinterpret_cast<mword>(&_mempool_e) -
                        reinterpret_cast<mword>(&_mempool_l));
ffffffff81001ae8:	48 c7 c2 00 50 16 81 	mov    $0xffffffff81165000,%rdx

/*
 * Buddy Allocator
 */
INIT_PRIORITY (PRIO_BUDDY)
Buddy Buddy::allocator (reinterpret_cast<mword>(&_mempool_p),
ffffffff81001aef:	49 c7 c0 00 00 40 89 	mov    $0xffffffff89400000,%r8
ffffffff81001af6:	48 c7 c1 00 d0 16 81 	mov    $0xffffffff8116d000,%rcx
ffffffff81001afd:	49 29 d0             	sub    %rdx,%r8
ffffffff81001b00:	48 c7 c6 00 50 56 00 	mov    $0x565000,%rsi
ffffffff81001b07:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
    private:
        uint16 val;

    public:
        ALWAYS_INLINE
        inline Spinlock() : val (0) {}
ffffffff81001b0e:	66 c7 05 59 02 02 00 	movw   $0x0,0x20259(%rip)        # ffffffff81021d70 <_ZN5Quota4initE>
ffffffff81001b15:	00 00 

    public:

        static Quota init;

        Quota () : used(0), over(0), upli(0), notr(0) { }
ffffffff81001b17:	48 c7 05 56 02 02 00 	movq   $0x0,0x20256(%rip)        # ffffffff81021d78 <_ZN5Quota4initE+0x8>
ffffffff81001b1e:	00 00 00 00 
ffffffff81001b22:	48 c7 05 53 02 02 00 	movq   $0x0,0x20253(%rip)        # ffffffff81021d80 <_ZN5Quota4initE+0x10>
ffffffff81001b29:	00 00 00 00 
ffffffff81001b2d:	48 c7 05 50 02 02 00 	movq   $0x0,0x20250(%rip)        # ffffffff81021d88 <_ZN5Quota4initE+0x18>
ffffffff81001b34:	00 00 00 00 
ffffffff81001b38:	48 c7 05 4d 02 02 00 	movq   $0x0,0x2024d(%rip)        # ffffffff81021d90 <_ZN5Quota4initE+0x20>
ffffffff81001b3f:	00 00 00 00 
ffffffff81001b43:	e9 00 f0 1f 7f       	jmpq   200b48 <_ZN5BuddyC1Emmmm>

ffffffff81001b48 <_ZN7Console9print_numEyjjj>:

Console *Console::list;
Spinlock Console::lock;

void Console::print_num (uint64 val, unsigned base, unsigned width, unsigned flags)
{
ffffffff81001b48:	41 56                	push   %r14
ffffffff81001b4a:	41 55                	push   %r13
    bool neg = false;
ffffffff81001b4c:	45 31 c9             	xor    %r9d,%r9d

Console *Console::list;
Spinlock Console::lock;

void Console::print_num (uint64 val, unsigned base, unsigned width, unsigned flags)
{
ffffffff81001b4f:	41 54                	push   %r12
ffffffff81001b51:	55                   	push   %rbp
ffffffff81001b52:	53                   	push   %rbx
ffffffff81001b53:	48 89 fb             	mov    %rdi,%rbx
ffffffff81001b56:	48 83 ec 30          	sub    $0x30,%rsp
    bool neg = false;

    if (flags & FLAG_SIGNED && static_cast<signed long long>(val) < 0) {
ffffffff81001b5a:	41 f6 c0 01          	test   $0x1,%r8b
ffffffff81001b5e:	74 0b                	je     ffffffff81001b6b <_ZN7Console9print_numEyjjj+0x23>
ffffffff81001b60:	48 85 f6             	test   %rsi,%rsi
ffffffff81001b63:	79 06                	jns    ffffffff81001b6b <_ZN7Console9print_numEyjjj+0x23>
        neg = true;
        val = -val;
ffffffff81001b65:	48 f7 de             	neg    %rsi
void Console::print_num (uint64 val, unsigned base, unsigned width, unsigned flags)
{
    bool neg = false;

    if (flags & FLAG_SIGNED && static_cast<signed long long>(val) < 0) {
        neg = true;
ffffffff81001b68:	41 b1 01             	mov    $0x1,%r9b
        val = -val;
    }

    char buffer[24], *ptr = buffer + sizeof buffer;
ffffffff81001b6b:	4c 8d 64 24 30       	lea    0x30(%rsp),%r12
                  : "a"  (static_cast<uint32>(n >> 32)),
                    "d"  (0),
                    "1"  (static_cast<uint32>(n)),
                    "rm" (d));
#else
     q = n / d;
ffffffff81001b70:	89 d7                	mov    %edx,%edi
ffffffff81001b72:	48 89 f0             	mov    %rsi,%rax
ffffffff81001b75:	31 d2                	xor    %edx,%edx

    do {
        uint32 r;
        val = div64 (val, base, &r);
        *--ptr = r["0123456789abcdef"];
ffffffff81001b77:	49 ff cc             	dec    %r12
ffffffff81001b7a:	48 f7 f7             	div    %rdi
ffffffff81001b7d:	8a 92 44 d7 01 81    	mov    -0x7efe28bc(%rdx),%dl
        val = -val;
    }

    char buffer[24], *ptr = buffer + sizeof buffer;

    do {
ffffffff81001b83:	48 85 c0             	test   %rax,%rax
ffffffff81001b86:	48 89 c6             	mov    %rax,%rsi
        uint32 r;
        val = div64 (val, base, &r);
        *--ptr = r["0123456789abcdef"];
ffffffff81001b89:	41 88 14 24          	mov    %dl,(%r12)
        val = -val;
    }

    char buffer[24], *ptr = buffer + sizeof buffer;

    do {
ffffffff81001b8d:	75 e3                	jne    ffffffff81001b72 <_ZN7Console9print_numEyjjj+0x2a>
        uint32 r;
        val = div64 (val, base, &r);
        *--ptr = r["0123456789abcdef"];
    } while (val);

    if (neg)
ffffffff81001b8f:	45 84 c9             	test   %r9b,%r9b
ffffffff81001b92:	4c 89 e0             	mov    %r12,%rax
ffffffff81001b95:	74 07                	je     ffffffff81001b9e <_ZN7Console9print_numEyjjj+0x56>
        *--ptr = '-';
ffffffff81001b97:	49 ff cc             	dec    %r12
ffffffff81001b9a:	c6 40 ff 2d          	movb   $0x2d,-0x1(%rax)

    unsigned long count = buffer + sizeof buffer - ptr;
ffffffff81001b9e:	4c 8d 74 24 30       	lea    0x30(%rsp),%r14
    unsigned long n = count + (flags & FLAG_ALT_FORM ? 2 : 0);
ffffffff81001ba3:	44 89 c0             	mov    %r8d,%eax
ffffffff81001ba6:	41 89 cd             	mov    %ecx,%r13d
ffffffff81001ba9:	83 e0 02             	and    $0x2,%eax
    } while (val);

    if (neg)
        *--ptr = '-';

    unsigned long count = buffer + sizeof buffer - ptr;
ffffffff81001bac:	4d 29 e6             	sub    %r12,%r14
    unsigned long n = count + (flags & FLAG_ALT_FORM ? 2 : 0);
ffffffff81001baf:	48 63 e8             	movslq %eax,%rbp
ffffffff81001bb2:	4c 01 f5             	add    %r14,%rbp

    if (flags & FLAG_ZERO_PAD) {
ffffffff81001bb5:	41 f6 c0 04          	test   $0x4,%r8b
ffffffff81001bb9:	74 35                	je     ffffffff81001bf0 <_ZN7Console9print_numEyjjj+0xa8>
        if (flags & FLAG_ALT_FORM) {
ffffffff81001bbb:	85 c0                	test   %eax,%eax
ffffffff81001bbd:	74 1a                	je     ffffffff81001bd9 <_ZN7Console9print_numEyjjj+0x91>
            putc ('0');
ffffffff81001bbf:	48 8b 03             	mov    (%rbx),%rax
ffffffff81001bc2:	be 30 00 00 00       	mov    $0x30,%esi
ffffffff81001bc7:	48 89 df             	mov    %rbx,%rdi
ffffffff81001bca:	ff 10                	callq  *(%rax)
            putc ('x');
ffffffff81001bcc:	48 8b 03             	mov    (%rbx),%rax
ffffffff81001bcf:	be 78 00 00 00       	mov    $0x78,%esi
ffffffff81001bd4:	48 89 df             	mov    %rbx,%rdi
ffffffff81001bd7:	ff 10                	callq  *(%rax)
        }
        while (n++ < width)
ffffffff81001bd9:	4c 39 ed             	cmp    %r13,%rbp
ffffffff81001bdc:	73 53                	jae    ffffffff81001c31 <_ZN7Console9print_numEyjjj+0xe9>
            putc ('0');
ffffffff81001bde:	48 8b 03             	mov    (%rbx),%rax
ffffffff81001be1:	be 30 00 00 00       	mov    $0x30,%esi
ffffffff81001be6:	48 89 df             	mov    %rbx,%rdi
ffffffff81001be9:	48 ff c5             	inc    %rbp
ffffffff81001bec:	ff 10                	callq  *(%rax)
ffffffff81001bee:	eb e9                	jmp    ffffffff81001bd9 <_ZN7Console9print_numEyjjj+0x91>
    } else {
        while (n++ < width)
ffffffff81001bf0:	4c 39 ed             	cmp    %r13,%rbp
ffffffff81001bf3:	73 1c                	jae    ffffffff81001c11 <_ZN7Console9print_numEyjjj+0xc9>
            putc (' ');
ffffffff81001bf5:	48 8b 03             	mov    (%rbx),%rax
ffffffff81001bf8:	44 89 44 24 0c       	mov    %r8d,0xc(%rsp)
ffffffff81001bfd:	be 20 00 00 00       	mov    $0x20,%esi
ffffffff81001c02:	48 89 df             	mov    %rbx,%rdi
ffffffff81001c05:	48 ff c5             	inc    %rbp
ffffffff81001c08:	ff 10                	callq  *(%rax)
ffffffff81001c0a:	44 8b 44 24 0c       	mov    0xc(%rsp),%r8d
ffffffff81001c0f:	eb df                	jmp    ffffffff81001bf0 <_ZN7Console9print_numEyjjj+0xa8>
        if (flags & FLAG_ALT_FORM) {
ffffffff81001c11:	41 80 e0 02          	and    $0x2,%r8b
ffffffff81001c15:	74 1a                	je     ffffffff81001c31 <_ZN7Console9print_numEyjjj+0xe9>
            putc ('0');
ffffffff81001c17:	48 8b 03             	mov    (%rbx),%rax
ffffffff81001c1a:	be 30 00 00 00       	mov    $0x30,%esi
ffffffff81001c1f:	48 89 df             	mov    %rbx,%rdi
ffffffff81001c22:	ff 10                	callq  *(%rax)
            putc ('x');
ffffffff81001c24:	48 8b 03             	mov    (%rbx),%rax
ffffffff81001c27:	be 78 00 00 00       	mov    $0x78,%esi
ffffffff81001c2c:	48 89 df             	mov    %rbx,%rdi
ffffffff81001c2f:	ff 10                	callq  *(%rax)
        *--ptr = '-';

    unsigned long count = buffer + sizeof buffer - ptr;
    unsigned long n = count + (flags & FLAG_ALT_FORM ? 2 : 0);

    if (flags & FLAG_ZERO_PAD) {
ffffffff81001c31:	31 ed                	xor    %ebp,%ebp
            putc ('0');
            putc ('x');
        }
    }

    while (count--)
ffffffff81001c33:	4c 39 f5             	cmp    %r14,%rbp
ffffffff81001c36:	74 12                	je     ffffffff81001c4a <_ZN7Console9print_numEyjjj+0x102>
        putc (*ptr++);
ffffffff81001c38:	48 8b 03             	mov    (%rbx),%rax
ffffffff81001c3b:	41 0f be 34 2c       	movsbl (%r12,%rbp,1),%esi
ffffffff81001c40:	48 89 df             	mov    %rbx,%rdi
ffffffff81001c43:	48 ff c5             	inc    %rbp
ffffffff81001c46:	ff 10                	callq  *(%rax)
ffffffff81001c48:	eb e9                	jmp    ffffffff81001c33 <_ZN7Console9print_numEyjjj+0xeb>
}
ffffffff81001c4a:	48 83 c4 30          	add    $0x30,%rsp
ffffffff81001c4e:	5b                   	pop    %rbx
ffffffff81001c4f:	5d                   	pop    %rbp
ffffffff81001c50:	41 5c                	pop    %r12
ffffffff81001c52:	41 5d                	pop    %r13
ffffffff81001c54:	41 5e                	pop    %r14
ffffffff81001c56:	c3                   	retq   
ffffffff81001c57:	90                   	nop

ffffffff81001c58 <_ZN7Console9print_strEPKcjj>:

void Console::print_str (char const *s, unsigned width, unsigned precs)
{
    if (EXPECT_FALSE (!s))
ffffffff81001c58:	48 85 f6             	test   %rsi,%rsi
    while (count--)
        putc (*ptr++);
}

void Console::print_str (char const *s, unsigned width, unsigned precs)
{
ffffffff81001c5b:	41 57                	push   %r15
ffffffff81001c5d:	41 56                	push   %r14
ffffffff81001c5f:	49 89 f6             	mov    %rsi,%r14
ffffffff81001c62:	41 55                	push   %r13
ffffffff81001c64:	41 54                	push   %r12
ffffffff81001c66:	55                   	push   %rbp
ffffffff81001c67:	53                   	push   %rbx
ffffffff81001c68:	41 50                	push   %r8
    if (EXPECT_FALSE (!s))
ffffffff81001c6a:	74 49                	je     ffffffff81001cb5 <_ZN7Console9print_strEPKcjj+0x5d>
ffffffff81001c6c:	89 cb                	mov    %ecx,%ebx
ffffffff81001c6e:	49 89 fc             	mov    %rdi,%r12
ffffffff81001c71:	41 89 d5             	mov    %edx,%r13d
ffffffff81001c74:	48 01 f3             	add    %rsi,%rbx
ffffffff81001c77:	48 89 f5             	mov    %rsi,%rbp
        return;

    unsigned n;

    for (n = 0; *s && precs--; n++)
ffffffff81001c7a:	8a 45 00             	mov    0x0(%rbp),%al
ffffffff81001c7d:	41 89 ef             	mov    %ebp,%r15d
ffffffff81001c80:	45 29 f7             	sub    %r14d,%r15d
ffffffff81001c83:	84 c0                	test   %al,%al
ffffffff81001c85:	74 16                	je     ffffffff81001c9d <_ZN7Console9print_strEPKcjj+0x45>
ffffffff81001c87:	48 39 dd             	cmp    %rbx,%rbp
ffffffff81001c8a:	74 11                	je     ffffffff81001c9d <_ZN7Console9print_strEPKcjj+0x45>
        putc (*s++);
ffffffff81001c8c:	49 8b 14 24          	mov    (%r12),%rdx
ffffffff81001c90:	48 ff c5             	inc    %rbp
ffffffff81001c93:	0f be f0             	movsbl %al,%esi
ffffffff81001c96:	4c 89 e7             	mov    %r12,%rdi
ffffffff81001c99:	ff 12                	callq  *(%rdx)
ffffffff81001c9b:	eb dd                	jmp    ffffffff81001c7a <_ZN7Console9print_strEPKcjj+0x22>

    while (n++ < width)
ffffffff81001c9d:	45 39 ef             	cmp    %r13d,%r15d
ffffffff81001ca0:	73 13                	jae    ffffffff81001cb5 <_ZN7Console9print_strEPKcjj+0x5d>
        putc (' ');
ffffffff81001ca2:	49 8b 04 24          	mov    (%r12),%rax
ffffffff81001ca6:	be 20 00 00 00       	mov    $0x20,%esi
ffffffff81001cab:	4c 89 e7             	mov    %r12,%rdi
ffffffff81001cae:	41 ff c7             	inc    %r15d
ffffffff81001cb1:	ff 10                	callq  *(%rax)
ffffffff81001cb3:	eb e8                	jmp    ffffffff81001c9d <_ZN7Console9print_strEPKcjj+0x45>
}
ffffffff81001cb5:	58                   	pop    %rax
ffffffff81001cb6:	5b                   	pop    %rbx
ffffffff81001cb7:	5d                   	pop    %rbp
ffffffff81001cb8:	41 5c                	pop    %r12
ffffffff81001cba:	41 5d                	pop    %r13
ffffffff81001cbc:	41 5e                	pop    %r14
ffffffff81001cbe:	41 5f                	pop    %r15
ffffffff81001cc0:	c3                   	retq   
ffffffff81001cc1:	90                   	nop

ffffffff81001cc2 <_ZN7Console7vprintfEPKcP13__va_list_tag>:

void Console::vprintf (char const *format, va_list args)
{
ffffffff81001cc2:	41 56                	push   %r14
ffffffff81001cc4:	49 89 f6             	mov    %rsi,%r14
ffffffff81001cc7:	41 55                	push   %r13
                case 'c':
                    putc (va_arg (args, int));
                    break;

                case 's':
                    print_str (va_arg (args, char *), width, precs ? precs : ~0u);
ffffffff81001cc9:	41 83 cd ff          	or     $0xffffffff,%r13d
    while (n++ < width)
        putc (' ');
}

void Console::vprintf (char const *format, va_list args)
{
ffffffff81001ccd:	41 54                	push   %r12
ffffffff81001ccf:	55                   	push   %rbp
ffffffff81001cd0:	48 89 fd             	mov    %rdi,%rbp
ffffffff81001cd3:	53                   	push   %rbx
ffffffff81001cd4:	48 89 d3             	mov    %rdx,%rbx
    while (*format) {
ffffffff81001cd7:	41 0f be 36          	movsbl (%r14),%esi
ffffffff81001cdb:	40 84 f6             	test   %sil,%sil
ffffffff81001cde:	0f 84 53 02 00 00    	je     ffffffff81001f37 <_ZN7Console7vprintfEPKcP13__va_list_tag+0x275>

        if (EXPECT_TRUE (*format != '%')) {
ffffffff81001ce4:	40 80 fe 25          	cmp    $0x25,%sil
ffffffff81001ce8:	75 0d                	jne    ffffffff81001cf7 <_ZN7Console7vprintfEPKcP13__va_list_tag+0x35>
ffffffff81001cea:	31 d2                	xor    %edx,%edx
ffffffff81001cec:	31 f6                	xor    %esi,%esi
ffffffff81001cee:	31 c9                	xor    %ecx,%ecx
ffffffff81001cf0:	31 ff                	xor    %edi,%edi
ffffffff81001cf2:	45 31 c0             	xor    %r8d,%r8d
ffffffff81001cf5:	eb 1c                	jmp    ffffffff81001d13 <_ZN7Console7vprintfEPKcP13__va_list_tag+0x51>
            putc (*format++);
ffffffff81001cf7:	48 8b 45 00          	mov    0x0(%rbp),%rax
ffffffff81001cfb:	49 ff c6             	inc    %r14
ffffffff81001cfe:	48 89 ef             	mov    %rbp,%rdi
ffffffff81001d01:	ff 10                	callq  *(%rax)
            continue;
ffffffff81001d03:	eb d2                	jmp    ffffffff81001cd7 <_ZN7Console7vprintfEPKcP13__va_list_tag+0x15>

        unsigned flags = 0, width = 0, precs = 0, len = 0, mode = MODE_FLAGS;

        for (uint64 u;;) {

            switch (*++format) {
ffffffff81001d05:	7f 4d                	jg     ffffffff81001d54 <_ZN7Console7vprintfEPKcP13__va_list_tag+0x92>
ffffffff81001d07:	3c 2e                	cmp    $0x2e,%al
ffffffff81001d09:	75 1a                	jne    ffffffff81001d25 <_ZN7Console7vprintfEPKcP13__va_list_tag+0x63>
                        case MODE_PRECS: precs = precs * 10 + *format - '0'; break;
                    }
                    continue;

                case '.':
                    mode = MODE_PRECS;
ffffffff81001d0b:	ba 02 00 00 00       	mov    $0x2,%edx

void Console::vprintf (char const *format, va_list args)
{
    while (*format) {

        if (EXPECT_TRUE (*format != '%')) {
ffffffff81001d10:	4d 89 e6             	mov    %r12,%r14

        unsigned flags = 0, width = 0, precs = 0, len = 0, mode = MODE_FLAGS;

        for (uint64 u;;) {

            switch (*++format) {
ffffffff81001d13:	41 0f be 46 01       	movsbl 0x1(%r14),%eax
ffffffff81001d18:	4d 8d 66 01          	lea    0x1(%r14),%r12
ffffffff81001d1c:	3c 63                	cmp    $0x63,%al
ffffffff81001d1e:	75 e5                	jne    ffffffff81001d05 <_ZN7Console7vprintfEPKcP13__va_list_tag+0x43>
ffffffff81001d20:	e9 9c 00 00 00       	jmpq   ffffffff81001dc1 <_ZN7Console7vprintfEPKcP13__va_list_tag+0xff>
ffffffff81001d25:	7f 1e                	jg     ffffffff81001d45 <_ZN7Console7vprintfEPKcP13__va_list_tag+0x83>
ffffffff81001d27:	84 c0                	test   %al,%al
ffffffff81001d29:	0f 84 ed 01 00 00    	je     ffffffff81001f1c <_ZN7Console7vprintfEPKcP13__va_list_tag+0x25a>
ffffffff81001d2f:	3c 23                	cmp    $0x23,%al
ffffffff81001d31:	0f 85 e8 01 00 00    	jne    ffffffff81001f1f <_ZN7Console7vprintfEPKcP13__va_list_tag+0x25d>
                    mode = MODE_PRECS;
                    continue;

                case '#':
                    if (mode == MODE_FLAGS)
                        flags |= FLAG_ALT_FORM;
ffffffff81001d37:	44 89 c0             	mov    %r8d,%eax
ffffffff81001d3a:	83 c8 02             	or     $0x2,%eax
ffffffff81001d3d:	85 d2                	test   %edx,%edx
ffffffff81001d3f:	44 0f 44 c0          	cmove  %eax,%r8d
ffffffff81001d43:	eb cb                	jmp    ffffffff81001d10 <_ZN7Console7vprintfEPKcP13__va_list_tag+0x4e>

        unsigned flags = 0, width = 0, precs = 0, len = 0, mode = MODE_FLAGS;

        for (uint64 u;;) {

            switch (*++format) {
ffffffff81001d45:	44 8d 48 d0          	lea    -0x30(%rax),%r9d
ffffffff81001d49:	41 80 f9 09          	cmp    $0x9,%r9b
ffffffff81001d4d:	76 3c                	jbe    ffffffff81001d8b <_ZN7Console7vprintfEPKcP13__va_list_tag+0xc9>
ffffffff81001d4f:	e9 cb 01 00 00       	jmpq   ffffffff81001f1f <_ZN7Console7vprintfEPKcP13__va_list_tag+0x25d>
ffffffff81001d54:	3c 70                	cmp    $0x70,%al
ffffffff81001d56:	0f 84 8e 01 00 00    	je     ffffffff81001eea <_ZN7Console7vprintfEPKcP13__va_list_tag+0x228>
ffffffff81001d5c:	7f 14                	jg     ffffffff81001d72 <_ZN7Console7vprintfEPKcP13__va_list_tag+0xb0>
ffffffff81001d5e:	3c 64                	cmp    $0x64,%al
ffffffff81001d60:	0f 84 c6 00 00 00    	je     ffffffff81001e2c <_ZN7Console7vprintfEPKcP13__va_list_tag+0x16a>
ffffffff81001d66:	3c 6c                	cmp    $0x6c,%al
ffffffff81001d68:	0f 85 b1 01 00 00    	jne    ffffffff81001f1f <_ZN7Console7vprintfEPKcP13__va_list_tag+0x25d>
                    if (mode == MODE_FLAGS)
                        flags |= FLAG_ALT_FORM;
                    continue;

                case 'l':
                    len++;
ffffffff81001d6e:	ff c6                	inc    %esi
                    continue;
ffffffff81001d70:	eb 9e                	jmp    ffffffff81001d10 <_ZN7Console7vprintfEPKcP13__va_list_tag+0x4e>

        unsigned flags = 0, width = 0, precs = 0, len = 0, mode = MODE_FLAGS;

        for (uint64 u;;) {

            switch (*++format) {
ffffffff81001d72:	3c 75                	cmp    $0x75,%al
ffffffff81001d74:	0f 84 09 01 00 00    	je     ffffffff81001e83 <_ZN7Console7vprintfEPKcP13__va_list_tag+0x1c1>
ffffffff81001d7a:	3c 78                	cmp    $0x78,%al
ffffffff81001d7c:	0f 84 01 01 00 00    	je     ffffffff81001e83 <_ZN7Console7vprintfEPKcP13__va_list_tag+0x1c1>
ffffffff81001d82:	3c 73                	cmp    $0x73,%al
ffffffff81001d84:	74 6e                	je     ffffffff81001df4 <_ZN7Console7vprintfEPKcP13__va_list_tag+0x132>
ffffffff81001d86:	e9 94 01 00 00       	jmpq   ffffffff81001f1f <_ZN7Console7vprintfEPKcP13__va_list_tag+0x25d>

                case '0'...'9':
                    switch (mode) {
ffffffff81001d8b:	83 fa 01             	cmp    $0x1,%edx
ffffffff81001d8e:	74 14                	je     ffffffff81001da4 <_ZN7Console7vprintfEPKcP13__va_list_tag+0xe2>
ffffffff81001d90:	83 fa 02             	cmp    $0x2,%edx
ffffffff81001d93:	74 20                	je     ffffffff81001db5 <_ZN7Console7vprintfEPKcP13__va_list_tag+0xf3>
                        case MODE_FLAGS:
                            if (*format == '0') {
ffffffff81001d95:	3c 30                	cmp    $0x30,%al
ffffffff81001d97:	75 0b                	jne    ffffffff81001da4 <_ZN7Console7vprintfEPKcP13__va_list_tag+0xe2>
                                flags |= FLAG_ZERO_PAD;
ffffffff81001d99:	41 83 c8 04          	or     $0x4,%r8d
                                break;
ffffffff81001d9d:	31 d2                	xor    %edx,%edx
ffffffff81001d9f:	e9 6c ff ff ff       	jmpq   ffffffff81001d10 <_ZN7Console7vprintfEPKcP13__va_list_tag+0x4e>
                            }
                            mode = MODE_WIDTH;
                        case MODE_WIDTH: width = width * 10 + *format - '0'; break;
ffffffff81001da4:	6b ff 0a             	imul   $0xa,%edi,%edi
ffffffff81001da7:	ba 01 00 00 00       	mov    $0x1,%edx
ffffffff81001dac:	8d 7c 07 d0          	lea    -0x30(%rdi,%rax,1),%edi
ffffffff81001db0:	e9 5b ff ff ff       	jmpq   ffffffff81001d10 <_ZN7Console7vprintfEPKcP13__va_list_tag+0x4e>
                        case MODE_PRECS: precs = precs * 10 + *format - '0'; break;
ffffffff81001db5:	6b c9 0a             	imul   $0xa,%ecx,%ecx
ffffffff81001db8:	8d 4c 01 d0          	lea    -0x30(%rcx,%rax,1),%ecx
ffffffff81001dbc:	e9 4f ff ff ff       	jmpq   ffffffff81001d10 <_ZN7Console7vprintfEPKcP13__va_list_tag+0x4e>
                case 'l':
                    len++;
                    continue;

                case 'c':
                    putc (va_arg (args, int));
ffffffff81001dc1:	8b 13                	mov    (%rbx),%edx
ffffffff81001dc3:	48 8b 45 00          	mov    0x0(%rbp),%rax
ffffffff81001dc7:	83 fa 30             	cmp    $0x30,%edx
ffffffff81001dca:	48 8b 08             	mov    (%rax),%rcx
ffffffff81001dcd:	73 0d                	jae    ffffffff81001ddc <_ZN7Console7vprintfEPKcP13__va_list_tag+0x11a>
ffffffff81001dcf:	89 d0                	mov    %edx,%eax
ffffffff81001dd1:	83 c2 08             	add    $0x8,%edx
ffffffff81001dd4:	48 03 43 10          	add    0x10(%rbx),%rax
ffffffff81001dd8:	89 13                	mov    %edx,(%rbx)
ffffffff81001dda:	eb 0c                	jmp    ffffffff81001de8 <_ZN7Console7vprintfEPKcP13__va_list_tag+0x126>
ffffffff81001ddc:	48 8b 43 08          	mov    0x8(%rbx),%rax
ffffffff81001de0:	48 8d 50 08          	lea    0x8(%rax),%rdx
ffffffff81001de4:	48 89 53 08          	mov    %rdx,0x8(%rbx)
ffffffff81001de8:	8b 30                	mov    (%rax),%esi
ffffffff81001dea:	48 89 ef             	mov    %rbp,%rdi
ffffffff81001ded:	ff d1                	callq  *%rcx
                    break;
ffffffff81001def:	e9 39 01 00 00       	jmpq   ffffffff81001f2d <_ZN7Console7vprintfEPKcP13__va_list_tag+0x26b>

                case 's':
                    print_str (va_arg (args, char *), width, precs ? precs : ~0u);
ffffffff81001df4:	8b 13                	mov    (%rbx),%edx
ffffffff81001df6:	85 c9                	test   %ecx,%ecx
ffffffff81001df8:	41 0f 44 cd          	cmove  %r13d,%ecx
ffffffff81001dfc:	83 fa 30             	cmp    $0x30,%edx
ffffffff81001dff:	73 0d                	jae    ffffffff81001e0e <_ZN7Console7vprintfEPKcP13__va_list_tag+0x14c>
ffffffff81001e01:	89 d0                	mov    %edx,%eax
ffffffff81001e03:	83 c2 08             	add    $0x8,%edx
ffffffff81001e06:	48 03 43 10          	add    0x10(%rbx),%rax
ffffffff81001e0a:	89 13                	mov    %edx,(%rbx)
ffffffff81001e0c:	eb 0c                	jmp    ffffffff81001e1a <_ZN7Console7vprintfEPKcP13__va_list_tag+0x158>
ffffffff81001e0e:	48 8b 43 08          	mov    0x8(%rbx),%rax
ffffffff81001e12:	48 8d 50 08          	lea    0x8(%rax),%rdx
ffffffff81001e16:	48 89 53 08          	mov    %rdx,0x8(%rbx)
ffffffff81001e1a:	48 8b 30             	mov    (%rax),%rsi
ffffffff81001e1d:	89 fa                	mov    %edi,%edx
ffffffff81001e1f:	48 89 ef             	mov    %rbp,%rdi
ffffffff81001e22:	e8 31 fe ff ff       	callq  ffffffff81001c58 <_ZN7Console9print_strEPKcjj>
                    break;
ffffffff81001e27:	e9 01 01 00 00       	jmpq   ffffffff81001f2d <_ZN7Console7vprintfEPKcP13__va_list_tag+0x26b>

                case 'd':
                    switch (len) {
ffffffff81001e2c:	85 f6                	test   %esi,%esi
ffffffff81001e2e:	8b 03                	mov    (%rbx),%eax
ffffffff81001e30:	75 23                	jne    ffffffff81001e55 <_ZN7Console7vprintfEPKcP13__va_list_tag+0x193>
                        case 0:  u = va_arg (args, int);        break;
ffffffff81001e32:	83 f8 30             	cmp    $0x30,%eax
ffffffff81001e35:	73 0d                	jae    ffffffff81001e44 <_ZN7Console7vprintfEPKcP13__va_list_tag+0x182>
ffffffff81001e37:	89 c2                	mov    %eax,%edx
ffffffff81001e39:	83 c0 08             	add    $0x8,%eax
ffffffff81001e3c:	48 03 53 10          	add    0x10(%rbx),%rdx
ffffffff81001e40:	89 03                	mov    %eax,(%rbx)
ffffffff81001e42:	eb 0c                	jmp    ffffffff81001e50 <_ZN7Console7vprintfEPKcP13__va_list_tag+0x18e>
ffffffff81001e44:	48 8b 53 08          	mov    0x8(%rbx),%rdx
ffffffff81001e48:	48 8d 42 08          	lea    0x8(%rdx),%rax
ffffffff81001e4c:	48 89 43 08          	mov    %rax,0x8(%rbx)
ffffffff81001e50:	48 63 32             	movslq (%rdx),%rsi
ffffffff81001e53:	eb 21                	jmp    ffffffff81001e76 <_ZN7Console7vprintfEPKcP13__va_list_tag+0x1b4>
                        case 1:  u = va_arg (args, long);       break;
                        default: u = va_arg (args, long long);  break;
ffffffff81001e55:	83 f8 30             	cmp    $0x30,%eax
ffffffff81001e58:	73 0d                	jae    ffffffff81001e67 <_ZN7Console7vprintfEPKcP13__va_list_tag+0x1a5>
ffffffff81001e5a:	89 c2                	mov    %eax,%edx
ffffffff81001e5c:	83 c0 08             	add    $0x8,%eax
ffffffff81001e5f:	48 03 53 10          	add    0x10(%rbx),%rdx
ffffffff81001e63:	89 03                	mov    %eax,(%rbx)
ffffffff81001e65:	eb 0c                	jmp    ffffffff81001e73 <_ZN7Console7vprintfEPKcP13__va_list_tag+0x1b1>
ffffffff81001e67:	48 8b 53 08          	mov    0x8(%rbx),%rdx
ffffffff81001e6b:	48 8d 42 08          	lea    0x8(%rdx),%rax
ffffffff81001e6f:	48 89 43 08          	mov    %rax,0x8(%rbx)
ffffffff81001e73:	48 8b 32             	mov    (%rdx),%rsi
                    }
                    print_num (u, 10, width, flags | FLAG_SIGNED);
ffffffff81001e76:	41 83 c8 01          	or     $0x1,%r8d
ffffffff81001e7a:	89 f9                	mov    %edi,%ecx
ffffffff81001e7c:	ba 0a 00 00 00       	mov    $0xa,%edx
ffffffff81001e81:	eb 5d                	jmp    ffffffff81001ee0 <_ZN7Console7vprintfEPKcP13__va_list_tag+0x21e>
                    break;

                case 'u':
                case 'x':
                    switch (len) {
ffffffff81001e83:	85 f6                	test   %esi,%esi
ffffffff81001e85:	8b 03                	mov    (%rbx),%eax
ffffffff81001e87:	75 22                	jne    ffffffff81001eab <_ZN7Console7vprintfEPKcP13__va_list_tag+0x1e9>
                        case 0:  u = va_arg (args, unsigned int);        break;
ffffffff81001e89:	83 f8 30             	cmp    $0x30,%eax
ffffffff81001e8c:	73 0d                	jae    ffffffff81001e9b <_ZN7Console7vprintfEPKcP13__va_list_tag+0x1d9>
ffffffff81001e8e:	89 c2                	mov    %eax,%edx
ffffffff81001e90:	83 c0 08             	add    $0x8,%eax
ffffffff81001e93:	48 03 53 10          	add    0x10(%rbx),%rdx
ffffffff81001e97:	89 03                	mov    %eax,(%rbx)
ffffffff81001e99:	eb 0c                	jmp    ffffffff81001ea7 <_ZN7Console7vprintfEPKcP13__va_list_tag+0x1e5>
ffffffff81001e9b:	48 8b 53 08          	mov    0x8(%rbx),%rdx
ffffffff81001e9f:	48 8d 42 08          	lea    0x8(%rdx),%rax
ffffffff81001ea3:	48 89 43 08          	mov    %rax,0x8(%rbx)
ffffffff81001ea7:	8b 32                	mov    (%rdx),%esi
ffffffff81001ea9:	eb 21                	jmp    ffffffff81001ecc <_ZN7Console7vprintfEPKcP13__va_list_tag+0x20a>
                        case 1:  u = va_arg (args, unsigned long);       break;
                        default: u = va_arg (args, unsigned long long);  break;
ffffffff81001eab:	83 f8 30             	cmp    $0x30,%eax
ffffffff81001eae:	73 0d                	jae    ffffffff81001ebd <_ZN7Console7vprintfEPKcP13__va_list_tag+0x1fb>
ffffffff81001eb0:	89 c2                	mov    %eax,%edx
ffffffff81001eb2:	83 c0 08             	add    $0x8,%eax
ffffffff81001eb5:	48 03 53 10          	add    0x10(%rbx),%rdx
ffffffff81001eb9:	89 03                	mov    %eax,(%rbx)
ffffffff81001ebb:	eb 0c                	jmp    ffffffff81001ec9 <_ZN7Console7vprintfEPKcP13__va_list_tag+0x207>
ffffffff81001ebd:	48 8b 53 08          	mov    0x8(%rbx),%rdx
ffffffff81001ec1:	48 8d 42 08          	lea    0x8(%rdx),%rax
ffffffff81001ec5:	48 89 43 08          	mov    %rax,0x8(%rbx)
ffffffff81001ec9:	48 8b 32             	mov    (%rdx),%rsi
                    }
                    print_num (u, *format == 'x' ? 16 : 10, width, flags);
ffffffff81001ecc:	41 80 3c 24 78       	cmpb   $0x78,(%r12)
ffffffff81001ed1:	ba 0a 00 00 00       	mov    $0xa,%edx
ffffffff81001ed6:	b8 10 00 00 00       	mov    $0x10,%eax
ffffffff81001edb:	89 f9                	mov    %edi,%ecx
ffffffff81001edd:	0f 44 d0             	cmove  %eax,%edx
ffffffff81001ee0:	48 89 ef             	mov    %rbp,%rdi
ffffffff81001ee3:	e8 60 fc ff ff       	callq  ffffffff81001b48 <_ZN7Console9print_numEyjjj>
                    break;
ffffffff81001ee8:	eb 43                	jmp    ffffffff81001f2d <_ZN7Console7vprintfEPKcP13__va_list_tag+0x26b>

                case 'p':
                    print_num (reinterpret_cast<mword>(va_arg (args, void *)), 16, width, FLAG_ALT_FORM);
ffffffff81001eea:	8b 13                	mov    (%rbx),%edx
ffffffff81001eec:	83 fa 30             	cmp    $0x30,%edx
ffffffff81001eef:	73 0d                	jae    ffffffff81001efe <_ZN7Console7vprintfEPKcP13__va_list_tag+0x23c>
ffffffff81001ef1:	89 d0                	mov    %edx,%eax
ffffffff81001ef3:	83 c2 08             	add    $0x8,%edx
ffffffff81001ef6:	48 03 43 10          	add    0x10(%rbx),%rax
ffffffff81001efa:	89 13                	mov    %edx,(%rbx)
ffffffff81001efc:	eb 0c                	jmp    ffffffff81001f0a <_ZN7Console7vprintfEPKcP13__va_list_tag+0x248>
ffffffff81001efe:	48 8b 43 08          	mov    0x8(%rbx),%rax
ffffffff81001f02:	48 8d 50 08          	lea    0x8(%rax),%rdx
ffffffff81001f06:	48 89 53 08          	mov    %rdx,0x8(%rbx)
ffffffff81001f0a:	41 b8 02 00 00 00    	mov    $0x2,%r8d
ffffffff81001f10:	89 f9                	mov    %edi,%ecx
ffffffff81001f12:	ba 10 00 00 00       	mov    $0x10,%edx
ffffffff81001f17:	48 8b 30             	mov    (%rax),%rsi
ffffffff81001f1a:	eb c4                	jmp    ffffffff81001ee0 <_ZN7Console7vprintfEPKcP13__va_list_tag+0x21e>

        unsigned flags = 0, width = 0, precs = 0, len = 0, mode = MODE_FLAGS;

        for (uint64 u;;) {

            switch (*++format) {
ffffffff81001f1c:	4d 89 f4             	mov    %r14,%r12

                case 0:
                    format--;

                default:
                    putc (*format);
ffffffff81001f1f:	48 8b 45 00          	mov    0x0(%rbp),%rax
ffffffff81001f23:	41 0f be 34 24       	movsbl (%r12),%esi
ffffffff81001f28:	48 89 ef             	mov    %rbp,%rdi
ffffffff81001f2b:	ff 10                	callq  *(%rax)
                    break;
            }

            format++;
ffffffff81001f2d:	4d 8d 74 24 01       	lea    0x1(%r12),%r14

            break;
ffffffff81001f32:	e9 a0 fd ff ff       	jmpq   ffffffff81001cd7 <_ZN7Console7vprintfEPKcP13__va_list_tag+0x15>
        }
    }

    putc ('\n');
ffffffff81001f37:	48 8b 45 00          	mov    0x0(%rbp),%rax
ffffffff81001f3b:	48 89 ef             	mov    %rbp,%rdi
ffffffff81001f3e:	be 0a 00 00 00       	mov    $0xa,%esi
}
ffffffff81001f43:	5b                   	pop    %rbx
ffffffff81001f44:	5d                   	pop    %rbp
ffffffff81001f45:	41 5c                	pop    %r12
ffffffff81001f47:	41 5d                	pop    %r13
ffffffff81001f49:	41 5e                	pop    %r14

            break;
        }
    }

    putc ('\n');
ffffffff81001f4b:	48 8b 00             	mov    (%rax),%rax
ffffffff81001f4e:	ff e0                	jmpq   *%rax

ffffffff81001f50 <_ZN7Console5panicEPKcz>:
        va_end (args);
    }
}

void Console::panic (char const *format, ...)
{
ffffffff81001f50:	41 54                	push   %r12
ffffffff81001f52:	55                   	push   %rbp
ffffffff81001f53:	53                   	push   %rbx
ffffffff81001f54:	48 81 ec d0 00 00 00 	sub    $0xd0,%rsp
ffffffff81001f5b:	84 c0                	test   %al,%al
ffffffff81001f5d:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
ffffffff81001f62:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
ffffffff81001f67:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
ffffffff81001f6c:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
ffffffff81001f71:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
ffffffff81001f76:	74 37                	je     ffffffff81001faf <_ZN7Console5panicEPKcz+0x5f>
ffffffff81001f78:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
ffffffff81001f7d:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
ffffffff81001f82:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
ffffffff81001f87:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
ffffffff81001f8e:	00 
ffffffff81001f8f:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
ffffffff81001f96:	00 
ffffffff81001f97:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
ffffffff81001f9e:	00 
ffffffff81001f9f:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
ffffffff81001fa6:	00 
ffffffff81001fa7:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
ffffffff81001fae:	00 
ffffffff81001faf:	49 89 fc             	mov    %rdi,%r12

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81001fb2:	9c                   	pushfq 
ffffffff81001fb3:	58                   	pop    %rax
            return flags & 0x200;
ffffffff81001fb4:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff81001fb8:	88 c3                	mov    %al,%bl
ffffffff81001fba:	80 e3 01             	and    $0x1,%bl
ffffffff81001fbd:	74 30                	je     ffffffff81001fef <_ZN7Console5panicEPKcz+0x9f>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81001fbf:	80 3d 6a d7 ff 3e 00 	cmpb   $0x0,0x3effd76a(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81001fc6:	75 1f                	jne    ffffffff81001fe7 <_ZN7Console5panicEPKcz+0x97>
ffffffff81001fc8:	49 c7 c0 90 d7 01 81 	mov    $0xffffffff8101d790,%r8
ffffffff81001fcf:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff81001fd4:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81001fdb:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff81001fe2:	e9 8a 00 00 00       	jmpq   ffffffff81002071 <_ZN7Console5panicEPKcz+0x121>

            asm volatile ("cli" : : : "memory");
ffffffff81001fe7:	fa                   	cli    
            preemption = false;
ffffffff81001fe8:	c6 05 41 d7 ff 3e 00 	movb   $0x0,0x3effd741(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff81001fef:	48 c7 c7 a2 1d 02 81 	mov    $0xffffffff81021da2,%rdi
ffffffff81001ff6:	e8 93 ee ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    {   Lock_guard <Spinlock> guard (lock);

        for (Console *c = list; c; c = c->next) {
ffffffff81001ffb:	48 8b 2d a6 fd 01 00 	mov    0x1fda6(%rip),%rbp        # ffffffff81021da8 <_ZN7Console4listE>
ffffffff81002002:	48 85 ed             	test   %rbp,%rbp
ffffffff81002005:	74 3d                	je     ffffffff81002044 <_ZN7Console5panicEPKcz+0xf4>
            va_list args;
            va_start (args, format);
ffffffff81002007:	48 8d 84 24 f0 00 00 	lea    0xf0(%rsp),%rax
ffffffff8100200e:	00 
            c->vprintf (format, args);
ffffffff8100200f:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
ffffffff81002014:	48 89 ef             	mov    %rbp,%rdi
ffffffff81002017:	4c 89 e6             	mov    %r12,%rsi
{
    {   Lock_guard <Spinlock> guard (lock);

        for (Console *c = list; c; c = c->next) {
            va_list args;
            va_start (args, format);
ffffffff8100201a:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%rsp)
ffffffff81002021:	00 
ffffffff81002022:	c7 44 24 0c 30 00 00 	movl   $0x30,0xc(%rsp)
ffffffff81002029:	00 
ffffffff8100202a:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
ffffffff8100202f:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
ffffffff81002034:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
            c->vprintf (format, args);
ffffffff81002039:	e8 84 fc ff ff       	callq  ffffffff81001cc2 <_ZN7Console7vprintfEPKcP13__va_list_tag>

void Console::panic (char const *format, ...)
{
    {   Lock_guard <Spinlock> guard (lock);

        for (Console *c = list; c; c = c->next) {
ffffffff8100203e:	48 8b 6d 08          	mov    0x8(%rbp),%rbp
ffffffff81002042:	eb be                	jmp    ffffffff81002002 <_ZN7Console5panicEPKcz+0xb2>
        }

        ALWAYS_INLINE
        inline void unlock()
        {
            asm volatile ("incb %0" : "=m" (val) : : "memory");
ffffffff81002044:	fe 05 58 fd 01 00    	incb   0x1fd58(%rip)        # ffffffff81021da2 <_ZN7Console4lockE>
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff8100204a:	84 db                	test   %bl,%bl
ffffffff8100204c:	74 39                	je     ffffffff81002087 <_ZN7Console5panicEPKcz+0x137>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100204e:	80 3d db d6 ff 3e 00 	cmpb   $0x0,0x3effd6db(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81002055:	74 28                	je     ffffffff8100207f <_ZN7Console5panicEPKcz+0x12f>
ffffffff81002057:	49 c7 c0 60 d7 01 81 	mov    $0xffffffff8101d760,%r8
ffffffff8100205e:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff81002063:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100206a:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff81002071:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81002078:	31 c0                	xor    %eax,%eax
ffffffff8100207a:	e8 d1 fe ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            preemption = true;
ffffffff8100207f:	c6 05 aa d6 ff 3e 01 	movb   $0x1,0x3effd6aa(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81002086:	fb                   	sti    

ALWAYS_INLINE NORETURN
inline void shutdown()
{
    for (;;)
        asm volatile ("cli; hlt");
ffffffff81002087:	fa                   	cli    
ffffffff81002088:	f4                   	hlt    
ffffffff81002089:	eb fc                	jmp    ffffffff81002087 <_ZN7Console5panicEPKcz+0x137>
ffffffff8100208b:	90                   	nop

ffffffff8100208c <_ZN7Console5printEPKcz>:

    putc ('\n');
}

void Console::print (char const *format, ...)
{
ffffffff8100208c:	41 54                	push   %r12
ffffffff8100208e:	55                   	push   %rbp
ffffffff8100208f:	53                   	push   %rbx
ffffffff81002090:	48 81 ec d0 00 00 00 	sub    $0xd0,%rsp
ffffffff81002097:	84 c0                	test   %al,%al
ffffffff81002099:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
ffffffff8100209e:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
ffffffff810020a3:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
ffffffff810020a8:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
ffffffff810020ad:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
ffffffff810020b2:	74 37                	je     ffffffff810020eb <_ZN7Console5printEPKcz+0x5f>
ffffffff810020b4:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
ffffffff810020b9:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
ffffffff810020be:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
ffffffff810020c3:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
ffffffff810020ca:	00 
ffffffff810020cb:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
ffffffff810020d2:	00 
ffffffff810020d3:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
ffffffff810020da:	00 
ffffffff810020db:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
ffffffff810020e2:	00 
ffffffff810020e3:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
ffffffff810020ea:	00 
ffffffff810020eb:	49 89 fc             	mov    %rdi,%r12

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff810020ee:	9c                   	pushfq 
ffffffff810020ef:	58                   	pop    %rax
            return flags & 0x200;
ffffffff810020f0:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff810020f4:	88 c3                	mov    %al,%bl
ffffffff810020f6:	80 e3 01             	and    $0x1,%bl
ffffffff810020f9:	74 30                	je     ffffffff8100212b <_ZN7Console5printEPKcz+0x9f>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff810020fb:	80 3d 2e d6 ff 3e 00 	cmpb   $0x0,0x3effd62e(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81002102:	75 1f                	jne    ffffffff81002123 <_ZN7Console5printEPKcz+0x97>
ffffffff81002104:	49 c7 c0 90 d7 01 81 	mov    $0xffffffff8101d790,%r8
ffffffff8100210b:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff81002110:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81002117:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff8100211e:	e9 8a 00 00 00       	jmpq   ffffffff810021ad <_ZN7Console5printEPKcz+0x121>

            asm volatile ("cli" : : : "memory");
ffffffff81002123:	fa                   	cli    
            preemption = false;
ffffffff81002124:	c6 05 05 d6 ff 3e 00 	movb   $0x0,0x3effd605(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff8100212b:	48 c7 c7 a2 1d 02 81 	mov    $0xffffffff81021da2,%rdi
ffffffff81002132:	e8 57 ed ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    Lock_guard <Spinlock> guard (lock);

    for (Console *c = list; c; c = c->next) {
ffffffff81002137:	48 8b 2d 6a fc 01 00 	mov    0x1fc6a(%rip),%rbp        # ffffffff81021da8 <_ZN7Console4listE>
ffffffff8100213e:	48 85 ed             	test   %rbp,%rbp
ffffffff81002141:	74 3d                	je     ffffffff81002180 <_ZN7Console5printEPKcz+0xf4>
        va_list args;
        va_start (args, format);
ffffffff81002143:	48 8d 84 24 f0 00 00 	lea    0xf0(%rsp),%rax
ffffffff8100214a:	00 
        c->vprintf (format, args);
ffffffff8100214b:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
ffffffff81002150:	48 89 ef             	mov    %rbp,%rdi
ffffffff81002153:	4c 89 e6             	mov    %r12,%rsi
{
    Lock_guard <Spinlock> guard (lock);

    for (Console *c = list; c; c = c->next) {
        va_list args;
        va_start (args, format);
ffffffff81002156:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%rsp)
ffffffff8100215d:	00 
ffffffff8100215e:	c7 44 24 0c 30 00 00 	movl   $0x30,0xc(%rsp)
ffffffff81002165:	00 
ffffffff81002166:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
ffffffff8100216b:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
ffffffff81002170:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
        c->vprintf (format, args);
ffffffff81002175:	e8 48 fb ff ff       	callq  ffffffff81001cc2 <_ZN7Console7vprintfEPKcP13__va_list_tag>

void Console::print (char const *format, ...)
{
    Lock_guard <Spinlock> guard (lock);

    for (Console *c = list; c; c = c->next) {
ffffffff8100217a:	48 8b 6d 08          	mov    0x8(%rbp),%rbp
ffffffff8100217e:	eb be                	jmp    ffffffff8100213e <_ZN7Console5printEPKcz+0xb2>
ffffffff81002180:	fe 05 1c fc 01 00    	incb   0x1fc1c(%rip)        # ffffffff81021da2 <_ZN7Console4lockE>
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81002186:	84 db                	test   %bl,%bl
ffffffff81002188:	74 39                	je     ffffffff810021c3 <_ZN7Console5printEPKcz+0x137>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100218a:	80 3d 9f d5 ff 3e 00 	cmpb   $0x0,0x3effd59f(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81002191:	74 28                	je     ffffffff810021bb <_ZN7Console5printEPKcz+0x12f>
ffffffff81002193:	49 c7 c0 60 d7 01 81 	mov    $0xffffffff8101d760,%r8
ffffffff8100219a:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff8100219f:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff810021a6:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff810021ad:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff810021b4:	31 c0                	xor    %eax,%eax
ffffffff810021b6:	e8 95 fd ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            preemption = true;
ffffffff810021bb:	c6 05 6e d5 ff 3e 01 	movb   $0x1,0x3effd56e(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff810021c2:	fb                   	sti    
        va_list args;
        va_start (args, format);
        c->vprintf (format, args);
        va_end (args);
    }
}
ffffffff810021c3:	48 81 c4 d0 00 00 00 	add    $0xd0,%rsp
ffffffff810021ca:	5b                   	pop    %rbx
ffffffff810021cb:	5d                   	pop    %rbp
ffffffff810021cc:	41 5c                	pop    %r12
ffffffff810021ce:	c3                   	retq   

ffffffff810021cf <_GLOBAL__sub_I__ZN7Console4listE>:
    private:
        uint16 val;

    public:
        ALWAYS_INLINE
        inline Spinlock() : val (0) {}
ffffffff810021cf:	66 c7 05 ca fb 01 00 	movw   $0x0,0x1fbca(%rip)        # ffffffff81021da2 <_ZN7Console4lockE>
ffffffff810021d6:	00 00 
ffffffff810021d8:	c3                   	retq   
ffffffff810021d9:	90                   	nop

ffffffff810021da <_ZN14Console_serial4putcEi>:

void Console_serial::putc (int c)
{
    if (c == '\n')
ffffffff810021da:	83 fe 0a             	cmp    $0xa,%esi

    enable();
}

void Console_serial::putc (int c)
{
ffffffff810021dd:	55                   	push   %rbp
ffffffff810021de:	53                   	push   %rbx
ffffffff810021df:	89 f5                	mov    %esi,%ebp
ffffffff810021e1:	52                   	push   %rdx
ffffffff810021e2:	48 89 fb             	mov    %rdi,%rbx
    if (c == '\n')
ffffffff810021e5:	75 0a                	jne    ffffffff810021f1 <_ZN14Console_serial4putcEi+0x17>
        putc ('\r');
ffffffff810021e7:	48 8b 07             	mov    (%rdi),%rax
ffffffff810021ea:	be 0d 00 00 00       	mov    $0xd,%esi
ffffffff810021ef:	ff 10                	callq  *(%rax)
ffffffff810021f1:	8b 73 10             	mov    0x10(%rbx),%esi
        static unsigned const freq = 115200;

        unsigned base;

        ALWAYS_INLINE
        inline unsigned in (Register r) { return Io::in<uint8>(base + r); }
ffffffff810021f4:	8d 56 05             	lea    0x5(%rsi),%edx
        template <typename T>
        ALWAYS_INLINE
        static inline unsigned in (unsigned port)
        {
            T val;
            asm volatile ("in %w1, %0" : "=a" (val) : "Nd" (port));
ffffffff810021f7:	ec                   	in     (%dx),%al

    while (EXPECT_FALSE (!(in (LSR) & 0x20)))
ffffffff810021f8:	a8 20                	test   $0x20,%al
ffffffff810021fa:	75 04                	jne    ffffffff81002200 <_ZN14Console_serial4putcEi+0x26>
}

ALWAYS_INLINE
static inline void pause()
{
    asm volatile ("pause" : : : "memory");
ffffffff810021fc:	f3 90                	pause  
ffffffff810021fe:	eb f1                	jmp    ffffffff810021f1 <_ZN14Console_serial4putcEi+0x17>

        template <typename T>
        ALWAYS_INLINE
        static inline void out (unsigned port, T val)
        {
            asm volatile ("out %0, %w1" : : "a" (val), "Nd" (port));
ffffffff81002200:	40 88 e8             	mov    %bpl,%al
ffffffff81002203:	89 f2                	mov    %esi,%edx
ffffffff81002205:	ee                   	out    %al,(%dx)
        pause();

    out (THR, c);
}
ffffffff81002206:	58                   	pop    %rax
ffffffff81002207:	5b                   	pop    %rbx
ffffffff81002208:	5d                   	pop    %rbp
ffffffff81002209:	c3                   	retq   

ffffffff8100220a <_ZN7Console6enableEv>:

    protected:
        NOINLINE
        void enable()
        {
            Console **ptr; for (ptr = &list; *ptr; ptr = &(*ptr)->next) ; *ptr = this;
ffffffff8100220a:	48 8b 05 97 fb 01 00 	mov    0x1fb97(%rip),%rax        # ffffffff81021da8 <_ZN7Console4listE>
ffffffff81002211:	48 c7 c2 a8 1d 02 81 	mov    $0xffffffff81021da8,%rdx
ffffffff81002218:	48 85 c0             	test   %rax,%rax
ffffffff8100221b:	74 0a                	je     ffffffff81002227 <_ZN7Console6enableEv+0x1d>
ffffffff8100221d:	48 8d 50 08          	lea    0x8(%rax),%rdx
ffffffff81002221:	48 8b 40 08          	mov    0x8(%rax),%rax
ffffffff81002225:	eb f1                	jmp    ffffffff81002218 <_ZN7Console6enableEv+0xe>
ffffffff81002227:	48 89 3a             	mov    %rdi,(%rdx)
ffffffff8100222a:	c3                   	retq   

ffffffff8100222b <_GLOBAL__sub_I.65533__ZN14Console_serial3conE>:
#include "console_serial.hpp"
#include "hpt.hpp"
#include "x86.hpp"
#include "pd.hpp"

INIT_PRIORITY (PRIO_CONSOLE) Console_serial Console_serial::con;
ffffffff8100222b:	48 c7 c7 b0 1d 02 81 	mov    $0xffffffff81021db0,%rdi
ffffffff81002232:	e9 a1 ea 1f 7f       	jmpq   200cd8 <_ZN14Console_serialC1Ev>
ffffffff81002237:	90                   	nop

ffffffff81002238 <_ZN11Console_vga4putcEi>:

void Console_vga::putc (int c)
{
    if (EXPECT_FALSE (c == '\f')) {
ffffffff81002238:	83 fe 0c             	cmp    $0xc,%esi
            put (num, i, COLOR_LIGHT_BLACK, ((i - SPN_GSI) & 0xf)["0123456789ABCDEF"]);
    }
}

void Console_vga::putc (int c)
{
ffffffff8100223b:	48 89 fa             	mov    %rdi,%rdx
    if (EXPECT_FALSE (c == '\f')) {
ffffffff8100223e:	75 21                	jne    ffffffff81002261 <_ZN11Console_vga4putcEi+0x29>
        }

        ALWAYS_INLINE
        inline void clear_all()
        {
            memset (reinterpret_cast<void *>(HV_GLOBAL_FBUF), 0, 160 * num);
ffffffff81002240:	69 4f 10 a0 00 00 00 	imul   $0xa0,0x10(%rdi),%ecx
ffffffff81002247:	31 c0                	xor    %eax,%eax
ffffffff81002249:	48 c7 c7 00 f0 df bf 	mov    $0xffffffffbfdff000,%rdi
ffffffff81002250:	f3 aa                	rep stos %al,%es:(%rdi)
        clear_all();
        row = col = 0;
ffffffff81002252:	c7 42 18 00 00 00 00 	movl   $0x0,0x18(%rdx)
ffffffff81002259:	c7 42 14 00 00 00 00 	movl   $0x0,0x14(%rdx)
ffffffff81002260:	c3                   	retq   
        return;
    }

    if (EXPECT_TRUE (c != '\n')) {
ffffffff81002261:	83 fe 0a             	cmp    $0xa,%esi
ffffffff81002264:	75 16                	jne    ffffffff8100227c <_ZN11Console_vga4putcEi+0x44>
            return;
    }

    col = 0;

    if (EXPECT_TRUE (++row == num))
ffffffff81002266:	8b 42 14             	mov    0x14(%rdx),%eax
        put (row, col, COLOR_LIGHT_WHITE, c);
        if (EXPECT_TRUE (++col < 80))
            return;
    }

    col = 0;
ffffffff81002269:	c7 42 18 00 00 00 00 	movl   $0x0,0x18(%rdx)

    if (EXPECT_TRUE (++row == num))
ffffffff81002270:	8d 48 01             	lea    0x1(%rax),%ecx
ffffffff81002273:	3b 4a 10             	cmp    0x10(%rdx),%ecx
ffffffff81002276:	89 4a 14             	mov    %ecx,0x14(%rdx)
ffffffff81002279:	74 2a                	je     ffffffff810022a5 <_ZN11Console_vga4putcEi+0x6d>
ffffffff8100227b:	c3                   	retq   
        row = col = 0;
        return;
    }

    if (EXPECT_TRUE (c != '\n')) {
        put (row, col, COLOR_LIGHT_WHITE, c);
ffffffff8100227c:	8b 47 14             	mov    0x14(%rdi),%eax
        inline unsigned spinner (unsigned id) { return id < 25 - num ? 24 - id : 0; }

        ALWAYS_INLINE
        inline void put (unsigned long r, unsigned long c, Color color, int x)
        {
            *reinterpret_cast<unsigned short volatile *>(HV_GLOBAL_FBUF + r * 160 + c * 2) = static_cast<unsigned short>(color << 8 | x);
ffffffff8100227f:	66 81 ce 00 0f       	or     $0xf00,%si
ffffffff81002284:	48 6b c8 50          	imul   $0x50,%rax,%rcx
ffffffff81002288:	8b 47 18             	mov    0x18(%rdi),%eax
ffffffff8100228b:	48 01 c8             	add    %rcx,%rax
ffffffff8100228e:	66 89 b4 00 00 f0 df 	mov    %si,-0x40201000(%rax,%rax,1)
ffffffff81002295:	bf 
        if (EXPECT_TRUE (++col < 80))
ffffffff81002296:	8b 47 18             	mov    0x18(%rdi),%eax
ffffffff81002299:	ff c0                	inc    %eax
ffffffff8100229b:	83 f8 4f             	cmp    $0x4f,%eax
ffffffff8100229e:	89 47 18             	mov    %eax,0x18(%rdi)
ffffffff810022a1:	76 33                	jbe    ffffffff810022d6 <_ZN11Console_vga4putcEi+0x9e>
ffffffff810022a3:	eb c1                	jmp    ffffffff81002266 <_ZN11Console_vga4putcEi+0x2e>
            put (num, i, COLOR_LIGHT_BLACK, ((i - SPN_GSI) & 0xf)["0123456789ABCDEF"]);
    }
}

void Console_vga::putc (int c)
{
ffffffff810022a5:	53                   	push   %rbx
        }

        ALWAYS_INLINE
        inline void clear_row (unsigned r)
        {
            memcpy (reinterpret_cast<void *>(HV_GLOBAL_FBUF), reinterpret_cast<void *>(HV_GLOBAL_FBUF + 160), 160 * r);
ffffffff810022a6:	48 c7 c6 a0 f0 df bf 	mov    $0xffffffffbfdff0a0,%rsi
    }

    col = 0;

    if (EXPECT_TRUE (++row == num))
        clear_row (--row);
ffffffff810022ad:	89 42 14             	mov    %eax,0x14(%rdx)
ffffffff810022b0:	69 d8 a0 00 00 00    	imul   $0xa0,%eax,%ebx
ffffffff810022b6:	48 c7 c7 00 f0 df bf 	mov    $0xffffffffbfdff000,%rdi
ffffffff810022bd:	48 89 da             	mov    %rbx,%rdx
ffffffff810022c0:	e8 9d 4b 01 00       	callq  ffffffff81016e62 <memcpy>
            memset (reinterpret_cast<void *>(HV_GLOBAL_FBUF + 160 * r), 0, 160);
ffffffff810022c5:	48 8d bb 00 f0 df bf 	lea    -0x40201000(%rbx),%rdi
ffffffff810022cc:	b9 a0 00 00 00       	mov    $0xa0,%ecx
ffffffff810022d1:	31 c0                	xor    %eax,%eax
ffffffff810022d3:	f3 aa                	rep stos %al,%es:(%rdi)
}
ffffffff810022d5:	5b                   	pop    %rbx
ffffffff810022d6:	c3                   	retq   

ffffffff810022d7 <_GLOBAL__sub_I.65533__ZN11Console_vga3conE>:

#include "cmdline.hpp"
#include "console_vga.hpp"
#include "pd.hpp"

INIT_PRIORITY (PRIO_CONSOLE) Console_vga Console_vga::con;
ffffffff810022d7:	48 c7 c7 d0 1d 02 81 	mov    $0xffffffff81021dd0,%rdi
ffffffff810022de:	e9 7b ea 1f 7f       	jmpq   200d5e <_ZN11Console_vgaC1Ev>
ffffffff810022e3:	90                   	nop

ffffffff810022e4 <_ZN7Counter4dumpEv>:
unsigned    Counter::schedule;
unsigned    Counter::helping;
uint64      Counter::cycles_idle;

void Counter::dump()
{
ffffffff810022e4:	41 54                	push   %r12
ffffffff810022e6:	55                   	push   %rbp
ffffffff810022e7:	53                   	push   %rbx
ffffffff810022e8:	48 83 ec 10          	sub    $0x10,%rsp

ALWAYS_INLINE
static inline uint64 rdtsc()
{
    mword h, l;
    asm volatile ("rdtsc" : "=a" (l), "=d" (h));
ffffffff810022ec:	0f 31                	rdtsc  
    return static_cast<uint64>(h) << 32 | l;
ffffffff810022ee:	48 c1 e2 20          	shl    $0x20,%rdx
    trace (0, "TIME: %16llu", rdtsc());
ffffffff810022f2:	48 8d 6c 24 07       	lea    0x7(%rsp),%rbp
ffffffff810022f7:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff810022fb:	48 09 c2             	or     %rax,%rdx
ffffffff810022fe:	8b 05 00 cd ff 3e    	mov    0x3effcd00(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81002304:	48 c7 c7 08 d8 01 81 	mov    $0xffffffff8101d808,%rdi
ffffffff8100230b:	48 89 eb             	mov    %rbp,%rbx
ffffffff8100230e:	48 81 e3 00 f0 ff ff 	and    $0xfffffffffffff000,%rbx
ffffffff81002315:	48 81 fb 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rbx
ffffffff8100231c:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff81002320:	31 c0                	xor    %eax,%eax
ffffffff81002322:	e8 65 fd ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
    trace (0, "IDLE: %16llu", Counter::cycles_idle);
ffffffff81002327:	8b 05 d7 cc ff 3e    	mov    0x3effccd7(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100232d:	48 8b 15 0c cd ff 3e 	mov    0x3effcd0c(%rip),%rdx        # ffffffffbffff040 <_ZN7Counter11cycles_idleE>
ffffffff81002334:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81002338:	48 81 fb 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rbx
ffffffff8100233f:	48 c7 c7 1c d8 01 81 	mov    $0xffffffff8101d81c,%rdi
ffffffff81002346:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff8100234a:	31 c0                	xor    %eax,%eax
ffffffff8100234c:	e8 3b fd ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
    trace (0, "VGPF: %16u", Counter::vtlb_gpf);
ffffffff81002351:	8b 05 ad cc ff 3e    	mov    0x3effccad(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81002357:	8b 15 ff cc ff 3e    	mov    0x3effccff(%rip),%edx        # ffffffffbffff05c <_ZN7Counter8vtlb_gpfE>
ffffffff8100235d:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81002361:	48 81 fb 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rbx
ffffffff81002368:	48 c7 c7 30 d8 01 81 	mov    $0xffffffff8101d830,%rdi
ffffffff8100236f:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff81002373:	31 c0                	xor    %eax,%eax
ffffffff81002375:	e8 12 fd ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
    trace (0, "VHPF: %16u", Counter::vtlb_hpf);
ffffffff8100237a:	8b 05 84 cc ff 3e    	mov    0x3effcc84(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81002380:	8b 15 d2 cc ff 3e    	mov    0x3effccd2(%rip),%edx        # ffffffffbffff058 <_ZN7Counter8vtlb_hpfE>
ffffffff81002386:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff8100238a:	48 81 fb 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rbx
ffffffff81002391:	48 c7 c7 42 d8 01 81 	mov    $0xffffffff8101d842,%rdi
ffffffff81002398:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff8100239c:	31 c0                	xor    %eax,%eax
ffffffff8100239e:	e8 e9 fc ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
    trace (0, "VFIL: %16u", Counter::vtlb_fill);
ffffffff810023a3:	8b 05 5b cc ff 3e    	mov    0x3effcc5b(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff810023a9:	8b 15 a5 cc ff 3e    	mov    0x3effcca5(%rip),%edx        # ffffffffbffff054 <_ZN7Counter9vtlb_fillE>
ffffffff810023af:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff810023b3:	48 81 fb 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rbx
ffffffff810023ba:	48 c7 c7 54 d8 01 81 	mov    $0xffffffff8101d854,%rdi
ffffffff810023c1:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff810023c5:	31 c0                	xor    %eax,%eax
ffffffff810023c7:	e8 c0 fc ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
    trace (0, "VFLU: %16u", Counter::vtlb_flush);
ffffffff810023cc:	8b 05 32 cc ff 3e    	mov    0x3effcc32(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff810023d2:	8b 15 78 cc ff 3e    	mov    0x3effcc78(%rip),%edx        # ffffffffbffff050 <_ZN7Counter10vtlb_flushE>
ffffffff810023d8:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff810023dc:	48 81 fb 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rbx
ffffffff810023e3:	48 c7 c7 66 d8 01 81 	mov    $0xffffffff8101d866,%rdi
ffffffff810023ea:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff810023ee:	31 c0                	xor    %eax,%eax
ffffffff810023f0:	e8 97 fc ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
    trace (0, "SCHD: %16u", Counter::schedule);
ffffffff810023f5:	8b 05 09 cc ff 3e    	mov    0x3effcc09(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff810023fb:	8b 15 4b cc ff 3e    	mov    0x3effcc4b(%rip),%edx        # ffffffffbffff04c <_ZN7Counter8scheduleE>
ffffffff81002401:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81002405:	48 81 fb 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rbx
ffffffff8100240c:	48 c7 c7 78 d8 01 81 	mov    $0xffffffff8101d878,%rdi
ffffffff81002413:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff81002417:	31 c0                	xor    %eax,%eax
ffffffff81002419:	e8 6e fc ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
    trace (0, "HELP: %16u", Counter::helping);
ffffffff8100241e:	8b 05 e0 cb ff 3e    	mov    0x3effcbe0(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81002424:	8b 15 1e cc ff 3e    	mov    0x3effcc1e(%rip),%edx        # ffffffffbffff048 <_ZN7Counter7helpingE>
ffffffff8100242a:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff8100242e:	48 81 fb 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rbx
ffffffff81002435:	48 c7 c7 8a d8 01 81 	mov    $0xffffffff8101d88a,%rdi
ffffffff8100243c:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff81002440:	31 c0                	xor    %eax,%eax

    Counter::vtlb_gpf = Counter::vtlb_hpf = Counter::vtlb_fill = Counter::vtlb_flush = Counter::schedule = Counter::helping = 0;
ffffffff81002442:	45 31 e4             	xor    %r12d,%r12d
    trace (0, "VGPF: %16u", Counter::vtlb_gpf);
    trace (0, "VHPF: %16u", Counter::vtlb_hpf);
    trace (0, "VFIL: %16u", Counter::vtlb_fill);
    trace (0, "VFLU: %16u", Counter::vtlb_flush);
    trace (0, "SCHD: %16u", Counter::schedule);
    trace (0, "HELP: %16u", Counter::helping);
ffffffff81002445:	e8 42 fc ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>

    Counter::vtlb_gpf = Counter::vtlb_hpf = Counter::vtlb_fill = Counter::vtlb_flush = Counter::schedule = Counter::helping = 0;
ffffffff8100244a:	c7 05 f4 cb ff 3e 00 	movl   $0x0,0x3effcbf4(%rip)        # ffffffffbffff048 <_ZN7Counter7helpingE>
ffffffff81002451:	00 00 00 
ffffffff81002454:	c7 05 ee cb ff 3e 00 	movl   $0x0,0x3effcbee(%rip)        # ffffffffbffff04c <_ZN7Counter8scheduleE>
ffffffff8100245b:	00 00 00 
ffffffff8100245e:	c7 05 e8 cb ff 3e 00 	movl   $0x0,0x3effcbe8(%rip)        # ffffffffbffff050 <_ZN7Counter10vtlb_flushE>
ffffffff81002465:	00 00 00 
ffffffff81002468:	c7 05 e2 cb ff 3e 00 	movl   $0x0,0x3effcbe2(%rip)        # ffffffffbffff054 <_ZN7Counter9vtlb_fillE>
ffffffff8100246f:	00 00 00 
ffffffff81002472:	c7 05 dc cb ff 3e 00 	movl   $0x0,0x3effcbdc(%rip)        # ffffffffbffff058 <_ZN7Counter8vtlb_hpfE>
ffffffff81002479:	00 00 00 
ffffffff8100247c:	c7 05 d6 cb ff 3e 00 	movl   $0x0,0x3effcbd6(%rip)        # ffffffffbffff05c <_ZN7Counter8vtlb_gpfE>
ffffffff81002483:	00 00 00 

    for (unsigned i = 0; i < sizeof (Counter::ipi) / sizeof (*Counter::ipi); i++)
        if (Counter::ipi[i]) {
ffffffff81002486:	42 8b 0c a5 18 f7 ff 	mov    -0x400008e8(,%r12,4),%ecx
ffffffff8100248d:	bf 
ffffffff8100248e:	85 c9                	test   %ecx,%ecx
ffffffff81002490:	74 32                	je     ffffffff810024c4 <_ZN7Counter4dumpEv+0x1e0>
            trace (0, "IPI %#4x: %12u", i, Counter::ipi[i]);
ffffffff81002492:	8b 05 6c cb ff 3e    	mov    0x3effcb6c(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81002498:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff8100249c:	48 81 fb 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rbx
ffffffff810024a3:	44 89 e2             	mov    %r12d,%edx
ffffffff810024a6:	48 c7 c7 9c d8 01 81 	mov    $0xffffffff8101d89c,%rdi
ffffffff810024ad:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff810024b1:	31 c0                	xor    %eax,%eax
ffffffff810024b3:	e8 d4 fb ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
            Counter::ipi[i] = 0;
ffffffff810024b8:	42 c7 04 a5 18 f7 ff 	movl   $0x0,-0x400008e8(,%r12,4)
ffffffff810024bf:	bf 00 00 00 00 
ffffffff810024c4:	49 ff c4             	inc    %r12
    trace (0, "SCHD: %16u", Counter::schedule);
    trace (0, "HELP: %16u", Counter::helping);

    Counter::vtlb_gpf = Counter::vtlb_hpf = Counter::vtlb_fill = Counter::vtlb_flush = Counter::schedule = Counter::helping = 0;

    for (unsigned i = 0; i < sizeof (Counter::ipi) / sizeof (*Counter::ipi); i++)
ffffffff810024c7:	49 83 fc 03          	cmp    $0x3,%r12
ffffffff810024cb:	75 b9                	jne    ffffffff81002486 <_ZN7Counter4dumpEv+0x1a2>
            Counter::ipi[i] = 0;
        }

    for (unsigned i = 0; i < sizeof (Counter::lvt) / sizeof (*Counter::lvt); i++)
        if (Counter::lvt[i]) {
            trace (0, "LVT %#4x: %12u", i, Counter::lvt[i]);
ffffffff810024cd:	49 89 ec             	mov    %rbp,%r12
ffffffff810024d0:	31 db                	xor    %ebx,%ebx
ffffffff810024d2:	49 81 e4 00 f0 ff ff 	and    $0xfffffffffffff000,%r12
            trace (0, "IPI %#4x: %12u", i, Counter::ipi[i]);
            Counter::ipi[i] = 0;
        }

    for (unsigned i = 0; i < sizeof (Counter::lvt) / sizeof (*Counter::lvt); i++)
        if (Counter::lvt[i]) {
ffffffff810024d9:	8b 0c 9d 00 f7 ff bf 	mov    -0x40000900(,%rbx,4),%ecx
ffffffff810024e0:	85 c9                	test   %ecx,%ecx
ffffffff810024e2:	74 30                	je     ffffffff81002514 <_ZN7Counter4dumpEv+0x230>
            trace (0, "LVT %#4x: %12u", i, Counter::lvt[i]);
ffffffff810024e4:	8b 05 1a cb ff 3e    	mov    0x3effcb1a(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff810024ea:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff810024ee:	49 81 fc 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%r12
ffffffff810024f5:	89 da                	mov    %ebx,%edx
ffffffff810024f7:	48 c7 c7 b2 d8 01 81 	mov    $0xffffffff8101d8b2,%rdi
ffffffff810024fe:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff81002502:	31 c0                	xor    %eax,%eax
ffffffff81002504:	e8 83 fb ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
            Counter::lvt[i] = 0;
ffffffff81002509:	c7 04 9d 00 f7 ff bf 	movl   $0x0,-0x40000900(,%rbx,4)
ffffffff81002510:	00 00 00 00 
ffffffff81002514:	48 ff c3             	inc    %rbx
        if (Counter::ipi[i]) {
            trace (0, "IPI %#4x: %12u", i, Counter::ipi[i]);
            Counter::ipi[i] = 0;
        }

    for (unsigned i = 0; i < sizeof (Counter::lvt) / sizeof (*Counter::lvt); i++)
ffffffff81002517:	48 83 fb 06          	cmp    $0x6,%rbx
ffffffff8100251b:	75 bc                	jne    ffffffff810024d9 <_ZN7Counter4dumpEv+0x1f5>
            Counter::lvt[i] = 0;
        }

    for (unsigned i = 0; i < sizeof (Counter::gsi) / sizeof (*Counter::gsi); i++)
        if (Counter::gsi[i]) {
            trace (0, "GSI %#4x: %12u", i, Counter::gsi[i]);
ffffffff8100251d:	49 89 ec             	mov    %rbp,%r12
ffffffff81002520:	30 db                	xor    %bl,%bl
ffffffff81002522:	49 81 e4 00 f0 ff ff 	and    $0xfffffffffffff000,%r12
            trace (0, "LVT %#4x: %12u", i, Counter::lvt[i]);
            Counter::lvt[i] = 0;
        }

    for (unsigned i = 0; i < sizeof (Counter::gsi) / sizeof (*Counter::gsi); i++)
        if (Counter::gsi[i]) {
ffffffff81002529:	8b 0c 9d 00 f5 ff bf 	mov    -0x40000b00(,%rbx,4),%ecx
ffffffff81002530:	85 c9                	test   %ecx,%ecx
ffffffff81002532:	74 30                	je     ffffffff81002564 <_ZN7Counter4dumpEv+0x280>
            trace (0, "GSI %#4x: %12u", i, Counter::gsi[i]);
ffffffff81002534:	8b 05 ca ca ff 3e    	mov    0x3effcaca(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100253a:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff8100253e:	49 81 fc 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%r12
ffffffff81002545:	89 da                	mov    %ebx,%edx
ffffffff81002547:	48 c7 c7 c8 d8 01 81 	mov    $0xffffffff8101d8c8,%rdi
ffffffff8100254e:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff81002552:	31 c0                	xor    %eax,%eax
ffffffff81002554:	e8 33 fb ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
            Counter::gsi[i] = 0;
ffffffff81002559:	c7 04 9d 00 f5 ff bf 	movl   $0x0,-0x40000b00(,%rbx,4)
ffffffff81002560:	00 00 00 00 
ffffffff81002564:	48 ff c3             	inc    %rbx
        if (Counter::lvt[i]) {
            trace (0, "LVT %#4x: %12u", i, Counter::lvt[i]);
            Counter::lvt[i] = 0;
        }

    for (unsigned i = 0; i < sizeof (Counter::gsi) / sizeof (*Counter::gsi); i++)
ffffffff81002567:	48 81 fb 80 00 00 00 	cmp    $0x80,%rbx
ffffffff8100256e:	75 b9                	jne    ffffffff81002529 <_ZN7Counter4dumpEv+0x245>
            Counter::gsi[i] = 0;
        }

    for (unsigned i = 0; i < sizeof (Counter::exc) / sizeof (*Counter::exc); i++)
        if (Counter::exc[i]) {
            trace (0, "EXC %#4x: %12u", i, Counter::exc[i]);
ffffffff81002570:	49 89 ec             	mov    %rbp,%r12
ffffffff81002573:	30 db                	xor    %bl,%bl
ffffffff81002575:	49 81 e4 00 f0 ff ff 	and    $0xfffffffffffff000,%r12
            trace (0, "GSI %#4x: %12u", i, Counter::gsi[i]);
            Counter::gsi[i] = 0;
        }

    for (unsigned i = 0; i < sizeof (Counter::exc) / sizeof (*Counter::exc); i++)
        if (Counter::exc[i]) {
ffffffff8100257c:	8b 0c 9d 80 f4 ff bf 	mov    -0x40000b80(,%rbx,4),%ecx
ffffffff81002583:	85 c9                	test   %ecx,%ecx
ffffffff81002585:	74 30                	je     ffffffff810025b7 <_ZN7Counter4dumpEv+0x2d3>
            trace (0, "EXC %#4x: %12u", i, Counter::exc[i]);
ffffffff81002587:	8b 05 77 ca ff 3e    	mov    0x3effca77(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100258d:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81002591:	49 81 fc 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%r12
ffffffff81002598:	89 da                	mov    %ebx,%edx
ffffffff8100259a:	48 c7 c7 de d8 01 81 	mov    $0xffffffff8101d8de,%rdi
ffffffff810025a1:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff810025a5:	31 c0                	xor    %eax,%eax
ffffffff810025a7:	e8 e0 fa ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
            Counter::exc[i] = 0;
ffffffff810025ac:	c7 04 9d 80 f4 ff bf 	movl   $0x0,-0x40000b80(,%rbx,4)
ffffffff810025b3:	00 00 00 00 
ffffffff810025b7:	48 ff c3             	inc    %rbx
        if (Counter::gsi[i]) {
            trace (0, "GSI %#4x: %12u", i, Counter::gsi[i]);
            Counter::gsi[i] = 0;
        }

    for (unsigned i = 0; i < sizeof (Counter::exc) / sizeof (*Counter::exc); i++)
ffffffff810025ba:	48 83 fb 20          	cmp    $0x20,%rbx
ffffffff810025be:	75 bc                	jne    ffffffff8100257c <_ZN7Counter4dumpEv+0x298>
ffffffff810025c0:	30 db                	xor    %bl,%bl
            Counter::exc[i] = 0;
        }

    for (unsigned i = 0; i < sizeof (Counter::vmi) / sizeof (*Counter::vmi); i++)
        if (Counter::vmi[i]) {
            trace (0, "VMI %#4x: %12u", i, Counter::vmi[i]);
ffffffff810025c2:	48 81 e5 00 f0 ff ff 	and    $0xfffffffffffff000,%rbp
            trace (0, "EXC %#4x: %12u", i, Counter::exc[i]);
            Counter::exc[i] = 0;
        }

    for (unsigned i = 0; i < sizeof (Counter::vmi) / sizeof (*Counter::vmi); i++)
        if (Counter::vmi[i]) {
ffffffff810025c9:	8b 0c 9d 80 f0 ff bf 	mov    -0x40000f80(,%rbx,4),%ecx
ffffffff810025d0:	85 c9                	test   %ecx,%ecx
ffffffff810025d2:	74 30                	je     ffffffff81002604 <_ZN7Counter4dumpEv+0x320>
            trace (0, "VMI %#4x: %12u", i, Counter::vmi[i]);
ffffffff810025d4:	8b 05 2a ca ff 3e    	mov    0x3effca2a(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff810025da:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff810025de:	48 81 fd 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rbp
ffffffff810025e5:	89 da                	mov    %ebx,%edx
ffffffff810025e7:	48 c7 c7 f4 d8 01 81 	mov    $0xffffffff8101d8f4,%rdi
ffffffff810025ee:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff810025f2:	31 c0                	xor    %eax,%eax
ffffffff810025f4:	e8 93 fa ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
            Counter::vmi[i] = 0;
ffffffff810025f9:	c7 04 9d 80 f0 ff bf 	movl   $0x0,-0x40000f80(,%rbx,4)
ffffffff81002600:	00 00 00 00 
ffffffff81002604:	48 ff c3             	inc    %rbx
        if (Counter::exc[i]) {
            trace (0, "EXC %#4x: %12u", i, Counter::exc[i]);
            Counter::exc[i] = 0;
        }

    for (unsigned i = 0; i < sizeof (Counter::vmi) / sizeof (*Counter::vmi); i++)
ffffffff81002607:	48 81 fb 00 01 00 00 	cmp    $0x100,%rbx
ffffffff8100260e:	75 b9                	jne    ffffffff810025c9 <_ZN7Counter4dumpEv+0x2e5>
        if (Counter::vmi[i]) {
            trace (0, "VMI %#4x: %12u", i, Counter::vmi[i]);
            Counter::vmi[i] = 0;
        }
}
ffffffff81002610:	48 83 c4 10          	add    $0x10,%rsp
ffffffff81002614:	5b                   	pop    %rbx
ffffffff81002615:	5d                   	pop    %rbp
ffffffff81002616:	41 5c                	pop    %r12
ffffffff81002618:	c3                   	retq   
ffffffff81002619:	90                   	nop

ffffffff8100261a <_ZN3Cow16get_cow_list_eltERt>:

/**
 * @param elt_index
 * @return 
 */
bool Cow::get_cow_list_elt(uint16 & elt_index) {
ffffffff8100261a:	31 c0                	xor    %eax,%eax
ffffffff8100261c:	48 89 c1             	mov    %rax,%rcx
ffffffff8100261f:	48 c1 e1 06          	shl    $0x6,%rcx
    for (uint16 i = 0; i < NB_COW_ELT; i++) {
        if (!cow_list[i].used) {
ffffffff81002623:	80 b9 b0 1f 06 81 00 	cmpb   $0x0,-0x7ef9e050(%rcx)
ffffffff8100262a:	75 13                	jne    ffffffff8100263f <_ZN3Cow16get_cow_list_eltERt+0x25>
            elt_index = i;
ffffffff8100262c:	66 89 07             	mov    %ax,(%rdi)
            cow_list[i].used = true;
ffffffff8100262f:	48 98                	cltq   
ffffffff81002631:	48 c1 e0 06          	shl    $0x6,%rax
ffffffff81002635:	c6 80 b0 1f 06 81 01 	movb   $0x1,-0x7ef9e050(%rax)
            return true;
ffffffff8100263c:	b0 01                	mov    $0x1,%al
ffffffff8100263e:	c3                   	retq   
ffffffff8100263f:	48 ff c0             	inc    %rax
/**
 * @param elt_index
 * @return 
 */
bool Cow::get_cow_list_elt(uint16 & elt_index) {
    for (uint16 i = 0; i < NB_COW_ELT; i++) {
ffffffff81002642:	48 3d 00 40 00 00    	cmp    $0x4000,%rax
ffffffff81002648:	75 d2                	jne    ffffffff8100261c <_ZN3Cow16get_cow_list_eltERt+0x2>
            elt_index = i;
            cow_list[i].used = true;
            return true;
        }
    }
    return false; //cow_list elt may be exhausted
ffffffff8100264a:	31 c0                	xor    %eax,%eax
}
ffffffff8100264c:	c3                   	retq   
ffffffff8100264d:	90                   	nop

ffffffff8100264e <_ZN3Cow17get_new_cow_frameERt>:

bool Cow::get_new_cow_frame(uint16 & frame_index) {
ffffffff8100264e:	31 c0                	xor    %eax,%eax
ffffffff81002650:	48 89 c1             	mov    %rax,%rcx
ffffffff81002653:	48 c1 e1 04          	shl    $0x4,%rcx
    for (uint16 i = 0; i < NB_COW_FRAME; i++) {
        if (!cow_frames[i].used) {
ffffffff81002657:	80 b9 8a 1f 02 81 00 	cmpb   $0x0,-0x7efde076(%rcx)
ffffffff8100265e:	75 13                	jne    ffffffff81002673 <_ZN3Cow17get_new_cow_frameERt+0x25>
            frame_index = i;
ffffffff81002660:	66 89 07             	mov    %ax,(%rdi)
            cow_frames[i].used = true;
ffffffff81002663:	48 98                	cltq   
ffffffff81002665:	48 c1 e0 04          	shl    $0x4,%rax
ffffffff81002669:	c6 80 8a 1f 02 81 01 	movb   $0x1,-0x7efde076(%rax)
            return true;
ffffffff81002670:	b0 01                	mov    $0x1,%al
ffffffff81002672:	c3                   	retq   
ffffffff81002673:	48 ff c0             	inc    %rax
    }
    return false; //cow_list elt may be exhausted
}

bool Cow::get_new_cow_frame(uint16 & frame_index) {
    for (uint16 i = 0; i < NB_COW_FRAME; i++) {
ffffffff81002676:	48 3d 00 40 00 00    	cmp    $0x4000,%rax
ffffffff8100267c:	75 d2                	jne    ffffffff81002650 <_ZN3Cow17get_new_cow_frameERt+0x2>
            frame_index = i;
            cow_frames[i].used = true;
            return true;
        }
    }
    return false;
ffffffff8100267e:	31 c0                	xor    %eax,%eax
}
ffffffff81002680:	c3                   	retq   
ffffffff81002681:	90                   	nop

ffffffff81002682 <_ZN3Cow12free_cow_eltEPNS_7cow_eltE>:
void Cow::free_cow_frame(struct cow_frame * frame_ptr) {
    frame_ptr->used = false;
}

void Cow::free_cow_elt(cow_elt * cow) {
    cow->old_phys =  (Paddr) (-1);//0xffffffff; old_phys when set would always be differrent from 0xffffffff because pages are allocated at page boundary
ffffffff81002682:	48 83 c8 ff          	or     $0xffffffffffffffff,%rax
    cow->page_addr_or_gpa = (mword) (-1); // 0xffffffff;
    cow->used = false;
ffffffff81002686:	c6 47 30 00          	movb   $0x0,0x30(%rdi)
void Cow::free_cow_frame(struct cow_frame * frame_ptr) {
    frame_ptr->used = false;
}

void Cow::free_cow_elt(cow_elt * cow) {
    cow->old_phys =  (Paddr) (-1);//0xffffffff; old_phys when set would always be differrent from 0xffffffff because pages are allocated at page boundary
ffffffff8100268a:	48 89 47 10          	mov    %rax,0x10(%rdi)
    cow->page_addr_or_gpa = (mword) (-1); // 0xffffffff;
ffffffff8100268e:	48 89 07             	mov    %rax,(%rdi)
    cow->used = false;
    free_cow_frame(cow->new_phys[0]);
ffffffff81002691:	48 8b 47 20          	mov    0x20(%rdi),%rax
    }
    return false;
}

void Cow::free_cow_frame(struct cow_frame * frame_ptr) {
    frame_ptr->used = false;
ffffffff81002695:	c6 40 0a 00          	movb   $0x0,0xa(%rax)
void Cow::free_cow_elt(cow_elt * cow) {
    cow->old_phys =  (Paddr) (-1);//0xffffffff; old_phys when set would always be differrent from 0xffffffff because pages are allocated at page boundary
    cow->page_addr_or_gpa = (mword) (-1); // 0xffffffff;
    cow->used = false;
    free_cow_frame(cow->new_phys[0]);
    free_cow_frame(cow->new_phys[1]);
ffffffff81002699:	48 8b 47 28          	mov    0x28(%rdi),%rax
    }
    return false;
}

void Cow::free_cow_frame(struct cow_frame * frame_ptr) {
    frame_ptr->used = false;
ffffffff8100269d:	c6 40 0a 00          	movb   $0x0,0xa(%rax)
ffffffff810026a1:	c3                   	retq   

ffffffff810026a2 <_ZN3Cow17get_new_cow_frameEPPNS_9cow_frameE>:
    cow->used = false;
    free_cow_frame(cow->new_phys[0]);
    free_cow_frame(cow->new_phys[1]);
}

bool Cow::get_new_cow_frame(cow_frame** frame_ptr) {
ffffffff810026a2:	53                   	push   %rbx
ffffffff810026a3:	48 89 fb             	mov    %rdi,%rbx
ffffffff810026a6:	48 83 ec 10          	sub    $0x10,%rsp
    uint16 frame_index = 0;
    if (!get_new_cow_frame(frame_index))
ffffffff810026aa:	48 8d 7c 24 0e       	lea    0xe(%rsp),%rdi
    free_cow_frame(cow->new_phys[0]);
    free_cow_frame(cow->new_phys[1]);
}

bool Cow::get_new_cow_frame(cow_frame** frame_ptr) {
    uint16 frame_index = 0;
ffffffff810026af:	66 c7 44 24 0e 00 00 	movw   $0x0,0xe(%rsp)
    if (!get_new_cow_frame(frame_index))
ffffffff810026b6:	e8 93 ff ff ff       	callq  ffffffff8100264e <_ZN3Cow17get_new_cow_frameERt>
ffffffff810026bb:	84 c0                	test   %al,%al
ffffffff810026bd:	74 38                	je     ffffffff810026f7 <_ZN3Cow17get_new_cow_frameEPPNS_9cow_frameE+0x55>
        return false;
    cow_frames[frame_index].used = true;
ffffffff810026bf:	0f b7 54 24 0e       	movzwl 0xe(%rsp),%edx
ffffffff810026c4:	48 89 d6             	mov    %rdx,%rsi
ffffffff810026c7:	48 c1 e6 04          	shl    $0x4,%rsi
    if (frame_index > frame_index_max) {
ffffffff810026cb:	66 3b 15 b0 f8 15 00 	cmp    0x15f8b0(%rip),%dx        # ffffffff81161f82 <_ZN3Cow15frame_index_maxE>

bool Cow::get_new_cow_frame(cow_frame** frame_ptr) {
    uint16 frame_index = 0;
    if (!get_new_cow_frame(frame_index))
        return false;
    cow_frames[frame_index].used = true;
ffffffff810026d2:	c6 86 8a 1f 02 81 01 	movb   $0x1,-0x7efde076(%rsi)
    if (frame_index > frame_index_max) {
ffffffff810026d9:	76 0e                	jbe    ffffffff810026e9 <_ZN3Cow17get_new_cow_frameEPPNS_9cow_frameE+0x47>
        frame_index_max = frame_index;
ffffffff810026db:	66 89 15 a0 f8 15 00 	mov    %dx,0x15f8a0(%rip)        # ffffffff81161f82 <_ZN3Cow15frame_index_maxE>
        max_displayed = false;
ffffffff810026e2:	c6 05 57 f8 01 00 00 	movb   $0x0,0x1f857(%rip)        # ffffffff81021f40 <_ZN3Cow13max_displayedE>
    }
    *frame_ptr = &cow_frames[frame_index];
ffffffff810026e9:	48 c1 e2 04          	shl    $0x4,%rdx
ffffffff810026ed:	48 81 c2 80 1f 02 81 	add    $0xffffffff81021f80,%rdx
ffffffff810026f4:	48 89 13             	mov    %rdx,(%rbx)
    //        if (Cpu::id != 0)
    //        Console::print("cpu: %2d  frame_index: %d", Cpu::id, frame_index);
    return true;
}
ffffffff810026f7:	48 83 c4 10          	add    $0x10,%rsp
ffffffff810026fb:	5b                   	pop    %rbx
ffffffff810026fc:	c3                   	retq   
ffffffff810026fd:	90                   	nop

ffffffff810026fe <_ZN3Cow16get_cow_list_eltEPPNS_7cow_eltE>:

bool Cow::get_cow_list_elt(cow_elt** cow_ptr) {
ffffffff810026fe:	55                   	push   %rbp
ffffffff810026ff:	53                   	push   %rbx
ffffffff81002700:	48 89 fd             	mov    %rdi,%rbp
ffffffff81002703:	48 83 ec 18          	sub    $0x18,%rsp

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81002707:	9c                   	pushfq 
ffffffff81002708:	58                   	pop    %rax
            return flags & 0x200;
ffffffff81002709:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8100270d:	88 c3                	mov    %al,%bl
ffffffff8100270f:	80 e3 01             	and    $0x1,%bl
ffffffff81002712:	74 30                	je     ffffffff81002744 <_ZN3Cow16get_cow_list_eltEPPNS_7cow_eltE+0x46>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81002714:	80 3d 15 d0 ff 3e 00 	cmpb   $0x0,0x3effd015(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100271b:	75 1f                	jne    ffffffff8100273c <_ZN3Cow16get_cow_list_eltEPPNS_7cow_eltE+0x3e>
ffffffff8100271d:	49 c7 c0 40 d9 01 81 	mov    $0xffffffff8101d940,%r8
ffffffff81002724:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff81002729:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81002730:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff81002737:	e9 81 00 00 00       	jmpq   ffffffff810027bd <_ZN3Cow16get_cow_list_eltEPPNS_7cow_eltE+0xbf>

            asm volatile ("cli" : : : "memory");
ffffffff8100273c:	fa                   	cli    
            preemption = false;
ffffffff8100273d:	c6 05 ec cf ff 3e 00 	movb   $0x0,0x3effcfec(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff81002744:	48 c7 c7 f0 1d 02 81 	mov    $0xffffffff81021df0,%rdi
ffffffff8100274b:	e8 3e e7 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    Lock_guard <Spinlock> guard(Cow::cow_lock);
    uint16 elt_index = 0;
    if (!get_cow_list_elt(elt_index)) return false;
ffffffff81002750:	48 8d 7c 24 0e       	lea    0xe(%rsp),%rdi
    return true;
}

bool Cow::get_cow_list_elt(cow_elt** cow_ptr) {
    Lock_guard <Spinlock> guard(Cow::cow_lock);
    uint16 elt_index = 0;
ffffffff81002755:	66 c7 44 24 0e 00 00 	movw   $0x0,0xe(%rsp)
    if (!get_cow_list_elt(elt_index)) return false;
ffffffff8100275c:	e8 b9 fe ff ff       	callq  ffffffff8100261a <_ZN3Cow16get_cow_list_eltERt>
ffffffff81002761:	84 c0                	test   %al,%al
ffffffff81002763:	74 2b                	je     ffffffff81002790 <_ZN3Cow16get_cow_list_eltEPPNS_7cow_eltE+0x92>
    if (elt_index > elt_index_max) {
ffffffff81002765:	0f b7 54 24 0e       	movzwl 0xe(%rsp),%edx
ffffffff8100276a:	66 3b 15 0f f8 15 00 	cmp    0x15f80f(%rip),%dx        # ffffffff81161f80 <_ZN3Cow13elt_index_maxE>
ffffffff81002771:	76 0e                	jbe    ffffffff81002781 <_ZN3Cow16get_cow_list_eltEPPNS_7cow_eltE+0x83>
        elt_index_max = elt_index;
ffffffff81002773:	66 89 15 06 f8 15 00 	mov    %dx,0x15f806(%rip)        # ffffffff81161f80 <_ZN3Cow13elt_index_maxE>
        max_displayed = false;
ffffffff8100277a:	c6 05 bf f7 01 00 00 	movb   $0x0,0x1f7bf(%rip)        # ffffffff81021f40 <_ZN3Cow13max_displayedE>
    }
    *cow_ptr = &cow_list[elt_index];
ffffffff81002781:	48 c1 e2 06          	shl    $0x6,%rdx
ffffffff81002785:	48 81 c2 80 1f 06 81 	add    $0xffffffff81061f80,%rdx
ffffffff8100278c:	48 89 55 00          	mov    %rdx,0x0(%rbp)
        }

        ALWAYS_INLINE
        inline void unlock()
        {
            asm volatile ("incb %0" : "=m" (val) : : "memory");
ffffffff81002790:	fe 05 5a f6 01 00    	incb   0x1f65a(%rip)        # ffffffff81021df0 <_ZN3Cow8cow_lockE>
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81002796:	84 db                	test   %bl,%bl
ffffffff81002798:	74 39                	je     ffffffff810027d3 <_ZN3Cow16get_cow_list_eltEPPNS_7cow_eltE+0xd5>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100279a:	80 3d 8f cf ff 3e 00 	cmpb   $0x0,0x3effcf8f(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff810027a1:	74 28                	je     ffffffff810027cb <_ZN3Cow16get_cow_list_eltEPPNS_7cow_eltE+0xcd>
ffffffff810027a3:	49 c7 c0 10 d9 01 81 	mov    $0xffffffff8101d910,%r8
ffffffff810027aa:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff810027af:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff810027b6:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff810027bd:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff810027c4:	31 c0                	xor    %eax,%eax
ffffffff810027c6:	e8 85 f7 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            preemption = true;
ffffffff810027cb:	c6 05 5e cf ff 3e 01 	movb   $0x1,0x3effcf5e(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff810027d2:	fb                   	sti    
    return true;
}
ffffffff810027d3:	48 83 c4 18          	add    $0x18,%rsp
ffffffff810027d7:	5b                   	pop    %rbx
ffffffff810027d8:	5d                   	pop    %rbp
ffffffff810027d9:	c3                   	retq   

ffffffff810027da <_ZN3Cow9subtituteEmPNS_7cow_eltEm>:

bool Cow::subtitute(Paddr phys, cow_elt* cow, mword addr) {
ffffffff810027da:	41 55                	push   %r13
ffffffff810027dc:	41 54                	push   %r12
ffffffff810027de:	49 89 fd             	mov    %rdi,%r13
ffffffff810027e1:	55                   	push   %rbp
ffffffff810027e2:	53                   	push   %rbx
ffffffff810027e3:	48 89 f5             	mov    %rsi,%rbp
ffffffff810027e6:	49 89 d4             	mov    %rdx,%r12
ffffffff810027e9:	48 83 ec 18          	sub    $0x18,%rsp
    //        Lock_guard <Spinlock> guard(Cow::cow_lock);
    struct cow_frame *frame1, *frame2;
    if (!get_new_cow_frame(&frame1))
ffffffff810027ed:	48 89 e7             	mov    %rsp,%rdi
ffffffff810027f0:	e8 ad fe ff ff       	callq  ffffffff810026a2 <_ZN3Cow17get_new_cow_frameEPPNS_9cow_frameE>
ffffffff810027f5:	84 c0                	test   %al,%al
ffffffff810027f7:	75 04                	jne    ffffffff810027fd <_ZN3Cow9subtituteEmPNS_7cow_eltEm+0x23>
        return false;
ffffffff810027f9:	31 db                	xor    %ebx,%ebx
ffffffff810027fb:	eb 70                	jmp    ffffffff8100286d <_ZN3Cow9subtituteEmPNS_7cow_eltEm+0x93>
    if (!get_new_cow_frame(&frame2))
ffffffff810027fd:	48 8d 7c 24 08       	lea    0x8(%rsp),%rdi
ffffffff81002802:	e8 9b fe ff ff       	callq  ffffffff810026a2 <_ZN3Cow17get_new_cow_frameEPPNS_9cow_frameE>
ffffffff81002807:	84 c0                	test   %al,%al
ffffffff81002809:	88 c3                	mov    %al,%bl
ffffffff8100280b:	74 ec                	je     ffffffff810027f9 <_ZN3Cow9subtituteEmPNS_7cow_eltEm+0x1f>
        return false;
//    if (!max_displayed) {
//        Console::print("cpu: %2d  frame_index_max: %d  elt_index_max: %d", Cpu::id, frame_index_max, elt_index_max);
//        max_displayed = true;
//    }
    void *ptr = Hpt::remap_cow(Pd::kern.quota, frame1->phys_addr); //we only have 2^NB_COW_FRAME availlable, may be exhausted
ffffffff8100280d:	48 8b 04 24          	mov    (%rsp),%rax
ffffffff81002811:	31 d2                	xor    %edx,%edx
ffffffff81002813:	48 c7 c7 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rdi
ffffffff8100281a:	48 8b 30             	mov    (%rax),%rsi
ffffffff8100281d:	e8 f2 59 00 00       	callq  ffffffff81008214 <_ZN3Hpt9remap_cowER5Quotamm>
    memcpy(ptr, reinterpret_cast<const void*> (addr), PAGE_SIZE);
ffffffff81002822:	ba 00 10 00 00       	mov    $0x1000,%edx
ffffffff81002827:	4c 89 e6             	mov    %r12,%rsi
ffffffff8100282a:	48 89 c7             	mov    %rax,%rdi
ffffffff8100282d:	e8 30 46 01 00       	callq  ffffffff81016e62 <memcpy>
    cow->new_phys[0] = frame1;
ffffffff81002832:	48 8b 04 24          	mov    (%rsp),%rax
    ptr = Hpt::remap_cow(Pd::kern.quota, frame2->phys_addr); //we only have 2^NB_COW_FRAME availlable, may be exhausted
ffffffff81002836:	31 d2                	xor    %edx,%edx
ffffffff81002838:	48 c7 c7 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rdi
//        Console::print("cpu: %2d  frame_index_max: %d  elt_index_max: %d", Cpu::id, frame_index_max, elt_index_max);
//        max_displayed = true;
//    }
    void *ptr = Hpt::remap_cow(Pd::kern.quota, frame1->phys_addr); //we only have 2^NB_COW_FRAME availlable, may be exhausted
    memcpy(ptr, reinterpret_cast<const void*> (addr), PAGE_SIZE);
    cow->new_phys[0] = frame1;
ffffffff8100283f:	48 89 45 20          	mov    %rax,0x20(%rbp)
    ptr = Hpt::remap_cow(Pd::kern.quota, frame2->phys_addr); //we only have 2^NB_COW_FRAME availlable, may be exhausted
ffffffff81002843:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
ffffffff81002848:	48 8b 30             	mov    (%rax),%rsi
ffffffff8100284b:	e8 c4 59 00 00       	callq  ffffffff81008214 <_ZN3Hpt9remap_cowER5Quotamm>
    memcpy(ptr, reinterpret_cast<const void*> (addr), PAGE_SIZE);
ffffffff81002850:	ba 00 10 00 00       	mov    $0x1000,%edx
ffffffff81002855:	4c 89 e6             	mov    %r12,%rsi
ffffffff81002858:	48 89 c7             	mov    %rax,%rdi
ffffffff8100285b:	e8 02 46 01 00       	callq  ffffffff81016e62 <memcpy>
    cow->new_phys[1] = frame2;
ffffffff81002860:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    cow->old_phys = phys;
ffffffff81002865:	4c 89 6d 10          	mov    %r13,0x10(%rbp)
    void *ptr = Hpt::remap_cow(Pd::kern.quota, frame1->phys_addr); //we only have 2^NB_COW_FRAME availlable, may be exhausted
    memcpy(ptr, reinterpret_cast<const void*> (addr), PAGE_SIZE);
    cow->new_phys[0] = frame1;
    ptr = Hpt::remap_cow(Pd::kern.quota, frame2->phys_addr); //we only have 2^NB_COW_FRAME availlable, may be exhausted
    memcpy(ptr, reinterpret_cast<const void*> (addr), PAGE_SIZE);
    cow->new_phys[1] = frame2;
ffffffff81002869:	48 89 45 28          	mov    %rax,0x28(%rbp)
    cow->old_phys = phys;

    return true;
}
ffffffff8100286d:	48 83 c4 18          	add    $0x18,%rsp
ffffffff81002871:	88 d8                	mov    %bl,%al
ffffffff81002873:	5b                   	pop    %rbx
ffffffff81002874:	5d                   	pop    %rbp
ffffffff81002875:	41 5c                	pop    %r12
ffffffff81002877:	41 5d                	pop    %r13
ffffffff81002879:	c3                   	retq   

ffffffff8100287a <_GLOBAL__sub_I__ZN3Cow15frame_index_maxE>:
ffffffff8100287a:	31 c0                	xor    %eax,%eax
        uint16 index;
        bool used = false;
    };
    static struct cow_frame cow_frames[NB_COW_FRAME];

    struct cow_elt {
ffffffff8100287c:	c6 80 b0 1f 06 81 00 	movb   $0x0,-0x7ef9e050(%rax)
ffffffff81002883:	48 c7 80 b8 1f 06 81 	movq   $0x0,-0x7ef9e048(%rax)
ffffffff8100288a:	00 00 00 00 
ffffffff8100288e:	48 83 c0 40          	add    $0x40,%rax
#include "memory.hpp"
#include "string.hpp"

uint16 Cow::frame_index_max = 0;
uint16 Cow::elt_index_max = 0;
struct Cow::cow_elt Cow::cow_list[NB_COW_ELT];
ffffffff81002892:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
ffffffff81002898:	75 e2                	jne    ffffffff8100287c <_GLOBAL__sub_I__ZN3Cow15frame_index_maxE+0x2>
ffffffff8100289a:	31 c0                	xor    %eax,%eax
public:
    static uint16 frame_index_max;
    static uint16 elt_index_max;
    static bool max_displayed;

    struct cow_frame {
ffffffff8100289c:	c6 80 8a 1f 02 81 00 	movb   $0x0,-0x7efde076(%rax)
ffffffff810028a3:	48 83 c0 10          	add    $0x10,%rax
struct Cow::cow_frame Cow::cow_frames[NB_COW_FRAME];
ffffffff810028a7:	48 3d 00 00 04 00    	cmp    $0x40000,%rax
ffffffff810028ad:	75 ed                	jne    ffffffff8100289c <_GLOBAL__sub_I__ZN3Cow15frame_index_maxE+0x22>
ffffffff810028af:	31 c0                	xor    %eax,%eax
        bool used = false;
        struct cow_elt *next = nullptr;
    };
    static struct cow_elt cow_list[NB_COW_ELT];

    struct block {
ffffffff810028b1:	c6 80 10 1e 02 81 00 	movb   $0x0,-0x7efde1f0(%rax)
ffffffff810028b8:	48 c7 80 18 1e 02 81 	movq   $0x0,-0x7efde1e8(%rax)
ffffffff810028bf:	00 00 00 00 
ffffffff810028c3:	48 83 c0 20          	add    $0x20,%rax
bool Cow::max_displayed = false;
struct Cow::block Cow::block_elts[NB_BLOCK_ELT];
ffffffff810028c7:	48 3d 40 01 00 00    	cmp    $0x140,%rax
ffffffff810028cd:	75 e2                	jne    ffffffff810028b1 <_GLOBAL__sub_I__ZN3Cow15frame_index_maxE+0x37>
    private:
        uint16 val;

    public:
        ALWAYS_INLINE
        inline Spinlock() : val (0) {}
ffffffff810028cf:	66 c7 05 18 f5 01 00 	movw   $0x0,0x1f518(%rip)        # ffffffff81021df0 <_ZN3Cow8cow_lockE>
ffffffff810028d6:	00 00 
ffffffff810028d8:	c3                   	retq   
ffffffff810028d9:	90                   	nop

ffffffff810028da <_ZN3Cpu4initEv>:

    set_cr4 (get_cr4() | Cpu::CR4_PCIDE);
}

void Cpu::init()
{
ffffffff810028da:	53                   	push   %rbx
    for (void (**func)() = &CTORS_L; func != &CTORS_C; (*func++)()) ;
ffffffff810028db:	48 c7 c3 b0 15 02 81 	mov    $0xffffffff810215b0,%rbx

    set_cr4 (get_cr4() | Cpu::CR4_PCIDE);
}

void Cpu::init()
{
ffffffff810028e2:	48 83 ec 20          	sub    $0x20,%rsp
    for (void (**func)() = &CTORS_L; func != &CTORS_C; (*func++)()) ;
ffffffff810028e6:	48 81 fb c8 15 02 81 	cmp    $0xffffffff810215c8,%rbx
ffffffff810028ed:	74 09                	je     ffffffff810028f8 <_ZN3Cpu4initEv+0x1e>
ffffffff810028ef:	48 83 c3 08          	add    $0x8,%rbx
ffffffff810028f3:	ff 53 f8             	callq  *-0x8(%rbx)
ffffffff810028f6:	eb ee                	jmp    ffffffff810028e6 <_ZN3Cpu4initEv+0xc>

    Gdt::build();
ffffffff810028f8:	e8 8d 50 00 00       	callq  ffffffff8100798a <_ZN3Gdt5buildEv>
    Tss::build();
ffffffff810028fd:	e8 04 85 01 00       	callq  ffffffff8101ae06 <_ZN3Tss5buildEv>
        uint16  limit;
        mword   base;

    public:
        ALWAYS_INLINE
        inline Pseudo_descriptor (mword l, mword b) : limit (static_cast<uint16>(l)), base (b) {}
ffffffff81002902:	66 c7 44 24 10 4f 00 	movw   $0x4f,0x10(%rsp)
ffffffff81002909:	48 c7 44 24 12 c8 f7 	movq   $0xffffffffbffff7c8,0x12(%rsp)
ffffffff81002910:	ff bf 
        static void build();

        ALWAYS_INLINE
        static inline void load()
        {
            asm volatile ("lgdt %0" : : "m" (Pseudo_descriptor (sizeof (gdt) - 1, reinterpret_cast<mword>(gdt))));
ffffffff81002912:	0f 01 54 24 10       	lgdt   0x10(%rsp)
        static void build();

        ALWAYS_INLINE
        static inline void load()
        {
            asm volatile ("ltr %w0" : : "rm" (SEL_TSS_RUN));
ffffffff81002917:	b8 30 00 00 00       	mov    $0x30,%eax
ffffffff8100291c:	0f 00 d8             	ltr    %ax
ffffffff8100291f:	66 c7 44 24 10 9f 0a 	movw   $0xa9f,0x10(%rsp)
ffffffff81002926:	48 c7 44 24 12 90 2d 	movq   $0xffffffff81162d90,0x12(%rsp)
ffffffff8100292d:	16 81 
        static void build();

        ALWAYS_INLINE
        static inline void load()
        {
            asm volatile ("lidt %0" : : "m" (Pseudo_descriptor (sizeof (idt) - 1, reinterpret_cast<mword>(idt))));
ffffffff8100292f:	0f 01 5c 24 10       	lidt   0x10(%rsp)
        }

        ALWAYS_INLINE
        static inline void cpuid (unsigned leaf, uint32 &eax, uint32 &ebx, uint32 &ecx, uint32 &edx)
        {
            asm volatile ("cpuid" : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx) : "a" (leaf));
ffffffff81002934:	30 c0                	xor    %al,%al
ffffffff81002936:	0f a2                	cpuid  

    cpuid (0, eax, ebx, ecx, edx);

    size_t v;
    for (v = sizeof (vendor_string) / sizeof (*vendor_string); --v;)
        if (*reinterpret_cast<uint32 const *>(vendor_string[v] + 0) == ebx &&
ffffffff81002938:	39 1d 25 b0 01 00    	cmp    %ebx,0x1b025(%rip)        # ffffffff8101d963 <_ZZN3Cpu15preempt_disableEvE19__PRETTY_FUNCTION__+0x23>
ffffffff8100293e:	89 c7                	mov    %eax,%edi
ffffffff81002940:	75 15                	jne    ffffffff81002957 <_ZN3Cpu4initEv+0x7d>
ffffffff81002942:	39 15 1f b0 01 00    	cmp    %edx,0x1b01f(%rip)        # ffffffff8101d967 <_ZZN3Cpu15preempt_disableEvE19__PRETTY_FUNCTION__+0x27>
ffffffff81002948:	75 0d                	jne    ffffffff81002957 <_ZN3Cpu4initEv+0x7d>
            *reinterpret_cast<uint32 const *>(vendor_string[v] + 4) == edx &&
ffffffff8100294a:	39 0d 1b b0 01 00    	cmp    %ecx,0x1b01b(%rip)        # ffffffff8101d96b <_ZZN3Cpu15preempt_disableEvE19__PRETTY_FUNCTION__+0x2b>
    uint32 eax, ebx, ecx, edx;

    cpuid (0, eax, ebx, ecx, edx);

    size_t v;
    for (v = sizeof (vendor_string) / sizeof (*vendor_string); --v;)
ffffffff81002950:	be 02 00 00 00       	mov    $0x2,%esi
        if (*reinterpret_cast<uint32 const *>(vendor_string[v] + 0) == ebx &&
            *reinterpret_cast<uint32 const *>(vendor_string[v] + 4) == edx &&
ffffffff81002955:	74 1e                	je     ffffffff81002975 <_ZN3Cpu4initEv+0x9b>
    uint32 eax, ebx, ecx, edx;

    cpuid (0, eax, ebx, ecx, edx);

    size_t v;
    for (v = sizeof (vendor_string) / sizeof (*vendor_string); --v;)
ffffffff81002957:	31 f6                	xor    %esi,%esi
        if (*reinterpret_cast<uint32 const *>(vendor_string[v] + 0) == ebx &&
ffffffff81002959:	39 1d 11 b0 01 00    	cmp    %ebx,0x1b011(%rip)        # ffffffff8101d970 <_ZZN3Cpu15preempt_disableEvE19__PRETTY_FUNCTION__+0x30>
ffffffff8100295f:	75 14                	jne    ffffffff81002975 <_ZN3Cpu4initEv+0x9b>
ffffffff81002961:	39 15 0d b0 01 00    	cmp    %edx,0x1b00d(%rip)        # ffffffff8101d974 <_ZZN3Cpu15preempt_disableEvE19__PRETTY_FUNCTION__+0x34>
ffffffff81002967:	75 0c                	jne    ffffffff81002975 <_ZN3Cpu4initEv+0x9b>
            *reinterpret_cast<uint32 const *>(vendor_string[v] + 4) == edx &&
ffffffff81002969:	31 f6                	xor    %esi,%esi
ffffffff8100296b:	39 0d 07 b0 01 00    	cmp    %ecx,0x1b007(%rip)        # ffffffff8101d978 <_ZZN3Cpu15preempt_disableEvE19__PRETTY_FUNCTION__+0x38>
ffffffff81002971:	40 0f 94 c6          	sete   %sil
            *reinterpret_cast<uint32 const *>(vendor_string[v] + 8) == ecx)
            break;

    vendor = Vendor (v);
ffffffff81002975:	89 35 31 ce ff 3e    	mov    %esi,0x3effce31(%rip)        # ffffffffbffff7ac <_ZN3Cpu6vendorE>

    if (vendor == INTEL) {
ffffffff8100297b:	48 ff ce             	dec    %rsi
ffffffff8100297e:	75 27                	jne    ffffffff810029a7 <_ZN3Cpu4initEv+0xcd>
ffffffff81002980:	31 c0                	xor    %eax,%eax
ffffffff81002982:	b9 8b 00 00 00       	mov    $0x8b,%ecx
ffffffff81002987:	48 89 c2             	mov    %rax,%rdx
ffffffff8100298a:	0f 30                	wrmsr  
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
ffffffff8100298c:	b1 17                	mov    $0x17,%cl
ffffffff8100298e:	0f 32                	rdmsr  
            return static_cast<T>(static_cast<uint64>(h) << 32 | l);
ffffffff81002990:	48 89 d1             	mov    %rdx,%rcx
ffffffff81002993:	48 c1 e1 20          	shl    $0x20,%rcx
ffffffff81002997:	48 09 c1             	or     %rax,%rcx
        Msr::write<uint64>(Msr::IA32_BIOS_SIGN_ID, 0);
        platform = static_cast<unsigned>(Msr::read<uint64>(Msr::IA32_PLATFORM_ID) >> 50) & 7;
ffffffff8100299a:	48 c1 e9 32          	shr    $0x32,%rcx
ffffffff8100299e:	83 e1 07             	and    $0x7,%ecx
ffffffff810029a1:	89 0d 01 ce ff 3e    	mov    %ecx,0x3effce01(%rip)        # ffffffffbffff7a8 <_ZN3Cpu8platformE>
ffffffff810029a7:	40 0f b6 c7          	movzbl %dil,%eax
    }

    switch (static_cast<uint8>(eax)) {
ffffffff810029ab:	ff c8                	dec    %eax
ffffffff810029ad:	83 f8 05             	cmp    $0x5,%eax
ffffffff810029b0:	77 07                	ja     ffffffff810029b9 <_ZN3Cpu4initEv+0xdf>
ffffffff810029b2:	ff 24 c5 d0 d9 01 81 	jmpq   *-0x7efe2630(,%rax,8)
        }

        ALWAYS_INLINE
        static inline void cpuid (unsigned leaf, unsigned subleaf, uint32 &eax, uint32 &ebx, uint32 &ecx, uint32 &edx)
        {
            asm volatile ("cpuid" : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx) : "a" (leaf), "c" (subleaf));
ffffffff810029b9:	31 c9                	xor    %ecx,%ecx
ffffffff810029bb:	b8 07 00 00 00       	mov    $0x7,%eax
ffffffff810029c0:	0f a2                	cpuid  
ffffffff810029c2:	89 1d 84 cd ff 3e    	mov    %ebx,0x3effcd84(%rip)        # ffffffffbffff74c <_ZN3Cpu8featuresE+0xc>
        }

        ALWAYS_INLINE
        static inline void cpuid (unsigned leaf, uint32 &eax, uint32 &ebx, uint32 &ecx, uint32 &edx)
        {
            asm volatile ("cpuid" : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx) : "a" (leaf));
ffffffff810029c8:	b8 06 00 00 00       	mov    $0x6,%eax
ffffffff810029cd:	0f a2                	cpuid  
ffffffff810029cf:	89 05 73 cd ff 3e    	mov    %eax,0x3effcd73(%rip)        # ffffffffbffff748 <_ZN3Cpu8featuresE+0x8>
        }

        ALWAYS_INLINE
        static inline void cpuid (unsigned leaf, unsigned subleaf, uint32 &eax, uint32 &ebx, uint32 &ecx, uint32 &edx)
        {
            asm volatile ("cpuid" : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx) : "a" (leaf), "c" (subleaf));
ffffffff810029d5:	31 c9                	xor    %ecx,%ecx
ffffffff810029d7:	b8 04 00 00 00       	mov    $0x4,%eax
ffffffff810029dc:	0f a2                	cpuid  
            cpuid (0x7, 0, eax, features[3], ecx, edx);
        case 0x6:
            cpuid (0x6, features[2], ebx, ecx, edx);
        case 0x4 ... 0x5:
            cpuid (0x4, 0, eax, ebx, ecx, edx);
            cpp = (eax >> 26 & 0x3f) + 1;
ffffffff810029de:	c1 e8 1a             	shr    $0x1a,%eax
ffffffff810029e1:	8d 70 01             	lea    0x1(%rax),%esi
ffffffff810029e4:	eb 05                	jmp    ffffffff810029eb <_ZN3Cpu4initEv+0x111>
bool        Cpu::bsp;
bool        Cpu::preemption;

void Cpu::check_features()
{
    unsigned top, tpp = 1, cpp = 1;
ffffffff810029e6:	be 01 00 00 00       	mov    $0x1,%esi
        }

        ALWAYS_INLINE
        static inline void cpuid (unsigned leaf, uint32 &eax, uint32 &ebx, uint32 &ecx, uint32 &edx)
        {
            asm volatile ("cpuid" : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx) : "a" (leaf));
ffffffff810029eb:	b8 01 00 00 00       	mov    $0x1,%eax
ffffffff810029f0:	0f a2                	cpuid  
ffffffff810029f2:	89 15 48 cd ff 3e    	mov    %edx,0x3effcd48(%rip)        # ffffffffbffff740 <_ZN3Cpu8featuresE>
        case 0x4 ... 0x5:
            cpuid (0x4, 0, eax, ebx, ecx, edx);
            cpp = (eax >> 26 & 0x3f) + 1;
        case 0x1 ... 0x3:
            cpuid (0x1, eax, ebx, features[1], features[0]);
            family   = (eax >> 8 & 0xf) + (eax >> 20 & 0xff);
ffffffff810029f8:	89 c2                	mov    %eax,%edx
ffffffff810029fa:	89 0d 44 cd ff 3e    	mov    %ecx,0x3effcd44(%rip)        # ffffffffbffff744 <_ZN3Cpu8featuresE+0x4>
ffffffff81002a00:	c1 ea 14             	shr    $0x14,%edx
            model    = (eax >> 4 & 0xf) + (eax >> 12 & 0xf0);
            stepping =  eax & 0xf;
            brand    =  ebx & 0xff;
            top      =  ebx >> 24;
ffffffff81002a03:	41 89 d8             	mov    %ebx,%r8d
        case 0x4 ... 0x5:
            cpuid (0x4, 0, eax, ebx, ecx, edx);
            cpp = (eax >> 26 & 0x3f) + 1;
        case 0x1 ... 0x3:
            cpuid (0x1, eax, ebx, features[1], features[0]);
            family   = (eax >> 8 & 0xf) + (eax >> 20 & 0xff);
ffffffff81002a06:	0f b6 ca             	movzbl %dl,%ecx
ffffffff81002a09:	89 c2                	mov    %eax,%edx
            model    = (eax >> 4 & 0xf) + (eax >> 12 & 0xf0);
            stepping =  eax & 0xf;
            brand    =  ebx & 0xff;
            top      =  ebx >> 24;
ffffffff81002a0b:	41 c1 e8 18          	shr    $0x18,%r8d
        case 0x4 ... 0x5:
            cpuid (0x4, 0, eax, ebx, ecx, edx);
            cpp = (eax >> 26 & 0x3f) + 1;
        case 0x1 ... 0x3:
            cpuid (0x1, eax, ebx, features[1], features[0]);
            family   = (eax >> 8 & 0xf) + (eax >> 20 & 0xff);
ffffffff81002a0f:	c1 ea 08             	shr    $0x8,%edx
ffffffff81002a12:	83 e2 0f             	and    $0xf,%edx
ffffffff81002a15:	01 ca                	add    %ecx,%edx
ffffffff81002a17:	89 15 87 cd ff 3e    	mov    %edx,0x3effcd87(%rip)        # ffffffffbffff7a4 <_ZN3Cpu6familyE>
            model    = (eax >> 4 & 0xf) + (eax >> 12 & 0xf0);
ffffffff81002a1d:	89 c2                	mov    %eax,%edx
ffffffff81002a1f:	c1 ea 0c             	shr    $0xc,%edx
ffffffff81002a22:	89 d1                	mov    %edx,%ecx
ffffffff81002a24:	89 c2                	mov    %eax,%edx
            stepping =  eax & 0xf;
ffffffff81002a26:	83 e0 0f             	and    $0xf,%eax
            cpuid (0x4, 0, eax, ebx, ecx, edx);
            cpp = (eax >> 26 & 0x3f) + 1;
        case 0x1 ... 0x3:
            cpuid (0x1, eax, ebx, features[1], features[0]);
            family   = (eax >> 8 & 0xf) + (eax >> 20 & 0xff);
            model    = (eax >> 4 & 0xf) + (eax >> 12 & 0xf0);
ffffffff81002a29:	c1 ea 04             	shr    $0x4,%edx
            stepping =  eax & 0xf;
ffffffff81002a2c:	89 05 6a cd ff 3e    	mov    %eax,0x3effcd6a(%rip)        # ffffffffbffff79c <_ZN3Cpu8steppingE>
            brand    =  ebx & 0xff;
ffffffff81002a32:	0f b6 c3             	movzbl %bl,%eax
            cpuid (0x4, 0, eax, ebx, ecx, edx);
            cpp = (eax >> 26 & 0x3f) + 1;
        case 0x1 ... 0x3:
            cpuid (0x1, eax, ebx, features[1], features[0]);
            family   = (eax >> 8 & 0xf) + (eax >> 20 & 0xff);
            model    = (eax >> 4 & 0xf) + (eax >> 12 & 0xf0);
ffffffff81002a35:	81 e1 f0 00 00 00    	and    $0xf0,%ecx
ffffffff81002a3b:	83 e2 0f             	and    $0xf,%edx
            stepping =  eax & 0xf;
            brand    =  ebx & 0xff;
ffffffff81002a3e:	89 05 54 cd ff 3e    	mov    %eax,0x3effcd54(%rip)        # ffffffffbffff798 <_ZN3Cpu5brandE>
            top      =  ebx >> 24;
            tpp      =  ebx >> 16 & 0xff;
ffffffff81002a44:	89 d8                	mov    %ebx,%eax
            cpuid (0x4, 0, eax, ebx, ecx, edx);
            cpp = (eax >> 26 & 0x3f) + 1;
        case 0x1 ... 0x3:
            cpuid (0x1, eax, ebx, features[1], features[0]);
            family   = (eax >> 8 & 0xf) + (eax >> 20 & 0xff);
            model    = (eax >> 4 & 0xf) + (eax >> 12 & 0xf0);
ffffffff81002a46:	01 ca                	add    %ecx,%edx
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
ffffffff81002a48:	b9 8b 00 00 00       	mov    $0x8b,%ecx
            stepping =  eax & 0xf;
            brand    =  ebx & 0xff;
            top      =  ebx >> 24;
            tpp      =  ebx >> 16 & 0xff;
ffffffff81002a4d:	c1 e8 10             	shr    $0x10,%eax
            cpuid (0x4, 0, eax, ebx, ecx, edx);
            cpp = (eax >> 26 & 0x3f) + 1;
        case 0x1 ... 0x3:
            cpuid (0x1, eax, ebx, features[1], features[0]);
            family   = (eax >> 8 & 0xf) + (eax >> 20 & 0xff);
            model    = (eax >> 4 & 0xf) + (eax >> 12 & 0xf0);
ffffffff81002a50:	89 15 4a cd ff 3e    	mov    %edx,0x3effcd4a(%rip)        # ffffffffbffff7a0 <_ZN3Cpu5modelE>
            stepping =  eax & 0xf;
            brand    =  ebx & 0xff;
            top      =  ebx >> 24;
            tpp      =  ebx >> 16 & 0xff;
ffffffff81002a56:	0f b6 f8             	movzbl %al,%edi
ffffffff81002a59:	0f 32                	rdmsr  
            return static_cast<T>(static_cast<uint64>(h) << 32 | l);
ffffffff81002a5b:	48 89 d1             	mov    %rdx,%rcx
ffffffff81002a5e:	48 c1 e1 20          	shl    $0x20,%rcx
ffffffff81002a62:	48 09 c1             	or     %rax,%rcx
ffffffff81002a65:	b8 00 00 00 80       	mov    $0x80000000,%eax
    }

    patch = static_cast<unsigned>(Msr::read<uint64>(Msr::IA32_BIOS_SIGN_ID) >> 32);
ffffffff81002a6a:	48 c1 e9 20          	shr    $0x20,%rcx
ffffffff81002a6e:	89 0d 20 cd ff 3e    	mov    %ecx,0x3effcd20(%rip)        # ffffffffbffff794 <_ZN3Cpu5patchE>
ffffffff81002a74:	0f a2                	cpuid  

    cpuid (0x80000000, eax, ebx, ecx, edx);

    if (eax & 0x80000000) {
ffffffff81002a76:	85 c0                	test   %eax,%eax
ffffffff81002a78:	0f 89 94 00 00 00    	jns    ffffffff81002b12 <_ZN3Cpu4initEv+0x238>
ffffffff81002a7e:	0f b6 c0             	movzbl %al,%eax
        switch (static_cast<uint8>(eax)) {
ffffffff81002a81:	ff c8                	dec    %eax
ffffffff81002a83:	83 f8 08             	cmp    $0x8,%eax
ffffffff81002a86:	77 07                	ja     ffffffff81002a8f <_ZN3Cpu4initEv+0x1b5>
ffffffff81002a88:	ff 24 c5 00 da 01 81 	jmpq   *-0x7efe2600(,%rax,8)
ffffffff81002a8f:	b8 0a 00 00 80       	mov    $0x8000000a,%eax
ffffffff81002a94:	0f a2                	cpuid  
ffffffff81002a96:	89 05 88 d2 ff 3e    	mov    %eax,0x3effd288(%rip)        # ffffffffbffffd24 <_ZN4Vmcb11svm_versionE>
ffffffff81002a9c:	89 15 7e d2 ff 3e    	mov    %edx,0x3effd27e(%rip)        # ffffffffbffffd20 <_ZN4Vmcb11svm_featureE>
ffffffff81002aa2:	b8 04 00 00 80       	mov    $0x80000004,%eax
ffffffff81002aa7:	0f a2                	cpuid  
ffffffff81002aa9:	89 05 d1 cc ff 3e    	mov    %eax,0x3effccd1(%rip)        # ffffffffbffff780 <_ZN3Cpu4nameE+0x20>
ffffffff81002aaf:	89 1d cf cc ff 3e    	mov    %ebx,0x3effcccf(%rip)        # ffffffffbffff784 <_ZN3Cpu4nameE+0x24>
ffffffff81002ab5:	89 0d cd cc ff 3e    	mov    %ecx,0x3effcccd(%rip)        # ffffffffbffff788 <_ZN3Cpu4nameE+0x28>
ffffffff81002abb:	89 15 cb cc ff 3e    	mov    %edx,0x3effcccb(%rip)        # ffffffffbffff78c <_ZN3Cpu4nameE+0x2c>
ffffffff81002ac1:	b8 03 00 00 80       	mov    $0x80000003,%eax
ffffffff81002ac6:	0f a2                	cpuid  
ffffffff81002ac8:	89 05 a2 cc ff 3e    	mov    %eax,0x3effcca2(%rip)        # ffffffffbffff770 <_ZN3Cpu4nameE+0x10>
ffffffff81002ace:	89 1d a0 cc ff 3e    	mov    %ebx,0x3effcca0(%rip)        # ffffffffbffff774 <_ZN3Cpu4nameE+0x14>
ffffffff81002ad4:	89 0d 9e cc ff 3e    	mov    %ecx,0x3effcc9e(%rip)        # ffffffffbffff778 <_ZN3Cpu4nameE+0x18>
ffffffff81002ada:	89 15 9c cc ff 3e    	mov    %edx,0x3effcc9c(%rip)        # ffffffffbffff77c <_ZN3Cpu4nameE+0x1c>
ffffffff81002ae0:	b8 02 00 00 80       	mov    $0x80000002,%eax
ffffffff81002ae5:	0f a2                	cpuid  
ffffffff81002ae7:	89 05 73 cc ff 3e    	mov    %eax,0x3effcc73(%rip)        # ffffffffbffff760 <_ZN3Cpu4nameE>
ffffffff81002aed:	89 1d 71 cc ff 3e    	mov    %ebx,0x3effcc71(%rip)        # ffffffffbffff764 <_ZN3Cpu4nameE+0x4>
ffffffff81002af3:	89 0d 6f cc ff 3e    	mov    %ecx,0x3effcc6f(%rip)        # ffffffffbffff768 <_ZN3Cpu4nameE+0x8>
ffffffff81002af9:	89 15 6d cc ff 3e    	mov    %edx,0x3effcc6d(%rip)        # ffffffffbffff76c <_ZN3Cpu4nameE+0xc>
ffffffff81002aff:	b8 01 00 00 80       	mov    $0x80000001,%eax
ffffffff81002b04:	0f a2                	cpuid  
ffffffff81002b06:	89 0d 48 cc ff 3e    	mov    %ecx,0x3effcc48(%rip)        # ffffffffbffff754 <_ZN3Cpu8featuresE+0x14>
ffffffff81002b0c:	89 15 3e cc ff 3e    	mov    %edx,0x3effcc3e(%rip)        # ffffffffbffff750 <_ZN3Cpu8featuresE+0x10>
                cpuid (0x80000001, eax, ebx, features[5], features[4]);
        }
    }

    if (feature (FEAT_CMP_LEGACY))
        cpp = tpp;
ffffffff81002b12:	f6 05 3b cc ff 3e 02 	testb  $0x2,0x3effcc3b(%rip)        # ffffffffbffff754 <_ZN3Cpu8featuresE+0x14>

    unsigned tpc = tpp / cpp;
ffffffff81002b19:	89 f8                	mov    %edi,%eax
                cpuid (0x80000001, eax, ebx, features[5], features[4]);
        }
    }

    if (feature (FEAT_CMP_LEGACY))
        cpp = tpp;
ffffffff81002b1b:	0f 45 f7             	cmovne %edi,%esi

    unsigned tpc = tpp / cpp;
ffffffff81002b1e:	31 d2                	xor    %edx,%edx
ffffffff81002b20:	f7 f6                	div    %esi
    unsigned long t_bits = bit_scan_reverse (tpc - 1) + 1;
ffffffff81002b22:	8d 78 ff             	lea    -0x1(%rax),%edi

ALWAYS_INLINE
inline long int bit_scan_reverse (mword val)
{
    if (EXPECT_FALSE (!val))
        return -1;
ffffffff81002b25:	48 83 c8 ff          	or     $0xffffffffffffffff,%rax
#include "util.hpp"

ALWAYS_INLINE
inline long int bit_scan_reverse (mword val)
{
    if (EXPECT_FALSE (!val))
ffffffff81002b29:	48 85 ff             	test   %rdi,%rdi
ffffffff81002b2c:	74 04                	je     ffffffff81002b32 <_ZN3Cpu4initEv+0x258>
        return -1;

    asm volatile ("bsr %1, %0" : "=r" (val) : "rm" (val));

    return val;
ffffffff81002b2e:	48 0f bd c7          	bsr    %rdi,%rax
    unsigned long c_bits = bit_scan_reverse (cpp - 1) + 1;
ffffffff81002b32:	8d 56 ff             	lea    -0x1(%rsi),%edx

    if (feature (FEAT_CMP_LEGACY))
        cpp = tpp;

    unsigned tpc = tpp / cpp;
    unsigned long t_bits = bit_scan_reverse (tpc - 1) + 1;
ffffffff81002b35:	48 ff c0             	inc    %rax

ALWAYS_INLINE
inline long int bit_scan_reverse (mword val)
{
    if (EXPECT_FALSE (!val))
        return -1;
ffffffff81002b38:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
#include "util.hpp"

ALWAYS_INLINE
inline long int bit_scan_reverse (mword val)
{
    if (EXPECT_FALSE (!val))
ffffffff81002b3c:	85 d2                	test   %edx,%edx
ffffffff81002b3e:	74 04                	je     ffffffff81002b44 <_ZN3Cpu4initEv+0x26a>
        return -1;

    asm volatile ("bsr %1, %0" : "=r" (val) : "rm" (val));

    return val;
ffffffff81002b40:	48 0f bd ca          	bsr    %rdx,%rcx
    unsigned long c_bits = bit_scan_reverse (cpp - 1) + 1;

    thread  = top            & ((1u << t_bits) - 1);
ffffffff81002b44:	ba 01 00 00 00       	mov    $0x1,%edx
    if (feature (FEAT_CMP_LEGACY))
        cpp = tpp;

    unsigned tpc = tpp / cpp;
    unsigned long t_bits = bit_scan_reverse (tpc - 1) + 1;
    unsigned long c_bits = bit_scan_reverse (cpp - 1) + 1;
ffffffff81002b49:	48 8d 71 01          	lea    0x1(%rcx),%rsi

    thread  = top            & ((1u << t_bits) - 1);
ffffffff81002b4d:	88 c1                	mov    %al,%cl
ffffffff81002b4f:	89 d7                	mov    %edx,%edi
ffffffff81002b51:	d3 e7                	shl    %cl,%edi
ffffffff81002b53:	89 f9                	mov    %edi,%ecx
    core    = top >>  t_bits & ((1u << c_bits) - 1);
ffffffff81002b55:	44 89 c7             	mov    %r8d,%edi

    unsigned tpc = tpp / cpp;
    unsigned long t_bits = bit_scan_reverse (tpc - 1) + 1;
    unsigned long c_bits = bit_scan_reverse (cpp - 1) + 1;

    thread  = top            & ((1u << t_bits) - 1);
ffffffff81002b58:	ff c9                	dec    %ecx
ffffffff81002b5a:	44 21 c1             	and    %r8d,%ecx
ffffffff81002b5d:	89 0d 4d cc ff 3e    	mov    %ecx,0x3effcc4d(%rip)        # ffffffffbffff7b0 <_ZN3Cpu6threadE>
    core    = top >>  t_bits & ((1u << c_bits) - 1);
ffffffff81002b63:	40 88 f1             	mov    %sil,%cl
ffffffff81002b66:	d3 e2                	shl    %cl,%edx
ffffffff81002b68:	88 c1                	mov    %al,%cl
ffffffff81002b6a:	d3 ef                	shr    %cl,%edi
    package = top >> (t_bits + c_bits);
ffffffff81002b6c:	8d 0c 06             	lea    (%rsi,%rax,1),%ecx
    unsigned tpc = tpp / cpp;
    unsigned long t_bits = bit_scan_reverse (tpc - 1) + 1;
    unsigned long c_bits = bit_scan_reverse (cpp - 1) + 1;

    thread  = top            & ((1u << t_bits) - 1);
    core    = top >>  t_bits & ((1u << c_bits) - 1);
ffffffff81002b6f:	ff ca                	dec    %edx
ffffffff81002b71:	21 fa                	and    %edi,%edx
    package = top >> (t_bits + c_bits);
ffffffff81002b73:	41 d3 e8             	shr    %cl,%r8d

    // Disable C1E on AMD Rev.F and beyond because it stops LAPIC clock
    if (vendor == AMD)
ffffffff81002b76:	83 3d 2f cc ff 3e 02 	cmpl   $0x2,0x3effcc2f(%rip)        # ffffffffbffff7ac <_ZN3Cpu6vendorE>
    unsigned tpc = tpp / cpp;
    unsigned long t_bits = bit_scan_reverse (tpc - 1) + 1;
    unsigned long c_bits = bit_scan_reverse (cpp - 1) + 1;

    thread  = top            & ((1u << t_bits) - 1);
    core    = top >>  t_bits & ((1u << c_bits) - 1);
ffffffff81002b7d:	89 15 31 cc ff 3e    	mov    %edx,0x3effcc31(%rip)        # ffffffffbffff7b4 <_ZN3Cpu4coreE>
    package = top >> (t_bits + c_bits);
ffffffff81002b83:	44 89 05 2e cc ff 3e 	mov    %r8d,0x3effcc2e(%rip)        # ffffffffbffff7b8 <_ZN3Cpu7packageE>

    // Disable C1E on AMD Rev.F and beyond because it stops LAPIC clock
    if (vendor == AMD)
ffffffff81002b8a:	75 24                	jne    ffffffff81002bb0 <_ZN3Cpu4initEv+0x2d6>
        if (family > 0xf || (family == 0xf && model >= 0x40))
ffffffff81002b8c:	83 3d 11 cc ff 3e 0f 	cmpl   $0xf,0x3effcc11(%rip)        # ffffffffbffff7a4 <_ZN3Cpu6familyE>
ffffffff81002b93:	77 0b                	ja     ffffffff81002ba0 <_ZN3Cpu4initEv+0x2c6>
ffffffff81002b95:	75 19                	jne    ffffffff81002bb0 <_ZN3Cpu4initEv+0x2d6>
ffffffff81002b97:	83 3d 02 cc ff 3e 3f 	cmpl   $0x3f,0x3effcc02(%rip)        # ffffffffbffff7a0 <_ZN3Cpu5modelE>
ffffffff81002b9e:	76 10                	jbe    ffffffff81002bb0 <_ZN3Cpu4initEv+0x2d6>
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
ffffffff81002ba0:	b9 55 00 01 c0       	mov    $0xc0010055,%ecx
ffffffff81002ba5:	0f 32                	rdmsr  

        template <typename T>
        ALWAYS_INLINE
        static inline void write (Register msr, T val)
        {
            asm volatile ("wrmsr" : : "a" (static_cast<mword>(val)), "d" (static_cast<mword>(static_cast<uint64>(val) >> 32)), "c" (msr));
ffffffff81002ba7:	31 d2                	xor    %edx,%edx
            Msr::write (Msr::AMD_IPMR, Msr::read<uint32>(Msr::AMD_IPMR) & ~(3ul << 27));
ffffffff81002ba9:	25 ff ff ff e7       	and    $0xe7ffffff,%eax
ffffffff81002bae:	0f 30                	wrmsr  
ffffffff81002bb0:	b8 01 00 00 00       	mov    $0x1,%eax
ffffffff81002bb5:	0f a2                	cpuid  

    // enable PAT if available
    cpuid (0x1, eax, ebx, ecx, edx);
    if (edx & (1 << 16)) {
ffffffff81002bb7:	81 e2 00 00 01 00    	and    $0x10000,%edx
ffffffff81002bbd:	48 8d 5c 24 0f       	lea    0xf(%rsp),%rbx
ffffffff81002bc2:	74 15                	je     ffffffff81002bd9 <_ZN3Cpu4initEv+0x2ff>
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
ffffffff81002bc4:	b9 77 02 00 00       	mov    $0x277,%ecx
ffffffff81002bc9:	0f 32                	rdmsr  
        uint32 cr_pat = Msr::read<uint32>(Msr::IA32_CR_PAT) & 0xffff00ff;

        cr_pat |= 1 << 8;
ffffffff81002bcb:	25 ff 00 ff ff       	and    $0xffff00ff,%eax

        template <typename T>
        ALWAYS_INLINE
        static inline void write (Register msr, T val)
        {
            asm volatile ("wrmsr" : : "a" (static_cast<mword>(val)), "d" (static_cast<mword>(static_cast<uint64>(val) >> 32)), "c" (msr));
ffffffff81002bd0:	31 d2                	xor    %edx,%edx
ffffffff81002bd2:	80 cc 01             	or     $0x1,%ah
ffffffff81002bd5:	0f 30                	wrmsr  
ffffffff81002bd7:	eb 2d                	jmp    ffffffff81002c06 <_ZN3Cpu4initEv+0x32c>
        Msr::write<uint32>(Msr::IA32_CR_PAT, cr_pat);
    } else
        trace (0, "warning: no PAT support");
ffffffff81002bd9:	8b 05 25 c4 ff 3e    	mov    0x3effc425(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81002bdf:	48 89 da             	mov    %rbx,%rdx
ffffffff81002be2:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81002be6:	48 81 e2 00 f0 ff ff 	and    $0xfffffffffffff000,%rdx
ffffffff81002bed:	48 c7 c7 7d d9 01 81 	mov    $0xffffffff8101d97d,%rdi
ffffffff81002bf4:	48 81 fa 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rdx
ffffffff81002bfb:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff81002bff:	31 c0                	xor    %eax,%eax
ffffffff81002c01:	e8 86 f4 ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
    Idt::load();

    // Initialize CPU number and check features
    check_features();

    Lapic::init();
ffffffff81002c06:	e8 59 58 00 00       	callq  ffffffff81008464 <_ZN5Lapic4initEv>

    row = Console_vga::con.spinner (id);
ffffffff81002c0b:	8b 05 f3 c3 ff 3e    	mov    0x3effc3f3(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>

        INIT
        void setup();

        ALWAYS_INLINE
        inline unsigned spinner (unsigned id) { return id < 25 - num ? 24 - id : 0; }
ffffffff81002c11:	b9 19 00 00 00       	mov    $0x19,%ecx
ffffffff81002c16:	2b 0d c4 f1 01 00    	sub    0x1f1c4(%rip),%ecx        # ffffffff81021de0 <_ZN11Console_vga3conE+0x10>
ffffffff81002c1c:	31 d2                	xor    %edx,%edx
ffffffff81002c1e:	39 c8                	cmp    %ecx,%eax
ffffffff81002c20:	73 04                	jae    ffffffff81002c26 <_ZN3Cpu4initEv+0x34c>
ffffffff81002c22:	b2 18                	mov    $0x18,%dl
ffffffff81002c24:	29 c2                	sub    %eax,%edx
ffffffff81002c26:	89 15 64 cb ff 3e    	mov    %edx,0x3effcb64(%rip)        # ffffffffbffff790 <_ZN3Cpu3rowE>
    }

    ALWAYS_INLINE
    static inline mword current() {
        mword addr;
        asm volatile ("mov %%cr3, %0" : "=r" (addr));
ffffffff81002c2c:	0f 20 da             	mov    %cr3,%rdx

    Paddr phys; mword attr;
    Pd::kern.Space_mem::loc[id] = Hptp (Hpt::current());
ffffffff81002c2f:	48 83 c0 14          	add    $0x14,%rax
    Pd::kern.Space_mem::loc[id].lookup (CPU_LOCAL_DATA, phys, attr);
ffffffff81002c33:	48 8d 4c 24 08       	lea    0x8(%rsp),%rcx
ffffffff81002c38:	48 c7 c6 00 f0 ff bf 	mov    $0xffffffffbffff000,%rsi
    Lapic::init();

    row = Console_vga::con.spinner (id);

    Paddr phys; mword attr;
    Pd::kern.Space_mem::loc[id] = Hptp (Hpt::current());
ffffffff81002c3f:	48 8d 3c c5 a0 3c 16 	lea    -0x7ee9c360(,%rax,8),%rdi
ffffffff81002c46:	81 
ffffffff81002c47:	48 89 14 c5 a0 3c 16 	mov    %rdx,-0x7ee9c360(,%rax,8)
ffffffff81002c4e:	81 
    Pd::kern.Space_mem::loc[id].lookup (CPU_LOCAL_DATA, phys, attr);
ffffffff81002c4f:	48 89 e2             	mov    %rsp,%rdx
ffffffff81002c52:	e8 7d ff 00 00       	callq  ffffffff81012bd4 <_ZN3PteI3HptmLj4ELj9ELb0EE6lookupEmRmS2_>
    Pd::kern.Space_mem::insert (Pd::kern.quota, HV_GLOBAL_CPUS + id * PAGE_SIZE, 0, Hpt::HPT_NX | Hpt::HPT_G | Hpt::HPT_W | Hpt::HPT_P, phys);
ffffffff81002c57:	8b 15 a7 c3 ff 3e    	mov    0x3effc3a7(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
        }

        ALWAYS_INLINE
        inline void insert (Quota &quota, mword virt, unsigned o, mword attr, Paddr phys)
        {
            hpt.update (quota, virt, o, phys, attr);
ffffffff81002c5d:	6a 00                	pushq  $0x0
ffffffff81002c5f:	31 c9                	xor    %ecx,%ecx
ffffffff81002c61:	6a 00                	pushq  $0x0
ffffffff81002c63:	4c 8b 44 24 10       	mov    0x10(%rsp),%r8
ffffffff81002c68:	48 c7 c6 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rsi
ffffffff81002c6f:	41 b9 03 01 00 00    	mov    $0x103,%r9d
ffffffff81002c75:	48 c7 c7 40 3f 16 81 	mov    $0xffffffff81163f40,%rdi
ffffffff81002c7c:	c1 e2 0c             	shl    $0xc,%edx
ffffffff81002c7f:	48 81 ea 00 00 20 41 	sub    $0x41200000,%rdx
ffffffff81002c86:	e8 8b 00 01 00       	callq  ffffffff81012d16 <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb>
        static void init();

        ALWAYS_INLINE
        static inline bool feature (Feature f)
        {
            return features[f / 32] & 1U << f % 32;
ffffffff81002c8b:	8b 05 bf ca ff 3e    	mov    0x3effcabf(%rip),%eax        # ffffffffbffff750 <_ZN3Cpu8featuresE+0x10>
ffffffff81002c91:	8b 35 a9 ca ff 3e    	mov    0x3effcaa9(%rip),%esi        # ffffffffbffff740 <_ZN3Cpu8featuresE>
    Hpt::ord = min (Hpt::ord, feature (FEAT_1GB_PAGES) ? 26UL : 17UL);
ffffffff81002c97:	5a                   	pop    %rdx
ffffffff81002c98:	48 8b 15 39 ef 01 00 	mov    0x1ef39(%rip),%rdx        # ffffffff81021bd8 <_ZN3Hpt3ordE>
ffffffff81002c9f:	c1 e8 1a             	shr    $0x1a,%eax
ffffffff81002ca2:	83 e0 01             	and    $0x1,%eax
ffffffff81002ca5:	83 f8 01             	cmp    $0x1,%eax
ffffffff81002ca8:	48 19 c0             	sbb    %rax,%rax
ffffffff81002cab:	48 83 e0 f7          	and    $0xfffffffffffffff7,%rax
ffffffff81002caf:	48 83 c0 1a          	add    $0x1a,%rax
ffffffff81002cb3:	48 39 d0             	cmp    %rdx,%rax
ffffffff81002cb6:	48 0f 47 c2          	cmova  %rdx,%rax

    if (EXPECT_TRUE (feature (FEAT_ACPI)))
ffffffff81002cba:	f7 c6 00 00 40 00    	test   $0x400000,%esi

    Paddr phys; mword attr;
    Pd::kern.Space_mem::loc[id] = Hptp (Hpt::current());
    Pd::kern.Space_mem::loc[id].lookup (CPU_LOCAL_DATA, phys, attr);
    Pd::kern.Space_mem::insert (Pd::kern.quota, HV_GLOBAL_CPUS + id * PAGE_SIZE, 0, Hpt::HPT_NX | Hpt::HPT_G | Hpt::HPT_W | Hpt::HPT_P, phys);
    Hpt::ord = min (Hpt::ord, feature (FEAT_1GB_PAGES) ? 26UL : 17UL);
ffffffff81002cc0:	59                   	pop    %rcx
ffffffff81002cc1:	48 89 05 10 ef 01 00 	mov    %rax,0x1ef10(%rip)        # ffffffff81021bd8 <_ZN3Hpt3ordE>

    if (EXPECT_TRUE (feature (FEAT_ACPI)))
ffffffff81002cc8:	74 0e                	je     ffffffff81002cd8 <_ZN3Cpu4initEv+0x3fe>
ffffffff81002cca:	b9 9b 01 00 00       	mov    $0x19b,%ecx
ffffffff81002ccf:	31 d2                	xor    %edx,%edx
ffffffff81002cd1:	b8 10 00 00 00       	mov    $0x10,%eax
ffffffff81002cd6:	0f 30                	wrmsr  
        setup_thermal();

    if (EXPECT_TRUE (feature (FEAT_SEP)))
ffffffff81002cd8:	81 e6 00 08 00 00    	and    $0x800,%esi
ffffffff81002cde:	74 33                	je     ffffffff81002d13 <_ZN3Cpu4initEv+0x439>
ffffffff81002ce0:	b9 81 00 00 c0       	mov    $0xc0000081,%ecx
ffffffff81002ce5:	ba 08 00 1b 00       	mov    $0x1b0008,%edx
ffffffff81002cea:	48 b8 00 00 00 00 08 	movabs $0x1b000800000000,%rax
ffffffff81002cf1:	00 1b 00 
ffffffff81002cf4:	0f 30                	wrmsr  
    Msr::write<mword>(Msr::IA32_SYSENTER_CS,  SEL_KERN_CODE);
    Msr::write<mword>(Msr::IA32_SYSENTER_ESP, reinterpret_cast<mword>(&Tss::run.sp0));
    Msr::write<mword>(Msr::IA32_SYSENTER_EIP, reinterpret_cast<mword>(&entry_sysenter));
#else
    Msr::write<mword>(Msr::IA32_STAR,  static_cast<mword>(SEL_USER_CODE) << 48 | static_cast<mword>(SEL_KERN_CODE) << 32);
    Msr::write<mword>(Msr::IA32_LSTAR, reinterpret_cast<mword>(&entry_sysenter));
ffffffff81002cf6:	48 c7 c0 0c 79 00 81 	mov    $0xffffffff8100790c,%rax
ffffffff81002cfd:	b1 82                	mov    $0x82,%cl
ffffffff81002cff:	48 89 c2             	mov    %rax,%rdx
ffffffff81002d02:	48 c1 ea 20          	shr    $0x20,%rdx
ffffffff81002d06:	0f 30                	wrmsr  
ffffffff81002d08:	31 d2                	xor    %edx,%edx
ffffffff81002d0a:	b1 84                	mov    $0x84,%cl
ffffffff81002d0c:	b8 00 06 00 00       	mov    $0x600,%eax
ffffffff81002d11:	0f 30                	wrmsr  
}

void Cpu::setup_pcid()
{
#ifdef __x86_64__
    if (EXPECT_FALSE (Cmdline::nopcid))
ffffffff81002d13:	80 3d 80 f0 01 00 00 	cmpb   $0x0,0x1f080(%rip)        # ffffffff81021d9a <_ZN7Cmdline6nopcidE>
ffffffff81002d1a:	74 0a                	je     ffffffff81002d26 <_ZN3Cpu4initEv+0x44c>
        }

        ALWAYS_INLINE
        static inline void defeature (Feature f)
        {
            features[f / 32] &= ~(1U << f % 32);
ffffffff81002d1c:	81 25 1e ca ff 3e ff 	andl   $0xfffdffff,0x3effca1e(%rip)        # ffffffffbffff744 <_ZN3Cpu8featuresE+0x4>
ffffffff81002d23:	ff fd ff 
#endif
        defeature (FEAT_PCID);

    if (EXPECT_FALSE (!feature (FEAT_PCID)))
ffffffff81002d26:	f6 05 19 ca ff 3e 02 	testb  $0x2,0x3effca19(%rip)        # ffffffffbffff746 <_ZN3Cpu8featuresE+0x6>
ffffffff81002d2d:	74 0c                	je     ffffffff81002d3b <_ZN3Cpu4initEv+0x461>

ALWAYS_INLINE
static inline mword get_cr4()
{
    mword cr4;
    asm volatile ("mov %%cr4, %0" : "=r" (cr4));
ffffffff81002d2f:	0f 20 e0             	mov    %cr4,%rax
        return;

    set_cr4 (get_cr4() | Cpu::CR4_PCIDE);
ffffffff81002d32:	48 0d 00 00 02 00    	or     $0x20000,%rax
}

ALWAYS_INLINE
static inline void set_cr4 (mword cr4)
{
    asm volatile ("mov %0, %%cr4" : : "r" (cr4));
ffffffff81002d38:	0f 22 e0             	mov    %rax,%cr4
    if (EXPECT_TRUE (feature (FEAT_SEP)))
        setup_sysenter();

    setup_pcid();

    if (EXPECT_TRUE (feature (FEAT_SMEP)))
ffffffff81002d3b:	f6 05 0a ca ff 3e 80 	testb  $0x80,0x3effca0a(%rip)        # ffffffffbffff74c <_ZN3Cpu8featuresE+0xc>
ffffffff81002d42:	74 0c                	je     ffffffff81002d50 <_ZN3Cpu4initEv+0x476>

ALWAYS_INLINE
static inline mword get_cr4()
{
    mword cr4;
    asm volatile ("mov %%cr4, %0" : "=r" (cr4));
ffffffff81002d44:	0f 20 e0             	mov    %cr4,%rax
        set_cr4 (get_cr4() | Cpu::CR4_SMEP);
ffffffff81002d47:	48 0d 00 00 10 00    	or     $0x100000,%rax
}

ALWAYS_INLINE
static inline void set_cr4 (mword cr4)
{
    asm volatile ("mov %0, %%cr4" : : "r" (cr4));
ffffffff81002d4d:	0f 22 e0             	mov    %rax,%cr4

    Vmcs::init();
ffffffff81002d50:	e8 9d 97 01 00       	callq  ffffffff8101c4f2 <_ZN4Vmcs4initEv>
    Vmcb::init();
ffffffff81002d55:	e8 7a 42 01 00       	callq  ffffffff81016fd4 <_ZN4Vmcb4initEv>

    Mca::init();
ffffffff81002d5a:	e8 2b 5a 00 00       	callq  ffffffff8100878a <_ZN3Mca4initEv>

    trace (TRACE_CPU, "CORE:%x:%x:%x %x:%x:%x:%x [%x] %.48s", package, core, thread, family, model, stepping, platform, patch, reinterpret_cast<char *>(name));
ffffffff81002d5f:	8b 05 9f c2 ff 3e    	mov    0x3effc29f(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81002d65:	48 81 e3 00 f0 ff ff 	and    $0xfffffffffffff000,%rbx
ffffffff81002d6c:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81002d70:	48 81 fb 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rbx
ffffffff81002d77:	44 8b 0d 26 ca ff 3e 	mov    0x3effca26(%rip),%r9d        # ffffffffbffff7a4 <_ZN3Cpu6familyE>
ffffffff81002d7e:	44 8b 05 2b ca ff 3e 	mov    0x3effca2b(%rip),%r8d        # ffffffffbffff7b0 <_ZN3Cpu6threadE>
ffffffff81002d85:	8b 0d 29 ca ff 3e    	mov    0x3effca29(%rip),%ecx        # ffffffffbffff7b4 <_ZN3Cpu4coreE>
ffffffff81002d8b:	8b 15 27 ca ff 3e    	mov    0x3effca27(%rip),%edx        # ffffffffbffff7b8 <_ZN3Cpu7packageE>
ffffffff81002d91:	48 c7 c7 9c d9 01 81 	mov    $0xffffffff8101d99c,%rdi
ffffffff81002d98:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff81002d9c:	50                   	push   %rax
ffffffff81002d9d:	8b 05 f1 c9 ff 3e    	mov    0x3effc9f1(%rip),%eax        # ffffffffbffff794 <_ZN3Cpu5patchE>
ffffffff81002da3:	68 60 f7 ff bf       	pushq  $0xffffffffbffff760
ffffffff81002da8:	50                   	push   %rax
ffffffff81002da9:	8b 05 f9 c9 ff 3e    	mov    0x3effc9f9(%rip),%eax        # ffffffffbffff7a8 <_ZN3Cpu8platformE>
ffffffff81002daf:	50                   	push   %rax
ffffffff81002db0:	8b 05 e6 c9 ff 3e    	mov    0x3effc9e6(%rip),%eax        # ffffffffbffff79c <_ZN3Cpu8steppingE>
ffffffff81002db6:	50                   	push   %rax
ffffffff81002db7:	8b 05 e3 c9 ff 3e    	mov    0x3effc9e3(%rip),%eax        # ffffffffbffff7a0 <_ZN3Cpu5modelE>
ffffffff81002dbd:	50                   	push   %rax
ffffffff81002dbe:	31 c0                	xor    %eax,%eax
ffffffff81002dc0:	e8 c7 f2 ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>

    Hip::add_cpu();
ffffffff81002dc5:	48 83 c4 30          	add    $0x30,%rsp
ffffffff81002dc9:	e8 1c 51 00 00       	callq  ffffffff81007eea <_ZN3Hip7add_cpuEv>

    boot_lock++;
ffffffff81002dce:	48 ff 05 73 f2 15 00 	incq   0x15f273(%rip)        # ffffffff81162048 <boot_lock>
}
ffffffff81002dd5:	48 83 c4 20          	add    $0x20,%rsp
ffffffff81002dd9:	5b                   	pop    %rbx
ffffffff81002dda:	c3                   	retq   
ffffffff81002ddb:	90                   	nop

ffffffff81002ddc <_ZN3MdbC1EP5SpacePFvP8Rcu_elemEmmmmmm>:

        NOINLINE
        explicit Mdb (Space *s, mword p, mword b, mword a, void (*f)(Rcu_elem *), void (*pf)(Rcu_elem *) = nullptr) : Rcu_elem (f, pf), dpth (0), prev (this), next (this), prnt (nullptr), space (s), node_phys (p), node_base (b), node_order (0), node_attr (a), node_type (0), node_sub (0) {}

        NOINLINE
        explicit Mdb (Space *s, void (*f)(Rcu_elem *), mword p, mword b, mword o = 0, mword a = 0, mword t = 0, mword sub = 0) : Rcu_elem (f), dpth (0), prev (this), next (this), prnt (nullptr), space (s), node_phys (p), node_base (b), node_order (o), node_attr (a), node_type (t), node_sub (sub) {}
ffffffff81002ddc:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
        enum State { REMOVED = 1, KIM = 2, STALE = 3 };

    protected:
        Avl *lnk[2];

        explicit Avl() : bal (2), sta(0) { lnk[0] = lnk[1] = nullptr; }
ffffffff81002de1:	66 c7 47 10 02 00    	movw   $0x2,0x10(%rdi)
ffffffff81002de7:	66 c7 47 12 00 00    	movw   $0x0,0x12(%rdi)
ffffffff81002ded:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
ffffffff81002df4:	00 
ffffffff81002df5:	48 c7 07 00 00 00 00 	movq   $0x0,(%rdi)
        Rcu_elem *next;
        void (*func)(Rcu_elem *);
        void (*pre_func)(Rcu_elem *);

        ALWAYS_INLINE
        explicit Rcu_elem (void (*f)(Rcu_elem *), void (*pf) (Rcu_elem *) = nullptr) : next (nullptr), func (f), pre_func(pf) {}
ffffffff81002dfc:	48 c7 47 18 00 00 00 	movq   $0x0,0x18(%rdi)
ffffffff81002e03:	00 
ffffffff81002e04:	48 89 47 70          	mov    %rax,0x70(%rdi)
ffffffff81002e08:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
ffffffff81002e0d:	48 89 57 20          	mov    %rdx,0x20(%rdi)
ffffffff81002e11:	48 c7 47 28 00 00 00 	movq   $0x0,0x28(%rdi)
ffffffff81002e18:	00 
ffffffff81002e19:	66 c7 47 30 00 00    	movw   $0x0,0x30(%rdi)
ffffffff81002e1f:	66 c7 47 32 00 00    	movw   $0x0,0x32(%rdi)
ffffffff81002e25:	48 89 47 78          	mov    %rax,0x78(%rdi)
ffffffff81002e29:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
ffffffff81002e2e:	48 89 7f 38          	mov    %rdi,0x38(%rdi)
ffffffff81002e32:	48 89 7f 40          	mov    %rdi,0x40(%rdi)
ffffffff81002e36:	48 c7 47 48 00 00 00 	movq   $0x0,0x48(%rdi)
ffffffff81002e3d:	00 
ffffffff81002e3e:	48 89 77 50          	mov    %rsi,0x50(%rdi)
ffffffff81002e42:	48 89 4f 58          	mov    %rcx,0x58(%rdi)
ffffffff81002e46:	4c 89 47 60          	mov    %r8,0x60(%rdi)
ffffffff81002e4a:	4c 89 4f 68          	mov    %r9,0x68(%rdi)
ffffffff81002e4e:	48 89 87 80 00 00 00 	mov    %rax,0x80(%rdi)
ffffffff81002e55:	c3                   	retq   

ffffffff81002e56 <_ZN5Space6addregER5Quotammmm>:
        {
            Lock_guard <Spinlock> guard (node->space->lock);
            return Mdb::remove<Mdb> (&node->space->tree, node, state);
        }

        void addreg (Quota &quota, mword addr, size_t size, mword attr, mword type = 0)
ffffffff81002e56:	41 57                	push   %r15
ffffffff81002e58:	41 56                	push   %r14
ffffffff81002e5a:	4d 89 cf             	mov    %r9,%r15
ffffffff81002e5d:	41 55                	push   %r13
ffffffff81002e5f:	41 54                	push   %r12
ffffffff81002e61:	49 89 fd             	mov    %rdi,%r13
ffffffff81002e64:	55                   	push   %rbp
ffffffff81002e65:	53                   	push   %rbx
ffffffff81002e66:	49 89 cc             	mov    %rcx,%r12
ffffffff81002e69:	48 89 d3             	mov    %rdx,%rbx
ffffffff81002e6c:	4d 89 c6             	mov    %r8,%r14
ffffffff81002e6f:	48 83 ec 28          	sub    $0x28,%rsp
ffffffff81002e73:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81002e78:	9c                   	pushfq 
ffffffff81002e79:	58                   	pop    %rax
            return flags & 0x200;
ffffffff81002e7a:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff81002e7e:	24 01                	and    $0x1,%al
ffffffff81002e80:	88 44 24 07          	mov    %al,0x7(%rsp)
ffffffff81002e84:	74 30                	je     ffffffff81002eb6 <_ZN5Space6addregER5Quotammmm+0x60>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81002e86:	80 3d a3 c8 ff 3e 00 	cmpb   $0x0,0x3effc8a3(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81002e8d:	75 1f                	jne    ffffffff81002eae <_ZN5Space6addregER5Quotammmm+0x58>
ffffffff81002e8f:	49 c7 c0 b0 da 01 81 	mov    $0xffffffff8101dab0,%r8
ffffffff81002e96:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff81002e9b:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81002ea2:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff81002ea9:	e9 bb 00 00 00       	jmpq   ffffffff81002f69 <_ZN5Space6addregER5Quotammmm+0x113>

            asm volatile ("cli" : : : "memory");
ffffffff81002eae:	fa                   	cli    
            preemption = false;
ffffffff81002eaf:	c6 05 7a c8 ff 3e 00 	movb   $0x0,0x3effc87a(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff81002eb6:	4c 89 ef             	mov    %r13,%rdi
ffffffff81002eb9:	e8 d0 df ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
        {
            Lock_guard <Spinlock> guard (lock);

            for (mword o; size; size -= 1UL << o, addr += 1UL << o)
                Mdb::insert<Mdb> (&tree, new (quota) Mdb (nullptr, nullptr, addr, addr, (o = max_order (addr, size)), attr, type));
ffffffff81002ebe:	49 8d 45 08          	lea    0x8(%r13),%rax
ffffffff81002ec2:	48 89 44 24 10       	mov    %rax,0x10(%rsp)

        void addreg (Quota &quota, mword addr, size_t size, mword attr, mword type = 0)
        {
            Lock_guard <Spinlock> guard (lock);

            for (mword o; size; size -= 1UL << o, addr += 1UL << o)
ffffffff81002ec7:	4d 85 e4             	test   %r12,%r12
ffffffff81002eca:	74 6f                	je     ffffffff81002f3b <_ZN5Space6addregER5Quotammmm+0xe5>
ffffffff81002ecc:	49 0f bd ec          	bsr    %r12,%rbp
ALWAYS_INLINE
inline unsigned long max_order (mword base, size_t size)
{
    long int o = bit_scan_reverse (size);

    if (base)
ffffffff81002ed0:	48 85 db             	test   %rbx,%rbx
ffffffff81002ed3:	74 0b                	je     ffffffff81002ee0 <_ZN5Space6addregER5Quotammmm+0x8a>
inline long int bit_scan_forward (mword val)
{
    if (EXPECT_FALSE (!val))
        return -1;

    asm volatile ("bsf %1, %0" : "=r" (val) : "rm" (val));
ffffffff81002ed5:	48 0f bc c3          	bsf    %rbx,%rax
ffffffff81002ed9:	48 39 c5             	cmp    %rax,%rbp
ffffffff81002edc:	48 0f 4f e8          	cmovg  %rax,%rbp
        bool insert_node (Mdb *, mword);
        void demote_node (mword);
        bool remove_node();

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
ffffffff81002ee0:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
ffffffff81002ee5:	48 c7 c7 80 38 16 81 	mov    $0xffffffff81163880,%rdi
ffffffff81002eec:	e8 3d 2a 01 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
                Mdb::insert<Mdb> (&tree, new (quota) Mdb (nullptr, nullptr, addr, addr, (o = max_order (addr, size)), attr, type));
ffffffff81002ef1:	52                   	push   %rdx
ffffffff81002ef2:	6a 00                	pushq  $0x0
ffffffff81002ef4:	48 89 d9             	mov    %rbx,%rcx
ffffffff81002ef7:	41 57                	push   %r15
ffffffff81002ef9:	41 56                	push   %r14
ffffffff81002efb:	49 89 d8             	mov    %rbx,%r8
ffffffff81002efe:	48 89 c7             	mov    %rax,%rdi
ffffffff81002f01:	49 89 e9             	mov    %rbp,%r9
ffffffff81002f04:	31 d2                	xor    %edx,%edx
ffffffff81002f06:	31 f6                	xor    %esi,%esi
ffffffff81002f08:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
ffffffff81002f0d:	e8 ca fe ff ff       	callq  ffffffff81002ddc <_ZN3MdbC1EP5SpacePFvP8Rcu_elemEmmmmmm>
ffffffff81002f12:	48 83 c4 20          	add    $0x20,%rsp
ffffffff81002f16:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
ffffffff81002f1b:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
ffffffff81002f20:	48 89 c6             	mov    %rax,%rsi
ffffffff81002f23:	e8 60 e0 ff ff       	callq  ffffffff81000f88 <_ZN3Avl6insertI3MdbEEbPPS_S2_>

        void addreg (Quota &quota, mword addr, size_t size, mword attr, mword type = 0)
        {
            Lock_guard <Spinlock> guard (lock);

            for (mword o; size; size -= 1UL << o, addr += 1UL << o)
ffffffff81002f28:	b8 01 00 00 00       	mov    $0x1,%eax
ffffffff81002f2d:	40 88 e9             	mov    %bpl,%cl
ffffffff81002f30:	48 d3 e0             	shl    %cl,%rax
ffffffff81002f33:	49 29 c4             	sub    %rax,%r12
ffffffff81002f36:	48 01 c3             	add    %rax,%rbx
ffffffff81002f39:	eb 8c                	jmp    ffffffff81002ec7 <_ZN5Space6addregER5Quotammmm+0x71>
        }

        ALWAYS_INLINE
        inline void unlock()
        {
            asm volatile ("incb %0" : "=m" (val) : : "memory");
ffffffff81002f3b:	41 fe 45 00          	incb   0x0(%r13)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81002f3f:	80 7c 24 07 00       	cmpb   $0x0,0x7(%rsp)
ffffffff81002f44:	74 39                	je     ffffffff81002f7f <_ZN5Space6addregER5Quotammmm+0x129>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81002f46:	80 3d e3 c7 ff 3e 00 	cmpb   $0x0,0x3effc7e3(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81002f4d:	74 28                	je     ffffffff81002f77 <_ZN5Space6addregER5Quotammmm+0x121>
ffffffff81002f4f:	49 c7 c0 80 da 01 81 	mov    $0xffffffff8101da80,%r8
ffffffff81002f56:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff81002f5b:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81002f62:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff81002f69:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81002f70:	31 c0                	xor    %eax,%eax
ffffffff81002f72:	e8 d9 ef ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            preemption = true;
ffffffff81002f77:	c6 05 b2 c7 ff 3e 01 	movb   $0x1,0x3effc7b2(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81002f7e:	fb                   	sti    
                Mdb::insert<Mdb> (&tree, new (quota) Mdb (nullptr, nullptr, addr, addr, (o = max_order (addr, size)), attr, type));
        }
ffffffff81002f7f:	48 83 c4 28          	add    $0x28,%rsp
ffffffff81002f83:	5b                   	pop    %rbx
ffffffff81002f84:	5d                   	pop    %rbp
ffffffff81002f85:	41 5c                	pop    %r12
ffffffff81002f87:	41 5d                	pop    %r13
ffffffff81002f89:	41 5e                	pop    %r14
ffffffff81002f8b:	41 5f                	pop    %r15
ffffffff81002f8d:	c3                   	retq   

ffffffff81002f8e <_ZN5Space6delregER5Quotam>:

        void delreg (Quota &quota, mword addr)
ffffffff81002f8e:	41 57                	push   %r15
ffffffff81002f90:	41 56                	push   %r14
ffffffff81002f92:	49 89 fe             	mov    %rdi,%r14
ffffffff81002f95:	41 55                	push   %r13
ffffffff81002f97:	49 89 f5             	mov    %rsi,%r13
ffffffff81002f9a:	41 54                	push   %r12
ffffffff81002f9c:	55                   	push   %rbp
ffffffff81002f9d:	48 89 d5             	mov    %rdx,%rbp
ffffffff81002fa0:	53                   	push   %rbx
ffffffff81002fa1:	41 50                	push   %r8

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81002fa3:	9c                   	pushfq 
ffffffff81002fa4:	41 5c                	pop    %r12
            return flags & 0x200;
ffffffff81002fa6:	49 c1 ec 09          	shr    $0x9,%r12

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff81002faa:	41 80 e4 01          	and    $0x1,%r12b
ffffffff81002fae:	74 30                	je     ffffffff81002fe0 <_ZN5Space6delregER5Quotam+0x52>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81002fb0:	80 3d 79 c7 ff 3e 00 	cmpb   $0x0,0x3effc779(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81002fb7:	75 1f                	jne    ffffffff81002fd8 <_ZN5Space6delregER5Quotam+0x4a>
ffffffff81002fb9:	49 c7 c0 b0 da 01 81 	mov    $0xffffffff8101dab0,%r8
ffffffff81002fc0:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff81002fc5:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81002fcc:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff81002fd3:	e9 83 00 00 00       	jmpq   ffffffff8100305b <_ZN5Space6delregER5Quotam+0xcd>

            asm volatile ("cli" : : : "memory");
ffffffff81002fd8:	fa                   	cli    
            preemption = false;
ffffffff81002fd9:	c6 05 50 c7 ff 3e 00 	movb   $0x0,0x3effc750(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff81002fe0:	4c 89 f7             	mov    %r14,%rdi
        {
            Mdb *node;

            {   Lock_guard <Spinlock> guard (lock);

                if (!(node = Mdb::lookup (tree, addr >>= PAGE_BITS, false)))
ffffffff81002fe3:	48 c1 ed 0c          	shr    $0xc,%rbp
ffffffff81002fe7:	e8 a2 de ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
ffffffff81002fec:	49 8b 5e 08          	mov    0x8(%r14),%rbx
        static Mdb *lookup (Avl *tree, mword base, bool next)
        {
            Mdb *n = nullptr;
            bool d;

            for (Mdb *m = static_cast<Mdb *>(tree); m; m = static_cast<Mdb *>(m->lnk[d])) {
ffffffff81002ff0:	48 85 db             	test   %rbx,%rbx
ffffffff81002ff3:	0f 84 e2 00 00 00    	je     ffffffff810030db <_ZN5Space6delregER5Quotam+0x14d>

                if ((m->node_base ^ base) >> m->node_order == 0)
ffffffff81002ff9:	48 8b 53 60          	mov    0x60(%rbx),%rdx
ffffffff81002ffd:	48 8b 4b 68          	mov    0x68(%rbx),%rcx
ffffffff81003001:	48 89 e8             	mov    %rbp,%rax
ffffffff81003004:	48 31 d0             	xor    %rdx,%rax
ffffffff81003007:	48 d3 e8             	shr    %cl,%rax
ffffffff8100300a:	48 85 c0             	test   %rax,%rax
ffffffff8100300d:	75 1b                	jne    ffffffff8100302a <_ZN5Space6delregER5Quotam+0x9c>
                    return;

                Mdb::remove<Mdb> (&tree, node);
ffffffff8100300f:	49 8d 7e 08          	lea    0x8(%r14),%rdi
ffffffff81003013:	ba 01 00 00 00       	mov    $0x1,%edx
ffffffff81003018:	48 89 de             	mov    %rbx,%rsi
ffffffff8100301b:	e8 82 e0 ff ff       	callq  ffffffff810010a2 <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE>
ffffffff81003020:	41 fe 06             	incb   (%r14)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81003023:	45 84 e4             	test   %r12b,%r12b
ffffffff81003026:	75 10                	jne    ffffffff81003038 <_ZN5Space6delregER5Quotam+0xaa>
ffffffff81003028:	eb 47                	jmp    ffffffff81003071 <_ZN5Space6delregER5Quotam+0xe3>
        static Mdb *lookup (Avl *tree, mword base, bool next)
        {
            Mdb *n = nullptr;
            bool d;

            for (Mdb *m = static_cast<Mdb *>(tree); m; m = static_cast<Mdb *>(m->lnk[d])) {
ffffffff8100302a:	31 c0                	xor    %eax,%eax
ffffffff8100302c:	48 39 d5             	cmp    %rdx,%rbp
ffffffff8100302f:	0f 97 c0             	seta   %al
ffffffff81003032:	48 8b 1c c3          	mov    (%rbx,%rax,8),%rbx
ffffffff81003036:	eb b8                	jmp    ffffffff81002ff0 <_ZN5Space6delregER5Quotam+0x62>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81003038:	80 3d f1 c6 ff 3e 00 	cmpb   $0x0,0x3effc6f1(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100303f:	74 28                	je     ffffffff81003069 <_ZN5Space6delregER5Quotam+0xdb>
ffffffff81003041:	49 c7 c0 80 da 01 81 	mov    $0xffffffff8101da80,%r8
ffffffff81003048:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff8100304d:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81003054:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff8100305b:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81003062:	31 c0                	xor    %eax,%eax
ffffffff81003064:	e8 e7 ee ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            preemption = true;
ffffffff81003069:	c6 05 c0 c6 ff 3e 01 	movb   $0x1,0x3effc6c0(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81003070:	fb                   	sti    
            }

            mword next = addr + 1, base = node->node_base, last = base + (1UL << node->node_order);
ffffffff81003071:	48 8b 4b 68          	mov    0x68(%rbx),%rcx
ffffffff81003075:	48 8b 53 60          	mov    0x60(%rbx),%rdx
ffffffff81003079:	41 bc 01 00 00 00    	mov    $0x1,%r12d

            addreg (quota, base, addr - base, node->node_attr, node->node_type);
ffffffff8100307f:	4c 8b 4b 78          	mov    0x78(%rbx),%r9
ffffffff81003083:	4c 8b 43 70          	mov    0x70(%rbx),%r8
ffffffff81003087:	4c 89 ee             	mov    %r13,%rsi
ffffffff8100308a:	4c 89 f7             	mov    %r14,%rdi
                    return;

                Mdb::remove<Mdb> (&tree, node);
            }

            mword next = addr + 1, base = node->node_base, last = base + (1UL << node->node_order);
ffffffff8100308d:	4c 8d 7d 01          	lea    0x1(%rbp),%r15
ffffffff81003091:	49 d3 e4             	shl    %cl,%r12

            addreg (quota, base, addr - base, node->node_attr, node->node_type);
ffffffff81003094:	48 89 e9             	mov    %rbp,%rcx
ffffffff81003097:	48 29 d1             	sub    %rdx,%rcx
                    return;

                Mdb::remove<Mdb> (&tree, node);
            }

            mword next = addr + 1, base = node->node_base, last = base + (1UL << node->node_order);
ffffffff8100309a:	49 01 d4             	add    %rdx,%r12

            addreg (quota, base, addr - base, node->node_attr, node->node_type);
ffffffff8100309d:	e8 b4 fd ff ff       	callq  ffffffff81002e56 <_ZN5Space6addregER5Quotammmm>
            addreg (quota, next, last - next, node->node_attr, node->node_type);
ffffffff810030a2:	4c 8b 4b 78          	mov    0x78(%rbx),%r9
ffffffff810030a6:	4c 8b 43 70          	mov    0x70(%rbx),%r8
ffffffff810030aa:	4c 89 e1             	mov    %r12,%rcx
ffffffff810030ad:	4c 29 f9             	sub    %r15,%rcx
ffffffff810030b0:	4c 89 fa             	mov    %r15,%rdx
ffffffff810030b3:	4c 89 ee             	mov    %r13,%rsi
ffffffff810030b6:	4c 89 f7             	mov    %r14,%rdi
ffffffff810030b9:	e8 98 fd ff ff       	callq  ffffffff81002e56 <_ZN5Space6addregER5Quotammmm>

            Mdb::destroy (node, quota);
        }
ffffffff810030be:	59                   	pop    %rcx

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void destroy (Mdb *obj, Quota &quota) { obj->~Mdb(); cache.free (obj, quota); }
ffffffff810030bf:	4c 89 ea             	mov    %r13,%rdx
ffffffff810030c2:	48 89 de             	mov    %rbx,%rsi
ffffffff810030c5:	48 c7 c7 80 38 16 81 	mov    $0xffffffff81163880,%rdi
ffffffff810030cc:	5b                   	pop    %rbx
ffffffff810030cd:	5d                   	pop    %rbp
ffffffff810030ce:	41 5c                	pop    %r12
ffffffff810030d0:	41 5d                	pop    %r13
ffffffff810030d2:	41 5e                	pop    %r14
ffffffff810030d4:	41 5f                	pop    %r15
ffffffff810030d6:	e9 8f 29 01 00       	jmpq   ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
ffffffff810030db:	41 fe 06             	incb   (%r14)
ffffffff810030de:	45 84 e4             	test   %r12b,%r12b
ffffffff810030e1:	74 15                	je     ffffffff810030f8 <_ZN5Space6delregER5Quotam+0x16a>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff810030e3:	80 3d 46 c6 ff 3e 00 	cmpb   $0x0,0x3effc646(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff810030ea:	0f 85 51 ff ff ff    	jne    ffffffff81003041 <_ZN5Space6delregER5Quotam+0xb3>

            preemption = true;
ffffffff810030f0:	c6 05 39 c6 ff 3e 01 	movb   $0x1,0x3effc639(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff810030f7:	fb                   	sti    
ffffffff810030f8:	58                   	pop    %rax
ffffffff810030f9:	5b                   	pop    %rbx
ffffffff810030fa:	5d                   	pop    %rbp
ffffffff810030fb:	41 5c                	pop    %r12
ffffffff810030fd:	41 5d                	pop    %r13
ffffffff810030ff:	41 5e                	pop    %r14
ffffffff81003101:	41 5f                	pop    %r15
ffffffff81003103:	c3                   	retq   

ffffffff81003104 <_ZN4Dmar6assignEmP2Pd>:

void Dmar::assign (unsigned long rid, Pd *p)
{
ffffffff81003104:	41 56                	push   %r14
ffffffff81003106:	41 55                	push   %r13
ffffffff81003108:	49 89 f6             	mov    %rsi,%r14
ffffffff8100310b:	41 54                	push   %r12
ffffffff8100310d:	55                   	push   %rbp

ALWAYS_INLINE
inline long int bit_scan_reverse (mword val)
{
    if (EXPECT_FALSE (!val))
        return -1;
ffffffff8100310e:	48 83 cd ff          	or     $0xffffffffffffffff,%rbp
ffffffff81003112:	53                   	push   %rbx

        template <typename T>
        ALWAYS_INLINE
        inline T read (Reg reg)
        {
            return *reinterpret_cast<T volatile *>(reg_base + reg);
ffffffff81003113:	48 8b 47 08          	mov    0x8(%rdi),%rax
ffffffff81003117:	48 89 fb             	mov    %rdi,%rbx
ffffffff8100311a:	49 89 d5             	mov    %rdx,%r13
ffffffff8100311d:	48 8b 40 08          	mov    0x8(%rax),%rax
    mword lev = bit_scan_reverse (read<mword>(REG_CAP) >> 8 & 0x1f);
ffffffff81003121:	48 c1 e8 08          	shr    $0x8,%rax
#include "util.hpp"

ALWAYS_INLINE
inline long int bit_scan_reverse (mword val)
{
    if (EXPECT_FALSE (!val))
ffffffff81003125:	83 e0 1f             	and    $0x1f,%eax
ffffffff81003128:	74 04                	je     ffffffff8100312e <_ZN4Dmar6assignEmP2Pd+0x2a>
        return -1;

    asm volatile ("bsr %1, %0" : "=r" (val) : "rm" (val));

    return val;
ffffffff8100312a:	48 0f bd e8          	bsr    %rax,%rbp

    Dmar_ctx *r = ctx + (rid >> 8);
ffffffff8100312e:	4d 89 f4             	mov    %r14,%r12
ffffffff81003131:	49 c1 ec 08          	shr    $0x8,%r12
ffffffff81003135:	49 c1 e4 04          	shl    $0x4,%r12
ffffffff81003139:	4c 03 25 18 ef 15 00 	add    0x15ef18(%rip),%r12        # ffffffff81162058 <_ZN4Dmar3ctxE>
    if (!r->present())
ffffffff81003140:	41 f6 04 24 01       	testb  $0x1,(%r12)
ffffffff81003145:	75 4e                	jne    ffffffff81003195 <_ZN4Dmar6assignEmP2Pd+0x91>
        r->set (0, Buddy::ptr_to_phys (new (p->quota) Dmar_ctx) | 1);
ffffffff81003147:	49 8d 95 08 03 00 00 	lea    0x308(%r13),%rdx

        ALWAYS_INLINE
        inline void set (uint64 h, uint64 l) { hi = h; lo = l; flush (this); }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return flush (Buddy::allocator.alloc (0, quota, Buddy::FILL_0), PAGE_SIZE); }
ffffffff8100314e:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff81003153:	31 f6                	xor    %esi,%esi
ffffffff81003155:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff8100315c:	e8 91 e7 ff ff       	callq  ffffffff810018f2 <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
ffffffff81003161:	48 8d 88 00 10 00 00 	lea    0x1000(%rax),%rcx
}

ALWAYS_INLINE NONNULL
inline void *flush (void *d, size_t n)
{
    for (char *p = static_cast<char *>(d); p < static_cast<char *>(d) + n; p += 32)
ffffffff81003168:	48 89 c2             	mov    %rax,%rdx
ffffffff8100316b:	48 39 ca             	cmp    %rcx,%rdx
ffffffff8100316e:	74 09                	je     ffffffff81003179 <_ZN4Dmar6assignEmP2Pd+0x75>

template <typename T>
ALWAYS_INLINE
static inline void flush (T t)
{
    asm volatile ("clflush %0" : : "m" (*t) : "memory");
ffffffff81003170:	0f ae 3a             	clflush (%rdx)
}

ALWAYS_INLINE NONNULL
inline void *flush (void *d, size_t n)
{
    for (char *p = static_cast<char *>(d); p < static_cast<char *>(d) + n; p += 32)
ffffffff81003173:	48 83 c2 20          	add    $0x20,%rdx
ffffffff81003177:	eb f2                	jmp    ffffffff8100316b <_ZN4Dmar6assignEmP2Pd+0x67>
ffffffff81003179:	48 2d 00 00 c0 80    	sub    $0xffffffff80c00000,%rax

        ALWAYS_INLINE
        inline Paddr addr() const { return static_cast<Paddr>(lo) & ~PAGE_MASK; }

        ALWAYS_INLINE
        inline void set (uint64 h, uint64 l) { hi = h; lo = l; flush (this); }
ffffffff8100317f:	49 c7 44 24 08 00 00 	movq   $0x0,0x8(%r12)
ffffffff81003186:	00 00 
ffffffff81003188:	48 83 c8 01          	or     $0x1,%rax
ffffffff8100318c:	49 89 04 24          	mov    %rax,(%r12)

template <typename T>
ALWAYS_INLINE
static inline void flush (T t)
{
    asm volatile ("clflush %0" : : "m" (*t) : "memory");
ffffffff81003190:	41 0f ae 3c 24       	clflush (%r12)
    public:
        ALWAYS_INLINE
        inline bool present() const { return lo & 1; }

        ALWAYS_INLINE
        inline Paddr addr() const { return static_cast<Paddr>(lo) & ~PAGE_MASK; }
ffffffff81003195:	49 8b 04 24          	mov    (%r12),%rax

    Dmar_ctx *c = static_cast<Dmar_ctx *>(Buddy::phys_to_ptr (r->addr())) + (rid & 0xff);
ffffffff81003199:	45 0f b6 f6          	movzbl %r14b,%r14d
ffffffff8100319d:	49 c1 e6 04          	shl    $0x4,%r14
ffffffff810031a1:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff810031a7:	4e 8d a4 30 00 00 c0 	lea    -0x7f400000(%rax,%r14,1),%r12
ffffffff810031ae:	80 
    if (c->present())
ffffffff810031af:	41 f6 04 24 01       	testb  $0x1,(%r12)
ffffffff810031b4:	74 16                	je     ffffffff810031cc <_ZN4Dmar6assignEmP2Pd+0xc8>

        ALWAYS_INLINE
        inline void set (uint64 h, uint64 l) { hi = h; lo = l; flush (this); }
ffffffff810031b6:	49 c7 44 24 08 00 00 	movq   $0x0,0x8(%r12)
ffffffff810031bd:	00 00 
ffffffff810031bf:	49 c7 04 24 00 00 00 	movq   $0x0,(%r12)
ffffffff810031c6:	00 
ffffffff810031c7:	41 0f ae 3c 24       	clflush (%r12)
        }

        ALWAYS_INLINE
        inline void flush_ctx()
        {
            if (qi()) {
ffffffff810031cc:	f6 43 18 02          	testb  $0x2,0x18(%rbx)
ffffffff810031d0:	0f 84 d3 00 00 00    	je     ffffffff810032a9 <_ZN4Dmar6assignEmP2Pd+0x1a5>
        }

        ALWAYS_INLINE
        inline void qi_submit (Dmar_qi const &q)
        {
            invq[invq_idx] = q;
ffffffff810031d6:	8b 43 28             	mov    0x28(%rbx),%eax
ffffffff810031d9:	48 c1 e0 04          	shl    $0x4,%rax
ffffffff810031dd:	48 03 43 20          	add    0x20(%rbx),%rax
ffffffff810031e1:	48 c7 00 11 00 00 00 	movq   $0x11,(%rax)
ffffffff810031e8:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
ffffffff810031ef:	00 
            invq_idx = (invq_idx + 1) % cnt;
ffffffff810031f0:	8b 43 28             	mov    0x28(%rbx),%eax

        template <typename T>
        ALWAYS_INLINE
        inline void write (Reg reg, T val)
        {
            *reinterpret_cast<T volatile *>(reg_base + reg) = val;
ffffffff810031f3:	48 8b 53 08          	mov    0x8(%rbx),%rdx

        ALWAYS_INLINE
        inline void qi_submit (Dmar_qi const &q)
        {
            invq[invq_idx] = q;
            invq_idx = (invq_idx + 1) % cnt;
ffffffff810031f7:	ff c0                	inc    %eax
ffffffff810031f9:	0f b6 c0             	movzbl %al,%eax
ffffffff810031fc:	89 43 28             	mov    %eax,0x28(%rbx)
            write<uint64>(REG_IQT, invq_idx << 4);
ffffffff810031ff:	c1 e0 04             	shl    $0x4,%eax

        template <typename T>
        ALWAYS_INLINE
        inline void write (Reg reg, T val)
        {
            *reinterpret_cast<T volatile *>(reg_base + reg) = val;
ffffffff81003202:	48 89 82 88 00 00 00 	mov    %rax,0x88(%rdx)
        }

        ALWAYS_INLINE
        inline void qi_submit (Dmar_qi const &q)
        {
            invq[invq_idx] = q;
ffffffff81003209:	8b 43 28             	mov    0x28(%rbx),%eax
ffffffff8100320c:	48 c1 e0 04          	shl    $0x4,%rax
ffffffff81003210:	48 03 43 20          	add    0x20(%rbx),%rax
ffffffff81003214:	48 c7 00 12 00 00 00 	movq   $0x12,(%rax)
ffffffff8100321b:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
ffffffff81003222:	00 
            invq_idx = (invq_idx + 1) % cnt;
ffffffff81003223:	8b 43 28             	mov    0x28(%rbx),%eax

        template <typename T>
        ALWAYS_INLINE
        inline void write (Reg reg, T val)
        {
            *reinterpret_cast<T volatile *>(reg_base + reg) = val;
ffffffff81003226:	48 8b 53 08          	mov    0x8(%rbx),%rdx

        ALWAYS_INLINE
        inline void qi_submit (Dmar_qi const &q)
        {
            invq[invq_idx] = q;
            invq_idx = (invq_idx + 1) % cnt;
ffffffff8100322a:	ff c0                	inc    %eax
ffffffff8100322c:	0f b6 c0             	movzbl %al,%eax
ffffffff8100322f:	89 43 28             	mov    %eax,0x28(%rbx)
            write<uint64>(REG_IQT, invq_idx << 4);
ffffffff81003232:	c1 e0 04             	shl    $0x4,%eax

        template <typename T>
        ALWAYS_INLINE
        inline void write (Reg reg, T val)
        {
            *reinterpret_cast<T volatile *>(reg_base + reg) = val;
ffffffff81003235:	48 89 82 88 00 00 00 	mov    %rax,0x88(%rdx)

        template <typename T>
        ALWAYS_INLINE
        inline T read (Reg reg)
        {
            return *reinterpret_cast<T volatile *>(reg_base + reg);
ffffffff8100323c:	48 8b 43 08          	mov    0x8(%rbx),%rax
ffffffff81003240:	48 8b 90 88 00 00 00 	mov    0x88(%rax),%rdx
ffffffff81003247:	48 8b 43 08          	mov    0x8(%rbx),%rax
ffffffff8100324b:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
        };

        ALWAYS_INLINE
        inline void qi_wait()
        {
            for (uint64 v = read<uint64>(REG_IQT); v != read<uint64>(REG_IQH); pause()) ;
ffffffff81003252:	48 39 c2             	cmp    %rax,%rdx
ffffffff81003255:	74 04                	je     ffffffff8100325b <_ZN4Dmar6assignEmP2Pd+0x157>
}

ALWAYS_INLINE
static inline void pause()
{
    asm volatile ("pause" : : : "memory");
ffffffff81003257:	f3 90                	pause  
ffffffff81003259:	eb ec                	jmp    ffffffff81003247 <_ZN4Dmar6assignEmP2Pd+0x143>
        c->set (0, 0);

    flush_ctx();

    c->set (lev | p->did << 8, p->dpt.root (p->quota, lev + 1) | 1);
ffffffff8100325b:	48 8d 4d 01          	lea    0x1(%rbp),%rcx
ffffffff8100325f:	49 8d b5 08 03 00 00 	lea    0x308(%r13),%rsi
ffffffff81003266:	49 8d bd a8 02 00 00 	lea    0x2a8(%r13),%rdi
        return L;
    }

    ALWAYS_INLINE
    inline E root(Quota &quota, mword l = L - 1) {
        return Buddy::ptr_to_phys(walk(quota, 0, l));
ffffffff8100326d:	31 d2                	xor    %edx,%edx
ffffffff8100326f:	41 b8 01 00 00 00    	mov    $0x1,%r8d
ffffffff81003275:	e8 38 f0 00 00       	callq  ffffffff810122b2 <_ZN3PteI3DptyLj4ELj9ELb1EE4walkER5Quotaymb>
ffffffff8100327a:	49 8b 95 b8 02 00 00 	mov    0x2b8(%r13),%rdx
ffffffff81003281:	48 2d 00 00 c0 80    	sub    $0xffffffff80c00000,%rax
ffffffff81003287:	48 83 c8 01          	or     $0x1,%rax
ffffffff8100328b:	49 89 04 24          	mov    %rax,(%r12)
ffffffff8100328f:	48 c1 e2 08          	shl    $0x8,%rdx
ffffffff81003293:	48 09 d5             	or     %rdx,%rbp
ffffffff81003296:	49 89 6c 24 08       	mov    %rbp,0x8(%r12)

template <typename T>
ALWAYS_INLINE
static inline void flush (T t)
{
    asm volatile ("clflush %0" : : "m" (*t) : "memory");
ffffffff8100329b:	41 0f ae 3c 24       	clflush (%r12)
}
ffffffff810032a0:	5b                   	pop    %rbx
ffffffff810032a1:	5d                   	pop    %rbp
ffffffff810032a2:	41 5c                	pop    %r12
ffffffff810032a4:	41 5d                	pop    %r13
ffffffff810032a6:	41 5e                	pop    %r14
ffffffff810032a8:	c3                   	retq   

        template <typename T>
        ALWAYS_INLINE
        inline void write (Reg reg, T val)
        {
            *reinterpret_cast<T volatile *>(reg_base + reg) = val;
ffffffff810032a9:	48 8b 43 08          	mov    0x8(%rbx),%rax
ffffffff810032ad:	48 be 00 00 00 00 00 	movabs $0xa000000000000000,%rsi
ffffffff810032b4:	00 00 a0 
ffffffff810032b7:	48 89 70 28          	mov    %rsi,0x28(%rax)
ffffffff810032bb:	48 8b 53 08          	mov    0x8(%rbx),%rdx

        template <typename T>
        ALWAYS_INLINE
        inline T read (Reg reg)
        {
            return *reinterpret_cast<T volatile *>(reg_base + reg);
ffffffff810032bf:	48 8b 42 28          	mov    0x28(%rdx),%rax
                qi_submit (Dmar_qi_ctx());
                qi_submit (Dmar_qi_tlb());
                qi_wait();
            } else {
                write<uint64>(REG_CCMD, 1ULL << 63 | 1ULL << 61);
                while (read<uint64>(REG_CCMD) & (1ULL << 63))
ffffffff810032c3:	48 85 c0             	test   %rax,%rax
ffffffff810032c6:	79 04                	jns    ffffffff810032cc <_ZN4Dmar6assignEmP2Pd+0x1c8>
}

ALWAYS_INLINE
static inline void pause()
{
    asm volatile ("pause" : : : "memory");
ffffffff810032c8:	f3 90                	pause  
ffffffff810032ca:	eb ef                	jmp    ffffffff810032bb <_ZN4Dmar6assignEmP2Pd+0x1b7>

        ALWAYS_INLINE
        inline mword fro() const { return static_cast<mword>(cap >> 20 & 0x3ff0) + reg_base; }

        ALWAYS_INLINE
        inline mword iro() const { return static_cast<mword>(ecap >> 4 & 0x3ff0) + reg_base; }
ffffffff810032cc:	48 8b 43 18          	mov    0x18(%rbx),%rax

        template <typename T>
        ALWAYS_INLINE
        inline void write (Tlb tlb, T val)
        {
            *reinterpret_cast<T volatile *>(iro() + tlb) = val;
ffffffff810032d0:	48 bf 00 00 00 00 00 	movabs $0x9000000000000000,%rdi
ffffffff810032d7:	00 00 90 

        ALWAYS_INLINE
        inline mword fro() const { return static_cast<mword>(cap >> 20 & 0x3ff0) + reg_base; }

        ALWAYS_INLINE
        inline mword iro() const { return static_cast<mword>(ecap >> 4 & 0x3ff0) + reg_base; }
ffffffff810032da:	48 c1 e8 04          	shr    $0x4,%rax
ffffffff810032de:	25 f0 3f 00 00       	and    $0x3ff0,%eax

        template <typename T>
        ALWAYS_INLINE
        inline void write (Tlb tlb, T val)
        {
            *reinterpret_cast<T volatile *>(iro() + tlb) = val;
ffffffff810032e3:	48 8d 44 02 08       	lea    0x8(%rdx,%rax,1),%rax
ffffffff810032e8:	48 89 38             	mov    %rdi,(%rax)

        ALWAYS_INLINE
        inline mword fro() const { return static_cast<mword>(cap >> 20 & 0x3ff0) + reg_base; }

        ALWAYS_INLINE
        inline mword iro() const { return static_cast<mword>(ecap >> 4 & 0x3ff0) + reg_base; }
ffffffff810032eb:	48 8b 43 18          	mov    0x18(%rbx),%rax
ffffffff810032ef:	48 8b 53 08          	mov    0x8(%rbx),%rdx
ffffffff810032f3:	48 c1 e8 04          	shr    $0x4,%rax
ffffffff810032f7:	25 f0 3f 00 00       	and    $0x3ff0,%eax

        template <typename T>
        ALWAYS_INLINE
        inline T read (Tlb tlb)
        {
            return *reinterpret_cast<T volatile *>(iro() + tlb);
ffffffff810032fc:	48 8d 44 02 08       	lea    0x8(%rdx,%rax,1),%rax
ffffffff81003301:	48 8b 00             	mov    (%rax),%rax
            } else {
                write<uint64>(REG_CCMD, 1ULL << 63 | 1ULL << 61);
                while (read<uint64>(REG_CCMD) & (1ULL << 63))
                    pause();
                write<uint64>(REG_IOTLB, 1ULL << 63 | 1ULL << 60);
                while (read<uint64>(REG_IOTLB) & (1ULL << 63))
ffffffff81003304:	48 85 c0             	test   %rax,%rax
ffffffff81003307:	0f 89 4e ff ff ff    	jns    ffffffff8100325b <_ZN4Dmar6assignEmP2Pd+0x157>
ffffffff8100330d:	f3 90                	pause  
ffffffff8100330f:	eb da                	jmp    ffffffff810032eb <_ZN4Dmar6assignEmP2Pd+0x1e7>
ffffffff81003311:	90                   	nop

ffffffff81003312 <_ZN4Dmar13fault_handlerEv>:

void Dmar::fault_handler()
{
ffffffff81003312:	41 55                	push   %r13
ffffffff81003314:	41 54                	push   %r12
ffffffff81003316:	49 89 fd             	mov    %rdi,%r13
ffffffff81003319:	55                   	push   %rbp
ffffffff8100331a:	53                   	push   %rbx
    for (uint32 fsts; fsts = read<uint32>(REG_FSTS), fsts & 0xff;) {

        if (fsts & 0x2) {
            uint64 hi, lo;
            for (unsigned frr = fsts >> 8 & 0xff; read (frr, hi, lo), hi & 1ull << 63; frr = (frr + 1) % nfr())
                trace (TRACE_IOMMU, "DMAR:%p FRR:%u FR:%#x BDF:%x:%x:%x FI:%#010llx",
ffffffff8100331b:	49 83 cc ff          	or     $0xffffffffffffffff,%r12

    c->set (lev | p->did << 8, p->dpt.root (p->quota, lev + 1) | 1);
}

void Dmar::fault_handler()
{
ffffffff8100331f:	48 83 ec 18          	sub    $0x18,%rsp
    for (uint32 fsts; fsts = read<uint32>(REG_FSTS), fsts & 0xff;) {

        if (fsts & 0x2) {
            uint64 hi, lo;
            for (unsigned frr = fsts >> 8 & 0xff; read (frr, hi, lo), hi & 1ull << 63; frr = (frr + 1) % nfr())
                trace (TRACE_IOMMU, "DMAR:%p FRR:%u FR:%#x BDF:%x:%x:%x FI:%#010llx",
ffffffff81003323:	48 8d 6c 24 07       	lea    0x7(%rsp),%rbp
ffffffff81003328:	48 81 e5 00 f0 ff ff 	and    $0xfffffffffffff000,%rbp

        template <typename T>
        ALWAYS_INLINE
        inline T read (Reg reg)
        {
            return *reinterpret_cast<T volatile *>(reg_base + reg);
ffffffff8100332f:	49 8b 45 08          	mov    0x8(%r13),%rax
ffffffff81003333:	8b 58 34             	mov    0x34(%rax),%ebx
    c->set (lev | p->did << 8, p->dpt.root (p->quota, lev + 1) | 1);
}

void Dmar::fault_handler()
{
    for (uint32 fsts; fsts = read<uint32>(REG_FSTS), fsts & 0xff;) {
ffffffff81003336:	84 db                	test   %bl,%bl
ffffffff81003338:	0f 84 ab 00 00 00    	je     ffffffff810033e9 <_ZN4Dmar13fault_handlerEv+0xd7>

        if (fsts & 0x2) {
ffffffff8100333e:	f6 c3 02             	test   $0x2,%bl
ffffffff81003341:	75 0d                	jne    ffffffff81003350 <_ZN4Dmar13fault_handlerEv+0x3e>
ffffffff81003343:	49 8b 45 08          	mov    0x8(%r13),%rax

        template <typename T>
        ALWAYS_INLINE
        inline void write (Reg reg, T val)
        {
            *reinterpret_cast<T volatile *>(reg_base + reg) = val;
ffffffff81003347:	c7 40 34 7d 00 00 00 	movl   $0x7d,0x34(%rax)
ffffffff8100334e:	eb df                	jmp    ffffffff8100332f <_ZN4Dmar13fault_handlerEv+0x1d>
            uint64 hi, lo;
            for (unsigned frr = fsts >> 8 & 0xff; read (frr, hi, lo), hi & 1ull << 63; frr = (frr + 1) % nfr())
ffffffff81003350:	0f b6 df             	movzbl %bh,%ebx

        ALWAYS_INLINE
        inline unsigned nfr() const { return static_cast<unsigned>(cap >> 40 & 0xff) + 1; }

        ALWAYS_INLINE
        inline mword fro() const { return static_cast<mword>(cap >> 20 & 0x3ff0) + reg_base; }
ffffffff81003353:	49 8b 4d 10          	mov    0x10(%r13),%rcx
        }

        ALWAYS_INLINE
        inline void read (unsigned frr, uint64 &hi, uint64 &lo)
        {
            lo = *reinterpret_cast<uint64 volatile *>(fro() + frr * 16);
ffffffff81003357:	89 d8                	mov    %ebx,%eax
            hi = *reinterpret_cast<uint64 volatile *>(fro() + frr * 16 + 8);
            *reinterpret_cast<uint64 volatile *>(fro() + frr * 16 + 8) = 1ULL << 63;
ffffffff81003359:	48 be 00 00 00 00 00 	movabs $0x8000000000000000,%rsi
ffffffff81003360:	00 00 80 
        }

        ALWAYS_INLINE
        inline void read (unsigned frr, uint64 &hi, uint64 &lo)
        {
            lo = *reinterpret_cast<uint64 volatile *>(fro() + frr * 16);
ffffffff81003363:	c1 e0 04             	shl    $0x4,%eax

        ALWAYS_INLINE
        inline unsigned nfr() const { return static_cast<unsigned>(cap >> 40 & 0xff) + 1; }

        ALWAYS_INLINE
        inline mword fro() const { return static_cast<mword>(cap >> 20 & 0x3ff0) + reg_base; }
ffffffff81003366:	48 c1 e9 14          	shr    $0x14,%rcx
ffffffff8100336a:	81 e1 f0 3f 00 00    	and    $0x3ff0,%ecx
ffffffff81003370:	49 03 4d 08          	add    0x8(%r13),%rcx
        }

        ALWAYS_INLINE
        inline void read (unsigned frr, uint64 &hi, uint64 &lo)
        {
            lo = *reinterpret_cast<uint64 volatile *>(fro() + frr * 16);
ffffffff81003374:	48 01 c1             	add    %rax,%rcx
ffffffff81003377:	48 8b 39             	mov    (%rcx),%rdi
            hi = *reinterpret_cast<uint64 volatile *>(fro() + frr * 16 + 8);
ffffffff8100337a:	48 8b 41 08          	mov    0x8(%rcx),%rax
            *reinterpret_cast<uint64 volatile *>(fro() + frr * 16 + 8) = 1ULL << 63;
ffffffff8100337e:	48 89 71 08          	mov    %rsi,0x8(%rcx)
ffffffff81003382:	48 85 c0             	test   %rax,%rax
ffffffff81003385:	79 bc                	jns    ffffffff81003343 <_ZN4Dmar13fault_handlerEv+0x31>
                trace (TRACE_IOMMU, "DMAR:%p FRR:%u FR:%#x BDF:%x:%x:%x FI:%#010llx",
ffffffff81003387:	0f b6 f4             	movzbl %ah,%esi
ffffffff8100338a:	48 89 c2             	mov    %rax,%rdx
ffffffff8100338d:	89 c1                	mov    %eax,%ecx
ffffffff8100338f:	49 89 f1             	mov    %rsi,%r9
ffffffff81003392:	8b 35 6c bc ff 3e    	mov    0x3effbc6c(%rip),%esi        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81003398:	48 c1 ea 03          	shr    $0x3,%rdx
ffffffff8100339c:	48 c1 e8 20          	shr    $0x20,%rax
ffffffff810033a0:	83 e1 07             	and    $0x7,%ecx
ffffffff810033a3:	83 e2 1f             	and    $0x1f,%edx
ffffffff810033a6:	49 89 c0             	mov    %rax,%r8
ffffffff810033a9:	48 81 fd 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rbp
ffffffff810033b0:	50                   	push   %rax
ffffffff810033b1:	57                   	push   %rdi
ffffffff810033b2:	51                   	push   %rcx
ffffffff810033b3:	48 c7 c7 48 da 01 81 	mov    $0xffffffff8101da48,%rdi
ffffffff810033ba:	52                   	push   %rdx
ffffffff810033bb:	49 0f 45 f4          	cmovne %r12,%rsi
ffffffff810033bf:	89 d9                	mov    %ebx,%ecx
ffffffff810033c1:	4c 89 ea             	mov    %r13,%rdx
ffffffff810033c4:	31 c0                	xor    %eax,%eax
ffffffff810033c6:	45 0f b6 c0          	movzbl %r8b,%r8d
ffffffff810033ca:	e8 bd ec ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
            GCMD_SRTP   = 1UL << 30,
            GCMD_TE     = 1UL << 31,
        };

        ALWAYS_INLINE
        inline unsigned nfr() const { return static_cast<unsigned>(cap >> 40 & 0xff) + 1; }
ffffffff810033cf:	41 0f b6 55 15       	movzbl 0x15(%r13),%edx
{
    for (uint32 fsts; fsts = read<uint32>(REG_FSTS), fsts & 0xff;) {

        if (fsts & 0x2) {
            uint64 hi, lo;
            for (unsigned frr = fsts >> 8 & 0xff; read (frr, hi, lo), hi & 1ull << 63; frr = (frr + 1) % nfr())
ffffffff810033d4:	8d 43 01             	lea    0x1(%rbx),%eax
ffffffff810033d7:	48 83 c4 20          	add    $0x20,%rsp
ffffffff810033db:	8d 7a 01             	lea    0x1(%rdx),%edi
ffffffff810033de:	31 d2                	xor    %edx,%edx
ffffffff810033e0:	f7 f7                	div    %edi
ffffffff810033e2:	89 d3                	mov    %edx,%ebx
ffffffff810033e4:	e9 6a ff ff ff       	jmpq   ffffffff81003353 <_ZN4Dmar13fault_handlerEv+0x41>
                       lo);
        }

        write<uint32>(REG_FSTS, 0x7d);
    }
}
ffffffff810033e9:	48 83 c4 18          	add    $0x18,%rsp
ffffffff810033ed:	5b                   	pop    %rbx
ffffffff810033ee:	5d                   	pop    %rbp
ffffffff810033ef:	41 5c                	pop    %r12
ffffffff810033f1:	41 5d                	pop    %r13
ffffffff810033f3:	c3                   	retq   

ffffffff810033f4 <msi_vector>:

void Dmar::vector (unsigned vector)
{
    unsigned msi = vector - VEC_MSI;

    if (EXPECT_TRUE (msi == 0))
ffffffff810033f4:	81 ff a6 00 00 00    	cmp    $0xa6,%edi
        write<uint32>(REG_FSTS, 0x7d);
    }
}

void Dmar::vector (unsigned vector)
{
ffffffff810033fa:	53                   	push   %rbx
    unsigned msi = vector - VEC_MSI;

    if (EXPECT_TRUE (msi == 0))
        for (Dmar *dmar = list; dmar; dmar = dmar->next)
ffffffff810033fb:	48 8b 1d 5e ec 15 00 	mov    0x15ec5e(%rip),%rbx        # ffffffff81162060 <_ZN4Dmar4listE>

void Dmar::vector (unsigned vector)
{
    unsigned msi = vector - VEC_MSI;

    if (EXPECT_TRUE (msi == 0))
ffffffff81003402:	74 0d                	je     ffffffff81003411 <msi_vector+0x1d>
        }

        ALWAYS_INLINE
        static inline void write (Register reg, uint32 val)
        {
            *reinterpret_cast<uint32 volatile *>(CPU_LOCAL_APIC + (reg << 4)) = val;
ffffffff81003404:	c7 04 25 b0 e0 ff bf 	movl   $0x0,0xffffffffbfffe0b0
ffffffff8100340b:	00 00 00 00 
        for (Dmar *dmar = list; dmar; dmar = dmar->next)
            dmar->fault_handler();

    Lapic::eoi();
}
ffffffff8100340f:	5b                   	pop    %rbx
ffffffff81003410:	c3                   	retq   
void Dmar::vector (unsigned vector)
{
    unsigned msi = vector - VEC_MSI;

    if (EXPECT_TRUE (msi == 0))
        for (Dmar *dmar = list; dmar; dmar = dmar->next)
ffffffff81003411:	48 85 db             	test   %rbx,%rbx
ffffffff81003414:	74 ee                	je     ffffffff81003404 <msi_vector+0x10>
            dmar->fault_handler();
ffffffff81003416:	48 89 df             	mov    %rbx,%rdi
ffffffff81003419:	e8 f4 fe ff ff       	callq  ffffffff81003312 <_ZN4Dmar13fault_handlerEv>
void Dmar::vector (unsigned vector)
{
    unsigned msi = vector - VEC_MSI;

    if (EXPECT_TRUE (msi == 0))
        for (Dmar *dmar = list; dmar; dmar = dmar->next)
ffffffff8100341e:	48 8b 1b             	mov    (%rbx),%rbx
ffffffff81003421:	eb ee                	jmp    ffffffff81003411 <msi_vector+0x1d>

ffffffff81003423 <_GLOBAL__sub_I.00102__ZN4Dmar5cacheE>:
#include "pd.hpp"
#include "stdio.hpp"
#include "vectors.hpp"

INIT_PRIORITY (PRIO_SLAB)
Slab_cache  Dmar::cache (sizeof (Dmar), 8);
ffffffff81003423:	ba 08 00 00 00       	mov    $0x8,%edx
ffffffff81003428:	be 30 00 00 00       	mov    $0x30,%esi
ffffffff8100342d:	48 c7 c7 70 20 16 81 	mov    $0xffffffff81162070,%rdi
ffffffff81003434:	e9 67 24 01 00       	jmpq   ffffffff810158a0 <_ZN10Slab_cacheC1Emj>

ffffffff81003439 <_GLOBAL__sub_I__ZN4Dmar5cacheE>:
    if (EXPECT_TRUE (msi == 0))
        for (Dmar *dmar = list; dmar; dmar = dmar->next)
            dmar->fault_handler();

    Lapic::eoi();
}
ffffffff81003439:	52                   	push   %rdx

        ALWAYS_INLINE
        inline void set (uint64 h, uint64 l) { hi = h; lo = l; flush (this); }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return flush (Buddy::allocator.alloc (0, quota, Buddy::FILL_0), PAGE_SIZE); }
ffffffff8100343a:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff8100343f:	48 c7 c2 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rdx
ffffffff81003446:	31 f6                	xor    %esi,%esi
ffffffff81003448:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff8100344f:	e8 9e e4 ff ff       	callq  ffffffff810018f2 <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
ffffffff81003454:	48 8d 88 00 10 00 00 	lea    0x1000(%rax),%rcx
}

ALWAYS_INLINE NONNULL
inline void *flush (void *d, size_t n)
{
    for (char *p = static_cast<char *>(d); p < static_cast<char *>(d) + n; p += 32)
ffffffff8100345b:	48 89 c2             	mov    %rax,%rdx
ffffffff8100345e:	48 39 ca             	cmp    %rcx,%rdx
ffffffff81003461:	74 09                	je     ffffffff8100346c <_GLOBAL__sub_I__ZN4Dmar5cacheE+0x33>

template <typename T>
ALWAYS_INLINE
static inline void flush (T t)
{
    asm volatile ("clflush %0" : : "m" (*t) : "memory");
ffffffff81003463:	0f ae 3a             	clflush (%rdx)
}

ALWAYS_INLINE NONNULL
inline void *flush (void *d, size_t n)
{
    for (char *p = static_cast<char *>(d); p < static_cast<char *>(d) + n; p += 32)
ffffffff81003466:	48 83 c2 20          	add    $0x20,%rdx
ffffffff8100346a:	eb f2                	jmp    ffffffff8100345e <_GLOBAL__sub_I__ZN4Dmar5cacheE+0x25>
    public:
        ALWAYS_INLINE
        inline void set (uint64 h, uint64 l) { hi = h; lo = l; flush (this); }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return flush (Buddy::allocator.alloc (0, quota, Buddy::FILL_0), PAGE_SIZE); }
ffffffff8100346c:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff81003471:	48 c7 c2 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rdx
ffffffff81003478:	31 f6                	xor    %esi,%esi
ffffffff8100347a:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi

INIT_PRIORITY (PRIO_SLAB)
Slab_cache  Dmar::cache (sizeof (Dmar), 8);

Dmar *      Dmar::list;
Dmar_ctx *  Dmar::ctx = new (Pd::kern.quota) Dmar_ctx;
ffffffff81003481:	48 89 05 d0 eb 15 00 	mov    %rax,0x15ebd0(%rip)        # ffffffff81162058 <_ZN4Dmar3ctxE>
ffffffff81003488:	e8 65 e4 ff ff       	callq  ffffffff810018f2 <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
ffffffff8100348d:	48 8d 88 00 10 00 00 	lea    0x1000(%rax),%rcx
ffffffff81003494:	48 89 c2             	mov    %rax,%rdx
ffffffff81003497:	48 39 ca             	cmp    %rcx,%rdx
ffffffff8100349a:	74 09                	je     ffffffff810034a5 <_GLOBAL__sub_I__ZN4Dmar5cacheE+0x6c>

template <typename T>
ALWAYS_INLINE
static inline void flush (T t)
{
    asm volatile ("clflush %0" : : "m" (*t) : "memory");
ffffffff8100349c:	0f ae 3a             	clflush (%rdx)
}

ALWAYS_INLINE NONNULL
inline void *flush (void *d, size_t n)
{
    for (char *p = static_cast<char *>(d); p < static_cast<char *>(d) + n; p += 32)
ffffffff8100349f:	48 83 c2 20          	add    $0x20,%rdx
ffffffff810034a3:	eb f2                	jmp    ffffffff81003497 <_GLOBAL__sub_I__ZN4Dmar5cacheE+0x5e>
Dmar_irt *  Dmar::irt = new (Pd::kern.quota) Dmar_irt;
ffffffff810034a5:	48 89 05 a4 eb 15 00 	mov    %rax,0x15eba4(%rip)        # ffffffff81162050 <_ZN4Dmar3irtE>
    if (EXPECT_TRUE (msi == 0))
        for (Dmar *dmar = list; dmar; dmar = dmar->next)
            dmar->fault_handler();

    Lapic::eoi();
}
ffffffff810034ac:	58                   	pop    %rax
ffffffff810034ad:	c3                   	retq   

ffffffff810034ae <_ZN7Kobject4freeEP8Rcu_elem>:
class Kobject : public Mdb
{
    private:
        uint8 objtype;

        static void free (Rcu_elem *) {}
ffffffff810034ae:	c3                   	retq   

ffffffff810034af <_ZN2Ec8pre_freeEP8Rcu_elem>:

    NOINLINE
    static void handle_hazard(mword, void (*)());

    static void pre_free(Rcu_elem * a) {
        Ec * e = static_cast<Ec *> (a);
ffffffff810034af:	48 85 ff             	test   %rdi,%rdi
    static bool fixup(mword &);

    NOINLINE
    static void handle_hazard(mword, void (*)());

    static void pre_free(Rcu_elem * a) {
ffffffff810034b2:	55                   	push   %rbp
ffffffff810034b3:	53                   	push   %rbx
ffffffff810034b4:	48 89 fb             	mov    %rdi,%rbx
ffffffff810034b7:	56                   	push   %rsi
        Ec * e = static_cast<Ec *> (a);
ffffffff810034b8:	74 09                	je     ffffffff810034c3 <_ZN2Ec8pre_freeEP8Rcu_elem+0x14>

        assert(e);
ffffffff810034ba:	48 89 fd             	mov    %rdi,%rbp
ffffffff810034bd:	48 83 ed 18          	sub    $0x18,%rbp
ffffffff810034c1:	75 1f                	jne    ffffffff810034e2 <_ZN2Ec8pre_freeEP8Rcu_elem+0x33>
ffffffff810034c3:	49 c7 c0 20 e1 01 81 	mov    $0xffffffff8101e120,%r8
ffffffff810034ca:	b9 7d 00 00 00       	mov    $0x7d,%ecx
ffffffff810034cf:	48 c7 c2 d3 da 01 81 	mov    $0xffffffff8101dad3,%rdx
ffffffff810034d6:	48 c7 c6 4e e2 01 81 	mov    $0xffffffff8101e24e,%rsi
ffffffff810034dd:	e9 92 00 00 00       	jmpq   ffffffff81003574 <_ZN2Ec8pre_freeEP8Rcu_elem+0xc5>

        // remove mapping in page table
        if (e->user_utcb) {
ffffffff810034e2:	48 8b b7 10 03 00 00 	mov    0x310(%rdi),%rsi
ffffffff810034e9:	48 85 f6             	test   %rsi,%rsi
ffffffff810034ec:	74 4d                	je     ffffffff8100353b <_ZN2Ec8pre_freeEP8Rcu_elem+0x8c>
            e->pd->remove_utcb(e->user_utcb);
ffffffff810034ee:	48 8b 87 80 02 00 00 	mov    0x280(%rdi),%rax
ffffffff810034f5:	48 8d b8 90 00 00 00 	lea    0x90(%rax),%rdi
ffffffff810034fc:	e8 cf 32 01 00       	callq  ffffffff810167d0 <_ZN9Space_mem11remove_utcbEm>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
ffffffff81003501:	48 8b bb 80 02 00 00 	mov    0x280(%rbx),%rdi
ffffffff81003508:	48 8b 93 10 03 00 00 	mov    0x310(%rbx),%rdx
ffffffff8100350f:	31 c9                	xor    %ecx,%ecx
ffffffff81003511:	6a 00                	pushq  $0x0
ffffffff81003513:	6a 00                	pushq  $0x0
ffffffff81003515:	45 31 c9             	xor    %r9d,%r9d
ffffffff81003518:	45 31 c0             	xor    %r8d,%r8d
            e->pd->Space_mem::insert(e->pd->quota, e->user_utcb, 0, 0, 0);
ffffffff8100351b:	48 8d b7 08 03 00 00 	lea    0x308(%rdi),%rsi
ffffffff81003522:	48 81 c7 a0 02 00 00 	add    $0x2a0,%rdi
ffffffff81003529:	e8 e8 f7 00 00       	callq  ffffffff81012d16 <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb>
ffffffff8100352e:	5a                   	pop    %rdx
ffffffff8100352f:	59                   	pop    %rcx
            e->user_utcb = 0;
ffffffff81003530:	48 c7 83 10 03 00 00 	movq   $0x0,0x310(%rbx)
ffffffff81003537:	00 00 00 00 
        }

        // XXX If e is on another CPU and there the fpowner - this check will fail.
        // XXX For now the destruction is delayed until somebody else grabs the FPU.
        if (fpowner == e) {
ffffffff8100353b:	48 39 2d 7e c2 ff 3e 	cmp    %rbp,0x3effc27e(%rip)        # ffffffffbffff7c0 <_ZN2Ec7fpownerE>
ffffffff81003542:	75 7b                	jne    ffffffff810035bf <_ZN2Ec8pre_freeEP8Rcu_elem+0x110>
            assert(Sc::current->cpu == e->cpu);
ffffffff81003544:	48 8b 15 cd ba ff 3e 	mov    0x3effbacd(%rip),%rdx        # ffffffffbffff018 <_ZN2Sc7currentE>
ffffffff8100354b:	0f b7 85 f0 02 00 00 	movzwl 0x2f0(%rbp),%eax
ffffffff81003552:	39 82 98 00 00 00    	cmp    %eax,0x98(%rdx)
ffffffff81003558:	74 28                	je     ffffffff81003582 <_ZN2Ec8pre_freeEP8Rcu_elem+0xd3>
ffffffff8100355a:	49 c7 c0 20 e1 01 81 	mov    $0xffffffff8101e120,%r8
ffffffff81003561:	b9 89 00 00 00       	mov    $0x89,%ecx
ffffffff81003566:	48 c7 c2 d3 da 01 81 	mov    $0xffffffff8101dad3,%rdx
ffffffff8100356d:	48 c7 c6 41 db 01 81 	mov    $0xffffffff8101db41,%rsi
ffffffff81003574:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100357b:	31 c0                	xor    %eax,%eax
ffffffff8100357d:	e8 ce e9 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff81003582:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff81003585:	f0 0f c1 85 8c 00 00 	lock xadd %eax,0x8c(%rbp)
ffffffff8100358c:	00 

            bool zero = fpowner->del_ref();
            assert(!zero);
ffffffff8100358d:	ff c8                	dec    %eax
ffffffff8100358f:	75 1c                	jne    ffffffff810035ad <_ZN2Ec8pre_freeEP8Rcu_elem+0xfe>
ffffffff81003591:	49 c7 c0 20 e1 01 81 	mov    $0xffffffff8101e120,%r8
ffffffff81003598:	b9 8c 00 00 00       	mov    $0x8c,%ecx
ffffffff8100359d:	48 c7 c2 d3 da 01 81 	mov    $0xffffffff8101dad3,%rdx
ffffffff810035a4:	48 c7 c6 5c db 01 81 	mov    $0xffffffff8101db5c,%rsi
ffffffff810035ab:	eb c7                	jmp    ffffffff81003574 <_ZN2Ec8pre_freeEP8Rcu_elem+0xc5>

            fpowner = nullptr;
            Cpu::hazard |= HZD_FPU;
ffffffff810035ad:	83 0d 4c ba ff 3e 08 	orl    $0x8,0x3effba4c(%rip)        # ffffffffbffff000 <_ZN3Cpu6hazardE>
            assert(Sc::current->cpu == e->cpu);

            bool zero = fpowner->del_ref();
            assert(!zero);

            fpowner = nullptr;
ffffffff810035b4:	48 c7 05 01 c2 ff 3e 	movq   $0x0,0x3effc201(%rip)        # ffffffffbffff7c0 <_ZN2Ec7fpownerE>
ffffffff810035bb:	00 00 00 00 
            Cpu::hazard |= HZD_FPU;
        }
    }
ffffffff810035bf:	58                   	pop    %rax
ffffffff810035c0:	5b                   	pop    %rbx
ffffffff810035c1:	5d                   	pop    %rbp
ffffffff810035c2:	c3                   	retq   
ffffffff810035c3:	90                   	nop

ffffffff810035c4 <_ZN5Quota7free_upERS_>:
        {
            kern.upli   = kern.used;
            root.upli  -= kern.used;
        }

        void free_up(Quota &to)
ffffffff810035c4:	41 57                	push   %r15
ffffffff810035c6:	41 56                	push   %r14
ffffffff810035c8:	41 55                	push   %r13
ffffffff810035ca:	41 54                	push   %r12
ffffffff810035cc:	49 89 fc             	mov    %rdi,%r12
ffffffff810035cf:	55                   	push   %rbp
ffffffff810035d0:	53                   	push   %rbx
ffffffff810035d1:	48 89 f3             	mov    %rsi,%rbx
ffffffff810035d4:	52                   	push   %rdx

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff810035d5:	9c                   	pushfq 
ffffffff810035d6:	58                   	pop    %rax
            return flags & 0x200;
ffffffff810035d7:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff810035db:	41 88 c7             	mov    %al,%r15b
ffffffff810035de:	41 80 e7 01          	and    $0x1,%r15b
ffffffff810035e2:	74 2d                	je     ffffffff81003611 <_ZN5Quota7free_upERS_+0x4d>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff810035e4:	80 3d 45 c1 ff 3e 00 	cmpb   $0x0,0x3effc145(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff810035eb:	75 1c                	jne    ffffffff81003609 <_ZN5Quota7free_upERS_+0x45>
ffffffff810035ed:	49 c7 c0 90 e0 01 81 	mov    $0xffffffff8101e090,%r8
ffffffff810035f4:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff810035f9:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81003600:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff81003607:	eb 66                	jmp    ffffffff8100366f <_ZN5Quota7free_upERS_+0xab>

            asm volatile ("cli" : : : "memory");
ffffffff81003609:	fa                   	cli    
            preemption = false;
ffffffff8100360a:	c6 05 1f c1 ff 3e 00 	movb   $0x0,0x3effc11f(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff81003611:	4c 89 e7             	mov    %r12,%rdi
ffffffff81003614:	e8 75 d8 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
        {
            mword l, u, o;
            {
                Lock_guard <Spinlock> guard (lock);
                l = upli;
ffffffff81003619:	4d 8b 74 24 18       	mov    0x18(%r12),%r14
                u = used;
ffffffff8100361e:	4d 8b 6c 24 08       	mov    0x8(%r12),%r13
                o = over;
ffffffff81003623:	49 8b 6c 24 10       	mov    0x10(%r12),%rbp
                upli = over = used = 0;
ffffffff81003628:	49 c7 44 24 08 00 00 	movq   $0x0,0x8(%r12)
ffffffff8100362f:	00 00 
ffffffff81003631:	49 c7 44 24 10 00 00 	movq   $0x0,0x10(%r12)
ffffffff81003638:	00 00 
ffffffff8100363a:	49 c7 44 24 18 00 00 	movq   $0x0,0x18(%r12)
ffffffff81003641:	00 00 
ffffffff81003643:	41 fe 04 24          	incb   (%r12)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81003647:	45 84 ff             	test   %r15b,%r15b
ffffffff8100364a:	74 39                	je     ffffffff81003685 <_ZN5Quota7free_upERS_+0xc1>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100364c:	80 3d dd c0 ff 3e 00 	cmpb   $0x0,0x3effc0dd(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81003653:	74 28                	je     ffffffff8100367d <_ZN5Quota7free_upERS_+0xb9>
ffffffff81003655:	49 c7 c0 60 e0 01 81 	mov    $0xffffffff8101e060,%r8
ffffffff8100365c:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff81003661:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81003668:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff8100366f:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81003676:	31 c0                	xor    %eax,%eax
ffffffff81003678:	e8 d3 e8 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            preemption = true;
ffffffff8100367d:	c6 05 ac c0 ff 3e 01 	movb   $0x1,0x3effc0ac(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81003684:	fb                   	sti    

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81003685:	9c                   	pushfq 
ffffffff81003686:	41 5c                	pop    %r12
            return flags & 0x200;
ffffffff81003688:	49 c1 ec 09          	shr    $0x9,%r12

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8100368c:	41 80 e4 01          	and    $0x1,%r12b
ffffffff81003690:	74 15                	je     ffffffff810036a7 <_ZN5Quota7free_upERS_+0xe3>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81003692:	80 3d 97 c0 ff 3e 00 	cmpb   $0x0,0x3effc097(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81003699:	0f 84 4e ff ff ff    	je     ffffffff810035ed <_ZN5Quota7free_upERS_+0x29>

            asm volatile ("cli" : : : "memory");
ffffffff8100369f:	fa                   	cli    
            preemption = false;
ffffffff810036a0:	c6 05 89 c0 ff 3e 00 	movb   $0x0,0x3effc089(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff810036a7:	48 89 df             	mov    %rbx,%rdi
ffffffff810036aa:	e8 df d7 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
            }

            Lock_guard <Spinlock> guard (to.lock);
            to.used += u;
            to.upli += l;
            to.over += o;
ffffffff810036af:	48 89 e8             	mov    %rbp,%rax
ffffffff810036b2:	48 03 43 10          	add    0x10(%rbx),%rax
                o = over;
                upli = over = used = 0;
            }

            Lock_guard <Spinlock> guard (to.lock);
            to.used += u;
ffffffff810036b6:	4c 89 ea             	mov    %r13,%rdx
            to.upli += l;
ffffffff810036b9:	4c 89 f1             	mov    %r14,%rcx
                o = over;
                upli = over = used = 0;
            }

            Lock_guard <Spinlock> guard (to.lock);
            to.used += u;
ffffffff810036bc:	48 03 53 08          	add    0x8(%rbx),%rdx
            to.upli += l;
ffffffff810036c0:	48 03 4b 18          	add    0x18(%rbx),%rcx
            to.over += o;

            if (to.over && to.used) {
ffffffff810036c4:	48 85 c0             	test   %rax,%rax
            }

            Lock_guard <Spinlock> guard (to.lock);
            to.used += u;
            to.upli += l;
            to.over += o;
ffffffff810036c7:	48 89 43 10          	mov    %rax,0x10(%rbx)
                o = over;
                upli = over = used = 0;
            }

            Lock_guard <Spinlock> guard (to.lock);
            to.used += u;
ffffffff810036cb:	48 89 53 08          	mov    %rdx,0x8(%rbx)
            to.upli += l;
ffffffff810036cf:	48 89 4b 18          	mov    %rcx,0x18(%rbx)
            to.over += o;

            if (to.over && to.used) {
ffffffff810036d3:	74 24                	je     ffffffff810036f9 <_ZN5Quota7free_upERS_+0x135>
ffffffff810036d5:	48 85 d2             	test   %rdx,%rdx
ffffffff810036d8:	74 1f                	je     ffffffff810036f9 <_ZN5Quota7free_upERS_+0x135>
ffffffff810036da:	48 39 d0             	cmp    %rdx,%rax
ffffffff810036dd:	48 89 d6             	mov    %rdx,%rsi
ffffffff810036e0:	48 0f 46 f0          	cmovbe %rax,%rsi
                mword s = min (to.used, to.over);
                to.used -= s;
ffffffff810036e4:	48 29 f2             	sub    %rsi,%rdx
                to.over -= s;
ffffffff810036e7:	48 29 f0             	sub    %rsi,%rax
                to.upli -= s;
ffffffff810036ea:	48 29 f1             	sub    %rsi,%rcx
            to.upli += l;
            to.over += o;

            if (to.over && to.used) {
                mword s = min (to.used, to.over);
                to.used -= s;
ffffffff810036ed:	48 89 53 08          	mov    %rdx,0x8(%rbx)
                to.over -= s;
ffffffff810036f1:	48 89 43 10          	mov    %rax,0x10(%rbx)
                to.upli -= s;
ffffffff810036f5:	48 89 4b 18          	mov    %rcx,0x18(%rbx)
ffffffff810036f9:	fe 03                	incb   (%rbx)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff810036fb:	45 84 e4             	test   %r12b,%r12b
ffffffff810036fe:	74 15                	je     ffffffff81003715 <_ZN5Quota7free_upERS_+0x151>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81003700:	80 3d 29 c0 ff 3e 00 	cmpb   $0x0,0x3effc029(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81003707:	0f 85 48 ff ff ff    	jne    ffffffff81003655 <_ZN5Quota7free_upERS_+0x91>

            preemption = true;
ffffffff8100370d:	c6 05 1c c0 ff 3e 01 	movb   $0x1,0x3effc01c(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81003714:	fb                   	sti    
            }
        }
ffffffff81003715:	58                   	pop    %rax
ffffffff81003716:	5b                   	pop    %rbx
ffffffff81003717:	5d                   	pop    %rbp
ffffffff81003718:	41 5c                	pop    %r12
ffffffff8100371a:	41 5d                	pop    %r13
ffffffff8100371c:	41 5e                	pop    %r14
ffffffff8100371e:	41 5f                	pop    %r15
ffffffff81003720:	c3                   	retq   
ffffffff81003721:	90                   	nop

ffffffff81003722 <_ZN5Quota11transfer_toERS_mb>:
                 return true;

             return usage() > upli - free_space;
        }

        bool transfer_to(Quota &to, mword transfer, bool check_notr = true)
ffffffff81003722:	41 56                	push   %r14
ffffffff81003724:	41 89 ce             	mov    %ecx,%r14d
ffffffff81003727:	41 55                	push   %r13
ffffffff81003729:	49 89 fd             	mov    %rdi,%r13
ffffffff8100372c:	41 54                	push   %r12
ffffffff8100372e:	49 89 f4             	mov    %rsi,%r12
ffffffff81003731:	55                   	push   %rbp
ffffffff81003732:	48 89 d5             	mov    %rdx,%rbp
ffffffff81003735:	53                   	push   %rbx

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81003736:	9c                   	pushfq 
ffffffff81003737:	5b                   	pop    %rbx
            return flags & 0x200;
ffffffff81003738:	48 c1 eb 09          	shr    $0x9,%rbx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8100373c:	80 e3 01             	and    $0x1,%bl
ffffffff8100373f:	74 30                	je     ffffffff81003771 <_ZN5Quota11transfer_toERS_mb+0x4f>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81003741:	80 3d e8 bf ff 3e 00 	cmpb   $0x0,0x3effbfe8(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81003748:	75 1f                	jne    ffffffff81003769 <_ZN5Quota11transfer_toERS_mb+0x47>
ffffffff8100374a:	49 c7 c0 90 e0 01 81 	mov    $0xffffffff8101e090,%r8
ffffffff81003751:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff81003756:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100375d:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff81003764:	e9 8a 00 00 00       	jmpq   ffffffff810037f3 <_ZN5Quota11transfer_toERS_mb+0xd1>

            asm volatile ("cli" : : : "memory");
ffffffff81003769:	fa                   	cli    
            preemption = false;
ffffffff8100376a:	c6 05 bf bf ff 3e 00 	movb   $0x0,0x3effbfbf(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff81003771:	4c 89 ef             	mov    %r13,%rdi
ffffffff81003774:	e8 15 d7 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
            }
        }

        bool hit_limit(mword free_space = 0)
        {
             if (free_space > upli)
ffffffff81003779:	49 8b 45 18          	mov    0x18(%r13),%rax
ffffffff8100377d:	49 8b 55 08          	mov    0x8(%r13),%rdx
             mword o = 0;

             {
                 Lock_guard <Spinlock> guard (lock);

                 if (hit_limit()) return false;
ffffffff81003781:	48 39 c2             	cmp    %rax,%rdx
ffffffff81003784:	0f 87 e4 00 00 00    	ja     ffffffff8100386e <_ZN5Quota11transfer_toERS_mb+0x14c>

                 mword not_for_transfer = check_notr ? notr : 0;
ffffffff8100378a:	31 f6                	xor    %esi,%esi
ffffffff8100378c:	45 84 f6             	test   %r14b,%r14b
ffffffff8100378f:	74 04                	je     ffffffff81003795 <_ZN5Quota11transfer_toERS_mb+0x73>
ffffffff81003791:	49 8b 75 20          	mov    0x20(%r13),%rsi

                 if (usage() + transfer > upli - not_for_transfer) return false;
ffffffff81003795:	48 89 c1             	mov    %rax,%rcx
ffffffff81003798:	48 01 ea             	add    %rbp,%rdx
ffffffff8100379b:	48 29 f1             	sub    %rsi,%rcx
ffffffff8100379e:	48 39 ca             	cmp    %rcx,%rdx
ffffffff810037a1:	0f 87 c7 00 00 00    	ja     ffffffff8100386e <_ZN5Quota11transfer_toERS_mb+0x14c>

                 upli -= transfer;
ffffffff810037a7:	48 29 e8             	sub    %rbp,%rax
ffffffff810037aa:	49 89 45 18          	mov    %rax,0x18(%r13)

                 o = min (over, transfer);
ffffffff810037ae:	49 8b 45 10          	mov    0x10(%r13),%rax
ffffffff810037b2:	48 39 c5             	cmp    %rax,%rbp
ffffffff810037b5:	49 89 c6             	mov    %rax,%r14
ffffffff810037b8:	4c 0f 46 f5          	cmovbe %rbp,%r14
                 if (o)
ffffffff810037bc:	4d 85 f6             	test   %r14,%r14
ffffffff810037bf:	74 07                	je     ffffffff810037c8 <_ZN5Quota11transfer_toERS_mb+0xa6>
                     over -= o;
ffffffff810037c1:	4c 29 f0             	sub    %r14,%rax
ffffffff810037c4:	49 89 45 10          	mov    %rax,0x10(%r13)
ffffffff810037c8:	41 fe 45 00          	incb   0x0(%r13)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff810037cc:	84 db                	test   %bl,%bl
ffffffff810037ce:	74 39                	je     ffffffff81003809 <_ZN5Quota11transfer_toERS_mb+0xe7>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff810037d0:	80 3d 59 bf ff 3e 00 	cmpb   $0x0,0x3effbf59(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff810037d7:	74 28                	je     ffffffff81003801 <_ZN5Quota11transfer_toERS_mb+0xdf>
ffffffff810037d9:	49 c7 c0 60 e0 01 81 	mov    $0xffffffff8101e060,%r8
ffffffff810037e0:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff810037e5:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff810037ec:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff810037f3:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff810037fa:	31 c0                	xor    %eax,%eax
ffffffff810037fc:	e8 4f e7 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            preemption = true;
ffffffff81003801:	c6 05 28 bf ff 3e 01 	movb   $0x1,0x3effbf28(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81003808:	fb                   	sti    

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81003809:	9c                   	pushfq 
ffffffff8100380a:	5b                   	pop    %rbx
            return flags & 0x200;
ffffffff8100380b:	48 c1 eb 09          	shr    $0x9,%rbx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8100380f:	80 e3 01             	and    $0x1,%bl
ffffffff81003812:	74 15                	je     ffffffff81003829 <_ZN5Quota11transfer_toERS_mb+0x107>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81003814:	80 3d 15 bf ff 3e 00 	cmpb   $0x0,0x3effbf15(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100381b:	0f 84 29 ff ff ff    	je     ffffffff8100374a <_ZN5Quota11transfer_toERS_mb+0x28>

            asm volatile ("cli" : : : "memory");
ffffffff81003821:	fa                   	cli    
            preemption = false;
ffffffff81003822:	c6 05 07 bf ff 3e 00 	movb   $0x0,0x3effbf07(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff81003829:	4c 89 e7             	mov    %r12,%rdi
ffffffff8100382c:	e8 5d d6 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
             }

             Lock_guard <Spinlock> guard (to.lock);
             to.upli += transfer;
ffffffff81003831:	49 03 6c 24 18       	add    0x18(%r12),%rbp

             if (to.used && o) {
ffffffff81003836:	4d 85 f6             	test   %r14,%r14
ffffffff81003839:	49 8b 44 24 08       	mov    0x8(%r12),%rax
                 if (o)
                     over -= o;
             }

             Lock_guard <Spinlock> guard (to.lock);
             to.upli += transfer;
ffffffff8100383e:	49 89 6c 24 18       	mov    %rbp,0x18(%r12)

             if (to.used && o) {
ffffffff81003843:	74 3b                	je     ffffffff81003880 <_ZN5Quota11transfer_toERS_mb+0x15e>
ffffffff81003845:	48 85 c0             	test   %rax,%rax
ffffffff81003848:	74 36                	je     ffffffff81003880 <_ZN5Quota11transfer_toERS_mb+0x15e>
ffffffff8100384a:	49 39 c6             	cmp    %rax,%r14
ffffffff8100384d:	48 89 c2             	mov    %rax,%rdx
ffffffff81003850:	49 0f 46 d6          	cmovbe %r14,%rdx
                mword u = min (to.used, o);
                to.used -= u;
ffffffff81003854:	48 29 d0             	sub    %rdx,%rax
                to.upli -= u;
ffffffff81003857:	48 29 d5             	sub    %rdx,%rbp
                to.over += o - u;
ffffffff8100385a:	49 29 d6             	sub    %rdx,%r14
             Lock_guard <Spinlock> guard (to.lock);
             to.upli += transfer;

             if (to.used && o) {
                mword u = min (to.used, o);
                to.used -= u;
ffffffff8100385d:	49 89 44 24 08       	mov    %rax,0x8(%r12)
                to.upli -= u;
ffffffff81003862:	49 89 6c 24 18       	mov    %rbp,0x18(%r12)
                to.over += o - u;
ffffffff81003867:	4d 01 74 24 10       	add    %r14,0x10(%r12)
ffffffff8100386c:	eb 12                	jmp    ffffffff81003880 <_ZN5Quota11transfer_toERS_mb+0x15e>
ffffffff8100386e:	41 fe 45 00          	incb   0x0(%r13)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81003872:	84 db                	test   %bl,%bl
ffffffff81003874:	74 2b                	je     ffffffff810038a1 <_ZN5Quota11transfer_toERS_mb+0x17f>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81003876:	8a 1d b4 be ff 3e    	mov    0x3effbeb4(%rip),%bl        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100387c:	84 db                	test   %bl,%bl
ffffffff8100387e:	eb 0f                	jmp    ffffffff8100388f <_ZN5Quota11transfer_toERS_mb+0x16d>
ffffffff81003880:	41 fe 04 24          	incb   (%r12)
ffffffff81003884:	84 db                	test   %bl,%bl
ffffffff81003886:	74 17                	je     ffffffff8100389f <_ZN5Quota11transfer_toERS_mb+0x17d>
ffffffff81003888:	80 3d a1 be ff 3e 00 	cmpb   $0x0,0x3effbea1(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100388f:	0f 85 44 ff ff ff    	jne    ffffffff810037d9 <_ZN5Quota11transfer_toERS_mb+0xb7>

            preemption = true;
ffffffff81003895:	c6 05 94 be ff 3e 01 	movb   $0x1,0x3effbe94(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100389c:	fb                   	sti    
ffffffff8100389d:	eb 02                	jmp    ffffffff810038a1 <_ZN5Quota11transfer_toERS_mb+0x17f>
             }

             return true;
ffffffff8100389f:	b3 01                	mov    $0x1,%bl
        }
ffffffff810038a1:	88 d8                	mov    %bl,%al
ffffffff810038a3:	5b                   	pop    %rbx
ffffffff810038a4:	5d                   	pop    %rbp
ffffffff810038a5:	41 5c                	pop    %r12
ffffffff810038a7:	41 5d                	pop    %r13
ffffffff810038a9:	41 5e                	pop    %r14
ffffffff810038ab:	c3                   	retq   

ffffffff810038ac <_ZN3MdbC1EP5SpacemmmPFvP8Rcu_elemES5_>:
ffffffff810038ac:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
ffffffff810038b1:	66 c7 47 10 02 00    	movw   $0x2,0x10(%rdi)
ffffffff810038b7:	66 c7 47 12 00 00    	movw   $0x0,0x12(%rdi)
ffffffff810038bd:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
ffffffff810038c4:	00 
ffffffff810038c5:	48 c7 07 00 00 00 00 	movq   $0x0,(%rdi)
ffffffff810038cc:	48 c7 47 18 00 00 00 	movq   $0x0,0x18(%rdi)
ffffffff810038d3:	00 
ffffffff810038d4:	4c 89 4f 20          	mov    %r9,0x20(%rdi)
ffffffff810038d8:	48 89 47 28          	mov    %rax,0x28(%rdi)
    private:
        uint16 val;

    public:
        ALWAYS_INLINE
        inline Spinlock() : val (0) {}
ffffffff810038dc:	66 c7 47 30 00 00    	movw   $0x0,0x30(%rdi)

        ALWAYS_INLINE
        inline bool equal  (Mdb *x) const { return (node_base ^ x->node_base) >> max (node_order, x->node_order) == 0; }

        NOINLINE
        explicit Mdb (Space *s, mword p, mword b, mword a, void (*f)(Rcu_elem *), void (*pf)(Rcu_elem *) = nullptr) : Rcu_elem (f, pf), dpth (0), prev (this), next (this), prnt (nullptr), space (s), node_phys (p), node_base (b), node_order (0), node_attr (a), node_type (0), node_sub (0) {}
ffffffff810038e2:	66 c7 47 32 00 00    	movw   $0x0,0x32(%rdi)
ffffffff810038e8:	48 89 7f 38          	mov    %rdi,0x38(%rdi)
ffffffff810038ec:	48 89 7f 40          	mov    %rdi,0x40(%rdi)
ffffffff810038f0:	48 c7 47 48 00 00 00 	movq   $0x0,0x48(%rdi)
ffffffff810038f7:	00 
ffffffff810038f8:	48 89 77 50          	mov    %rsi,0x50(%rdi)
ffffffff810038fc:	48 89 57 58          	mov    %rdx,0x58(%rdi)
ffffffff81003900:	48 89 4f 60          	mov    %rcx,0x60(%rdi)
ffffffff81003904:	48 c7 47 68 00 00 00 	movq   $0x0,0x68(%rdi)
ffffffff8100390b:	00 
ffffffff8100390c:	4c 89 47 70          	mov    %r8,0x70(%rdi)
ffffffff81003910:	48 c7 47 78 00 00 00 	movq   $0x0,0x78(%rdi)
ffffffff81003917:	00 
ffffffff81003918:	48 c7 87 80 00 00 00 	movq   $0x0,0x80(%rdi)
ffffffff8100391f:	00 00 00 00 
ffffffff81003923:	c3                   	retq   

ffffffff81003924 <_ZN2EcC1EP2PdPFvvEj>:
Slab_cache Ec::cache(sizeof (Ec), 32);

Ec *Ec::current, *Ec::fpowner;
// Constructors

Ec::Ec(Pd *own, void (*f)(), unsigned c) : Kobject(EC, static_cast<Space_obj *> (own)), cont(f), utcb(nullptr), pd(own), partner(nullptr), prev(nullptr), next(nullptr), fpu(nullptr), cpu(static_cast<uint16> (c)), glb(true), evt(0), timeout(this), user_utcb(0), xcpu_sm(nullptr), pt_oom(nullptr) {
ffffffff81003924:	41 55                	push   %r13
ffffffff81003926:	41 54                	push   %r12
ffffffff81003928:	48 8d 86 f8 02 00 00 	lea    0x2f8(%rsi),%rax
ffffffff8100392f:	55                   	push   %rbp
ffffffff81003930:	53                   	push   %rbx
ffffffff81003931:	48 89 f5             	mov    %rsi,%rbp
ffffffff81003934:	49 89 d5             	mov    %rdx,%r13
            PT,
            SM,
            INVALID,
        };

        explicit Kobject (Type t, Space *s, mword b = 0, mword a = 0, void (*f)(Rcu_elem *) = free, void (*pref)(Rcu_elem *) = nullptr ) : Mdb (s, reinterpret_cast<mword>(this), b, a, f, pref), objtype (t) {}
ffffffff81003937:	49 c7 c1 ae 34 00 81 	mov    $0xffffffff810034ae,%r9
ffffffff8100393e:	41 89 cc             	mov    %ecx,%r12d
ffffffff81003941:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff81003945:	48 85 f6             	test   %rsi,%rsi
ffffffff81003948:	be 00 00 00 00       	mov    $0x0,%esi
ffffffff8100394d:	6a 00                	pushq  $0x0
ffffffff8100394f:	48 0f 45 f0          	cmovne %rax,%rsi
ffffffff81003953:	48 89 fa             	mov    %rdi,%rdx
ffffffff81003956:	45 31 c0             	xor    %r8d,%r8d
ffffffff81003959:	31 c9                	xor    %ecx,%ecx
ffffffff8100395b:	48 89 fb             	mov    %rdi,%rbx
ffffffff8100395e:	e8 49 ff ff ff       	callq  ffffffff810038ac <_ZN3MdbC1EP5SpacemmmPFvP8Rcu_elemES5_>
ffffffff81003963:	41 59                	pop    %r9
ffffffff81003965:	41 5a                	pop    %r10
ffffffff81003967:	c6 83 88 00 00 00 01 	movb   $0x1,0x88(%rbx)
ffffffff8100396e:	66 c7 83 8a 00 00 00 	movw   $0x0,0x8a(%rbx)
ffffffff81003975:	00 00 
    private:
        uint32 ref;

    public:
        ALWAYS_INLINE
        inline Refex() : ref (1) {}
ffffffff81003977:	c7 83 8c 00 00 00 01 	movl   $0x1,0x8c(%rbx)
ffffffff8100397e:	00 00 00 
    private:
        T *headptr;

    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}
ffffffff81003981:	48 c7 83 90 00 00 00 	movq   $0x0,0x90(%rbx)
ffffffff81003988:	00 00 00 00 
ffffffff8100398c:	4c 89 ab a0 00 00 00 	mov    %r13,0xa0(%rbx)
ffffffff81003993:	48 c7 83 90 02 00 00 	movq   $0x0,0x290(%rbx)
ffffffff8100399a:	00 00 00 00 

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100399e:	8b 85 8c 00 00 00    	mov    0x8c(%rbp),%eax
ffffffff810039a4:	85 c0                	test   %eax,%eax
ffffffff810039a6:	74 0f                	je     ffffffff810039b7 <_ZN2EcC1EP2PdPFvvEj+0x93>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff810039a8:	8d 50 01             	lea    0x1(%rax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff810039ab:	f0 0f b1 95 8c 00 00 	lock cmpxchg %edx,0x8c(%rbp)
ffffffff810039b2:	00 
ffffffff810039b3:	75 e9                	jne    ffffffff8100399e <_ZN2EcC1EP2PdPFvvEj+0x7a>
ffffffff810039b5:	eb 02                	jmp    ffffffff810039b9 <_ZN2EcC1EP2PdPFvvEj+0x95>
    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }

        ALWAYS_INLINE
        inline Refptr (T *p) : ptr (p->add_ref() ? p : nullptr) {}
ffffffff810039b7:	31 ed                	xor    %ebp,%ebp
ffffffff810039b9:	48 89 ab 98 02 00 00 	mov    %rbp,0x298(%rbx)
ffffffff810039c0:	66 44 89 a3 f0 02 00 	mov    %r12w,0x2f0(%rbx)
ffffffff810039c7:	00 
ffffffff810039c8:	48 c7 83 a0 02 00 00 	movq   $0x0,0x2a0(%rbx)
ffffffff810039cf:	00 00 00 00 
ffffffff810039d3:	48 c7 83 a8 02 00 00 	movq   $0x0,0x2a8(%rbx)
ffffffff810039da:	00 00 00 00 
ffffffff810039de:	48 c7 83 b0 02 00 00 	movq   $0x0,0x2b0(%rbx)
ffffffff810039e5:	00 00 00 00 
ffffffff810039e9:	48 c7 83 b8 02 00 00 	movq   $0x0,0x2b8(%rbx)
ffffffff810039f0:	00 00 00 00 
ffffffff810039f4:	66 c7 83 f2 02 00 00 	movw   $0x1,0x2f2(%rbx)
ffffffff810039fb:	01 00 
ffffffff810039fd:	c7 83 f4 02 00 00 00 	movl   $0x0,0x2f4(%rbx)
ffffffff81003a04:	00 00 00 

    public:
        static Timeout *list CPULOCAL;

        ALWAYS_INLINE
        inline Timeout() : prev (nullptr), next (nullptr), time (0) {}
ffffffff81003a07:	48 c7 83 00 03 00 00 	movq   $0x0,0x300(%rbx)
ffffffff81003a0e:	00 00 00 00 
ffffffff81003a12:	48 c7 83 08 03 00 00 	movq   $0x0,0x308(%rbx)
ffffffff81003a19:	00 00 00 00 
ffffffff81003a1d:	48 c7 83 10 03 00 00 	movq   $0x0,0x310(%rbx)
ffffffff81003a24:	00 00 00 00 

        void trigger();

    public:
        ALWAYS_INLINE
        inline Timeout_hypercall (Ec *e) : ec (e) {}
ffffffff81003a28:	48 c7 83 f8 02 00 00 	movq   $0xffffffff81021450,0x2f8(%rbx)
ffffffff81003a2f:	50 14 02 81 
ffffffff81003a33:	48 89 9b 18 03 00 00 	mov    %rbx,0x318(%rbx)
ffffffff81003a3a:	48 c7 83 28 03 00 00 	movq   $0x0,0x328(%rbx)
ffffffff81003a41:	00 00 00 00 
ffffffff81003a45:	48 c7 83 30 03 00 00 	movq   $0x0,0x330(%rbx)
ffffffff81003a4c:	00 00 00 00 
ffffffff81003a50:	48 c7 83 38 03 00 00 	movq   $0x0,0x338(%rbx)
ffffffff81003a57:	00 00 00 00 
ffffffff81003a5b:	48 c7 83 40 03 00 00 	movq   $0x0,0x340(%rbx)
ffffffff81003a62:	00 00 00 00 
ffffffff81003a66:	66 c7 83 48 03 00 00 	movw   $0x0,0x348(%rbx)
ffffffff81003a6d:	00 00 
ffffffff81003a6f:	c6 83 4a 03 00 00 00 	movb   $0x0,0x34a(%rbx)
ffffffff81003a76:	c7 83 4c 03 00 00 00 	movl   $0x0,0x34c(%rbx)
ffffffff81003a7d:	00 00 00 
ffffffff81003a80:	c6 83 50 03 00 00 00 	movb   $0x0,0x350(%rbx)
ffffffff81003a87:	c6 83 51 03 00 00 00 	movb   $0x0,0x351(%rbx)
ffffffff81003a8e:	c7 83 54 03 00 00 00 	movl   $0x0,0x354(%rbx)
ffffffff81003a95:	00 00 00 
ffffffff81003a98:	c7 83 58 03 00 00 00 	movl   $0x0,0x358(%rbx)
ffffffff81003a9f:	00 00 00 
ffffffff81003aa2:	c7 83 5c 03 00 00 00 	movl   $0x0,0x35c(%rbx)
ffffffff81003aa9:	00 00 00 
    trace(TRACE_SYSCALL, "EC:%p created (PD:%p Kernel)", this, own);

    regs.vtlb = nullptr;
ffffffff81003aac:	48 c7 83 30 01 00 00 	movq   $0x0,0x130(%rbx)
ffffffff81003ab3:	00 00 00 00 
    regs.vmcs = nullptr;
ffffffff81003ab7:	48 c7 83 28 01 00 00 	movq   $0x0,0x128(%rbx)
ffffffff81003abe:	00 00 00 00 
    regs.vmcb = nullptr;
}
ffffffff81003ac2:	58                   	pop    %rax
ffffffff81003ac3:	5b                   	pop    %rbx
ffffffff81003ac4:	5d                   	pop    %rbp
ffffffff81003ac5:	41 5c                	pop    %r12
ffffffff81003ac7:	41 5d                	pop    %r13
ffffffff81003ac9:	c3                   	retq   

ffffffff81003aca <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt>:
 * @param c : cpu
 * @param e : event selector for this execution context
 * @param u : user thread control block
 * @param s : stack pointer
 */
Ec::Ec(Pd *own, mword sel, Pd *p, void (*f)(), unsigned c, unsigned e, mword u, mword s, Pt *oom) : Kobject(EC, static_cast<Space_obj *> (own), sel, 0xd, free, pre_free), cont(f), pd(p), partner(nullptr), prev(nullptr), next(nullptr), fpu(nullptr), cpu(static_cast<uint16> (c)), glb(!!f), evt(e), timeout(this), user_utcb(u), xcpu_sm(nullptr), pt_oom(oom) {
ffffffff81003aca:	41 57                	push   %r15
ffffffff81003acc:	41 56                	push   %r14
ffffffff81003ace:	48 8d 86 f8 02 00 00 	lea    0x2f8(%rsi),%rax
ffffffff81003ad5:	41 55                	push   %r13
ffffffff81003ad7:	41 54                	push   %r12
ffffffff81003ad9:	4d 89 c7             	mov    %r8,%r15
ffffffff81003adc:	55                   	push   %rbp
ffffffff81003add:	53                   	push   %rbx
ffffffff81003ade:	48 89 cd             	mov    %rcx,%rbp
ffffffff81003ae1:	45 89 cc             	mov    %r9d,%r12d
ffffffff81003ae4:	48 89 d1             	mov    %rdx,%rcx
ffffffff81003ae7:	49 c7 c1 4e 47 00 81 	mov    $0xffffffff8100474e,%r9
ffffffff81003aee:	48 83 ec 30          	sub    $0x30,%rsp
ffffffff81003af2:	48 85 f6             	test   %rsi,%rsi
ffffffff81003af5:	be 00 00 00 00       	mov    $0x0,%esi
ffffffff81003afa:	4c 8b 6c 24 70       	mov    0x70(%rsp),%r13
ffffffff81003aff:	4c 8b 74 24 78       	mov    0x78(%rsp),%r14
ffffffff81003b04:	48 0f 45 f0          	cmovne %rax,%rsi
ffffffff81003b08:	68 af 34 00 81       	pushq  $0xffffffff810034af
ffffffff81003b0d:	41 b8 0d 00 00 00    	mov    $0xd,%r8d
ffffffff81003b13:	48 89 fa             	mov    %rdi,%rdx
ffffffff81003b16:	48 89 fb             	mov    %rdi,%rbx
ffffffff81003b19:	e8 8e fd ff ff       	callq  ffffffff810038ac <_ZN3MdbC1EP5SpacemmmPFvP8Rcu_elemES5_>
ffffffff81003b1e:	59                   	pop    %rcx
ffffffff81003b1f:	5e                   	pop    %rsi
ffffffff81003b20:	c6 83 88 00 00 00 01 	movb   $0x1,0x88(%rbx)
ffffffff81003b27:	66 c7 83 8a 00 00 00 	movw   $0x0,0x8a(%rbx)
ffffffff81003b2e:	00 00 
    private:
        uint32 ref;

    public:
        ALWAYS_INLINE
        inline Refex() : ref (1) {}
ffffffff81003b30:	c7 83 8c 00 00 00 01 	movl   $0x1,0x8c(%rbx)
ffffffff81003b37:	00 00 00 
ffffffff81003b3a:	48 c7 83 90 00 00 00 	movq   $0x0,0x90(%rbx)
ffffffff81003b41:	00 00 00 00 
ffffffff81003b45:	4c 89 bb a0 00 00 00 	mov    %r15,0xa0(%rbx)

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff81003b4c:	8b 85 8c 00 00 00    	mov    0x8c(%rbp),%eax
ffffffff81003b52:	85 c0                	test   %eax,%eax
ffffffff81003b54:	74 0f                	je     ffffffff81003b65 <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x9b>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff81003b56:	8d 50 01             	lea    0x1(%rax),%edx
ffffffff81003b59:	f0 0f b1 95 8c 00 00 	lock cmpxchg %edx,0x8c(%rbp)
ffffffff81003b60:	00 
ffffffff81003b61:	75 e9                	jne    ffffffff81003b4c <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x82>
ffffffff81003b63:	eb 02                	jmp    ffffffff81003b67 <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x9d>
    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }

        ALWAYS_INLINE
        inline Refptr (T *p) : ptr (p->add_ref() ? p : nullptr) {}
ffffffff81003b65:	31 ed                	xor    %ebp,%ebp
ffffffff81003b67:	31 c0                	xor    %eax,%eax
ffffffff81003b69:	4d 85 ff             	test   %r15,%r15
    // Make sure we have a PTAB for this CPU in the PD
    pd->Space_mem::init(pd->quota, c);
ffffffff81003b6c:	48 8d b5 08 03 00 00 	lea    0x308(%rbp),%rsi
 * @param c : cpu
 * @param e : event selector for this execution context
 * @param u : user thread control block
 * @param s : stack pointer
 */
Ec::Ec(Pd *own, mword sel, Pd *p, void (*f)(), unsigned c, unsigned e, mword u, mword s, Pt *oom) : Kobject(EC, static_cast<Space_obj *> (own), sel, 0xd, free, pre_free), cont(f), pd(p), partner(nullptr), prev(nullptr), next(nullptr), fpu(nullptr), cpu(static_cast<uint16> (c)), glb(!!f), evt(e), timeout(this), user_utcb(u), xcpu_sm(nullptr), pt_oom(oom) {
ffffffff81003b73:	0f 95 c0             	setne  %al
    // Make sure we have a PTAB for this CPU in the PD
    pd->Space_mem::init(pd->quota, c);
ffffffff81003b76:	48 8d bd 90 00 00 00 	lea    0x90(%rbp),%rdi
ffffffff81003b7d:	44 89 e2             	mov    %r12d,%edx
 * @param c : cpu
 * @param e : event selector for this execution context
 * @param u : user thread control block
 * @param s : stack pointer
 */
Ec::Ec(Pd *own, mword sel, Pd *p, void (*f)(), unsigned c, unsigned e, mword u, mword s, Pt *oom) : Kobject(EC, static_cast<Space_obj *> (own), sel, 0xd, free, pre_free), cont(f), pd(p), partner(nullptr), prev(nullptr), next(nullptr), fpu(nullptr), cpu(static_cast<uint16> (c)), glb(!!f), evt(e), timeout(this), user_utcb(u), xcpu_sm(nullptr), pt_oom(oom) {
ffffffff81003b80:	66 89 83 f2 02 00 00 	mov    %ax,0x2f2(%rbx)
ffffffff81003b87:	8b 44 24 60          	mov    0x60(%rsp),%eax
ffffffff81003b8b:	48 89 ab 98 02 00 00 	mov    %rbp,0x298(%rbx)
ffffffff81003b92:	48 c7 83 a0 02 00 00 	movq   $0x0,0x2a0(%rbx)
ffffffff81003b99:	00 00 00 00 
ffffffff81003b9d:	48 c7 83 a8 02 00 00 	movq   $0x0,0x2a8(%rbx)
ffffffff81003ba4:	00 00 00 00 
ffffffff81003ba8:	48 c7 83 b0 02 00 00 	movq   $0x0,0x2b0(%rbx)
ffffffff81003baf:	00 00 00 00 
ffffffff81003bb3:	89 83 f4 02 00 00    	mov    %eax,0x2f4(%rbx)
ffffffff81003bb9:	48 8b 44 24 78       	mov    0x78(%rsp),%rax
ffffffff81003bbe:	48 c7 83 b8 02 00 00 	movq   $0x0,0x2b8(%rbx)
ffffffff81003bc5:	00 00 00 00 
ffffffff81003bc9:	66 44 89 a3 f0 02 00 	mov    %r12w,0x2f0(%rbx)
ffffffff81003bd0:	00 
ffffffff81003bd1:	48 c7 83 00 03 00 00 	movq   $0x0,0x300(%rbx)
ffffffff81003bd8:	00 00 00 00 
ffffffff81003bdc:	48 c7 83 08 03 00 00 	movq   $0x0,0x308(%rbx)
ffffffff81003be3:	00 00 00 00 
ffffffff81003be7:	48 c7 83 10 03 00 00 	movq   $0x0,0x310(%rbx)
ffffffff81003bee:	00 00 00 00 
ffffffff81003bf2:	48 c7 83 f8 02 00 00 	movq   $0xffffffff81021450,0x2f8(%rbx)
ffffffff81003bf9:	50 14 02 81 
ffffffff81003bfd:	48 89 9b 18 03 00 00 	mov    %rbx,0x318(%rbx)
ffffffff81003c04:	4c 89 ab 28 03 00 00 	mov    %r13,0x328(%rbx)
ffffffff81003c0b:	48 c7 83 30 03 00 00 	movq   $0x0,0x330(%rbx)
ffffffff81003c12:	00 00 00 00 
ffffffff81003c16:	48 89 83 38 03 00 00 	mov    %rax,0x338(%rbx)
ffffffff81003c1d:	48 c7 83 40 03 00 00 	movq   $0x0,0x340(%rbx)
ffffffff81003c24:	00 00 00 00 
ffffffff81003c28:	66 c7 83 48 03 00 00 	movw   $0x0,0x348(%rbx)
ffffffff81003c2f:	00 00 
ffffffff81003c31:	c6 83 4a 03 00 00 00 	movb   $0x0,0x34a(%rbx)
ffffffff81003c38:	c7 83 4c 03 00 00 00 	movl   $0x0,0x34c(%rbx)
ffffffff81003c3f:	00 00 00 
ffffffff81003c42:	c6 83 50 03 00 00 00 	movb   $0x0,0x350(%rbx)
ffffffff81003c49:	c6 83 51 03 00 00 00 	movb   $0x0,0x351(%rbx)
ffffffff81003c50:	c7 83 54 03 00 00 00 	movl   $0x0,0x354(%rbx)
ffffffff81003c57:	00 00 00 
ffffffff81003c5a:	c7 83 58 03 00 00 00 	movl   $0x0,0x358(%rbx)
ffffffff81003c61:	00 00 00 
ffffffff81003c64:	c7 83 5c 03 00 00 00 	movl   $0x0,0x35c(%rbx)
ffffffff81003c6b:	00 00 00 
    // Make sure we have a PTAB for this CPU in the PD
    pd->Space_mem::init(pd->quota, c);
ffffffff81003c6e:	e8 dd 23 01 00       	callq  ffffffff81016050 <_ZN9Space_mem4initER5Quotaj>

    regs.vtlb = nullptr;
    regs.vmcs = nullptr;
    regs.vmcb = nullptr;

    if (pt_oom)
ffffffff81003c73:	48 8b 93 38 03 00 00 	mov    0x338(%rbx),%rdx
 */
Ec::Ec(Pd *own, mword sel, Pd *p, void (*f)(), unsigned c, unsigned e, mword u, mword s, Pt *oom) : Kobject(EC, static_cast<Space_obj *> (own), sel, 0xd, free, pre_free), cont(f), pd(p), partner(nullptr), prev(nullptr), next(nullptr), fpu(nullptr), cpu(static_cast<uint16> (c)), glb(!!f), evt(e), timeout(this), user_utcb(u), xcpu_sm(nullptr), pt_oom(oom) {
    // Make sure we have a PTAB for this CPU in the PD
    pd->Space_mem::init(pd->quota, c);

    regs.vtlb = nullptr;
ffffffff81003c7a:	48 c7 83 30 01 00 00 	movq   $0x0,0x130(%rbx)
ffffffff81003c81:	00 00 00 00 
    regs.vmcs = nullptr;
ffffffff81003c85:	48 c7 83 28 01 00 00 	movq   $0x0,0x128(%rbx)
ffffffff81003c8c:	00 00 00 00 
    regs.vmcb = nullptr;

    if (pt_oom)
ffffffff81003c90:	48 85 d2             	test   %rdx,%rdx
ffffffff81003c93:	75 0a                	jne    ffffffff81003c9f <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x1d5>
        pt_oom->add_ref();

    if (u) { // if a user thread
ffffffff81003c95:	4d 85 ed             	test   %r13,%r13
ffffffff81003c98:	75 1c                	jne    ffffffff81003cb6 <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x1ec>
ffffffff81003c9a:	e9 1d 01 00 00       	jmpq   ffffffff81003dbc <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x2f2>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff81003c9f:	8b 82 8c 00 00 00    	mov    0x8c(%rdx),%eax
ffffffff81003ca5:	85 c0                	test   %eax,%eax
ffffffff81003ca7:	74 ec                	je     ffffffff81003c95 <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x1cb>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff81003ca9:	8d 48 01             	lea    0x1(%rax),%ecx
ffffffff81003cac:	f0 0f b1 8a 8c 00 00 	lock cmpxchg %ecx,0x8c(%rdx)
ffffffff81003cb3:	00 
ffffffff81003cb4:	eb dd                	jmp    ffffffff81003c93 <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x1c9>
        regs.cs = SEL_USER_CODE;
        regs.ds = SEL_USER_DATA;
        regs.es = SEL_USER_DATA;
        regs.ss = SEL_USER_DATA;
        regs.REG(fl) = Cpu::EFL_IF;
        if (glb) { // if global
ffffffff81003cb6:	66 83 bb f2 02 00 00 	cmpw   $0x0,0x2f2(%rbx)
ffffffff81003cbd:	00 
    if (pt_oom)
        pt_oom->add_ref();

    if (u) { // if a user thread
        //        Console::print("...user thread.");
        regs.cs = SEL_USER_CODE;
ffffffff81003cbe:	48 c7 83 60 01 00 00 	movq   $0x1b,0x160(%rbx)
ffffffff81003cc5:	1b 00 00 00 
        regs.ds = SEL_USER_DATA;
ffffffff81003cc9:	48 c7 83 40 01 00 00 	movq   $0x23,0x140(%rbx)
ffffffff81003cd0:	23 00 00 00 
        regs.es = SEL_USER_DATA;
ffffffff81003cd4:	48 c7 83 38 01 00 00 	movq   $0x23,0x138(%rbx)
ffffffff81003cdb:	23 00 00 00 
        regs.ss = SEL_USER_DATA;
ffffffff81003cdf:	48 c7 83 78 01 00 00 	movq   $0x23,0x178(%rbx)
ffffffff81003ce6:	23 00 00 00 
        regs.REG(fl) = Cpu::EFL_IF;
ffffffff81003cea:	48 c7 83 68 01 00 00 	movq   $0x200,0x168(%rbx)
ffffffff81003cf1:	00 02 00 00 
        if (glb) { // if global
ffffffff81003cf5:	74 09                	je     ffffffff81003d00 <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x236>
            regs.REG(sp) = s;
ffffffff81003cf7:	4c 89 b3 70 01 00 00 	mov    %r14,0x170(%rbx)
ffffffff81003cfe:	eb 07                	jmp    ffffffff81003d07 <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x23d>

        ALWAYS_INLINE
        inline void set_sp (mword sp) { ARG_SP = sp; }
ffffffff81003d00:	4c 89 b3 c8 00 00 00 	mov    %r14,0xc8(%rbx)
        } else // local thread
            regs.set_sp(s);

        utcb = new (pd->quota) Utcb;
ffffffff81003d07:	48 8b 83 98 02 00 00 	mov    0x298(%rbx),%rax

        ALWAYS_INLINE
        inline Xfer *xfer() { return reinterpret_cast<Xfer *>(this) + PAGE_SIZE / sizeof (Xfer) - 1; }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return Buddy::allocator.alloc (0, quota, Buddy::FILL_0); }
ffffffff81003d0e:	31 f6                	xor    %esi,%esi
ffffffff81003d10:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff81003d15:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff81003d1c:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff81003d23:	e8 ca db ff ff       	callq  ffffffff810018f2 <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
            PIO = 2,
            OBJ = 3,
        };

        ALWAYS_INLINE
        inline explicit Crd() : val (0) {}
ffffffff81003d28:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
ffffffff81003d2f:	00 
ffffffff81003d30:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
ffffffff81003d37:	00 
ffffffff81003d38:	31 c9                	xor    %ecx,%ecx
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
ffffffff81003d3a:	48 8b bb 98 02 00 00 	mov    0x298(%rbx),%rdi
ffffffff81003d41:	6a 00                	pushq  $0x0
ffffffff81003d43:	4c 89 ea             	mov    %r13,%rdx
ffffffff81003d46:	6a 00                	pushq  $0x0
ffffffff81003d48:	48 89 83 90 02 00 00 	mov    %rax,0x290(%rbx)
ffffffff81003d4f:	48 2d 00 00 c0 80    	sub    $0xffffffff80c00000,%rax
ffffffff81003d55:	41 b9 07 00 00 00    	mov    $0x7,%r9d
ffffffff81003d5b:	49 89 c0             	mov    %rax,%r8

        pd->Space_mem::insert(pd->quota, u, 0, Hpt::HPT_U | Hpt::HPT_W | Hpt::HPT_P, Buddy::ptr_to_phys(utcb));
ffffffff81003d5e:	48 8d b7 08 03 00 00 	lea    0x308(%rdi),%rsi
ffffffff81003d65:	48 81 c7 a0 02 00 00 	add    $0x2a0,%rdi
ffffffff81003d6c:	e8 a5 ef 00 00       	callq  ffffffff81012d16 <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb>

        regs.dst_portal = NUM_EXC - 2;

        trace(TRACE_SYSCALL, "EC:%p created (PD:%p CPU:%#x UTCB:%#lx ESP:%lx EVT:%#x)", this, p, c, u, s, e);

        if (pd == &Pd::root)
ffffffff81003d71:	48 81 bb 98 02 00 00 	cmpq   $0xffffffff81163960,0x298(%rbx)
ffffffff81003d78:	60 39 16 81 

        utcb = new (pd->quota) Utcb;

        pd->Space_mem::insert(pd->quota, u, 0, Hpt::HPT_U | Hpt::HPT_W | Hpt::HPT_P, Buddy::ptr_to_phys(utcb));

        regs.dst_portal = NUM_EXC - 2;
ffffffff81003d7c:	48 c7 83 50 01 00 00 	movq   $0x1e,0x150(%rbx)
ffffffff81003d83:	1e 00 00 00 

        trace(TRACE_SYSCALL, "EC:%p created (PD:%p CPU:%#x UTCB:%#lx ESP:%lx EVT:%#x)", this, p, c, u, s, e);

        if (pd == &Pd::root)
ffffffff81003d87:	58                   	pop    %rax
ffffffff81003d88:	5a                   	pop    %rdx
ffffffff81003d89:	0f 85 80 04 00 00    	jne    ffffffff8100420f <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x745>
ffffffff81003d8f:	48 8b 8b 90 02 00 00 	mov    0x290(%rbx),%rcx
            pd->insert_utcb(pd->quota, u, Buddy::ptr_to_phys(utcb) >> 12);
ffffffff81003d96:	4c 89 ea             	mov    %r13,%rdx
ffffffff81003d99:	48 c7 c6 68 3c 16 81 	mov    $0xffffffff81163c68,%rsi
ffffffff81003da0:	48 c7 c7 f0 39 16 81 	mov    $0xffffffff811639f0,%rdi
ffffffff81003da7:	48 81 e9 00 00 c0 80 	sub    $0xffffffff80c00000,%rcx
ffffffff81003dae:	48 c1 e9 0c          	shr    $0xc,%rcx
ffffffff81003db2:	e8 7b 29 01 00       	callq  ffffffff81016732 <_ZN9Space_mem11insert_utcbER5Quotamm>
ffffffff81003db7:	e9 53 04 00 00       	jmpq   ffffffff8100420f <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x745>

    } else { //virtual CPU
        Console::print("...virtual CPU.");
ffffffff81003dbc:	48 c7 c7 62 db 01 81 	mov    $0xffffffff8101db62,%rdi
ffffffff81003dc3:	31 c0                	xor    %eax,%eax
ffffffff81003dc5:	e8 c2 e2 ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>

        utcb = nullptr;

        regs.dst_portal = NUM_VMI - 2;
        regs.vtlb = new (pd->quota) Vtlb;
ffffffff81003dca:	48 8b 83 98 02 00 00 	mov    0x298(%rbx),%rax
            pd->insert_utcb(pd->quota, u, Buddy::ptr_to_phys(utcb) >> 12);

    } else { //virtual CPU
        Console::print("...virtual CPU.");

        utcb = nullptr;
ffffffff81003dd1:	48 c7 83 90 02 00 00 	movq   $0x0,0x290(%rbx)
ffffffff81003dd8:	00 00 00 00 
    bool is_cow_fault(mword virt, mword gpa, Paddr hpa, mword err);
    void update(mword, Paddr, mword);

    ALWAYS_INLINE
    static inline void *operator new (size_t, Quota &quota) {
        return Buddy::allocator.alloc(0, quota, Buddy::NOFILL);
ffffffff81003ddc:	31 c9                	xor    %ecx,%ecx

        regs.dst_portal = NUM_VMI - 2;
ffffffff81003dde:	48 c7 83 50 01 00 00 	movq   $0xfe,0x150(%rbx)
ffffffff81003de5:	fe 00 00 00 
ffffffff81003de9:	31 f6                	xor    %esi,%esi
ffffffff81003deb:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
        regs.vtlb = new (pd->quota) Vtlb;
ffffffff81003df2:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff81003df9:	e8 f4 da ff ff       	callq  ffffffff810018f2 <_ZN5Buddy5allocEtR5QuotaNS_4FillE>

    void free_up(Quota &quota, unsigned l, P *, mword, bool (*) (Paddr, mword, unsigned), bool (*) (unsigned, mword));

public:

    Pte() : val(0) {
ffffffff81003dfe:	31 d2                	xor    %edx,%edx
ffffffff81003e00:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
        GPA_HPA
    };

    ALWAYS_INLINE
    inline Vtlb() {
        for (unsigned i = 0; i < 1UL << bpl(); i++)
ffffffff81003e07:	48 81 fa 00 02 00 00 	cmp    $0x200,%rdx
ffffffff81003e0e:	74 0d                	je     ffffffff81003e1d <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x353>
            this[i].val = TLB_S;
ffffffff81003e10:	48 c7 04 d0 80 00 00 	movq   $0x80,(%rax,%rdx,8)
ffffffff81003e17:	00 
ffffffff81003e18:	48 ff c2             	inc    %rdx
ffffffff81003e1b:	eb ea                	jmp    ffffffff81003e07 <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x33d>
ffffffff81003e1d:	48 89 83 30 01 00 00 	mov    %rax,0x130(%rbx)
    static inline Hip *hip() {
        return reinterpret_cast<Hip *> (&PAGE_H);
    }

    static uint32 feature() {
        return hip()->api_flg;
ffffffff81003e24:	8b 05 e6 31 16 00    	mov    0x1631e6(%rip),%eax        # ffffffff81167010 <PAGE_H+0x10>

        if (Hip::feature() & Hip::FEAT_VMX) {
ffffffff81003e2a:	a8 02                	test   $0x2,%al
ffffffff81003e2c:	0f 84 e2 02 00 00    	je     ffffffff81004114 <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x64a>
ffffffff81003e32:	48 8b bb 98 02 00 00 	mov    0x298(%rbx),%rdi

            regs.vmcs = new (pd->quota) Vmcs(reinterpret_cast<mword> (sys_regs() + 1),
                    pd->Space_pio::walk(pd->quota),
                    pd->loc[c].root(pd->quota),
                    pd->ept.root(pd->quota));
ffffffff81003e39:	31 c9                	xor    %ecx,%ecx
ffffffff81003e3b:	66 31 d2             	xor    %dx,%dx
        regs.vtlb = new (pd->quota) Vtlb;

        if (Hip::feature() & Hip::FEAT_VMX) {

            regs.vmcs = new (pd->quota) Vmcs(reinterpret_cast<mword> (sys_regs() + 1),
                    pd->Space_pio::walk(pd->quota),
ffffffff81003e3e:	48 8d b7 08 03 00 00 	lea    0x308(%rdi),%rsi
ffffffff81003e45:	48 81 c7 d8 02 00 00 	add    $0x2d8,%rdi
                    pd->loc[c].root(pd->quota),
                    pd->ept.root(pd->quota));
ffffffff81003e4c:	e8 fd 2c 01 00       	callq  ffffffff81016b4e <_ZN9Space_pio4walkER5Quotabm>
ffffffff81003e51:	48 89 c5             	mov    %rax,%rbp
ffffffff81003e54:	48 8b 83 98 02 00 00 	mov    0x298(%rbx),%rax
        return L;
    }

    ALWAYS_INLINE
    inline E root(Quota &quota, mword l = L - 1) {
        return Buddy::ptr_to_phys(walk(quota, 0, l));
ffffffff81003e5b:	31 d2                	xor    %edx,%edx
ffffffff81003e5d:	41 b8 01 00 00 00    	mov    $0x1,%r8d
ffffffff81003e63:	b9 03 00 00 00       	mov    $0x3,%ecx

        if (Hip::feature() & Hip::FEAT_VMX) {

            regs.vmcs = new (pd->quota) Vmcs(reinterpret_cast<mword> (sys_regs() + 1),
                    pd->Space_pio::walk(pd->quota),
                    pd->loc[c].root(pd->quota),
ffffffff81003e68:	4a 8d bc e0 a0 00 00 	lea    0xa0(%rax,%r12,8),%rdi
ffffffff81003e6f:	00 
ffffffff81003e70:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff81003e77:	e8 8a eb 00 00       	callq  ffffffff81012a06 <_ZN3PteI3HptmLj4ELj9ELb0EE4walkER5Quotammb>
ffffffff81003e7c:	48 8b bb 98 02 00 00 	mov    0x298(%rbx),%rdi
ffffffff81003e83:	48 2d 00 00 c0 80    	sub    $0xffffffff80c00000,%rax
ffffffff81003e89:	41 b8 01 00 00 00    	mov    $0x1,%r8d
ffffffff81003e8f:	31 d2                	xor    %edx,%edx
ffffffff81003e91:	b9 03 00 00 00       	mov    $0x3,%ecx
ffffffff81003e96:	49 89 c4             	mov    %rax,%r12
                    pd->ept.root(pd->quota));
ffffffff81003e99:	48 8d b7 08 03 00 00 	lea    0x308(%rdi),%rsi
ffffffff81003ea0:	48 81 c7 b0 02 00 00 	add    $0x2b0,%rdi
ffffffff81003ea7:	e8 28 e8 00 00       	callq  ffffffff810126d4 <_ZN3PteI3EptyLj4ELj9ELb0EE4walkER5Quotaymb>
ffffffff81003eac:	48 2d 00 00 c0 80    	sub    $0xffffffff80c00000,%rax
        };

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota)
        {
            return Buddy::allocator.alloc (0, quota, Buddy::FILL_0);
ffffffff81003eb2:	31 f6                	xor    %esi,%esi
ffffffff81003eb4:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff81003eb9:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
ffffffff81003ebe:	48 8b 83 98 02 00 00 	mov    0x298(%rbx),%rax
ffffffff81003ec5:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff81003ecc:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff81003ed3:	e8 1a da ff ff       	callq  ffffffff810018f2 <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
ffffffff81003ed8:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
        regs.dst_portal = NUM_VMI - 2;
        regs.vtlb = new (pd->quota) Vtlb;

        if (Hip::feature() & Hip::FEAT_VMX) {

            regs.vmcs = new (pd->quota) Vmcs(reinterpret_cast<mword> (sys_regs() + 1),
ffffffff81003edd:	48 8d b3 28 01 00 00 	lea    0x128(%rbx),%rsi
                    pd->Space_pio::walk(pd->quota),
                    pd->loc[c].root(pd->quota),
                    pd->ept.root(pd->quota));
ffffffff81003ee4:	4c 89 e1             	mov    %r12,%rcx
ffffffff81003ee7:	48 89 ea             	mov    %rbp,%rdx
ffffffff81003eea:	48 89 c7             	mov    %rax,%rdi
ffffffff81003eed:	49 89 c5             	mov    %rax,%r13
ffffffff81003ef0:	e8 43 84 01 00       	callq  ffffffff8101c338 <_ZN4VmcsC1Emmmy>
        }

        static bool has_secondary() { return ctrl_cpu[0].clr & CPU_SECONDARY; }
        static bool has_ept()       { return ctrl_cpu[1].clr & CPU_EPT; }
        static bool has_vpid()      { return ctrl_cpu[1].clr & CPU_VPID; }
        static bool has_urg()       { return ctrl_cpu[1].clr & CPU_URG; }
ffffffff81003ef5:	8b 35 71 bf ff 3e    	mov    0x3effbf71(%rip),%esi        # ffffffffbffffe6c <_ZN4Vmcs8ctrl_cpuE+0xc>

            regs.nst_ctrl<Vmcs>();
ffffffff81003efb:	48 8d bb a8 00 00 00 	lea    0xa8(%rbx),%rdi
        if (Hip::feature() & Hip::FEAT_VMX) {

            regs.vmcs = new (pd->quota) Vmcs(reinterpret_cast<mword> (sys_regs() + 1),
                    pd->Space_pio::walk(pd->quota),
                    pd->loc[c].root(pd->quota),
                    pd->ept.root(pd->quota));
ffffffff81003f02:	4c 89 ab 28 01 00 00 	mov    %r13,0x128(%rbx)
ffffffff81003f09:	c1 ee 07             	shr    $0x7,%esi
ffffffff81003f0c:	83 e6 01             	and    $0x1,%esi

            regs.nst_ctrl<Vmcs>();
ffffffff81003f0f:	e8 fa f6 00 00       	callq  ffffffff8101360e <_ZN8Exc_regs8nst_ctrlI4VmcsEEvb>

            /* allocate and register the host MSR area */
            mword host_msr_area_phys = Buddy::ptr_to_phys(new (pd->quota) Msr_area);
ffffffff81003f14:	48 8b 83 98 02 00 00 	mov    0x298(%rbx),%rax

    ALWAYS_INLINE
    static inline void *operator new (size_t, Quota &quota)
    {
        /* allocate one page */
        return Buddy::allocator.alloc (0, quota, Buddy::FILL_0);
ffffffff81003f1b:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff81003f20:	31 f6                	xor    %esi,%esi
ffffffff81003f22:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff81003f29:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff81003f30:	e8 bd d9 ff ff       	callq  ffffffff810018f2 <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
ffffffff81003f35:	ba 08 20 00 00       	mov    $0x2008,%edx
    uint32 msr_index;
    uint32 reserved;
    uint64 msr_data;

    Msr_entry(uint32 index)
    : msr_index(index), reserved(0), msr_data(0) { }
ffffffff81003f3a:	c7 00 81 00 00 c0    	movl   $0xc0000081,(%rax)
ffffffff81003f40:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
ffffffff81003f47:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
ffffffff81003f4e:	00 
ffffffff81003f4f:	c7 40 10 82 00 00 c0 	movl   $0xc0000082,0x10(%rax)
ffffffff81003f56:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%rax)
ffffffff81003f5d:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
ffffffff81003f64:	00 
ffffffff81003f65:	c7 40 20 84 00 00 c0 	movl   $0xc0000084,0x20(%rax)
ffffffff81003f6c:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%rax)
ffffffff81003f73:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
ffffffff81003f7a:	00 
ffffffff81003f7b:	c7 40 30 02 01 00 c0 	movl   $0xc0000102,0x30(%rax)
ffffffff81003f82:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%rax)
ffffffff81003f89:	48 c7 40 38 00 00 00 	movq   $0x0,0x38(%rax)
ffffffff81003f90:	00 
ffffffff81003f91:	48 2d 00 00 c0 80    	sub    $0xffffffff80c00000,%rax
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
ffffffff81003f97:	0f 79 d0             	vmwrite %rax,%rdx
ffffffff81003f9a:	bd 04 00 00 00       	mov    $0x4,%ebp
ffffffff81003f9f:	b8 10 40 00 00       	mov    $0x4010,%eax
ffffffff81003fa4:	0f 79 c5             	vmwrite %rbp,%rax
            Vmcs::write(Vmcs::EXI_MSR_LD_ADDR, host_msr_area_phys);
            Vmcs::write(Vmcs::EXI_MSR_LD_CNT, Msr_area::MSR_COUNT);

            /* allocate and register the guest MSR area */
            mword guest_msr_area_phys = Buddy::ptr_to_phys(new (pd->quota) Msr_area);
ffffffff81003fa7:	48 8b 83 98 02 00 00 	mov    0x298(%rbx),%rax

    ALWAYS_INLINE
    static inline void *operator new (size_t, Quota &quota)
    {
        /* allocate one page */
        return Buddy::allocator.alloc (0, quota, Buddy::FILL_0);
ffffffff81003fae:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff81003fb3:	31 f6                	xor    %esi,%esi
ffffffff81003fb5:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff81003fbc:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff81003fc3:	e8 2a d9 ff ff       	callq  ffffffff810018f2 <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
ffffffff81003fc8:	ba 0a 20 00 00       	mov    $0x200a,%edx
    uint32 msr_index;
    uint32 reserved;
    uint64 msr_data;

    Msr_entry(uint32 index)
    : msr_index(index), reserved(0), msr_data(0) { }
ffffffff81003fcd:	c7 00 81 00 00 c0    	movl   $0xc0000081,(%rax)
ffffffff81003fd3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
ffffffff81003fda:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
ffffffff81003fe1:	00 
ffffffff81003fe2:	c7 40 10 82 00 00 c0 	movl   $0xc0000082,0x10(%rax)
ffffffff81003fe9:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%rax)
ffffffff81003ff0:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
ffffffff81003ff7:	00 
ffffffff81003ff8:	c7 40 20 84 00 00 c0 	movl   $0xc0000084,0x20(%rax)
ffffffff81003fff:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%rax)
ffffffff81004006:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
ffffffff8100400d:	00 
ffffffff8100400e:	c7 40 30 02 01 00 c0 	movl   $0xc0000102,0x30(%rax)
ffffffff81004015:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%rax)
ffffffff8100401c:	48 c7 40 38 00 00 00 	movq   $0x0,0x38(%rax)
ffffffff81004023:	00 
ffffffff81004024:	48 2d 00 00 c0 80    	sub    $0xffffffff80c00000,%rax
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
ffffffff8100402a:	0f 79 d0             	vmwrite %rax,%rdx
ffffffff8100402d:	66 ba 14 40          	mov    $0x4014,%dx
ffffffff81004031:	0f 79 d5             	vmwrite %rbp,%rdx
ffffffff81004034:	66 ba 06 20          	mov    $0x2006,%dx
ffffffff81004038:	0f 79 d0             	vmwrite %rax,%rdx
ffffffff8100403b:	b8 0e 40 00 00       	mov    $0x400e,%eax
ffffffff81004040:	0f 79 c5             	vmwrite %rbp,%rax
            Vmcs::write(Vmcs::ENT_MSR_LD_CNT, Msr_area::MSR_COUNT);
            Vmcs::write(Vmcs::EXI_MSR_ST_ADDR, guest_msr_area_phys);
            Vmcs::write(Vmcs::EXI_MSR_ST_CNT, Msr_area::MSR_COUNT);

            /* allocate and register the virtual APIC page */
            mword virtual_apic_page_phys = Buddy::ptr_to_phys(new (pd->quota) Virtual_apic_page);
ffffffff81004043:	48 8b 83 98 02 00 00 	mov    0x298(%rbx),%rax

    ALWAYS_INLINE
    static inline void *operator new (size_t, Quota &quota)
    {
        /* allocate one page */
        return Buddy::allocator.alloc (0, quota, Buddy::FILL_0);
ffffffff8100404a:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff8100404f:	31 f6                	xor    %esi,%esi
ffffffff81004051:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff81004058:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff8100405f:	e8 8e d8 ff ff       	callq  ffffffff810018f2 <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
ffffffff81004064:	ba 12 20 00 00       	mov    $0x2012,%edx
ffffffff81004069:	48 2d 00 00 c0 80    	sub    $0xffffffff80c00000,%rax
ffffffff8100406f:	0f 79 d0             	vmwrite %rax,%rdx
            Vmcs::write(Vmcs::APIC_VIRT_ADDR, virtual_apic_page_phys);
            vmcs_backup = regs.vmcs->clone();
ffffffff81004072:	48 8b bb 28 01 00 00 	mov    0x128(%rbx),%rdi
ffffffff81004079:	e8 6c 87 01 00       	callq  ffffffff8101c7ea <_ZN4Vmcs5cloneEv>
            vmcs1 = regs.vmcs->clone();
ffffffff8100407e:	48 8b bb 28 01 00 00 	mov    0x128(%rbx),%rdi
            Vmcs::write(Vmcs::EXI_MSR_ST_CNT, Msr_area::MSR_COUNT);

            /* allocate and register the virtual APIC page */
            mword virtual_apic_page_phys = Buddy::ptr_to_phys(new (pd->quota) Virtual_apic_page);
            Vmcs::write(Vmcs::APIC_VIRT_ADDR, virtual_apic_page_phys);
            vmcs_backup = regs.vmcs->clone();
ffffffff81004085:	48 89 83 d8 02 00 00 	mov    %rax,0x2d8(%rbx)
            vmcs1 = regs.vmcs->clone();
ffffffff8100408c:	e8 59 87 01 00       	callq  ffffffff8101c7ea <_ZN4Vmcs5cloneEv>
            vmcs2 = regs.vmcs->clone();
ffffffff81004091:	48 8b bb 28 01 00 00 	mov    0x128(%rbx),%rdi

            /* allocate and register the virtual APIC page */
            mword virtual_apic_page_phys = Buddy::ptr_to_phys(new (pd->quota) Virtual_apic_page);
            Vmcs::write(Vmcs::APIC_VIRT_ADDR, virtual_apic_page_phys);
            vmcs_backup = regs.vmcs->clone();
            vmcs1 = regs.vmcs->clone();
ffffffff81004098:	48 89 83 e0 02 00 00 	mov    %rax,0x2e0(%rbx)
            vmcs2 = regs.vmcs->clone();
ffffffff8100409f:	e8 46 87 01 00       	callq  ffffffff8101c7ea <_ZN4Vmcs5cloneEv>
ffffffff810040a4:	48 89 83 e8 02 00 00 	mov    %rax,0x2e8(%rbx)
            
            regs.vmcs->clear();
ffffffff810040ab:	48 8b 83 28 01 00 00 	mov    0x128(%rbx),%rax
        }

        ALWAYS_INLINE
        inline void clear()
        {
            if (EXPECT_TRUE (current == this))
ffffffff810040b2:	48 39 05 67 af ff 3e 	cmp    %rax,0x3effaf67(%rip)        # ffffffffbffff020 <_ZN4Vmcs7currentE>
ffffffff810040b9:	75 0b                	jne    ffffffff810040c6 <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x5fc>
                current = nullptr;
ffffffff810040bb:	48 c7 05 5a af ff 3e 	movq   $0x0,0x3effaf5a(%rip)        # ffffffffbffff020 <_ZN4Vmcs7currentE>
ffffffff810040c2:	00 00 00 00 
ffffffff810040c6:	48 2d 00 00 c0 80    	sub    $0xffffffff80c00000,%rax
ffffffff810040cc:	48 89 44 24 18       	mov    %rax,0x18(%rsp)

            uint64 phys = Buddy::ptr_to_phys (this);

            bool ret;
            asm volatile ("vmclear %1; seta %0" : "=q" (ret) : "m" (phys) : "cc");
ffffffff810040d1:	66 0f c7 74 24 18    	vmclear 0x18(%rsp)
ffffffff810040d7:	0f 97 c0             	seta   %al
            assert (ret);
ffffffff810040da:	84 c0                	test   %al,%al
ffffffff810040dc:	75 26                	jne    ffffffff81004104 <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x63a>
ffffffff810040de:	49 c7 c0 e0 e0 01 81 	mov    $0xffffffff8101e0e0,%r8
ffffffff810040e5:	b9 8b 01 00 00       	mov    $0x18b,%ecx
ffffffff810040ea:	48 c7 c2 72 db 01 81 	mov    $0xffffffff8101db72,%rdx
ffffffff810040f1:	48 c7 c6 e1 db 01 81 	mov    $0xffffffff8101dbe1,%rsi
ffffffff810040f8:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff810040ff:	e8 4c de ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
            cont = send_msg<ret_user_vmresume>;
ffffffff81004104:	48 c7 83 a0 00 00 00 	movq   $0xffffffff8101766e,0xa0(%rbx)
ffffffff8100410b:	6e 76 01 81 
ffffffff8100410f:	e9 fb 00 00 00       	jmpq   ffffffff8100420f <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x745>
            trace(TRACE_SYSCALL, "EC:%p created (PD:%p VMCS:%p VTLB:%p)", this, p, regs.vmcs, regs.vtlb);

        } else if (Hip::feature() & Hip::FEAT_SVM) {
ffffffff81004114:	a8 04                	test   $0x4,%al
ffffffff81004116:	0f 84 f3 00 00 00    	je     ffffffff8100420f <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt+0x745>
ffffffff8100411c:	48 8b bb 98 02 00 00 	mov    0x298(%rbx),%rdi

            regs.REG(ax) = Buddy::ptr_to_phys(regs.vmcb = new (pd->quota) Vmcb(pd->quota, pd->Space_pio::walk(pd->quota), pd->npt.root(pd->quota)));
ffffffff81004123:	31 c9                	xor    %ecx,%ecx
ffffffff81004125:	31 d2                	xor    %edx,%edx
ffffffff81004127:	4c 8d b7 08 03 00 00 	lea    0x308(%rdi),%r14
ffffffff8100412e:	48 81 c7 d8 02 00 00 	add    $0x2d8,%rdi
ffffffff81004135:	4c 89 f6             	mov    %r14,%rsi
ffffffff81004138:	e8 11 2a 01 00       	callq  ffffffff81016b4e <_ZN9Space_pio4walkER5Quotabm>
ffffffff8100413d:	48 8b bb 98 02 00 00 	mov    0x298(%rbx),%rdi
ffffffff81004144:	41 b8 01 00 00 00    	mov    $0x1,%r8d
ffffffff8100414a:	b9 03 00 00 00       	mov    $0x3,%ecx
ffffffff8100414f:	31 d2                	xor    %edx,%edx
ffffffff81004151:	49 89 c5             	mov    %rax,%r13
ffffffff81004154:	48 8d b7 08 03 00 00 	lea    0x308(%rdi),%rsi
ffffffff8100415b:	48 81 c7 b0 02 00 00 	add    $0x2b0,%rdi
ffffffff81004162:	e8 9f e8 00 00       	callq  ffffffff81012a06 <_ZN3PteI3HptmLj4ELj9ELb0EE4walkER5Quotammb>
ffffffff81004167:	48 2d 00 00 c0 80    	sub    $0xffffffff80c00000,%rax
            CPU_CLGI |
            CPU_SKINIT;

    ALWAYS_INLINE
    static inline void *operator new (size_t, Quota &quota) {
        return Buddy::allocator.alloc(0, quota, Buddy::FILL_0);
ffffffff8100416d:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff81004172:	31 f6                	xor    %esi,%esi
ffffffff81004174:	49 89 c4             	mov    %rax,%r12
ffffffff81004177:	48 8b 83 98 02 00 00 	mov    0x298(%rbx),%rax
ffffffff8100417e:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff81004185:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff8100418c:	e8 61 d7 ff ff       	callq  ffffffff810018f2 <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
ffffffff81004191:	4c 89 e1             	mov    %r12,%rcx
ffffffff81004194:	48 89 c5             	mov    %rax,%rbp
ffffffff81004197:	4c 89 ea             	mov    %r13,%rdx
ffffffff8100419a:	48 89 c7             	mov    %rax,%rdi
ffffffff8100419d:	4c 89 f6             	mov    %r14,%rsi
ffffffff810041a0:	e8 25 2d 01 00       	callq  ffffffff81016eca <_ZN4VmcbC1ER5Quotamm>
ffffffff810041a5:	48 89 ab 28 01 00 00 	mov    %rbp,0x128(%rbx)

            regs.nst_ctrl<Vmcb>();
ffffffff810041ac:	48 8d bb a8 00 00 00 	lea    0xa8(%rbx),%rdi
ffffffff810041b3:	48 81 ed 00 00 c0 80 	sub    $0xffffffff80c00000,%rbp
ffffffff810041ba:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff810041bf:	48 89 ab 20 01 00 00 	mov    %rbp,0x120(%rbx)
ffffffff810041c6:	e8 49 f2 00 00       	callq  ffffffff81013414 <_ZN8Exc_regs8nst_ctrlI4VmcbEEvb>
            vmcb_backup = regs.vmcb->clone();
ffffffff810041cb:	48 8b bb 28 01 00 00 	mov    0x128(%rbx),%rdi
ffffffff810041d2:	e8 5d 2d 01 00       	callq  ffffffff81016f34 <_ZN4Vmcb5cloneEv>
            vmcb1 = regs.vmcb->clone();
ffffffff810041d7:	48 8b bb 28 01 00 00 	mov    0x128(%rbx),%rdi
        } else if (Hip::feature() & Hip::FEAT_SVM) {

            regs.REG(ax) = Buddy::ptr_to_phys(regs.vmcb = new (pd->quota) Vmcb(pd->quota, pd->Space_pio::walk(pd->quota), pd->npt.root(pd->quota)));

            regs.nst_ctrl<Vmcb>();
            vmcb_backup = regs.vmcb->clone();
ffffffff810041de:	48 89 83 c0 02 00 00 	mov    %rax,0x2c0(%rbx)
            vmcb1 = regs.vmcb->clone();
ffffffff810041e5:	e8 4a 2d 01 00       	callq  ffffffff81016f34 <_ZN4Vmcb5cloneEv>
            vmcb2 = regs.vmcb->clone();
ffffffff810041ea:	48 8b bb 28 01 00 00 	mov    0x128(%rbx),%rdi

            regs.REG(ax) = Buddy::ptr_to_phys(regs.vmcb = new (pd->quota) Vmcb(pd->quota, pd->Space_pio::walk(pd->quota), pd->npt.root(pd->quota)));

            regs.nst_ctrl<Vmcb>();
            vmcb_backup = regs.vmcb->clone();
            vmcb1 = regs.vmcb->clone();
ffffffff810041f1:	48 89 83 c8 02 00 00 	mov    %rax,0x2c8(%rbx)
            vmcb2 = regs.vmcb->clone();
ffffffff810041f8:	e8 37 2d 01 00       	callq  ffffffff81016f34 <_ZN4Vmcb5cloneEv>
            cont = send_msg<ret_user_vmrun>;
ffffffff810041fd:	48 c7 83 a0 00 00 00 	movq   $0xffffffff81017958,0xa0(%rbx)
ffffffff81004204:	58 79 01 81 
            regs.REG(ax) = Buddy::ptr_to_phys(regs.vmcb = new (pd->quota) Vmcb(pd->quota, pd->Space_pio::walk(pd->quota), pd->npt.root(pd->quota)));

            regs.nst_ctrl<Vmcb>();
            vmcb_backup = regs.vmcb->clone();
            vmcb1 = regs.vmcb->clone();
            vmcb2 = regs.vmcb->clone();
ffffffff81004208:	48 89 83 d0 02 00 00 	mov    %rax,0x2d0(%rbx)
            cont = send_msg<ret_user_vmrun>;
            trace(TRACE_SYSCALL, "EC:%p created (PD:%p VMCB:%p VTLB:%p)", this, p, regs.vmcb, regs.vtlb);
        }
    }
}
ffffffff8100420f:	48 83 c4 28          	add    $0x28,%rsp
ffffffff81004213:	5b                   	pop    %rbx
ffffffff81004214:	5d                   	pop    %rbp
ffffffff81004215:	41 5c                	pop    %r12
ffffffff81004217:	41 5d                	pop    %r13
ffffffff81004219:	41 5e                	pop    %r14
ffffffff8100421b:	41 5f                	pop    %r15
ffffffff8100421d:	c3                   	retq   

ffffffff8100421e <_ZN2EcC1EP2PdS1_PFvvEjPS_>:

Ec::Ec(Pd *own, Pd *p, void (*f)(), unsigned c, Ec *clone) : Kobject(EC, static_cast<Space_obj *> (own), 0, 0xd, free, pre_free), cont(f), regs(clone->regs), rcap(clone), utcb(clone->utcb), pd(p), partner(nullptr), prev(nullptr), next(nullptr), fpu(clone->fpu), cpu(static_cast<uint16> (c)), glb(!!f), evt(clone->evt), timeout(this), user_utcb(0), xcpu_sm(clone->xcpu_sm), pt_oom(clone->pt_oom) {
ffffffff8100421e:	48 8d 86 f8 02 00 00 	lea    0x2f8(%rsi),%rax
ffffffff81004225:	48 85 f6             	test   %rsi,%rsi
ffffffff81004228:	be 00 00 00 00       	mov    $0x0,%esi
ffffffff8100422d:	41 56                	push   %r14
ffffffff8100422f:	41 55                	push   %r13
ffffffff81004231:	49 89 ce             	mov    %rcx,%r14
ffffffff81004234:	41 54                	push   %r12
ffffffff81004236:	48 0f 45 f0          	cmovne %rax,%rsi
ffffffff8100423a:	55                   	push   %rbp
ffffffff8100423b:	53                   	push   %rbx
ffffffff8100423c:	50                   	push   %rax
ffffffff8100423d:	48 89 fb             	mov    %rdi,%rbx
ffffffff81004240:	68 af 34 00 81       	pushq  $0xffffffff810034af
ffffffff81004245:	4d 89 cc             	mov    %r9,%r12
ffffffff81004248:	31 c9                	xor    %ecx,%ecx
ffffffff8100424a:	48 89 d5             	mov    %rdx,%rbp
ffffffff8100424d:	45 89 c5             	mov    %r8d,%r13d
ffffffff81004250:	48 89 fa             	mov    %rdi,%rdx
ffffffff81004253:	49 c7 c1 4e 47 00 81 	mov    $0xffffffff8100474e,%r9
ffffffff8100425a:	41 b8 0d 00 00 00    	mov    $0xd,%r8d
ffffffff81004260:	e8 47 f6 ff ff       	callq  ffffffff810038ac <_ZN3MdbC1EP5SpacemmmPFvP8Rcu_elemES5_>
ffffffff81004265:	c6 83 88 00 00 00 01 	movb   $0x1,0x88(%rbx)
ffffffff8100426c:	66 c7 83 8a 00 00 00 	movw   $0x0,0x8a(%rbx)
ffffffff81004273:	00 00 
ffffffff81004275:	48 8d bb a8 00 00 00 	lea    0xa8(%rbx),%rdi
    private:
        uint32 ref;

    public:
        ALWAYS_INLINE
        inline Refex() : ref (1) {}
ffffffff8100427c:	c7 83 8c 00 00 00 01 	movl   $0x1,0x8c(%rbx)
ffffffff81004283:	00 00 00 
ffffffff81004286:	48 c7 83 90 00 00 00 	movq   $0x0,0x90(%rbx)
ffffffff8100428d:	00 00 00 00 
ffffffff81004291:	49 8d b4 24 a8 00 00 	lea    0xa8(%r12),%rsi
ffffffff81004298:	00 
ffffffff81004299:	4c 89 b3 a0 00 00 00 	mov    %r14,0xa0(%rbx)
ffffffff810042a0:	b9 3c 00 00 00       	mov    $0x3c,%ecx
ffffffff810042a5:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
ffffffff810042a7:	4c 89 a3 88 02 00 00 	mov    %r12,0x288(%rbx)
ffffffff810042ae:	5a                   	pop    %rdx
ffffffff810042af:	49 8b 84 24 90 02 00 	mov    0x290(%r12),%rax
ffffffff810042b6:	00 
ffffffff810042b7:	59                   	pop    %rcx
ffffffff810042b8:	48 89 83 90 02 00 00 	mov    %rax,0x290(%rbx)

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff810042bf:	8b 85 8c 00 00 00    	mov    0x8c(%rbp),%eax
ffffffff810042c5:	85 c0                	test   %eax,%eax
ffffffff810042c7:	74 0f                	je     ffffffff810042d8 <_ZN2EcC1EP2PdS1_PFvvEjPS_+0xba>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff810042c9:	8d 50 01             	lea    0x1(%rax),%edx
ffffffff810042cc:	f0 0f b1 95 8c 00 00 	lock cmpxchg %edx,0x8c(%rbp)
ffffffff810042d3:	00 
ffffffff810042d4:	75 e9                	jne    ffffffff810042bf <_ZN2EcC1EP2PdS1_PFvvEjPS_+0xa1>
ffffffff810042d6:	eb 02                	jmp    ffffffff810042da <_ZN2EcC1EP2PdS1_PFvvEjPS_+0xbc>
    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }

        ALWAYS_INLINE
        inline Refptr (T *p) : ptr (p->add_ref() ? p : nullptr) {}
ffffffff810042d8:	31 ed                	xor    %ebp,%ebp
ffffffff810042da:	48 89 ab 98 02 00 00 	mov    %rbp,0x298(%rbx)
ffffffff810042e1:	48 c7 83 a0 02 00 00 	movq   $0x0,0x2a0(%rbx)
ffffffff810042e8:	00 00 00 00 
    // Make sure we have a PTAB for this CPU in the PD
    pd->Space_mem::init(pd->quota, c);
ffffffff810042ec:	48 8d b5 08 03 00 00 	lea    0x308(%rbp),%rsi
            trace(TRACE_SYSCALL, "EC:%p created (PD:%p VMCB:%p VTLB:%p)", this, p, regs.vmcb, regs.vtlb);
        }
    }
}

Ec::Ec(Pd *own, Pd *p, void (*f)(), unsigned c, Ec *clone) : Kobject(EC, static_cast<Space_obj *> (own), 0, 0xd, free, pre_free), cont(f), regs(clone->regs), rcap(clone), utcb(clone->utcb), pd(p), partner(nullptr), prev(nullptr), next(nullptr), fpu(clone->fpu), cpu(static_cast<uint16> (c)), glb(!!f), evt(clone->evt), timeout(this), user_utcb(0), xcpu_sm(clone->xcpu_sm), pt_oom(clone->pt_oom) {
ffffffff810042f3:	48 c7 83 a8 02 00 00 	movq   $0x0,0x2a8(%rbx)
ffffffff810042fa:	00 00 00 00 
ffffffff810042fe:	48 c7 83 b0 02 00 00 	movq   $0x0,0x2b0(%rbx)
ffffffff81004305:	00 00 00 00 
    // Make sure we have a PTAB for this CPU in the PD
    pd->Space_mem::init(pd->quota, c);
ffffffff81004309:	48 8d bd 90 00 00 00 	lea    0x90(%rbp),%rdi
            trace(TRACE_SYSCALL, "EC:%p created (PD:%p VMCB:%p VTLB:%p)", this, p, regs.vmcb, regs.vtlb);
        }
    }
}

Ec::Ec(Pd *own, Pd *p, void (*f)(), unsigned c, Ec *clone) : Kobject(EC, static_cast<Space_obj *> (own), 0, 0xd, free, pre_free), cont(f), regs(clone->regs), rcap(clone), utcb(clone->utcb), pd(p), partner(nullptr), prev(nullptr), next(nullptr), fpu(clone->fpu), cpu(static_cast<uint16> (c)), glb(!!f), evt(clone->evt), timeout(this), user_utcb(0), xcpu_sm(clone->xcpu_sm), pt_oom(clone->pt_oom) {
ffffffff81004310:	49 8b 84 24 b8 02 00 	mov    0x2b8(%r12),%rax
ffffffff81004317:	00 
ffffffff81004318:	66 44 89 ab f0 02 00 	mov    %r13w,0x2f0(%rbx)
ffffffff8100431f:	00 
    // Make sure we have a PTAB for this CPU in the PD
    pd->Space_mem::init(pd->quota, c);
ffffffff81004320:	44 89 ea             	mov    %r13d,%edx
            trace(TRACE_SYSCALL, "EC:%p created (PD:%p VMCB:%p VTLB:%p)", this, p, regs.vmcb, regs.vtlb);
        }
    }
}

Ec::Ec(Pd *own, Pd *p, void (*f)(), unsigned c, Ec *clone) : Kobject(EC, static_cast<Space_obj *> (own), 0, 0xd, free, pre_free), cont(f), regs(clone->regs), rcap(clone), utcb(clone->utcb), pd(p), partner(nullptr), prev(nullptr), next(nullptr), fpu(clone->fpu), cpu(static_cast<uint16> (c)), glb(!!f), evt(clone->evt), timeout(this), user_utcb(0), xcpu_sm(clone->xcpu_sm), pt_oom(clone->pt_oom) {
ffffffff81004323:	48 89 83 b8 02 00 00 	mov    %rax,0x2b8(%rbx)
ffffffff8100432a:	31 c0                	xor    %eax,%eax
ffffffff8100432c:	4d 85 f6             	test   %r14,%r14
ffffffff8100432f:	0f 95 c0             	setne  %al
ffffffff81004332:	66 89 83 f2 02 00 00 	mov    %ax,0x2f2(%rbx)
ffffffff81004339:	41 8b 84 24 f4 02 00 	mov    0x2f4(%r12),%eax
ffffffff81004340:	00 
ffffffff81004341:	48 c7 83 00 03 00 00 	movq   $0x0,0x300(%rbx)
ffffffff81004348:	00 00 00 00 
ffffffff8100434c:	48 c7 83 08 03 00 00 	movq   $0x0,0x308(%rbx)
ffffffff81004353:	00 00 00 00 
ffffffff81004357:	48 c7 83 10 03 00 00 	movq   $0x0,0x310(%rbx)
ffffffff8100435e:	00 00 00 00 
ffffffff81004362:	48 c7 83 f8 02 00 00 	movq   $0xffffffff81021450,0x2f8(%rbx)
ffffffff81004369:	50 14 02 81 
ffffffff8100436d:	89 83 f4 02 00 00    	mov    %eax,0x2f4(%rbx)
ffffffff81004373:	48 89 9b 18 03 00 00 	mov    %rbx,0x318(%rbx)
ffffffff8100437a:	48 c7 83 28 03 00 00 	movq   $0x0,0x328(%rbx)
ffffffff81004381:	00 00 00 00 
ffffffff81004385:	49 8b 84 24 30 03 00 	mov    0x330(%r12),%rax
ffffffff8100438c:	00 
ffffffff8100438d:	48 89 83 30 03 00 00 	mov    %rax,0x330(%rbx)
ffffffff81004394:	49 8b 84 24 38 03 00 	mov    0x338(%r12),%rax
ffffffff8100439b:	00 
ffffffff8100439c:	48 c7 83 40 03 00 00 	movq   $0x0,0x340(%rbx)
ffffffff810043a3:	00 00 00 00 
ffffffff810043a7:	66 c7 83 48 03 00 00 	movw   $0x0,0x348(%rbx)
ffffffff810043ae:	00 00 
ffffffff810043b0:	c6 83 4a 03 00 00 00 	movb   $0x0,0x34a(%rbx)
ffffffff810043b7:	c7 83 4c 03 00 00 00 	movl   $0x0,0x34c(%rbx)
ffffffff810043be:	00 00 00 
ffffffff810043c1:	48 89 83 38 03 00 00 	mov    %rax,0x338(%rbx)
ffffffff810043c8:	c6 83 50 03 00 00 00 	movb   $0x0,0x350(%rbx)
ffffffff810043cf:	c6 83 51 03 00 00 00 	movb   $0x0,0x351(%rbx)
ffffffff810043d6:	c7 83 54 03 00 00 00 	movl   $0x0,0x354(%rbx)
ffffffff810043dd:	00 00 00 
ffffffff810043e0:	c7 83 58 03 00 00 00 	movl   $0x0,0x358(%rbx)
ffffffff810043e7:	00 00 00 
ffffffff810043ea:	c7 83 5c 03 00 00 00 	movl   $0x0,0x35c(%rbx)
ffffffff810043f1:	00 00 00 
    // Make sure we have a PTAB for this CPU in the PD
    pd->Space_mem::init(pd->quota, c);
ffffffff810043f4:	e8 57 1c 01 00       	callq  ffffffff81016050 <_ZN9Space_mem4initER5Quotaj>

    regs.vtlb = nullptr;
    regs.vmcs = nullptr;
    regs.vmcb = nullptr;

    if (pt_oom)
ffffffff810043f9:	48 8b 93 38 03 00 00 	mov    0x338(%rbx),%rdx

Ec::Ec(Pd *own, Pd *p, void (*f)(), unsigned c, Ec *clone) : Kobject(EC, static_cast<Space_obj *> (own), 0, 0xd, free, pre_free), cont(f), regs(clone->regs), rcap(clone), utcb(clone->utcb), pd(p), partner(nullptr), prev(nullptr), next(nullptr), fpu(clone->fpu), cpu(static_cast<uint16> (c)), glb(!!f), evt(clone->evt), timeout(this), user_utcb(0), xcpu_sm(clone->xcpu_sm), pt_oom(clone->pt_oom) {
    // Make sure we have a PTAB for this CPU in the PD
    pd->Space_mem::init(pd->quota, c);

    regs.vtlb = nullptr;
ffffffff81004400:	48 c7 83 30 01 00 00 	movq   $0x0,0x130(%rbx)
ffffffff81004407:	00 00 00 00 
    regs.vmcs = nullptr;
ffffffff8100440b:	48 c7 83 28 01 00 00 	movq   $0x0,0x128(%rbx)
ffffffff81004412:	00 00 00 00 
    regs.vmcb = nullptr;

    if (pt_oom)
ffffffff81004416:	48 85 d2             	test   %rdx,%rdx

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff81004419:	74 17                	je     ffffffff81004432 <_ZN2EcC1EP2PdS1_PFvvEjPS_+0x214>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100441b:	8b 82 8c 00 00 00    	mov    0x8c(%rdx),%eax
ffffffff81004421:	85 c0                	test   %eax,%eax
ffffffff81004423:	74 0d                	je     ffffffff81004432 <_ZN2EcC1EP2PdS1_PFvvEjPS_+0x214>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff81004425:	8d 48 01             	lea    0x1(%rax),%ecx
ffffffff81004428:	f0 0f b1 8a 8c 00 00 	lock cmpxchg %ecx,0x8c(%rdx)
ffffffff8100442f:	00 
ffffffff81004430:	eb e7                	jmp    ffffffff81004419 <_ZN2EcC1EP2PdS1_PFvvEjPS_+0x1fb>
        pt_oom->add_ref();
}
ffffffff81004432:	5b                   	pop    %rbx
ffffffff81004433:	5d                   	pop    %rbp
ffffffff81004434:	41 5c                	pop    %r12
ffffffff81004436:	41 5d                	pop    %r13
ffffffff81004438:	41 5e                	pop    %r14
ffffffff8100443a:	c3                   	retq   
ffffffff8100443b:	90                   	nop

ffffffff8100443c <_ZN2EcD1Ev>:

//De-constructor

Ec::~Ec() {
ffffffff8100443c:	41 54                	push   %r12
ffffffff8100443e:	55                   	push   %rbp
ffffffff8100443f:	53                   	push   %rbx
ffffffff81004440:	48 89 fb             	mov    %rdi,%rbx
    pre_free(this);
ffffffff81004443:	48 8d 7f 18          	lea    0x18(%rdi),%rdi
        pt_oom->add_ref();
}

//De-constructor

Ec::~Ec() {
ffffffff81004447:	48 83 ec 10          	sub    $0x10,%rsp
    pre_free(this);
ffffffff8100444b:	e8 5f f0 ff ff       	callq  ffffffff810034af <_ZN2Ec8pre_freeEP8Rcu_elem>

    if (pt_oom && pt_oom->del_ref())
ffffffff81004450:	48 8b 83 38 03 00 00 	mov    0x338(%rbx),%rax
ffffffff81004457:	48 85 c0             	test   %rax,%rax
ffffffff8100445a:	74 55                	je     ffffffff810044b1 <_ZN2EcD1Ev+0x75>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff8100445c:	83 ca ff             	or     $0xffffffff,%edx
ffffffff8100445f:	f0 0f c1 90 8c 00 00 	lock xadd %edx,0x8c(%rax)
ffffffff81004466:	00 
ffffffff81004467:	ff ca                	dec    %edx
ffffffff81004469:	75 46                	jne    ffffffff810044b1 <_ZN2EcD1Ev+0x75>
        Pt::destroy(pt_oom, pd->quota);
ffffffff8100446b:	48 8b 83 98 02 00 00 	mov    0x298(%rbx),%rax
ffffffff81004472:	48 8b ab 38 03 00 00 	mov    0x338(%rbx),%rbp
ffffffff81004479:	4c 8d a0 08 03 00 00 	lea    0x308(%rax),%r12
        inline Refptr (T *p) : ptr (p->add_ref() ? p : nullptr) {}

        ALWAYS_INLINE
        inline ~Refptr()
        {
            if (ptr && ptr->del_ref())
ffffffff81004480:	48 8b 85 90 00 00 00 	mov    0x90(%rbp),%rax
ffffffff81004487:	48 85 c0             	test   %rax,%rax
ffffffff8100448a:	74 13                	je     ffffffff8100449f <_ZN2EcD1Ev+0x63>
ffffffff8100448c:	83 ca ff             	or     $0xffffffff,%edx
ffffffff8100448f:	f0 0f c1 90 8c 00 00 	lock xadd %edx,0x8c(%rax)
ffffffff81004496:	00 
ffffffff81004497:	ff ca                	dec    %edx
ffffffff81004499:	0f 84 17 02 00 00    	je     ffffffff810046b6 <_ZN2EcD1Ev+0x27a>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void destroy(Pt *obj, Quota &quota) { obj->~Pt(); cache.free (obj, quota); }
ffffffff8100449f:	4c 89 e2             	mov    %r12,%rdx
ffffffff810044a2:	48 89 ee             	mov    %rbp,%rsi
ffffffff810044a5:	48 c7 c7 00 40 16 81 	mov    $0xffffffff81164000,%rdi
ffffffff810044ac:	e8 b9 15 01 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>

    if (fpu)
ffffffff810044b1:	48 8b b3 b8 02 00 00 	mov    0x2b8(%rbx),%rsi
ffffffff810044b8:	48 85 f6             	test   %rsi,%rsi
ffffffff810044bb:	74 1a                	je     ffffffff810044d7 <_ZN2EcD1Ev+0x9b>
        Fpu::destroy(fpu, pd->quota);
ffffffff810044bd:	48 8b 83 98 02 00 00 	mov    0x298(%rbx),%rax

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void destroy(Fpu *obj, Quota &quota) { obj->~Fpu(); cache.free (obj, quota); }
ffffffff810044c4:	48 c7 c7 d0 20 16 81 	mov    $0xffffffff811620d0,%rdi
ffffffff810044cb:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff810044d2:	e8 93 15 01 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>

    if (utcb) {
ffffffff810044d7:	48 8b b3 90 02 00 00 	mov    0x290(%rbx),%rsi
ffffffff810044de:	48 8b 93 98 02 00 00 	mov    0x298(%rbx),%rdx
ffffffff810044e5:	48 85 f6             	test   %rsi,%rsi
ffffffff810044e8:	74 0c                	je     ffffffff810044f6 <_ZN2EcD1Ev+0xba>
        Utcb::destroy(utcb, pd->quota);
ffffffff810044ea:	48 81 c2 08 03 00 00 	add    $0x308,%rdx
ffffffff810044f1:	e9 90 01 00 00       	jmpq   ffffffff81004686 <_ZN2EcD1Ev+0x24a>
        return;
    }

    /* skip xCPU EC */
    if (!regs.vtlb)
ffffffff810044f6:	48 8b b3 30 01 00 00 	mov    0x130(%rbx),%rsi
ffffffff810044fd:	48 85 f6             	test   %rsi,%rsi
ffffffff81004500:	0f 84 8c 01 00 00    	je     ffffffff81004692 <_ZN2EcD1Ev+0x256>
        return;

    /* vCPU cleanup */
    Vtlb::destroy(regs.vtlb, pd->quota);
ffffffff81004506:	48 81 c2 08 03 00 00 	add    $0x308,%rdx
    }

    ALWAYS_INLINE
    static inline void destroy(Vtlb *obj, Quota &quota) {
        obj->~Vtlb();
        Buddy::allocator.free(reinterpret_cast<mword> (obj), quota);
ffffffff8100450d:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff81004514:	e8 95 d0 ff ff       	callq  ffffffff810015ae <_ZN5Buddy4freeEmR5Quota>
ffffffff81004519:	8b 05 f1 2a 16 00    	mov    0x162af1(%rip),%eax        # ffffffff81167010 <PAGE_H+0x10>

    if (Hip::feature() & Hip::FEAT_VMX) {
ffffffff8100451f:	a8 02                	test   $0x2,%al
ffffffff81004521:	0f 84 25 01 00 00    	je     ffffffff8100464c <_ZN2EcD1Ev+0x210>

        regs.vmcs->make_current();
ffffffff81004527:	48 8b 83 28 01 00 00 	mov    0x128(%rbx),%rax
        Vmcs* clone();

        ALWAYS_INLINE
        inline void make_current()
        {
            if (EXPECT_TRUE (current == this))
ffffffff8100452e:	48 39 05 eb aa ff 3e 	cmp    %rax,0x3effaaeb(%rip)        # ffffffffbffff020 <_ZN4Vmcs7currentE>
ffffffff81004535:	74 2e                	je     ffffffff81004565 <_ZN2EcD1Ev+0x129>
                return;

            uint64 phys = Buddy::ptr_to_phys (current = this);
ffffffff81004537:	48 89 05 e2 aa ff 3e 	mov    %rax,0x3effaae2(%rip)        # ffffffffbffff020 <_ZN4Vmcs7currentE>
ffffffff8100453e:	48 2d 00 00 c0 80    	sub    $0xffffffff80c00000,%rax
ffffffff81004544:	48 89 44 24 08       	mov    %rax,0x8(%rsp)

            bool ret;
            asm volatile ("vmptrld %1; seta %0" : "=q" (ret) : "m" (phys) : "cc");
ffffffff81004549:	0f c7 74 24 08       	vmptrld 0x8(%rsp)
ffffffff8100454e:	0f 97 c0             	seta   %al
            assert (ret);
ffffffff81004551:	84 c0                	test   %al,%al
ffffffff81004553:	49 c7 c0 c0 e0 01 81 	mov    $0xffffffff8101e0c0,%r8
ffffffff8100455a:	b9 9a 01 00 00       	mov    $0x19a,%ecx
ffffffff8100455f:	0f 84 bd 00 00 00    	je     ffffffff81004622 <_ZN2EcD1Ev+0x1e6>

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
ffffffff81004565:	be 08 20 00 00       	mov    $0x2008,%esi
ffffffff8100456a:	0f 78 f6             	vmread %rsi,%rsi

        mword host_msr_area_phys = Vmcs::read(Vmcs::EXI_MSR_LD_ADDR);
        Msr_area *host_msr_area = reinterpret_cast<Msr_area*> (Buddy::phys_to_ptr(host_msr_area_phys));
        Msr_area::destroy(host_msr_area, pd->quota);
ffffffff8100456d:	48 8b 83 98 02 00 00 	mov    0x298(%rbx),%rax
        }

        ALWAYS_INLINE
        inline mword phys_to_virt (mword phys)
        {
            return phys + reinterpret_cast<mword>(&OFFSET);
ffffffff81004574:	48 81 c6 00 00 c0 80 	add    $0xffffffff80c00000,%rsi
    }

    ALWAYS_INLINE
    static inline void destroy(Msr_area *obj, Quota &quota)
    {
        Buddy::allocator.free (reinterpret_cast<mword>(obj), quota);
ffffffff8100457b:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff81004582:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff81004589:	e8 20 d0 ff ff       	callq  ffffffff810015ae <_ZN5Buddy4freeEmR5Quota>

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
ffffffff8100458e:	be 06 20 00 00       	mov    $0x2006,%esi
ffffffff81004593:	0f 78 f6             	vmread %rsi,%rsi

        mword guest_msr_area_phys = Vmcs::read(Vmcs::EXI_MSR_ST_ADDR);
        Msr_area *guest_msr_area = reinterpret_cast<Msr_area*> (Buddy::phys_to_ptr(guest_msr_area_phys));
        Msr_area::destroy(guest_msr_area, pd->quota);
ffffffff81004596:	48 8b 83 98 02 00 00 	mov    0x298(%rbx),%rax
ffffffff8100459d:	48 81 c6 00 00 c0 80 	add    $0xffffffff80c00000,%rsi
    }

    ALWAYS_INLINE
    static inline void destroy(Msr_area *obj, Quota &quota)
    {
        Buddy::allocator.free (reinterpret_cast<mword>(obj), quota);
ffffffff810045a4:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff810045ab:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff810045b2:	e8 f7 cf ff ff       	callq  ffffffff810015ae <_ZN5Buddy4freeEmR5Quota>

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
ffffffff810045b7:	be 12 20 00 00       	mov    $0x2012,%esi
ffffffff810045bc:	0f 78 f6             	vmread %rsi,%rsi

        mword virtual_apic_page_phys = Vmcs::read(Vmcs::APIC_VIRT_ADDR);
        Virtual_apic_page *virtual_apic_page =
                reinterpret_cast<Virtual_apic_page*> (Buddy::phys_to_ptr(virtual_apic_page_phys));
        Virtual_apic_page::destroy(virtual_apic_page, pd->quota);
ffffffff810045bf:	48 8b 83 98 02 00 00 	mov    0x298(%rbx),%rax
ffffffff810045c6:	48 81 c6 00 00 c0 80 	add    $0xffffffff80c00000,%rsi
    }

    ALWAYS_INLINE
    static inline void destroy(Virtual_apic_page *obj, Quota &quota)
    {
        Buddy::allocator.free (reinterpret_cast<mword>(obj), quota);
ffffffff810045cd:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff810045d4:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff810045db:	e8 ce cf ff ff       	callq  ffffffff810015ae <_ZN5Buddy4freeEmR5Quota>

        regs.vmcs->clear();
ffffffff810045e0:	48 8b b3 28 01 00 00 	mov    0x128(%rbx),%rsi
        }

        ALWAYS_INLINE
        inline void clear()
        {
            if (EXPECT_TRUE (current == this))
ffffffff810045e7:	48 39 35 32 aa ff 3e 	cmp    %rsi,0x3effaa32(%rip)        # ffffffffbffff020 <_ZN4Vmcs7currentE>
ffffffff810045ee:	75 0b                	jne    ffffffff810045fb <_ZN2EcD1Ev+0x1bf>
                current = nullptr;
ffffffff810045f0:	48 c7 05 25 aa ff 3e 	movq   $0x0,0x3effaa25(%rip)        # ffffffffbffff020 <_ZN4Vmcs7currentE>
ffffffff810045f7:	00 00 00 00 
        }

        ALWAYS_INLINE
        inline mword virt_to_phys (mword virt)
        {
            return virt - reinterpret_cast<mword>(&OFFSET);
ffffffff810045fb:	48 89 f0             	mov    %rsi,%rax
ffffffff810045fe:	48 2d 00 00 c0 80    	sub    $0xffffffff80c00000,%rax
ffffffff81004604:	48 89 44 24 08       	mov    %rax,0x8(%rsp)

            uint64 phys = Buddy::ptr_to_phys (this);

            bool ret;
            asm volatile ("vmclear %1; seta %0" : "=q" (ret) : "m" (phys) : "cc");
ffffffff81004609:	66 0f c7 74 24 08    	vmclear 0x8(%rsp)
ffffffff8100460f:	0f 97 c0             	seta   %al
            assert (ret);
ffffffff81004612:	84 c0                	test   %al,%al
ffffffff81004614:	75 26                	jne    ffffffff8100463c <_ZN2EcD1Ev+0x200>
ffffffff81004616:	49 c7 c0 e0 e0 01 81 	mov    $0xffffffff8101e0e0,%r8
ffffffff8100461d:	b9 8b 01 00 00       	mov    $0x18b,%ecx
ffffffff81004622:	48 c7 c2 72 db 01 81 	mov    $0xffffffff8101db72,%rdx
ffffffff81004629:	48 c7 c6 e1 db 01 81 	mov    $0xffffffff8101dbe1,%rsi
ffffffff81004630:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81004637:	e8 14 d9 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

        Vmcs::destroy(regs.vmcs, pd->quota);
ffffffff8100463c:	48 8b 83 98 02 00 00 	mov    0x298(%rbx),%rax
ffffffff81004643:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff8100464a:	eb 3a                	jmp    ffffffff81004686 <_ZN2EcD1Ev+0x24a>
    } else if (Hip::feature() & Hip::FEAT_SVM)
ffffffff8100464c:	a8 04                	test   $0x4,%al
ffffffff8100464e:	74 42                	je     ffffffff81004692 <_ZN2EcD1Ev+0x256>
        Vmcb::destroy(regs.vmcb, pd->quota);
ffffffff81004650:	48 8b 83 98 02 00 00 	mov    0x298(%rbx),%rax
ffffffff81004657:	4c 8b a3 28 01 00 00 	mov    0x128(%rbx),%r12
    }

    ALWAYS_INLINE
    static inline void destroy(Vmcb *obj, Quota &quota) {
        Buddy::allocator.free(reinterpret_cast<mword> (Buddy::phys_to_ptr(static_cast<Paddr> (obj->base_msr))), quota);
ffffffff8100465e:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff81004665:	48 8d a8 08 03 00 00 	lea    0x308(%rax),%rbp
        }

        ALWAYS_INLINE
        inline mword phys_to_virt (mword phys)
        {
            return phys + reinterpret_cast<mword>(&OFFSET);
ffffffff8100466c:	49 8b 44 24 48       	mov    0x48(%r12),%rax
ffffffff81004671:	48 89 ea             	mov    %rbp,%rdx
ffffffff81004674:	48 8d b0 00 00 c0 80 	lea    -0x7f400000(%rax),%rsi
ffffffff8100467b:	e8 2e cf ff ff       	callq  ffffffff810015ae <_ZN5Buddy4freeEmR5Quota>
        obj->~Vmcb();
        Buddy::allocator.free(reinterpret_cast<mword> (obj), quota);
ffffffff81004680:	48 89 ea             	mov    %rbp,%rdx
ffffffff81004683:	4c 89 e6             	mov    %r12,%rsi
ffffffff81004686:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff8100468d:	e8 1c cf ff ff       	callq  ffffffff810015ae <_ZN5Buddy4freeEmR5Quota>
ffffffff81004692:	48 8b 83 98 02 00 00 	mov    0x298(%rbx),%rax
ffffffff81004699:	48 85 c0             	test   %rax,%rax
ffffffff8100469c:	0f 84 a3 00 00 00    	je     ffffffff81004745 <_ZN2EcD1Ev+0x309>
ffffffff810046a2:	83 ca ff             	or     $0xffffffff,%edx
ffffffff810046a5:	f0 0f c1 90 8c 00 00 	lock xadd %edx,0x8c(%rax)
ffffffff810046ac:	00 
ffffffff810046ad:	ff ca                	dec    %edx
ffffffff810046af:	74 40                	je     ffffffff810046f1 <_ZN2EcD1Ev+0x2b5>
ffffffff810046b1:	e9 8f 00 00 00       	jmpq   ffffffff81004745 <_ZN2EcD1Ev+0x309>
                delete ptr;
ffffffff810046b6:	48 8b bd 90 00 00 00 	mov    0x90(%rbp),%rdi
ffffffff810046bd:	48 85 ff             	test   %rdi,%rdi
ffffffff810046c0:	0f 84 d9 fd ff ff    	je     ffffffff8100449f <_ZN2EcD1Ev+0x63>
ffffffff810046c6:	e8 71 fd ff ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
ffffffff810046cb:	48 8b b5 90 00 00 00 	mov    0x90(%rbp),%rsi
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff810046d2:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff810046d9:	48 8b 86 98 02 00 00 	mov    0x298(%rsi),%rax
ffffffff810046e0:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff810046e7:	e8 7e 13 01 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
ffffffff810046ec:	e9 ae fd ff ff       	jmpq   ffffffff8100449f <_ZN2EcD1Ev+0x63>
ffffffff810046f1:	48 8b bb 98 02 00 00 	mov    0x298(%rbx),%rdi
ffffffff810046f8:	48 85 ff             	test   %rdi,%rdi
ffffffff810046fb:	74 48                	je     ffffffff81004745 <_ZN2EcD1Ev+0x309>
ffffffff810046fd:	e8 26 c9 00 00       	callq  ffffffff81011028 <_ZN2PdD1Ev>
ffffffff81004702:	48 8b ab 98 02 00 00 	mov    0x298(%rbx),%rbp

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff81004709:	31 d2                	xor    %edx,%edx
ffffffff8100470b:	48 8b 45 50          	mov    0x50(%rbp),%rax

            pd_del->quota.free_up(pd_to->quota);
ffffffff8100470f:	48 8d bd 08 03 00 00 	lea    0x308(%rbp),%rdi

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff81004716:	48 8d 88 08 fd ff ff 	lea    -0x2f8(%rax),%rcx
ffffffff8100471d:	48 85 c0             	test   %rax,%rax
ffffffff81004720:	48 0f 45 d1          	cmovne %rcx,%rdx

            pd_del->quota.free_up(pd_to->quota);
ffffffff81004724:	48 8d 9a 08 03 00 00 	lea    0x308(%rdx),%rbx
ffffffff8100472b:	48 89 de             	mov    %rbx,%rsi
ffffffff8100472e:	e8 91 ee ff ff       	callq  ffffffff810035c4 <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
ffffffff81004733:	48 89 da             	mov    %rbx,%rdx
ffffffff81004736:	48 89 ee             	mov    %rbp,%rsi
ffffffff81004739:	48 c7 c7 d0 3f 16 81 	mov    $0xffffffff81163fd0,%rdi
ffffffff81004740:	e8 25 13 01 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
}
ffffffff81004745:	48 83 c4 10          	add    $0x10,%rsp
ffffffff81004749:	5b                   	pop    %rbx
ffffffff8100474a:	5d                   	pop    %rbp
ffffffff8100474b:	41 5c                	pop    %r12
ffffffff8100474d:	c3                   	retq   

ffffffff8100474e <_ZN2Ec4freeEP8Rcu_elem>:
            fpowner = nullptr;
            Cpu::hazard |= HZD_FPU;
        }
    }

    static void free(Rcu_elem * a) {
ffffffff8100474e:	55                   	push   %rbp
ffffffff8100474f:	53                   	push   %rbx
ffffffff81004750:	48 83 ec 18          	sub    $0x18,%rsp
        Ec * e = static_cast<Ec *> (a);
ffffffff81004754:	48 85 ff             	test   %rdi,%rdi
ffffffff81004757:	0f 84 b6 00 00 00    	je     ffffffff81004813 <_ZN2Ec4freeEP8Rcu_elem+0xc5>

        if (!e->utcb && !e->xcpu_sm) {
ffffffff8100475d:	48 83 bf 78 02 00 00 	cmpq   $0x0,0x278(%rdi)
ffffffff81004764:	00 
ffffffff81004765:	75 3d                	jne    ffffffff810047a4 <_ZN2Ec4freeEP8Rcu_elem+0x56>
ffffffff81004767:	48 83 bf 18 03 00 00 	cmpq   $0x0,0x318(%rdi)
ffffffff8100476e:	00 
ffffffff8100476f:	75 33                	jne    ffffffff810047a4 <_ZN2Ec4freeEP8Rcu_elem+0x56>
            trace(0, "leaking memory - vCPU EC memory re-usage not supported");
ffffffff81004771:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff81004776:	8b 15 88 a8 ff 3e    	mov    0x3effa888(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100477c:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81004780:	48 c7 c7 e5 db 01 81 	mov    $0xffffffff8101dbe5,%rdi
ffffffff81004787:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8100478d:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff81004793:	48 0f 44 f2          	cmove  %rdx,%rsi

        if (e->del_ref()) {
            assert(e != Ec::current);
            delete e;
        }
    }
ffffffff81004797:	48 83 c4 18          	add    $0x18,%rsp

    static void free(Rcu_elem * a) {
        Ec * e = static_cast<Ec *> (a);

        if (!e->utcb && !e->xcpu_sm) {
            trace(0, "leaking memory - vCPU EC memory re-usage not supported");
ffffffff8100479b:	31 c0                	xor    %eax,%eax

        if (e->del_ref()) {
            assert(e != Ec::current);
            delete e;
        }
    }
ffffffff8100479d:	5b                   	pop    %rbx
ffffffff8100479e:	5d                   	pop    %rbp

    static void free(Rcu_elem * a) {
        Ec * e = static_cast<Ec *> (a);

        if (!e->utcb && !e->xcpu_sm) {
            trace(0, "leaking memory - vCPU EC memory re-usage not supported");
ffffffff8100479f:	e9 e8 d8 ff ff       	jmpq   ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff810047a4:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff810047a7:	f0 0f c1 47 74       	lock xadd %eax,0x74(%rdi)
            return;
        }

        if (e->del_ref()) {
ffffffff810047ac:	ff c8                	dec    %eax
ffffffff810047ae:	75 6d                	jne    ffffffff8100481d <_ZN2Ec4freeEP8Rcu_elem+0xcf>
            Cpu::hazard |= HZD_FPU;
        }
    }

    static void free(Rcu_elem * a) {
        Ec * e = static_cast<Ec *> (a);
ffffffff810047b0:	48 8d 6f e8          	lea    -0x18(%rdi),%rbp
            trace(0, "leaking memory - vCPU EC memory re-usage not supported");
            return;
        }

        if (e->del_ref()) {
            assert(e != Ec::current);
ffffffff810047b4:	48 3b 2d 4d a8 ff 3e 	cmp    0x3effa84d(%rip),%rbp        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff810047bb:	48 89 fb             	mov    %rdi,%rbx
ffffffff810047be:	75 28                	jne    ffffffff810047e8 <_ZN2Ec4freeEP8Rcu_elem+0x9a>
ffffffff810047c0:	49 c7 c0 00 e1 01 81 	mov    $0xffffffff8101e100,%r8
ffffffff810047c7:	b9 9c 00 00 00       	mov    $0x9c,%ecx
ffffffff810047cc:	48 c7 c2 d3 da 01 81 	mov    $0xffffffff8101dad3,%rdx
ffffffff810047d3:	48 c7 c6 23 dc 01 81 	mov    $0xffffffff8101dc23,%rsi
ffffffff810047da:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff810047e1:	31 c0                	xor    %eax,%eax
ffffffff810047e3:	e8 68 d7 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
            delete e;
ffffffff810047e8:	48 89 ef             	mov    %rbp,%rdi
ffffffff810047eb:	e8 4c fc ff ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff810047f0:	48 8b 93 80 02 00 00 	mov    0x280(%rbx),%rdx

        if (e->del_ref()) {
            assert(e != Ec::current);
            delete e;
        }
    }
ffffffff810047f7:	48 83 c4 18          	add    $0x18,%rsp
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff810047fb:	48 89 ee             	mov    %rbp,%rsi

        if (e->del_ref()) {
            assert(e != Ec::current);
            delete e;
        }
    }
ffffffff810047fe:	5b                   	pop    %rbx
ffffffff810047ff:	5d                   	pop    %rbp
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff81004800:	48 81 c2 08 03 00 00 	add    $0x308,%rdx
ffffffff81004807:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff8100480e:	e9 57 12 01 00       	jmpq   ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
    }

    static void free(Rcu_elem * a) {
        Ec * e = static_cast<Ec *> (a);

        if (!e->utcb && !e->xcpu_sm) {
ffffffff81004813:	48 8b 04 25 90 02 00 	mov    0x290,%rax
ffffffff8100481a:	00 
ffffffff8100481b:	0f 0b                	ud2    

        if (e->del_ref()) {
            assert(e != Ec::current);
            delete e;
        }
    }
ffffffff8100481d:	48 83 c4 18          	add    $0x18,%rsp
ffffffff81004821:	5b                   	pop    %rbx
ffffffff81004822:	5d                   	pop    %rbp
ffffffff81004823:	c3                   	retq   

ffffffff81004824 <_ZN2Ec13handle_hazardEmPFvvE>:

void Ec::handle_hazard(mword hzd, void (*func)()) {
ffffffff81004824:	55                   	push   %rbp
ffffffff81004825:	53                   	push   %rbx
ffffffff81004826:	48 89 f5             	mov    %rsi,%rbp
ffffffff81004829:	48 89 fb             	mov    %rdi,%rbx
ffffffff8100482c:	48 83 ec 18          	sub    $0x18,%rsp
    if (hzd & HZD_RCU)
ffffffff81004830:	40 f6 c7 10          	test   $0x10,%dil
ffffffff81004834:	74 05                	je     ffffffff8100483b <_ZN2Ec13handle_hazardEmPFvvE+0x17>
        Rcu::quiet();
ffffffff81004836:	e8 3b e7 00 00       	callq  ffffffff81012f76 <_ZN3Rcu5quietEv>

    if (hzd & HZD_SCHED) {
ffffffff8100483b:	f6 c3 01             	test   $0x1,%bl
ffffffff8100483e:	74 1a                	je     ffffffff8100485a <_ZN2Ec13handle_hazardEmPFvvE+0x36>
        current->cont = func;
ffffffff81004840:	48 8b 05 c1 a7 ff 3e 	mov    0x3effa7c1(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
        Sc::schedule();
ffffffff81004847:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff8100484c:	31 ff                	xor    %edi,%edi
void Ec::handle_hazard(mword hzd, void (*func)()) {
    if (hzd & HZD_RCU)
        Rcu::quiet();

    if (hzd & HZD_SCHED) {
        current->cont = func;
ffffffff8100484e:	48 89 a8 a0 00 00 00 	mov    %rbp,0xa0(%rax)
        Sc::schedule();
ffffffff81004855:	e8 5a 05 01 00       	callq  ffffffff81014db4 <_ZN2Sc8scheduleEbb>
    }

    if (hzd & HZD_RECALL) {
ffffffff8100485a:	f7 c3 00 00 00 80    	test   $0x80000000,%ebx
ffffffff81004860:	0f 84 84 00 00 00    	je     ffffffff810048ea <_ZN2Ec13handle_hazardEmPFvvE+0xc6>
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
ffffffff81004866:	48 8b 05 9b a7 ff 3e 	mov    0x3effa79b(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100486d:	48 b9 ff ff ff 7f ff 	movabs $0xffffffff7fffffff,%rcx
ffffffff81004874:	ff ff ff 
ffffffff81004877:	f0 48 21 88 80 01 00 	lock and %rcx,0x180(%rax)
ffffffff8100487e:	00 
ffffffff8100487f:	48 8b 05 82 a7 ff 3e 	mov    0x3effa782(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
        current->regs.clr_hazard(HZD_RECALL);

        if (func == ret_user_vmresume) {
ffffffff81004886:	48 81 fd 52 51 00 81 	cmp    $0xffffffff81005152,%rbp
ffffffff8100488d:	75 10                	jne    ffffffff8100489f <_ZN2Ec13handle_hazardEmPFvvE+0x7b>
            current->regs.dst_portal = NUM_VMI - 1;
ffffffff8100488f:	48 c7 80 50 01 00 00 	movq   $0xff,0x150(%rax)
ffffffff81004896:	ff 00 00 00 
            send_msg<ret_user_vmresume>();
ffffffff8100489a:	e8 cf 2d 01 00       	callq  ffffffff8101766e <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv>
        }

        if (func == ret_user_vmrun) {
ffffffff8100489f:	48 81 fd 8a 4a 00 81 	cmp    $0xffffffff81004a8a,%rbp
ffffffff810048a6:	75 10                	jne    ffffffff810048b8 <_ZN2Ec13handle_hazardEmPFvvE+0x94>
            current->regs.dst_portal = NUM_VMI - 1;
ffffffff810048a8:	48 c7 80 50 01 00 00 	movq   $0xff,0x150(%rax)
ffffffff810048af:	ff 00 00 00 
            send_msg<ret_user_vmrun>();
ffffffff810048b3:	e8 a0 30 01 00       	callq  ffffffff81017958 <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv>
        }

        if (func == ret_user_sysexit)
ffffffff810048b8:	48 81 fd 00 00 00 81 	cmp    $0xffffffff81000000,%rbp
ffffffff810048bf:	75 1c                	jne    ffffffff810048dd <_ZN2Ec13handle_hazardEmPFvvE+0xb9>
        return Sc::ctr_link--;
    }

    ALWAYS_INLINE
    inline void redirect_to_iret() {
        regs.REG(sp) = regs.ARG_SP;
ffffffff810048c1:	48 8b 90 c8 00 00 00 	mov    0xc8(%rax),%rdx
ffffffff810048c8:	48 89 90 70 01 00 00 	mov    %rdx,0x170(%rax)
        regs.REG(ip) = regs.ARG_IP;
ffffffff810048cf:	48 8b 90 18 01 00 00 	mov    0x118(%rax),%rdx
ffffffff810048d6:	48 89 90 58 01 00 00 	mov    %rdx,0x158(%rax)
            current->redirect_to_iret();

        current->regs.dst_portal = NUM_EXC - 1;
ffffffff810048dd:	48 c7 80 50 01 00 00 	movq   $0x1f,0x150(%rax)
ffffffff810048e4:	1f 00 00 00 
ffffffff810048e8:	eb 52                	jmp    ffffffff8100493c <_ZN2Ec13handle_hazardEmPFvvE+0x118>
        send_msg<ret_user_iret>();
    }

    if (hzd & HZD_STEP) {
ffffffff810048ea:	f7 c3 00 00 00 40    	test   $0x40000000,%ebx
ffffffff810048f0:	74 4f                	je     ffffffff81004941 <_ZN2Ec13handle_hazardEmPFvvE+0x11d>
ffffffff810048f2:	48 8b 05 0f a7 ff 3e 	mov    0x3effa70f(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff810048f9:	f0 48 81 a0 80 01 00 	lock andq $0xffffffffbfffffff,0x180(%rax)
ffffffff81004900:	00 ff ff ff bf 
ffffffff81004905:	48 8b 05 fc a6 ff 3e 	mov    0x3effa6fc(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
        current->regs.clr_hazard(HZD_STEP);

        if (func == ret_user_sysexit)
ffffffff8100490c:	48 81 fd 00 00 00 81 	cmp    $0xffffffff81000000,%rbp
ffffffff81004913:	75 1c                	jne    ffffffff81004931 <_ZN2Ec13handle_hazardEmPFvvE+0x10d>
        return Sc::ctr_link--;
    }

    ALWAYS_INLINE
    inline void redirect_to_iret() {
        regs.REG(sp) = regs.ARG_SP;
ffffffff81004915:	48 8b 90 c8 00 00 00 	mov    0xc8(%rax),%rdx
ffffffff8100491c:	48 89 90 70 01 00 00 	mov    %rdx,0x170(%rax)
        regs.REG(ip) = regs.ARG_IP;
ffffffff81004923:	48 8b 90 18 01 00 00 	mov    0x118(%rax),%rdx
ffffffff8100492a:	48 89 90 58 01 00 00 	mov    %rdx,0x158(%rax)
            current->redirect_to_iret();

        current->regs.dst_portal = Cpu::EXC_DB;
ffffffff81004931:	48 c7 80 50 01 00 00 	movq   $0x1,0x150(%rax)
ffffffff81004938:	01 00 00 00 
        send_msg<ret_user_iret>();
ffffffff8100493c:	e8 01 33 01 00       	callq  ffffffff81017c42 <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv>
    }

    if (hzd & HZD_TSC) {
ffffffff81004941:	f7 c3 00 00 00 20    	test   $0x20000000,%ebx
ffffffff81004947:	0f 84 bc 00 00 00    	je     ffffffff81004a09 <_ZN2Ec13handle_hazardEmPFvvE+0x1e5>
ffffffff8100494d:	48 8b 05 b4 a6 ff 3e 	mov    0x3effa6b4(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81004954:	f0 48 81 a0 80 01 00 	lock andq $0xffffffffdfffffff,0x180(%rax)
ffffffff8100495b:	00 ff ff ff df 
        current->regs.clr_hazard(HZD_TSC);

        if (func == ret_user_vmresume) {
ffffffff81004960:	48 81 fd 52 51 00 81 	cmp    $0xffffffff81005152,%rbp
ffffffff81004967:	0f 85 83 00 00 00    	jne    ffffffff810049f0 <_ZN2Ec13handle_hazardEmPFvvE+0x1cc>
            Console::print("TSC_OFFSET");
ffffffff8100496d:	31 c0                	xor    %eax,%eax
ffffffff8100496f:	48 c7 c7 34 dc 01 81 	mov    $0xffffffff8101dc34,%rdi
ffffffff81004976:	e8 11 d7 ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
            current->regs.vmcs->make_current();
ffffffff8100497b:	48 8b 15 86 a6 ff 3e 	mov    0x3effa686(%rip),%rdx        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81004982:	48 8b 82 28 01 00 00 	mov    0x128(%rdx),%rax
        Vmcs* clone();

        ALWAYS_INLINE
        inline void make_current()
        {
            if (EXPECT_TRUE (current == this))
ffffffff81004989:	48 39 05 90 a6 ff 3e 	cmp    %rax,0x3effa690(%rip)        # ffffffffbffff020 <_ZN4Vmcs7currentE>
ffffffff81004990:	74 44                	je     ffffffff810049d6 <_ZN2Ec13handle_hazardEmPFvvE+0x1b2>
                return;

            uint64 phys = Buddy::ptr_to_phys (current = this);
ffffffff81004992:	48 89 05 87 a6 ff 3e 	mov    %rax,0x3effa687(%rip)        # ffffffffbffff020 <_ZN4Vmcs7currentE>
        }

        ALWAYS_INLINE
        inline mword virt_to_phys (mword virt)
        {
            return virt - reinterpret_cast<mword>(&OFFSET);
ffffffff81004999:	48 2d 00 00 c0 80    	sub    $0xffffffff80c00000,%rax
ffffffff8100499f:	48 89 44 24 08       	mov    %rax,0x8(%rsp)

            bool ret;
            asm volatile ("vmptrld %1; seta %0" : "=q" (ret) : "m" (phys) : "cc");
ffffffff810049a4:	0f c7 74 24 08       	vmptrld 0x8(%rsp)
ffffffff810049a9:	0f 97 c0             	seta   %al
            assert (ret);
ffffffff810049ac:	84 c0                	test   %al,%al
ffffffff810049ae:	75 26                	jne    ffffffff810049d6 <_ZN2Ec13handle_hazardEmPFvvE+0x1b2>
ffffffff810049b0:	49 c7 c0 c0 e0 01 81 	mov    $0xffffffff8101e0c0,%r8
ffffffff810049b7:	b9 9a 01 00 00       	mov    $0x19a,%ecx
ffffffff810049bc:	48 c7 c2 72 db 01 81 	mov    $0xffffffff8101db72,%rdx
ffffffff810049c3:	48 c7 c6 e1 db 01 81 	mov    $0xffffffff8101dbe1,%rsi
ffffffff810049ca:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff810049d1:	e8 7a d5 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
            Vmcs::write(Vmcs::TSC_OFFSET, static_cast<mword> (current->regs.tsc_offset));
ffffffff810049d6:	48 8b 82 88 01 00 00 	mov    0x188(%rdx),%rax
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
ffffffff810049dd:	ba 10 20 00 00       	mov    $0x2010,%edx
ffffffff810049e2:	0f 79 d0             	vmwrite %rax,%rdx
            Vmcs::write(Vmcs::TSC_OFFSET_HI, static_cast<mword> (current->regs.tsc_offset >> 32));
ffffffff810049e5:	48 c1 e8 20          	shr    $0x20,%rax
ffffffff810049e9:	b2 11                	mov    $0x11,%dl
ffffffff810049eb:	0f 79 d0             	vmwrite %rax,%rdx
ffffffff810049ee:	eb 19                	jmp    ffffffff81004a09 <_ZN2Ec13handle_hazardEmPFvvE+0x1e5>
        } else
            current->regs.vmcb->tsc_offset = current->regs.tsc_offset;
ffffffff810049f0:	48 8b 05 11 a6 ff 3e 	mov    0x3effa611(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff810049f7:	48 8b 90 28 01 00 00 	mov    0x128(%rax),%rdx
ffffffff810049fe:	48 8b 80 88 01 00 00 	mov    0x188(%rax),%rax
ffffffff81004a05:	48 89 42 50          	mov    %rax,0x50(%rdx)
    }

    if (hzd & HZD_DS_ES) {
ffffffff81004a09:	f6 c3 02             	test   $0x2,%bl
ffffffff81004a0c:	74 10                	je     ffffffff81004a1e <_ZN2Ec13handle_hazardEmPFvvE+0x1fa>
        Cpu::hazard &= ~HZD_DS_ES;
ffffffff81004a0e:	83 25 eb a5 ff 3e fd 	andl   $0xfffffffd,0x3effa5eb(%rip)        # ffffffffbffff000 <_ZN3Cpu6hazardE>
        asm volatile ("mov %0, %%ds; mov %0, %%es" : : "r" (SEL_USER_DATA));
ffffffff81004a15:	b8 23 00 00 00       	mov    $0x23,%eax
ffffffff81004a1a:	8e d8                	mov    %eax,%ds
ffffffff81004a1c:	8e c0                	mov    %eax,%es
    }

    if (hzd & HZD_FPU)
ffffffff81004a1e:	80 e3 08             	and    $0x8,%bl
ffffffff81004a21:	74 21                	je     ffffffff81004a44 <_ZN2Ec13handle_hazardEmPFvvE+0x220>
        if (current != fpowner)
ffffffff81004a23:	48 8b 05 96 ad ff 3e 	mov    0x3effad96(%rip),%rax        # ffffffffbffff7c0 <_ZN2Ec7fpownerE>
ffffffff81004a2a:	48 39 05 d7 a5 ff 3e 	cmp    %rax,0x3effa5d7(%rip)        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81004a31:	74 11                	je     ffffffff81004a44 <_ZN2Ec13handle_hazardEmPFvvE+0x220>

ALWAYS_INLINE
static inline mword get_cr0()
{
    mword cr0;
    asm volatile ("mov %%cr0, %0" : "=r" (cr0));
ffffffff81004a33:	0f 20 c0             	mov    %cr0,%rax

        ALWAYS_INLINE
        static inline void enable() { asm volatile ("clts"); Cpu::hazard |= HZD_FPU; }

        ALWAYS_INLINE
        static inline void disable() { set_cr0 (get_cr0() | Cpu::CR0_TS); Cpu::hazard &= ~HZD_FPU; }
ffffffff81004a36:	48 83 c8 08          	or     $0x8,%rax
}

ALWAYS_INLINE
static inline void set_cr0 (mword cr0)
{
    asm volatile ("mov %0, %%cr0" : : "r" (cr0));
ffffffff81004a3a:	0f 22 c0             	mov    %rax,%cr0
ffffffff81004a3d:	83 25 bc a5 ff 3e f7 	andl   $0xfffffff7,0x3effa5bc(%rip)        # ffffffffbffff000 <_ZN3Cpu6hazardE>
            Fpu::disable();
}
ffffffff81004a44:	48 83 c4 18          	add    $0x18,%rsp
ffffffff81004a48:	5b                   	pop    %rbx
ffffffff81004a49:	5d                   	pop    %rbp
ffffffff81004a4a:	c3                   	retq   
ffffffff81004a4b:	90                   	nop

ffffffff81004a4c <_ZN2Ec4idleEv>:
                : : "m" (current->regs), "m" (Vmcb::root), "i" (CPU_LOCAL_STCK + PAGE_SIZE) : "memory");

    UNREACHED;
}

void Ec::idle() {
ffffffff81004a4c:	50                   	push   %rax
    for (;;) {

        mword hzd = Cpu::hazard & (HZD_RCU | HZD_SCHED);
        if (EXPECT_FALSE(hzd))
ffffffff81004a4d:	8b 3d ad a5 ff 3e    	mov    0x3effa5ad(%rip),%edi        # ffffffffbffff000 <_ZN3Cpu6hazardE>
ffffffff81004a53:	83 e7 11             	and    $0x11,%edi
ffffffff81004a56:	74 0e                	je     ffffffff81004a66 <_ZN2Ec4idleEv+0x1a>
}

void Ec::idle() {
    for (;;) {

        mword hzd = Cpu::hazard & (HZD_RCU | HZD_SCHED);
ffffffff81004a58:	89 ff                	mov    %edi,%edi
        if (EXPECT_FALSE(hzd))
            handle_hazard(hzd, idle);
ffffffff81004a5a:	48 c7 c6 4c 4a 00 81 	mov    $0xffffffff81004a4c,%rsi
ffffffff81004a61:	e8 be fd ff ff       	callq  ffffffff81004824 <_ZN2Ec13handle_hazardEmPFvvE>

ALWAYS_INLINE
static inline uint64 rdtsc()
{
    mword h, l;
    asm volatile ("rdtsc" : "=a" (l), "=d" (h));
ffffffff81004a66:	0f 31                	rdtsc  
    return static_cast<uint64>(h) << 32 | l;
ffffffff81004a68:	48 c1 e2 20          	shl    $0x20,%rdx
ffffffff81004a6c:	48 89 d1             	mov    %rdx,%rcx
ffffffff81004a6f:	48 09 c1             	or     %rax,%rcx

        uint64 t1 = rdtsc();
        asm volatile ("sti; hlt; cli" : : : "memory");
ffffffff81004a72:	fb                   	sti    
ffffffff81004a73:	f4                   	hlt    
ffffffff81004a74:	fa                   	cli    

ALWAYS_INLINE
static inline uint64 rdtsc()
{
    mword h, l;
    asm volatile ("rdtsc" : "=a" (l), "=d" (h));
ffffffff81004a75:	0f 31                	rdtsc  
    return static_cast<uint64>(h) << 32 | l;
ffffffff81004a77:	48 c1 e2 20          	shl    $0x20,%rdx
ffffffff81004a7b:	48 09 d0             	or     %rdx,%rax
        uint64 t2 = rdtsc();

        Counter::cycles_idle += t2 - t1;
ffffffff81004a7e:	48 29 c8             	sub    %rcx,%rax
ffffffff81004a81:	48 01 05 b8 a5 ff 3e 	add    %rax,0x3effa5b8(%rip)        # ffffffffbffff040 <_ZN7Counter11cycles_idleE>
    }
ffffffff81004a88:	eb c3                	jmp    ffffffff81004a4d <_ZN2Ec4idleEv+0x1>

ffffffff81004a8a <_ZN2Ec14ret_user_vmrunEv>:
    trace(0, "VM entry failed with error %#lx", Vmcs::read(Vmcs::VMX_INST_ERROR));

    die("VMENTRY");
}

void Ec::ret_user_vmrun() {
ffffffff81004a8a:	50                   	push   %rax
    if (!Ec::current->hardening_started || current->is_idle()) {
ffffffff81004a8b:	48 8b 05 76 a5 ff 3e 	mov    0x3effa576(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81004a92:	80 b8 51 03 00 00 00 	cmpb   $0x0,0x351(%rax)
ffffffff81004a99:	74 09                	je     ffffffff81004aa4 <_ZN2Ec14ret_user_vmrunEv+0x1a>
ffffffff81004a9b:	83 b8 4c 03 00 00 00 	cmpl   $0x0,0x34c(%rax)
ffffffff81004aa2:	75 66                	jne    ffffffff81004b0a <_ZN2Ec14ret_user_vmrunEv+0x80>
        mword hzd = (Cpu::hazard | current->regs.hazard()) & (HZD_RECALL | HZD_TSC | HZD_RCU | HZD_SCHED);
ffffffff81004aa4:	8b 3d 56 a5 ff 3e    	mov    0x3effa556(%rip),%edi        # ffffffffbffff000 <_ZN3Cpu6hazardE>
ffffffff81004aaa:	48 0b b8 80 01 00 00 	or     0x180(%rax),%rdi
        if (EXPECT_FALSE(hzd))
ffffffff81004ab1:	81 e7 11 00 00 a0    	and    $0xa0000011,%edi
ffffffff81004ab7:	74 0c                	je     ffffffff81004ac5 <_ZN2Ec14ret_user_vmrunEv+0x3b>
            handle_hazard(hzd, ret_user_vmrun);
ffffffff81004ab9:	48 c7 c6 8a 4a 00 81 	mov    $0xffffffff81004a8a,%rsi
ffffffff81004ac0:	e8 5f fd ff ff       	callq  ffffffff81004824 <_ZN2Ec13handle_hazardEmPFvvE>

        current->svm_save_state();
ffffffff81004ac5:	48 8b 05 3c a5 ff 3e 	mov    0x3effa53c(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
    void restore_state();

    void rollback();

    void save_state() {
        regs_0 = regs;
ffffffff81004acc:	b9 3c 00 00 00       	mov    $0x3c,%ecx
    }

    void svm_save_state() {
        save_state();
        memcpy(vmcb_backup, regs.vmcb, PAGE_SIZE);
ffffffff81004ad1:	ba 00 10 00 00       	mov    $0x1000,%edx
    void restore_state();

    void rollback();

    void save_state() {
        regs_0 = regs;
ffffffff81004ad6:	48 8d b8 98 01 00 00 	lea    0x198(%rax),%rdi
ffffffff81004add:	48 8d b0 a8 00 00 00 	lea    0xa8(%rax),%rsi
ffffffff81004ae4:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
    }

    void svm_save_state() {
        save_state();
        memcpy(vmcb_backup, regs.vmcb, PAGE_SIZE);
ffffffff81004ae6:	48 8b b0 28 01 00 00 	mov    0x128(%rax),%rsi
ffffffff81004aed:	48 8b b8 c0 02 00 00 	mov    0x2c0(%rax),%rdi
ffffffff81004af4:	e8 69 23 01 00       	callq  ffffffff81016e62 <memcpy>
        current->launch_state = Ec::vmrun;
ffffffff81004af9:	48 8b 05 08 a5 ff 3e 	mov    0x3effa508(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81004b00:	c7 80 4c 03 00 00 04 	movl   $0x4,0x34c(%rax)
ffffffff81004b07:	00 00 00 
    }
    if (EXPECT_FALSE(Pd::current->gtlb.chk(Cpu::id))) {
ffffffff81004b0a:	48 8b 05 ff a4 ff 3e 	mov    0x3effa4ff(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
ffffffff81004b11:	8b 0d ed a4 ff 3e    	mov    0x3effa4ed(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81004b17:	48 8b 90 d0 02 00 00 	mov    0x2d0(%rax),%rdx
ffffffff81004b1e:	48 0f a3 ca          	bt     %rcx,%rdx
ffffffff81004b22:	73 43                	jae    ffffffff81004b67 <_ZN2Ec14ret_user_vmrunEv+0xdd>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
ffffffff81004b24:	48 c7 c2 fe ff ff ff 	mov    $0xfffffffffffffffe,%rdx
ffffffff81004b2b:	48 d3 c2             	rol    %cl,%rdx
ffffffff81004b2e:	f0 48 21 90 d0 02 00 	lock and %rdx,0x2d0(%rax)
ffffffff81004b35:	00 
        Pd::current->gtlb.clr(Cpu::id);
        if (current->regs.nst_on)
ffffffff81004b36:	48 8b 05 cb a4 ff 3e 	mov    0x3effa4cb(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81004b3d:	80 b8 68 01 00 00 00 	cmpb   $0x0,0x168(%rax)
ffffffff81004b44:	74 10                	je     ffffffff81004b56 <_ZN2Ec14ret_user_vmrunEv+0xcc>
            current->regs.vmcb->tlb_control = 1;
ffffffff81004b46:	48 8b 80 28 01 00 00 	mov    0x128(%rax),%rax
ffffffff81004b4d:	c7 40 5c 01 00 00 00 	movl   $0x1,0x5c(%rax)
ffffffff81004b54:	eb 11                	jmp    ffffffff81004b67 <_ZN2Ec14ret_user_vmrunEv+0xdd>
        else
            current->regs.vtlb->flush(true);
ffffffff81004b56:	48 8b b8 30 01 00 00 	mov    0x130(%rax),%rdi
ffffffff81004b5d:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff81004b62:	e8 f1 81 01 00       	callq  ffffffff8101cd58 <_ZN4Vtlb5flushEb>
    }
    current->regs.disable_rdtsc<Vmcb>();
ffffffff81004b67:	48 8b 05 9a a4 ff 3e 	mov    0x3effa49a(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81004b6e:	48 8d b8 a8 00 00 00 	lea    0xa8(%rax),%rdi
ffffffff81004b75:	e8 4a ed 00 00       	callq  ffffffff810138c4 <_ZN8Exc_regs13disable_rdtscI4VmcbEEvv>
                "mov %2," EXPAND(PREG(sp);)
                "vmload;"
                "cli;"
                "stgi;"
                "jmp svm_handler;"
                : : "m" (current->regs), "m" (Vmcb::root), "i" (CPU_LOCAL_STCK + PAGE_SIZE) : "memory");
ffffffff81004b7a:	48 8b 05 87 a4 ff 3e 	mov    0x3effa487(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81004b81:	48 8d a0 a8 00 00 00 	lea    0xa8(%rax),%rsp
ffffffff81004b88:	41 5f                	pop    %r15
ffffffff81004b8a:	41 5e                	pop    %r14
ffffffff81004b8c:	41 5d                	pop    %r13
ffffffff81004b8e:	41 5c                	pop    %r12
ffffffff81004b90:	41 5b                	pop    %r11
ffffffff81004b92:	41 5a                	pop    %r10
ffffffff81004b94:	41 59                	pop    %r9
ffffffff81004b96:	41 58                	pop    %r8
ffffffff81004b98:	5f                   	pop    %rdi
ffffffff81004b99:	5e                   	pop    %rsi
ffffffff81004b9a:	5d                   	pop    %rbp
ffffffff81004b9b:	58                   	pop    %rax
ffffffff81004b9c:	5b                   	pop    %rbx
ffffffff81004b9d:	5a                   	pop    %rdx
ffffffff81004b9e:	59                   	pop    %rcx
ffffffff81004b9f:	58                   	pop    %rax
ffffffff81004ba0:	0f 01 dd             	clgi   
ffffffff81004ba3:	fb                   	sti    
ffffffff81004ba4:	0f 01 da             	vmload 
ffffffff81004ba7:	0f 01 d8             	vmrun  
ffffffff81004baa:	0f 01 db             	vmsave 
ffffffff81004bad:	50                   	push   %rax
ffffffff81004bae:	51                   	push   %rcx
ffffffff81004baf:	52                   	push   %rdx
ffffffff81004bb0:	53                   	push   %rbx
ffffffff81004bb1:	54                   	push   %rsp
ffffffff81004bb2:	55                   	push   %rbp
ffffffff81004bb3:	56                   	push   %rsi
ffffffff81004bb4:	57                   	push   %rdi
ffffffff81004bb5:	41 50                	push   %r8
ffffffff81004bb7:	41 51                	push   %r9
ffffffff81004bb9:	41 52                	push   %r10
ffffffff81004bbb:	41 53                	push   %r11
ffffffff81004bbd:	41 54                	push   %r12
ffffffff81004bbf:	41 55                	push   %r13
ffffffff81004bc1:	41 56                	push   %r14
ffffffff81004bc3:	41 57                	push   %r15
ffffffff81004bc5:	48 8b 05 64 b1 ff 3e 	mov    0x3effb164(%rip),%rax        # ffffffffbffffd30 <_ZN4Vmcb4rootE>
ffffffff81004bcc:	48 c7 c4 00 e0 ff bf 	mov    $0xffffffffbfffe000,%rsp
ffffffff81004bd3:	0f 01 da             	vmload 
ffffffff81004bd6:	fa                   	cli    
ffffffff81004bd7:	0f 01 dc             	stgi   
ffffffff81004bda:	e9 3d 20 00 00       	jmpq   ffffffff81006c1c <svm_handler>
ffffffff81004bdf:	90                   	nop

ffffffff81004be0 <_ZN2Ec5fixupERm>:
void Ec::handle_tss() {
    Console::panic("Task gate invoked");
}

bool Ec::fixup(mword &eip) {
    for (mword *ptr = &FIXUP_S; ptr < &FIXUP_E; ptr += 2)
ffffffff81004be0:	48 c7 c0 60 15 02 81 	mov    $0xffffffff81021560,%rax
ffffffff81004be7:	48 3d b0 15 02 81    	cmp    $0xffffffff810215b0,%rax
ffffffff81004bed:	73 18                	jae    ffffffff81004c07 <_ZN2Ec5fixupERm+0x27>
        if (eip == *ptr) {
ffffffff81004bef:	48 8b 10             	mov    (%rax),%rdx
ffffffff81004bf2:	48 39 17             	cmp    %rdx,(%rdi)
ffffffff81004bf5:	75 0a                	jne    ffffffff81004c01 <_ZN2Ec5fixupERm+0x21>
            eip = *++ptr;
ffffffff81004bf7:	48 8b 40 08          	mov    0x8(%rax),%rax
ffffffff81004bfb:	48 89 07             	mov    %rax,(%rdi)
            return true;
ffffffff81004bfe:	b0 01                	mov    $0x1,%al
ffffffff81004c00:	c3                   	retq   
void Ec::handle_tss() {
    Console::panic("Task gate invoked");
}

bool Ec::fixup(mword &eip) {
    for (mword *ptr = &FIXUP_S; ptr < &FIXUP_E; ptr += 2)
ffffffff81004c01:	48 83 c0 10          	add    $0x10,%rax
ffffffff81004c05:	eb e0                	jmp    ffffffff81004be7 <_ZN2Ec5fixupERm+0x7>
        if (eip == *ptr) {
            eip = *++ptr;
            return true;
        }

    return false;
ffffffff81004c07:	31 c0                	xor    %eax,%eax
}
ffffffff81004c09:	c3                   	retq   

ffffffff81004c0a <_ZN2Ec3dieEPKcP8Exc_regs>:

void Ec::die(char const *reason, Exc_regs *r) {
ffffffff81004c0a:	48 83 ec 18          	sub    $0x18,%rsp
    if (current->utcb || current->pd == &Pd::kern) {
ffffffff81004c0e:	48 8b 15 f3 a3 ff 3e 	mov    0x3effa3f3(%rip),%rdx        # ffffffffbffff008 <_ZN2Ec7currentE>
        }

    return false;
}

void Ec::die(char const *reason, Exc_regs *r) {
ffffffff81004c15:	48 89 f0             	mov    %rsi,%rax
ffffffff81004c18:	48 89 fe             	mov    %rdi,%rsi
    if (current->utcb || current->pd == &Pd::kern) {
ffffffff81004c1b:	48 83 ba 90 02 00 00 	cmpq   $0x0,0x290(%rdx)
ffffffff81004c22:	00 
ffffffff81004c23:	75 11                	jne    ffffffff81004c36 <_ZN2Ec3dieEPKcP8Exc_regs+0x2c>
ffffffff81004c25:	48 81 ba 98 02 00 00 	cmpq   $0xffffffff81163ca0,0x298(%rdx)
ffffffff81004c2c:	a0 3c 16 81 
ffffffff81004c30:	0f 85 bf 00 00 00    	jne    ffffffff81004cf5 <_ZN2Ec3dieEPKcP8Exc_regs+0xeb>
ffffffff81004c36:	48 c7 c1 51 dc 01 81 	mov    $0xffffffff8101dc51,%rcx
    return d;
}

extern "C" NONNULL
inline int strcmp(char const *s1, char const *s2) {
    while (*s1 && *s1 == *s2)
ffffffff81004c3d:	44 8a 06             	mov    (%rsi),%r8b
ffffffff81004c40:	45 84 c0             	test   %r8b,%r8b
ffffffff81004c43:	74 0d                	je     ffffffff81004c52 <_ZN2Ec3dieEPKcP8Exc_regs+0x48>
ffffffff81004c45:	44 3a 01             	cmp    (%rcx),%r8b
ffffffff81004c48:	75 08                	jne    ffffffff81004c52 <_ZN2Ec3dieEPKcP8Exc_regs+0x48>
        s1++, s2++;
ffffffff81004c4a:	48 ff c6             	inc    %rsi
ffffffff81004c4d:	48 ff c1             	inc    %rcx
ffffffff81004c50:	eb eb                	jmp    ffffffff81004c3d <_ZN2Ec3dieEPKcP8Exc_regs+0x33>
        if (strcmp(reason, "PT not found"))
ffffffff81004c52:	44 3a 01             	cmp    (%rcx),%r8b
ffffffff81004c55:	74 59                	je     ffffffff81004cb0 <_ZN2Ec3dieEPKcP8Exc_regs+0xa6>
            trace(0, "Killed EC:%p SC:%p V:%#lx CS:%#lx EIP:%#lx CR2:%#lx ERR:%#lx (%s)",
ffffffff81004c57:	48 8d 4c 24 07       	lea    0x7(%rsp),%rcx
ffffffff81004c5c:	44 8b 05 a1 a3 ff 3e 	mov    0x3effa3a1(%rip),%r8d        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81004c63:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81004c67:	57                   	push   %rdi
ffffffff81004c68:	ff b0 a0 00 00 00    	pushq  0xa0(%rax)
ffffffff81004c6e:	48 c7 c7 5e dc 01 81 	mov    $0xffffffff8101dc5e,%rdi
ffffffff81004c75:	48 81 e1 00 f0 ff ff 	and    $0xfffffffffffff000,%rcx
ffffffff81004c7c:	ff 70 58             	pushq  0x58(%rax)
ffffffff81004c7f:	ff b0 b0 00 00 00    	pushq  0xb0(%rax)
ffffffff81004c85:	48 81 f9 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rcx
ffffffff81004c8c:	4c 8b 88 b8 00 00 00 	mov    0xb8(%rax),%r9
ffffffff81004c93:	48 8b 0d 7e a3 ff 3e 	mov    0x3effa37e(%rip),%rcx        # ffffffffbffff018 <_ZN2Sc7currentE>
ffffffff81004c9a:	49 0f 44 f0          	cmove  %r8,%rsi
ffffffff81004c9e:	4c 8b 80 a8 00 00 00 	mov    0xa8(%rax),%r8
ffffffff81004ca5:	31 c0                	xor    %eax,%eax
ffffffff81004ca7:	e8 e0 d3 ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff81004cac:	48 83 c4 20          	add    $0x20,%rsp
                current, Sc::current, r->vec, r->cs, r->REG(ip), r->cr2, r->err, reason);
    } else
        trace(0, "Killed EC:%p SC:%p V:%#lx CR0:%#lx CR3:%#lx CR4:%#lx (%s)",
            current, Sc::current, r->vec, r->cr0_shadow, r->cr3_shadow, r->cr4_shadow, reason);

    Ec *ec = current->rcap;
ffffffff81004cb0:	48 8b 05 51 a3 ff 3e 	mov    0x3effa351(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81004cb7:	48 8b 80 88 02 00 00 	mov    0x288(%rax),%rax

    if (ec)
ffffffff81004cbe:	48 85 c0             	test   %rax,%rax
ffffffff81004cc1:	74 24                	je     ffffffff81004ce7 <_ZN2Ec3dieEPKcP8Exc_regs+0xdd>
        ec->cont = ec->cont == ret_user_sysexit ? static_cast<void (*)()> (sys_finish<Sys_regs::COM_ABT>) : dead;
ffffffff81004cc3:	48 81 b8 a0 00 00 00 	cmpq   $0xffffffff81000000,0xa0(%rax)
ffffffff81004cca:	00 00 00 81 
ffffffff81004cce:	48 c7 c1 36 51 00 81 	mov    $0xffffffff81005136,%rcx
ffffffff81004cd5:	48 c7 c2 2c 7f 01 81 	mov    $0xffffffff81017f2c,%rdx
ffffffff81004cdc:	48 0f 45 d1          	cmovne %rcx,%rdx
ffffffff81004ce0:	48 89 90 a0 00 00 00 	mov    %rdx,0xa0(%rax)

    reply(dead);
ffffffff81004ce7:	31 f6                	xor    %esi,%esi
ffffffff81004ce9:	48 c7 c7 36 51 00 81 	mov    $0xffffffff81005136,%rdi
ffffffff81004cf0:	e8 d9 b4 ff ff       	callq  ffffffff810001ce <_ZN2Ec5replyEPFvvEP2Sm>
    if (current->utcb || current->pd == &Pd::kern) {
        if (strcmp(reason, "PT not found"))
            trace(0, "Killed EC:%p SC:%p V:%#lx CS:%#lx EIP:%#lx CR2:%#lx ERR:%#lx (%s)",
                current, Sc::current, r->vec, r->cs, r->REG(ip), r->cr2, r->err, reason);
    } else
        trace(0, "Killed EC:%p SC:%p V:%#lx CR0:%#lx CR3:%#lx CR4:%#lx (%s)",
ffffffff81004cf5:	48 8b 88 98 00 00 00 	mov    0x98(%rax),%rcx
ffffffff81004cfc:	4c 8b 90 a0 00 00 00 	mov    0xa0(%rax),%r10
ffffffff81004d03:	4c 8b 88 90 00 00 00 	mov    0x90(%rax),%r9
ffffffff81004d0a:	4c 8b 80 a8 00 00 00 	mov    0xa8(%rax),%r8
ffffffff81004d11:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff81004d16:	8b 35 e8 a2 ff 3e    	mov    0x3effa2e8(%rip),%esi        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81004d1c:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81004d22:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff81004d28:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
ffffffff81004d2f:	48 0f 45 f0          	cmovne %rax,%rsi
ffffffff81004d33:	50                   	push   %rax
ffffffff81004d34:	57                   	push   %rdi
ffffffff81004d35:	48 c7 c7 a7 dc 01 81 	mov    $0xffffffff8101dca7,%rdi
ffffffff81004d3c:	41 52                	push   %r10
ffffffff81004d3e:	51                   	push   %rcx
ffffffff81004d3f:	48 8b 0d d2 a2 ff 3e 	mov    0x3effa2d2(%rip),%rcx        # ffffffffbffff018 <_ZN2Sc7currentE>
ffffffff81004d46:	e9 5a ff ff ff       	jmpq   ffffffff81004ca5 <_ZN2Ec3dieEPKcP8Exc_regs+0x9b>
ffffffff81004d4b:	90                   	nop

ffffffff81004d4c <_ZN2Ec11root_invokeEv>:

        Counter::cycles_idle += t2 - t1;
    }
}

void Ec::root_invoke() {
ffffffff81004d4c:	41 57                	push   %r15
ffffffff81004d4e:	41 56                	push   %r14
    Eh *e = static_cast<Eh *> (Hpt::remap(Pd::kern.quota, Hip::root_addr));
ffffffff81004d50:	48 c7 c7 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rdi

        Counter::cycles_idle += t2 - t1;
    }
}

void Ec::root_invoke() {
ffffffff81004d57:	41 55                	push   %r13
ffffffff81004d59:	41 54                	push   %r12
ffffffff81004d5b:	55                   	push   %rbp
ffffffff81004d5c:	53                   	push   %rbx
ffffffff81004d5d:	48 83 ec 48          	sub    $0x48,%rsp
    Eh *e = static_cast<Eh *> (Hpt::remap(Pd::kern.quota, Hip::root_addr));
ffffffff81004d61:	48 8b 35 e0 df 15 00 	mov    0x15dfe0(%rip),%rsi        # ffffffff81162d48 <_ZN3Hip9root_addrE>
ffffffff81004d68:	e8 a5 33 00 00       	callq  ffffffff81008112 <_ZN3Hpt5remapER5Quotam>
    if (!Hip::root_addr || e->ei_magic != 0x464c457f || e->ei_class != ELF_CLASS || e->ei_data != 1 || e->type != 2 || e->machine != ELF_MACHINE)
ffffffff81004d6d:	48 8b 35 d4 df 15 00 	mov    0x15dfd4(%rip),%rsi        # ffffffff81162d48 <_ZN3Hip9root_addrE>
ffffffff81004d74:	48 8b 15 8d a2 ff 3e 	mov    0x3effa28d(%rip),%rdx        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81004d7b:	48 85 f6             	test   %rsi,%rsi
ffffffff81004d7e:	74 25                	je     ffffffff81004da5 <_ZN2Ec11root_invokeEv+0x59>
ffffffff81004d80:	48 b9 ff ff ff ff ff 	movabs $0xffffffffffff,%rcx
ffffffff81004d87:	ff 00 00 
ffffffff81004d8a:	48 23 08             	and    (%rax),%rcx
ffffffff81004d8d:	48 bf 7f 45 4c 46 02 	movabs $0x102464c457f,%rdi
ffffffff81004d94:	01 00 00 
ffffffff81004d97:	48 39 f9             	cmp    %rdi,%rcx
ffffffff81004d9a:	75 09                	jne    ffffffff81004da5 <_ZN2Ec11root_invokeEv+0x59>
ffffffff81004d9c:	81 78 10 02 00 3e 00 	cmpl   $0x3e0002,0x10(%rax)
ffffffff81004da3:	74 13                	je     ffffffff81004db8 <_ZN2Ec11root_invokeEv+0x6c>
        die("No ELF");
ffffffff81004da5:	48 8d b2 a8 00 00 00 	lea    0xa8(%rdx),%rsi
ffffffff81004dac:	48 c7 c7 e8 dc 01 81 	mov    $0xffffffff8101dce8,%rdi
ffffffff81004db3:	e9 eb 00 00 00       	jmpq   ffffffff81004ea3 <_ZN2Ec11root_invokeEv+0x157>

    unsigned count = e->ph_count;
ffffffff81004db8:	0f b7 58 38          	movzwl 0x38(%rax),%ebx
    current->regs.set_pt(Cpu::id);
    current->regs.set_ip(e->entry);
    current->regs.set_sp(USER_ADDR - PAGE_SIZE);

    ELF_PHDR *p = static_cast<ELF_PHDR *> (Hpt::remap(Pd::kern.quota, Hip::root_addr + e->ph_offset));
ffffffff81004dbc:	48 c7 c7 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rdi

    for (unsigned i = 0; i < count; i++, p++) {
ffffffff81004dc3:	45 31 ff             	xor    %r15d,%r15d
void Ec::root_invoke() {
    Eh *e = static_cast<Eh *> (Hpt::remap(Pd::kern.quota, Hip::root_addr));
    if (!Hip::root_addr || e->ei_magic != 0x464c457f || e->ei_class != ELF_CLASS || e->ei_data != 1 || e->type != 2 || e->machine != ELF_MACHINE)
        die("No ELF");

    unsigned count = e->ph_count;
ffffffff81004dc6:	89 5c 24 04          	mov    %ebx,0x4(%rsp)
    current->regs.set_pt(Cpu::id);
ffffffff81004dca:	8b 1d 34 a2 ff 3e    	mov    0x3effa234(%rip),%ebx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81004dd0:	48 89 9a e8 00 00 00 	mov    %rbx,0xe8(%rdx)
    current->regs.set_ip(e->entry);
ffffffff81004dd7:	48 8b 48 18          	mov    0x18(%rax),%rcx
ffffffff81004ddb:	48 bb 00 e0 ff ff ff 	movabs $0x7fffffffe000,%rbx
ffffffff81004de2:	7f 00 00 
ffffffff81004de5:	48 89 9a c8 00 00 00 	mov    %rbx,0xc8(%rdx)

        ALWAYS_INLINE
        inline void set_pt (mword pt, mword pt2, mword s) { ARG_1 = pt; ARG_2 = pt2; ARG_3 = s; }

        ALWAYS_INLINE
        inline void set_ip (mword ip) { ARG_IP = ip; }
ffffffff81004dec:	48 89 8a 18 01 00 00 	mov    %rcx,0x118(%rdx)
    current->regs.set_sp(USER_ADDR - PAGE_SIZE);

    ELF_PHDR *p = static_cast<ELF_PHDR *> (Hpt::remap(Pd::kern.quota, Hip::root_addr + e->ph_offset));
ffffffff81004df3:	48 03 70 20          	add    0x20(%rax),%rsi
ffffffff81004df7:	e8 16 33 00 00       	callq  ffffffff81008112 <_ZN3Hpt5remapER5Quotam>
ffffffff81004dfc:	49 89 c5             	mov    %rax,%r13

    for (unsigned i = 0; i < count; i++, p++) {
ffffffff81004dff:	eb 4c                	jmp    ffffffff81004e4d <_ZN2Ec11root_invokeEv+0x101>

            unsigned attr = !!(p->flags & 0x4) << 0 | // R
                    !!(p->flags & 0x2) << 1 | // W
                    !!(p->flags & 0x1) << 2; // X

            if (p->f_size != p->m_size || p->v_addr % PAGE_SIZE != p->f_offs % PAGE_SIZE)
ffffffff81004e01:	4d 8b 65 08          	mov    0x8(%r13),%r12
ffffffff81004e05:	4d 8b 75 10          	mov    0x10(%r13),%r14
ffffffff81004e09:	4c 89 e2             	mov    %r12,%rdx
ffffffff81004e0c:	4c 31 f2             	xor    %r14,%rdx
ffffffff81004e0f:	f7 c2 ff 0f 00 00    	test   $0xfff,%edx
ffffffff81004e15:	75 77                	jne    ffffffff81004e8e <_ZN2Ec11root_invokeEv+0x142>
                die("Bad ELF");

            mword phys = align_dn(p->f_offs + Hip::root_addr, PAGE_SIZE);
ffffffff81004e17:	4c 03 25 2a df 15 00 	add    0x15df2a(%rip),%r12        # ffffffff81162d48 <_ZN3Hip9root_addrE>
}

ALWAYS_INLINE
static inline mword align_up (mword val, mword align)
{
    val += (align - 1);                 // Expect power-of-2
ffffffff81004e1e:	48 81 c5 ff 0f 00 00 	add    $0xfff,%rbp
            mword virt = align_dn(p->v_addr, PAGE_SIZE);
            mword size = align_up(p->f_size, PAGE_SIZE);

            for (unsigned long o; size; size -= 1UL << o, phys += 1UL << o, virt += 1UL << o)
                Pd::current->delegate<Space_mem>(&Pd::kern, phys >> PAGE_BITS, virt >> PAGE_BITS, (o = min(max_order(phys, size), max_order(virt, size))) - PAGE_BITS, attr);
ffffffff81004e25:	48 98                	cltq   
}

ALWAYS_INLINE
static inline mword align_dn (mword val, mword align)
{
    val &= ~(align - 1);                // Expect power-of-2
ffffffff81004e27:	49 81 e6 00 f0 ff ff 	and    $0xfffffffffffff000,%r14
ffffffff81004e2e:	48 81 e5 00 f0 ff ff 	and    $0xfffffffffffff000,%rbp
ffffffff81004e35:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
ffffffff81004e3a:	49 81 e4 00 f0 ff ff 	and    $0xfffffffffffff000,%r12

            mword phys = align_dn(p->f_offs + Hip::root_addr, PAGE_SIZE);
            mword virt = align_dn(p->v_addr, PAGE_SIZE);
            mword size = align_up(p->f_size, PAGE_SIZE);

            for (unsigned long o; size; size -= 1UL << o, phys += 1UL << o, virt += 1UL << o)
ffffffff81004e41:	48 85 ed             	test   %rbp,%rbp
ffffffff81004e44:	75 62                	jne    ffffffff81004ea8 <_ZN2Ec11root_invokeEv+0x15c>
    current->regs.set_ip(e->entry);
    current->regs.set_sp(USER_ADDR - PAGE_SIZE);

    ELF_PHDR *p = static_cast<ELF_PHDR *> (Hpt::remap(Pd::kern.quota, Hip::root_addr + e->ph_offset));

    for (unsigned i = 0; i < count; i++, p++) {
ffffffff81004e46:	41 ff c7             	inc    %r15d
ffffffff81004e49:	49 83 c5 38          	add    $0x38,%r13
ffffffff81004e4d:	44 3b 7c 24 04       	cmp    0x4(%rsp),%r15d
ffffffff81004e52:	0f 83 ca 00 00 00    	jae    ffffffff81004f22 <_ZN2Ec11root_invokeEv+0x1d6>

        if (p->type == 1) {
ffffffff81004e58:	41 83 7d 00 01       	cmpl   $0x1,0x0(%r13)
ffffffff81004e5d:	75 e7                	jne    ffffffff81004e46 <_ZN2Ec11root_invokeEv+0xfa>

            unsigned attr = !!(p->flags & 0x4) << 0 | // R
ffffffff81004e5f:	41 8b 55 04          	mov    0x4(%r13),%edx
                    !!(p->flags & 0x2) << 1 | // W
                    !!(p->flags & 0x1) << 2; // X

            if (p->f_size != p->m_size || p->v_addr % PAGE_SIZE != p->f_offs % PAGE_SIZE)
ffffffff81004e63:	49 8b 6d 20          	mov    0x20(%r13),%rbp

    for (unsigned i = 0; i < count; i++, p++) {

        if (p->type == 1) {

            unsigned attr = !!(p->flags & 0x4) << 0 | // R
ffffffff81004e67:	89 d0                	mov    %edx,%eax
                    !!(p->flags & 0x2) << 1 | // W
ffffffff81004e69:	89 d1                	mov    %edx,%ecx
                    !!(p->flags & 0x1) << 2; // X
ffffffff81004e6b:	83 e2 01             	and    $0x1,%edx

    for (unsigned i = 0; i < count; i++, p++) {

        if (p->type == 1) {

            unsigned attr = !!(p->flags & 0x4) << 0 | // R
ffffffff81004e6e:	c1 e8 02             	shr    $0x2,%eax
                    !!(p->flags & 0x2) << 1 | // W
ffffffff81004e71:	83 e1 02             	and    $0x2,%ecx

    for (unsigned i = 0; i < count; i++, p++) {

        if (p->type == 1) {

            unsigned attr = !!(p->flags & 0x4) << 0 | // R
ffffffff81004e74:	83 e0 01             	and    $0x1,%eax
ffffffff81004e77:	09 c8                	or     %ecx,%eax
ffffffff81004e79:	89 c3                	mov    %eax,%ebx
                    !!(p->flags & 0x2) << 1 | // W
                    !!(p->flags & 0x1) << 2; // X
ffffffff81004e7b:	89 d0                	mov    %edx,%eax
ffffffff81004e7d:	f7 d8                	neg    %eax
ffffffff81004e7f:	83 e0 04             	and    $0x4,%eax
    for (unsigned i = 0; i < count; i++, p++) {

        if (p->type == 1) {

            unsigned attr = !!(p->flags & 0x4) << 0 | // R
                    !!(p->flags & 0x2) << 1 | // W
ffffffff81004e82:	09 d8                	or     %ebx,%eax
                    !!(p->flags & 0x1) << 2; // X

            if (p->f_size != p->m_size || p->v_addr % PAGE_SIZE != p->f_offs % PAGE_SIZE)
ffffffff81004e84:	49 3b 6d 28          	cmp    0x28(%r13),%rbp
ffffffff81004e88:	0f 84 73 ff ff ff    	je     ffffffff81004e01 <_ZN2Ec11root_invokeEv+0xb5>
                die("Bad ELF");
ffffffff81004e8e:	48 8b 05 73 a1 ff 3e 	mov    0x3effa173(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81004e95:	48 c7 c7 ef dc 01 81 	mov    $0xffffffff8101dcef,%rdi
ffffffff81004e9c:	48 8d b0 a8 00 00 00 	lea    0xa8(%rax),%rsi
ffffffff81004ea3:	e8 62 fd ff ff       	callq  ffffffff81004c0a <_ZN2Ec3dieEPKcP8Exc_regs>
    if (EXPECT_FALSE (!val))
        return -1;

    asm volatile ("bsr %1, %0" : "=r" (val) : "rm" (val));

    return val;
ffffffff81004ea8:	48 0f bd c5          	bsr    %rbp,%rax
ALWAYS_INLINE
inline unsigned long max_order (mword base, size_t size)
{
    long int o = bit_scan_reverse (size);

    if (base)
ffffffff81004eac:	4d 85 f6             	test   %r14,%r14
ffffffff81004eaf:	74 0b                	je     ffffffff81004ebc <_ZN2Ec11root_invokeEv+0x170>
inline long int bit_scan_forward (mword val)
{
    if (EXPECT_FALSE (!val))
        return -1;

    asm volatile ("bsf %1, %0" : "=r" (val) : "rm" (val));
ffffffff81004eb1:	49 0f bc d6          	bsf    %r14,%rdx
ffffffff81004eb5:	48 39 d0             	cmp    %rdx,%rax
ffffffff81004eb8:	48 0f 4f c2          	cmovg  %rdx,%rax
    if (EXPECT_FALSE (!val))
        return -1;

    asm volatile ("bsr %1, %0" : "=r" (val) : "rm" (val));

    return val;
ffffffff81004ebc:	4c 0f bd d5          	bsr    %rbp,%r10
ALWAYS_INLINE
inline unsigned long max_order (mword base, size_t size)
{
    long int o = bit_scan_reverse (size);

    if (base)
ffffffff81004ec0:	4d 85 e4             	test   %r12,%r12
ffffffff81004ec3:	74 0b                	je     ffffffff81004ed0 <_ZN2Ec11root_invokeEv+0x184>
inline long int bit_scan_forward (mword val)
{
    if (EXPECT_FALSE (!val))
        return -1;

    asm volatile ("bsf %1, %0" : "=r" (val) : "rm" (val));
ffffffff81004ec5:	49 0f bc d4          	bsf    %r12,%rdx
ffffffff81004ec9:	49 39 d2             	cmp    %rdx,%r10
ffffffff81004ecc:	4c 0f 4f d2          	cmovg  %rdx,%r10
ffffffff81004ed0:	49 39 c2             	cmp    %rax,%r10
            mword phys = align_dn(p->f_offs + Hip::root_addr, PAGE_SIZE);
            mword virt = align_dn(p->v_addr, PAGE_SIZE);
            mword size = align_up(p->f_size, PAGE_SIZE);

            for (unsigned long o; size; size -= 1UL << o, phys += 1UL << o, virt += 1UL << o)
                Pd::current->delegate<Space_mem>(&Pd::kern, phys >> PAGE_BITS, virt >> PAGE_BITS, (o = min(max_order(phys, size), max_order(virt, size))) - PAGE_BITS, attr);
ffffffff81004ed3:	6a 00                	pushq  $0x0
ffffffff81004ed5:	48 8b 3d 34 a1 ff 3e 	mov    0x3effa134(%rip),%rdi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81004edc:	49 0f 46 c2          	cmovbe %r10,%rax
ffffffff81004ee0:	6a 00                	pushq  $0x0
ffffffff81004ee2:	4c 8b 4c 24 18       	mov    0x18(%rsp),%r9
ffffffff81004ee7:	4c 89 f1             	mov    %r14,%rcx
ffffffff81004eea:	4c 89 e2             	mov    %r12,%rdx
ffffffff81004eed:	4c 8d 40 f4          	lea    -0xc(%rax),%r8
ffffffff81004ef1:	48 89 c3             	mov    %rax,%rbx
ffffffff81004ef4:	48 c1 e9 0c          	shr    $0xc,%rcx
ffffffff81004ef8:	48 c7 c6 a0 3c 16 81 	mov    $0xffffffff81163ca0,%rsi
ffffffff81004eff:	48 c1 ea 0c          	shr    $0xc,%rdx
ffffffff81004f03:	e8 1c c4 00 00       	callq  ffffffff81011324 <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc>

            mword phys = align_dn(p->f_offs + Hip::root_addr, PAGE_SIZE);
            mword virt = align_dn(p->v_addr, PAGE_SIZE);
            mword size = align_up(p->f_size, PAGE_SIZE);

            for (unsigned long o; size; size -= 1UL << o, phys += 1UL << o, virt += 1UL << o)
ffffffff81004f08:	b8 01 00 00 00       	mov    $0x1,%eax
ffffffff81004f0d:	88 d9                	mov    %bl,%cl
ffffffff81004f0f:	48 d3 e0             	shl    %cl,%rax
ffffffff81004f12:	5e                   	pop    %rsi
ffffffff81004f13:	48 29 c5             	sub    %rax,%rbp
ffffffff81004f16:	49 01 c4             	add    %rax,%r12
ffffffff81004f19:	49 01 c6             	add    %rax,%r14
ffffffff81004f1c:	5f                   	pop    %rdi
ffffffff81004f1d:	e9 1f ff ff ff       	jmpq   ffffffff81004e41 <_ZN2Ec11root_invokeEv+0xf5>
                Pd::current->delegate<Space_mem>(&Pd::kern, phys >> PAGE_BITS, virt >> PAGE_BITS, (o = min(max_order(phys, size), max_order(virt, size))) - PAGE_BITS, attr);
        }
    }

    // Map hypervisor information page
    Pd::current->delegate<Space_mem>(&Pd::kern, reinterpret_cast<Paddr> (&FRAME_H) >> PAGE_BITS, (USER_ADDR - PAGE_SIZE) >> PAGE_BITS, 0, 1);
ffffffff81004f22:	48 8b 3d e7 a0 ff 3e 	mov    0x3effa0e7(%rip),%rdi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81004f29:	6a 00                	pushq  $0x0
ffffffff81004f2b:	48 c7 c2 00 70 56 00 	mov    $0x567000,%rdx
ffffffff81004f32:	6a 00                	pushq  $0x0
ffffffff81004f34:	48 c1 ea 0c          	shr    $0xc,%rdx
ffffffff81004f38:	45 31 c0             	xor    %r8d,%r8d
ffffffff81004f3b:	41 b9 01 00 00 00    	mov    $0x1,%r9d
ffffffff81004f41:	48 b9 fe ff ff ff 07 	movabs $0x7fffffffe,%rcx
ffffffff81004f48:	00 00 00 
ffffffff81004f4b:	48 c7 c6 a0 3c 16 81 	mov    $0xffffffff81163ca0,%rsi
ffffffff81004f52:	e8 cd c3 00 00       	callq  ffffffff81011324 <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc>

    Space_obj::insert_root(Pd::kern.quota, Pd::current);
ffffffff81004f57:	48 8b 35 b2 a0 ff 3e 	mov    0x3effa0b2(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81004f5e:	48 c7 c7 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rdi
ffffffff81004f65:	e8 00 1b 01 00       	callq  ffffffff81016a6a <_ZN9Space_obj11insert_rootER5QuotaP7Kobject>
    Space_obj::insert_root(Pd::kern.quota, Ec::current);
ffffffff81004f6a:	48 8b 35 97 a0 ff 3e 	mov    0x3effa097(%rip),%rsi        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81004f71:	48 c7 c7 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rdi
ffffffff81004f78:	e8 ed 1a 01 00       	callq  ffffffff81016a6a <_ZN9Space_obj11insert_rootER5QuotaP7Kobject>
    Space_obj::insert_root(Pd::kern.quota, Sc::current);
ffffffff81004f7d:	48 8b 35 94 a0 ff 3e 	mov    0x3effa094(%rip),%rsi        # ffffffffbffff018 <_ZN2Sc7currentE>
ffffffff81004f84:	48 c7 c7 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rdi
ffffffff81004f8b:	e8 da 1a 01 00       	callq  ffffffff81016a6a <_ZN9Space_obj11insert_rootER5QuotaP7Kobject>

        mword usage() { return used; }

        static void boot(Quota &kern, Quota &root)
        {
            kern.upli   = kern.used;
ffffffff81004f90:	48 8b 05 19 f0 15 00 	mov    0x15f019(%rip),%rax        # ffffffff81163fb0 <_ZN2Pd4kernE+0x310>
            root.upli  -= kern.used;
ffffffff81004f97:	48 29 05 e2 ec 15 00 	sub    %rax,0x15ece2(%rip)        # ffffffff81163c80 <_ZN2Pd4rootE+0x320>
    /* adjust root quota used by Pd::kern during bootstrap */
    Quota::boot(Pd::kern.quota, Pd::root.quota);

    /* preserve per CPU 4 pages quota */
    Quota cpus;
    bool s = Pd::root.quota.transfer_to(cpus, Cpu::online * 4);
ffffffff81004f9e:	48 8d 74 24 28       	lea    0x28(%rsp),%rsi
ffffffff81004fa3:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff81004fa8:	48 c7 c7 68 3c 16 81 	mov    $0xffffffff81163c68,%rdi
ffffffff81004faf:	66 c7 44 24 28 00 00 	movw   $0x0,0x28(%rsp)

    public:

        static Quota init;

        Quota () : used(0), over(0), upli(0), notr(0) { }
ffffffff81004fb6:	48 c7 44 24 30 00 00 	movq   $0x0,0x30(%rsp)
ffffffff81004fbd:	00 00 
ffffffff81004fbf:	48 c7 44 24 38 00 00 	movq   $0x0,0x38(%rsp)
ffffffff81004fc6:	00 00 

        mword usage() { return used; }

        static void boot(Quota &kern, Quota &root)
        {
            kern.upli   = kern.used;
ffffffff81004fc8:	48 89 05 f1 ef 15 00 	mov    %rax,0x15eff1(%rip)        # ffffffff81163fc0 <_ZN2Pd4kernE+0x320>
ffffffff81004fcf:	8b 05 6b d0 15 00    	mov    0x15d06b(%rip),%eax        # ffffffff81162040 <_ZN3Cpu6onlineE>

    public:

        static Quota init;

        Quota () : used(0), over(0), upli(0), notr(0) { }
ffffffff81004fd5:	48 c7 44 24 40 00 00 	movq   $0x0,0x40(%rsp)
ffffffff81004fdc:	00 00 
ffffffff81004fde:	48 c7 44 24 48 00 00 	movq   $0x0,0x48(%rsp)
ffffffff81004fe5:	00 00 
ffffffff81004fe7:	8d 14 85 00 00 00 00 	lea    0x0(,%rax,4),%edx
ffffffff81004fee:	e8 2f e7 ff ff       	callq  ffffffff81003722 <_ZN5Quota11transfer_toERS_mb>
    assert(s);
ffffffff81004ff3:	84 c0                	test   %al,%al
ffffffff81004ff5:	5a                   	pop    %rdx
ffffffff81004ff6:	59                   	pop    %rcx
ffffffff81004ff7:	75 26                	jne    ffffffff8100501f <_ZN2Ec11root_invokeEv+0x2d3>
ffffffff81004ff9:	49 c7 c0 20 e0 01 81 	mov    $0xffffffff8101e020,%r8
ffffffff81005000:	b9 b8 01 00 00       	mov    $0x1b8,%ecx
ffffffff81005005:	48 c7 c2 f7 dc 01 81 	mov    $0xffffffff8101dcf7,%rdx
ffffffff8100500c:	48 c7 c6 84 04 02 81 	mov    $0xffffffff81020484,%rsi
ffffffff81005013:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100501a:	e9 12 01 00 00       	jmpq   ffffffff81005131 <_ZN2Ec11root_invokeEv+0x3e5>
             return true;
        }

        bool set_limit(mword l, mword h, Quota &from)
        {
            if (!from.transfer_to(*this, h))
ffffffff8100501f:	48 c7 c6 68 3c 16 81 	mov    $0xffffffff81163c68,%rsi
ffffffff81005026:	31 d2                	xor    %edx,%edx
ffffffff81005028:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff8100502d:	48 89 f7             	mov    %rsi,%rdi
ffffffff81005030:	e8 ed e6 ff ff       	callq  ffffffff81003722 <_ZN5Quota11transfer_toERS_mb>
ffffffff81005035:	84 c0                	test   %al,%al
ffffffff81005037:	0f 84 d1 00 00 00    	je     ffffffff8100510e <_ZN2Ec11root_invokeEv+0x3c2>
                return false;

            notr = l;
ffffffff8100503d:	48 c7 05 40 ec 15 00 	movq   $0x100,0x15ec40(%rip)        # ffffffff81163c88 <_ZN2Pd4rootE+0x328>
ffffffff81005044:	00 01 00 00 
        template <typename T>
        ALWAYS_INLINE
        static inline bool test_set_bit (T &val, unsigned long bit)
        {
            bool ret;
            asm volatile ("lock; bts%z1 %2, %1; setc %0" : "=q" (ret), "+m" (val) : "ir" (bit) : "cc");
ffffffff81005048:	f0 48 0f ba 2d 6e f0 	lock btsq $0x2,0x15f06e(%rip)        # ffffffff811640c0 <_ZN9Space_mem5did_cE>
ffffffff8100504f:	15 00 02 
ffffffff81005052:	0f 92 c0             	setb   %al

        ALWAYS_INLINE
        static inline void boot_init()
        {
            bool res = !Atomic::test_set_bit (did_c[0], NO_PCID);
            assert (res);
ffffffff81005055:	84 c0                	test   %al,%al
ffffffff81005057:	74 18                	je     ffffffff81005071 <_ZN2Ec11root_invokeEv+0x325>
ffffffff81005059:	49 c7 c0 f0 df 01 81 	mov    $0xffffffff8101dff0,%r8
ffffffff81005060:	b9 3a 00 00 00       	mov    $0x3a,%ecx
ffffffff81005065:	48 c7 c2 61 dd 01 81 	mov    $0xffffffff8101dd61,%rdx
ffffffff8100506c:	e9 b0 00 00 00       	jmpq   ffffffff81005121 <_ZN2Ec11root_invokeEv+0x3d5>
    bool res = Pd::root.quota.set_limit((1 * 1024 * 1024) >> 12, 0, Pd::root.quota);
    assert(res);

    /* setup PCID handling */
    Space_mem::boot_init();
    assert(Pd::kern.did == 0);
ffffffff81005071:	48 83 3d df ee 15 00 	cmpq   $0x0,0x15eedf(%rip)        # ffffffff81163f58 <_ZN2Pd4kernE+0x2b8>
ffffffff81005078:	00 
ffffffff81005079:	74 1f                	je     ffffffff8100509a <_ZN2Ec11root_invokeEv+0x34e>
ffffffff8100507b:	49 c7 c0 20 e0 01 81 	mov    $0xffffffff8101e020,%r8
ffffffff81005082:	b9 c0 01 00 00       	mov    $0x1c0,%ecx
ffffffff81005087:	48 c7 c2 f7 dc 01 81 	mov    $0xffffffff8101dcf7,%rdx
ffffffff8100508e:	48 c7 c6 da dd 01 81 	mov    $0xffffffff8101ddda,%rsi
ffffffff81005095:	e9 8e 00 00 00       	jmpq   ffffffff81005128 <_ZN2Ec11root_invokeEv+0x3dc>
    assert(Pd::root.did == 1);
ffffffff8100509a:	48 83 3d 76 eb 15 00 	cmpq   $0x1,0x15eb76(%rip)        # ffffffff81163c18 <_ZN2Pd4rootE+0x2b8>
ffffffff810050a1:	01 
ffffffff810050a2:	74 1c                	je     ffffffff810050c0 <_ZN2Ec11root_invokeEv+0x374>
ffffffff810050a4:	49 c7 c0 20 e0 01 81 	mov    $0xffffffff8101e020,%r8
ffffffff810050ab:	b9 c1 01 00 00       	mov    $0x1c1,%ecx
ffffffff810050b0:	48 c7 c2 f7 dc 01 81 	mov    $0xffffffff8101dcf7,%rdx
ffffffff810050b7:	48 c7 c6 ec dd 01 81 	mov    $0xffffffff8101ddec,%rsi
ffffffff810050be:	eb 68                	jmp    ffffffff81005128 <_ZN2Ec11root_invokeEv+0x3dc>

    /* quirk */
    if (Dpt::ord != ~0UL && Dpt::ord > 0x8) {
ffffffff810050c0:	48 8b 05 21 cb 01 00 	mov    0x1cb21(%rip),%rax        # ffffffff81021be8 <_ZN3Dpt3ordE>
ffffffff810050c7:	48 83 e8 09          	sub    $0x9,%rax
ffffffff810050cb:	48 83 f8 f5          	cmp    $0xfffffffffffffff5,%rax
ffffffff810050cf:	77 38                	ja     ffffffff81005109 <_ZN2Ec11root_invokeEv+0x3bd>
        trace(0, "disabling super pages for DMAR");
ffffffff810050d1:	8b 15 2d 9f ff 3e    	mov    0x3eff9f2d(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff810050d7:	48 8d 44 24 0f       	lea    0xf(%rsp),%rax
ffffffff810050dc:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff810050e0:	48 c7 c7 fe dd 01 81 	mov    $0xffffffff8101ddfe,%rdi
ffffffff810050e7:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff810050ed:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff810050f3:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff810050f7:	31 c0                	xor    %eax,%eax
ffffffff810050f9:	e8 8e cf ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
        Dpt::ord = 0x8;
ffffffff810050fe:	48 c7 05 df ca 01 00 	movq   $0x8,0x1cadf(%rip)        # ffffffff81021be8 <_ZN3Dpt3ordE>
ffffffff81005105:	08 00 00 00 
    }

    ret_user_sysexit();
ffffffff81005109:	e8 f2 ae ff ff       	callq  ffffffff81000000 <_ZN2Ec16ret_user_sysexitEv>
    bool s = Pd::root.quota.transfer_to(cpus, Cpu::online * 4);
    assert(s);

    /* preserve for the root task memory that is not transferable */
    bool res = Pd::root.quota.set_limit((1 * 1024 * 1024) >> 12, 0, Pd::root.quota);
    assert(res);
ffffffff8100510e:	49 c7 c0 20 e0 01 81 	mov    $0xffffffff8101e020,%r8
ffffffff81005115:	b9 bc 01 00 00       	mov    $0x1bc,%ecx
ffffffff8100511a:	48 c7 c2 f7 dc 01 81 	mov    $0xffffffff8101dcf7,%rdx
ffffffff81005121:	48 c7 c6 d6 dd 01 81 	mov    $0xffffffff8101ddd6,%rsi
ffffffff81005128:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100512f:	31 c0                	xor    %eax,%eax
ffffffff81005131:	e8 1a ce ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

ffffffff81005136 <_ZN2Ec4deadEv>:

    template <bool>
    static void delegate();

    NORETURN
    static void dead() {
ffffffff81005136:	50                   	push   %rax
        die("IPC Abort");
ffffffff81005137:	48 8b 05 ca 9e ff 3e 	mov    0x3eff9eca(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100513e:	48 c7 c7 24 de 01 81 	mov    $0xffffffff8101de24,%rdi
ffffffff81005145:	48 8d b0 a8 00 00 00 	lea    0xa8(%rax),%rsi
ffffffff8100514c:	e8 b9 fa ff ff       	callq  ffffffff81004c0a <_ZN2Ec3dieEPKcP8Exc_regs>
ffffffff81005151:	90                   	nop

ffffffff81005152 <_ZN2Ec17ret_user_vmresumeEv>:
        Cpu::preempt_disable();
        Sc::schedule();
    }
}

void Ec::ret_user_vmresume() {
ffffffff81005152:	48 83 ec 18          	sub    $0x18,%rsp
    if (current->is_idle()) {
ffffffff81005156:	48 8b 05 ab 9e ff 3e 	mov    0x3eff9eab(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100515d:	83 b8 4c 03 00 00 00 	cmpl   $0x0,0x34c(%rax)
ffffffff81005164:	0f 85 aa 00 00 00    	jne    ffffffff81005214 <_ZN2Ec17ret_user_vmresumeEv+0xc2>
        mword hzd = (Cpu::hazard | current->regs.hazard()) & (HZD_RECALL | HZD_TSC | HZD_RCU | HZD_SCHED);
ffffffff8100516a:	8b 3d 90 9e ff 3e    	mov    0x3eff9e90(%rip),%edi        # ffffffffbffff000 <_ZN3Cpu6hazardE>
ffffffff81005170:	48 0b b8 80 01 00 00 	or     0x180(%rax),%rdi
        if (EXPECT_FALSE(hzd))
ffffffff81005177:	81 e7 11 00 00 a0    	and    $0xa0000011,%edi
ffffffff8100517d:	74 0c                	je     ffffffff8100518b <_ZN2Ec17ret_user_vmresumeEv+0x39>
            handle_hazard(hzd, ret_user_vmresume);
ffffffff8100517f:	48 c7 c6 52 51 00 81 	mov    $0xffffffff81005152,%rsi
ffffffff81005186:	e8 99 f6 ff ff       	callq  ffffffff81004824 <_ZN2Ec13handle_hazardEmPFvvE>

        current->regs.vmcs->make_current();
ffffffff8100518b:	48 8b 15 76 9e ff 3e 	mov    0x3eff9e76(%rip),%rdx        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81005192:	48 8b 82 28 01 00 00 	mov    0x128(%rdx),%rax
        Vmcs* clone();

        ALWAYS_INLINE
        inline void make_current()
        {
            if (EXPECT_TRUE (current == this))
ffffffff81005199:	48 39 05 80 9e ff 3e 	cmp    %rax,0x3eff9e80(%rip)        # ffffffffbffff020 <_ZN4Vmcs7currentE>
ffffffff810051a0:	74 38                	je     ffffffff810051da <_ZN2Ec17ret_user_vmresumeEv+0x88>
ffffffff810051a2:	48 89 c1             	mov    %rax,%rcx
                return;

            uint64 phys = Buddy::ptr_to_phys (current = this);
ffffffff810051a5:	48 89 05 74 9e ff 3e 	mov    %rax,0x3eff9e74(%rip)        # ffffffffbffff020 <_ZN4Vmcs7currentE>
ffffffff810051ac:	48 81 e9 00 00 c0 80 	sub    $0xffffffff80c00000,%rcx
ffffffff810051b3:	48 89 0c 24          	mov    %rcx,(%rsp)

            bool ret;
            asm volatile ("vmptrld %1; seta %0" : "=q" (ret) : "m" (phys) : "cc");
ffffffff810051b7:	0f c7 34 24          	vmptrld (%rsp)
ffffffff810051bb:	0f 97 c1             	seta   %cl
            assert (ret);
ffffffff810051be:	84 c9                	test   %cl,%cl
ffffffff810051c0:	75 18                	jne    ffffffff810051da <_ZN2Ec17ret_user_vmresumeEv+0x88>
ffffffff810051c2:	49 c7 c0 c0 e0 01 81 	mov    $0xffffffff8101e0c0,%r8
ffffffff810051c9:	b9 9a 01 00 00       	mov    $0x19a,%ecx
ffffffff810051ce:	48 c7 c2 72 db 01 81 	mov    $0xffffffff8101db72,%rdx
ffffffff810051d5:	e9 ce 00 00 00       	jmpq   ffffffff810052a8 <_ZN2Ec17ret_user_vmresumeEv+0x156>
    void restore_state();

    void rollback();

    void save_state() {
        regs_0 = regs;
ffffffff810051da:	48 8d ba 98 01 00 00 	lea    0x198(%rdx),%rdi
ffffffff810051e1:	48 8d b2 a8 00 00 00 	lea    0xa8(%rdx),%rsi
ffffffff810051e8:	b9 3c 00 00 00       	mov    $0x3c,%ecx
ffffffff810051ed:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
        memcpy(vmcb_backup, regs.vmcb, PAGE_SIZE);
    }

    void vmx_save_state() {
        save_state();
        memcpy(vmcs_backup, regs.vmcs, PAGE_SIZE);
ffffffff810051ef:	48 89 c6             	mov    %rax,%rsi
ffffffff810051f2:	48 8b ba d8 02 00 00 	mov    0x2d8(%rdx),%rdi
ffffffff810051f9:	ba 00 10 00 00       	mov    $0x1000,%edx
ffffffff810051fe:	e8 5f 1c 01 00       	callq  ffffffff81016e62 <memcpy>

        current->vmx_save_state();
        current->launch_state = Ec::vmresume;
ffffffff81005203:	48 8b 05 fe 9d ff 3e 	mov    0x3eff9dfe(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100520a:	c7 80 4c 03 00 00 03 	movl   $0x3,0x34c(%rax)
ffffffff81005211:	00 00 00 
    }
    
    if (EXPECT_FALSE(Pd::current->gtlb.chk(Cpu::id))) {
ffffffff81005214:	48 8b 05 f5 9d ff 3e 	mov    0x3eff9df5(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
ffffffff8100521b:	8b 0d e3 9d ff 3e    	mov    0x3eff9de3(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81005221:	48 8b 90 d0 02 00 00 	mov    0x2d0(%rax),%rdx
ffffffff81005228:	48 0f a3 ca          	bt     %rcx,%rdx
ffffffff8100522c:	0f 83 9c 00 00 00    	jae    ffffffff810052ce <_ZN2Ec17ret_user_vmresumeEv+0x17c>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
ffffffff81005232:	ba 01 00 00 00       	mov    $0x1,%edx
ffffffff81005237:	48 89 d6             	mov    %rdx,%rsi
ffffffff8100523a:	48 d3 e6             	shl    %cl,%rsi
ffffffff8100523d:	48 89 f1             	mov    %rsi,%rcx
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
ffffffff81005240:	48 f7 d1             	not    %rcx
ffffffff81005243:	f0 48 21 88 d0 02 00 	lock and %rcx,0x2d0(%rax)
ffffffff8100524a:	00 
        Pd::current->gtlb.clr(Cpu::id);
        if (current->regs.nst_on)
ffffffff8100524b:	48 8b 05 b6 9d ff 3e 	mov    0x3eff9db6(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81005252:	80 b8 68 01 00 00 00 	cmpb   $0x0,0x168(%rax)
ffffffff81005259:	74 62                	je     ffffffff810052bd <_ZN2Ec17ret_user_vmresumeEv+0x16b>
        return static_cast<mword> (val) & PAGE_MASK;
    }

    ALWAYS_INLINE
    inline Paddr addr() const {
        return static_cast<Paddr> (val) & ~((1UL << order()) - 1);
ffffffff8100525b:	48 8b 05 ae 9d ff 3e 	mov    0x3eff9dae(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
    ALWAYS_INLINE
    inline void flush() {

        struct {
            uint64 eptp, rsvd;
        } desc = {addr() | (max() - 1) << 3 | 6, 0};
ffffffff81005262:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
ffffffff81005269:	00 
ffffffff8100526a:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
ffffffff81005271:	00 00 
ffffffff81005273:	48 8b 80 b0 02 00 00 	mov    0x2b0(%rax),%rax
ffffffff8100527a:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81005280:	48 83 c8 1e          	or     $0x1e,%rax
ffffffff81005284:	48 89 04 24          	mov    %rax,(%rsp)

        bool ret;
        asm volatile ("invept %1, %2; seta %0" : "=q" (ret) : "m" (desc), "r" (1UL) : "cc", "memory");
ffffffff81005288:	66 0f 38 80 14 24    	invept (%rsp),%rdx
ffffffff8100528e:	0f 97 c2             	seta   %dl
        assert(ret);
ffffffff81005291:	84 d2                	test   %dl,%dl
ffffffff81005293:	75 39                	jne    ffffffff810052ce <_ZN2Ec17ret_user_vmresumeEv+0x17c>
ffffffff81005295:	49 c7 c0 40 e0 01 81 	mov    $0xffffffff8101e040,%r8
ffffffff8100529c:	b9 47 00 00 00       	mov    $0x47,%ecx
ffffffff810052a1:	48 c7 c2 2e de 01 81 	mov    $0xffffffff8101de2e,%rdx
ffffffff810052a8:	48 c7 c6 e1 db 01 81 	mov    $0xffffffff8101dbe1,%rsi
ffffffff810052af:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff810052b6:	31 c0                	xor    %eax,%eax
ffffffff810052b8:	e8 93 cc ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
            Pd::current->ept.flush();
        else
            current->regs.vtlb->flush(true);
ffffffff810052bd:	48 8b b8 30 01 00 00 	mov    0x130(%rax),%rdi
ffffffff810052c4:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff810052c9:	e8 8a 7a 01 00       	callq  ffffffff8101cd58 <_ZN4Vtlb5flushEb>

ALWAYS_INLINE
static inline mword get_cr2()
{
    mword cr2;
    asm volatile ("mov %%cr2, %0" : "=r" (cr2));
ffffffff810052ce:	0f 20 d2             	mov    %cr2,%rdx
    }

    if (EXPECT_FALSE(get_cr2() != current->regs.cr2))
ffffffff810052d1:	48 8b 3d 30 9d ff 3e 	mov    0x3eff9d30(%rip),%rdi        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff810052d8:	48 8b 87 00 01 00 00 	mov    0x100(%rdi),%rax
ffffffff810052df:	48 39 c2             	cmp    %rax,%rdx
ffffffff810052e2:	74 03                	je     ffffffff810052e7 <_ZN2Ec17ret_user_vmresumeEv+0x195>
}

ALWAYS_INLINE
static inline void set_cr2 (mword cr2)
{
    asm volatile ("mov %0, %%cr2" : : "r" (cr2));
ffffffff810052e4:	0f 22 d0             	mov    %rax,%cr2
        set_cr2(current->regs.cr2);
    current->regs.disable_rdtsc<Vmcs>();
ffffffff810052e7:	48 81 c7 a8 00 00 00 	add    $0xa8,%rdi
ffffffff810052ee:	e8 ef e5 00 00       	callq  ffffffff810138e2 <_ZN8Exc_regs13disable_rdtscI4VmcsEEvv>
    asm volatile ("lea %0," EXPAND(PREG(sp); LOAD_GPR)
                "vmresume;"
                "vmlaunch;"
                "mov %1," EXPAND(PREG(sp);)
                : : "m" (current->regs), "i" (CPU_LOCAL_STCK + PAGE_SIZE) : "memory");
ffffffff810052f3:	48 8b 05 0e 9d ff 3e 	mov    0x3eff9d0e(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff810052fa:	48 8d a0 a8 00 00 00 	lea    0xa8(%rax),%rsp
ffffffff81005301:	41 5f                	pop    %r15
ffffffff81005303:	41 5e                	pop    %r14
ffffffff81005305:	41 5d                	pop    %r13
ffffffff81005307:	41 5c                	pop    %r12
ffffffff81005309:	41 5b                	pop    %r11
ffffffff8100530b:	41 5a                	pop    %r10
ffffffff8100530d:	41 59                	pop    %r9
ffffffff8100530f:	41 58                	pop    %r8
ffffffff81005311:	5f                   	pop    %rdi
ffffffff81005312:	5e                   	pop    %rsi
ffffffff81005313:	5d                   	pop    %rbp
ffffffff81005314:	58                   	pop    %rax
ffffffff81005315:	5b                   	pop    %rbx
ffffffff81005316:	5a                   	pop    %rdx
ffffffff81005317:	59                   	pop    %rcx
ffffffff81005318:	58                   	pop    %rax
ffffffff81005319:	0f 01 c3             	vmresume 
ffffffff8100531c:	0f 01 c2             	vmlaunch 
ffffffff8100531f:	48 c7 c4 00 e0 ff bf 	mov    $0xffffffffbfffe000,%rsp

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
ffffffff81005326:	ba 00 44 00 00       	mov    $0x4400,%edx
ffffffff8100532b:	0f 78 d2             	vmread %rdx,%rdx

    trace(0, "VM entry failed with error %#lx", Vmcs::read(Vmcs::VMX_INST_ERROR));
ffffffff8100532e:	8b 0d d0 9c ff 3e    	mov    0x3eff9cd0(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81005334:	48 8d 44 24 ff       	lea    -0x1(%rsp),%rax
ffffffff81005339:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff8100533d:	48 c7 c7 9d de 01 81 	mov    $0xffffffff8101de9d,%rdi
ffffffff81005344:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8100534a:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff81005350:	48 0f 44 f1          	cmove  %rcx,%rsi
ffffffff81005354:	31 c0                	xor    %eax,%eax
ffffffff81005356:	e8 31 cd ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>

    die("VMENTRY");
ffffffff8100535b:	48 8b 05 a6 9c ff 3e 	mov    0x3eff9ca6(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81005362:	48 c7 c7 c4 de 01 81 	mov    $0xffffffff8101dec4,%rdi
ffffffff81005369:	48 8d b0 a8 00 00 00 	lea    0xa8(%rax),%rsi
ffffffff81005370:	e8 95 f8 ff ff       	callq  ffffffff81004c0a <_ZN2Ec3dieEPKcP8Exc_regs>
ffffffff81005375:	90                   	nop

ffffffff81005376 <_ZN2Ec11xcpu_returnEv>:
        ec->cont = ec->cont == ret_user_sysexit ? static_cast<void (*)()> (sys_finish<Sys_regs::COM_ABT>) : dead;

    reply(dead);
}

void Ec::xcpu_return() {
ffffffff81005376:	41 55                	push   %r13
ffffffff81005378:	41 54                	push   %r12
ffffffff8100537a:	55                   	push   %rbp
ffffffff8100537b:	53                   	push   %rbx
ffffffff8100537c:	48 83 ec 18          	sub    $0x18,%rsp
    assert(current->xcpu_sm);
ffffffff81005380:	48 8b 05 81 9c ff 3e 	mov    0x3eff9c81(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81005387:	48 83 b8 30 03 00 00 	cmpq   $0x0,0x330(%rax)
ffffffff8100538e:	00 
ffffffff8100538f:	75 1c                	jne    ffffffff810053ad <_ZN2Ec11xcpu_returnEv+0x37>
ffffffff81005391:	49 c7 c0 d0 df 01 81 	mov    $0xffffffff8101dfd0,%r8
ffffffff81005398:	b9 ec 01 00 00       	mov    $0x1ec,%ecx
ffffffff8100539d:	48 c7 c2 f7 dc 01 81 	mov    $0xffffffff8101dcf7,%rdx
ffffffff810053a4:	48 c7 c6 cc de 01 81 	mov    $0xffffffff8101decc,%rsi
ffffffff810053ab:	eb 26                	jmp    ffffffff810053d3 <_ZN2Ec11xcpu_returnEv+0x5d>
    assert(current->rcap);
ffffffff810053ad:	48 8b b8 88 02 00 00 	mov    0x288(%rax),%rdi
ffffffff810053b4:	48 85 ff             	test   %rdi,%rdi
ffffffff810053b7:	75 28                	jne    ffffffff810053e1 <_ZN2Ec11xcpu_returnEv+0x6b>
ffffffff810053b9:	49 c7 c0 d0 df 01 81 	mov    $0xffffffff8101dfd0,%r8
ffffffff810053c0:	b9 ed 01 00 00       	mov    $0x1ed,%ecx
ffffffff810053c5:	48 c7 c2 f7 dc 01 81 	mov    $0xffffffff8101dcf7,%rdx
ffffffff810053cc:	48 c7 c6 dd de 01 81 	mov    $0xffffffff8101dedd,%rsi
ffffffff810053d3:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff810053da:	31 c0                	xor    %eax,%eax
ffffffff810053dc:	e8 6f cb ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
    assert(current->utcb);
ffffffff810053e1:	48 83 b8 90 02 00 00 	cmpq   $0x0,0x290(%rax)
ffffffff810053e8:	00 
ffffffff810053e9:	75 1c                	jne    ffffffff81005407 <_ZN2Ec11xcpu_returnEv+0x91>
ffffffff810053eb:	49 c7 c0 d0 df 01 81 	mov    $0xffffffff8101dfd0,%r8
ffffffff810053f2:	b9 ee 01 00 00       	mov    $0x1ee,%ecx
ffffffff810053f7:	48 c7 c2 f7 dc 01 81 	mov    $0xffffffff8101dcf7,%rdx
ffffffff810053fe:	48 c7 c6 eb de 01 81 	mov    $0xffffffff8101deeb,%rsi
ffffffff81005405:	eb cc                	jmp    ffffffff810053d3 <_ZN2Ec11xcpu_returnEv+0x5d>
{
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
ffffffff81005407:	48 8b 15 0a 9c ff 3e 	mov    0x3eff9c0a(%rip),%rdx        # ffffffffbffff018 <_ZN2Sc7currentE>
ffffffff8100540e:	48 8b 92 90 00 00 00 	mov    0x90(%rdx),%rdx
    assert(Sc::current->ec == current);
ffffffff81005415:	48 39 c2             	cmp    %rax,%rdx
ffffffff81005418:	74 1c                	je     ffffffff81005436 <_ZN2Ec11xcpu_returnEv+0xc0>
ffffffff8100541a:	49 c7 c0 d0 df 01 81 	mov    $0xffffffff8101dfd0,%r8
ffffffff81005421:	b9 ef 01 00 00       	mov    $0x1ef,%ecx
ffffffff81005426:	48 c7 c2 f7 dc 01 81 	mov    $0xffffffff8101dcf7,%rdx
ffffffff8100542d:	48 c7 c6 f9 de 01 81 	mov    $0xffffffff8101def9,%rsi
ffffffff81005434:	eb 9d                	jmp    ffffffff810053d3 <_ZN2Ec11xcpu_returnEv+0x5d>

    current->rcap->regs = current->regs;
ffffffff81005436:	48 81 c7 a8 00 00 00 	add    $0xa8,%rdi
ffffffff8100543d:	48 8d b2 a8 00 00 00 	lea    0xa8(%rdx),%rsi
ffffffff81005444:	b9 3c 00 00 00       	mov    $0x3c,%ecx
ffffffff81005449:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)

    current->xcpu_sm->up(ret_xcpu_reply);
ffffffff8100544b:	48 8b aa 30 03 00 00 	mov    0x330(%rdx),%rbp
        ALWAYS_INLINE
        inline void up (void (*c)() = nullptr, Sm * si = nullptr)
        {
            Ec *ec;

            {   Lock_guard <Spinlock> guard (lock);
ffffffff81005452:	48 8d bd 8a 00 00 00 	lea    0x8a(%rbp),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81005459:	9c                   	pushfq 
ffffffff8100545a:	41 5c                	pop    %r12
            return flags & 0x200;
ffffffff8100545c:	49 c1 ec 09          	shr    $0x9,%r12

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff81005460:	41 80 e4 01          	and    $0x1,%r12b
ffffffff81005464:	74 30                	je     ffffffff81005496 <_ZN2Ec11xcpu_returnEv+0x120>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81005466:	80 3d c3 a2 ff 3e 00 	cmpb   $0x0,0x3effa2c3(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100546d:	75 1f                	jne    ffffffff8100548e <_ZN2Ec11xcpu_returnEv+0x118>
ffffffff8100546f:	49 c7 c0 90 e0 01 81 	mov    $0xffffffff8101e090,%r8
ffffffff81005476:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff8100547b:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81005482:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff81005489:	e9 45 ff ff ff       	jmpq   ffffffff810053d3 <_ZN2Ec11xcpu_returnEv+0x5d>

            asm volatile ("cli" : : : "memory");
ffffffff8100548e:	fa                   	cli    
            preemption = false;
ffffffff8100548f:	c6 05 9a a2 ff 3e 00 	movb   $0x0,0x3effa29a(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff81005496:	e8 f3 b9 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff8100549b:	48 8b 9d 90 00 00 00 	mov    0x90(%rbp),%rbx
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff810054a2:	48 85 db             	test   %rbx,%rbx
ffffffff810054a5:	0f 84 1e 02 00 00    	je     ffffffff810056c9 <_ZN2Ec11xcpu_returnEv+0x353>
ffffffff810054ab:	48 8b 83 b0 02 00 00 	mov    0x2b0(%rbx),%rax
ffffffff810054b2:	48 85 c0             	test   %rax,%rax
ffffffff810054b5:	0f 84 0e 02 00 00    	je     ffffffff810056c9 <_ZN2Ec11xcpu_returnEv+0x353>
ffffffff810054bb:	48 8b 93 a8 02 00 00 	mov    0x2a8(%rbx),%rdx
ffffffff810054c2:	48 85 d2             	test   %rdx,%rdx
ffffffff810054c5:	0f 84 fe 01 00 00    	je     ffffffff810056c9 <_ZN2Ec11xcpu_returnEv+0x353>
                return false;

            if (t == t->next)
ffffffff810054cb:	48 39 c3             	cmp    %rax,%rbx
ffffffff810054ce:	75 0d                	jne    ffffffff810054dd <_ZN2Ec11xcpu_returnEv+0x167>
                headptr = nullptr;
ffffffff810054d0:	48 c7 85 90 00 00 00 	movq   $0x0,0x90(%rbp)
ffffffff810054d7:	00 00 00 00 
ffffffff810054db:	eb 33                	jmp    ffffffff81005510 <_ZN2Ec11xcpu_returnEv+0x19a>

            else {
                t->next->prev = t->prev;
ffffffff810054dd:	48 89 90 a8 02 00 00 	mov    %rdx,0x2a8(%rax)
                t->prev->next = t->next;
ffffffff810054e4:	48 8b 83 a8 02 00 00 	mov    0x2a8(%rbx),%rax
ffffffff810054eb:	48 8b 93 b0 02 00 00 	mov    0x2b0(%rbx),%rdx
ffffffff810054f2:	48 89 90 b0 02 00 00 	mov    %rdx,0x2b0(%rax)
                if (t == headptr)
ffffffff810054f9:	48 3b 9d 90 00 00 00 	cmp    0x90(%rbp),%rbx
ffffffff81005500:	75 0e                	jne    ffffffff81005510 <_ZN2Ec11xcpu_returnEv+0x19a>
                    headptr = t->next;
ffffffff81005502:	48 8b 83 b0 02 00 00 	mov    0x2b0(%rbx),%rax
ffffffff81005509:	48 89 85 90 00 00 00 	mov    %rax,0x90(%rbp)
        }

        ALWAYS_INLINE
        inline bool del_ref()
        {
            return Atomic::sub (ref, 1U) == 0;
ffffffff81005510:	4c 8d ab 8c 00 00 00 	lea    0x8c(%rbx),%r13
            }

            t->next = t->prev = nullptr;
ffffffff81005517:	48 c7 83 a8 02 00 00 	movq   $0x0,0x2a8(%rbx)
ffffffff8100551e:	00 00 00 00 
ffffffff81005522:	48 c7 83 b0 02 00 00 	movq   $0x0,0x2b0(%rbx)
ffffffff81005529:	00 00 00 00 
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff8100552d:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff81005530:	f0 41 0f c1 45 00    	lock xadd %eax,0x0(%r13)

                    counter++;
                    return;
                }

                if (EXPECT_FALSE(ec->del_ref())) {
ffffffff81005536:	ff c8                	dec    %eax
ffffffff81005538:	75 2a                	jne    ffffffff81005564 <_ZN2Ec11xcpu_returnEv+0x1ee>
                    delete ec;
ffffffff8100553a:	48 89 df             	mov    %rbx,%rdi
ffffffff8100553d:	e8 fa ee ff ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff81005542:	48 8b 83 98 02 00 00 	mov    0x298(%rbx),%rax
ffffffff81005549:	48 89 de             	mov    %rbx,%rsi
ffffffff8100554c:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff81005553:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff8100555a:	e8 0b 05 01 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
ffffffff8100555f:	e9 37 ff ff ff       	jmpq   ffffffff8100549b <_ZN2Ec11xcpu_returnEv+0x125>
        }

        ALWAYS_INLINE
        inline void unlock()
        {
            asm volatile ("incb %0" : "=m" (val) : : "memory");
ffffffff81005564:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff8100556a:	45 84 e4             	test   %r12b,%r12b
ffffffff8100556d:	74 30                	je     ffffffff8100559f <_ZN2Ec11xcpu_returnEv+0x229>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100556f:	80 3d ba a1 ff 3e 00 	cmpb   $0x0,0x3effa1ba(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81005576:	74 1f                	je     ffffffff81005597 <_ZN2Ec11xcpu_returnEv+0x221>
ffffffff81005578:	49 c7 c0 60 e0 01 81 	mov    $0xffffffff8101e060,%r8
ffffffff8100557f:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff81005584:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100558b:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff81005592:	e9 3c fe ff ff       	jmpq   ffffffff810053d3 <_ZN2Ec11xcpu_returnEv+0x5d>

            preemption = true;
ffffffff81005597:	c6 05 92 a1 ff 3e 01 	movb   $0x1,0x3effa192(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100559e:	fb                   	sti    
    }

    ALWAYS_INLINE
    inline void release(void (*c)()) {
        if (c)
            cont = c;
ffffffff8100559f:	48 c7 83 a0 00 00 00 	movq   $0xffffffff81017234,0xa0(%rbx)
ffffffff810055a6:	34 72 01 81 

        Lock_guard <Spinlock> guard(lock);
ffffffff810055aa:	48 8d bb 8a 00 00 00 	lea    0x8a(%rbx),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff810055b1:	9c                   	pushfq 
ffffffff810055b2:	58                   	pop    %rax
            return flags & 0x200;
ffffffff810055b3:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff810055b7:	41 88 c4             	mov    %al,%r12b
ffffffff810055ba:	41 80 e4 01          	and    $0x1,%r12b
ffffffff810055be:	74 15                	je     ffffffff810055d5 <_ZN2Ec11xcpu_returnEv+0x25f>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff810055c0:	80 3d 69 a1 ff 3e 00 	cmpb   $0x0,0x3effa169(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff810055c7:	0f 84 a2 fe ff ff    	je     ffffffff8100546f <_ZN2Ec11xcpu_returnEv+0xf9>

            asm volatile ("cli" : : : "memory");
ffffffff810055cd:	fa                   	cli    
            preemption = false;
ffffffff810055ce:	c6 05 5b a1 ff 3e 00 	movb   $0x0,0x3effa15b(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff810055d5:	e8 b4 b8 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff810055da:	48 8b ab 90 00 00 00 	mov    0x90(%rbx),%rbp
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff810055e1:	48 85 ed             	test   %rbp,%rbp
ffffffff810055e4:	0f 84 fb 00 00 00    	je     ffffffff810056e5 <_ZN2Ec11xcpu_returnEv+0x36f>
ffffffff810055ea:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff810055f1:	48 85 c0             	test   %rax,%rax
ffffffff810055f4:	0f 84 eb 00 00 00    	je     ffffffff810056e5 <_ZN2Ec11xcpu_returnEv+0x36f>
ffffffff810055fa:	48 8b 95 b8 00 00 00 	mov    0xb8(%rbp),%rdx
ffffffff81005601:	48 85 d2             	test   %rdx,%rdx
ffffffff81005604:	0f 84 db 00 00 00    	je     ffffffff810056e5 <_ZN2Ec11xcpu_returnEv+0x36f>
                return false;

            if (t == t->next)
ffffffff8100560a:	48 39 c5             	cmp    %rax,%rbp
ffffffff8100560d:	75 0d                	jne    ffffffff8100561c <_ZN2Ec11xcpu_returnEv+0x2a6>
                headptr = nullptr;
ffffffff8100560f:	48 c7 83 90 00 00 00 	movq   $0x0,0x90(%rbx)
ffffffff81005616:	00 00 00 00 
ffffffff8100561a:	eb 33                	jmp    ffffffff8100564f <_ZN2Ec11xcpu_returnEv+0x2d9>

            else {
                t->next->prev = t->prev;
ffffffff8100561c:	48 89 90 b8 00 00 00 	mov    %rdx,0xb8(%rax)
                t->prev->next = t->next;
ffffffff81005623:	48 8b 85 b8 00 00 00 	mov    0xb8(%rbp),%rax
ffffffff8100562a:	48 8b 95 c0 00 00 00 	mov    0xc0(%rbp),%rdx
ffffffff81005631:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
                if (t == headptr)
ffffffff81005638:	48 3b ab 90 00 00 00 	cmp    0x90(%rbx),%rbp
ffffffff8100563f:	75 0e                	jne    ffffffff8100564f <_ZN2Ec11xcpu_returnEv+0x2d9>
                    headptr = t->next;
ffffffff81005641:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff81005648:	48 89 83 90 00 00 00 	mov    %rax,0x90(%rbx)
            }

            t->next = t->prev = nullptr;
ffffffff8100564f:	48 c7 85 b8 00 00 00 	movq   $0x0,0xb8(%rbp)
ffffffff81005656:	00 00 00 00 
ffffffff8100565a:	48 c7 85 c0 00 00 00 	movq   $0x0,0xc0(%rbp)
ffffffff81005661:	00 00 00 00 
ffffffff81005665:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff81005668:	f0 0f c1 85 8c 00 00 	lock xadd %eax,0x8c(%rbp)
ffffffff8100566f:	00 

        for (Sc *s; dequeue(s = head());) {
            if (EXPECT_FALSE(s->del_ref()) && (this == s->ec)) {
ffffffff81005670:	ff c8                	dec    %eax
ffffffff81005672:	75 64                	jne    ffffffff810056d8 <_ZN2Ec11xcpu_returnEv+0x362>
ffffffff81005674:	48 3b 9d 90 00 00 00 	cmp    0x90(%rbp),%rbx
ffffffff8100567b:	75 5b                	jne    ffffffff810056d8 <_ZN2Ec11xcpu_returnEv+0x362>
ffffffff8100567d:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff81005680:	f0 41 0f c1 45 00    	lock xadd %eax,0x0(%r13)
        inline Refptr (T *p) : ptr (p->add_ref() ? p : nullptr) {}

        ALWAYS_INLINE
        inline ~Refptr()
        {
            if (ptr && ptr->del_ref())
ffffffff81005686:	ff c8                	dec    %eax
ffffffff81005688:	75 32                	jne    ffffffff810056bc <_ZN2Ec11xcpu_returnEv+0x346>
                delete ptr;
ffffffff8100568a:	48 8b bd 90 00 00 00 	mov    0x90(%rbp),%rdi
ffffffff81005691:	48 85 ff             	test   %rdi,%rdi
ffffffff81005694:	74 26                	je     ffffffff810056bc <_ZN2Ec11xcpu_returnEv+0x346>
ffffffff81005696:	e8 a1 ed ff ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
ffffffff8100569b:	48 8b b5 90 00 00 00 	mov    0x90(%rbp),%rsi
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff810056a2:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff810056a9:	48 8b 86 98 02 00 00 	mov    0x298(%rsi),%rax
ffffffff810056b0:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff810056b7:	e8 ae 03 01 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>

        Lock_guard <Spinlock> guard(lock);

        for (Sc *s; dequeue(s = head());) {
            if (EXPECT_FALSE(s->del_ref()) && (this == s->ec)) {
                delete s;
ffffffff810056bc:	48 89 ef             	mov    %rbp,%rdi
ffffffff810056bf:	e8 66 f6 00 00       	callq  ffffffff81014d2a <_ZN2ScdlEPv>
ffffffff810056c4:	e9 11 ff ff ff       	jmpq   ffffffff810055da <_ZN2Ec11xcpu_returnEv+0x264>
                    if (si) {
                       if (si->queued()) return;
                       Queue<Si>::enqueue(si);
                    }

                    counter++;
ffffffff810056c9:	48 ff 85 c0 00 00 00 	incq   0xc0(%rbp)
ffffffff810056d0:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
ffffffff810056d6:	eb 13                	jmp    ffffffff810056eb <_ZN2Ec11xcpu_returnEv+0x375>
                continue;
            }
            s->remote_enqueue();
ffffffff810056d8:	48 89 ef             	mov    %rbp,%rdi
ffffffff810056db:	e8 80 f3 00 00       	callq  ffffffff81014a60 <_ZN2Sc14remote_enqueueEv>
ffffffff810056e0:	e9 f5 fe ff ff       	jmpq   ffffffff810055da <_ZN2Ec11xcpu_returnEv+0x264>
ffffffff810056e5:	fe 83 8a 00 00 00    	incb   0x8a(%rbx)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff810056eb:	45 84 e4             	test   %r12b,%r12b
ffffffff810056ee:	74 15                	je     ffffffff81005705 <_ZN2Ec11xcpu_returnEv+0x38f>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff810056f0:	80 3d 39 a0 ff 3e 00 	cmpb   $0x0,0x3effa039(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff810056f7:	0f 85 7b fe ff ff    	jne    ffffffff81005578 <_ZN2Ec11xcpu_returnEv+0x202>

            preemption = true;
ffffffff810056fd:	c6 05 2c a0 ff 3e 01 	movb   $0x1,0x3effa02c(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81005704:	fb                   	sti    

    current->rcap = nullptr;
ffffffff81005705:	48 8b 1d fc 98 ff 3e 	mov    0x3eff98fc(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
ffffffff8100570c:	48 8b 43 28          	mov    0x28(%rbx),%rax
ffffffff81005710:	48 c7 83 88 02 00 00 	movq   $0x0,0x288(%rbx)
ffffffff81005717:	00 00 00 00 
    current->utcb = nullptr;
    current->fpu = nullptr;

    Rcu::call(current);
ffffffff8100571b:	48 8d 6b 18          	lea    0x18(%rbx),%rbp
    current->rcap->regs = current->regs;

    current->xcpu_sm->up(ret_xcpu_reply);

    current->rcap = nullptr;
    current->utcb = nullptr;
ffffffff8100571f:	48 c7 83 90 02 00 00 	movq   $0x0,0x290(%rbx)
ffffffff81005726:	00 00 00 00 
    current->fpu = nullptr;
ffffffff8100572a:	48 c7 83 b8 02 00 00 	movq   $0x0,0x2b8(%rbx)
ffffffff81005731:	00 00 00 00 
ffffffff81005735:	48 85 c0             	test   %rax,%rax
ffffffff81005738:	74 05                	je     ffffffff8100573f <_ZN2Ec11xcpu_returnEv+0x3c9>
                e->pre_func(e);
ffffffff8100573a:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100573d:	ff d0                	callq  *%rax
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
ffffffff8100573f:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
ffffffff81005744:	75 0c                	jne    ffffffff81005752 <_ZN2Ec11xcpu_returnEv+0x3dc>
ffffffff81005746:	48 8b 05 1b a1 ff 3e 	mov    0x3effa11b(%rip),%rax        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff8100574d:	48 39 e8             	cmp    %rbp,%rax
ffffffff81005750:	75 2f                	jne    ffffffff81005781 <_ZN2Ec11xcpu_returnEv+0x40b>
                trace (0, "warning: rcu element already enqueued");
ffffffff81005752:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff81005757:	8b 15 a7 98 ff 3e    	mov    0x3eff98a7(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100575d:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81005761:	48 c7 c7 14 df 01 81 	mov    $0xffffffff8101df14,%rdi
ffffffff81005768:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8100576e:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff81005774:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff81005778:	31 c0                	xor    %eax,%eax
ffffffff8100577a:	e8 0d c9 ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff8100577f:	eb 11                	jmp    ffffffff81005792 <_ZN2Ec11xcpu_returnEv+0x41c>
                return;
            }

            count ++;
ffffffff81005781:	48 ff 05 e8 a0 ff 3e 	incq   0x3effa0e8(%rip)        # ffffffffbffff870 <_ZN3Rcu4nextE+0x10>

           *tail = e;
ffffffff81005788:	48 89 28             	mov    %rbp,(%rax)
            tail = &e->next;
ffffffff8100578b:	48 89 2d d6 a0 ff 3e 	mov    %rbp,0x3effa0d6(%rip)        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>

    Rcu::call(current);
    Rcu::call(Sc::current);
ffffffff81005792:	48 8b 2d 7f 98 ff 3e 	mov    0x3eff987f(%rip),%rbp        # ffffffffbffff018 <_ZN2Sc7currentE>
ffffffff81005799:	48 85 ed             	test   %rbp,%rbp
ffffffff8100579c:	74 74                	je     ffffffff81005812 <_ZN2Ec11xcpu_returnEv+0x49c>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
ffffffff8100579e:	48 8b 45 28          	mov    0x28(%rbp),%rax
ffffffff810057a2:	48 8d 5d 18          	lea    0x18(%rbp),%rbx
ffffffff810057a6:	48 85 c0             	test   %rax,%rax
ffffffff810057a9:	74 05                	je     ffffffff810057b0 <_ZN2Ec11xcpu_returnEv+0x43a>
                e->pre_func(e);
ffffffff810057ab:	48 89 df             	mov    %rbx,%rdi
ffffffff810057ae:	ff d0                	callq  *%rax
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
ffffffff810057b0:	48 83 7d 18 00       	cmpq   $0x0,0x18(%rbp)
ffffffff810057b5:	75 0c                	jne    ffffffff810057c3 <_ZN2Ec11xcpu_returnEv+0x44d>
ffffffff810057b7:	48 8b 05 aa a0 ff 3e 	mov    0x3effa0aa(%rip),%rax        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff810057be:	48 39 d8             	cmp    %rbx,%rax
ffffffff810057c1:	75 2f                	jne    ffffffff810057f2 <_ZN2Ec11xcpu_returnEv+0x47c>
                trace (0, "warning: rcu element already enqueued");
ffffffff810057c3:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff810057c8:	8b 15 36 98 ff 3e    	mov    0x3eff9836(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff810057ce:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff810057d2:	48 c7 c7 14 df 01 81 	mov    $0xffffffff8101df14,%rdi
ffffffff810057d9:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff810057df:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff810057e5:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff810057e9:	31 c0                	xor    %eax,%eax
ffffffff810057eb:	e8 9c c8 ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff810057f0:	eb 11                	jmp    ffffffff81005803 <_ZN2Ec11xcpu_returnEv+0x48d>
                return;
            }

            count ++;
ffffffff810057f2:	48 ff 05 77 a0 ff 3e 	incq   0x3effa077(%rip)        # ffffffffbffff870 <_ZN3Rcu4nextE+0x10>

           *tail = e;
ffffffff810057f9:	48 89 18             	mov    %rbx,(%rax)
            tail = &e->next;
ffffffff810057fc:	48 89 1d 65 a0 ff 3e 	mov    %rbx,0x3effa065(%rip)        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>

    Sc::schedule(true);
ffffffff81005803:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff81005808:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff8100580d:	e8 a2 f5 00 00       	callq  ffffffff81014db4 <_ZN2Sc8scheduleEbb>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
ffffffff81005812:	48 8b 04 25 10 00 00 	mov    0x10,%rax
ffffffff81005819:	00 
ffffffff8100581a:	0f 0b                	ud2    

ffffffff8100581c <_ZN2Ec11idl_handlerEv>:
}

void Ec::idl_handler() {
    if (Ec::current->cont == Ec::idle)
ffffffff8100581c:	48 8b 05 e5 97 ff 3e 	mov    0x3eff97e5(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81005823:	48 81 b8 a0 00 00 00 	cmpq   $0xffffffff81004a4c,0xa0(%rax)
ffffffff8100582a:	4c 4a 00 81 
ffffffff8100582e:	75 05                	jne    ffffffff81005835 <_ZN2Ec11idl_handlerEv+0x19>
        Rcu::update();
ffffffff81005830:	e9 65 d7 00 00       	jmpq   ffffffff81012f9a <_ZN3Rcu6updateEv>
ffffffff81005835:	c3                   	retq   

ffffffff81005836 <_ZN2Ec7add_cowEPN3Cow7cow_eltE>:
}

void Ec::add_cow(Cow::cow_elt *ce) {
ffffffff81005836:	41 54                	push   %r12
ffffffff81005838:	49 89 f4             	mov    %rsi,%r12
ffffffff8100583b:	55                   	push   %rbp
ffffffff8100583c:	48 89 fd             	mov    %rdi,%rbp
ffffffff8100583f:	53                   	push   %rbx
    Lock_guard <Spinlock> guard(cow_lock);
ffffffff81005840:	48 8d bf 48 03 00 00 	lea    0x348(%rdi),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81005847:	9c                   	pushfq 
ffffffff81005848:	58                   	pop    %rax
            return flags & 0x200;
ffffffff81005849:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8100584d:	88 c3                	mov    %al,%bl
ffffffff8100584f:	80 e3 01             	and    $0x1,%bl
ffffffff81005852:	74 2d                	je     ffffffff81005881 <_ZN2Ec7add_cowEPN3Cow7cow_eltE+0x4b>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81005854:	80 3d d5 9e ff 3e 00 	cmpb   $0x0,0x3eff9ed5(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100585b:	75 1c                	jne    ffffffff81005879 <_ZN2Ec7add_cowEPN3Cow7cow_eltE+0x43>
ffffffff8100585d:	49 c7 c0 90 e0 01 81 	mov    $0xffffffff8101e090,%r8
ffffffff81005864:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff81005869:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81005870:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff81005877:	eb 4d                	jmp    ffffffff810058c6 <_ZN2Ec7add_cowEPN3Cow7cow_eltE+0x90>

            asm volatile ("cli" : : : "memory");
ffffffff81005879:	fa                   	cli    
            preemption = false;
ffffffff8100587a:	c6 05 af 9e ff 3e 00 	movb   $0x0,0x3eff9eaf(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff81005881:	e8 08 b6 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    Cow::cow_elt *tampon = cow_list;
ffffffff81005886:	48 8b 85 40 03 00 00 	mov    0x340(%rbp),%rax
    cow_list = ce;
ffffffff8100588d:	4c 89 a5 40 03 00 00 	mov    %r12,0x340(%rbp)
    ce->next = tampon;
ffffffff81005894:	49 89 44 24 38       	mov    %rax,0x38(%r12)
ffffffff81005899:	fe 85 48 03 00 00    	incb   0x348(%rbp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff8100589f:	84 db                	test   %bl,%bl
ffffffff810058a1:	74 39                	je     ffffffff810058dc <_ZN2Ec7add_cowEPN3Cow7cow_eltE+0xa6>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff810058a3:	80 3d 86 9e ff 3e 00 	cmpb   $0x0,0x3eff9e86(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff810058aa:	74 28                	je     ffffffff810058d4 <_ZN2Ec7add_cowEPN3Cow7cow_eltE+0x9e>
ffffffff810058ac:	49 c7 c0 60 e0 01 81 	mov    $0xffffffff8101e060,%r8
ffffffff810058b3:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff810058b8:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff810058bf:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff810058c6:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff810058cd:	31 c0                	xor    %eax,%eax
ffffffff810058cf:	e8 7c c6 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            preemption = true;
ffffffff810058d4:	c6 05 55 9e ff 3e 01 	movb   $0x1,0x3eff9e55(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff810058db:	fb                   	sti    
}
ffffffff810058dc:	5b                   	pop    %rbx
ffffffff810058dd:	5d                   	pop    %rbp
ffffffff810058de:	41 5c                	pop    %r12
ffffffff810058e0:	c3                   	retq   
ffffffff810058e1:	90                   	nop

ffffffff810058e2 <_ZN2Ec13restore_stateEv>:

void Ec::restore_state() {
ffffffff810058e2:	41 55                	push   %r13
ffffffff810058e4:	41 54                	push   %r12
ffffffff810058e6:	55                   	push   %rbp
ffffffff810058e7:	53                   	push   %rbx
ffffffff810058e8:	48 89 fd             	mov    %rdi,%rbp
    Lock_guard <Spinlock> guard(cow_lock);
ffffffff810058eb:	48 8d bf 48 03 00 00 	lea    0x348(%rdi),%rdi
    Cow::cow_elt *tampon = cow_list;
    cow_list = ce;
    ce->next = tampon;
}

void Ec::restore_state() {
ffffffff810058f2:	48 83 ec 38          	sub    $0x38,%rsp

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff810058f6:	9c                   	pushfq 
ffffffff810058f7:	58                   	pop    %rax
            return flags & 0x200;
ffffffff810058f8:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff810058fc:	41 88 c4             	mov    %al,%r12b
ffffffff810058ff:	41 80 e4 01          	and    $0x1,%r12b
ffffffff81005903:	74 30                	je     ffffffff81005935 <_ZN2Ec13restore_stateEv+0x53>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81005905:	80 3d 24 9e ff 3e 00 	cmpb   $0x0,0x3eff9e24(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100590c:	75 1f                	jne    ffffffff8100592d <_ZN2Ec13restore_stateEv+0x4b>
ffffffff8100590e:	49 c7 c0 90 e0 01 81 	mov    $0xffffffff8101e090,%r8
ffffffff81005915:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff8100591a:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81005921:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff81005928:	e9 9b 01 00 00       	jmpq   ffffffff81005ac8 <_ZN2Ec13restore_stateEv+0x1e6>

            asm volatile ("cli" : : : "memory");
ffffffff8100592d:	fa                   	cli    
            preemption = false;
ffffffff8100592e:	c6 05 fb 9d ff 3e 00 	movb   $0x0,0x3eff9dfb(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff81005935:	e8 54 b5 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    Lock_guard <Spinlock> guard(cow_lock);
    Cow::cow_elt *cow = current->cow_list;
    if (user_utcb) {
ffffffff8100593a:	48 83 bd 28 03 00 00 	cmpq   $0x0,0x328(%rbp)
ffffffff81005941:	00 
    ce->next = tampon;
}

void Ec::restore_state() {
    Lock_guard <Spinlock> guard(cow_lock);
    Cow::cow_elt *cow = current->cow_list;
ffffffff81005942:	48 8b 05 bf 96 ff 3e 	mov    0x3eff96bf(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81005949:	48 8b 98 40 03 00 00 	mov    0x340(%rax),%rbx
    if (user_utcb) {
ffffffff81005950:	74 6a                	je     ffffffff810059bc <_ZN2Ec13restore_stateEv+0xda>
        Quota quota = Pd::current->quota;
ffffffff81005952:	48 8b 05 b7 96 ff 3e 	mov    0x3eff96b7(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81005959:	48 8d 7c 24 08       	lea    0x8(%rsp),%rdi
ffffffff8100595e:	b9 0a 00 00 00       	mov    $0xa,%ecx
ffffffff81005963:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff8100596a:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
        while (cow != nullptr) {
ffffffff8100596c:	48 85 db             	test   %rbx,%rbx
ffffffff8100596f:	0f 84 13 01 00 00    	je     ffffffff81005a88 <_ZN2Ec13restore_stateEv+0x1a6>
            mword v = cow->page_addr_or_gpa;
            Pd::current->Space_mem::loc[Cpu::id].update(quota, v, 0, cow->new_phys[1]->phys_addr, cow->attr | Hpt::HPT_W, Hpt::TYPE_UP, true);
ffffffff81005975:	48 8b 43 28          	mov    0x28(%rbx),%rax
ffffffff81005979:	8b 0d 85 96 ff 3e    	mov    0x3eff9685(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100597f:	48 8b 15 8a 96 ff 3e 	mov    0x3eff968a(%rip),%rdx        # ffffffffbffff010 <_ZN2Pd7currentE>
    Lock_guard <Spinlock> guard(cow_lock);
    Cow::cow_elt *cow = current->cow_list;
    if (user_utcb) {
        Quota quota = Pd::current->quota;
        while (cow != nullptr) {
            mword v = cow->page_addr_or_gpa;
ffffffff81005986:	4c 8b 2b             	mov    (%rbx),%r13
            Pd::current->Space_mem::loc[Cpu::id].update(quota, v, 0, cow->new_phys[1]->phys_addr, cow->attr | Hpt::HPT_W, Hpt::TYPE_UP, true);
ffffffff81005989:	4c 8b 4b 18          	mov    0x18(%rbx),%r9
ffffffff8100598d:	6a 01                	pushq  $0x1
ffffffff8100598f:	6a 00                	pushq  $0x0
ffffffff81005991:	4c 8b 00             	mov    (%rax),%r8
ffffffff81005994:	48 8d bc ca a0 00 00 	lea    0xa0(%rdx,%rcx,8),%rdi
ffffffff8100599b:	00 
ffffffff8100599c:	31 c9                	xor    %ecx,%ecx
ffffffff8100599e:	4c 89 ea             	mov    %r13,%rdx
ffffffff810059a1:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi
ffffffff810059a6:	49 83 c9 02          	or     $0x2,%r9
ffffffff810059aa:	e8 67 d3 00 00       	callq  ffffffff81012d16 <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb>

public:

    ALWAYS_INLINE
    static inline void flush(mword addr) {
        asm volatile ("invlpg %0" : : "m" (*reinterpret_cast<mword *> (addr)));
ffffffff810059af:	41 0f 01 7d 00       	invlpg 0x0(%r13)
ffffffff810059b4:	58                   	pop    %rax
            Hpt::cow_flush(v);
            cow = cow->next;
ffffffff810059b5:	48 8b 5b 38          	mov    0x38(%rbx),%rbx
ffffffff810059b9:	5a                   	pop    %rdx
ffffffff810059ba:	eb b0                	jmp    ffffffff8100596c <_ZN2Ec13restore_stateEv+0x8a>
ffffffff810059bc:	8b 05 4e 16 16 00    	mov    0x16164e(%rip),%eax        # ffffffff81167010 <PAGE_H+0x10>
        }
    } else if(Hip::feature() & Hip::FEAT_SVM){
ffffffff810059c2:	a8 04                	test   $0x4,%al
ffffffff810059c4:	74 61                	je     ffffffff81005a27 <_ZN2Ec13restore_stateEv+0x145>
        memcpy(vmcb1, regs.vmcb, PAGE_SIZE);
ffffffff810059c6:	48 8b b5 28 01 00 00 	mov    0x128(%rbp),%rsi
ffffffff810059cd:	48 8b bd c8 02 00 00 	mov    0x2c8(%rbp),%rdi
ffffffff810059d4:	ba 00 10 00 00       	mov    $0x1000,%edx
ffffffff810059d9:	e8 84 14 01 00       	callq  ffffffff81016e62 <memcpy>
        memcpy(regs_0.vmcb, vmcb_backup, PAGE_SIZE);
ffffffff810059de:	48 8b b5 c0 02 00 00 	mov    0x2c0(%rbp),%rsi
ffffffff810059e5:	48 8b bd 18 02 00 00 	mov    0x218(%rbp),%rdi
ffffffff810059ec:	ba 00 10 00 00       	mov    $0x1000,%edx
ffffffff810059f1:	e8 6c 14 01 00       	callq  ffffffff81016e62 <memcpy>
        Vtlb *tlb = regs.vtlb;
ffffffff810059f6:	4c 8b ad 30 01 00 00 	mov    0x130(%rbp),%r13
        while (cow != nullptr) {
ffffffff810059fd:	48 85 db             	test   %rbx,%rbx
ffffffff81005a00:	0f 84 82 00 00 00    	je     ffffffff81005a88 <_ZN2Ec13restore_stateEv+0x1a6>
            mword v = cow->gla;
            tlb->update(v, cow->new_phys[1]->phys_addr, cow->attr | Vtlb::TLB_W);
ffffffff81005a06:	48 8b 43 28          	mov    0x28(%rbx),%rax
ffffffff81005a0a:	48 8b 4b 18          	mov    0x18(%rbx),%rcx
ffffffff81005a0e:	4c 89 ef             	mov    %r13,%rdi
ffffffff81005a11:	48 8b 73 08          	mov    0x8(%rbx),%rsi
ffffffff81005a15:	48 8b 10             	mov    (%rax),%rdx
ffffffff81005a18:	48 83 c9 02          	or     $0x2,%rcx
ffffffff81005a1c:	e8 c3 72 01 00       	callq  ffffffff8101cce4 <_ZN4Vtlb6updateEmmm>
            cow = cow->next;
ffffffff81005a21:	48 8b 5b 38          	mov    0x38(%rbx),%rbx
ffffffff81005a25:	eb d6                	jmp    ffffffff810059fd <_ZN2Ec13restore_stateEv+0x11b>
        }
    } else if(Hip::feature() & Hip::FEAT_VMX){
ffffffff81005a27:	a8 02                	test   $0x2,%al
ffffffff81005a29:	74 5d                	je     ffffffff81005a88 <_ZN2Ec13restore_stateEv+0x1a6>
        memcpy(vmcs1, regs.vmcs, PAGE_SIZE);
ffffffff81005a2b:	48 8b b5 28 01 00 00 	mov    0x128(%rbp),%rsi
ffffffff81005a32:	48 8b bd e0 02 00 00 	mov    0x2e0(%rbp),%rdi
ffffffff81005a39:	ba 00 10 00 00       	mov    $0x1000,%edx
ffffffff81005a3e:	e8 1f 14 01 00       	callq  ffffffff81016e62 <memcpy>
        memcpy(regs_0.vmcs, vmcs_backup, PAGE_SIZE);
ffffffff81005a43:	48 8b b5 d8 02 00 00 	mov    0x2d8(%rbp),%rsi
ffffffff81005a4a:	48 8b bd 18 02 00 00 	mov    0x218(%rbp),%rdi
ffffffff81005a51:	ba 00 10 00 00       	mov    $0x1000,%edx
ffffffff81005a56:	e8 07 14 01 00       	callq  ffffffff81016e62 <memcpy>
        Vtlb *tlb = regs.vtlb;
ffffffff81005a5b:	4c 8b ad 30 01 00 00 	mov    0x130(%rbp),%r13
        while (cow != nullptr) {
ffffffff81005a62:	48 85 db             	test   %rbx,%rbx
ffffffff81005a65:	74 21                	je     ffffffff81005a88 <_ZN2Ec13restore_stateEv+0x1a6>
            mword v = cow->gla;
            tlb->update(v, cow->new_phys[1]->phys_addr, cow->attr | Vtlb::TLB_W);
ffffffff81005a67:	48 8b 43 28          	mov    0x28(%rbx),%rax
ffffffff81005a6b:	48 8b 4b 18          	mov    0x18(%rbx),%rcx
ffffffff81005a6f:	4c 89 ef             	mov    %r13,%rdi
ffffffff81005a72:	48 8b 73 08          	mov    0x8(%rbx),%rsi
ffffffff81005a76:	48 8b 10             	mov    (%rax),%rdx
ffffffff81005a79:	48 83 c9 02          	or     $0x2,%rcx
ffffffff81005a7d:	e8 62 72 01 00       	callq  ffffffff8101cce4 <_ZN4Vtlb6updateEmmm>
            cow = cow->next;
ffffffff81005a82:	48 8b 5b 38          	mov    0x38(%rbx),%rbx
ffffffff81005a86:	eb da                	jmp    ffffffff81005a62 <_ZN2Ec13restore_stateEv+0x180>
        }
    }
    regs = regs_0;
ffffffff81005a88:	48 8d bd a8 00 00 00 	lea    0xa8(%rbp),%rdi
ffffffff81005a8f:	48 8d b5 98 01 00 00 	lea    0x198(%rbp),%rsi
ffffffff81005a96:	b9 3c 00 00 00       	mov    $0x3c,%ecx
ffffffff81005a9b:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
ffffffff81005a9d:	fe 85 48 03 00 00    	incb   0x348(%rbp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81005aa3:	45 84 e4             	test   %r12b,%r12b
ffffffff81005aa6:	74 36                	je     ffffffff81005ade <_ZN2Ec13restore_stateEv+0x1fc>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81005aa8:	80 3d 81 9c ff 3e 00 	cmpb   $0x0,0x3eff9c81(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81005aaf:	74 25                	je     ffffffff81005ad6 <_ZN2Ec13restore_stateEv+0x1f4>
ffffffff81005ab1:	49 c7 c0 60 e0 01 81 	mov    $0xffffffff8101e060,%r8
ffffffff81005ab8:	b1 c0                	mov    $0xc0,%cl
ffffffff81005aba:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81005ac1:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff81005ac8:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81005acf:	31 c0                	xor    %eax,%eax
ffffffff81005ad1:	e8 7a c4 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            preemption = true;
ffffffff81005ad6:	c6 05 53 9c ff 3e 01 	movb   $0x1,0x3eff9c53(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81005add:	fb                   	sti    

}
ffffffff81005ade:	48 83 c4 38          	add    $0x38,%rsp
ffffffff81005ae2:	5b                   	pop    %rbx
ffffffff81005ae3:	5d                   	pop    %rbp
ffffffff81005ae4:	41 5c                	pop    %r12
ffffffff81005ae6:	41 5d                	pop    %r13
ffffffff81005ae8:	c3                   	retq   
ffffffff81005ae9:	90                   	nop

ffffffff81005aea <_ZN2Ec8rollbackEv>:

void Ec::rollback() {
ffffffff81005aea:	41 56                	push   %r14
ffffffff81005aec:	41 55                	push   %r13
    regs = regs_0;
ffffffff81005aee:	b9 3c 00 00 00       	mov    $0x3c,%ecx
    }
    regs = regs_0;

}

void Ec::rollback() {
ffffffff81005af3:	41 54                	push   %r12
ffffffff81005af5:	55                   	push   %rbp
ffffffff81005af6:	48 89 fd             	mov    %rdi,%rbp
ffffffff81005af9:	53                   	push   %rbx
    regs = regs_0;
ffffffff81005afa:	48 8d b5 98 01 00 00 	lea    0x198(%rbp),%rsi
ffffffff81005b01:	48 8d bf a8 00 00 00 	lea    0xa8(%rdi),%rdi
    }
    regs = regs_0;

}

void Ec::rollback() {
ffffffff81005b08:	48 83 ec 40          	sub    $0x40,%rsp
    regs = regs_0;
ffffffff81005b0c:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
    Lock_guard <Spinlock> guard(cow_lock);
ffffffff81005b0e:	48 8d bd 48 03 00 00 	lea    0x348(%rbp),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81005b15:	9c                   	pushfq 
ffffffff81005b16:	58                   	pop    %rax
            return flags & 0x200;
ffffffff81005b17:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff81005b1b:	41 88 c4             	mov    %al,%r12b
ffffffff81005b1e:	41 80 e4 01          	and    $0x1,%r12b
ffffffff81005b22:	74 2d                	je     ffffffff81005b51 <_ZN2Ec8rollbackEv+0x67>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81005b24:	80 3d 05 9c ff 3e 00 	cmpb   $0x0,0x3eff9c05(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81005b2b:	75 1c                	jne    ffffffff81005b49 <_ZN2Ec8rollbackEv+0x5f>
ffffffff81005b2d:	49 c7 c0 90 e0 01 81 	mov    $0xffffffff8101e090,%r8
ffffffff81005b34:	b1 b7                	mov    $0xb7,%cl
ffffffff81005b36:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81005b3d:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff81005b44:	e9 e7 01 00 00       	jmpq   ffffffff81005d30 <_ZN2Ec8rollbackEv+0x246>

            asm volatile ("cli" : : : "memory");
ffffffff81005b49:	fa                   	cli    
            preemption = false;
ffffffff81005b4a:	c6 05 df 9b ff 3e 00 	movb   $0x0,0x3eff9bdf(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff81005b51:	e8 38 b3 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    Cow::cow_elt *cow = current->cow_list;
ffffffff81005b56:	48 8b 05 ab 94 ff 3e 	mov    0x3eff94ab(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
    Hpt hpt = Pd::current->Space_mem::loc[Cpu::id];
ffffffff81005b5d:	48 8b 35 ac 94 ff 3e 	mov    0x3eff94ac(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
    Quota quota = Pd::current->quota;
ffffffff81005b64:	48 8d 7c 24 18       	lea    0x18(%rsp),%rdi
ffffffff81005b69:	b9 0a 00 00 00       	mov    $0xa,%ecx
}

void Ec::rollback() {
    regs = regs_0;
    Lock_guard <Spinlock> guard(cow_lock);
    Cow::cow_elt *cow = current->cow_list;
ffffffff81005b6e:	48 8b 98 40 03 00 00 	mov    0x340(%rax),%rbx
    Hpt hpt = Pd::current->Space_mem::loc[Cpu::id];
ffffffff81005b75:	8b 05 89 94 ff 3e    	mov    0x3eff9489(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81005b7b:	48 8b 84 c6 a0 00 00 	mov    0xa0(%rsi,%rax,8),%rax
ffffffff81005b82:	00 
    Quota quota = Pd::current->quota;
ffffffff81005b83:	48 81 c6 08 03 00 00 	add    $0x308,%rsi
    if (user_utcb) {
ffffffff81005b8a:	48 83 bd 28 03 00 00 	cmpq   $0x0,0x328(%rbp)
ffffffff81005b91:	00 
void Ec::rollback() {
    regs = regs_0;
    Lock_guard <Spinlock> guard(cow_lock);
    Cow::cow_elt *cow = current->cow_list;
    Hpt hpt = Pd::current->Space_mem::loc[Cpu::id];
    Quota quota = Pd::current->quota;
ffffffff81005b92:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)

void Ec::rollback() {
    regs = regs_0;
    Lock_guard <Spinlock> guard(cow_lock);
    Cow::cow_elt *cow = current->cow_list;
    Hpt hpt = Pd::current->Space_mem::loc[Cpu::id];
ffffffff81005b94:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    Quota quota = Pd::current->quota;
    if (user_utcb) {
ffffffff81005b99:	74 56                	je     ffffffff81005bf1 <_ZN2Ec8rollbackEv+0x107>
        while (cow != nullptr) {
ffffffff81005b9b:	48 85 db             	test   %rbx,%rbx
ffffffff81005b9e:	74 3d                	je     ffffffff81005bdd <_ZN2Ec8rollbackEv+0xf3>
            Paddr old_phys = cow->old_phys;
            mword v = cow->page_addr_or_gpa;
ffffffff81005ba0:	4c 8b 2b             	mov    (%rbx),%r13
            hpt.update(quota, v, 0, old_phys, cow->attr & ~Hpt::HPT_W, Hpt::TYPE_UP, true);
ffffffff81005ba3:	4c 8b 4b 18          	mov    0x18(%rbx),%r9
ffffffff81005ba7:	31 c9                	xor    %ecx,%ecx
ffffffff81005ba9:	6a 01                	pushq  $0x1
ffffffff81005bab:	6a 00                	pushq  $0x0
ffffffff81005bad:	4c 8b 43 10          	mov    0x10(%rbx),%r8
ffffffff81005bb1:	48 8d 74 24 28       	lea    0x28(%rsp),%rsi
ffffffff81005bb6:	48 8d 7c 24 20       	lea    0x20(%rsp),%rdi
ffffffff81005bbb:	49 83 e1 fd          	and    $0xfffffffffffffffd,%r9
ffffffff81005bbf:	4c 89 ea             	mov    %r13,%rdx
ffffffff81005bc2:	e8 4f d1 00 00       	callq  ffffffff81012d16 <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb>
ffffffff81005bc7:	41 0f 01 7d 00       	invlpg 0x0(%r13)
ffffffff81005bcc:	5f                   	pop    %rdi
ffffffff81005bcd:	41 58                	pop    %r8
            Hpt::cow_flush(v);
            Cow::free_cow_elt(cow);
ffffffff81005bcf:	48 89 df             	mov    %rbx,%rdi
ffffffff81005bd2:	e8 ab ca ff ff       	callq  ffffffff81002682 <_ZN3Cow12free_cow_eltEPNS_7cow_eltE>
            cow = cow->next;
ffffffff81005bd7:	48 8b 5b 38          	mov    0x38(%rbx),%rbx
ffffffff81005bdb:	eb be                	jmp    ffffffff81005b9b <_ZN2Ec8rollbackEv+0xb1>
ffffffff81005bdd:	fe 85 48 03 00 00    	incb   0x348(%rbp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81005be3:	45 84 e4             	test   %r12b,%r12b
ffffffff81005be6:	0f 85 21 01 00 00    	jne    ffffffff81005d0d <_ZN2Ec8rollbackEv+0x223>
ffffffff81005bec:	e9 55 01 00 00       	jmpq   ffffffff81005d46 <_ZN2Ec8rollbackEv+0x25c>
ffffffff81005bf1:	8b 05 19 14 16 00    	mov    0x161419(%rip),%eax        # ffffffff81167010 <PAGE_H+0x10>
        }
    } else if(Hip::feature() & Hip::FEAT_SVM){
ffffffff81005bf7:	a8 04                	test   $0x4,%al
ffffffff81005bf9:	0f 84 81 00 00 00    	je     ffffffff81005c80 <_ZN2Ec8rollbackEv+0x196>
        memcpy(regs.vmcb, vmcb_backup, PAGE_SIZE);
ffffffff81005bff:	48 8b b5 c0 02 00 00 	mov    0x2c0(%rbp),%rsi
ffffffff81005c06:	48 8b bd 28 01 00 00 	mov    0x128(%rbp),%rdi
ffffffff81005c0d:	ba 00 10 00 00       	mov    $0x1000,%edx
ffffffff81005c12:	e8 4b 12 01 00       	callq  ffffffff81016e62 <memcpy>
        Vtlb *tlb = regs.vtlb;
ffffffff81005c17:	4c 8b b5 30 01 00 00 	mov    0x130(%rbp),%r14
        while (cow != nullptr) {
ffffffff81005c1e:	48 85 db             	test   %rbx,%rbx
ffffffff81005c21:	74 ba                	je     ffffffff81005bdd <_ZN2Ec8rollbackEv+0xf3>
            Paddr old_phys = cow->old_phys;
ffffffff81005c23:	4c 8b 43 10          	mov    0x10(%rbx),%r8
            mword v = cow->gla;
            tlb->update(v, old_phys, cow->attr & ~Vtlb::TLB_W);
ffffffff81005c27:	48 8b 4b 18          	mov    0x18(%rbx),%rcx
ffffffff81005c2b:	4c 89 f7             	mov    %r14,%rdi
ffffffff81005c2e:	48 8b 73 08          	mov    0x8(%rbx),%rsi
ffffffff81005c32:	48 83 e1 fd          	and    $0xfffffffffffffffd,%rcx
ffffffff81005c36:	4c 89 c2             	mov    %r8,%rdx
ffffffff81005c39:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
ffffffff81005c3e:	e8 a1 70 01 00       	callq  ffffffff8101cce4 <_ZN4Vtlb6updateEmmm>
            v = cow->page_addr_or_gpa;
ffffffff81005c43:	4c 8b 2b             	mov    (%rbx),%r13
            hpt.update(quota, v, 0, old_phys, cow->attr & ~Hpt::HPT_W, Hpt::TYPE_UP, true);
ffffffff81005c46:	4c 8b 4b 18          	mov    0x18(%rbx),%r9
ffffffff81005c4a:	31 c9                	xor    %ecx,%ecx
ffffffff81005c4c:	6a 01                	pushq  $0x1
ffffffff81005c4e:	6a 00                	pushq  $0x0
ffffffff81005c50:	4c 8b 44 24 18       	mov    0x18(%rsp),%r8
ffffffff81005c55:	48 8d 74 24 28       	lea    0x28(%rsp),%rsi
ffffffff81005c5a:	48 8d 7c 24 20       	lea    0x20(%rsp),%rdi
ffffffff81005c5f:	49 83 e1 fd          	and    $0xfffffffffffffffd,%r9
ffffffff81005c63:	4c 89 ea             	mov    %r13,%rdx
ffffffff81005c66:	e8 ab d0 00 00       	callq  ffffffff81012d16 <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb>
ffffffff81005c6b:	41 0f 01 7d 00       	invlpg 0x0(%r13)
ffffffff81005c70:	59                   	pop    %rcx
ffffffff81005c71:	5e                   	pop    %rsi
            Hpt::cow_flush(v);
            Cow::free_cow_elt(cow);
ffffffff81005c72:	48 89 df             	mov    %rbx,%rdi
ffffffff81005c75:	e8 08 ca ff ff       	callq  ffffffff81002682 <_ZN3Cow12free_cow_eltEPNS_7cow_eltE>
            cow = cow->next;
ffffffff81005c7a:	48 8b 5b 38          	mov    0x38(%rbx),%rbx
ffffffff81005c7e:	eb 9e                	jmp    ffffffff81005c1e <_ZN2Ec8rollbackEv+0x134>
        }
    }
    else if(Hip::feature() & Hip::FEAT_VMX){
ffffffff81005c80:	a8 02                	test   $0x2,%al
ffffffff81005c82:	0f 84 55 ff ff ff    	je     ffffffff81005bdd <_ZN2Ec8rollbackEv+0xf3>
        memcpy(regs.vmcs, vmcs_backup, PAGE_SIZE);
ffffffff81005c88:	48 8b b5 d8 02 00 00 	mov    0x2d8(%rbp),%rsi
ffffffff81005c8f:	48 8b bd 28 01 00 00 	mov    0x128(%rbp),%rdi
ffffffff81005c96:	ba 00 10 00 00       	mov    $0x1000,%edx
ffffffff81005c9b:	e8 c2 11 01 00       	callq  ffffffff81016e62 <memcpy>
        Vtlb *tlb = regs.vtlb;
ffffffff81005ca0:	4c 8b b5 30 01 00 00 	mov    0x130(%rbp),%r14
        while (cow != nullptr) {
ffffffff81005ca7:	48 85 db             	test   %rbx,%rbx
ffffffff81005caa:	0f 84 2d ff ff ff    	je     ffffffff81005bdd <_ZN2Ec8rollbackEv+0xf3>
            Paddr old_phys = cow->old_phys;
ffffffff81005cb0:	4c 8b 43 10          	mov    0x10(%rbx),%r8
            mword v = cow->gla;
            tlb->update(v, old_phys, cow->attr & ~Vtlb::TLB_W);
ffffffff81005cb4:	48 8b 4b 18          	mov    0x18(%rbx),%rcx
ffffffff81005cb8:	4c 89 f7             	mov    %r14,%rdi
ffffffff81005cbb:	48 8b 73 08          	mov    0x8(%rbx),%rsi
ffffffff81005cbf:	48 83 e1 fd          	and    $0xfffffffffffffffd,%rcx
ffffffff81005cc3:	4c 89 c2             	mov    %r8,%rdx
ffffffff81005cc6:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
ffffffff81005ccb:	e8 14 70 01 00       	callq  ffffffff8101cce4 <_ZN4Vtlb6updateEmmm>
            v = cow->page_addr_or_gpa;
ffffffff81005cd0:	4c 8b 2b             	mov    (%rbx),%r13
            hpt.update(quota, v, 0, old_phys, cow->attr & ~Hpt::HPT_W, Hpt::TYPE_UP, true);
ffffffff81005cd3:	4c 8b 4b 18          	mov    0x18(%rbx),%r9
ffffffff81005cd7:	31 c9                	xor    %ecx,%ecx
ffffffff81005cd9:	6a 01                	pushq  $0x1
ffffffff81005cdb:	6a 00                	pushq  $0x0
ffffffff81005cdd:	4c 8b 44 24 18       	mov    0x18(%rsp),%r8
ffffffff81005ce2:	48 8d 74 24 28       	lea    0x28(%rsp),%rsi
ffffffff81005ce7:	48 8d 7c 24 20       	lea    0x20(%rsp),%rdi
ffffffff81005cec:	49 83 e1 fd          	and    $0xfffffffffffffffd,%r9
ffffffff81005cf0:	4c 89 ea             	mov    %r13,%rdx
ffffffff81005cf3:	e8 1e d0 00 00       	callq  ffffffff81012d16 <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb>
ffffffff81005cf8:	41 0f 01 7d 00       	invlpg 0x0(%r13)
ffffffff81005cfd:	58                   	pop    %rax
ffffffff81005cfe:	5a                   	pop    %rdx
            Hpt::cow_flush(v);
            Cow::free_cow_elt(cow);
ffffffff81005cff:	48 89 df             	mov    %rbx,%rdi
ffffffff81005d02:	e8 7b c9 ff ff       	callq  ffffffff81002682 <_ZN3Cow12free_cow_eltEPNS_7cow_eltE>
            cow = cow->next;
ffffffff81005d07:	48 8b 5b 38          	mov    0x38(%rbx),%rbx
ffffffff81005d0b:	eb 9a                	jmp    ffffffff81005ca7 <_ZN2Ec8rollbackEv+0x1bd>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81005d0d:	80 3d 1c 9a ff 3e 00 	cmpb   $0x0,0x3eff9a1c(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81005d14:	74 28                	je     ffffffff81005d3e <_ZN2Ec8rollbackEv+0x254>
ffffffff81005d16:	49 c7 c0 60 e0 01 81 	mov    $0xffffffff8101e060,%r8
ffffffff81005d1d:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff81005d22:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81005d29:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff81005d30:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81005d37:	31 c0                	xor    %eax,%eax
ffffffff81005d39:	e8 12 c2 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            preemption = true;
ffffffff81005d3e:	c6 05 eb 99 ff 3e 01 	movb   $0x1,0x3eff99eb(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81005d45:	fb                   	sti    
        }
    }
}
ffffffff81005d46:	48 83 c4 40          	add    $0x40,%rsp
ffffffff81005d4a:	5b                   	pop    %rbx
ffffffff81005d4b:	5d                   	pop    %rbp
ffffffff81005d4c:	41 5c                	pop    %r12
ffffffff81005d4e:	41 5d                	pop    %r13
ffffffff81005d50:	41 5e                	pop    %r14
ffffffff81005d52:	c3                   	retq   
ffffffff81005d53:	90                   	nop

ffffffff81005d54 <_ZN2Ec18compare_and_commitEv>:

bool Ec::compare_and_commit() {
ffffffff81005d54:	41 57                	push   %r15
ffffffff81005d56:	41 56                	push   %r14
ffffffff81005d58:	41 55                	push   %r13
ffffffff81005d5a:	41 54                	push   %r12
ffffffff81005d5c:	49 89 fd             	mov    %rdi,%r13
ffffffff81005d5f:	55                   	push   %rbp
ffffffff81005d60:	53                   	push   %rbx
    Lock_guard <Spinlock> guard(cow_lock);
ffffffff81005d61:	48 8d bf 48 03 00 00 	lea    0x348(%rdi),%rdi
            cow = cow->next;
        }
    }
}

bool Ec::compare_and_commit() {
ffffffff81005d68:	48 83 ec 48          	sub    $0x48,%rsp

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81005d6c:	9c                   	pushfq 
ffffffff81005d6d:	41 5c                	pop    %r12
            return flags & 0x200;
ffffffff81005d6f:	49 c1 ec 09          	shr    $0x9,%r12

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff81005d73:	41 80 e4 01          	and    $0x1,%r12b
ffffffff81005d77:	74 30                	je     ffffffff81005da9 <_ZN2Ec18compare_and_commitEv+0x55>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81005d79:	80 3d b0 99 ff 3e 00 	cmpb   $0x0,0x3eff99b0(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81005d80:	75 1f                	jne    ffffffff81005da1 <_ZN2Ec18compare_and_commitEv+0x4d>
ffffffff81005d82:	49 c7 c0 90 e0 01 81 	mov    $0xffffffff8101e090,%r8
ffffffff81005d89:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff81005d8e:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81005d95:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff81005d9c:	e9 52 02 00 00       	jmpq   ffffffff81005ff3 <_ZN2Ec18compare_and_commitEv+0x29f>

            asm volatile ("cli" : : : "memory");
ffffffff81005da1:	fa                   	cli    
            preemption = false;
ffffffff81005da2:	c6 05 87 99 ff 3e 00 	movb   $0x0,0x3eff9987(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff81005da9:	e8 e0 b0 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    Lock_guard <Spinlock> guard(cow_lock);
    Cow::cow_elt *cow = current->cow_list;
ffffffff81005dae:	48 8b 05 53 92 ff 3e 	mov    0x3eff9253(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
    Quota quota = Pd::current->quota;
    Hpt hpt = Pd::current->Space_mem::loc[Cpu::id];
ffffffff81005db5:	8b 15 49 92 ff 3e    	mov    0x3eff9249(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
}

bool Ec::compare_and_commit() {
    Lock_guard <Spinlock> guard(cow_lock);
    Cow::cow_elt *cow = current->cow_list;
    Quota quota = Pd::current->quota;
ffffffff81005dbb:	48 8d 7c 24 18       	lea    0x18(%rsp),%rdi
    Hpt hpt = Pd::current->Space_mem::loc[Cpu::id];
    if (user_utcb) {
ffffffff81005dc0:	49 83 bd 28 03 00 00 	cmpq   $0x0,0x328(%r13)
ffffffff81005dc7:	00 
}

bool Ec::compare_and_commit() {
    Lock_guard <Spinlock> guard(cow_lock);
    Cow::cow_elt *cow = current->cow_list;
    Quota quota = Pd::current->quota;
ffffffff81005dc8:	b9 0a 00 00 00       	mov    $0xa,%ecx
    }
}

bool Ec::compare_and_commit() {
    Lock_guard <Spinlock> guard(cow_lock);
    Cow::cow_elt *cow = current->cow_list;
ffffffff81005dcd:	48 8b 98 40 03 00 00 	mov    0x340(%rax),%rbx
    Quota quota = Pd::current->quota;
ffffffff81005dd4:	48 8b 05 35 92 ff 3e 	mov    0x3eff9235(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81005ddb:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
    Hpt hpt = Pd::current->Space_mem::loc[Cpu::id];
ffffffff81005de2:	48 8b 84 d0 a0 00 00 	mov    0xa0(%rax,%rdx,8),%rax
ffffffff81005de9:	00 
}

bool Ec::compare_and_commit() {
    Lock_guard <Spinlock> guard(cow_lock);
    Cow::cow_elt *cow = current->cow_list;
    Quota quota = Pd::current->quota;
ffffffff81005dea:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
    Hpt hpt = Pd::current->Space_mem::loc[Cpu::id];
ffffffff81005dec:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    if (user_utcb) {
ffffffff81005df1:	0f 84 ba 00 00 00    	je     ffffffff81005eb1 <_ZN2Ec18compare_and_commitEv+0x15d>
        while (cow != nullptr) {
ffffffff81005df7:	48 85 db             	test   %rbx,%rbx
ffffffff81005dfa:	0f 84 bd 00 00 00    	je     ffffffff81005ebd <_ZN2Ec18compare_and_commitEv+0x169>
            const void *ptr1 = reinterpret_cast<const void*> (Hpt::remap_cow(quota, cow->new_phys[0]->phys_addr)),
ffffffff81005e00:	48 8b 43 20          	mov    0x20(%rbx),%rax
ffffffff81005e04:	48 8d 7c 24 18       	lea    0x18(%rsp),%rdi
ffffffff81005e09:	31 d2                	xor    %edx,%edx
ffffffff81005e0b:	48 8b 30             	mov    (%rax),%rsi
ffffffff81005e0e:	e8 01 24 00 00       	callq  ffffffff81008214 <_ZN3Hpt9remap_cowER5Quotamm>
                    *ptr2 = reinterpret_cast<const void*> (cow->page_addr_or_gpa);
ffffffff81005e13:	4c 8b 03             	mov    (%rbx),%r8
extern "C" NONNULL
inline int memcmp(const void *s1, const void *s2, size_t len) {
    len /=4;
    uint8 diff;
    asm volatile ("repe; cmpsl; setnz %0"
                : "=qm" (diff), "+D" (s1), "+S" (s2), "+c" (len));
ffffffff81005e16:	48 89 c7             	mov    %rax,%rdi
ffffffff81005e19:	b9 00 04 00 00       	mov    $0x400,%ecx
ffffffff81005e1e:	4c 89 c6             	mov    %r8,%rsi
ffffffff81005e21:	f3 a7                	repz cmpsl %es:(%rdi),%ds:(%rsi)
ffffffff81005e23:	0f 95 c2             	setne  %dl
            if (memcmp(ptr1, ptr2, PAGE_SIZE)) {
ffffffff81005e26:	84 d2                	test   %dl,%dl
ffffffff81005e28:	74 1f                	je     ffffffff81005e49 <_ZN2Ec18compare_and_commitEv+0xf5>
                Console::print("Ec: %p  Pd: %p  ptr1: %p  "
                        "ptr2: %p", current, current->pd.operator->(), ptr1, ptr2);
ffffffff81005e2a:	48 8b 35 d7 91 ff 3e 	mov    0x3eff91d7(%rip),%rsi        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81005e31:	48 89 c1             	mov    %rax,%rcx
ffffffff81005e34:	48 c7 c7 41 df 01 81 	mov    $0xffffffff8101df41,%rdi
ffffffff81005e3b:	31 c0                	xor    %eax,%eax
ffffffff81005e3d:	48 8b 96 98 02 00 00 	mov    0x298(%rsi),%rdx
ffffffff81005e44:	e8 43 c2 ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
                //                return false;
            }
            Paddr old_phys = cow->old_phys;
ffffffff81005e49:	4c 8b 43 10          	mov    0x10(%rbx),%r8
            mword v = cow->page_addr_or_gpa;
ffffffff81005e4d:	48 8b 2b             	mov    (%rbx),%rbp
            void *ptr = Hpt::remap_cow(quota, old_phys);
ffffffff81005e50:	48 8d 7c 24 18       	lea    0x18(%rsp),%rdi
ffffffff81005e55:	31 d2                	xor    %edx,%edx
ffffffff81005e57:	4c 89 c6             	mov    %r8,%rsi
ffffffff81005e5a:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
ffffffff81005e5f:	e8 b0 23 00 00       	callq  ffffffff81008214 <_ZN3Hpt9remap_cowER5Quotamm>
            memcpy(ptr, reinterpret_cast<const void*> (v), PAGE_SIZE);
ffffffff81005e64:	48 89 ee             	mov    %rbp,%rsi
ffffffff81005e67:	ba 00 10 00 00       	mov    $0x1000,%edx
ffffffff81005e6c:	48 89 c7             	mov    %rax,%rdi
ffffffff81005e6f:	e8 ee 0f 01 00       	callq  ffffffff81016e62 <memcpy>
            hpt.update(quota, v, 0, old_phys, cow->attr & ~Hpt::HPT_W, Hpt::TYPE_UP, true); // the old frame may have been released; so we have to retain it
ffffffff81005e74:	4c 8b 4b 18          	mov    0x18(%rbx),%r9
ffffffff81005e78:	6a 01                	pushq  $0x1
ffffffff81005e7a:	31 c9                	xor    %ecx,%ecx
ffffffff81005e7c:	6a 00                	pushq  $0x0
ffffffff81005e7e:	4c 8b 44 24 18       	mov    0x18(%rsp),%r8
ffffffff81005e83:	48 89 ea             	mov    %rbp,%rdx
ffffffff81005e86:	48 8d 74 24 28       	lea    0x28(%rsp),%rsi
ffffffff81005e8b:	48 8d 7c 24 20       	lea    0x20(%rsp),%rdi
ffffffff81005e90:	49 83 e1 fd          	and    $0xfffffffffffffffd,%r9
ffffffff81005e94:	e8 7d ce 00 00       	callq  ffffffff81012d16 <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb>
ffffffff81005e99:	0f 01 7d 00          	invlpg 0x0(%rbp)
ffffffff81005e9d:	41 5b                	pop    %r11
ffffffff81005e9f:	5d                   	pop    %rbp
            Hpt::cow_flush(v);
            Cow::free_cow_elt(cow);
ffffffff81005ea0:	48 89 df             	mov    %rbx,%rdi
ffffffff81005ea3:	e8 da c7 ff ff       	callq  ffffffff81002682 <_ZN3Cow12free_cow_eltEPNS_7cow_eltE>
            cow = cow->next;
ffffffff81005ea8:	48 8b 5b 38          	mov    0x38(%rbx),%rbx
ffffffff81005eac:	e9 46 ff ff ff       	jmpq   ffffffff81005df7 <_ZN2Ec18compare_and_commitEv+0xa3>
        }
    } else {
        Vtlb *tlb = regs.vtlb;
ffffffff81005eb1:	4d 8b bd 30 01 00 00 	mov    0x130(%r13),%r15
        while (cow != nullptr) {
ffffffff81005eb8:	48 85 db             	test   %rbx,%rbx
ffffffff81005ebb:	75 07                	jne    ffffffff81005ec4 <_ZN2Ec18compare_and_commitEv+0x170>
            tlb->update(cow->gla, old_phys, cow->attr & ~Vtlb::TLB_W);
            Cow::free_cow_elt(cow);
            cow = cow->next;
        }
    }
    return true;
ffffffff81005ebd:	b0 01                	mov    $0x1,%al
ffffffff81005ebf:	e9 00 01 00 00       	jmpq   ffffffff81005fc4 <_ZN2Ec18compare_and_commitEv+0x270>
    } else {
        Vtlb *tlb = regs.vtlb;
        while (cow != nullptr) {
            Paddr old_phys = cow->old_phys;
            mword v = cow->page_addr_or_gpa;
            hpt.update(quota, v, 0, cow->new_phys[1]->phys_addr, cow->attr, Hpt::TYPE_UP, true);
ffffffff81005ec4:	48 8b 43 28          	mov    0x28(%rbx),%rax
        }
    } else {
        Vtlb *tlb = regs.vtlb;
        while (cow != nullptr) {
            Paddr old_phys = cow->old_phys;
            mword v = cow->page_addr_or_gpa;
ffffffff81005ec8:	48 8b 2b             	mov    (%rbx),%rbp
            hpt.update(quota, v, 0, cow->new_phys[1]->phys_addr, cow->attr, Hpt::TYPE_UP, true);
ffffffff81005ecb:	31 c9                	xor    %ecx,%ecx
            cow = cow->next;
        }
    } else {
        Vtlb *tlb = regs.vtlb;
        while (cow != nullptr) {
            Paddr old_phys = cow->old_phys;
ffffffff81005ecd:	4c 8b 73 10          	mov    0x10(%rbx),%r14
            mword v = cow->page_addr_or_gpa;
            hpt.update(quota, v, 0, cow->new_phys[1]->phys_addr, cow->attr, Hpt::TYPE_UP, true);
ffffffff81005ed1:	6a 01                	pushq  $0x1
ffffffff81005ed3:	6a 00                	pushq  $0x0
ffffffff81005ed5:	4c 8b 4b 18          	mov    0x18(%rbx),%r9
ffffffff81005ed9:	4c 8b 00             	mov    (%rax),%r8
ffffffff81005edc:	48 89 ea             	mov    %rbp,%rdx
ffffffff81005edf:	48 8d 74 24 28       	lea    0x28(%rsp),%rsi
ffffffff81005ee4:	48 8d 7c 24 20       	lea    0x20(%rsp),%rdi
ffffffff81005ee9:	e8 28 ce 00 00       	callq  ffffffff81012d16 <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb>
ffffffff81005eee:	0f 01 7d 00          	invlpg 0x0(%rbp)
            Hpt::cow_flush(v);
            const void *ptr1 = reinterpret_cast<const void*> (Hpt::remap_cow(quota, cow->new_phys[0]->phys_addr)),
ffffffff81005ef2:	48 8b 43 20          	mov    0x20(%rbx),%rax
ffffffff81005ef6:	48 8d 7c 24 28       	lea    0x28(%rsp),%rdi
ffffffff81005efb:	31 d2                	xor    %edx,%edx
ffffffff81005efd:	48 8b 30             	mov    (%rax),%rsi
ffffffff81005f00:	e8 0f 23 00 00       	callq  ffffffff81008214 <_ZN3Hpt9remap_cowER5Quotamm>
ffffffff81005f05:	48 89 ee             	mov    %rbp,%rsi
ffffffff81005f08:	49 89 c1             	mov    %rax,%r9
ffffffff81005f0b:	48 89 c7             	mov    %rax,%rdi
ffffffff81005f0e:	b9 00 04 00 00       	mov    $0x400,%ecx
ffffffff81005f13:	f3 a7                	repz cmpsl %es:(%rdi),%ds:(%rsi)
ffffffff81005f15:	0f 95 c0             	setne  %al
                    *ptr2 = reinterpret_cast<const void*> (v);
            if (memcmp(ptr1, ptr2, PAGE_SIZE)) {
ffffffff81005f18:	84 c0                	test   %al,%al
ffffffff81005f1a:	41 58                	pop    %r8
ffffffff81005f1c:	41 5a                	pop    %r10
ffffffff81005f1e:	74 38                	je     ffffffff81005f58 <_ZN2Ec18compare_and_commitEv+0x204>
                Console::print("old_phys: %08lx  v: %08lx  new_phys[0]: %08lx  new_phys[1]: %08lx  ptr1: %p  "
                        "ptr2: %p", old_phys, v, cow->new_phys[0]->phys_addr, cow->new_phys[1]->phys_addr, ptr1, ptr2);
ffffffff81005f20:	51                   	push   %rcx
ffffffff81005f21:	48 8b 53 28          	mov    0x28(%rbx),%rdx
ffffffff81005f25:	4c 89 f6             	mov    %r14,%rsi
ffffffff81005f28:	48 8b 43 20          	mov    0x20(%rbx),%rax
ffffffff81005f2c:	55                   	push   %rbp
ffffffff81005f2d:	48 c7 c7 64 df 01 81 	mov    $0xffffffff8101df64,%rdi
ffffffff81005f34:	4c 8b 02             	mov    (%rdx),%r8
ffffffff81005f37:	48 89 ea             	mov    %rbp,%rdx
ffffffff81005f3a:	48 8b 08             	mov    (%rax),%rcx
ffffffff81005f3d:	31 c0                	xor    %eax,%eax
ffffffff81005f3f:	e8 48 c1 ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
                //                if (nb_fail > 0) {
                current->debug = true;
ffffffff81005f44:	48 8b 05 bd 90 ff 3e 	mov    0x3eff90bd(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81005f4b:	c6 80 50 03 00 00 01 	movb   $0x1,0x350(%rax)
                return false;
ffffffff81005f52:	31 c0                	xor    %eax,%eax
ffffffff81005f54:	5e                   	pop    %rsi
ffffffff81005f55:	5f                   	pop    %rdi
ffffffff81005f56:	eb 6c                	jmp    ffffffff81005fc4 <_ZN2Ec18compare_and_commitEv+0x270>
                //                } else
                //                    nb_fail++;
            }
            void *ptr = Hpt::remap_cow(quota, old_phys);
ffffffff81005f58:	48 8d 7c 24 18       	lea    0x18(%rsp),%rdi
ffffffff81005f5d:	31 d2                	xor    %edx,%edx
ffffffff81005f5f:	4c 89 f6             	mov    %r14,%rsi
ffffffff81005f62:	e8 ad 22 00 00       	callq  ffffffff81008214 <_ZN3Hpt9remap_cowER5Quotamm>
            memcpy(ptr, reinterpret_cast<const void*> (v), PAGE_SIZE);
ffffffff81005f67:	48 89 ee             	mov    %rbp,%rsi
ffffffff81005f6a:	ba 00 10 00 00       	mov    $0x1000,%edx
ffffffff81005f6f:	48 89 c7             	mov    %rax,%rdi
ffffffff81005f72:	e8 eb 0e 01 00       	callq  ffffffff81016e62 <memcpy>
            hpt.update(quota, v, 0, old_phys, cow->attr, Hpt::TYPE_UP, true);
ffffffff81005f77:	6a 01                	pushq  $0x1
ffffffff81005f79:	6a 00                	pushq  $0x0
ffffffff81005f7b:	4d 89 f0             	mov    %r14,%r8
ffffffff81005f7e:	4c 8b 4b 18          	mov    0x18(%rbx),%r9
ffffffff81005f82:	31 c9                	xor    %ecx,%ecx
ffffffff81005f84:	48 89 ea             	mov    %rbp,%rdx
ffffffff81005f87:	48 8d 74 24 28       	lea    0x28(%rsp),%rsi
ffffffff81005f8c:	48 8d 7c 24 20       	lea    0x20(%rsp),%rdi
ffffffff81005f91:	e8 80 cd 00 00       	callq  ffffffff81012d16 <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb>
ffffffff81005f96:	0f 01 7d 00          	invlpg 0x0(%rbp)
ffffffff81005f9a:	58                   	pop    %rax
            Hpt::cow_flush(v);
            tlb->update(cow->gla, old_phys, cow->attr & ~Vtlb::TLB_W);
ffffffff81005f9b:	48 8b 4b 18          	mov    0x18(%rbx),%rcx
ffffffff81005f9f:	48 8b 73 08          	mov    0x8(%rbx),%rsi
ffffffff81005fa3:	4c 89 ff             	mov    %r15,%rdi
ffffffff81005fa6:	5a                   	pop    %rdx
ffffffff81005fa7:	4c 89 f2             	mov    %r14,%rdx
ffffffff81005faa:	48 83 e1 fd          	and    $0xfffffffffffffffd,%rcx
ffffffff81005fae:	e8 31 6d 01 00       	callq  ffffffff8101cce4 <_ZN4Vtlb6updateEmmm>
            Cow::free_cow_elt(cow);
ffffffff81005fb3:	48 89 df             	mov    %rbx,%rdi
ffffffff81005fb6:	e8 c7 c6 ff ff       	callq  ffffffff81002682 <_ZN3Cow12free_cow_eltEPNS_7cow_eltE>
            cow = cow->next;
ffffffff81005fbb:	48 8b 5b 38          	mov    0x38(%rbx),%rbx
ffffffff81005fbf:	e9 f4 fe ff ff       	jmpq   ffffffff81005eb8 <_ZN2Ec18compare_and_commitEv+0x164>
ffffffff81005fc4:	41 fe 85 48 03 00 00 	incb   0x348(%r13)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81005fcb:	45 84 e4             	test   %r12b,%r12b
ffffffff81005fce:	74 39                	je     ffffffff81006009 <_ZN2Ec18compare_and_commitEv+0x2b5>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81005fd0:	80 3d 59 97 ff 3e 00 	cmpb   $0x0,0x3eff9759(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81005fd7:	74 28                	je     ffffffff81006001 <_ZN2Ec18compare_and_commitEv+0x2ad>
ffffffff81005fd9:	49 c7 c0 60 e0 01 81 	mov    $0xffffffff8101e060,%r8
ffffffff81005fe0:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff81005fe5:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81005fec:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff81005ff3:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81005ffa:	31 c0                	xor    %eax,%eax
ffffffff81005ffc:	e8 4f bf ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            preemption = true;
ffffffff81006001:	c6 05 28 97 ff 3e 01 	movb   $0x1,0x3eff9728(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81006008:	fb                   	sti    
        }
    }
    return true;
}
ffffffff81006009:	48 83 c4 48          	add    $0x48,%rsp
ffffffff8100600d:	5b                   	pop    %rbx
ffffffff8100600e:	5d                   	pop    %rbp
ffffffff8100600f:	41 5c                	pop    %r12
ffffffff81006011:	41 5d                	pop    %r13
ffffffff81006013:	41 5e                	pop    %r14
ffffffff81006015:	41 5f                	pop    %r15
ffffffff81006017:	c3                   	retq   

ffffffff81006018 <_ZN2Ec19is_mapped_elsewhereEmPN3Cow7cow_eltE>:

bool Ec::is_mapped_elsewhere(Paddr phys, Cow::cow_elt* cow) {
ffffffff81006018:	41 55                	push   %r13
ffffffff8100601a:	41 54                	push   %r12
ffffffff8100601c:	49 89 fd             	mov    %rdi,%r13
ffffffff8100601f:	55                   	push   %rbp
ffffffff81006020:	49 89 f4             	mov    %rsi,%r12
ffffffff81006023:	53                   	push   %rbx
    Lock_guard <Spinlock> guard(cow_lock);
ffffffff81006024:	48 8d bf 48 03 00 00 	lea    0x348(%rdi),%rdi
        }
    }
    return true;
}

bool Ec::is_mapped_elsewhere(Paddr phys, Cow::cow_elt* cow) {
ffffffff8100602b:	51                   	push   %rcx
ffffffff8100602c:	48 89 d3             	mov    %rdx,%rbx

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff8100602f:	9c                   	pushfq 
ffffffff81006030:	58                   	pop    %rax
            return flags & 0x200;
ffffffff81006031:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff81006035:	40 88 c5             	mov    %al,%bpl
ffffffff81006038:	40 80 e5 01          	and    $0x1,%bpl
ffffffff8100603c:	74 30                	je     ffffffff8100606e <_ZN2Ec19is_mapped_elsewhereEmPN3Cow7cow_eltE+0x56>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff8100603e:	80 3d eb 96 ff 3e 00 	cmpb   $0x0,0x3eff96eb(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81006045:	75 1f                	jne    ffffffff81006066 <_ZN2Ec19is_mapped_elsewhereEmPN3Cow7cow_eltE+0x4e>
ffffffff81006047:	49 c7 c0 90 e0 01 81 	mov    $0xffffffff8101e090,%r8
ffffffff8100604e:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff81006053:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100605a:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff81006061:	e9 a0 00 00 00       	jmpq   ffffffff81006106 <_ZN2Ec19is_mapped_elsewhereEmPN3Cow7cow_eltE+0xee>

            asm volatile ("cli" : : : "memory");
ffffffff81006066:	fa                   	cli    
            preemption = false;
ffffffff81006067:	c6 05 c2 96 ff 3e 00 	movb   $0x0,0x3eff96c2(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff8100606e:	e8 1b ae ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    Lock_guard <Spinlock> guard(cow_lock);
    bool is_mapped = false;
    Cow::cow_elt *c = Ec::current->cow_list;
ffffffff81006073:	48 8b 05 8e 8f ff 3e 	mov    0x3eff8f8e(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100607a:	48 8b 88 40 03 00 00 	mov    0x340(%rax),%rcx
    return true;
}

bool Ec::is_mapped_elsewhere(Paddr phys, Cow::cow_elt* cow) {
    Lock_guard <Spinlock> guard(cow_lock);
    bool is_mapped = false;
ffffffff81006081:	31 c0                	xor    %eax,%eax
    Cow::cow_elt *c = Ec::current->cow_list;
    while ((c != nullptr) && (c != cow)) {
ffffffff81006083:	48 39 d9             	cmp    %rbx,%rcx
ffffffff81006086:	74 4f                	je     ffffffff810060d7 <_ZN2Ec19is_mapped_elsewhereEmPN3Cow7cow_eltE+0xbf>
ffffffff81006088:	48 85 c9             	test   %rcx,%rcx
ffffffff8100608b:	74 4a                	je     ffffffff810060d7 <_ZN2Ec19is_mapped_elsewhereEmPN3Cow7cow_eltE+0xbf>
        if (c->old_phys == phys) {//frame already mapped elsewhere
ffffffff8100608d:	4c 39 61 10          	cmp    %r12,0x10(%rcx)
ffffffff81006091:	75 16                	jne    ffffffff810060a9 <_ZN2Ec19is_mapped_elsewhereEmPN3Cow7cow_eltE+0x91>
            cow->old_phys = phys;
ffffffff81006093:	4c 89 63 10          	mov    %r12,0x10(%rbx)
            cow->new_phys[0] = c->new_phys[0];
ffffffff81006097:	48 8b 41 20          	mov    0x20(%rcx),%rax
ffffffff8100609b:	48 89 43 20          	mov    %rax,0x20(%rbx)
            cow->new_phys[1] = c->new_phys[1];
ffffffff8100609f:	48 8b 41 28          	mov    0x28(%rcx),%rax
ffffffff810060a3:	48 89 43 28          	mov    %rax,0x28(%rbx)
            is_mapped = true;
ffffffff810060a7:	b0 01                	mov    $0x1,%al
        }
        if (c->new_phys[0] && c->new_phys[0]->phys_addr == phys) {//mapping created before subtitute(v)
ffffffff810060a9:	48 8b 51 20          	mov    0x20(%rcx),%rdx
ffffffff810060ad:	48 85 d2             	test   %rdx,%rdx
ffffffff810060b0:	74 1f                	je     ffffffff810060d1 <_ZN2Ec19is_mapped_elsewhereEmPN3Cow7cow_eltE+0xb9>
ffffffff810060b2:	4c 39 22             	cmp    %r12,(%rdx)
ffffffff810060b5:	75 1a                	jne    ffffffff810060d1 <_ZN2Ec19is_mapped_elsewhereEmPN3Cow7cow_eltE+0xb9>
            cow->old_phys = c->old_phys;
ffffffff810060b7:	48 8b 41 10          	mov    0x10(%rcx),%rax
ffffffff810060bb:	48 89 43 10          	mov    %rax,0x10(%rbx)
            cow->new_phys[0] = c->new_phys[0];
ffffffff810060bf:	48 8b 41 20          	mov    0x20(%rcx),%rax
ffffffff810060c3:	48 89 43 20          	mov    %rax,0x20(%rbx)
            cow->new_phys[1] = c->new_phys[1];
ffffffff810060c7:	48 8b 41 28          	mov    0x28(%rcx),%rax
ffffffff810060cb:	48 89 43 28          	mov    %rax,0x28(%rbx)
            is_mapped = true;
ffffffff810060cf:	b0 01                	mov    $0x1,%al
        }

        c = c->next;
ffffffff810060d1:	48 8b 49 38          	mov    0x38(%rcx),%rcx
ffffffff810060d5:	eb ac                	jmp    ffffffff81006083 <_ZN2Ec19is_mapped_elsewhereEmPN3Cow7cow_eltE+0x6b>
ffffffff810060d7:	41 fe 85 48 03 00 00 	incb   0x348(%r13)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff810060de:	40 84 ed             	test   %bpl,%bpl
ffffffff810060e1:	74 39                	je     ffffffff8100611c <_ZN2Ec19is_mapped_elsewhereEmPN3Cow7cow_eltE+0x104>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff810060e3:	80 3d 46 96 ff 3e 00 	cmpb   $0x0,0x3eff9646(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff810060ea:	74 28                	je     ffffffff81006114 <_ZN2Ec19is_mapped_elsewhereEmPN3Cow7cow_eltE+0xfc>
ffffffff810060ec:	49 c7 c0 60 e0 01 81 	mov    $0xffffffff8101e060,%r8
ffffffff810060f3:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff810060f8:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff810060ff:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff81006106:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100610d:	31 c0                	xor    %eax,%eax
ffffffff8100610f:	e8 3c be ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            preemption = true;
ffffffff81006114:	c6 05 15 96 ff 3e 01 	movb   $0x1,0x3eff9615(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100611b:	fb                   	sti    
    }
    if (is_mapped)
        return true;
    else
        return false;
}
ffffffff8100611c:	5a                   	pop    %rdx
ffffffff8100611d:	5b                   	pop    %rbx
ffffffff8100611e:	5d                   	pop    %rbp
ffffffff8100611f:	41 5c                	pop    %r12
ffffffff81006121:	41 5d                	pop    %r13
ffffffff81006123:	c3                   	retq   

ffffffff81006124 <_ZN2Ec12find_cow_eltEm>:

Cow::cow_elt* Ec::find_cow_elt(mword gpa) {
ffffffff81006124:	41 54                	push   %r12
ffffffff81006126:	49 89 fc             	mov    %rdi,%r12
ffffffff81006129:	55                   	push   %rbp
    int n = 0;
    Lock_guard <Spinlock> guard(cow_lock);
ffffffff8100612a:	48 8d bf 48 03 00 00 	lea    0x348(%rdi),%rdi
        return true;
    else
        return false;
}

Cow::cow_elt* Ec::find_cow_elt(mword gpa) {
ffffffff81006131:	53                   	push   %rbx
ffffffff81006132:	48 89 f5             	mov    %rsi,%rbp

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81006135:	9c                   	pushfq 
ffffffff81006136:	58                   	pop    %rax
            return flags & 0x200;
ffffffff81006137:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8100613b:	88 c3                	mov    %al,%bl
ffffffff8100613d:	80 e3 01             	and    $0x1,%bl
ffffffff81006140:	74 2d                	je     ffffffff8100616f <_ZN2Ec12find_cow_eltEm+0x4b>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81006142:	80 3d e7 95 ff 3e 00 	cmpb   $0x0,0x3eff95e7(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81006149:	75 1c                	jne    ffffffff81006167 <_ZN2Ec12find_cow_eltEm+0x43>
ffffffff8100614b:	49 c7 c0 90 e0 01 81 	mov    $0xffffffff8101e090,%r8
ffffffff81006152:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff81006157:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100615e:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff81006165:	eb 7e                	jmp    ffffffff810061e5 <_ZN2Ec12find_cow_eltEm+0xc1>

            asm volatile ("cli" : : : "memory");
ffffffff81006167:	fa                   	cli    
            preemption = false;
ffffffff81006168:	c6 05 c1 95 ff 3e 00 	movb   $0x0,0x3eff95c1(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff8100616f:	e8 1a ad ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    int n = 0;
    Lock_guard <Spinlock> guard(cow_lock);
    Cow::cow_elt *c = Ec::current->cow_list, *result = nullptr;
ffffffff81006174:	48 8b 15 8d 8e ff 3e 	mov    0x3eff8e8d(%rip),%rdx        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100617b:	31 c0                	xor    %eax,%eax
    else
        return false;
}

Cow::cow_elt* Ec::find_cow_elt(mword gpa) {
    int n = 0;
ffffffff8100617d:	31 c9                	xor    %ecx,%ecx
    Lock_guard <Spinlock> guard(cow_lock);
    Cow::cow_elt *c = Ec::current->cow_list, *result = nullptr;
    while (c != nullptr) {
        if (c->old_phys == (gpa & ~PAGE_MASK)) {
ffffffff8100617f:	48 81 e5 00 f0 ff ff 	and    $0xfffffffffffff000,%rbp
}

Cow::cow_elt* Ec::find_cow_elt(mword gpa) {
    int n = 0;
    Lock_guard <Spinlock> guard(cow_lock);
    Cow::cow_elt *c = Ec::current->cow_list, *result = nullptr;
ffffffff81006186:	4c 8b 82 40 03 00 00 	mov    0x340(%rdx),%r8
    while (c != nullptr) {
ffffffff8100618d:	4d 85 c0             	test   %r8,%r8
ffffffff81006190:	74 0d                	je     ffffffff8100619f <_ZN2Ec12find_cow_eltEm+0x7b>
        if (c->old_phys == (gpa & ~PAGE_MASK)) {
ffffffff81006192:	49 39 68 10          	cmp    %rbp,0x10(%r8)
ffffffff81006196:	75 f5                	jne    ffffffff8100618d <_ZN2Ec12find_cow_eltEm+0x69>
            result = c;
            n++;
ffffffff81006198:	ff c1                	inc    %ecx
ffffffff8100619a:	4c 89 c0             	mov    %r8,%rax
ffffffff8100619d:	eb ee                	jmp    ffffffff8100618d <_ZN2Ec12find_cow_eltEm+0x69>
        }
    }
    if (n != 1) {
ffffffff8100619f:	ff c9                	dec    %ecx
ffffffff810061a1:	74 13                	je     ffffffff810061b6 <_ZN2Ec12find_cow_eltEm+0x92>
        die("Cow elt not find");
ffffffff810061a3:	48 8d b2 a8 00 00 00 	lea    0xa8(%rdx),%rsi
ffffffff810061aa:	48 c7 c7 ba df 01 81 	mov    $0xffffffff8101dfba,%rdi
ffffffff810061b1:	e8 54 ea ff ff       	callq  ffffffff81004c0a <_ZN2Ec3dieEPKcP8Exc_regs>
ffffffff810061b6:	41 fe 84 24 48 03 00 	incb   0x348(%r12)
ffffffff810061bd:	00 
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff810061be:	84 db                	test   %bl,%bl
ffffffff810061c0:	74 39                	je     ffffffff810061fb <_ZN2Ec12find_cow_eltEm+0xd7>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff810061c2:	80 3d 67 95 ff 3e 00 	cmpb   $0x0,0x3eff9567(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff810061c9:	74 28                	je     ffffffff810061f3 <_ZN2Ec12find_cow_eltEm+0xcf>
ffffffff810061cb:	49 c7 c0 60 e0 01 81 	mov    $0xffffffff8101e060,%r8
ffffffff810061d2:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff810061d7:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff810061de:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff810061e5:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff810061ec:	31 c0                	xor    %eax,%eax
ffffffff810061ee:	e8 5d bd ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            preemption = true;
ffffffff810061f3:	c6 05 36 95 ff 3e 01 	movb   $0x1,0x3eff9536(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff810061fa:	fb                   	sti    
        Console::print("Cow elt not find");
    }
    return result;
}
ffffffff810061fb:	5b                   	pop    %rbx
ffffffff810061fc:	5d                   	pop    %rbp
ffffffff810061fd:	41 5c                	pop    %r12
ffffffff810061ff:	c3                   	retq   

ffffffff81006200 <_GLOBAL__sub_I.00102__ZN2Ec5cacheE>:
#include "vtlb.hpp"
#include "sm.hpp"
#include "pt.hpp"

INIT_PRIORITY(PRIO_SLAB)
Slab_cache Ec::cache(sizeof (Ec), 32);
ffffffff81006200:	ba 20 00 00 00       	mov    $0x20,%edx
ffffffff81006205:	be 60 03 00 00       	mov    $0x360,%esi
ffffffff8100620a:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff81006211:	e9 8a f6 00 00       	jmpq   ffffffff810158a0 <_ZN10Slab_cacheC1Emj>

ffffffff81006216 <_ZN2Ec8load_fpuEv>:
#include "ec.hpp"
#include "gdt.hpp"
#include "mca.hpp"
#include "stdio.hpp"

void Ec::load_fpu() {
ffffffff81006216:	53                   	push   %rbx
    if (!utcb)
ffffffff81006217:	48 83 bf 90 02 00 00 	cmpq   $0x0,0x290(%rdi)
ffffffff8100621e:	00 
#include "ec.hpp"
#include "gdt.hpp"
#include "mca.hpp"
#include "stdio.hpp"

void Ec::load_fpu() {
ffffffff8100621f:	48 89 fb             	mov    %rdi,%rbx
    if (!utcb)
ffffffff81006222:	75 11                	jne    ffffffff81006235 <_ZN2Ec8load_fpuEv+0x1f>
        regs.fpu_ctrl(true);
ffffffff81006224:	48 8d bf a8 00 00 00 	lea    0xa8(%rdi),%rdi
ffffffff8100622b:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff81006230:	e8 41 d7 00 00       	callq  ffffffff81013976 <_ZN8Exc_regs8fpu_ctrlEb>

    if (EXPECT_FALSE(!fpu))
ffffffff81006235:	48 8b 83 b8 02 00 00 	mov    0x2b8(%rbx),%rax
ffffffff8100623c:	48 85 c0             	test   %rax,%rax
ffffffff8100623f:	75 04                	jne    ffffffff81006245 <_ZN2Ec8load_fpuEv+0x2f>

        ALWAYS_INLINE
        inline void load() { asm volatile ("fxrstor %0" : : "m" (*data)); }

        ALWAYS_INLINE
        static inline void init() { asm volatile ("fninit"); }
ffffffff81006241:	db e3                	fninit 
ffffffff81006243:	eb 03                	jmp    ffffffff81006248 <_ZN2Ec8load_fpuEv+0x32>
    public:
        ALWAYS_INLINE
        inline void save() { asm volatile ("fxsave %0" : "=m" (*data)); }

        ALWAYS_INLINE
        inline void load() { asm volatile ("fxrstor %0" : : "m" (*data)); }
ffffffff81006245:	0f ae 08             	fxrstor (%rax)
        Fpu::init();
    else
        fpu->load();
}
ffffffff81006248:	5b                   	pop    %rbx
ffffffff81006249:	c3                   	retq   

ffffffff8100624a <_ZN2Ec8save_fpuEv>:

void Ec::save_fpu() {
    if (EXPECT_FALSE(!this))
ffffffff8100624a:	48 85 ff             	test   %rdi,%rdi
ffffffff8100624d:	74 52                	je     ffffffff810062a1 <_ZN2Ec8save_fpuEv+0x57>
        Fpu::init();
    else
        fpu->load();
}

void Ec::save_fpu() {
ffffffff8100624f:	53                   	push   %rbx
    if (EXPECT_FALSE(!this))
        return;

    if (!utcb)
ffffffff81006250:	48 83 bf 90 02 00 00 	cmpq   $0x0,0x290(%rdi)
ffffffff81006257:	00 
ffffffff81006258:	48 89 fb             	mov    %rdi,%rbx
ffffffff8100625b:	75 0e                	jne    ffffffff8100626b <_ZN2Ec8save_fpuEv+0x21>
        regs.fpu_ctrl(false);
ffffffff8100625d:	48 8d bf a8 00 00 00 	lea    0xa8(%rdi),%rdi
ffffffff81006264:	31 f6                	xor    %esi,%esi
ffffffff81006266:	e8 0b d7 00 00       	callq  ffffffff81013976 <_ZN8Exc_regs8fpu_ctrlEb>

    if (EXPECT_FALSE(!fpu))
ffffffff8100626b:	48 83 bb b8 02 00 00 	cmpq   $0x0,0x2b8(%rbx)
ffffffff81006272:	00 
ffffffff81006273:	75 21                	jne    ffffffff81006296 <_ZN2Ec8save_fpuEv+0x4c>
        fpu = new (pd->quota) Fpu;
ffffffff81006275:	48 8b 83 98 02 00 00 	mov    0x298(%rbx),%rax

        ALWAYS_INLINE
        static inline void disable() { set_cr0 (get_cr0() | Cpu::CR0_TS); Cpu::hazard &= ~HZD_FPU; }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
ffffffff8100627c:	48 c7 c7 d0 20 16 81 	mov    $0xffffffff811620d0,%rdi
ffffffff81006283:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff8100628a:	e8 9f f6 00 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff8100628f:	48 89 83 b8 02 00 00 	mov    %rax,0x2b8(%rbx)

    fpu->save();
ffffffff81006296:	48 8b 83 b8 02 00 00 	mov    0x2b8(%rbx),%rax

        static Slab_cache cache;

    public:
        ALWAYS_INLINE
        inline void save() { asm volatile ("fxsave %0" : "=m" (*data)); }
ffffffff8100629d:	0f ae 00             	fxsave (%rax)
}
ffffffff810062a0:	5b                   	pop    %rbx
ffffffff810062a1:	c3                   	retq   

ffffffff810062a2 <_ZN2Ec12transfer_fpuEPS_>:

void Ec::transfer_fpu(Ec *ec) {
ffffffff810062a2:	55                   	push   %rbp
ffffffff810062a3:	53                   	push   %rbx
ffffffff810062a4:	52                   	push   %rdx
    if ((!utcb && !regs.fpu_on) ||
ffffffff810062a5:	48 83 bf 90 02 00 00 	cmpq   $0x0,0x290(%rdi)
ffffffff810062ac:	00 
ffffffff810062ad:	75 0d                	jne    ffffffff810062bc <_ZN2Ec12transfer_fpuEPS_+0x1a>
ffffffff810062af:	80 bf 69 01 00 00 00 	cmpb   $0x0,0x169(%rdi)
ffffffff810062b6:	0f 84 b5 00 00 00    	je     ffffffff81006371 <_ZN2Ec12transfer_fpuEPS_+0xcf>
ffffffff810062bc:	48 83 be 90 02 00 00 	cmpq   $0x0,0x290(%rsi)
ffffffff810062c3:	00 
ffffffff810062c4:	75 0d                	jne    ffffffff810062d3 <_ZN2Ec12transfer_fpuEPS_+0x31>
            (!ec->utcb && !ec->regs.fpu_on))
ffffffff810062c6:	80 be 69 01 00 00 00 	cmpb   $0x0,0x169(%rsi)
ffffffff810062cd:	0f 84 9e 00 00 00    	je     ffffffff81006371 <_ZN2Ec12transfer_fpuEPS_+0xcf>
        return;

    if (!(Cpu::hazard & HZD_FPU)) {
ffffffff810062d3:	8b 05 27 8d ff 3e    	mov    0x3eff8d27(%rip),%eax        # ffffffffbffff000 <_ZN3Cpu6hazardE>
ffffffff810062d9:	48 89 f3             	mov    %rsi,%rbx
ffffffff810062dc:	48 89 fd             	mov    %rdi,%rbp
ffffffff810062df:	a8 08                	test   $0x8,%al
ffffffff810062e1:	75 24                	jne    ffffffff81006307 <_ZN2Ec12transfer_fpuEPS_+0x65>

        ALWAYS_INLINE
        static inline void init() { asm volatile ("fninit"); }

        ALWAYS_INLINE
        static inline void enable() { asm volatile ("clts"); Cpu::hazard |= HZD_FPU; }
ffffffff810062e3:	0f 06                	clts   

        Fpu::enable();

        if (fpowner != this) {
ffffffff810062e5:	48 8b 3d d4 94 ff 3e 	mov    0x3eff94d4(%rip),%rdi        # ffffffffbffff7c0 <_ZN2Ec7fpownerE>
ffffffff810062ec:	83 c8 08             	or     $0x8,%eax
ffffffff810062ef:	89 05 0b 8d ff 3e    	mov    %eax,0x3eff8d0b(%rip)        # ffffffffbffff000 <_ZN3Cpu6hazardE>
ffffffff810062f5:	48 39 ef             	cmp    %rbp,%rdi
ffffffff810062f8:	74 0d                	je     ffffffff81006307 <_ZN2Ec12transfer_fpuEPS_+0x65>
            fpowner->save_fpu();
ffffffff810062fa:	e8 4b ff ff ff       	callq  ffffffff8100624a <_ZN2Ec8save_fpuEv>
            load_fpu();
ffffffff810062ff:	48 89 ef             	mov    %rbp,%rdi
ffffffff81006302:	e8 0f ff ff ff       	callq  ffffffff81006216 <_ZN2Ec8load_fpuEv>
        }
    }

    if (fpowner && fpowner->del_ref())
ffffffff81006307:	48 8b 05 b2 94 ff 3e 	mov    0x3eff94b2(%rip),%rax        # ffffffffbffff7c0 <_ZN2Ec7fpownerE>
ffffffff8100630e:	48 85 c0             	test   %rax,%rax
ffffffff81006311:	74 40                	je     ffffffff81006353 <_ZN2Ec12transfer_fpuEPS_+0xb1>
ffffffff81006313:	83 ca ff             	or     $0xffffffff,%edx
ffffffff81006316:	f0 0f c1 90 8c 00 00 	lock xadd %edx,0x8c(%rax)
ffffffff8100631d:	00 
ffffffff8100631e:	ff ca                	dec    %edx
ffffffff81006320:	75 31                	jne    ffffffff81006353 <_ZN2Ec12transfer_fpuEPS_+0xb1>
        delete fpowner;
ffffffff81006322:	48 8b 2d 97 94 ff 3e 	mov    0x3eff9497(%rip),%rbp        # ffffffffbffff7c0 <_ZN2Ec7fpownerE>
ffffffff81006329:	48 85 ed             	test   %rbp,%rbp
ffffffff8100632c:	74 25                	je     ffffffff81006353 <_ZN2Ec12transfer_fpuEPS_+0xb1>
ffffffff8100632e:	48 89 ef             	mov    %rbp,%rdi
ffffffff81006331:	e8 06 e1 ff ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff81006336:	48 8b 85 98 02 00 00 	mov    0x298(%rbp),%rax
ffffffff8100633d:	48 89 ee             	mov    %rbp,%rsi
ffffffff81006340:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff81006347:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff8100634e:	e8 17 f7 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>

    fpowner = ec;
ffffffff81006353:	48 89 1d 66 94 ff 3e 	mov    %rbx,0x3eff9466(%rip)        # ffffffffbffff7c0 <_ZN2Ec7fpownerE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100635a:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff81006360:	85 c0                	test   %eax,%eax
ffffffff81006362:	74 0d                	je     ffffffff81006371 <_ZN2Ec12transfer_fpuEPS_+0xcf>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff81006364:	8d 50 01             	lea    0x1(%rax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff81006367:	f0 0f b1 93 8c 00 00 	lock cmpxchg %edx,0x8c(%rbx)
ffffffff8100636e:	00 
ffffffff8100636f:	75 e9                	jne    ffffffff8100635a <_ZN2Ec12transfer_fpuEPS_+0xb8>
    fpowner->add_ref();
}
ffffffff81006371:	58                   	pop    %rax
ffffffff81006372:	5b                   	pop    %rbx
ffffffff81006373:	5d                   	pop    %rbp
ffffffff81006374:	c3                   	retq   
ffffffff81006375:	90                   	nop

ffffffff81006376 <_ZN2Ec13handle_exc_nmEv>:
ffffffff81006376:	0f 06                	clts   
ffffffff81006378:	83 0d 81 8c ff 3e 08 	orl    $0x8,0x3eff8c81(%rip)        # ffffffffbffff000 <_ZN3Cpu6hazardE>

void Ec::handle_exc_nm() {
    Fpu::enable();

    if (current == fpowner)
ffffffff8100637f:	48 8b 3d 3a 94 ff 3e 	mov    0x3eff943a(%rip),%rdi        # ffffffffbffff7c0 <_ZN2Ec7fpownerE>
ffffffff81006386:	48 39 3d 7b 8c ff 3e 	cmp    %rdi,0x3eff8c7b(%rip)        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100638d:	0f 84 84 00 00 00    	je     ffffffff81006417 <_ZN2Ec13handle_exc_nmEv+0xa1>

    fpowner = ec;
    fpowner->add_ref();
}

void Ec::handle_exc_nm() {
ffffffff81006393:	53                   	push   %rbx
    Fpu::enable();

    if (current == fpowner)
        return;

    fpowner->save_fpu();
ffffffff81006394:	e8 b1 fe ff ff       	callq  ffffffff8100624a <_ZN2Ec8save_fpuEv>
    current->load_fpu();
ffffffff81006399:	48 8b 3d 68 8c ff 3e 	mov    0x3eff8c68(%rip),%rdi        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff810063a0:	e8 71 fe ff ff       	callq  ffffffff81006216 <_ZN2Ec8load_fpuEv>

    if (fpowner && fpowner->del_ref())
ffffffff810063a5:	48 8b 05 14 94 ff 3e 	mov    0x3eff9414(%rip),%rax        # ffffffffbffff7c0 <_ZN2Ec7fpownerE>
ffffffff810063ac:	48 85 c0             	test   %rax,%rax
ffffffff810063af:	74 40                	je     ffffffff810063f1 <_ZN2Ec13handle_exc_nmEv+0x7b>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff810063b1:	83 ca ff             	or     $0xffffffff,%edx
ffffffff810063b4:	f0 0f c1 90 8c 00 00 	lock xadd %edx,0x8c(%rax)
ffffffff810063bb:	00 
ffffffff810063bc:	ff ca                	dec    %edx
ffffffff810063be:	75 31                	jne    ffffffff810063f1 <_ZN2Ec13handle_exc_nmEv+0x7b>
        delete fpowner;
ffffffff810063c0:	48 8b 1d f9 93 ff 3e 	mov    0x3eff93f9(%rip),%rbx        # ffffffffbffff7c0 <_ZN2Ec7fpownerE>
ffffffff810063c7:	48 85 db             	test   %rbx,%rbx
ffffffff810063ca:	74 25                	je     ffffffff810063f1 <_ZN2Ec13handle_exc_nmEv+0x7b>
ffffffff810063cc:	48 89 df             	mov    %rbx,%rdi
ffffffff810063cf:	e8 68 e0 ff ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
ffffffff810063d4:	48 8b 83 98 02 00 00 	mov    0x298(%rbx),%rax
ffffffff810063db:	48 89 de             	mov    %rbx,%rsi
ffffffff810063de:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff810063e5:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff810063ec:	e8 79 f6 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>

    fpowner = current;
ffffffff810063f1:	48 8b 15 10 8c ff 3e 	mov    0x3eff8c10(%rip),%rdx        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff810063f8:	48 89 15 c1 93 ff 3e 	mov    %rdx,0x3eff93c1(%rip)        # ffffffffbffff7c0 <_ZN2Ec7fpownerE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff810063ff:	8b 82 8c 00 00 00    	mov    0x8c(%rdx),%eax
ffffffff81006405:	85 c0                	test   %eax,%eax
ffffffff81006407:	74 0d                	je     ffffffff81006416 <_ZN2Ec13handle_exc_nmEv+0xa0>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff81006409:	8d 48 01             	lea    0x1(%rax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff8100640c:	f0 0f b1 8a 8c 00 00 	lock cmpxchg %ecx,0x8c(%rdx)
ffffffff81006413:	00 
ffffffff81006414:	75 e9                	jne    ffffffff810063ff <_ZN2Ec13handle_exc_nmEv+0x89>
    fpowner->add_ref();
}
ffffffff81006416:	5b                   	pop    %rbx
ffffffff81006417:	c3                   	retq   

ffffffff81006418 <_ZN2Ec13handle_exc_tsEP8Exc_regs>:

bool Ec::handle_exc_ts(Exc_regs *r) {
    if (r->user())
        return false;
ffffffff81006418:	31 c0                	xor    %eax,%eax
    fpowner = current;
    fpowner->add_ref();
}

bool Ec::handle_exc_ts(Exc_regs *r) {
    if (r->user())
ffffffff8100641a:	f6 87 b8 00 00 00 03 	testb  $0x3,0xb8(%rdi)
ffffffff81006421:	75 0d                	jne    ffffffff81006430 <_ZN2Ec13handle_exc_tsEP8Exc_regs+0x18>
        return false;

    // SYSENTER with EFLAGS.NT=1 and IRET faulted
    r->REG(fl) &= ~Cpu::EFL_NT;
ffffffff81006423:	48 81 a7 c0 00 00 00 	andq   $0xffffffffffffbfff,0xc0(%rdi)
ffffffff8100642a:	ff bf ff ff 

    return true;
ffffffff8100642e:	b0 01                	mov    $0x1,%al
}
ffffffff81006430:	c3                   	retq   
ffffffff81006431:	90                   	nop

ffffffff81006432 <_ZN2Ec13handle_exc_gpEP8Exc_regs>:

bool Ec::handle_exc_gp(Exc_regs *) {
    if (Cpu::hazard & HZD_TR) {
ffffffff81006432:	8b 15 c8 8b ff 3e    	mov    0x3eff8bc8(%rip),%edx        # ffffffffbffff000 <_ZN3Cpu6hazardE>
        Gdt::unbusy_tss();
        asm volatile ("ltr %w0" : : "r" (SEL_TSS_RUN));
        return true;
    }

    return false;
ffffffff81006438:	31 c0                	xor    %eax,%eax

    return true;
}

bool Ec::handle_exc_gp(Exc_regs *) {
    if (Cpu::hazard & HZD_TR) {
ffffffff8100643a:	f6 c2 04             	test   $0x4,%dl
ffffffff8100643d:	74 1d                	je     ffffffff8100645c <_ZN2Ec13handle_exc_gpEP8Exc_regs+0x2a>
        Cpu::hazard &= ~HZD_TR;
ffffffff8100643f:	83 e2 fb             	and    $0xfffffffb,%edx
        }

        ALWAYS_INLINE
        static inline void unbusy_tss()
        {
            gdt[SEL_TSS_RUN >> 3].val[1] &= ~0x200;
ffffffff81006442:	81 25 b0 93 ff 3e ff 	andl   $0xfffffdff,0x3eff93b0(%rip)        # ffffffffbffff7fc <_ZN3Gdt3gdtE+0x34>
ffffffff81006449:	fd ff ff 
        Gdt::unbusy_tss();
        asm volatile ("ltr %w0" : : "r" (SEL_TSS_RUN));
ffffffff8100644c:	b8 30 00 00 00       	mov    $0x30,%eax
    return true;
}

bool Ec::handle_exc_gp(Exc_regs *) {
    if (Cpu::hazard & HZD_TR) {
        Cpu::hazard &= ~HZD_TR;
ffffffff81006451:	89 15 a9 8b ff 3e    	mov    %edx,0x3eff8ba9(%rip)        # ffffffffbffff000 <_ZN3Cpu6hazardE>
        Gdt::unbusy_tss();
        asm volatile ("ltr %w0" : : "r" (SEL_TSS_RUN));
ffffffff81006457:	0f 00 d8             	ltr    %ax
        return true;
ffffffff8100645a:	b0 01                	mov    $0x1,%al
    }

    return false;
}
ffffffff8100645c:	c3                   	retq   
ffffffff8100645d:	90                   	nop

ffffffff8100645e <_ZN2Ec13handle_exc_pfEP8Exc_regs>:

bool Ec::handle_exc_pf(Exc_regs *r) {
ffffffff8100645e:	55                   	push   %rbp
ffffffff8100645f:	53                   	push   %rbx
ffffffff81006460:	48 ba ff ef ff ff ff 	movabs $0x7fffffffefff,%rdx
ffffffff81006467:	7f 00 00 
ffffffff8100646a:	41 52                	push   %r10
    mword addr = r->cr2;

    if (r->err & Hpt::ERR_U)
ffffffff8100646c:	f6 87 a0 00 00 00 04 	testb  $0x4,0xa0(%rdi)

    return false;
}

bool Ec::handle_exc_pf(Exc_regs *r) {
    mword addr = r->cr2;
ffffffff81006473:	48 8b 5f 58          	mov    0x58(%rdi),%rbx

    if (r->err & Hpt::ERR_U)
ffffffff81006477:	74 44                	je     ffffffff810064bd <_ZN2Ec13handle_exc_pfEP8Exc_regs+0x5f>
        return addr < USER_ADDR && Pd::current->Space_mem::loc[Cpu::id].sync_from(Pd::current->quota, Pd::current->Space_mem::hpt, addr, USER_ADDR);
ffffffff81006479:	31 c0                	xor    %eax,%eax
ffffffff8100647b:	48 39 d3             	cmp    %rdx,%rbx
ffffffff8100647e:	0f 87 29 01 00 00    	ja     ffffffff810065ad <_ZN2Ec13handle_exc_pfEP8Exc_regs+0x14f>
ffffffff81006484:	8b 0d 7a 8b ff 3e    	mov    0x3eff8b7a(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100648a:	48 8b 05 7f 8b ff 3e 	mov    0x3eff8b7f(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81006491:	49 b8 00 f0 ff ff ff 	movabs $0x7ffffffff000,%r8
ffffffff81006498:	7f 00 00 
ffffffff8100649b:	48 8b 90 a0 02 00 00 	mov    0x2a0(%rax),%rdx
ffffffff810064a2:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
        Space_obj::page_fault(addr, r->err);
        return true;
    }

    die("#PF (kernel)", r);
}
ffffffff810064a9:	41 59                	pop    %r9

bool Ec::handle_exc_pf(Exc_regs *r) {
    mword addr = r->cr2;

    if (r->err & Hpt::ERR_U)
        return addr < USER_ADDR && Pd::current->Space_mem::loc[Cpu::id].sync_from(Pd::current->quota, Pd::current->Space_mem::hpt, addr, USER_ADDR);
ffffffff810064ab:	48 8d bc c8 a0 00 00 	lea    0xa0(%rax,%rcx,8),%rdi
ffffffff810064b2:	00 
ffffffff810064b3:	48 89 d9             	mov    %rbx,%rcx
        Space_obj::page_fault(addr, r->err);
        return true;
    }

    die("#PF (kernel)", r);
}
ffffffff810064b6:	5b                   	pop    %rbx
ffffffff810064b7:	5d                   	pop    %rbp

bool Ec::handle_exc_pf(Exc_regs *r) {
    mword addr = r->cr2;

    if (r->err & Hpt::ERR_U)
        return addr < USER_ADDR && Pd::current->Space_mem::loc[Cpu::id].sync_from(Pd::current->quota, Pd::current->Space_mem::hpt, addr, USER_ADDR);
ffffffff810064b8:	e9 c5 1a 00 00       	jmpq   ffffffff81007f82 <_ZN3Hpt9sync_fromER5QuotaS_mm>

    if (addr < USER_ADDR) {
ffffffff810064bd:	48 39 d3             	cmp    %rdx,%rbx
ffffffff810064c0:	48 89 fd             	mov    %rdi,%rbp
ffffffff810064c3:	77 56                	ja     ffffffff8100651b <_ZN2Ec13handle_exc_pfEP8Exc_regs+0xbd>

        if (Pd::current->Space_mem::loc[Cpu::id].sync_from(Pd::current->quota, Pd::current->Space_mem::hpt, addr, USER_ADDR))
ffffffff810064c5:	48 8b 05 44 8b ff 3e 	mov    0x3eff8b44(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff810064cc:	8b 0d 32 8b ff 3e    	mov    0x3eff8b32(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff810064d2:	49 b8 00 f0 ff ff ff 	movabs $0x7ffffffff000,%r8
ffffffff810064d9:	7f 00 00 
ffffffff810064dc:	48 8b 90 a0 02 00 00 	mov    0x2a0(%rax),%rdx
ffffffff810064e3:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff810064ea:	48 8d bc c8 a0 00 00 	lea    0xa0(%rax,%rcx,8),%rdi
ffffffff810064f1:	00 
ffffffff810064f2:	48 89 d9             	mov    %rbx,%rcx
ffffffff810064f5:	e8 88 1a 00 00       	callq  ffffffff81007f82 <_ZN3Hpt9sync_fromER5QuotaS_mm>
ffffffff810064fa:	84 c0                	test   %al,%al
ffffffff810064fc:	0f 85 98 00 00 00    	jne    ffffffff8100659a <_ZN2Ec13handle_exc_pfEP8Exc_regs+0x13c>
            return true;

        if (fixup(r->REG(ip))) {
ffffffff81006502:	48 8d bd b0 00 00 00 	lea    0xb0(%rbp),%rdi
ffffffff81006509:	e8 d2 e6 ff ff       	callq  ffffffff81004be0 <_ZN2Ec5fixupERm>
ffffffff8100650e:	84 c0                	test   %al,%al
ffffffff81006510:	74 09                	je     ffffffff8100651b <_ZN2Ec13handle_exc_pfEP8Exc_regs+0xbd>
            r->REG(ax) = addr;
ffffffff81006512:	48 89 5d 78          	mov    %rbx,0x78(%rbp)
            return true;
ffffffff81006516:	e9 92 00 00 00       	jmpq   ffffffff810065ad <_ZN2Ec13handle_exc_pfEP8Exc_regs+0x14f>
        }
    }

    if (addr >= LINK_ADDR && addr < CPU_LOCAL && Pd::current->Space_mem::loc[Cpu::id].sync_from(Pd::current->quota, Hptp(reinterpret_cast<mword> (&PDBR)), addr, CPU_LOCAL))
ffffffff8100651b:	48 8d 83 00 00 00 7f 	lea    0x7f000000(%rbx),%rax
ffffffff81006522:	48 3d ff ff df 3e    	cmp    $0x3edfffff,%rax
ffffffff81006528:	76 20                	jbe    ffffffff8100654a <_ZN2Ec13handle_exc_pfEP8Exc_regs+0xec>
        return true;

    // Kernel fault in I/O space
    if (addr >= SPC_LOCAL_IOP && addr <= SPC_LOCAL_IOP_E) {
ffffffff8100652a:	48 8d 83 00 00 00 40 	lea    0x40000000(%rbx),%rax
ffffffff81006531:	48 3d 00 20 00 00    	cmp    $0x2000,%rax
ffffffff81006537:	77 49                	ja     ffffffff81006582 <_ZN2Ec13handle_exc_pfEP8Exc_regs+0x124>
        Space_pio::page_fault(addr, r->err);
ffffffff81006539:	48 8b b5 a0 00 00 00 	mov    0xa0(%rbp),%rsi
ffffffff81006540:	48 89 df             	mov    %rbx,%rdi
ffffffff81006543:	e8 78 08 01 00       	callq  ffffffff81016dc0 <_ZN9Space_pio10page_faultEmm>
ffffffff81006548:	eb 50                	jmp    ffffffff8100659a <_ZN2Ec13handle_exc_pfEP8Exc_regs+0x13c>
            r->REG(ax) = addr;
            return true;
        }
    }

    if (addr >= LINK_ADDR && addr < CPU_LOCAL && Pd::current->Space_mem::loc[Cpu::id].sync_from(Pd::current->quota, Hptp(reinterpret_cast<mword> (&PDBR)), addr, CPU_LOCAL))
ffffffff8100654a:	8b 15 b4 8a ff 3e    	mov    0x3eff8ab4(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81006550:	48 8b 05 b9 8a ff 3e 	mov    0x3eff8ab9(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81006557:	49 c7 c0 00 00 e0 bf 	mov    $0xffffffffbfe00000,%r8
ffffffff8100655e:	48 89 d9             	mov    %rbx,%rcx
ffffffff81006561:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff81006568:	48 8d bc d0 a0 00 00 	lea    0xa0(%rax,%rdx,8),%rdi
ffffffff8100656f:	00 
ffffffff81006570:	48 c7 c2 00 80 56 00 	mov    $0x568000,%rdx
ffffffff81006577:	e8 06 1a 00 00       	callq  ffffffff81007f82 <_ZN3Hpt9sync_fromER5QuotaS_mm>
ffffffff8100657c:	84 c0                	test   %al,%al
ffffffff8100657e:	75 1a                	jne    ffffffff8100659a <_ZN2Ec13handle_exc_pfEP8Exc_regs+0x13c>
ffffffff81006580:	eb a8                	jmp    ffffffff8100652a <_ZN2Ec13handle_exc_pfEP8Exc_regs+0xcc>
        Space_pio::page_fault(addr, r->err);
        return true;
    }

    // Kernel fault in OBJ space
    if (addr >= SPC_LOCAL_OBJ) {
ffffffff81006582:	48 81 fb ff ff ff df 	cmp    $0xffffffffdfffffff,%rbx
ffffffff81006589:	76 13                	jbe    ffffffff8100659e <_ZN2Ec13handle_exc_pfEP8Exc_regs+0x140>
        Space_obj::page_fault(addr, r->err);
ffffffff8100658b:	48 8b b5 a0 00 00 00 	mov    0xa0(%rbp),%rsi
ffffffff81006592:	48 89 df             	mov    %rbx,%rdi
ffffffff81006595:	e8 20 05 01 00       	callq  ffffffff81016aba <_ZN9Space_obj10page_faultEmm>
        return true;

    // Kernel fault in I/O space
    if (addr >= SPC_LOCAL_IOP && addr <= SPC_LOCAL_IOP_E) {
        Space_pio::page_fault(addr, r->err);
        return true;
ffffffff8100659a:	b0 01                	mov    $0x1,%al
ffffffff8100659c:	eb 0f                	jmp    ffffffff810065ad <_ZN2Ec13handle_exc_pfEP8Exc_regs+0x14f>
    if (addr >= SPC_LOCAL_OBJ) {
        Space_obj::page_fault(addr, r->err);
        return true;
    }

    die("#PF (kernel)", r);
ffffffff8100659e:	48 89 ee             	mov    %rbp,%rsi
ffffffff810065a1:	48 c7 c7 44 e1 01 81 	mov    $0xffffffff8101e144,%rdi
ffffffff810065a8:	e8 5d e6 ff ff       	callq  ffffffff81004c0a <_ZN2Ec3dieEPKcP8Exc_regs>
}
ffffffff810065ad:	5a                   	pop    %rdx
ffffffff810065ae:	5b                   	pop    %rbx
ffffffff810065af:	5d                   	pop    %rbp
ffffffff810065b0:	c3                   	retq   
ffffffff810065b1:	90                   	nop

ffffffff810065b2 <exc_handler>:

void Ec::handle_exc(Exc_regs *r) {
ffffffff810065b2:	53                   	push   %rbx
    Counter::exc[r->vec]++;
ffffffff810065b3:	48 8b 87 a8 00 00 00 	mov    0xa8(%rdi),%rax
    }

    die("#PF (kernel)", r);
}

void Ec::handle_exc(Exc_regs *r) {
ffffffff810065ba:	48 89 fb             	mov    %rdi,%rbx
    Counter::exc[r->vec]++;
ffffffff810065bd:	ff 04 85 80 f4 ff bf 	incl   -0x40000b80(,%rax,4)

    switch (r->vec) {
ffffffff810065c4:	48 83 e8 07          	sub    $0x7,%rax
ffffffff810065c8:	48 83 f8 0b          	cmp    $0xb,%rax
ffffffff810065cc:	77 2b                	ja     ffffffff810065f9 <exc_handler+0x47>
ffffffff810065ce:	ff 24 c5 90 e1 01 81 	jmpq   *-0x7efe1e70(,%rax,8)

    if (r->user())
        send_msg<ret_user_iret>();

    die("EXC", r);
}
ffffffff810065d5:	5b                   	pop    %rbx
    Counter::exc[r->vec]++;

    switch (r->vec) {

        case Cpu::EXC_NM:
            handle_exc_nm();
ffffffff810065d6:	e9 9b fd ff ff       	jmpq   ffffffff81006376 <_ZN2Ec13handle_exc_nmEv>
            return;

        case Cpu::EXC_TS:
            if (handle_exc_ts(r))
ffffffff810065db:	e8 38 fe ff ff       	callq  ffffffff81006418 <_ZN2Ec13handle_exc_tsEP8Exc_regs>
ffffffff810065e0:	eb 0c                	jmp    ffffffff810065ee <exc_handler+0x3c>
                return;
            break;

        case Cpu::EXC_GP:
            if (handle_exc_gp(r))
ffffffff810065e2:	e8 4b fe ff ff       	callq  ffffffff81006432 <_ZN2Ec13handle_exc_gpEP8Exc_regs>
ffffffff810065e7:	eb 05                	jmp    ffffffff810065ee <exc_handler+0x3c>
                return;
            break;

        case Cpu::EXC_PF:
            if (handle_exc_pf(r))
ffffffff810065e9:	e8 70 fe ff ff       	callq  ffffffff8100645e <_ZN2Ec13handle_exc_pfEP8Exc_regs>
ffffffff810065ee:	84 c0                	test   %al,%al
ffffffff810065f0:	74 07                	je     ffffffff810065f9 <exc_handler+0x47>
ffffffff810065f2:	eb 22                	jmp    ffffffff81006616 <exc_handler+0x64>
                return;
            break;

        case Cpu::EXC_MC:
            Mca::vector();
ffffffff810065f4:	e8 49 22 00 00       	callq  ffffffff81008842 <_ZN3Mca6vectorEv>
            break;
    }

    if (r->user())
ffffffff810065f9:	f6 83 b8 00 00 00 03 	testb  $0x3,0xb8(%rbx)
ffffffff81006600:	74 05                	je     ffffffff81006607 <exc_handler+0x55>
        send_msg<ret_user_iret>();
ffffffff81006602:	e8 3b 16 01 00       	callq  ffffffff81017c42 <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv>

    die("EXC", r);
ffffffff81006607:	48 89 de             	mov    %rbx,%rsi
ffffffff8100660a:	48 c7 c7 51 e1 01 81 	mov    $0xffffffff8101e151,%rdi
ffffffff81006611:	e8 f4 e5 ff ff       	callq  ffffffff81004c0a <_ZN2Ec3dieEPKcP8Exc_regs>
}
ffffffff81006616:	5b                   	pop    %rbx
ffffffff81006617:	c3                   	retq   

ffffffff81006618 <memory_checker>:
void Ec::check_memory(mword from) {
//            Console::print(".....  Checking memory from %lx.", from);
    //    if (!current->user_utcb) {
    //        current->debug = true;
    //    }
    if ((Ec::current->is_idle()) || (Ec::current->cow_list == nullptr)) {
ffffffff81006618:	48 8b 05 e9 89 ff 3e 	mov    0x3eff89e9(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100661f:	83 b8 4c 03 00 00 00 	cmpl   $0x0,0x34c(%rax)
ffffffff81006626:	0f 84 52 01 00 00    	je     ffffffff8100677e <memory_checker+0x166>
ffffffff8100662c:	48 83 b8 40 03 00 00 	cmpq   $0x0,0x340(%rax)
ffffffff81006633:	00 
ffffffff81006634:	0f 84 44 01 00 00    	je     ffffffff8100677e <memory_checker+0x166>
        send_msg<ret_user_iret>();

    die("EXC", r);
}

void Ec::check_memory(mword from) {
ffffffff8100663a:	52                   	push   %rdx
ffffffff8100663b:	48 89 fe             	mov    %rdi,%rsi
        current->launch_state = Ec::unlaunched;
        return;
    }
//    if (!current->user_utcb && current->hardening_started) {
//        if (from == 0x60) {
            Console::print(".....  Checking memory from %lx.", from);
ffffffff8100663e:	31 c0                	xor    %eax,%eax
ffffffff81006640:	48 c7 c7 6d e1 01 81 	mov    $0xffffffff8101e16d,%rdi
ffffffff81006647:	e8 40 ba ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
//        }
//    }

    if (Ec::current->one_run_ok()) {
ffffffff8100664c:	48 8b 3d b5 89 ff 3e 	mov    0x3eff89b5(%rip),%rdi        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81006653:	80 bf 4a 03 00 00 01 	cmpb   $0x1,0x34a(%rdi)
ffffffff8100665a:	0f 85 ba 00 00 00    	jne    ffffffff8100671a <memory_checker+0x102>
        //        Console::print("Tour 2 Ec: %p  Pd: %p", current, current->pd.operator->());
        if (Ec::current->compare_and_commit()) {
ffffffff81006660:	e8 ef f6 ff ff       	callq  ffffffff81005d54 <_ZN2Ec18compare_and_commitEv>
ffffffff81006665:	84 c0                	test   %al,%al
ffffffff81006667:	74 28                	je     ffffffff81006691 <memory_checker+0x79>
            current->cow_list = nullptr;
ffffffff81006669:	48 8b 05 98 89 ff 3e 	mov    0x3eff8998(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81006670:	48 c7 80 40 03 00 00 	movq   $0x0,0x340(%rax)
ffffffff81006677:	00 00 00 00 
            current->run_number = 0;
ffffffff8100667b:	c6 80 4a 03 00 00 00 	movb   $0x0,0x34a(%rax)
            current->launch_state = Ec::unlaunched;
ffffffff81006682:	c7 80 4c 03 00 00 00 	movl   $0x0,0x34c(%rax)
ffffffff81006689:	00 00 00 
            return;
ffffffff8100668c:	e9 ff 00 00 00       	jmpq   ffffffff81006790 <memory_checker+0x178>
        } else {
            Console::print("Checking failed");
ffffffff81006691:	31 c0                	xor    %eax,%eax
ffffffff81006693:	48 c7 c7 55 e1 01 81 	mov    $0xffffffff8101e155,%rdi
ffffffff8100669a:	e8 ed b9 ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
            Ec::current->rollback();
ffffffff8100669f:	48 8b 3d 62 89 ff 3e 	mov    0x3eff8962(%rip),%rdi        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff810066a6:	e8 3f f4 ff ff       	callq  ffffffff81005aea <_ZN2Ec8rollbackEv>
            current->run_number = 0;
ffffffff810066ab:	48 8b 05 56 89 ff 3e 	mov    0x3eff8956(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
            current->cow_list = nullptr;
            switch (current->launch_state) {
ffffffff810066b2:	83 b8 4c 03 00 00 04 	cmpl   $0x4,0x34c(%rax)
            current->launch_state = Ec::unlaunched;
            return;
        } else {
            Console::print("Checking failed");
            Ec::current->rollback();
            current->run_number = 0;
ffffffff810066b9:	c6 80 4a 03 00 00 00 	movb   $0x0,0x34a(%rax)
            current->cow_list = nullptr;
ffffffff810066c0:	48 c7 80 40 03 00 00 	movq   $0x0,0x340(%rax)
ffffffff810066c7:	00 00 00 00 
            switch (current->launch_state) {
ffffffff810066cb:	0f 87 bf 00 00 00    	ja     ffffffff81006790 <memory_checker+0x178>
ffffffff810066d1:	8b 80 4c 03 00 00    	mov    0x34c(%rax),%eax
ffffffff810066d7:	ff 24 c5 f0 e1 01 81 	jmpq   *-0x7efe1e10(,%rax,8)
                case Ec::sysexit:
                    Ec::ret_user_sysexit();
ffffffff810066de:	e8 1d 99 ff ff       	callq  ffffffff81000000 <_ZN2Ec16ret_user_sysexitEv>
                    break;
                case Ec::iret:
                    Ec::ret_user_iret();
ffffffff810066e3:	e8 a4 99 ff ff       	callq  ffffffff8100008c <ret_user_iret>
                case Ec::vmresume:
                    Ec::ret_user_vmresume();
ffffffff810066e8:	e8 65 ea ff ff       	callq  ffffffff81005152 <_ZN2Ec17ret_user_vmresumeEv>
                case Ec::vmrun:
                    Ec::ret_user_vmrun();
ffffffff810066ed:	e8 98 e3 ff ff       	callq  ffffffff81004a8a <_ZN2Ec14ret_user_vmrunEv>
                case Ec::unlaunched:
                    Console::print("Bad Run");
ffffffff810066f2:	48 c7 c7 65 e1 01 81 	mov    $0xffffffff8101e165,%rdi
ffffffff810066f9:	31 c0                	xor    %eax,%eax
ffffffff810066fb:	e8 8c b9 ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
                    Ec::die("Bad Run");
ffffffff81006700:	48 8b 05 01 89 ff 3e 	mov    0x3eff8901(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81006707:	48 c7 c7 65 e1 01 81 	mov    $0xffffffff8101e165,%rdi
ffffffff8100670e:	48 8d b0 a8 00 00 00 	lea    0xa8(%rax),%rsi
ffffffff81006715:	e8 f0 e4 ff ff       	callq  ffffffff81004c0a <_ZN2Ec3dieEPKcP8Exc_regs>
            }
        }
    } else {
        //        Console::print("Tour 1 Ec: %p  Pd: %p", current, current->pd.operator->());
        Ec::current->restore_state();
ffffffff8100671a:	e8 c3 f1 ff ff       	callq  ffffffff810058e2 <_ZN2Ec13restore_stateEv>
        current->run_number++;
ffffffff8100671f:	48 8b 05 e2 88 ff 3e 	mov    0x3eff88e2(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81006726:	fe 80 4a 03 00 00    	incb   0x34a(%rax)
        switch (current->launch_state) {
ffffffff8100672c:	83 b8 4c 03 00 00 04 	cmpl   $0x4,0x34c(%rax)
ffffffff81006733:	77 5b                	ja     ffffffff81006790 <memory_checker+0x178>
ffffffff81006735:	8b 80 4c 03 00 00    	mov    0x34c(%rax),%eax
ffffffff8100673b:	ff 24 c5 18 e2 01 81 	jmpq   *-0x7efe1de8(,%rax,8)
            case Ec::sysexit:
                Ec::ret_user_sysexit();
ffffffff81006742:	e8 b9 98 ff ff       	callq  ffffffff81000000 <_ZN2Ec16ret_user_sysexitEv>
                break;
            case Ec::iret:
                Ec::ret_user_iret();
ffffffff81006747:	e8 40 99 ff ff       	callq  ffffffff8100008c <ret_user_iret>
            case Ec::vmresume:
                Ec::ret_user_vmresume();
ffffffff8100674c:	e8 01 ea ff ff       	callq  ffffffff81005152 <_ZN2Ec17ret_user_vmresumeEv>
            case Ec::vmrun:
                Ec::ret_user_vmrun();
ffffffff81006751:	e8 34 e3 ff ff       	callq  ffffffff81004a8a <_ZN2Ec14ret_user_vmrunEv>
            case Ec::unlaunched:
                Console::print("Bad Run");
ffffffff81006756:	48 c7 c7 65 e1 01 81 	mov    $0xffffffff8101e165,%rdi
ffffffff8100675d:	31 c0                	xor    %eax,%eax
ffffffff8100675f:	e8 28 b9 ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
                Ec::die("Bad Run");
ffffffff81006764:	48 8b 05 9d 88 ff 3e 	mov    0x3eff889d(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100676b:	48 c7 c7 65 e1 01 81 	mov    $0xffffffff8101e165,%rdi
ffffffff81006772:	48 8d b0 a8 00 00 00 	lea    0xa8(%rax),%rsi
ffffffff81006779:	e8 8c e4 ff ff       	callq  ffffffff81004c0a <_ZN2Ec3dieEPKcP8Exc_regs>
//            Console::print(".....  Checking memory from %lx.", from);
    //    if (!current->user_utcb) {
    //        current->debug = true;
    //    }
    if ((Ec::current->is_idle()) || (Ec::current->cow_list == nullptr)) {
        current->run_number = 0;
ffffffff8100677e:	c6 80 4a 03 00 00 00 	movb   $0x0,0x34a(%rax)
        current->launch_state = Ec::unlaunched;
ffffffff81006785:	c7 80 4c 03 00 00 00 	movl   $0x0,0x34c(%rax)
ffffffff8100678c:	00 00 00 
        return;
ffffffff8100678f:	c3                   	retq   

    //        /*when atomic sequence is executed in parallel, it is an other EC which 
    //         should be picked. Make sure this is respected*/
    //        Sc::schedule();
    return;
}
ffffffff81006790:	58                   	pop    %rax
ffffffff81006791:	c3                   	retq   

ffffffff81006792 <_ZN2Ec6ifetchEm>:

#include "ec.hpp"
#include "svm.hpp"
#include "vtlb.hpp"

uint8 Ec::ifetch(mword virt) {
ffffffff81006792:	48 83 ec 28          	sub    $0x28,%rsp
    mword phys, attr = 0, type = 0;
    uint8 opcode;

    if (!Vtlb::gwalk(&current->regs, virt, phys, attr, type))
ffffffff81006796:	48 8b 05 6b 88 ff 3e 	mov    0x3eff886b(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>

#include "ec.hpp"
#include "svm.hpp"
#include "vtlb.hpp"

uint8 Ec::ifetch(mword virt) {
ffffffff8100679d:	48 89 fe             	mov    %rdi,%rsi
    mword phys, attr = 0, type = 0;
    uint8 opcode;

    if (!Vtlb::gwalk(&current->regs, virt, phys, attr, type))
ffffffff810067a0:	4c 8d 44 24 18       	lea    0x18(%rsp),%r8
ffffffff810067a5:	48 8d 4c 24 10       	lea    0x10(%rsp),%rcx
ffffffff810067aa:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
#include "ec.hpp"
#include "svm.hpp"
#include "vtlb.hpp"

uint8 Ec::ifetch(mword virt) {
    mword phys, attr = 0, type = 0;
ffffffff810067af:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
ffffffff810067b6:	00 00 
ffffffff810067b8:	48 c7 44 24 18 00 00 	movq   $0x0,0x18(%rsp)
ffffffff810067bf:	00 00 
    uint8 opcode;

    if (!Vtlb::gwalk(&current->regs, virt, phys, attr, type))
ffffffff810067c1:	48 8d b8 a8 00 00 00 	lea    0xa8(%rax),%rdi
ffffffff810067c8:	e8 15 61 01 00       	callq  ffffffff8101c8e2 <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_>
ffffffff810067cd:	48 85 c0             	test   %rax,%rax
ffffffff810067d0:	75 17                	jne    ffffffff810067e9 <_ZN2Ec6ifetchEm+0x57>
        die("SVM TLB failure");
ffffffff810067d2:	48 8b 05 2f 88 ff 3e 	mov    0x3eff882f(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff810067d9:	48 c7 c7 40 e2 01 81 	mov    $0xffffffff8101e240,%rdi
ffffffff810067e0:	48 8d b0 a8 00 00 00 	lea    0xa8(%rax),%rsi
ffffffff810067e7:	eb 25                	jmp    ffffffff8100680e <_ZN2Ec6ifetchEm+0x7c>
        static inline mword peek (T *addr, T &val)
        {
            mword ret;
            asm volatile ("1: mov %2, %1; or $-1, %0; 2:"
                          ".section .fixup,\"a\"; .align 8;" EXPAND (WORD) " 1b,2b; .previous"
                          : "=a" (ret), "=q" (val) : "m" (*addr));
ffffffff810067e9:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
ffffffff810067ee:	8a 10                	mov    (%rax),%dl
ffffffff810067f0:	48 83 c8 ff          	or     $0xffffffffffffffff,%rax

    if (User::peek(reinterpret_cast<uint8 *> (phys), opcode) != ~0UL)
ffffffff810067f4:	48 ff c0             	inc    %rax
ffffffff810067f7:	74 1a                	je     ffffffff81006813 <_ZN2Ec6ifetchEm+0x81>
        die("SVM ifetch failure");
ffffffff810067f9:	48 8b 05 08 88 ff 3e 	mov    0x3eff8808(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81006800:	48 c7 c7 50 e2 01 81 	mov    $0xffffffff8101e250,%rdi
ffffffff81006807:	48 8d b0 a8 00 00 00 	lea    0xa8(%rax),%rsi
ffffffff8100680e:	e8 f7 e3 ff ff       	callq  ffffffff81004c0a <_ZN2Ec3dieEPKcP8Exc_regs>

    return opcode;
}
ffffffff81006813:	88 d0                	mov    %dl,%al
ffffffff81006815:	48 83 c4 28          	add    $0x28,%rsp
ffffffff81006819:	c3                   	retq   

ffffffff8100681a <_ZN2Ec13svm_exceptionEm>:

void Ec::svm_exception(mword reason) {
ffffffff8100681a:	55                   	push   %rbp
ffffffff8100681b:	53                   	push   %rbx
ffffffff8100681c:	48 89 fb             	mov    %rdi,%rbx
ffffffff8100681f:	48 83 ec 28          	sub    $0x28,%rsp
    if (current->regs.vmcb->exitintinfo & 0x80000000) {
ffffffff81006823:	48 8b 05 de 87 ff 3e 	mov    0x3eff87de(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100682a:	48 8b b8 28 01 00 00 	mov    0x128(%rax),%rdi
ffffffff81006831:	48 8b 97 88 00 00 00 	mov    0x88(%rdi),%rdx
ffffffff81006838:	f7 c2 00 00 00 80    	test   $0x80000000,%edx
ffffffff8100683e:	74 26                	je     ffffffff81006866 <_ZN2Ec13svm_exceptionEm+0x4c>

        mword t = static_cast<mword> (current->regs.vmcb->exitintinfo) >> 8 & 0x7;
ffffffff81006840:	48 89 d1             	mov    %rdx,%rcx
ffffffff81006843:	48 c1 e9 08          	shr    $0x8,%rcx
        mword v = static_cast<mword> (current->regs.vmcb->exitintinfo) & 0xff;

        if (t == 0 || (t == 3 && v != 3 && v != 4))
ffffffff81006847:	83 e1 07             	and    $0x7,%ecx
ffffffff8100684a:	74 13                	je     ffffffff8100685f <_ZN2Ec13svm_exceptionEm+0x45>

void Ec::svm_exception(mword reason) {
    if (current->regs.vmcb->exitintinfo & 0x80000000) {

        mword t = static_cast<mword> (current->regs.vmcb->exitintinfo) >> 8 & 0x7;
        mword v = static_cast<mword> (current->regs.vmcb->exitintinfo) & 0xff;
ffffffff8100684c:	0f b6 f2             	movzbl %dl,%esi

        if (t == 0 || (t == 3 && v != 3 && v != 4))
ffffffff8100684f:	48 83 ee 03          	sub    $0x3,%rsi
ffffffff81006853:	48 83 fe 01          	cmp    $0x1,%rsi
ffffffff81006857:	76 0d                	jbe    ffffffff81006866 <_ZN2Ec13svm_exceptionEm+0x4c>
ffffffff81006859:	48 83 f9 03          	cmp    $0x3,%rcx
ffffffff8100685d:	75 07                	jne    ffffffff81006866 <_ZN2Ec13svm_exceptionEm+0x4c>
            current->regs.vmcb->inj_control = current->regs.vmcb->exitintinfo;
ffffffff8100685f:	48 89 97 a8 00 00 00 	mov    %rdx,0xa8(%rdi)
    }

    switch (reason) {
ffffffff81006866:	48 83 fb 47          	cmp    $0x47,%rbx
ffffffff8100686a:	74 12                	je     ffffffff8100687e <_ZN2Ec13svm_exceptionEm+0x64>
ffffffff8100686c:	48 83 fb 4e          	cmp    $0x4e,%rbx
ffffffff81006870:	74 20                	je     ffffffff81006892 <_ZN2Ec13svm_exceptionEm+0x78>

        default:
            current->regs.dst_portal = reason;
ffffffff81006872:	48 89 98 50 01 00 00 	mov    %rbx,0x150(%rax)
ffffffff81006879:	e9 f8 00 00 00       	jmpq   ffffffff81006976 <_ZN2Ec13svm_exceptionEm+0x15c>
            break;

        case 0x47: // #NM
            check_memory(reason);
ffffffff8100687e:	bf 47 00 00 00       	mov    $0x47,%edi
ffffffff81006883:	e8 90 fd ff ff       	callq  ffffffff81006618 <memory_checker>
            handle_exc_nm();
ffffffff81006888:	e8 e9 fa ff ff       	callq  ffffffff81006376 <_ZN2Ec13handle_exc_nmEv>
ffffffff8100688d:	e9 df 00 00 00       	jmpq   ffffffff81006971 <_ZN2Ec13svm_exceptionEm+0x157>
            ret_user_vmrun();

        case 0x4e: // #PF
            mword err = static_cast<mword> (current->regs.vmcb->exitinfo1);
ffffffff81006892:	48 8b 90 28 01 00 00 	mov    0x128(%rax),%rdx
            mword cr2 = static_cast<mword> (current->regs.vmcb->exitinfo2);

            mword phys;
            Paddr host;
            switch (Vtlb::miss(&current->regs, cr2, err, phys, host)) {
ffffffff81006899:	48 8d b8 a8 00 00 00 	lea    0xa8(%rax),%rdi
ffffffff810068a0:	4c 8d 44 24 18       	lea    0x18(%rsp),%r8
            check_memory(reason);
            handle_exc_nm();
            ret_user_vmrun();

        case 0x4e: // #PF
            mword err = static_cast<mword> (current->regs.vmcb->exitinfo1);
ffffffff810068a5:	48 8b 4a 78          	mov    0x78(%rdx),%rcx
            mword cr2 = static_cast<mword> (current->regs.vmcb->exitinfo2);
ffffffff810068a9:	48 8b aa 80 00 00 00 	mov    0x80(%rdx),%rbp

            mword phys;
            Paddr host;
            switch (Vtlb::miss(&current->regs, cr2, err, phys, host)) {
ffffffff810068b0:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
            check_memory(reason);
            handle_exc_nm();
            ret_user_vmrun();

        case 0x4e: // #PF
            mword err = static_cast<mword> (current->regs.vmcb->exitinfo1);
ffffffff810068b5:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
            mword cr2 = static_cast<mword> (current->regs.vmcb->exitinfo2);

            mword phys;
            Paddr host;
            switch (Vtlb::miss(&current->regs, cr2, err, phys, host)) {
ffffffff810068ba:	48 8d 4c 24 10       	lea    0x10(%rsp),%rcx
ffffffff810068bf:	48 89 ee             	mov    %rbp,%rsi
ffffffff810068c2:	e8 25 65 01 00       	callq  ffffffff8101cdec <_ZN4Vtlb4missEP8Exc_regsmRmS2_S2_>
ffffffff810068c7:	83 f8 01             	cmp    $0x1,%eax
ffffffff810068ca:	0f 84 a1 00 00 00    	je     ffffffff81006971 <_ZN2Ec13svm_exceptionEm+0x157>
ffffffff810068d0:	7f 0d                	jg     ffffffff810068df <_ZN2Ec13svm_exceptionEm+0xc5>
ffffffff810068d2:	85 c0                	test   %eax,%eax
ffffffff810068d4:	0f 84 97 00 00 00    	je     ffffffff81006971 <_ZN2Ec13svm_exceptionEm+0x157>
ffffffff810068da:	e9 97 00 00 00       	jmpq   ffffffff81006976 <_ZN2Ec13svm_exceptionEm+0x15c>
ffffffff810068df:	83 f8 02             	cmp    $0x2,%eax
ffffffff810068e2:	74 59                	je     ffffffff8100693d <_ZN2Ec13svm_exceptionEm+0x123>
ffffffff810068e4:	83 f8 03             	cmp    $0x3,%eax
ffffffff810068e7:	0f 85 89 00 00 00    	jne    ffffffff81006976 <_ZN2Ec13svm_exceptionEm+0x15c>

                case Vtlb::GPA_HPA:
                    current->regs.nst_error = 0;
ffffffff810068ed:	48 8b 05 14 87 ff 3e 	mov    0x3eff8714(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff810068f4:	48 c7 80 60 01 00 00 	movq   $0x0,0x160(%rax)
ffffffff810068fb:	00 00 00 00 
                    current->regs.dst_portal = NUM_VMI - 4;
ffffffff810068ff:	48 c7 80 50 01 00 00 	movq   $0xfc,0x150(%rax)
ffffffff81006906:	fc 00 00 00 
                    //                    if (current->debug) {
                    //                                            Console::print("GPA_HPA gla: %08lx  gpa: %08lx  host: %08lx  err: %08lx  rip: %llx", cr2, phys, host, err, current->regs.vmcb->rip);
                    //                    }
                    if (cr2 == 0xc6400008 && phys == 0x06400008) {
ffffffff8100690a:	b8 08 00 40 c6       	mov    $0xc6400008,%eax
ffffffff8100690f:	48 39 c5             	cmp    %rax,%rbp
ffffffff81006912:	75 62                	jne    ffffffff81006976 <_ZN2Ec13svm_exceptionEm+0x15c>
ffffffff81006914:	48 81 7c 24 10 08 00 	cmpq   $0x6400008,0x10(%rsp)
ffffffff8100691b:	40 06 
ffffffff8100691d:	75 57                	jne    ffffffff81006976 <_ZN2Ec13svm_exceptionEm+0x15c>
                        Console::print("Hardening begin");
ffffffff8100691f:	31 c0                	xor    %eax,%eax
ffffffff81006921:	48 c7 c7 63 e2 01 81 	mov    $0xffffffff8101e263,%rdi
ffffffff81006928:	e8 5f b7 ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
                        current->hardening_started = true;
ffffffff8100692d:	48 8b 05 d4 86 ff 3e 	mov    0x3eff86d4(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81006934:	c6 80 51 03 00 00 01 	movb   $0x1,0x351(%rax)
ffffffff8100693b:	eb 39                	jmp    ffffffff81006976 <_ZN2Ec13svm_exceptionEm+0x15c>
                    }
                    break;

                case Vtlb::GLA_GPA:
                    current->regs.vmcb->cr2 = cr2;
ffffffff8100693d:	48 8b 05 c4 86 ff 3e 	mov    0x3eff86c4(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81006944:	48 8b 90 28 01 00 00 	mov    0x128(%rax),%rdx
ffffffff8100694b:	48 89 aa 40 06 00 00 	mov    %rbp,0x640(%rdx)
                    current->regs.vmcb->inj_control = static_cast<uint64> (err) << 32 | 0x80000b0e;
ffffffff81006952:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
ffffffff81006957:	48 8b 88 28 01 00 00 	mov    0x128(%rax),%rcx
ffffffff8100695e:	b8 0e 0b 00 80       	mov    $0x80000b0e,%eax
ffffffff81006963:	48 c1 e2 20          	shl    $0x20,%rdx
ffffffff81006967:	48 09 d0             	or     %rdx,%rax
ffffffff8100696a:	48 89 81 a8 00 00 00 	mov    %rax,0xa8(%rcx)
                    //                    if (current->debug) {
                    //                                            Console::print("GLA_GPA gla: %08lx  gpa: %08lx  host: %08lx  err: %08lx  rip: %llx", cr2, phys, host, err, current->regs.vmcb->rip);
                    //                    }
                    ret_user_vmrun();
ffffffff81006971:	e8 14 e1 ff ff       	callq  ffffffff81004a8a <_ZN2Ec14ret_user_vmrunEv>
                    //                    }
                    ret_user_vmrun();
            }
    }

    check_memory(reason);
ffffffff81006976:	48 89 df             	mov    %rbx,%rdi
ffffffff81006979:	e8 9a fc ff ff       	callq  ffffffff81006618 <memory_checker>
    send_msg<ret_user_vmrun>();
ffffffff8100697e:	e8 d5 0f 01 00       	callq  ffffffff81017958 <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv>
ffffffff81006983:	90                   	nop

ffffffff81006984 <_ZN2Ec10svm_invlpgEv>:
}

void Ec::svm_invlpg() {
    current->regs.svm_update_shadows();
ffffffff81006984:	48 8b 05 7d 86 ff 3e 	mov    0x3eff867d(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>

    check_memory(reason);
    send_msg<ret_user_vmrun>();
}

void Ec::svm_invlpg() {
ffffffff8100698b:	53                   	push   %rbx
    current->regs.svm_update_shadows();
ffffffff8100698c:	48 8d b8 a8 00 00 00 	lea    0xa8(%rax),%rdi
ffffffff81006993:	e8 d4 d2 00 00       	callq  ffffffff81013c6c <_ZN8Exc_regs18svm_update_shadowsEv>

    mword virt = current->regs.linear_address<Vmcb>(static_cast<mword> (current->regs.vmcb->cs.base) + static_cast<mword> (current->regs.vmcb->rip));
ffffffff81006998:	48 8b 3d 69 86 ff 3e 	mov    0x3eff8669(%rip),%rdi        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100699f:	48 8b 87 28 01 00 00 	mov    0x128(%rdi),%rax
ffffffff810069a6:	48 81 c7 a8 00 00 00 	add    $0xa8,%rdi
ffffffff810069ad:	48 8b b0 18 04 00 00 	mov    0x418(%rax),%rsi
ffffffff810069b4:	48 03 b0 78 05 00 00 	add    0x578(%rax),%rsi
ffffffff810069bb:	e8 6c d4 00 00       	callq  ffffffff81013e2c <_ZNK8Exc_regs14linear_addressI4VmcbEEmm>

    assert(ifetch(virt) == 0xf && ifetch(virt + 1) == 0x1);
ffffffff810069c0:	48 89 c7             	mov    %rax,%rdi
}

void Ec::svm_invlpg() {
    current->regs.svm_update_shadows();

    mword virt = current->regs.linear_address<Vmcb>(static_cast<mword> (current->regs.vmcb->cs.base) + static_cast<mword> (current->regs.vmcb->rip));
ffffffff810069c3:	48 89 c3             	mov    %rax,%rbx

    assert(ifetch(virt) == 0xf && ifetch(virt + 1) == 0x1);
ffffffff810069c6:	e8 c7 fd ff ff       	callq  ffffffff81006792 <_ZN2Ec6ifetchEm>
ffffffff810069cb:	3c 0f                	cmp    $0xf,%al
ffffffff810069cd:	0f 85 ab 00 00 00    	jne    ffffffff81006a7e <_ZN2Ec10svm_invlpgEv+0xfa>
ffffffff810069d3:	48 8d 7b 01          	lea    0x1(%rbx),%rdi
ffffffff810069d7:	e8 b6 fd ff ff       	callq  ffffffff81006792 <_ZN2Ec6ifetchEm>
ffffffff810069dc:	fe c8                	dec    %al
ffffffff810069de:	0f 85 9a 00 00 00    	jne    ffffffff81006a7e <_ZN2Ec10svm_invlpgEv+0xfa>

    uint8 mrm = ifetch(virt + 2);
ffffffff810069e4:	48 8d 7b 02          	lea    0x2(%rbx),%rdi
ffffffff810069e8:	e8 a5 fd ff ff       	callq  ffffffff81006792 <_ZN2Ec6ifetchEm>
    uint8 r_m = mrm & 7;
ffffffff810069ed:	88 c2                	mov    %al,%dl

    unsigned len = 3;

    switch (mrm >> 6) {
ffffffff810069ef:	0f b6 c0             	movzbl %al,%eax
ffffffff810069f2:	c1 f8 06             	sar    $0x6,%eax
    mword virt = current->regs.linear_address<Vmcb>(static_cast<mword> (current->regs.vmcb->cs.base) + static_cast<mword> (current->regs.vmcb->rip));

    assert(ifetch(virt) == 0xf && ifetch(virt + 1) == 0x1);

    uint8 mrm = ifetch(virt + 2);
    uint8 r_m = mrm & 7;
ffffffff810069f5:	83 e2 07             	and    $0x7,%edx

    unsigned len = 3;

    switch (mrm >> 6) {
ffffffff810069f8:	83 f8 01             	cmp    $0x1,%eax
ffffffff810069fb:	75 6f                	jne    ffffffff81006a6c <_ZN2Ec10svm_invlpgEv+0xe8>
        case 0: len += (r_m == 4 ? 1: r_m == 5 ? 4: 0);
            break;
        case 1: len += (r_m == 4 ? 2: 1);
ffffffff810069fd:	31 db                	xor    %ebx,%ebx
ffffffff810069ff:	80 fa 04             	cmp    $0x4,%dl
ffffffff81006a02:	0f 94 c3             	sete   %bl
ffffffff81006a05:	83 c3 04             	add    $0x4,%ebx
            break;
ffffffff81006a08:	eb 21                	jmp    ffffffff81006a2b <_ZN2Ec10svm_invlpgEv+0xa7>
    uint8 mrm = ifetch(virt + 2);
    uint8 r_m = mrm & 7;

    unsigned len = 3;

    switch (mrm >> 6) {
ffffffff81006a0a:	85 c0                	test   %eax,%eax
    assert(ifetch(virt) == 0xf && ifetch(virt + 1) == 0x1);

    uint8 mrm = ifetch(virt + 2);
    uint8 r_m = mrm & 7;

    unsigned len = 3;
ffffffff81006a0c:	bb 03 00 00 00       	mov    $0x3,%ebx

    switch (mrm >> 6) {
ffffffff81006a11:	75 18                	jne    ffffffff81006a2b <_ZN2Ec10svm_invlpgEv+0xa7>
        case 0: len += (r_m == 4 ? 1: r_m == 5 ? 4: 0);
ffffffff81006a13:	80 fa 04             	cmp    $0x4,%dl
ffffffff81006a16:	bb 01 00 00 00       	mov    $0x1,%ebx
ffffffff81006a1b:	74 0b                	je     ffffffff81006a28 <_ZN2Ec10svm_invlpgEv+0xa4>
ffffffff81006a1d:	31 db                	xor    %ebx,%ebx
ffffffff81006a1f:	80 fa 05             	cmp    $0x5,%dl
ffffffff81006a22:	0f 94 c3             	sete   %bl
ffffffff81006a25:	c1 e3 02             	shl    $0x2,%ebx
ffffffff81006a28:	83 c3 03             	add    $0x3,%ebx
            break;
        case 2: len += (r_m == 4 ? 5: 4);
            break;
    }

    current->regs.tlb_flush<Vmcb>(true);
ffffffff81006a2b:	48 8b 05 d6 85 ff 3e 	mov    0x3eff85d6(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81006a32:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff81006a37:	48 8d b8 a8 00 00 00 	lea    0xa8(%rax),%rdi
ffffffff81006a3e:	e8 01 c8 00 00       	callq  ffffffff81013244 <_ZNK8Exc_regs9tlb_flushI4VmcbEEvb>
    current->regs.vmcb->adjust_rip(len);
ffffffff81006a43:	48 8b 05 be 85 ff 3e 	mov    0x3eff85be(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81006a4a:	48 8b 80 28 01 00 00 	mov    0x128(%rax),%rax
        asm volatile ("vmsave" : : "a" (Buddy::ptr_to_phys(this)) : "memory");
    }

    ALWAYS_INLINE
    inline void adjust_rip(mword len) {
        rip += len;
ffffffff81006a51:	48 01 98 78 05 00 00 	add    %rbx,0x578(%rax)

        if (int_shadow)
ffffffff81006a58:	48 83 78 68 00       	cmpq   $0x0,0x68(%rax)
ffffffff81006a5d:	74 08                	je     ffffffff81006a67 <_ZN2Ec10svm_invlpgEv+0xe3>
            int_shadow = 0;
ffffffff81006a5f:	48 c7 40 68 00 00 00 	movq   $0x0,0x68(%rax)
ffffffff81006a66:	00 
    ret_user_vmrun();
ffffffff81006a67:	e8 1e e0 ff ff       	callq  ffffffff81004a8a <_ZN2Ec14ret_user_vmrunEv>
    uint8 mrm = ifetch(virt + 2);
    uint8 r_m = mrm & 7;

    unsigned len = 3;

    switch (mrm >> 6) {
ffffffff81006a6c:	83 f8 02             	cmp    $0x2,%eax
ffffffff81006a6f:	75 99                	jne    ffffffff81006a0a <_ZN2Ec10svm_invlpgEv+0x86>
        case 0: len += (r_m == 4 ? 1: r_m == 5 ? 4: 0);
            break;
        case 1: len += (r_m == 4 ? 2: 1);
            break;
        case 2: len += (r_m == 4 ? 5: 4);
ffffffff81006a71:	31 db                	xor    %ebx,%ebx
ffffffff81006a73:	80 fa 04             	cmp    $0x4,%dl
ffffffff81006a76:	0f 94 c3             	sete   %bl
ffffffff81006a79:	83 c3 07             	add    $0x7,%ebx
            break;
ffffffff81006a7c:	eb ad                	jmp    ffffffff81006a2b <_ZN2Ec10svm_invlpgEv+0xa7>
void Ec::svm_invlpg() {
    current->regs.svm_update_shadows();

    mword virt = current->regs.linear_address<Vmcb>(static_cast<mword> (current->regs.vmcb->cs.base) + static_cast<mword> (current->regs.vmcb->rip));

    assert(ifetch(virt) == 0xf && ifetch(virt + 1) == 0x1);
ffffffff81006a7e:	49 c7 c0 50 e3 01 81 	mov    $0xffffffff8101e350,%r8
ffffffff81006a85:	b9 72 00 00 00       	mov    $0x72,%ecx
ffffffff81006a8a:	48 c7 c2 73 e2 01 81 	mov    $0xffffffff8101e273,%rdx
ffffffff81006a91:	48 c7 c6 e1 e2 01 81 	mov    $0xffffffff8101e2e1,%rsi
ffffffff81006a98:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81006a9f:	31 c0                	xor    %eax,%eax
ffffffff81006aa1:	e8 aa b4 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

ffffffff81006aa6 <_ZN2Ec6svm_crEv>:
    current->regs.vmcb->adjust_rip(len);
    ret_user_vmrun();
}

void Ec::svm_cr() {
    current->regs.svm_update_shadows();
ffffffff81006aa6:	48 8b 05 5b 85 ff 3e 	mov    0x3eff855b(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
    current->regs.tlb_flush<Vmcb>(true);
    current->regs.vmcb->adjust_rip(len);
    ret_user_vmrun();
}

void Ec::svm_cr() {
ffffffff81006aad:	41 54                	push   %r12
ffffffff81006aaf:	55                   	push   %rbp
ffffffff81006ab0:	53                   	push   %rbx
    current->regs.svm_update_shadows();
ffffffff81006ab1:	48 8d b8 a8 00 00 00 	lea    0xa8(%rax),%rdi
ffffffff81006ab8:	e8 af d1 00 00       	callq  ffffffff81013c6c <_ZN8Exc_regs18svm_update_shadowsEv>

    mword virt = current->regs.linear_address<Vmcb>(static_cast<mword> (current->regs.vmcb->cs.base) + static_cast<mword> (current->regs.vmcb->rip));
ffffffff81006abd:	48 8b 3d 44 85 ff 3e 	mov    0x3eff8544(%rip),%rdi        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81006ac4:	48 8b 87 28 01 00 00 	mov    0x128(%rdi),%rax
ffffffff81006acb:	48 81 c7 a8 00 00 00 	add    $0xa8,%rdi
ffffffff81006ad2:	48 8b b0 18 04 00 00 	mov    0x418(%rax),%rsi
ffffffff81006ad9:	48 03 b0 78 05 00 00 	add    0x578(%rax),%rsi
ffffffff81006ae0:	e8 47 d3 00 00       	callq  ffffffff81013e2c <_ZNK8Exc_regs14linear_addressI4VmcbEEmm>

    assert(ifetch(virt) == 0xf);
ffffffff81006ae5:	48 89 c7             	mov    %rax,%rdi
}

void Ec::svm_cr() {
    current->regs.svm_update_shadows();

    mword virt = current->regs.linear_address<Vmcb>(static_cast<mword> (current->regs.vmcb->cs.base) + static_cast<mword> (current->regs.vmcb->rip));
ffffffff81006ae8:	48 89 c3             	mov    %rax,%rbx

    assert(ifetch(virt) == 0xf);
ffffffff81006aeb:	e8 a2 fc ff ff       	callq  ffffffff81006792 <_ZN2Ec6ifetchEm>
ffffffff81006af0:	3c 0f                	cmp    $0xf,%al
ffffffff81006af2:	74 28                	je     ffffffff81006b1c <_ZN2Ec6svm_crEv+0x76>
ffffffff81006af4:	49 c7 c0 70 e3 01 81 	mov    $0xffffffff8101e370,%r8
ffffffff81006afb:	b9 8c 00 00 00       	mov    $0x8c,%ecx
ffffffff81006b00:	48 c7 c2 73 e2 01 81 	mov    $0xffffffff8101e273,%rdx
ffffffff81006b07:	48 c7 c6 10 e3 01 81 	mov    $0xffffffff8101e310,%rsi
ffffffff81006b0e:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81006b15:	31 c0                	xor    %eax,%eax
ffffffff81006b17:	e8 34 b4 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

    uint8 opc = ifetch(virt + 1);
ffffffff81006b1c:	48 8d 7b 01          	lea    0x1(%rbx),%rdi
ffffffff81006b20:	e8 6d fc ff ff       	callq  ffffffff81006792 <_ZN2Ec6ifetchEm>
    uint8 mrm = ifetch(virt + 2);
ffffffff81006b25:	48 8d 7b 02          	lea    0x2(%rbx),%rdi

    mword virt = current->regs.linear_address<Vmcb>(static_cast<mword> (current->regs.vmcb->cs.base) + static_cast<mword> (current->regs.vmcb->rip));

    assert(ifetch(virt) == 0xf);

    uint8 opc = ifetch(virt + 1);
ffffffff81006b29:	41 88 c4             	mov    %al,%r12b
    uint8 mrm = ifetch(virt + 2);
ffffffff81006b2c:	e8 61 fc ff ff       	callq  ffffffff81006792 <_ZN2Ec6ifetchEm>

    unsigned len, gpr = mrm & 0x7, cr = mrm >> 3 & 0x7;
ffffffff81006b31:	89 c3                	mov    %eax,%ebx
ffffffff81006b33:	89 c5                	mov    %eax,%ebp
ffffffff81006b35:	48 8b 3d cc 84 ff 3e 	mov    0x3eff84cc(%rip),%rdi        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81006b3c:	c1 eb 03             	shr    $0x3,%ebx
ffffffff81006b3f:	83 e5 07             	and    $0x7,%ebp
ffffffff81006b42:	83 e3 07             	and    $0x7,%ebx

    switch (opc) {
ffffffff81006b45:	41 80 fc 20          	cmp    $0x20,%r12b
ffffffff81006b49:	74 40                	je     ffffffff81006b8b <_ZN2Ec6svm_crEv+0xe5>
ffffffff81006b4b:	41 80 fc 22          	cmp    $0x22,%r12b
ffffffff81006b4f:	74 62                	je     ffffffff81006bb3 <_ZN2Ec6svm_crEv+0x10d>
ffffffff81006b51:	41 80 fc 06          	cmp    $0x6,%r12b
ffffffff81006b55:	0f 85 85 00 00 00    	jne    ffffffff81006be0 <_ZN2Ec6svm_crEv+0x13a>

        case 0x6: // CLTS
            current->regs.write_cr<Vmcb> (0, current->regs.read_cr<Vmcb> (0) & ~Cpu::CR0_TS);
ffffffff81006b5b:	48 81 c7 a8 00 00 00 	add    $0xa8,%rdi
ffffffff81006b62:	31 f6                	xor    %esi,%esi
ffffffff81006b64:	e8 37 d3 00 00       	callq  ffffffff81013ea0 <_ZNK8Exc_regs7read_crI4VmcbEEmj>
ffffffff81006b69:	83 e0 f7             	and    $0xfffffff7,%eax
ffffffff81006b6c:	31 f6                	xor    %esi,%esi
ffffffff81006b6e:	48 89 c2             	mov    %rax,%rdx
ffffffff81006b71:	48 8b 05 90 84 ff 3e 	mov    0x3eff8490(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81006b78:	48 8d b8 a8 00 00 00 	lea    0xa8(%rax),%rdi
ffffffff81006b7f:	e8 ce d4 00 00       	callq  ffffffff81014052 <_ZN8Exc_regs8write_crI4VmcbEEvjm>
            len = 2;
ffffffff81006b84:	b8 02 00 00 00       	mov    $0x2,%eax
            break;
ffffffff81006b89:	eb 68                	jmp    ffffffff81006bf3 <_ZN2Ec6svm_crEv+0x14d>

        case 0x20: // MOV from CR
            current->regs.svm_write_gpr(gpr, current->regs.read_cr<Vmcb>(cr));
ffffffff81006b8b:	48 81 c7 a8 00 00 00 	add    $0xa8,%rdi
ffffffff81006b92:	89 de                	mov    %ebx,%esi
ffffffff81006b94:	e8 07 d3 00 00       	callq  ffffffff81013ea0 <_ZNK8Exc_regs7read_crI4VmcbEEmj>
ffffffff81006b99:	48 8b 0d 68 84 ff 3e 	mov    0x3eff8468(%rip),%rcx        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81006ba0:	48 89 c2             	mov    %rax,%rdx
ffffffff81006ba3:	89 ee                	mov    %ebp,%esi
ffffffff81006ba5:	48 8d b9 a8 00 00 00 	lea    0xa8(%rcx),%rdi
ffffffff81006bac:	e8 d1 d1 00 00       	callq  ffffffff81013d82 <_ZN8Exc_regs13svm_write_gprEjm>
ffffffff81006bb1:	eb 26                	jmp    ffffffff81006bd9 <_ZN2Ec6svm_crEv+0x133>
            len = 3;
            break;

        case 0x22: // MOV to CR
            current->regs.write_cr<Vmcb> (cr, current->regs.svm_read_gpr(gpr));
ffffffff81006bb3:	48 81 c7 a8 00 00 00 	add    $0xa8,%rdi
ffffffff81006bba:	89 ee                	mov    %ebp,%esi
ffffffff81006bbc:	e8 8b d1 00 00       	callq  ffffffff81013d4c <_ZN8Exc_regs12svm_read_gprEj>
ffffffff81006bc1:	48 8b 0d 40 84 ff 3e 	mov    0x3eff8440(%rip),%rcx        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81006bc8:	48 89 c2             	mov    %rax,%rdx
ffffffff81006bcb:	89 de                	mov    %ebx,%esi
ffffffff81006bcd:	48 8d b9 a8 00 00 00 	lea    0xa8(%rcx),%rdi
ffffffff81006bd4:	e8 79 d4 00 00       	callq  ffffffff81014052 <_ZN8Exc_regs8write_crI4VmcbEEvjm>
            len = 3;
ffffffff81006bd9:	b8 03 00 00 00       	mov    $0x3,%eax
            break;
ffffffff81006bde:	eb 13                	jmp    ffffffff81006bf3 <_ZN2Ec6svm_crEv+0x14d>

        default:
            die("SVM decode failure");
ffffffff81006be0:	48 8d b7 a8 00 00 00 	lea    0xa8(%rdi),%rsi
ffffffff81006be7:	48 c7 c7 24 e3 01 81 	mov    $0xffffffff8101e324,%rdi
ffffffff81006bee:	e8 17 e0 ff ff       	callq  ffffffff81004c0a <_ZN2Ec3dieEPKcP8Exc_regs>
    }

    current->regs.vmcb->adjust_rip(len);
ffffffff81006bf3:	48 8b 15 0e 84 ff 3e 	mov    0x3eff840e(%rip),%rdx        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81006bfa:	48 8b 92 28 01 00 00 	mov    0x128(%rdx),%rdx
        asm volatile ("vmsave" : : "a" (Buddy::ptr_to_phys(this)) : "memory");
    }

    ALWAYS_INLINE
    inline void adjust_rip(mword len) {
        rip += len;
ffffffff81006c01:	48 01 82 78 05 00 00 	add    %rax,0x578(%rdx)

        if (int_shadow)
ffffffff81006c08:	48 83 7a 68 00       	cmpq   $0x0,0x68(%rdx)
ffffffff81006c0d:	74 08                	je     ffffffff81006c17 <_ZN2Ec6svm_crEv+0x171>
            int_shadow = 0;
ffffffff81006c0f:	48 c7 42 68 00 00 00 	movq   $0x0,0x68(%rdx)
ffffffff81006c16:	00 
    ret_user_vmrun();
ffffffff81006c17:	e8 6e de ff ff       	callq  ffffffff81004a8a <_ZN2Ec14ret_user_vmrunEv>

ffffffff81006c1c <svm_handler>:
}

void Ec::handle_svm() {
    current->regs.vmcb->tlb_control = 0;
ffffffff81006c1c:	48 8b 05 e5 83 ff 3e 	mov    0x3eff83e5(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>

    current->regs.vmcb->adjust_rip(len);
    ret_user_vmrun();
}

void Ec::handle_svm() {
ffffffff81006c23:	53                   	push   %rbx
    current->regs.vmcb->tlb_control = 0;
ffffffff81006c24:	48 8b 90 28 01 00 00 	mov    0x128(%rax),%rdx
ffffffff81006c2b:	c7 42 5c 00 00 00 00 	movl   $0x0,0x5c(%rdx)

    mword reason = static_cast<mword> (current->regs.vmcb->exitcode);
ffffffff81006c32:	48 8b 90 28 01 00 00 	mov    0x128(%rax),%rdx
ffffffff81006c39:	48 8b 5a 70          	mov    0x70(%rdx),%rbx
//    if (current->hardening_started) {
//        Console::print("VM Exit reason: %lx rip: %llx  nrip: %llx  eip: %08lx",
//                reason, current->regs.vmcb->rip, current->regs.vmcb->nrip, current->regs.REG(ip));
//    }

    switch (reason) {
ffffffff81006c3d:	48 81 fb 00 04 00 00 	cmp    $0x400,%rbx
ffffffff81006c44:	74 0f                	je     ffffffff81006c55 <svm_handler+0x39>
        case -1UL: // Invalid state
            reason = NUM_VMI - 3;
ffffffff81006c46:	48 83 fb ff          	cmp    $0xffffffffffffffff,%rbx
ffffffff81006c4a:	ba fd 00 00 00       	mov    $0xfd,%edx
ffffffff81006c4f:	48 0f 44 da          	cmove  %rdx,%rbx
ffffffff81006c53:	eb 1e                	jmp    ffffffff81006c73 <svm_handler+0x57>
            break;
        case 0x400: // NPT
            reason = NUM_VMI - 4;
            current->regs.nst_error = static_cast<mword> (current->regs.vmcb->exitinfo1);
ffffffff81006c55:	48 8b 4a 78          	mov    0x78(%rdx),%rcx
    switch (reason) {
        case -1UL: // Invalid state
            reason = NUM_VMI - 3;
            break;
        case 0x400: // NPT
            reason = NUM_VMI - 4;
ffffffff81006c59:	bb fc 00 00 00       	mov    $0xfc,%ebx
            current->regs.nst_error = static_cast<mword> (current->regs.vmcb->exitinfo1);
ffffffff81006c5e:	48 89 88 60 01 00 00 	mov    %rcx,0x160(%rax)
            current->regs.nst_fault = static_cast<mword> (current->regs.vmcb->exitinfo2);
ffffffff81006c65:	48 8b 92 80 00 00 00 	mov    0x80(%rdx),%rdx
ffffffff81006c6c:	48 89 90 58 01 00 00 	mov    %rdx,0x158(%rax)
            break;
    }

    Counter::vmi[reason]++;
ffffffff81006c73:	ff 04 9d 80 f0 ff bf 	incl   -0x40000f80(,%rbx,4)
    if (reason == 0x60) {
ffffffff81006c7a:	48 83 fb 60          	cmp    $0x60,%rbx
ffffffff81006c7e:	75 2a                	jne    ffffffff81006caa <svm_handler+0x8e>
        if (current->previous_reason == 0x60) {
ffffffff81006c80:	83 b8 58 03 00 00 60 	cmpl   $0x60,0x358(%rax)
ffffffff81006c87:	75 08                	jne    ffffffff81006c91 <svm_handler+0x75>
            current->nb_extint++;
ffffffff81006c89:	ff 80 5c 03 00 00    	incl   0x35c(%rax)
ffffffff81006c8f:	eb 0a                	jmp    ffffffff81006c9b <svm_handler+0x7f>
        } else {
            current->nb_extint = 1;
ffffffff81006c91:	c7 80 5c 03 00 00 01 	movl   $0x1,0x35c(%rax)
ffffffff81006c98:	00 00 00 
        }
        current->previous_reason = 0x60;
ffffffff81006c9b:	c7 80 58 03 00 00 60 	movl   $0x60,0x358(%rax)
ffffffff81006ca2:	00 00 00 
            //            if (current->nb_extint >= 4) {
            //                if(current->nb_extint > 4)
            //                    current->nb_extint = 0;
            //                check_memory(reason);
            //            }
            asm volatile ("sti; nop; cli" : : : "memory");
ffffffff81006ca5:	fb                   	sti    
ffffffff81006ca6:	90                   	nop
ffffffff81006ca7:	fa                   	cli    
ffffffff81006ca8:	eb 7f                	jmp    ffffffff81006d29 <svm_handler+0x10d>
        }
        current->previous_reason = 0x60;
    } else {
        current->previous_reason = 0;
    }
    switch (reason) {
ffffffff81006caa:	48 83 fb 5f          	cmp    $0x5f,%rbx
        } else {
            current->nb_extint = 1;
        }
        current->previous_reason = 0x60;
    } else {
        current->previous_reason = 0;
ffffffff81006cae:	c7 80 58 03 00 00 00 	movl   $0x0,0x358(%rax)
ffffffff81006cb5:	00 00 00 
    }
    switch (reason) {
ffffffff81006cb8:	77 19                	ja     ffffffff81006cd3 <svm_handler+0xb7>
ffffffff81006cba:	48 83 fb 40          	cmp    $0x40,%rbx
ffffffff81006cbe:	73 53                	jae    ffffffff81006d13 <svm_handler+0xf7>
ffffffff81006cc0:	48 83 fb 1f          	cmp    $0x1f,%rbx
ffffffff81006cc4:	77 77                	ja     ffffffff81006d3d <svm_handler+0x121>

        case 0x0 ... 0x1f: // CR Access
            //Console::print("Cr access  opc: %02x", opc);
            check_memory(reason);
ffffffff81006cc6:	48 89 df             	mov    %rbx,%rdi
ffffffff81006cc9:	e8 4a f9 ff ff       	callq  ffffffff81006618 <memory_checker>
            svm_cr();
ffffffff81006cce:	e8 d3 fd ff ff       	callq  ffffffff81006aa6 <_ZN2Ec6svm_crEv>
        }
        current->previous_reason = 0x60;
    } else {
        current->previous_reason = 0;
    }
    switch (reason) {
ffffffff81006cd3:	48 83 fb 79          	cmp    $0x79,%rbx
ffffffff81006cd7:	74 55                	je     ffffffff81006d2e <svm_handler+0x112>
ffffffff81006cd9:	48 81 fb 87 00 00 00 	cmp    $0x87,%rbx
ffffffff81006ce0:	74 39                	je     ffffffff81006d1b <svm_handler+0xff>
ffffffff81006ce2:	48 83 fb 6e          	cmp    $0x6e,%rbx
ffffffff81006ce6:	75 55                	jne    ffffffff81006d3d <svm_handler+0x121>
            asm volatile ("sti; nop; cli" : : : "memory");
            ret_user_vmrun();

        case 0x6e: //RDTSC
            //            Console::print("RDTSC in VM");
            check_memory(reason);
ffffffff81006ce8:	bf 6e 00 00 00       	mov    $0x6e,%edi
ffffffff81006ced:	e8 26 f9 ff ff       	callq  ffffffff81006618 <memory_checker>

ALWAYS_INLINE
static inline uint64 rdtsc()
{
    mword h, l;
    asm volatile ("rdtsc" : "=a" (l), "=d" (h));
ffffffff81006cf2:	0f 31                	rdtsc  
    return static_cast<uint64>(h) << 32 | l;
ffffffff81006cf4:	48 89 d6             	mov    %rdx,%rsi
ffffffff81006cf7:	48 c1 e6 20          	shl    $0x20,%rsi
ffffffff81006cfb:	48 09 c6             	or     %rax,%rsi
            current->regs.resolve_rdtsc<Vmcb>(rdtsc());
ffffffff81006cfe:	48 8b 05 03 83 ff 3e 	mov    0x3eff8303(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81006d05:	48 8d b8 a8 00 00 00 	lea    0xa8(%rax),%rdi
ffffffff81006d0c:	e8 e5 cb 00 00       	callq  ffffffff810138f6 <_ZN8Exc_regs13resolve_rdtscI4VmcbEEvy>
ffffffff81006d11:	eb 16                	jmp    ffffffff81006d29 <svm_handler+0x10d>
            //Console::print("Cr access  opc: %02x", opc);
            check_memory(reason);
            svm_cr();

        case 0x40 ... 0x5f: // Exception
            svm_exception(reason);
ffffffff81006d13:	48 89 df             	mov    %rbx,%rdi
ffffffff81006d16:	e8 ff fa ff ff       	callq  ffffffff8100681a <_ZN2Ec13svm_exceptionEm>
        case 0x79: // INVLPG
            check_memory(reason);
            svm_invlpg();

        case 0x87: //RDTSCP
            Console::print("RDTSCP in VM");
ffffffff81006d1b:	48 c7 c7 37 e3 01 81 	mov    $0xffffffff8101e337,%rdi
ffffffff81006d22:	31 c0                	xor    %eax,%eax
ffffffff81006d24:	e8 63 b3 ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>

        case 0x6e: //RDTSC
            //            Console::print("RDTSC in VM");
            check_memory(reason);
            current->regs.resolve_rdtsc<Vmcb>(rdtsc());
            ret_user_vmrun();
ffffffff81006d29:	e8 5c dd ff ff       	callq  ffffffff81004a8a <_ZN2Ec14ret_user_vmrunEv>

        case 0x79: // INVLPG
            check_memory(reason);
ffffffff81006d2e:	bf 79 00 00 00       	mov    $0x79,%edi
ffffffff81006d33:	e8 e0 f8 ff ff       	callq  ffffffff81006618 <memory_checker>
            svm_invlpg();
ffffffff81006d38:	e8 47 fc ff ff       	callq  ffffffff81006984 <_ZN2Ec10svm_invlpgEv>
        case 0x87: //RDTSCP
            Console::print("RDTSCP in VM");
            ret_user_vmrun();
    }

    check_memory(reason);
ffffffff81006d3d:	48 89 df             	mov    %rbx,%rdi
ffffffff81006d40:	e8 d3 f8 ff ff       	callq  ffffffff81006618 <memory_checker>
    current->regs.dst_portal = reason;
ffffffff81006d45:	48 8b 05 bc 82 ff 3e 	mov    0x3eff82bc(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81006d4c:	48 89 98 50 01 00 00 	mov    %rbx,0x150(%rax)

    send_msg<ret_user_vmrun>();
ffffffff81006d53:	e8 00 0c 01 00       	callq  ffffffff81017958 <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv>

ffffffff81006d58 <_ZN2Ec13vmx_exceptionEv>:
#include "vectors.hpp"
#include "vmx.hpp"
#include "vtlb.hpp"

void Ec::vmx_exception()
{
ffffffff81006d58:	41 54                	push   %r12
ffffffff81006d5a:	55                   	push   %rbp
ffffffff81006d5b:	b8 08 44 00 00       	mov    $0x4408,%eax
ffffffff81006d60:	53                   	push   %rbx
ffffffff81006d61:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff81006d65:	0f 78 c0             	vmread %rax,%rax
    mword vect_info = Vmcs::read (Vmcs::IDT_VECT_INFO);

    if (vect_info & 0x80000000) {
ffffffff81006d68:	a9 00 00 00 80       	test   $0x80000000,%eax
ffffffff81006d6d:	74 41                	je     ffffffff81006db0 <_ZN2Ec13vmx_exceptionEv+0x58>

        Vmcs::write (Vmcs::ENT_INTR_INFO, vect_info & ~0x1000);
ffffffff81006d6f:	48 89 c2             	mov    %rax,%rdx
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
ffffffff81006d72:	b9 16 40 00 00       	mov    $0x4016,%ecx
ffffffff81006d77:	80 e6 ef             	and    $0xef,%dh
ffffffff81006d7a:	0f 79 ca             	vmwrite %rdx,%rcx

        if (vect_info & 0x800)
ffffffff81006d7d:	f6 c4 08             	test   $0x8,%ah
ffffffff81006d80:	74 0d                	je     ffffffff81006d8f <_ZN2Ec13vmx_exceptionEv+0x37>

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
ffffffff81006d82:	ba 0a 44 00 00       	mov    $0x440a,%edx
ffffffff81006d87:	0f 78 d2             	vmread %rdx,%rdx
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
ffffffff81006d8a:	b1 18                	mov    $0x18,%cl
ffffffff81006d8c:	0f 79 ca             	vmwrite %rdx,%rcx
            Vmcs::write (Vmcs::ENT_INTR_ERROR, Vmcs::read (Vmcs::IDT_VECT_ERROR));

        if ((vect_info >> 8 & 0x7) >= 4 && (vect_info >> 8 & 0x7) <= 6)
ffffffff81006d8f:	48 c1 e8 08          	shr    $0x8,%rax
ffffffff81006d93:	83 e0 07             	and    $0x7,%eax
ffffffff81006d96:	48 83 e8 04          	sub    $0x4,%rax
ffffffff81006d9a:	48 83 f8 02          	cmp    $0x2,%rax
ffffffff81006d9e:	77 10                	ja     ffffffff81006db0 <_ZN2Ec13vmx_exceptionEv+0x58>

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
ffffffff81006da0:	b8 0c 44 00 00       	mov    $0x440c,%eax
ffffffff81006da5:	0f 78 c0             	vmread %rax,%rax
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
ffffffff81006da8:	ba 1a 40 00 00       	mov    $0x401a,%edx
ffffffff81006dad:	0f 79 d0             	vmwrite %rax,%rdx

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
ffffffff81006db0:	bb 04 44 00 00       	mov    $0x4404,%ebx
ffffffff81006db5:	0f 78 db             	vmread %rbx,%rbx
            Vmcs::write (Vmcs::ENT_INST_LEN, Vmcs::read (Vmcs::EXI_INST_LEN));
    };

    mword intr_info = Vmcs::read (Vmcs::EXI_INTR_INFO);

    switch (intr_info & 0x7ff) {
ffffffff81006db8:	48 89 dd             	mov    %rbx,%rbp
ffffffff81006dbb:	81 e5 ff 07 00 00    	and    $0x7ff,%ebp
ffffffff81006dc1:	48 81 fd 07 03 00 00 	cmp    $0x307,%rbp
ffffffff81006dc8:	74 2d                	je     ffffffff81006df7 <_ZN2Ec13vmx_exceptionEv+0x9f>
ffffffff81006dca:	48 81 fd 0e 03 00 00 	cmp    $0x30e,%rbp
ffffffff81006dd1:	74 38                	je     ffffffff81006e0b <_ZN2Ec13vmx_exceptionEv+0xb3>
ffffffff81006dd3:	48 81 fd 02 02 00 00 	cmp    $0x202,%rbp
ffffffff81006dda:	74 17                	je     ffffffff81006df3 <_ZN2Ec13vmx_exceptionEv+0x9b>

        default:
            current->regs.dst_portal = Vmcs::VMX_EXC_NMI;
ffffffff81006ddc:	48 8b 05 25 82 ff 3e 	mov    0x3eff8225(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81006de3:	48 c7 80 50 01 00 00 	movq   $0x0,0x150(%rax)
ffffffff81006dea:	00 00 00 00 
ffffffff81006dee:	e9 9a 00 00 00       	jmpq   ffffffff81006e8d <_ZN2Ec13vmx_exceptionEv+0x135>
            break;

        case 0x202:         // NMI
            asm volatile ("int $0x2" : : : "memory");
ffffffff81006df3:	cd 02                	int    $0x2
ffffffff81006df5:	eb 0f                	jmp    ffffffff81006e06 <_ZN2Ec13vmx_exceptionEv+0xae>
            ret_user_vmresume();

        case 0x307:         // #NM
            check_memory(intr_info & 0x7ff);
ffffffff81006df7:	bf 07 03 00 00       	mov    $0x307,%edi
ffffffff81006dfc:	e8 17 f8 ff ff       	callq  ffffffff81006618 <memory_checker>
            handle_exc_nm();
ffffffff81006e01:	e8 70 f5 ff ff       	callq  ffffffff81006376 <_ZN2Ec13handle_exc_nmEv>
            ret_user_vmresume();
ffffffff81006e06:	e8 47 e3 ff ff       	callq  ffffffff81005152 <_ZN2Ec17ret_user_vmresumeEv>

        case 0x30e:         // #PF
            mword err = Vmcs::read (Vmcs::EXI_INTR_ERROR);
ffffffff81006e0b:	b8 06 44 00 00       	mov    $0x4406,%eax
ffffffff81006e10:	0f 78 44 24 08       	vmread %rax,0x8(%rsp)
ffffffff81006e15:	41 bc 00 64 00 00    	mov    $0x6400,%r12d
ffffffff81006e1b:	45 0f 78 e4          	vmread %r12,%r12
            mword cr2 = Vmcs::read (Vmcs::EXI_QUALIFICATION);

            mword phys;
            Paddr host;    
            switch (Vtlb::miss (&current->regs, cr2, err, phys, host)) {
ffffffff81006e1f:	48 8b 05 e2 81 ff 3e 	mov    0x3eff81e2(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81006e26:	4c 8d 44 24 18       	lea    0x18(%rsp),%r8
ffffffff81006e2b:	48 8d 4c 24 10       	lea    0x10(%rsp),%rcx
ffffffff81006e30:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
ffffffff81006e35:	4c 89 e6             	mov    %r12,%rsi
ffffffff81006e38:	48 8d b8 a8 00 00 00 	lea    0xa8(%rax),%rdi
ffffffff81006e3f:	e8 a8 5f 01 00       	callq  ffffffff8101cdec <_ZN4Vtlb4missEP8Exc_regsmRmS2_S2_>
ffffffff81006e44:	83 f8 02             	cmp    $0x2,%eax
ffffffff81006e47:	74 1f                	je     ffffffff81006e68 <_ZN2Ec13vmx_exceptionEv+0x110>
ffffffff81006e49:	83 f8 03             	cmp    $0x3,%eax
ffffffff81006e4c:	74 06                	je     ffffffff81006e54 <_ZN2Ec13vmx_exceptionEv+0xfc>
ffffffff81006e4e:	ff c8                	dec    %eax
ffffffff81006e50:	75 3b                	jne    ffffffff81006e8d <_ZN2Ec13vmx_exceptionEv+0x135>
ffffffff81006e52:	eb b2                	jmp    ffffffff81006e06 <_ZN2Ec13vmx_exceptionEv+0xae>
                case Vtlb::GPA_HPA:
                    current->regs.dst_portal = Vmcs::VMX_EPT_VIOLATION;
ffffffff81006e54:	48 8b 05 ad 81 ff 3e 	mov    0x3eff81ad(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81006e5b:	48 c7 80 50 01 00 00 	movq   $0x30,0x150(%rax)
ffffffff81006e62:	30 00 00 00 
                    break;
ffffffff81006e66:	eb 25                	jmp    ffffffff81006e8d <_ZN2Ec13vmx_exceptionEv+0x135>

                case Vtlb::GLA_GPA:
                    current->regs.cr2 = cr2;
ffffffff81006e68:	48 8b 05 99 81 ff 3e 	mov    0x3eff8199(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
                    Vmcs::write (Vmcs::ENT_INTR_INFO,  intr_info & ~0x1000);
ffffffff81006e6f:	80 e7 ef             	and    $0xef,%bh
                case Vtlb::GPA_HPA:
                    current->regs.dst_portal = Vmcs::VMX_EPT_VIOLATION;
                    break;

                case Vtlb::GLA_GPA:
                    current->regs.cr2 = cr2;
ffffffff81006e72:	4c 89 a0 00 01 00 00 	mov    %r12,0x100(%rax)
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
ffffffff81006e79:	b8 16 40 00 00       	mov    $0x4016,%eax
ffffffff81006e7e:	0f 79 c3             	vmwrite %rbx,%rax
ffffffff81006e81:	b0 18                	mov    $0x18,%al
ffffffff81006e83:	0f 79 44 24 08       	vmwrite 0x8(%rsp),%rax
ffffffff81006e88:	e9 79 ff ff ff       	jmpq   ffffffff81006e06 <_ZN2Ec13vmx_exceptionEv+0xae>

                case Vtlb::SUCCESS:
                    ret_user_vmresume();
            }
    }
    check_memory(intr_info & 0x7ff);
ffffffff81006e8d:	48 89 ef             	mov    %rbp,%rdi
ffffffff81006e90:	e8 83 f7 ff ff       	callq  ffffffff81006618 <memory_checker>
            
    send_msg<ret_user_vmresume>();
ffffffff81006e95:	e8 d4 07 01 00       	callq  ffffffff8101766e <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv>

ffffffff81006e9a <_ZN2Ec10vmx_extintEv>:

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
ffffffff81006e9a:	bf 04 44 00 00       	mov    $0x4404,%edi
}

void Ec::vmx_extint()
{
ffffffff81006e9f:	50                   	push   %rax
ffffffff81006ea0:	0f 78 ff             	vmread %rdi,%rdi
    unsigned vector = Vmcs::read (Vmcs::EXI_INTR_INFO) & 0xff;
ffffffff81006ea3:	40 0f b6 ff          	movzbl %dil,%edi

    if (vector >= VEC_IPI)
ffffffff81006ea7:	81 ff a6 00 00 00    	cmp    $0xa6,%edi
ffffffff81006ead:	76 07                	jbe    ffffffff81006eb6 <_ZN2Ec10vmx_extintEv+0x1c>
        Lapic::ipi_vector (vector);
ffffffff81006eaf:	e8 62 18 00 00       	callq  ffffffff81008716 <ipi_vector>
ffffffff81006eb4:	eb 27                	jmp    ffffffff81006edd <_ZN2Ec10vmx_extintEv+0x43>
    else if (vector >= VEC_MSI)
ffffffff81006eb6:	75 0c                	jne    ffffffff81006ec4 <_ZN2Ec10vmx_extintEv+0x2a>
        Dmar::vector (vector);
ffffffff81006eb8:	bf a6 00 00 00       	mov    $0xa6,%edi
ffffffff81006ebd:	e8 32 c5 ff ff       	callq  ffffffff810033f4 <msi_vector>
ffffffff81006ec2:	eb 19                	jmp    ffffffff81006edd <_ZN2Ec10vmx_extintEv+0x43>
    else if (vector >= VEC_LVT)
ffffffff81006ec4:	81 ff 9f 00 00 00    	cmp    $0x9f,%edi
ffffffff81006eca:	76 07                	jbe    ffffffff81006ed3 <_ZN2Ec10vmx_extintEv+0x39>
        Lapic::lvt_vector (vector);
ffffffff81006ecc:	e8 9d 17 00 00       	callq  ffffffff8100866e <lvt_vector>
ffffffff81006ed1:	eb 0a                	jmp    ffffffff81006edd <_ZN2Ec10vmx_extintEv+0x43>
    else if (vector >= VEC_GSI)
ffffffff81006ed3:	83 ff 1f             	cmp    $0x1f,%edi
ffffffff81006ed6:	76 05                	jbe    ffffffff81006edd <_ZN2Ec10vmx_extintEv+0x43>
        Gsi::vector (vector);
ffffffff81006ed8:	e8 61 0f 00 00       	callq  ffffffff81007e3e <gsi_vector>

    ret_user_vmresume();
ffffffff81006edd:	e8 70 e2 ff ff       	callq  ffffffff81005152 <_ZN2Ec17ret_user_vmresumeEv>

ffffffff81006ee2 <_ZN2Ec10vmx_invlpgEv>:
ffffffff81006ee2:	be 00 64 00 00       	mov    $0x6400,%esi
}

void Ec::vmx_invlpg()
{
ffffffff81006ee7:	50                   	push   %rax
ffffffff81006ee8:	0f 78 f6             	vmread %rsi,%rsi
    current->regs.tlb_flush<Vmcs>(Vmcs::read (Vmcs::EXI_QUALIFICATION));
ffffffff81006eeb:	48 8b 05 16 81 ff 3e 	mov    0x3eff8116(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81006ef2:	48 8d b8 a8 00 00 00 	lea    0xa8(%rax),%rdi
ffffffff81006ef9:	e8 be c3 00 00       	callq  ffffffff810132bc <_ZNK8Exc_regs9tlb_flushI4VmcsEEvm>
ffffffff81006efe:	b9 1e 68 00 00       	mov    $0x681e,%ecx
ffffffff81006f03:	0f 78 ca             	vmread %rcx,%rdx
ffffffff81006f06:	b8 0c 44 00 00       	mov    $0x440c,%eax
ffffffff81006f0b:	0f 78 c0             	vmread %rax,%rax
        }

        ALWAYS_INLINE
        static inline void adjust_rip()
        {
            write (GUEST_RIP, read (GUEST_RIP) + read (EXI_INST_LEN));
ffffffff81006f0e:	48 01 d0             	add    %rdx,%rax
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
ffffffff81006f11:	0f 79 c8             	vmwrite %rax,%rcx

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
ffffffff81006f14:	b8 24 48 00 00       	mov    $0x4824,%eax
ffffffff81006f19:	0f 78 c0             	vmread %rax,%rax
        static inline void adjust_rip()
        {
            write (GUEST_RIP, read (GUEST_RIP) + read (EXI_INST_LEN));

            uint32 intr = static_cast<uint32>(read (GUEST_INTR_STATE));
            if (EXPECT_FALSE (intr & 3))
ffffffff81006f1c:	a8 03                	test   $0x3,%al
ffffffff81006f1e:	74 0b                	je     ffffffff81006f2b <_ZN2Ec10vmx_invlpgEv+0x49>
                write (GUEST_INTR_STATE, intr & ~3);
ffffffff81006f20:	83 e0 fc             	and    $0xfffffffc,%eax
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
ffffffff81006f23:	ba 24 48 00 00       	mov    $0x4824,%edx
ffffffff81006f28:	0f 79 d0             	vmwrite %rax,%rdx
    Vmcs::adjust_rip();
    ret_user_vmresume();
ffffffff81006f2b:	e8 22 e2 ff ff       	callq  ffffffff81005152 <_ZN2Ec17ret_user_vmresumeEv>

ffffffff81006f30 <_ZN2Ec6vmx_crEv>:
}

void Ec::vmx_cr()
{
ffffffff81006f30:	41 55                	push   %r13
ffffffff81006f32:	41 54                	push   %r12
ffffffff81006f34:	55                   	push   %rbp
ffffffff81006f35:	53                   	push   %rbx
ffffffff81006f36:	50                   	push   %rax

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
ffffffff81006f37:	b8 00 64 00 00       	mov    $0x6400,%eax
ffffffff81006f3c:	0f 78 c0             	vmread %rax,%rax
    mword qual = Vmcs::read (Vmcs::EXI_QUALIFICATION);

    unsigned gpr = qual >> 8 & 0xf;
    unsigned acc = qual >> 4 & 0x3;
ffffffff81006f3f:	48 89 c2             	mov    %rax,%rdx

void Ec::vmx_cr()
{
    mword qual = Vmcs::read (Vmcs::EXI_QUALIFICATION);

    unsigned gpr = qual >> 8 & 0xf;
ffffffff81006f42:	48 89 c5             	mov    %rax,%rbp
    unsigned acc = qual >> 4 & 0x3;
    unsigned cr  = qual      & 0xf;
ffffffff81006f45:	89 c3                	mov    %eax,%ebx
void Ec::vmx_cr()
{
    mword qual = Vmcs::read (Vmcs::EXI_QUALIFICATION);

    unsigned gpr = qual >> 8 & 0xf;
    unsigned acc = qual >> 4 & 0x3;
ffffffff81006f47:	48 c1 ea 04          	shr    $0x4,%rdx

void Ec::vmx_cr()
{
    mword qual = Vmcs::read (Vmcs::EXI_QUALIFICATION);

    unsigned gpr = qual >> 8 & 0xf;
ffffffff81006f4b:	48 c1 ed 08          	shr    $0x8,%rbp
    unsigned acc = qual >> 4 & 0x3;
    unsigned cr  = qual      & 0xf;
ffffffff81006f4f:	83 e3 0f             	and    $0xf,%ebx
void Ec::vmx_cr()
{
    mword qual = Vmcs::read (Vmcs::EXI_QUALIFICATION);

    unsigned gpr = qual >> 8 & 0xf;
    unsigned acc = qual >> 4 & 0x3;
ffffffff81006f52:	83 e2 03             	and    $0x3,%edx

void Ec::vmx_cr()
{
    mword qual = Vmcs::read (Vmcs::EXI_QUALIFICATION);

    unsigned gpr = qual >> 8 & 0xf;
ffffffff81006f55:	83 e5 0f             	and    $0xf,%ebp
    unsigned acc = qual >> 4 & 0x3;
    unsigned cr  = qual      & 0xf;

    switch (acc) {
ffffffff81006f58:	83 fa 01             	cmp    $0x1,%edx
ffffffff81006f5b:	0f 84 39 01 00 00    	je     ffffffff8100709a <_ZN2Ec6vmx_crEv+0x16a>
ffffffff81006f61:	48 8b 3d a0 80 ff 3e 	mov    0x3eff80a0(%rip),%rdi        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81006f68:	72 2e                	jb     ffffffff81006f98 <_ZN2Ec6vmx_crEv+0x68>

            assert (cr != 0 && cr != 4);
            current->regs.vmx_write_gpr (gpr, current->regs.read_cr<Vmcs> (cr));
            break;
        case 2:     // CLTS
            current->regs.write_cr<Vmcs> (cr, current->regs.read_cr<Vmcs> (cr) & ~Cpu::CR0_TS);
ffffffff81006f6a:	48 81 c7 a8 00 00 00 	add    $0xa8,%rdi
ffffffff81006f71:	89 de                	mov    %ebx,%esi
ffffffff81006f73:	e8 00 d0 00 00       	callq  ffffffff81013f78 <_ZNK8Exc_regs7read_crI4VmcsEEmj>
ffffffff81006f78:	83 e0 f7             	and    $0xfffffff7,%eax
ffffffff81006f7b:	89 de                	mov    %ebx,%esi
ffffffff81006f7d:	48 89 c2             	mov    %rax,%rdx
ffffffff81006f80:	48 8b 05 81 80 ff 3e 	mov    0x3eff8081(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81006f87:	48 8d b8 a8 00 00 00 	lea    0xa8(%rax),%rdi
ffffffff81006f8e:	e8 15 d3 00 00       	callq  ffffffff810142a8 <_ZN8Exc_regs8write_crI4VmcsEEvjm>
            break;
ffffffff81006f93:	e9 60 01 00 00       	jmpq   ffffffff810070f8 <_ZN2Ec6vmx_crEv+0x1c8>
    unsigned cr  = qual      & 0xf;

    switch (acc) {
        case 0:     // MOV to CR
        {
            if (cr == 8) {
ffffffff81006f98:	83 fb 08             	cmp    $0x8,%ebx
ffffffff81006f9b:	75 10                	jne    ffffffff81006fad <_ZN2Ec6vmx_crEv+0x7d>
                /* Let the VMM handle CR8 */
                current->regs.dst_portal = Vmcs::VMX_CR;
ffffffff81006f9d:	48 c7 87 50 01 00 00 	movq   $0x1c,0x150(%rdi)
ffffffff81006fa4:	1c 00 00 00 
ffffffff81006fa8:	e9 e8 00 00 00       	jmpq   ffffffff81007095 <_ZN2Ec6vmx_crEv+0x165>
                send_msg<ret_user_vmresume>();
            }

            mword old_cr0 = current->regs.read_cr<Vmcs>(0);
ffffffff81006fad:	48 81 c7 a8 00 00 00 	add    $0xa8,%rdi
ffffffff81006fb4:	31 f6                	xor    %esi,%esi
ffffffff81006fb6:	e8 bd cf 00 00       	callq  ffffffff81013f78 <_ZNK8Exc_regs7read_crI4VmcsEEmj>
ffffffff81006fbb:	49 89 c5             	mov    %rax,%r13
            mword old_cr4 = current->regs.read_cr<Vmcs>(4);
ffffffff81006fbe:	48 8b 05 43 80 ff 3e 	mov    0x3eff8043(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81006fc5:	be 04 00 00 00       	mov    $0x4,%esi
ffffffff81006fca:	48 8d b8 a8 00 00 00 	lea    0xa8(%rax),%rdi
ffffffff81006fd1:	e8 a2 cf 00 00       	callq  ffffffff81013f78 <_ZNK8Exc_regs7read_crI4VmcsEEmj>
ffffffff81006fd6:	49 89 c4             	mov    %rax,%r12

            current->regs.write_cr<Vmcs> (cr, current->regs.vmx_read_gpr (gpr));
ffffffff81006fd9:	48 8b 05 28 80 ff 3e 	mov    0x3eff8028(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81006fe0:	89 ee                	mov    %ebp,%esi
ffffffff81006fe2:	48 8d b8 a8 00 00 00 	lea    0xa8(%rax),%rdi
ffffffff81006fe9:	e8 ca cd 00 00       	callq  ffffffff81013db8 <_ZN8Exc_regs12vmx_read_gprEj>
ffffffff81006fee:	48 8b 0d 13 80 ff 3e 	mov    0x3eff8013(%rip),%rcx        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81006ff5:	48 89 c2             	mov    %rax,%rdx
ffffffff81006ff8:	89 de                	mov    %ebx,%esi
ffffffff81006ffa:	48 8d b9 a8 00 00 00 	lea    0xa8(%rcx),%rdi
ffffffff81007001:	e8 a2 d2 00 00       	callq  ffffffff810142a8 <_ZN8Exc_regs8write_crI4VmcsEEvjm>
             * Intel manual sections 4.4.1 of Vol. 3A and 26.3.2.4 of Vol. 3C
             * indicate the conditions when this is the case.
             */

            /* no update needed if nested paging is not enabled */
            if (!current->regs.nst_on)
ffffffff81007006:	48 8b 3d fb 7f ff 3e 	mov    0x3eff7ffb(%rip),%rdi        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100700d:	80 bf 68 01 00 00 00 	cmpb   $0x0,0x168(%rdi)
ffffffff81007014:	0f 84 de 00 00 00    	je     ffffffff810070f8 <_ZN2Ec6vmx_crEv+0x1c8>
                break;

            mword cr0 = current->regs.read_cr<Vmcs>(0);
ffffffff8100701a:	48 81 c7 a8 00 00 00 	add    $0xa8,%rdi
ffffffff81007021:	31 f6                	xor    %esi,%esi
ffffffff81007023:	e8 50 cf 00 00       	callq  ffffffff81013f78 <_ZNK8Exc_regs7read_crI4VmcsEEmj>
ffffffff81007028:	48 89 c5             	mov    %rax,%rbp
            mword cr4 = current->regs.read_cr<Vmcs>(4);
ffffffff8100702b:	48 8b 05 d6 7f ff 3e 	mov    0x3eff7fd6(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81007032:	be 04 00 00 00       	mov    $0x4,%esi
ffffffff81007037:	48 8d b8 a8 00 00 00 	lea    0xa8(%rax),%rdi
ffffffff8100703e:	e8 35 cf 00 00       	callq  ffffffff81013f78 <_ZNK8Exc_regs7read_crI4VmcsEEmj>

            /* no update needed if not in protected mode with paging and PAE enabled */
            if (!((cr0 & Cpu::CR0_PE) &&
ffffffff81007043:	48 89 e9             	mov    %rbp,%rcx
            /* no update needed if nested paging is not enabled */
            if (!current->regs.nst_on)
                break;

            mword cr0 = current->regs.read_cr<Vmcs>(0);
            mword cr4 = current->regs.read_cr<Vmcs>(4);
ffffffff81007046:	48 89 c2             	mov    %rax,%rdx

            /* no update needed if not in protected mode with paging and PAE enabled */
            if (!((cr0 & Cpu::CR0_PE) &&
ffffffff81007049:	b8 01 00 00 80       	mov    $0x80000001,%eax
ffffffff8100704e:	81 e1 01 00 00 80    	and    $0x80000001,%ecx
ffffffff81007054:	48 39 c1             	cmp    %rax,%rcx
ffffffff81007057:	0f 85 9b 00 00 00    	jne    ffffffff810070f8 <_ZN2Ec6vmx_crEv+0x1c8>
                  (cr0 & Cpu::CR0_PG) &&
                  (cr4 & Cpu::CR4_PAE)))
ffffffff8100705d:	f6 c2 20             	test   $0x20,%dl
ffffffff81007060:	0f 84 92 00 00 00    	je     ffffffff810070f8 <_ZN2Ec6vmx_crEv+0x1c8>
                break;

            /* no update needed if no relevant bits of CR0 or CR4 have changed */
            if ((cr != 3) &&
ffffffff81007066:	83 fb 03             	cmp    $0x3,%ebx
ffffffff81007069:	74 18                	je     ffffffff81007083 <_ZN2Ec6vmx_crEv+0x153>
                ((cr0 & Cpu::CR0_CD) == (old_cr0 & Cpu::CR0_CD)) &&
                ((cr0 & Cpu::CR0_NW) == (old_cr0 & Cpu::CR0_NW)) &&
ffffffff8100706b:	49 31 ed             	xor    %rbp,%r13
ffffffff8100706e:	41 f7 c5 00 00 00 e0 	test   $0xe0000000,%r13d
ffffffff81007075:	75 0c                	jne    ffffffff81007083 <_ZN2Ec6vmx_crEv+0x153>
                ((cr0 & Cpu::CR0_PG) == (old_cr0 & Cpu::CR0_PG)) &&
                ((cr4 & Cpu::CR4_PAE) == (old_cr4 & Cpu::CR4_PAE)) &&
                ((cr4 & Cpu::CR4_PGE) == (old_cr4 & Cpu::CR4_PGE)) &&
                ((cr4 & Cpu::CR4_PSE) == (old_cr4 & Cpu::CR4_PSE)) &&
ffffffff81007077:	49 31 d4             	xor    %rdx,%r12
ffffffff8100707a:	41 f7 c4 b0 00 10 00 	test   $0x1000b0,%r12d
ffffffff81007081:	74 75                	je     ffffffff810070f8 <_ZN2Ec6vmx_crEv+0x1c8>
                ((cr4 & Cpu::CR4_SMEP) == (old_cr4 & Cpu::CR4_SMEP)))
               break;

            /* PDPTE register update necessary */
            current->regs.dst_portal = Vmcs::VMX_CR;
ffffffff81007083:	48 8b 05 7e 7f ff 3e 	mov    0x3eff7f7e(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100708a:	48 c7 80 50 01 00 00 	movq   $0x1c,0x150(%rax)
ffffffff81007091:	1c 00 00 00 
            send_msg<ret_user_vmresume>();
ffffffff81007095:	e8 d4 05 01 00       	callq  ffffffff8101766e <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv>

            break;
        }
        case 1:     // MOV from CR

            if (cr == 8) {
ffffffff8100709a:	83 fb 08             	cmp    $0x8,%ebx
ffffffff8100709d:	74 e4                	je     ffffffff81007083 <_ZN2Ec6vmx_crEv+0x153>
                /* Let the VMM handle CR8 */
                current->regs.dst_portal = Vmcs::VMX_CR;
                send_msg<ret_user_vmresume>();
            }

            assert (cr != 0 && cr != 4);
ffffffff8100709f:	a8 0b                	test   $0xb,%al
ffffffff810070a1:	75 28                	jne    ffffffff810070cb <_ZN2Ec6vmx_crEv+0x19b>
ffffffff810070a3:	49 c7 c0 10 e4 01 81 	mov    $0xffffffff8101e410,%r8
ffffffff810070aa:	b9 b0 00 00 00       	mov    $0xb0,%ecx
ffffffff810070af:	48 c7 c2 89 e3 01 81 	mov    $0xffffffff8101e389,%rdx
ffffffff810070b6:	48 c7 c6 f7 e3 01 81 	mov    $0xffffffff8101e3f7,%rsi
ffffffff810070bd:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff810070c4:	31 c0                	xor    %eax,%eax
ffffffff810070c6:	e8 85 ae ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
            current->regs.vmx_write_gpr (gpr, current->regs.read_cr<Vmcs> (cr));
ffffffff810070cb:	48 8b 05 36 7f ff 3e 	mov    0x3eff7f36(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff810070d2:	89 de                	mov    %ebx,%esi
ffffffff810070d4:	48 8d b8 a8 00 00 00 	lea    0xa8(%rax),%rdi
ffffffff810070db:	e8 98 ce 00 00       	callq  ffffffff81013f78 <_ZNK8Exc_regs7read_crI4VmcsEEmj>
ffffffff810070e0:	48 8b 0d 21 7f ff 3e 	mov    0x3eff7f21(%rip),%rcx        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff810070e7:	48 89 c2             	mov    %rax,%rdx
ffffffff810070ea:	89 ee                	mov    %ebp,%esi
ffffffff810070ec:	48 8d b9 a8 00 00 00 	lea    0xa8(%rcx),%rdi
ffffffff810070f3:	e8 de cc 00 00       	callq  ffffffff81013dd6 <_ZN8Exc_regs13vmx_write_gprEjm>
ffffffff810070f8:	b9 1e 68 00 00       	mov    $0x681e,%ecx
ffffffff810070fd:	0f 78 ca             	vmread %rcx,%rdx
ffffffff81007100:	b8 0c 44 00 00       	mov    $0x440c,%eax
ffffffff81007105:	0f 78 c0             	vmread %rax,%rax
        }

        ALWAYS_INLINE
        static inline void adjust_rip()
        {
            write (GUEST_RIP, read (GUEST_RIP) + read (EXI_INST_LEN));
ffffffff81007108:	48 01 d0             	add    %rdx,%rax
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
ffffffff8100710b:	0f 79 c8             	vmwrite %rax,%rcx

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
ffffffff8100710e:	b8 24 48 00 00       	mov    $0x4824,%eax
ffffffff81007113:	0f 78 c0             	vmread %rax,%rax
        static inline void adjust_rip()
        {
            write (GUEST_RIP, read (GUEST_RIP) + read (EXI_INST_LEN));

            uint32 intr = static_cast<uint32>(read (GUEST_INTR_STATE));
            if (EXPECT_FALSE (intr & 3))
ffffffff81007116:	a8 03                	test   $0x3,%al
ffffffff81007118:	74 0b                	je     ffffffff81007125 <_ZN2Ec6vmx_crEv+0x1f5>
                write (GUEST_INTR_STATE, intr & ~3);
ffffffff8100711a:	83 e0 fc             	and    $0xfffffffc,%eax
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
ffffffff8100711d:	ba 24 48 00 00       	mov    $0x4824,%edx
ffffffff81007122:	0f 79 d0             	vmwrite %rax,%rdx
        default:
            UNREACHED;
    }

    Vmcs::adjust_rip();
    ret_user_vmresume();
ffffffff81007125:	e8 28 e0 ff ff       	callq  ffffffff81005152 <_ZN2Ec17ret_user_vmresumeEv>

ffffffff8100712a <vmx_handler>:
}

void Ec::handle_vmx()
{
    Cpu::hazard = (Cpu::hazard | HZD_DS_ES | HZD_TR) & ~HZD_FPU;
ffffffff8100712a:	8b 05 d0 7e ff 3e    	mov    0x3eff7ed0(%rip),%eax        # ffffffffbffff000 <_ZN3Cpu6hazardE>
    Vmcs::adjust_rip();
    ret_user_vmresume();
}

void Ec::handle_vmx()
{
ffffffff81007130:	53                   	push   %rbx

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
ffffffff81007131:	bb 02 44 00 00       	mov    $0x4402,%ebx
    Cpu::hazard = (Cpu::hazard | HZD_DS_ES | HZD_TR) & ~HZD_FPU;
ffffffff81007136:	83 e0 f1             	and    $0xfffffff1,%eax
ffffffff81007139:	83 c8 06             	or     $0x6,%eax
ffffffff8100713c:	89 05 be 7e ff 3e    	mov    %eax,0x3eff7ebe(%rip)        # ffffffffbffff000 <_ZN3Cpu6hazardE>
ffffffff81007142:	0f 78 db             	vmread %rbx,%rbx

    mword reason = Vmcs::read (Vmcs::EXI_REASON) & 0xff;
ffffffff81007145:	0f b6 db             	movzbl %bl,%ebx

    Counter::vmi[reason]++;
ffffffff81007148:	ff 04 9d 80 f0 ff bf 	incl   -0x40000f80(,%rbx,4)
//    Console::print("VM Exit %08lx", reason);
    
    switch (reason) {
ffffffff8100714f:	48 83 fb 10          	cmp    $0x10,%rbx
ffffffff81007153:	74 64                	je     ffffffff810071b9 <vmx_handler+0x8f>
ffffffff81007155:	77 17                	ja     ffffffff8100716e <vmx_handler+0x44>
ffffffff81007157:	48 83 fb 01          	cmp    $0x1,%rbx
ffffffff8100715b:	74 37                	je     ffffffff81007194 <vmx_handler+0x6a>
ffffffff8100715d:	72 30                	jb     ffffffff8100718f <vmx_handler+0x65>
ffffffff8100715f:	48 83 fb 0e          	cmp    $0xe,%rbx
ffffffff81007163:	0f 85 91 00 00 00    	jne    ffffffff810071fa <vmx_handler+0xd0>
        case Vmcs::VMX_EXC_NMI:     vmx_exception();
        case Vmcs::VMX_EXTINT:      vmx_extint();
        case Vmcs::VMX_INVLPG:      vmx_invlpg();
ffffffff81007169:	e8 74 fd ff ff       	callq  ffffffff81006ee2 <_ZN2Ec10vmx_invlpgEv>
    mword reason = Vmcs::read (Vmcs::EXI_REASON) & 0xff;

    Counter::vmi[reason]++;
//    Console::print("VM Exit %08lx", reason);
    
    switch (reason) {
ffffffff8100716e:	48 83 fb 30          	cmp    $0x30,%rbx
ffffffff81007172:	74 25                	je     ffffffff81007199 <vmx_handler+0x6f>
ffffffff81007174:	48 83 fb 33          	cmp    $0x33,%rbx
ffffffff81007178:	74 6d                	je     ffffffff810071e7 <vmx_handler+0xbd>
ffffffff8100717a:	48 83 fb 1c          	cmp    $0x1c,%rbx
ffffffff8100717e:	75 7a                	jne    ffffffff810071fa <vmx_handler+0xd0>
        case Vmcs::VMX_EXC_NMI:     vmx_exception();
        case Vmcs::VMX_EXTINT:      vmx_extint();
        case Vmcs::VMX_INVLPG:      vmx_invlpg();
        case Vmcs::VMX_CR:          {check_memory(reason); vmx_cr();}
ffffffff81007180:	bf 1c 00 00 00       	mov    $0x1c,%edi
ffffffff81007185:	e8 8e f4 ff ff       	callq  ffffffff81006618 <memory_checker>
ffffffff8100718a:	e8 a1 fd ff ff       	callq  ffffffff81006f30 <_ZN2Ec6vmx_crEv>

    Counter::vmi[reason]++;
//    Console::print("VM Exit %08lx", reason);
    
    switch (reason) {
        case Vmcs::VMX_EXC_NMI:     vmx_exception();
ffffffff8100718f:	e8 c4 fb ff ff       	callq  ffffffff81006d58 <_ZN2Ec13vmx_exceptionEv>
        case Vmcs::VMX_EXTINT:      vmx_extint();
ffffffff81007194:	e8 01 fd ff ff       	callq  ffffffff81006e9a <_ZN2Ec10vmx_extintEv>
        case Vmcs::VMX_INVLPG:      vmx_invlpg();
        case Vmcs::VMX_CR:          {check_memory(reason); vmx_cr();}
        case Vmcs::VMX_EPT_VIOLATION:
            current->regs.nst_error = Vmcs::read (Vmcs::EXI_QUALIFICATION);
ffffffff81007199:	48 8b 05 68 7e ff 3e 	mov    0x3eff7e68(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff810071a0:	ba 00 64 00 00       	mov    $0x6400,%edx
ffffffff810071a5:	0f 78 90 60 01 00 00 	vmread %rdx,0x160(%rax)
            current->regs.nst_fault = Vmcs::read (Vmcs::INFO_PHYS_ADDR);
ffffffff810071ac:	66 ba 00 24          	mov    $0x2400,%dx
ffffffff810071b0:	0f 78 90 58 01 00 00 	vmread %rdx,0x158(%rax)
            break;
ffffffff810071b7:	eb 41                	jmp    ffffffff810071fa <vmx_handler+0xd0>
        case Vmcs::VMX_RDTSC: 
            check_memory(reason);
ffffffff810071b9:	bf 10 00 00 00       	mov    $0x10,%edi
ffffffff810071be:	e8 55 f4 ff ff       	callq  ffffffff81006618 <memory_checker>

ALWAYS_INLINE
static inline uint64 rdtsc()
{
    mword h, l;
    asm volatile ("rdtsc" : "=a" (l), "=d" (h));
ffffffff810071c3:	0f 31                	rdtsc  
    return static_cast<uint64>(h) << 32 | l;
ffffffff810071c5:	48 89 d6             	mov    %rdx,%rsi
ffffffff810071c8:	48 c1 e6 20          	shl    $0x20,%rsi
ffffffff810071cc:	48 09 c6             	or     %rax,%rsi
            current->regs.resolve_rdtsc<Vmcs>(rdtsc());
ffffffff810071cf:	48 8b 05 32 7e ff 3e 	mov    0x3eff7e32(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff810071d6:	48 8d b8 a8 00 00 00 	lea    0xa8(%rax),%rdi
ffffffff810071dd:	e8 4e c7 00 00       	callq  ffffffff81013930 <_ZN8Exc_regs13resolve_rdtscI4VmcsEEvy>
            ret_user_vmresume();
ffffffff810071e2:	e8 6b df ff ff       	callq  ffffffff81005152 <_ZN2Ec17ret_user_vmresumeEv>
            break;
        case Vmcs::VMX_RDTSCP:
            Console::print("RDTSCP in VM");
ffffffff810071e7:	48 c7 c7 37 e3 01 81 	mov    $0xffffffff8101e337,%rdi
ffffffff810071ee:	31 c0                	xor    %eax,%eax
ffffffff810071f0:	e8 97 ae ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
            ret_user_vmrun();
ffffffff810071f5:	e8 90 d8 ff ff       	callq  ffffffff81004a8a <_ZN2Ec14ret_user_vmrunEv>
            break;
    }

    check_memory(reason);
ffffffff810071fa:	48 89 df             	mov    %rbx,%rdi
ffffffff810071fd:	e8 16 f4 ff ff       	callq  ffffffff81006618 <memory_checker>
    current->regs.dst_portal = reason;
ffffffff81007202:	48 8b 05 ff 7d ff 3e 	mov    0x3eff7dff(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81007209:	48 89 98 50 01 00 00 	mov    %rbx,0x150(%rax)

    send_msg<ret_user_vmresume>();
ffffffff81007210:	e8 59 04 01 00       	callq  ffffffff8101766e <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv>
ffffffff81007215:	90                   	nop
ffffffff81007216:	90                   	nop
ffffffff81007217:	90                   	nop

ffffffff81007218 <entry_exc>:
.endm

/*
 * Exception Entries
 */
entry_exc:              push    $0
ffffffff81007218:	6a 00                	pushq  $0x0

ffffffff8100721a <entry_exc_error>:
entry_exc_error:        SAVE_STATE
ffffffff8100721a:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff8100721e:	50                   	push   %rax
ffffffff8100721f:	51                   	push   %rcx
ffffffff81007220:	52                   	push   %rdx
ffffffff81007221:	53                   	push   %rbx
ffffffff81007222:	54                   	push   %rsp
ffffffff81007223:	55                   	push   %rbp
ffffffff81007224:	56                   	push   %rsi
ffffffff81007225:	57                   	push   %rdi
ffffffff81007226:	41 50                	push   %r8
ffffffff81007228:	41 51                	push   %r9
ffffffff8100722a:	41 52                	push   %r10
ffffffff8100722c:	41 53                	push   %r11
ffffffff8100722e:	41 54                	push   %r12
ffffffff81007230:	41 55                	push   %r13
ffffffff81007232:	41 56                	push   %r14
ffffffff81007234:	41 57                	push   %r15
ffffffff81007236:	48 89 e3             	mov    %rsp,%rbx
ffffffff81007239:	48 81 fc 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rsp
ffffffff81007240:	73 15                	jae    ffffffff81007257 <entry_exc_error+0x3d>
ffffffff81007242:	fc                   	cld    
ffffffff81007243:	48 c7 c4 00 e0 ff bf 	mov    $0xffffffffbfffe000,%rsp
ffffffff8100724a:	48 c7 c0 23 00 00 00 	mov    $0x23,%rax
ffffffff81007251:	48 8e d8             	mov    %rax,%ds
ffffffff81007254:	48 8e c0             	mov    %rax,%es
                        mov     %cr2, %REG(ax)
ffffffff81007257:	0f 20 d0             	mov    %cr2,%rax
                        mov     %REG(ax), OFS_CR2 (%REG(bx))
ffffffff8100725a:	48 89 43 58          	mov    %rax,0x58(%rbx)
                        mov     %REG(bx), %ARG_1
ffffffff8100725e:	48 89 df             	mov    %rbx,%rdi
                        call    exc_handler
ffffffff81007261:	e8 4c f3 ff ff       	callq  ffffffff810065b2 <exc_handler>
                        jmp     ret_from_interrupt
ffffffff81007266:	e9 71 06 00 00       	jmpq   ffffffff810078dc <ret_from_interrupt>
ffffffff8100726b:	90                   	nop

EXCEPTION               0x0,    0
ffffffff8100726c:	6a 00                	pushq  $0x0
ffffffff8100726e:	eb a8                	jmp    ffffffff81007218 <entry_exc>
EXCEPTION               0x1,    0
ffffffff81007270:	6a 01                	pushq  $0x1
ffffffff81007272:	eb a4                	jmp    ffffffff81007218 <entry_exc>
TASKGATE
EXCEPTION               0x3,    3
ffffffff81007274:	6a 03                	pushq  $0x3
ffffffff81007276:	eb a0                	jmp    ffffffff81007218 <entry_exc>
EXCEPTION               0x4,    3
ffffffff81007278:	6a 04                	pushq  $0x4
ffffffff8100727a:	eb 9c                	jmp    ffffffff81007218 <entry_exc>
EXCEPTION               0x5,    0
ffffffff8100727c:	6a 05                	pushq  $0x5
ffffffff8100727e:	eb 98                	jmp    ffffffff81007218 <entry_exc>
EXCEPTION               0x6,    0
ffffffff81007280:	6a 06                	pushq  $0x6
ffffffff81007282:	eb 94                	jmp    ffffffff81007218 <entry_exc>
EXCEPTION               0x7,    0
ffffffff81007284:	6a 07                	pushq  $0x7
ffffffff81007286:	eb 90                	jmp    ffffffff81007218 <entry_exc>
TASKGATE
TASKGATE
EXCEPTION_ERROR         0xa,    0
ffffffff81007288:	ff 34 24             	pushq  (%rsp)
ffffffff8100728b:	48 c7 44 24 08 0a 00 	movq   $0xa,0x8(%rsp)
ffffffff81007292:	00 00 
ffffffff81007294:	eb 84                	jmp    ffffffff8100721a <entry_exc_error>
ffffffff81007296:	66 90                	xchg   %ax,%ax
EXCEPTION_ERROR         0xb,    0
ffffffff81007298:	ff 34 24             	pushq  (%rsp)
ffffffff8100729b:	48 c7 44 24 08 0b 00 	movq   $0xb,0x8(%rsp)
ffffffff810072a2:	00 00 
ffffffff810072a4:	e9 71 ff ff ff       	jmpq   ffffffff8100721a <entry_exc_error>
ffffffff810072a9:	0f 1f 00             	nopl   (%rax)
EXCEPTION_ERROR         0xc,    0
ffffffff810072ac:	ff 34 24             	pushq  (%rsp)
ffffffff810072af:	48 c7 44 24 08 0c 00 	movq   $0xc,0x8(%rsp)
ffffffff810072b6:	00 00 
ffffffff810072b8:	e9 5d ff ff ff       	jmpq   ffffffff8100721a <entry_exc_error>
ffffffff810072bd:	0f 1f 00             	nopl   (%rax)
EXCEPTION_ERROR         0xd,    0
ffffffff810072c0:	ff 34 24             	pushq  (%rsp)
ffffffff810072c3:	48 c7 44 24 08 0d 00 	movq   $0xd,0x8(%rsp)
ffffffff810072ca:	00 00 
ffffffff810072cc:	e9 49 ff ff ff       	jmpq   ffffffff8100721a <entry_exc_error>
ffffffff810072d1:	0f 1f 00             	nopl   (%rax)
EXCEPTION_ERROR         0xe,    0
ffffffff810072d4:	ff 34 24             	pushq  (%rsp)
ffffffff810072d7:	48 c7 44 24 08 0e 00 	movq   $0xe,0x8(%rsp)
ffffffff810072de:	00 00 
ffffffff810072e0:	e9 35 ff ff ff       	jmpq   ffffffff8100721a <entry_exc_error>
ffffffff810072e5:	0f 1f 00             	nopl   (%rax)
TASKGATE
EXCEPTION               0x10,   0
ffffffff810072e8:	6a 10                	pushq  $0x10
ffffffff810072ea:	e9 29 ff ff ff       	jmpq   ffffffff81007218 <entry_exc>
ffffffff810072ef:	90                   	nop
EXCEPTION_ERROR         0x11,   0
ffffffff810072f0:	ff 34 24             	pushq  (%rsp)
ffffffff810072f3:	48 c7 44 24 08 11 00 	movq   $0x11,0x8(%rsp)
ffffffff810072fa:	00 00 
ffffffff810072fc:	e9 19 ff ff ff       	jmpq   ffffffff8100721a <entry_exc_error>
ffffffff81007301:	0f 1f 00             	nopl   (%rax)
EXCEPTION               0x12,   0
ffffffff81007304:	6a 12                	pushq  $0x12
ffffffff81007306:	e9 0d ff ff ff       	jmpq   ffffffff81007218 <entry_exc>
ffffffff8100730b:	90                   	nop
EXCEPTION               0x13,   0
ffffffff8100730c:	6a 13                	pushq  $0x13
ffffffff8100730e:	e9 05 ff ff ff       	jmpq   ffffffff81007218 <entry_exc>
ffffffff81007313:	90                   	nop
.rept                   NUM_GSI
INTRGATE                0
                        push    $VEC
                        jmp     entry_gsi
.set                    VEC, VEC + 1
.endr
ffffffff81007314:	6a 20                	pushq  $0x20
ffffffff81007316:	e9 38 04 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff8100731b:	90                   	nop
ffffffff8100731c:	6a 21                	pushq  $0x21
ffffffff8100731e:	e9 30 04 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff81007323:	90                   	nop
ffffffff81007324:	6a 22                	pushq  $0x22
ffffffff81007326:	e9 28 04 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff8100732b:	90                   	nop
ffffffff8100732c:	6a 23                	pushq  $0x23
ffffffff8100732e:	e9 20 04 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff81007333:	90                   	nop
ffffffff81007334:	6a 24                	pushq  $0x24
ffffffff81007336:	e9 18 04 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff8100733b:	90                   	nop
ffffffff8100733c:	6a 25                	pushq  $0x25
ffffffff8100733e:	e9 10 04 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff81007343:	90                   	nop
ffffffff81007344:	6a 26                	pushq  $0x26
ffffffff81007346:	e9 08 04 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff8100734b:	90                   	nop
ffffffff8100734c:	6a 27                	pushq  $0x27
ffffffff8100734e:	e9 00 04 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff81007353:	90                   	nop
ffffffff81007354:	6a 28                	pushq  $0x28
ffffffff81007356:	e9 f8 03 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff8100735b:	90                   	nop
ffffffff8100735c:	6a 29                	pushq  $0x29
ffffffff8100735e:	e9 f0 03 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff81007363:	90                   	nop
ffffffff81007364:	6a 2a                	pushq  $0x2a
ffffffff81007366:	e9 e8 03 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff8100736b:	90                   	nop
ffffffff8100736c:	6a 2b                	pushq  $0x2b
ffffffff8100736e:	e9 e0 03 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff81007373:	90                   	nop
ffffffff81007374:	6a 2c                	pushq  $0x2c
ffffffff81007376:	e9 d8 03 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff8100737b:	90                   	nop
ffffffff8100737c:	6a 2d                	pushq  $0x2d
ffffffff8100737e:	e9 d0 03 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff81007383:	90                   	nop
ffffffff81007384:	6a 2e                	pushq  $0x2e
ffffffff81007386:	e9 c8 03 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff8100738b:	90                   	nop
ffffffff8100738c:	6a 2f                	pushq  $0x2f
ffffffff8100738e:	e9 c0 03 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff81007393:	90                   	nop
ffffffff81007394:	6a 30                	pushq  $0x30
ffffffff81007396:	e9 b8 03 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff8100739b:	90                   	nop
ffffffff8100739c:	6a 31                	pushq  $0x31
ffffffff8100739e:	e9 b0 03 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810073a3:	90                   	nop
ffffffff810073a4:	6a 32                	pushq  $0x32
ffffffff810073a6:	e9 a8 03 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810073ab:	90                   	nop
ffffffff810073ac:	6a 33                	pushq  $0x33
ffffffff810073ae:	e9 a0 03 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810073b3:	90                   	nop
ffffffff810073b4:	6a 34                	pushq  $0x34
ffffffff810073b6:	e9 98 03 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810073bb:	90                   	nop
ffffffff810073bc:	6a 35                	pushq  $0x35
ffffffff810073be:	e9 90 03 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810073c3:	90                   	nop
ffffffff810073c4:	6a 36                	pushq  $0x36
ffffffff810073c6:	e9 88 03 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810073cb:	90                   	nop
ffffffff810073cc:	6a 37                	pushq  $0x37
ffffffff810073ce:	e9 80 03 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810073d3:	90                   	nop
ffffffff810073d4:	6a 38                	pushq  $0x38
ffffffff810073d6:	e9 78 03 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810073db:	90                   	nop
ffffffff810073dc:	6a 39                	pushq  $0x39
ffffffff810073de:	e9 70 03 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810073e3:	90                   	nop
ffffffff810073e4:	6a 3a                	pushq  $0x3a
ffffffff810073e6:	e9 68 03 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810073eb:	90                   	nop
ffffffff810073ec:	6a 3b                	pushq  $0x3b
ffffffff810073ee:	e9 60 03 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810073f3:	90                   	nop
ffffffff810073f4:	6a 3c                	pushq  $0x3c
ffffffff810073f6:	e9 58 03 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810073fb:	90                   	nop
ffffffff810073fc:	6a 3d                	pushq  $0x3d
ffffffff810073fe:	e9 50 03 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff81007403:	90                   	nop
ffffffff81007404:	6a 3e                	pushq  $0x3e
ffffffff81007406:	e9 48 03 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff8100740b:	90                   	nop
ffffffff8100740c:	6a 3f                	pushq  $0x3f
ffffffff8100740e:	e9 40 03 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff81007413:	90                   	nop
ffffffff81007414:	6a 40                	pushq  $0x40
ffffffff81007416:	e9 38 03 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff8100741b:	90                   	nop
ffffffff8100741c:	6a 41                	pushq  $0x41
ffffffff8100741e:	e9 30 03 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff81007423:	90                   	nop
ffffffff81007424:	6a 42                	pushq  $0x42
ffffffff81007426:	e9 28 03 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff8100742b:	90                   	nop
ffffffff8100742c:	6a 43                	pushq  $0x43
ffffffff8100742e:	e9 20 03 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff81007433:	90                   	nop
ffffffff81007434:	6a 44                	pushq  $0x44
ffffffff81007436:	e9 18 03 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff8100743b:	90                   	nop
ffffffff8100743c:	6a 45                	pushq  $0x45
ffffffff8100743e:	e9 10 03 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff81007443:	90                   	nop
ffffffff81007444:	6a 46                	pushq  $0x46
ffffffff81007446:	e9 08 03 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff8100744b:	90                   	nop
ffffffff8100744c:	6a 47                	pushq  $0x47
ffffffff8100744e:	e9 00 03 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff81007453:	90                   	nop
ffffffff81007454:	6a 48                	pushq  $0x48
ffffffff81007456:	e9 f8 02 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff8100745b:	90                   	nop
ffffffff8100745c:	6a 49                	pushq  $0x49
ffffffff8100745e:	e9 f0 02 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff81007463:	90                   	nop
ffffffff81007464:	6a 4a                	pushq  $0x4a
ffffffff81007466:	e9 e8 02 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff8100746b:	90                   	nop
ffffffff8100746c:	6a 4b                	pushq  $0x4b
ffffffff8100746e:	e9 e0 02 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff81007473:	90                   	nop
ffffffff81007474:	6a 4c                	pushq  $0x4c
ffffffff81007476:	e9 d8 02 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff8100747b:	90                   	nop
ffffffff8100747c:	6a 4d                	pushq  $0x4d
ffffffff8100747e:	e9 d0 02 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff81007483:	90                   	nop
ffffffff81007484:	6a 4e                	pushq  $0x4e
ffffffff81007486:	e9 c8 02 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff8100748b:	90                   	nop
ffffffff8100748c:	6a 4f                	pushq  $0x4f
ffffffff8100748e:	e9 c0 02 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff81007493:	90                   	nop
ffffffff81007494:	6a 50                	pushq  $0x50
ffffffff81007496:	e9 b8 02 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff8100749b:	90                   	nop
ffffffff8100749c:	6a 51                	pushq  $0x51
ffffffff8100749e:	e9 b0 02 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810074a3:	90                   	nop
ffffffff810074a4:	6a 52                	pushq  $0x52
ffffffff810074a6:	e9 a8 02 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810074ab:	90                   	nop
ffffffff810074ac:	6a 53                	pushq  $0x53
ffffffff810074ae:	e9 a0 02 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810074b3:	90                   	nop
ffffffff810074b4:	6a 54                	pushq  $0x54
ffffffff810074b6:	e9 98 02 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810074bb:	90                   	nop
ffffffff810074bc:	6a 55                	pushq  $0x55
ffffffff810074be:	e9 90 02 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810074c3:	90                   	nop
ffffffff810074c4:	6a 56                	pushq  $0x56
ffffffff810074c6:	e9 88 02 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810074cb:	90                   	nop
ffffffff810074cc:	6a 57                	pushq  $0x57
ffffffff810074ce:	e9 80 02 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810074d3:	90                   	nop
ffffffff810074d4:	6a 58                	pushq  $0x58
ffffffff810074d6:	e9 78 02 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810074db:	90                   	nop
ffffffff810074dc:	6a 59                	pushq  $0x59
ffffffff810074de:	e9 70 02 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810074e3:	90                   	nop
ffffffff810074e4:	6a 5a                	pushq  $0x5a
ffffffff810074e6:	e9 68 02 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810074eb:	90                   	nop
ffffffff810074ec:	6a 5b                	pushq  $0x5b
ffffffff810074ee:	e9 60 02 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810074f3:	90                   	nop
ffffffff810074f4:	6a 5c                	pushq  $0x5c
ffffffff810074f6:	e9 58 02 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810074fb:	90                   	nop
ffffffff810074fc:	6a 5d                	pushq  $0x5d
ffffffff810074fe:	e9 50 02 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff81007503:	90                   	nop
ffffffff81007504:	6a 5e                	pushq  $0x5e
ffffffff81007506:	e9 48 02 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff8100750b:	90                   	nop
ffffffff8100750c:	6a 5f                	pushq  $0x5f
ffffffff8100750e:	e9 40 02 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff81007513:	90                   	nop
ffffffff81007514:	6a 60                	pushq  $0x60
ffffffff81007516:	e9 38 02 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff8100751b:	90                   	nop
ffffffff8100751c:	6a 61                	pushq  $0x61
ffffffff8100751e:	e9 30 02 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff81007523:	90                   	nop
ffffffff81007524:	6a 62                	pushq  $0x62
ffffffff81007526:	e9 28 02 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff8100752b:	90                   	nop
ffffffff8100752c:	6a 63                	pushq  $0x63
ffffffff8100752e:	e9 20 02 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff81007533:	90                   	nop
ffffffff81007534:	6a 64                	pushq  $0x64
ffffffff81007536:	e9 18 02 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff8100753b:	90                   	nop
ffffffff8100753c:	6a 65                	pushq  $0x65
ffffffff8100753e:	e9 10 02 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff81007543:	90                   	nop
ffffffff81007544:	6a 66                	pushq  $0x66
ffffffff81007546:	e9 08 02 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff8100754b:	90                   	nop
ffffffff8100754c:	6a 67                	pushq  $0x67
ffffffff8100754e:	e9 00 02 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff81007553:	90                   	nop
ffffffff81007554:	6a 68                	pushq  $0x68
ffffffff81007556:	e9 f8 01 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff8100755b:	90                   	nop
ffffffff8100755c:	6a 69                	pushq  $0x69
ffffffff8100755e:	e9 f0 01 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff81007563:	90                   	nop
ffffffff81007564:	6a 6a                	pushq  $0x6a
ffffffff81007566:	e9 e8 01 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff8100756b:	90                   	nop
ffffffff8100756c:	6a 6b                	pushq  $0x6b
ffffffff8100756e:	e9 e0 01 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff81007573:	90                   	nop
ffffffff81007574:	6a 6c                	pushq  $0x6c
ffffffff81007576:	e9 d8 01 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff8100757b:	90                   	nop
ffffffff8100757c:	6a 6d                	pushq  $0x6d
ffffffff8100757e:	e9 d0 01 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff81007583:	90                   	nop
ffffffff81007584:	6a 6e                	pushq  $0x6e
ffffffff81007586:	e9 c8 01 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff8100758b:	90                   	nop
ffffffff8100758c:	6a 6f                	pushq  $0x6f
ffffffff8100758e:	e9 c0 01 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff81007593:	90                   	nop
ffffffff81007594:	6a 70                	pushq  $0x70
ffffffff81007596:	e9 b8 01 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff8100759b:	90                   	nop
ffffffff8100759c:	6a 71                	pushq  $0x71
ffffffff8100759e:	e9 b0 01 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810075a3:	90                   	nop
ffffffff810075a4:	6a 72                	pushq  $0x72
ffffffff810075a6:	e9 a8 01 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810075ab:	90                   	nop
ffffffff810075ac:	6a 73                	pushq  $0x73
ffffffff810075ae:	e9 a0 01 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810075b3:	90                   	nop
ffffffff810075b4:	6a 74                	pushq  $0x74
ffffffff810075b6:	e9 98 01 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810075bb:	90                   	nop
ffffffff810075bc:	6a 75                	pushq  $0x75
ffffffff810075be:	e9 90 01 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810075c3:	90                   	nop
ffffffff810075c4:	6a 76                	pushq  $0x76
ffffffff810075c6:	e9 88 01 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810075cb:	90                   	nop
ffffffff810075cc:	6a 77                	pushq  $0x77
ffffffff810075ce:	e9 80 01 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810075d3:	90                   	nop
ffffffff810075d4:	6a 78                	pushq  $0x78
ffffffff810075d6:	e9 78 01 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810075db:	90                   	nop
ffffffff810075dc:	6a 79                	pushq  $0x79
ffffffff810075de:	e9 70 01 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810075e3:	90                   	nop
ffffffff810075e4:	6a 7a                	pushq  $0x7a
ffffffff810075e6:	e9 68 01 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810075eb:	90                   	nop
ffffffff810075ec:	6a 7b                	pushq  $0x7b
ffffffff810075ee:	e9 60 01 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810075f3:	90                   	nop
ffffffff810075f4:	6a 7c                	pushq  $0x7c
ffffffff810075f6:	e9 58 01 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810075fb:	90                   	nop
ffffffff810075fc:	6a 7d                	pushq  $0x7d
ffffffff810075fe:	e9 50 01 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff81007603:	90                   	nop
ffffffff81007604:	6a 7e                	pushq  $0x7e
ffffffff81007606:	e9 48 01 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff8100760b:	90                   	nop
ffffffff8100760c:	6a 7f                	pushq  $0x7f
ffffffff8100760e:	e9 40 01 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff81007613:	90                   	nop
ffffffff81007614:	68 80 00 00 00       	pushq  $0x80
ffffffff81007619:	e9 35 01 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff8100761e:	66 90                	xchg   %ax,%ax
ffffffff81007620:	68 81 00 00 00       	pushq  $0x81
ffffffff81007625:	e9 29 01 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff8100762a:	66 90                	xchg   %ax,%ax
ffffffff8100762c:	68 82 00 00 00       	pushq  $0x82
ffffffff81007631:	e9 1d 01 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff81007636:	66 90                	xchg   %ax,%ax
ffffffff81007638:	68 83 00 00 00       	pushq  $0x83
ffffffff8100763d:	e9 11 01 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff81007642:	66 90                	xchg   %ax,%ax
ffffffff81007644:	68 84 00 00 00       	pushq  $0x84
ffffffff81007649:	e9 05 01 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff8100764e:	66 90                	xchg   %ax,%ax
ffffffff81007650:	68 85 00 00 00       	pushq  $0x85
ffffffff81007655:	e9 f9 00 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff8100765a:	66 90                	xchg   %ax,%ax
ffffffff8100765c:	68 86 00 00 00       	pushq  $0x86
ffffffff81007661:	e9 ed 00 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff81007666:	66 90                	xchg   %ax,%ax
ffffffff81007668:	68 87 00 00 00       	pushq  $0x87
ffffffff8100766d:	e9 e1 00 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff81007672:	66 90                	xchg   %ax,%ax
ffffffff81007674:	68 88 00 00 00       	pushq  $0x88
ffffffff81007679:	e9 d5 00 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff8100767e:	66 90                	xchg   %ax,%ax
ffffffff81007680:	68 89 00 00 00       	pushq  $0x89
ffffffff81007685:	e9 c9 00 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff8100768a:	66 90                	xchg   %ax,%ax
ffffffff8100768c:	68 8a 00 00 00       	pushq  $0x8a
ffffffff81007691:	e9 bd 00 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff81007696:	66 90                	xchg   %ax,%ax
ffffffff81007698:	68 8b 00 00 00       	pushq  $0x8b
ffffffff8100769d:	e9 b1 00 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810076a2:	66 90                	xchg   %ax,%ax
ffffffff810076a4:	68 8c 00 00 00       	pushq  $0x8c
ffffffff810076a9:	e9 a5 00 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810076ae:	66 90                	xchg   %ax,%ax
ffffffff810076b0:	68 8d 00 00 00       	pushq  $0x8d
ffffffff810076b5:	e9 99 00 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810076ba:	66 90                	xchg   %ax,%ax
ffffffff810076bc:	68 8e 00 00 00       	pushq  $0x8e
ffffffff810076c1:	e9 8d 00 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810076c6:	66 90                	xchg   %ax,%ax
ffffffff810076c8:	68 8f 00 00 00       	pushq  $0x8f
ffffffff810076cd:	e9 81 00 00 00       	jmpq   ffffffff81007753 <entry_gsi>
ffffffff810076d2:	66 90                	xchg   %ax,%ax
ffffffff810076d4:	68 90 00 00 00       	pushq  $0x90
ffffffff810076d9:	eb 78                	jmp    ffffffff81007753 <entry_gsi>
ffffffff810076db:	90                   	nop
ffffffff810076dc:	68 91 00 00 00       	pushq  $0x91
ffffffff810076e1:	eb 70                	jmp    ffffffff81007753 <entry_gsi>
ffffffff810076e3:	90                   	nop
ffffffff810076e4:	68 92 00 00 00       	pushq  $0x92
ffffffff810076e9:	eb 68                	jmp    ffffffff81007753 <entry_gsi>
ffffffff810076eb:	90                   	nop
ffffffff810076ec:	68 93 00 00 00       	pushq  $0x93
ffffffff810076f1:	eb 60                	jmp    ffffffff81007753 <entry_gsi>
ffffffff810076f3:	90                   	nop
ffffffff810076f4:	68 94 00 00 00       	pushq  $0x94
ffffffff810076f9:	eb 58                	jmp    ffffffff81007753 <entry_gsi>
ffffffff810076fb:	90                   	nop
ffffffff810076fc:	68 95 00 00 00       	pushq  $0x95
ffffffff81007701:	eb 50                	jmp    ffffffff81007753 <entry_gsi>
ffffffff81007703:	90                   	nop
ffffffff81007704:	68 96 00 00 00       	pushq  $0x96
ffffffff81007709:	eb 48                	jmp    ffffffff81007753 <entry_gsi>
ffffffff8100770b:	90                   	nop
ffffffff8100770c:	68 97 00 00 00       	pushq  $0x97
ffffffff81007711:	eb 40                	jmp    ffffffff81007753 <entry_gsi>
ffffffff81007713:	90                   	nop
ffffffff81007714:	68 98 00 00 00       	pushq  $0x98
ffffffff81007719:	eb 38                	jmp    ffffffff81007753 <entry_gsi>
ffffffff8100771b:	90                   	nop
ffffffff8100771c:	68 99 00 00 00       	pushq  $0x99
ffffffff81007721:	eb 30                	jmp    ffffffff81007753 <entry_gsi>
ffffffff81007723:	90                   	nop
ffffffff81007724:	68 9a 00 00 00       	pushq  $0x9a
ffffffff81007729:	eb 28                	jmp    ffffffff81007753 <entry_gsi>
ffffffff8100772b:	90                   	nop
ffffffff8100772c:	68 9b 00 00 00       	pushq  $0x9b
ffffffff81007731:	eb 20                	jmp    ffffffff81007753 <entry_gsi>
ffffffff81007733:	90                   	nop
ffffffff81007734:	68 9c 00 00 00       	pushq  $0x9c
ffffffff81007739:	eb 18                	jmp    ffffffff81007753 <entry_gsi>
ffffffff8100773b:	90                   	nop
ffffffff8100773c:	68 9d 00 00 00       	pushq  $0x9d
ffffffff81007741:	eb 10                	jmp    ffffffff81007753 <entry_gsi>
ffffffff81007743:	90                   	nop
ffffffff81007744:	68 9e 00 00 00       	pushq  $0x9e
ffffffff81007749:	eb 08                	jmp    ffffffff81007753 <entry_gsi>
ffffffff8100774b:	90                   	nop
ffffffff8100774c:	68 9f 00 00 00       	pushq  $0x9f
ffffffff81007751:	eb 00                	jmp    ffffffff81007753 <entry_gsi>

ffffffff81007753 <entry_gsi>:

entry_gsi:              push    $0
ffffffff81007753:	6a 00                	pushq  $0x0
                        SAVE_STATE
ffffffff81007755:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff81007759:	50                   	push   %rax
ffffffff8100775a:	51                   	push   %rcx
ffffffff8100775b:	52                   	push   %rdx
ffffffff8100775c:	53                   	push   %rbx
ffffffff8100775d:	54                   	push   %rsp
ffffffff8100775e:	55                   	push   %rbp
ffffffff8100775f:	56                   	push   %rsi
ffffffff81007760:	57                   	push   %rdi
ffffffff81007761:	41 50                	push   %r8
ffffffff81007763:	41 51                	push   %r9
ffffffff81007765:	41 52                	push   %r10
ffffffff81007767:	41 53                	push   %r11
ffffffff81007769:	41 54                	push   %r12
ffffffff8100776b:	41 55                	push   %r13
ffffffff8100776d:	41 56                	push   %r14
ffffffff8100776f:	41 57                	push   %r15
ffffffff81007771:	48 89 e3             	mov    %rsp,%rbx
ffffffff81007774:	48 81 fc 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rsp
ffffffff8100777b:	73 15                	jae    ffffffff81007792 <entry_gsi+0x3f>
ffffffff8100777d:	fc                   	cld    
ffffffff8100777e:	48 c7 c4 00 e0 ff bf 	mov    $0xffffffffbfffe000,%rsp
ffffffff81007785:	48 c7 c0 23 00 00 00 	mov    $0x23,%rax
ffffffff8100778c:	48 8e d8             	mov    %rax,%ds
ffffffff8100778f:	48 8e c0             	mov    %rax,%es
                        mov     OFS_VEC (%REG(bx)), %ARG_1
ffffffff81007792:	48 8b bb a8 00 00 00 	mov    0xa8(%rbx),%rdi
                        call    gsi_vector
ffffffff81007799:	e8 a0 06 00 00       	callq  ffffffff81007e3e <gsi_vector>
                        jmp     ret_from_interrupt
ffffffff8100779e:	e9 39 01 00 00       	jmpq   ffffffff810078dc <ret_from_interrupt>
ffffffff810077a3:	90                   	nop
.rept                   NUM_LVT
INTRGATE                0
                        push    $VEC
                        jmp     entry_lvt
.set                    VEC, VEC + 1
.endr
ffffffff810077a4:	68 a0 00 00 00       	pushq  $0xa0
ffffffff810077a9:	eb 28                	jmp    ffffffff810077d3 <entry_lvt>
ffffffff810077ab:	90                   	nop
ffffffff810077ac:	68 a1 00 00 00       	pushq  $0xa1
ffffffff810077b1:	eb 20                	jmp    ffffffff810077d3 <entry_lvt>
ffffffff810077b3:	90                   	nop
ffffffff810077b4:	68 a2 00 00 00       	pushq  $0xa2
ffffffff810077b9:	eb 18                	jmp    ffffffff810077d3 <entry_lvt>
ffffffff810077bb:	90                   	nop
ffffffff810077bc:	68 a3 00 00 00       	pushq  $0xa3
ffffffff810077c1:	eb 10                	jmp    ffffffff810077d3 <entry_lvt>
ffffffff810077c3:	90                   	nop
ffffffff810077c4:	68 a4 00 00 00       	pushq  $0xa4
ffffffff810077c9:	eb 08                	jmp    ffffffff810077d3 <entry_lvt>
ffffffff810077cb:	90                   	nop
ffffffff810077cc:	68 a5 00 00 00       	pushq  $0xa5
ffffffff810077d1:	eb 00                	jmp    ffffffff810077d3 <entry_lvt>

ffffffff810077d3 <entry_lvt>:

entry_lvt:              push    $0
ffffffff810077d3:	6a 00                	pushq  $0x0
                        SAVE_STATE
ffffffff810077d5:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff810077d9:	50                   	push   %rax
ffffffff810077da:	51                   	push   %rcx
ffffffff810077db:	52                   	push   %rdx
ffffffff810077dc:	53                   	push   %rbx
ffffffff810077dd:	54                   	push   %rsp
ffffffff810077de:	55                   	push   %rbp
ffffffff810077df:	56                   	push   %rsi
ffffffff810077e0:	57                   	push   %rdi
ffffffff810077e1:	41 50                	push   %r8
ffffffff810077e3:	41 51                	push   %r9
ffffffff810077e5:	41 52                	push   %r10
ffffffff810077e7:	41 53                	push   %r11
ffffffff810077e9:	41 54                	push   %r12
ffffffff810077eb:	41 55                	push   %r13
ffffffff810077ed:	41 56                	push   %r14
ffffffff810077ef:	41 57                	push   %r15
ffffffff810077f1:	48 89 e3             	mov    %rsp,%rbx
ffffffff810077f4:	48 81 fc 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rsp
ffffffff810077fb:	73 15                	jae    ffffffff81007812 <entry_lvt+0x3f>
ffffffff810077fd:	fc                   	cld    
ffffffff810077fe:	48 c7 c4 00 e0 ff bf 	mov    $0xffffffffbfffe000,%rsp
ffffffff81007805:	48 c7 c0 23 00 00 00 	mov    $0x23,%rax
ffffffff8100780c:	48 8e d8             	mov    %rax,%ds
ffffffff8100780f:	48 8e c0             	mov    %rax,%es
                        mov     OFS_VEC (%REG(bx)), %ARG_1
ffffffff81007812:	48 8b bb a8 00 00 00 	mov    0xa8(%rbx),%rdi
                        call    lvt_vector
ffffffff81007819:	e8 50 0e 00 00       	callq  ffffffff8100866e <lvt_vector>
                        jmp     ret_from_interrupt
ffffffff8100781e:	e9 b9 00 00 00       	jmpq   ffffffff810078dc <ret_from_interrupt>
ffffffff81007823:	90                   	nop
.rept                   NUM_MSI
INTRGATE                0
                        push    $VEC
                        jmp     entry_msi
.set                    VEC, VEC + 1
.endr
ffffffff81007824:	68 a6 00 00 00       	pushq  $0xa6
ffffffff81007829:	eb 00                	jmp    ffffffff8100782b <entry_msi>

ffffffff8100782b <entry_msi>:

entry_msi:              push    $0
ffffffff8100782b:	6a 00                	pushq  $0x0
                        SAVE_STATE
ffffffff8100782d:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff81007831:	50                   	push   %rax
ffffffff81007832:	51                   	push   %rcx
ffffffff81007833:	52                   	push   %rdx
ffffffff81007834:	53                   	push   %rbx
ffffffff81007835:	54                   	push   %rsp
ffffffff81007836:	55                   	push   %rbp
ffffffff81007837:	56                   	push   %rsi
ffffffff81007838:	57                   	push   %rdi
ffffffff81007839:	41 50                	push   %r8
ffffffff8100783b:	41 51                	push   %r9
ffffffff8100783d:	41 52                	push   %r10
ffffffff8100783f:	41 53                	push   %r11
ffffffff81007841:	41 54                	push   %r12
ffffffff81007843:	41 55                	push   %r13
ffffffff81007845:	41 56                	push   %r14
ffffffff81007847:	41 57                	push   %r15
ffffffff81007849:	48 89 e3             	mov    %rsp,%rbx
ffffffff8100784c:	48 81 fc 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rsp
ffffffff81007853:	73 15                	jae    ffffffff8100786a <entry_msi+0x3f>
ffffffff81007855:	fc                   	cld    
ffffffff81007856:	48 c7 c4 00 e0 ff bf 	mov    $0xffffffffbfffe000,%rsp
ffffffff8100785d:	48 c7 c0 23 00 00 00 	mov    $0x23,%rax
ffffffff81007864:	48 8e d8             	mov    %rax,%ds
ffffffff81007867:	48 8e c0             	mov    %rax,%es
                        mov     OFS_VEC (%REG(bx)), %ARG_1
ffffffff8100786a:	48 8b bb a8 00 00 00 	mov    0xa8(%rbx),%rdi
                        call    msi_vector
ffffffff81007871:	e8 7e bb ff ff       	callq  ffffffff810033f4 <msi_vector>
                        jmp     ret_from_interrupt
ffffffff81007876:	eb 64                	jmp    ffffffff810078dc <ret_from_interrupt>
.rept                   NUM_IPI
INTRGATE                0
                        push    $VEC
                        jmp     entry_ipi
.set                    VEC, VEC + 1
.endr
ffffffff81007878:	68 a7 00 00 00       	pushq  $0xa7
ffffffff8100787d:	eb 10                	jmp    ffffffff8100788f <entry_ipi>
ffffffff8100787f:	90                   	nop
ffffffff81007880:	68 a8 00 00 00       	pushq  $0xa8
ffffffff81007885:	eb 08                	jmp    ffffffff8100788f <entry_ipi>
ffffffff81007887:	90                   	nop
ffffffff81007888:	68 a9 00 00 00       	pushq  $0xa9
ffffffff8100788d:	eb 00                	jmp    ffffffff8100788f <entry_ipi>

ffffffff8100788f <entry_ipi>:

entry_ipi:              push    $0
ffffffff8100788f:	6a 00                	pushq  $0x0
                        SAVE_STATE
ffffffff81007891:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff81007895:	50                   	push   %rax
ffffffff81007896:	51                   	push   %rcx
ffffffff81007897:	52                   	push   %rdx
ffffffff81007898:	53                   	push   %rbx
ffffffff81007899:	54                   	push   %rsp
ffffffff8100789a:	55                   	push   %rbp
ffffffff8100789b:	56                   	push   %rsi
ffffffff8100789c:	57                   	push   %rdi
ffffffff8100789d:	41 50                	push   %r8
ffffffff8100789f:	41 51                	push   %r9
ffffffff810078a1:	41 52                	push   %r10
ffffffff810078a3:	41 53                	push   %r11
ffffffff810078a5:	41 54                	push   %r12
ffffffff810078a7:	41 55                	push   %r13
ffffffff810078a9:	41 56                	push   %r14
ffffffff810078ab:	41 57                	push   %r15
ffffffff810078ad:	48 89 e3             	mov    %rsp,%rbx
ffffffff810078b0:	48 81 fc 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rsp
ffffffff810078b7:	73 15                	jae    ffffffff810078ce <entry_ipi+0x3f>
ffffffff810078b9:	fc                   	cld    
ffffffff810078ba:	48 c7 c4 00 e0 ff bf 	mov    $0xffffffffbfffe000,%rsp
ffffffff810078c1:	48 c7 c0 23 00 00 00 	mov    $0x23,%rax
ffffffff810078c8:	48 8e d8             	mov    %rax,%ds
ffffffff810078cb:	48 8e c0             	mov    %rax,%es
                        mov     OFS_VEC (%REG(bx)), %ARG_1
ffffffff810078ce:	48 8b bb a8 00 00 00 	mov    0xa8(%rbx),%rdi
                        call    ipi_vector
ffffffff810078d5:	e8 3c 0e 00 00       	callq  ffffffff81008716 <ipi_vector>
                        jmp     ret_from_interrupt
ffffffff810078da:	eb 00                	jmp    ffffffff810078dc <ret_from_interrupt>

ffffffff810078dc <ret_from_interrupt>:

/*
 * Interrupt Return
 */
ret_from_interrupt:     testb   $3, OFS_CS (%REG(bx))
ffffffff810078dc:	f6 83 b8 00 00 00 03 	testb  $0x3,0xb8(%rbx)
                        jnz     ret_user_iret
ffffffff810078e3:	0f 85 a3 87 ff ff    	jne    ffffffff8100008c <ret_user_iret>
                        call    chk_kern_preempt
ffffffff810078e9:	e8 22 88 ff ff       	callq  ffffffff81000110 <chk_kern_preempt>
                        LOAD_GPR
ffffffff810078ee:	41 5f                	pop    %r15
ffffffff810078f0:	41 5e                	pop    %r14
ffffffff810078f2:	41 5d                	pop    %r13
ffffffff810078f4:	41 5c                	pop    %r12
ffffffff810078f6:	41 5b                	pop    %r11
ffffffff810078f8:	41 5a                	pop    %r10
ffffffff810078fa:	41 59                	pop    %r9
ffffffff810078fc:	41 58                	pop    %r8
ffffffff810078fe:	5f                   	pop    %rdi
ffffffff810078ff:	5e                   	pop    %rsi
ffffffff81007900:	5d                   	pop    %rbp
ffffffff81007901:	58                   	pop    %rax
ffffffff81007902:	5b                   	pop    %rbx
ffffffff81007903:	5a                   	pop    %rdx
ffffffff81007904:	59                   	pop    %rcx
ffffffff81007905:	58                   	pop    %rax
                        add     $(6 * SIZE), %REG(sp)
ffffffff81007906:	48 83 c4 30          	add    $0x30,%rsp
                        RET_USER_EXC
ffffffff8100790a:	48 cf                	iretq  

ffffffff8100790c <entry_sysenter>:
/*
 * System-Call Entry
 */
.align                  4, 0x90
.globl                  entry_sysenter
entry_sysenter:         LOAD_KSP
ffffffff8100790c:	49 89 e3             	mov    %rsp,%r11
ffffffff8100790f:	48 8b 24 25 cc fd ff 	mov    0xffffffffbffffdcc,%rsp
ffffffff81007916:	bf 
                        lea     -11*SIZE(%REG(sp)), %REG(sp)
ffffffff81007917:	48 8d 64 24 a8       	lea    -0x58(%rsp),%rsp
                        SAVE_GPR
ffffffff8100791c:	50                   	push   %rax
ffffffff8100791d:	51                   	push   %rcx
ffffffff8100791e:	52                   	push   %rdx
ffffffff8100791f:	53                   	push   %rbx
ffffffff81007920:	54                   	push   %rsp
ffffffff81007921:	55                   	push   %rbp
ffffffff81007922:	56                   	push   %rsi
ffffffff81007923:	57                   	push   %rdi
ffffffff81007924:	41 50                	push   %r8
ffffffff81007926:	41 51                	push   %r9
ffffffff81007928:	41 52                	push   %r10
ffffffff8100792a:	41 53                	push   %r11
ffffffff8100792c:	41 54                	push   %r12
ffffffff8100792e:	41 55                	push   %r13
ffffffff81007930:	41 56                	push   %r14
ffffffff81007932:	41 57                	push   %r15
                        mov     $(CPU_LOCAL_STCK + PAGE_SIZE), %REG(sp)
ffffffff81007934:	48 c7 c4 00 e0 ff bf 	mov    $0xffffffffbfffe000,%rsp
                        and     $0xf, %ARG_1
ffffffff8100793b:	48 83 e7 0f          	and    $0xf,%rdi
                        jmp     *syscall(,%ARG_1,SIZE)
ffffffff8100793f:	ff 24 fd 40 13 02 81 	jmpq   *-0x7efdecc0(,%rdi,8)
ffffffff81007946:	66 90                	xchg   %ax,%ax

ffffffff81007948 <entry_vmx>:
/*
 * VMX Entry
 */
.align                  4, 0x90
.globl                  entry_vmx
entry_vmx:              SAVE_GPR
ffffffff81007948:	50                   	push   %rax
ffffffff81007949:	51                   	push   %rcx
ffffffff8100794a:	52                   	push   %rdx
ffffffff8100794b:	53                   	push   %rbx
ffffffff8100794c:	54                   	push   %rsp
ffffffff8100794d:	55                   	push   %rbp
ffffffff8100794e:	56                   	push   %rsi
ffffffff8100794f:	57                   	push   %rdi
ffffffff81007950:	41 50                	push   %r8
ffffffff81007952:	41 51                	push   %r9
ffffffff81007954:	41 52                	push   %r10
ffffffff81007956:	41 53                	push   %r11
ffffffff81007958:	41 54                	push   %r12
ffffffff8100795a:	41 55                	push   %r13
ffffffff8100795c:	41 56                	push   %r14
ffffffff8100795e:	41 57                	push   %r15
                        mov     %cr2, %REG(ax)
ffffffff81007960:	0f 20 d0             	mov    %cr2,%rax
                        mov     %REG(ax), OFS_CR2 (%REG(sp))
ffffffff81007963:	48 89 44 24 58       	mov    %rax,0x58(%rsp)
                        mov     $(CPU_LOCAL_STCK + PAGE_SIZE), %REG(sp)
ffffffff81007968:	48 c7 c4 00 e0 ff bf 	mov    $0xffffffffbfffe000,%rsp
                        jmp     vmx_handler
ffffffff8100796f:	e9 b6 f7 ff ff       	jmpq   ffffffff8100712a <vmx_handler>

ffffffff81007974 <_GLOBAL__sub_I.00102__ZN3Fpu5cacheE>:
 */

#include "fpu.hpp"

INIT_PRIORITY (PRIO_SLAB)
Slab_cache Fpu::cache (sizeof (Fpu), 16);
ffffffff81007974:	ba 10 00 00 00       	mov    $0x10,%edx
ffffffff81007979:	be 00 02 00 00       	mov    $0x200,%esi
ffffffff8100797e:	48 c7 c7 d0 20 16 81 	mov    $0xffffffff811620d0,%rdi
ffffffff81007985:	e9 16 df 00 00       	jmpq   ffffffff810158a0 <_ZN10Slab_cacheC1Emj>

ffffffff8100798a <_ZN3Gdt5buildEv>:

#ifdef __i386__
    gdt[SEL_TSS_RUN >> 3].set32 (SYS_TSS, BYTES, BIT_16, false, 0, reinterpret_cast<mword>(&Tss::run), SPC_LOCAL_IOP_E - reinterpret_cast<mword>(&Tss::run));
    gdt[SEL_TSS_DBF >> 3].set32 (SYS_TSS, BYTES, BIT_16, false, 0, reinterpret_cast<mword>(&Tss::dbf), sizeof (Tss) - 1);
#else
    gdt[SEL_TSS_RUN >> 3].set64 (SYS_TSS, BYTES, BIT_16, false, 0, reinterpret_cast<mword>(&Tss::run), SPC_LOCAL_IOP_E - reinterpret_cast<mword>(&Tss::run));
ffffffff8100798a:	48 c7 c2 c8 fd ff bf 	mov    $0xffffffffbffffdc8,%rdx
ffffffff81007991:	48 c7 c0 00 20 00 c0 	mov    $0xffffffffc0002000,%rax
        uint32 val[2];

        ALWAYS_INLINE
        inline void set32 (Type type, Granularity gran, Size size, bool l, unsigned dpl, mword base, mword limit)
        {
            val[0] = static_cast<uint32>(base << 16 | (limit & 0xffff));
ffffffff81007998:	c7 05 2e 7e ff 3e ff 	movl   $0xffff,0x3eff7e2e(%rip)        # ffffffffbffff7d0 <_ZN3Gdt3gdtE+0x8>
ffffffff8100799f:	ff 00 00 
ffffffff810079a2:	48 29 d0             	sub    %rdx,%rax
ffffffff810079a5:	89 d1                	mov    %edx,%ecx
            val[1] = static_cast<uint32>((base & 0xff000000) | gran | size | (limit & 0xf0000) | l << 21 | 1u << 15 | dpl << 13 | type | (base >> 16 & 0xff));
ffffffff810079a7:	c7 05 23 7e ff 3e 00 	movl   $0xaf9b00,0x3eff7e23(%rip)        # ffffffffbffff7d4 <_ZN3Gdt3gdtE+0xc>
ffffffff810079ae:	9b af 00 
        uint32 val[2];

        ALWAYS_INLINE
        inline void set32 (Type type, Granularity gran, Size size, bool l, unsigned dpl, mword base, mword limit)
        {
            val[0] = static_cast<uint32>(base << 16 | (limit & 0xffff));
ffffffff810079b1:	0f b7 f0             	movzwl %ax,%esi
ffffffff810079b4:	c1 e1 10             	shl    $0x10,%ecx
            val[1] = static_cast<uint32>((base & 0xff000000) | gran | size | (limit & 0xf0000) | l << 21 | 1u << 15 | dpl << 13 | type | (base >> 16 & 0xff));
ffffffff810079b7:	25 00 00 0f 00       	and    $0xf0000,%eax
        uint32 val[2];

        ALWAYS_INLINE
        inline void set32 (Type type, Granularity gran, Size size, bool l, unsigned dpl, mword base, mword limit)
        {
            val[0] = static_cast<uint32>(base << 16 | (limit & 0xffff));
ffffffff810079bc:	09 f1                	or     %esi,%ecx
ffffffff810079be:	c7 05 10 7e ff 3e ff 	movl   $0xffff,0x3eff7e10(%rip)        # ffffffffbffff7d8 <_ZN3Gdt3gdtE+0x10>
ffffffff810079c5:	ff 00 00 
            val[1] = static_cast<uint32>((base & 0xff000000) | gran | size | (limit & 0xf0000) | l << 21 | 1u << 15 | dpl << 13 | type | (base >> 16 & 0xff));
ffffffff810079c8:	c7 05 0a 7e ff 3e 00 	movl   $0xaf9300,0x3eff7e0a(%rip)        # ffffffffbffff7dc <_ZN3Gdt3gdtE+0x14>
ffffffff810079cf:	93 af 00 
        uint32 val[2];

        ALWAYS_INLINE
        inline void set32 (Type type, Granularity gran, Size size, bool l, unsigned dpl, mword base, mword limit)
        {
            val[0] = static_cast<uint32>(base << 16 | (limit & 0xffff));
ffffffff810079d2:	89 0d 20 7e ff 3e    	mov    %ecx,0x3eff7e20(%rip)        # ffffffffbffff7f8 <_ZN3Gdt3gdtE+0x30>
            val[1] = static_cast<uint32>((base & 0xff000000) | gran | size | (limit & 0xf0000) | l << 21 | 1u << 15 | dpl << 13 | type | (base >> 16 & 0xff));
ffffffff810079d8:	89 d1                	mov    %edx,%ecx
        uint32 val[2];

        ALWAYS_INLINE
        inline void set32 (Type type, Granularity gran, Size size, bool l, unsigned dpl, mword base, mword limit)
        {
            val[0] = static_cast<uint32>(base << 16 | (limit & 0xffff));
ffffffff810079da:	c7 05 fc 7d ff 3e ff 	movl   $0xffff,0x3eff7dfc(%rip)        # ffffffffbffff7e0 <_ZN3Gdt3gdtE+0x18>
ffffffff810079e1:	ff 00 00 
            val[1] = static_cast<uint32>((base & 0xff000000) | gran | size | (limit & 0xf0000) | l << 21 | 1u << 15 | dpl << 13 | type | (base >> 16 & 0xff));
ffffffff810079e4:	81 e1 00 00 00 ff    	and    $0xff000000,%ecx
ffffffff810079ea:	c7 05 f0 7d ff 3e 00 	movl   $0xaffb00,0x3eff7df0(%rip)        # ffffffffbffff7e4 <_ZN3Gdt3gdtE+0x1c>
ffffffff810079f1:	fb af 00 
        uint32 val[2];

        ALWAYS_INLINE
        inline void set32 (Type type, Granularity gran, Size size, bool l, unsigned dpl, mword base, mword limit)
        {
            val[0] = static_cast<uint32>(base << 16 | (limit & 0xffff));
ffffffff810079f4:	c7 05 ea 7d ff 3e ff 	movl   $0xffff,0x3eff7dea(%rip)        # ffffffffbffff7e8 <_ZN3Gdt3gdtE+0x20>
ffffffff810079fb:	ff 00 00 
ffffffff810079fe:	80 cd 89             	or     $0x89,%ch
            val[1] = static_cast<uint32>((base & 0xff000000) | gran | size | (limit & 0xf0000) | l << 21 | 1u << 15 | dpl << 13 | type | (base >> 16 & 0xff));
ffffffff81007a01:	c7 05 e1 7d ff 3e 00 	movl   $0xaff300,0x3eff7de1(%rip)        # ffffffffbffff7ec <_ZN3Gdt3gdtE+0x24>
ffffffff81007a08:	f3 af 00 
        uint32 val[2];

        ALWAYS_INLINE
        inline void set32 (Type type, Granularity gran, Size size, bool l, unsigned dpl, mword base, mword limit)
        {
            val[0] = static_cast<uint32>(base << 16 | (limit & 0xffff));
ffffffff81007a0b:	c7 05 db 7d ff 3e ff 	movl   $0xffff,0x3eff7ddb(%rip)        # ffffffffbffff7f0 <_ZN3Gdt3gdtE+0x28>
ffffffff81007a12:	ff 00 00 
ffffffff81007a15:	09 c8                	or     %ecx,%eax
            val[1] = static_cast<uint32>((base & 0xff000000) | gran | size | (limit & 0xf0000) | l << 21 | 1u << 15 | dpl << 13 | type | (base >> 16 & 0xff));
ffffffff81007a17:	48 89 d1             	mov    %rdx,%rcx
#ifdef __x86_64__
        ALWAYS_INLINE
        inline void set64 (Type type, Granularity gran, Size size, bool l, unsigned dpl, mword base, mword limit)
        {
            set32 (type, gran, size, l, dpl, base, limit);
            (this + 1)->val[0] = static_cast<uint32>(base >> 32);
ffffffff81007a1a:	48 c1 ea 20          	shr    $0x20,%rdx

        ALWAYS_INLINE
        inline void set32 (Type type, Granularity gran, Size size, bool l, unsigned dpl, mword base, mword limit)
        {
            val[0] = static_cast<uint32>(base << 16 | (limit & 0xffff));
            val[1] = static_cast<uint32>((base & 0xff000000) | gran | size | (limit & 0xf0000) | l << 21 | 1u << 15 | dpl << 13 | type | (base >> 16 & 0xff));
ffffffff81007a1e:	48 c1 e9 10          	shr    $0x10,%rcx
#ifdef __x86_64__
        ALWAYS_INLINE
        inline void set64 (Type type, Granularity gran, Size size, bool l, unsigned dpl, mword base, mword limit)
        {
            set32 (type, gran, size, l, dpl, base, limit);
            (this + 1)->val[0] = static_cast<uint32>(base >> 32);
ffffffff81007a22:	89 15 d8 7d ff 3e    	mov    %edx,0x3eff7dd8(%rip)        # ffffffffbffff800 <_ZN3Gdt3gdtE+0x38>

        ALWAYS_INLINE
        inline void set32 (Type type, Granularity gran, Size size, bool l, unsigned dpl, mword base, mword limit)
        {
            val[0] = static_cast<uint32>(base << 16 | (limit & 0xffff));
            val[1] = static_cast<uint32>((base & 0xff000000) | gran | size | (limit & 0xf0000) | l << 21 | 1u << 15 | dpl << 13 | type | (base >> 16 & 0xff));
ffffffff81007a28:	c7 05 c2 7d ff 3e 00 	movl   $0xaffb00,0x3eff7dc2(%rip)        # ffffffffbffff7f4 <_ZN3Gdt3gdtE+0x2c>
ffffffff81007a2f:	fb af 00 
ffffffff81007a32:	0f b6 c9             	movzbl %cl,%ecx
        ALWAYS_INLINE
        inline void set64 (Type type, Granularity gran, Size size, bool l, unsigned dpl, mword base, mword limit)
        {
            set32 (type, gran, size, l, dpl, base, limit);
            (this + 1)->val[0] = static_cast<uint32>(base >> 32);
            (this + 1)->val[1] = 0;
ffffffff81007a35:	c7 05 c5 7d ff 3e 00 	movl   $0x0,0x3eff7dc5(%rip)        # ffffffffbffff804 <_ZN3Gdt3gdtE+0x3c>
ffffffff81007a3c:	00 00 00 
ffffffff81007a3f:	c7 05 cb 7d ff 3e 00 	movl   $0x0,0x3eff7dcb(%rip)        # ffffffffbffff814 <_ZN3Gdt3gdtE+0x4c>
ffffffff81007a46:	00 00 00 

        ALWAYS_INLINE
        inline void set32 (Type type, Granularity gran, Size size, bool l, unsigned dpl, mword base, mword limit)
        {
            val[0] = static_cast<uint32>(base << 16 | (limit & 0xffff));
            val[1] = static_cast<uint32>((base & 0xff000000) | gran | size | (limit & 0xf0000) | l << 21 | 1u << 15 | dpl << 13 | type | (base >> 16 & 0xff));
ffffffff81007a49:	09 c8                	or     %ecx,%eax
ffffffff81007a4b:	89 05 ab 7d ff 3e    	mov    %eax,0x3eff7dab(%rip)        # ffffffffbffff7fc <_ZN3Gdt3gdtE+0x34>
    gdt[SEL_TSS_DBF >> 3].set64 (SYS_TSS, BYTES, BIT_16, false, 0, reinterpret_cast<mword>(&Tss::dbf), sizeof (Tss) - 1);
ffffffff81007a51:	48 c7 c0 60 fd ff bf 	mov    $0xffffffffbffffd60,%rax
        uint32 val[2];

        ALWAYS_INLINE
        inline void set32 (Type type, Granularity gran, Size size, bool l, unsigned dpl, mword base, mword limit)
        {
            val[0] = static_cast<uint32>(base << 16 | (limit & 0xffff));
ffffffff81007a58:	89 c2                	mov    %eax,%edx
            val[1] = static_cast<uint32>((base & 0xff000000) | gran | size | (limit & 0xf0000) | l << 21 | 1u << 15 | dpl << 13 | type | (base >> 16 & 0xff));
ffffffff81007a5a:	48 89 c1             	mov    %rax,%rcx
        uint32 val[2];

        ALWAYS_INLINE
        inline void set32 (Type type, Granularity gran, Size size, bool l, unsigned dpl, mword base, mword limit)
        {
            val[0] = static_cast<uint32>(base << 16 | (limit & 0xffff));
ffffffff81007a5d:	c1 e2 10             	shl    $0x10,%edx
            val[1] = static_cast<uint32>((base & 0xff000000) | gran | size | (limit & 0xf0000) | l << 21 | 1u << 15 | dpl << 13 | type | (base >> 16 & 0xff));
ffffffff81007a60:	48 c1 e9 10          	shr    $0x10,%rcx
        uint32 val[2];

        ALWAYS_INLINE
        inline void set32 (Type type, Granularity gran, Size size, bool l, unsigned dpl, mword base, mword limit)
        {
            val[0] = static_cast<uint32>(base << 16 | (limit & 0xffff));
ffffffff81007a64:	83 ca 67             	or     $0x67,%edx
            val[1] = static_cast<uint32>((base & 0xff000000) | gran | size | (limit & 0xf0000) | l << 21 | 1u << 15 | dpl << 13 | type | (base >> 16 & 0xff));
ffffffff81007a67:	0f b6 c9             	movzbl %cl,%ecx
        uint32 val[2];

        ALWAYS_INLINE
        inline void set32 (Type type, Granularity gran, Size size, bool l, unsigned dpl, mword base, mword limit)
        {
            val[0] = static_cast<uint32>(base << 16 | (limit & 0xffff));
ffffffff81007a6a:	89 15 98 7d ff 3e    	mov    %edx,0x3eff7d98(%rip)        # ffffffffbffff808 <_ZN3Gdt3gdtE+0x40>
            val[1] = static_cast<uint32>((base & 0xff000000) | gran | size | (limit & 0xf0000) | l << 21 | 1u << 15 | dpl << 13 | type | (base >> 16 & 0xff));
ffffffff81007a70:	89 c2                	mov    %eax,%edx
#ifdef __x86_64__
        ALWAYS_INLINE
        inline void set64 (Type type, Granularity gran, Size size, bool l, unsigned dpl, mword base, mword limit)
        {
            set32 (type, gran, size, l, dpl, base, limit);
            (this + 1)->val[0] = static_cast<uint32>(base >> 32);
ffffffff81007a72:	48 c1 e8 20          	shr    $0x20,%rax

        ALWAYS_INLINE
        inline void set32 (Type type, Granularity gran, Size size, bool l, unsigned dpl, mword base, mword limit)
        {
            val[0] = static_cast<uint32>(base << 16 | (limit & 0xffff));
            val[1] = static_cast<uint32>((base & 0xff000000) | gran | size | (limit & 0xf0000) | l << 21 | 1u << 15 | dpl << 13 | type | (base >> 16 & 0xff));
ffffffff81007a76:	81 e2 00 00 00 ff    	and    $0xff000000,%edx
#ifdef __x86_64__
        ALWAYS_INLINE
        inline void set64 (Type type, Granularity gran, Size size, bool l, unsigned dpl, mword base, mword limit)
        {
            set32 (type, gran, size, l, dpl, base, limit);
            (this + 1)->val[0] = static_cast<uint32>(base >> 32);
ffffffff81007a7c:	89 05 8e 7d ff 3e    	mov    %eax,0x3eff7d8e(%rip)        # ffffffffbffff810 <_ZN3Gdt3gdtE+0x48>
ffffffff81007a82:	80 ce 89             	or     $0x89,%dh

        ALWAYS_INLINE
        inline void set32 (Type type, Granularity gran, Size size, bool l, unsigned dpl, mword base, mword limit)
        {
            val[0] = static_cast<uint32>(base << 16 | (limit & 0xffff));
            val[1] = static_cast<uint32>((base & 0xff000000) | gran | size | (limit & 0xf0000) | l << 21 | 1u << 15 | dpl << 13 | type | (base >> 16 & 0xff));
ffffffff81007a85:	09 ca                	or     %ecx,%edx
ffffffff81007a87:	89 15 7f 7d ff 3e    	mov    %edx,0x3eff7d7f(%rip)        # ffffffffbffff80c <_ZN3Gdt3gdtE+0x44>
        ALWAYS_INLINE
        inline void set64 (Type type, Granularity gran, Size size, bool l, unsigned dpl, mword base, mword limit)
        {
            set32 (type, gran, size, l, dpl, base, limit);
            (this + 1)->val[0] = static_cast<uint32>(base >> 32);
            (this + 1)->val[1] = 0;
ffffffff81007a8d:	c3                   	retq   

ffffffff81007a8e <_ZN3Gsi3setEjjj>:

uint64 Gsi::set (unsigned gsi, unsigned cpu, unsigned rid)
{
ffffffff81007a8e:	41 57                	push   %r15
ffffffff81007a90:	41 56                	push   %r14
    uint32 msi_addr = 0, msi_data = 0, aid = Cpu::apic_id[cpu];
ffffffff81007a92:	89 f6                	mov    %esi,%esi
        }
    }
}

uint64 Gsi::set (unsigned gsi, unsigned cpu, unsigned rid)
{
ffffffff81007a94:	41 55                	push   %r13
ffffffff81007a96:	41 54                	push   %r12
ffffffff81007a98:	55                   	push   %rbp
ffffffff81007a99:	89 fd                	mov    %edi,%ebp
ffffffff81007a9b:	53                   	push   %rbx
    uint32 msi_addr = 0, msi_data = 0, aid = Cpu::apic_id[cpu];

    Ioapic *ioapic = gsi_table[gsi].ioapic;
ffffffff81007a9c:	48 6b fd 18          	imul   $0x18,%rbp,%rdi
        }
    }
}

uint64 Gsi::set (unsigned gsi, unsigned cpu, unsigned rid)
{
ffffffff81007aa0:	48 89 eb             	mov    %rbp,%rbx
ffffffff81007aa3:	48 83 ec 18          	sub    $0x18,%rsp
    uint32 msi_addr = 0, msi_data = 0, aid = Cpu::apic_id[cpu];
ffffffff81007aa7:	0f b6 8e c0 1f 16 81 	movzbl -0x7ee9e040(%rsi),%ecx
ffffffff81007aae:	44 8b 05 c3 9b 01 00 	mov    0x19bc3(%rip),%r8d        # ffffffff81021678 <CTORS_E>

    Ioapic *ioapic = gsi_table[gsi].ioapic;
ffffffff81007ab5:	48 81 c7 40 21 16 81 	add    $0xffffffff81162140,%rdi
ffffffff81007abc:	4c 8b 6f 08          	mov    0x8(%rdi),%r13
    }
}

uint64 Gsi::set (unsigned gsi, unsigned cpu, unsigned rid)
{
    uint32 msi_addr = 0, msi_data = 0, aid = Cpu::apic_id[cpu];
ffffffff81007ac0:	49 89 cc             	mov    %rcx,%r12

    Ioapic *ioapic = gsi_table[gsi].ioapic;

    if (ioapic) {
ffffffff81007ac3:	4d 85 ed             	test   %r13,%r13
ffffffff81007ac6:	0f 84 57 01 00 00    	je     ffffffff81007c23 <_ZN3Gsi3setEjjj+0x195>
        ioapic->set_cpu (gsi, Dmar::ire() ? 0 : aid);
ffffffff81007acc:	41 81 e0 00 00 00 02 	and    $0x2000000,%r8d
ffffffff81007ad3:	41 be 00 00 00 00    	mov    $0x0,%r14d
ffffffff81007ad9:	89 e8                	mov    %ebp,%eax
ffffffff81007adb:	41 0f 45 ce          	cmovne %r14d,%ecx

        ALWAYS_INLINE
        inline void set_cpu (unsigned gsi, unsigned cpu)
        {
            unsigned pin = gsi - gsi_base;
            write (Register (IOAPIC_IRT + 2 * pin + 1), cpu << 24 | gsi << 17 | 1ul << 16);
ffffffff81007adf:	41 89 ee             	mov    %ebp,%r14d
ffffffff81007ae2:	41 2b 45 10          	sub    0x10(%r13),%eax
ffffffff81007ae6:	41 c1 e6 11          	shl    $0x11,%r14d
ffffffff81007aea:	c1 e1 18             	shl    $0x18,%ecx
        }

        ALWAYS_INLINE
        inline void write (Register reg, uint32 val)
        {
            Lock_guard <Spinlock> guard (lock);
ffffffff81007aed:	49 8d 55 1a          	lea    0x1a(%r13),%rdx
ffffffff81007af1:	41 81 ce 00 00 01 00 	or     $0x10000,%r14d

        ALWAYS_INLINE
        inline void set_cpu (unsigned gsi, unsigned cpu)
        {
            unsigned pin = gsi - gsi_base;
            write (Register (IOAPIC_IRT + 2 * pin + 1), cpu << 24 | gsi << 17 | 1ul << 16);
ffffffff81007af8:	41 09 ce             	or     %ecx,%r14d
ffffffff81007afb:	44 89 74 24 04       	mov    %r14d,0x4(%rsp)
ffffffff81007b00:	44 8d 74 00 11       	lea    0x11(%rax,%rax,1),%r14d

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81007b05:	9c                   	pushfq 
ffffffff81007b06:	58                   	pop    %rax
            return flags & 0x200;
ffffffff81007b07:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff81007b0b:	41 88 c7             	mov    %al,%r15b
ffffffff81007b0e:	41 80 e7 01          	and    $0x1,%r15b
ffffffff81007b12:	74 2d                	je     ffffffff81007b41 <_ZN3Gsi3setEjjj+0xb3>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81007b14:	80 3d 15 7c ff 3e 00 	cmpb   $0x0,0x3eff7c15(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81007b1b:	75 1c                	jne    ffffffff81007b39 <_ZN3Gsi3setEjjj+0xab>
ffffffff81007b1d:	49 c7 c0 60 e4 01 81 	mov    $0xffffffff8101e460,%r8
ffffffff81007b24:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff81007b29:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81007b30:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff81007b37:	eb 58                	jmp    ffffffff81007b91 <_ZN3Gsi3setEjjj+0x103>

            asm volatile ("cli" : : : "memory");
ffffffff81007b39:	fa                   	cli    
            preemption = false;
ffffffff81007b3a:	c6 05 ef 7b ff 3e 00 	movb   $0x0,0x3eff7bef(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff81007b41:	48 89 d7             	mov    %rdx,%rdi
ffffffff81007b44:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
ffffffff81007b49:	e8 40 93 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
        };

        ALWAYS_INLINE
        inline void index (Register reg)
        {
            *reinterpret_cast<uint8 volatile *>(reg_base + IOAPIC_IDX) = reg;
ffffffff81007b4e:	49 8b 45 08          	mov    0x8(%r13),%rax
        ALWAYS_INLINE
        inline void write (Register reg, uint32 val)
        {
            Lock_guard <Spinlock> guard (lock);
            index (reg);
            *reinterpret_cast<uint32 volatile *>(reg_base + IOAPIC_WND) = val;
ffffffff81007b52:	8b 7c 24 04          	mov    0x4(%rsp),%edi
        };

        ALWAYS_INLINE
        inline void index (Register reg)
        {
            *reinterpret_cast<uint8 volatile *>(reg_base + IOAPIC_IDX) = reg;
ffffffff81007b56:	44 88 30             	mov    %r14b,(%rax)
        ALWAYS_INLINE
        inline void write (Register reg, uint32 val)
        {
            Lock_guard <Spinlock> guard (lock);
            index (reg);
            *reinterpret_cast<uint32 volatile *>(reg_base + IOAPIC_WND) = val;
ffffffff81007b59:	49 8b 45 08          	mov    0x8(%r13),%rax
ffffffff81007b5d:	89 78 10             	mov    %edi,0x10(%rax)
ffffffff81007b60:	41 fe 45 1a          	incb   0x1a(%r13)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81007b64:	45 84 ff             	test   %r15b,%r15b
ffffffff81007b67:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
ffffffff81007b6c:	74 39                	je     ffffffff81007ba7 <_ZN3Gsi3setEjjj+0x119>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81007b6e:	80 3d bb 7b ff 3e 00 	cmpb   $0x0,0x3eff7bbb(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81007b75:	74 28                	je     ffffffff81007b9f <_ZN3Gsi3setEjjj+0x111>
ffffffff81007b77:	49 c7 c0 30 e4 01 81 	mov    $0xffffffff8101e430,%r8
ffffffff81007b7e:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff81007b83:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81007b8a:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff81007b91:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81007b98:	31 c0                	xor    %eax,%eax
ffffffff81007b9a:	e8 b1 a3 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            preemption = true;
ffffffff81007b9f:	c6 05 8a 7b ff 3e 01 	movb   $0x1,0x3eff7b8a(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81007ba6:	fb                   	sti    
        ioapic->set_irt (gsi, gsi_table[gsi].irt);
ffffffff81007ba7:	48 6b c5 18          	imul   $0x18,%rbp,%rax
ffffffff81007bab:	44 0f b7 b8 50 21 16 	movzwl -0x7ee9deb0(%rax),%r15d
ffffffff81007bb2:	81 
ffffffff81007bb3:	89 d8                	mov    %ebx,%eax
ffffffff81007bb5:	41 2b 45 10          	sub    0x10(%r13),%eax

        ALWAYS_INLINE
        inline void set_irt (unsigned gsi, unsigned val)
        {
            unsigned pin = gsi - gsi_base;
            write (Register (IOAPIC_IRT + 2 * pin), val);
ffffffff81007bb9:	44 8d 74 00 10       	lea    0x10(%rax,%rax,1),%r14d

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81007bbe:	9c                   	pushfq 
ffffffff81007bbf:	58                   	pop    %rax
            return flags & 0x200;
ffffffff81007bc0:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff81007bc4:	24 01                	and    $0x1,%al
ffffffff81007bc6:	88 44 24 04          	mov    %al,0x4(%rsp)
ffffffff81007bca:	74 15                	je     ffffffff81007be1 <_ZN3Gsi3setEjjj+0x153>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81007bcc:	80 3d 5d 7b ff 3e 00 	cmpb   $0x0,0x3eff7b5d(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81007bd3:	0f 84 44 ff ff ff    	je     ffffffff81007b1d <_ZN3Gsi3setEjjj+0x8f>

            asm volatile ("cli" : : : "memory");
ffffffff81007bd9:	fa                   	cli    
            preemption = false;
ffffffff81007bda:	c6 05 4f 7b ff 3e 00 	movb   $0x0,0x3eff7b4f(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff81007be1:	48 89 d7             	mov    %rdx,%rdi
ffffffff81007be4:	e8 a5 92 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
        };

        ALWAYS_INLINE
        inline void index (Register reg)
        {
            *reinterpret_cast<uint8 volatile *>(reg_base + IOAPIC_IDX) = reg;
ffffffff81007be9:	49 8b 45 08          	mov    0x8(%r13),%rax
ffffffff81007bed:	44 88 30             	mov    %r14b,(%rax)
        ALWAYS_INLINE
        inline void write (Register reg, uint32 val)
        {
            Lock_guard <Spinlock> guard (lock);
            index (reg);
            *reinterpret_cast<uint32 volatile *>(reg_base + IOAPIC_WND) = val;
ffffffff81007bf0:	49 8b 45 08          	mov    0x8(%r13),%rax
ffffffff81007bf4:	44 89 78 10          	mov    %r15d,0x10(%rax)
ffffffff81007bf8:	41 fe 45 1a          	incb   0x1a(%r13)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81007bfc:	80 7c 24 04 00       	cmpb   $0x0,0x4(%rsp)
ffffffff81007c01:	74 15                	je     ffffffff81007c18 <_ZN3Gsi3setEjjj+0x18a>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81007c03:	80 3d 26 7b ff 3e 00 	cmpb   $0x0,0x3eff7b26(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81007c0a:	0f 85 67 ff ff ff    	jne    ffffffff81007b77 <_ZN3Gsi3setEjjj+0xe9>

            preemption = true;
ffffffff81007c10:	c6 05 19 7b ff 3e 01 	movb   $0x1,0x3eff7b19(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81007c17:	fb                   	sti    
        rid = ioapic->get_rid();
ffffffff81007c18:	41 0f b7 55 18       	movzwl 0x18(%r13),%edx
    }
}

uint64 Gsi::set (unsigned gsi, unsigned cpu, unsigned rid)
{
    uint32 msi_addr = 0, msi_data = 0, aid = Cpu::apic_id[cpu];
ffffffff81007c1d:	31 f6                	xor    %esi,%esi
ffffffff81007c1f:	31 c0                	xor    %eax,%eax
ffffffff81007c21:	eb 1e                	jmp    ffffffff81007c41 <_ZN3Gsi3setEjjj+0x1b3>
    if (ioapic) {
        ioapic->set_cpu (gsi, Dmar::ire() ? 0 : aid);
        ioapic->set_irt (gsi, gsi_table[gsi].irt);
        rid = ioapic->get_rid();
    } else {
        msi_addr = 0xfee00000 | (Dmar::ire() ? 3U << 3 : aid << 12);
ffffffff81007c23:	41 81 e0 00 00 00 02 	and    $0x2000000,%r8d
        msi_data = Dmar::ire() ? gsi : gsi_table[gsi].vec;
ffffffff81007c2a:	89 ee                	mov    %ebp,%esi
    if (ioapic) {
        ioapic->set_cpu (gsi, Dmar::ire() ? 0 : aid);
        ioapic->set_irt (gsi, gsi_table[gsi].irt);
        rid = ioapic->get_rid();
    } else {
        msi_addr = 0xfee00000 | (Dmar::ire() ? 3U << 3 : aid << 12);
ffffffff81007c2c:	b8 18 00 e0 fe       	mov    $0xfee00018,%eax
ffffffff81007c31:	75 0e                	jne    ffffffff81007c41 <_ZN3Gsi3setEjjj+0x1b3>
        msi_data = Dmar::ire() ? gsi : gsi_table[gsi].vec;
ffffffff81007c33:	0f b6 77 10          	movzbl 0x10(%rdi),%esi
    if (ioapic) {
        ioapic->set_cpu (gsi, Dmar::ire() ? 0 : aid);
        ioapic->set_irt (gsi, gsi_table[gsi].irt);
        rid = ioapic->get_rid();
    } else {
        msi_addr = 0xfee00000 | (Dmar::ire() ? 3U << 3 : aid << 12);
ffffffff81007c37:	89 c8                	mov    %ecx,%eax
ffffffff81007c39:	c1 e0 0c             	shl    $0xc,%eax
ffffffff81007c3c:	0d 00 00 e0 fe       	or     $0xfee00000,%eax
        msi_data = Dmar::ire() ? gsi : gsi_table[gsi].vec;
    }

    Dmar::set_irt (gsi, rid, aid, VEC_GSI + gsi, gsi_table[gsi].trg);
ffffffff81007c41:	48 6b cd 18          	imul   $0x18,%rbp,%rcx
ffffffff81007c45:	83 c3 20             	add    $0x20,%ebx
        }

        ALWAYS_INLINE
        static inline void set_irt (unsigned i, unsigned rid, unsigned cpu, unsigned vec, unsigned trg)
        {
            irt[i].set (1ULL << 18 | rid, static_cast<uint64>(cpu) << 40 | vec << 16 | trg << 4 | 1);
ffffffff81007c48:	48 c1 e5 04          	shl    $0x4,%rbp
ffffffff81007c4c:	48 03 2d fd a3 15 00 	add    0x15a3fd(%rip),%rbp        # ffffffff81162050 <_ZN4Dmar3irtE>
ffffffff81007c53:	c1 e3 10             	shl    $0x10,%ebx
ffffffff81007c56:	49 c1 e4 28          	shl    $0x28,%r12
ffffffff81007c5a:	81 ca 00 00 04 00    	or     $0x40000,%edx
ffffffff81007c60:	89 d7                	mov    %edx,%edi
ffffffff81007c62:	8a 89 51 21 16 81    	mov    -0x7ee9deaf(%rcx),%cl
ffffffff81007c68:	48 89 7d 08          	mov    %rdi,0x8(%rbp)
ffffffff81007c6c:	c0 e9 07             	shr    $0x7,%cl
ffffffff81007c6f:	0f b6 c9             	movzbl %cl,%ecx
ffffffff81007c72:	c1 e1 04             	shl    $0x4,%ecx
ffffffff81007c75:	83 c9 01             	or     $0x1,%ecx
ffffffff81007c78:	09 cb                	or     %ecx,%ebx
ffffffff81007c7a:	4c 09 e3             	or     %r12,%rbx
    private:
        uint64 lo, hi;

    public:
        ALWAYS_INLINE
        inline void set (uint64 h, uint64 l) { hi = h; lo = l; flush (this); }
ffffffff81007c7d:	48 89 5d 00          	mov    %rbx,0x0(%rbp)

template <typename T>
ALWAYS_INLINE
static inline void flush (T t)
{
    asm volatile ("clflush %0" : : "m" (*t) : "memory");
ffffffff81007c81:	0f ae 7d 00          	clflush 0x0(%rbp)

    return static_cast<uint64>(msi_addr) << 32 | msi_data;
}
ffffffff81007c85:	48 83 c4 18          	add    $0x18,%rsp
        msi_data = Dmar::ire() ? gsi : gsi_table[gsi].vec;
    }

    Dmar::set_irt (gsi, rid, aid, VEC_GSI + gsi, gsi_table[gsi].trg);

    return static_cast<uint64>(msi_addr) << 32 | msi_data;
ffffffff81007c89:	48 c1 e0 20          	shl    $0x20,%rax
}
ffffffff81007c8d:	5b                   	pop    %rbx
        msi_data = Dmar::ire() ? gsi : gsi_table[gsi].vec;
    }

    Dmar::set_irt (gsi, rid, aid, VEC_GSI + gsi, gsi_table[gsi].trg);

    return static_cast<uint64>(msi_addr) << 32 | msi_data;
ffffffff81007c8e:	48 09 f0             	or     %rsi,%rax
}
ffffffff81007c91:	5d                   	pop    %rbp
ffffffff81007c92:	41 5c                	pop    %r12
ffffffff81007c94:	41 5d                	pop    %r13
ffffffff81007c96:	41 5e                	pop    %r14
ffffffff81007c98:	41 5f                	pop    %r15
ffffffff81007c9a:	c3                   	retq   
ffffffff81007c9b:	90                   	nop

ffffffff81007c9c <_ZN3Gsi4maskEj>:

void Gsi::mask (unsigned gsi)
{
    Ioapic *ioapic = gsi_table[gsi].ioapic;
ffffffff81007c9c:	89 f8                	mov    %edi,%eax

    return static_cast<uint64>(msi_addr) << 32 | msi_data;
}

void Gsi::mask (unsigned gsi)
{
ffffffff81007c9e:	41 55                	push   %r13
ffffffff81007ca0:	41 54                	push   %r12
    Ioapic *ioapic = gsi_table[gsi].ioapic;
ffffffff81007ca2:	48 6b c0 18          	imul   $0x18,%rax,%rax

    return static_cast<uint64>(msi_addr) << 32 | msi_data;
}

void Gsi::mask (unsigned gsi)
{
ffffffff81007ca6:	55                   	push   %rbp
ffffffff81007ca7:	53                   	push   %rbx
ffffffff81007ca8:	52                   	push   %rdx
    Ioapic *ioapic = gsi_table[gsi].ioapic;
ffffffff81007ca9:	48 8b 98 48 21 16 81 	mov    -0x7ee9deb8(%rax),%rbx
ffffffff81007cb0:	48 05 40 21 16 81    	add    $0xffffffff81162140,%rax

    if (ioapic)
ffffffff81007cb6:	48 85 db             	test   %rbx,%rbx
ffffffff81007cb9:	0f 84 a9 00 00 00    	je     ffffffff81007d68 <_ZN3Gsi4maskEj+0xcc>
ffffffff81007cbf:	2b 7b 10             	sub    0x10(%rbx),%edi
        ioapic->set_irt (gsi, 1U << 16 | gsi_table[gsi].irt);
ffffffff81007cc2:	44 0f b7 60 10       	movzwl 0x10(%rax),%r12d

        ALWAYS_INLINE
        inline void set_irt (unsigned gsi, unsigned val)
        {
            unsigned pin = gsi - gsi_base;
            write (Register (IOAPIC_IRT + 2 * pin), val);
ffffffff81007cc7:	44 8d 6c 3f 10       	lea    0x10(%rdi,%rdi,1),%r13d
ffffffff81007ccc:	41 81 cc 00 00 01 00 	or     $0x10000,%r12d
        }

        ALWAYS_INLINE
        inline void write (Register reg, uint32 val)
        {
            Lock_guard <Spinlock> guard (lock);
ffffffff81007cd3:	48 8d 7b 1a          	lea    0x1a(%rbx),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81007cd7:	9c                   	pushfq 
ffffffff81007cd8:	58                   	pop    %rax
            return flags & 0x200;
ffffffff81007cd9:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff81007cdd:	40 88 c5             	mov    %al,%bpl
ffffffff81007ce0:	40 80 e5 01          	and    $0x1,%bpl
ffffffff81007ce4:	74 2d                	je     ffffffff81007d13 <_ZN3Gsi4maskEj+0x77>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81007ce6:	80 3d 43 7a ff 3e 00 	cmpb   $0x0,0x3eff7a43(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81007ced:	75 1c                	jne    ffffffff81007d0b <_ZN3Gsi4maskEj+0x6f>
ffffffff81007cef:	49 c7 c0 60 e4 01 81 	mov    $0xffffffff8101e460,%r8
ffffffff81007cf6:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff81007cfb:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81007d02:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff81007d09:	eb 47                	jmp    ffffffff81007d52 <_ZN3Gsi4maskEj+0xb6>

            asm volatile ("cli" : : : "memory");
ffffffff81007d0b:	fa                   	cli    
            preemption = false;
ffffffff81007d0c:	c6 05 1d 7a ff 3e 00 	movb   $0x0,0x3eff7a1d(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff81007d13:	e8 76 91 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
        };

        ALWAYS_INLINE
        inline void index (Register reg)
        {
            *reinterpret_cast<uint8 volatile *>(reg_base + IOAPIC_IDX) = reg;
ffffffff81007d18:	48 8b 43 08          	mov    0x8(%rbx),%rax
ffffffff81007d1c:	44 88 28             	mov    %r13b,(%rax)
        ALWAYS_INLINE
        inline void write (Register reg, uint32 val)
        {
            Lock_guard <Spinlock> guard (lock);
            index (reg);
            *reinterpret_cast<uint32 volatile *>(reg_base + IOAPIC_WND) = val;
ffffffff81007d1f:	48 8b 43 08          	mov    0x8(%rbx),%rax
ffffffff81007d23:	44 89 60 10          	mov    %r12d,0x10(%rax)
ffffffff81007d27:	fe 43 1a             	incb   0x1a(%rbx)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81007d2a:	40 84 ed             	test   %bpl,%bpl
ffffffff81007d2d:	74 39                	je     ffffffff81007d68 <_ZN3Gsi4maskEj+0xcc>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81007d2f:	80 3d fa 79 ff 3e 00 	cmpb   $0x0,0x3eff79fa(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81007d36:	74 28                	je     ffffffff81007d60 <_ZN3Gsi4maskEj+0xc4>
ffffffff81007d38:	49 c7 c0 30 e4 01 81 	mov    $0xffffffff8101e430,%r8
ffffffff81007d3f:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff81007d44:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81007d4b:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff81007d52:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81007d59:	31 c0                	xor    %eax,%eax
ffffffff81007d5b:	e8 f0 a1 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            preemption = true;
ffffffff81007d60:	c6 05 c9 79 ff 3e 01 	movb   $0x1,0x3eff79c9(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81007d67:	fb                   	sti    
}
ffffffff81007d68:	58                   	pop    %rax
ffffffff81007d69:	5b                   	pop    %rbx
ffffffff81007d6a:	5d                   	pop    %rbp
ffffffff81007d6b:	41 5c                	pop    %r12
ffffffff81007d6d:	41 5d                	pop    %r13
ffffffff81007d6f:	c3                   	retq   

ffffffff81007d70 <_ZN3Gsi6unmaskEj>:

void Gsi::unmask (unsigned gsi)
{
    Ioapic *ioapic = gsi_table[gsi].ioapic;
ffffffff81007d70:	89 f8                	mov    %edi,%eax
    if (ioapic)
        ioapic->set_irt (gsi, 1U << 16 | gsi_table[gsi].irt);
}

void Gsi::unmask (unsigned gsi)
{
ffffffff81007d72:	41 55                	push   %r13
ffffffff81007d74:	41 54                	push   %r12
    Ioapic *ioapic = gsi_table[gsi].ioapic;
ffffffff81007d76:	48 6b c0 18          	imul   $0x18,%rax,%rax
    if (ioapic)
        ioapic->set_irt (gsi, 1U << 16 | gsi_table[gsi].irt);
}

void Gsi::unmask (unsigned gsi)
{
ffffffff81007d7a:	55                   	push   %rbp
ffffffff81007d7b:	53                   	push   %rbx
ffffffff81007d7c:	52                   	push   %rdx
    Ioapic *ioapic = gsi_table[gsi].ioapic;
ffffffff81007d7d:	48 8b 98 48 21 16 81 	mov    -0x7ee9deb8(%rax),%rbx
ffffffff81007d84:	48 05 40 21 16 81    	add    $0xffffffff81162140,%rax

    if (ioapic)
ffffffff81007d8a:	48 85 db             	test   %rbx,%rbx
ffffffff81007d8d:	0f 84 a2 00 00 00    	je     ffffffff81007e35 <_ZN3Gsi6unmaskEj+0xc5>
ffffffff81007d93:	2b 7b 10             	sub    0x10(%rbx),%edi
        ioapic->set_irt (gsi, 0U << 16 | gsi_table[gsi].irt);
ffffffff81007d96:	44 0f b7 60 10       	movzwl 0x10(%rax),%r12d

        ALWAYS_INLINE
        inline void set_irt (unsigned gsi, unsigned val)
        {
            unsigned pin = gsi - gsi_base;
            write (Register (IOAPIC_IRT + 2 * pin), val);
ffffffff81007d9b:	44 8d 6c 3f 10       	lea    0x10(%rdi,%rdi,1),%r13d
        }

        ALWAYS_INLINE
        inline void write (Register reg, uint32 val)
        {
            Lock_guard <Spinlock> guard (lock);
ffffffff81007da0:	48 8d 7b 1a          	lea    0x1a(%rbx),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81007da4:	9c                   	pushfq 
ffffffff81007da5:	58                   	pop    %rax
            return flags & 0x200;
ffffffff81007da6:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff81007daa:	40 88 c5             	mov    %al,%bpl
ffffffff81007dad:	40 80 e5 01          	and    $0x1,%bpl
ffffffff81007db1:	74 2d                	je     ffffffff81007de0 <_ZN3Gsi6unmaskEj+0x70>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81007db3:	80 3d 76 79 ff 3e 00 	cmpb   $0x0,0x3eff7976(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81007dba:	75 1c                	jne    ffffffff81007dd8 <_ZN3Gsi6unmaskEj+0x68>
ffffffff81007dbc:	49 c7 c0 60 e4 01 81 	mov    $0xffffffff8101e460,%r8
ffffffff81007dc3:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff81007dc8:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81007dcf:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff81007dd6:	eb 47                	jmp    ffffffff81007e1f <_ZN3Gsi6unmaskEj+0xaf>

            asm volatile ("cli" : : : "memory");
ffffffff81007dd8:	fa                   	cli    
            preemption = false;
ffffffff81007dd9:	c6 05 50 79 ff 3e 00 	movb   $0x0,0x3eff7950(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff81007de0:	e8 a9 90 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
        };

        ALWAYS_INLINE
        inline void index (Register reg)
        {
            *reinterpret_cast<uint8 volatile *>(reg_base + IOAPIC_IDX) = reg;
ffffffff81007de5:	48 8b 43 08          	mov    0x8(%rbx),%rax
ffffffff81007de9:	44 88 28             	mov    %r13b,(%rax)
        ALWAYS_INLINE
        inline void write (Register reg, uint32 val)
        {
            Lock_guard <Spinlock> guard (lock);
            index (reg);
            *reinterpret_cast<uint32 volatile *>(reg_base + IOAPIC_WND) = val;
ffffffff81007dec:	48 8b 43 08          	mov    0x8(%rbx),%rax
ffffffff81007df0:	44 89 60 10          	mov    %r12d,0x10(%rax)
ffffffff81007df4:	fe 43 1a             	incb   0x1a(%rbx)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81007df7:	40 84 ed             	test   %bpl,%bpl
ffffffff81007dfa:	74 39                	je     ffffffff81007e35 <_ZN3Gsi6unmaskEj+0xc5>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81007dfc:	80 3d 2d 79 ff 3e 00 	cmpb   $0x0,0x3eff792d(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81007e03:	74 28                	je     ffffffff81007e2d <_ZN3Gsi6unmaskEj+0xbd>
ffffffff81007e05:	49 c7 c0 30 e4 01 81 	mov    $0xffffffff8101e430,%r8
ffffffff81007e0c:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff81007e11:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81007e18:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff81007e1f:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81007e26:	31 c0                	xor    %eax,%eax
ffffffff81007e28:	e8 23 a1 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            preemption = true;
ffffffff81007e2d:	c6 05 fc 78 ff 3e 01 	movb   $0x1,0x3eff78fc(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81007e34:	fb                   	sti    
}
ffffffff81007e35:	58                   	pop    %rax
ffffffff81007e36:	5b                   	pop    %rbx
ffffffff81007e37:	5d                   	pop    %rbp
ffffffff81007e38:	41 5c                	pop    %r12
ffffffff81007e3a:	41 5d                	pop    %r13
ffffffff81007e3c:	c3                   	retq   
ffffffff81007e3d:	90                   	nop

ffffffff81007e3e <gsi_vector>:

void Gsi::vector (unsigned vector)
{
ffffffff81007e3e:	55                   	push   %rbp
ffffffff81007e3f:	53                   	push   %rbx
    unsigned gsi = vector - VEC_GSI;
ffffffff81007e40:	8d 6f e0             	lea    -0x20(%rdi),%ebp
    if (ioapic)
        ioapic->set_irt (gsi, 0U << 16 | gsi_table[gsi].irt);
}

void Gsi::vector (unsigned vector)
{
ffffffff81007e43:	52                   	push   %rdx
    unsigned gsi = vector - VEC_GSI;

    if (gsi == Keyb::gsi)
ffffffff81007e44:	3b 2d 82 9d 01 00    	cmp    0x19d82(%rip),%ebp        # ffffffff81021bcc <_ZN4Keyb3gsiE>
        ioapic->set_irt (gsi, 0U << 16 | gsi_table[gsi].irt);
}

void Gsi::vector (unsigned vector)
{
    unsigned gsi = vector - VEC_GSI;
ffffffff81007e4a:	48 89 eb             	mov    %rbp,%rbx

    if (gsi == Keyb::gsi)
ffffffff81007e4d:	75 07                	jne    ffffffff81007e56 <gsi_vector+0x18>
        Keyb::interrupt();
ffffffff81007e4f:	e8 42 05 00 00       	callq  ffffffff81008396 <_ZN4Keyb9interruptEv>
ffffffff81007e54:	eb 23                	jmp    ffffffff81007e79 <gsi_vector+0x3b>

    else if (gsi == Acpi::gsi)
ffffffff81007e56:	3b 2d a8 9d 01 00    	cmp    0x19da8(%rip),%ebp        # ffffffff81021c04 <_ZN4Acpi3gsiE>
ffffffff81007e5c:	75 07                	jne    ffffffff81007e65 <gsi_vector+0x27>
        Acpi::interrupt();
ffffffff81007e5e:	e8 eb 8f ff ff       	callq  ffffffff81000e4e <_ZN4Acpi9interruptEv>
ffffffff81007e63:	eb 14                	jmp    ffffffff81007e79 <gsi_vector+0x3b>

    else if (gsi_table[gsi].trg)
ffffffff81007e65:	48 6b c5 18          	imul   $0x18,%rbp,%rax
ffffffff81007e69:	80 b8 51 21 16 81 00 	cmpb   $0x0,-0x7ee9deaf(%rax)
ffffffff81007e70:	79 07                	jns    ffffffff81007e79 <gsi_vector+0x3b>
        mask (gsi);
ffffffff81007e72:	89 ef                	mov    %ebp,%edi
ffffffff81007e74:	e8 23 fe ff ff       	callq  ffffffff81007c9c <_ZN3Gsi4maskEj>

    Lapic::eoi();

    gsi_table[gsi].sm->submit();
ffffffff81007e79:	48 6b c5 18          	imul   $0x18,%rbp,%rax
ffffffff81007e7d:	c7 04 25 b0 e0 ff bf 	movl   $0x0,0xffffffffbfffe0b0
ffffffff81007e84:	00 00 00 00 
ffffffff81007e88:	48 8b b8 40 21 16 81 	mov    -0x7ee9dec0(%rax),%rdi
ffffffff81007e8f:	48 81 c7 a0 00 00 00 	add    $0xa0,%rdi
ffffffff81007e96:	e8 19 d2 00 00       	callq  ffffffff810150b4 <_ZN2Si6submitEv>
        }

        template <unsigned D, unsigned B>
        static void print (mword val, Console_vga::Color c, unsigned col)
        {
            if (EXPECT_FALSE (Cpu::row))
ffffffff81007e9b:	8b 15 ef 78 ff 3e    	mov    0x3eff78ef(%rip),%edx        # ffffffffbffff790 <_ZN3Cpu3rowE>

    Counter::print<1,16> (++Counter::gsi[gsi], Console_vga::Color (Console_vga::COLOR_LIGHT_YELLOW - gsi / 64), SPN_GSI + gsi % 64);
ffffffff81007ea1:	8b 04 ad 00 f5 ff bf 	mov    -0x40000b00(,%rbp,4),%eax
ffffffff81007ea8:	ff c0                	inc    %eax
ffffffff81007eaa:	85 d2                	test   %edx,%edx
ffffffff81007eac:	89 04 ad 00 f5 ff bf 	mov    %eax,-0x40000b00(,%rbp,4)
ffffffff81007eb3:	74 30                	je     ffffffff81007ee5 <gsi_vector+0xa7>

        ALWAYS_INLINE
        inline void put (unsigned long r, unsigned long c, Color color, int x)
        {
            *reinterpret_cast<unsigned short volatile *>(HV_GLOBAL_FBUF + r * 160 + c * 2) = static_cast<unsigned short>(color << 8 | x);
ffffffff81007eb5:	48 6b d2 50          	imul   $0x50,%rdx,%rdx
ffffffff81007eb9:	89 d9                	mov    %ebx,%ecx
                for (unsigned i = 0; i < D; i++, val /= B)
                    Console_vga::con.put (Cpu::row, col - i, c, !i || val ? (val % B)["0123456789ABCDEF"] : ' ');
ffffffff81007ebb:	83 e0 0f             	and    $0xf,%eax
ffffffff81007ebe:	83 e1 3f             	and    $0x3f,%ecx
ffffffff81007ec1:	c1 eb 06             	shr    $0x6,%ebx
ffffffff81007ec4:	48 8d 54 11 10       	lea    0x10(%rcx,%rdx,1),%rdx
ffffffff81007ec9:	66 0f be 88 d8 d7 01 	movsbw -0x7efe2828(%rax),%cx
ffffffff81007ed0:	81 
ffffffff81007ed1:	b8 0e 00 00 00       	mov    $0xe,%eax
ffffffff81007ed6:	29 d8                	sub    %ebx,%eax
ffffffff81007ed8:	c1 e0 08             	shl    $0x8,%eax
ffffffff81007edb:	09 c8                	or     %ecx,%eax
ffffffff81007edd:	66 89 84 12 00 f0 df 	mov    %ax,-0x40201000(%rdx,%rdx,1)
ffffffff81007ee4:	bf 
}
ffffffff81007ee5:	58                   	pop    %rax
ffffffff81007ee6:	5b                   	pop    %rbx
ffffffff81007ee7:	5d                   	pop    %rbp
ffffffff81007ee8:	c3                   	retq   
ffffffff81007ee9:	90                   	nop

ffffffff81007eea <_ZN3Hip7add_cpuEv>:
    mem++;
}

void Hip::add_cpu()
{
    Hip_cpu *cpu = hip()->cpu_desc + Cpu::id;
ffffffff81007eea:	8b 15 14 71 ff 3e    	mov    0x3eff7114(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>

    cpu->acpi_id = Cpu::acpi_id[Cpu::id];
ffffffff81007ef0:	48 8d 42 06          	lea    0x6(%rdx),%rax
ffffffff81007ef4:	8a 92 00 20 16 81    	mov    -0x7ee9e000(%rdx),%dl
    cpu->package = static_cast<uint8>(Cpu::package);
    cpu->core    = static_cast<uint8>(Cpu::core);
    cpu->thread  = static_cast<uint8>(Cpu::thread);
    cpu->flags   = 1;
ffffffff81007efa:	c6 04 c5 08 70 16 81 	movb   $0x1,-0x7ee98ff8(,%rax,8)
ffffffff81007f01:	01 

void Hip::add_cpu()
{
    Hip_cpu *cpu = hip()->cpu_desc + Cpu::id;

    cpu->acpi_id = Cpu::acpi_id[Cpu::id];
ffffffff81007f02:	88 14 c5 0c 70 16 81 	mov    %dl,-0x7ee98ff4(,%rax,8)
    cpu->package = static_cast<uint8>(Cpu::package);
ffffffff81007f09:	8b 15 a9 78 ff 3e    	mov    0x3eff78a9(%rip),%edx        # ffffffffbffff7b8 <_ZN3Cpu7packageE>
ffffffff81007f0f:	88 14 c5 0b 70 16 81 	mov    %dl,-0x7ee98ff5(,%rax,8)
    cpu->core    = static_cast<uint8>(Cpu::core);
ffffffff81007f16:	8b 15 98 78 ff 3e    	mov    0x3eff7898(%rip),%edx        # ffffffffbffff7b4 <_ZN3Cpu4coreE>
ffffffff81007f1c:	88 14 c5 0a 70 16 81 	mov    %dl,-0x7ee98ff6(,%rax,8)
    cpu->thread  = static_cast<uint8>(Cpu::thread);
ffffffff81007f23:	8b 15 87 78 ff 3e    	mov    0x3eff7887(%rip),%edx        # ffffffffbffff7b0 <_ZN3Cpu6threadE>
ffffffff81007f29:	88 14 c5 09 70 16 81 	mov    %dl,-0x7ee98ff7(,%rax,8)
    cpu->flags   = 1;
ffffffff81007f30:	c3                   	retq   
ffffffff81007f31:	90                   	nop

ffffffff81007f32 <_ZN3Hip9add_checkEv>:

    h->freq_tsc = Lapic::freq_tsc;

    uint16 c = 0;
    for (uint16 const *ptr = reinterpret_cast<uint16 const *>(&PAGE_H);
                       ptr < reinterpret_cast<uint16 const *>(&PAGE_H + h->length);
ffffffff81007f32:	0f b7 0d cd f0 15 00 	movzwl 0x15f0cd(%rip),%ecx        # ffffffff81167006 <PAGE_H+0x6>

void Hip::add_check()
{
    Hip *h = hip();

    h->freq_tsc = Lapic::freq_tsc;
ffffffff81007f39:	8b 05 35 b9 15 00    	mov    0x15b935(%rip),%eax        # ffffffff81163874 <_ZN5Lapic8freq_tscE>

    uint16 c = 0;
ffffffff81007f3f:	31 d2                	xor    %edx,%edx

void Hip::add_check()
{
    Hip *h = hip();

    h->freq_tsc = Lapic::freq_tsc;
ffffffff81007f41:	89 05 e9 f0 15 00    	mov    %eax,0x15f0e9(%rip)        # ffffffff81167030 <PAGE_H+0x30>

    uint16 c = 0;
    for (uint16 const *ptr = reinterpret_cast<uint16 const *>(&PAGE_H);
ffffffff81007f47:	48 c7 c0 00 70 16 81 	mov    $0xffffffff81167000,%rax
                       ptr < reinterpret_cast<uint16 const *>(&PAGE_H + h->length);
ffffffff81007f4e:	48 81 c1 00 70 16 81 	add    $0xffffffff81167000,%rcx
    Hip *h = hip();

    h->freq_tsc = Lapic::freq_tsc;

    uint16 c = 0;
    for (uint16 const *ptr = reinterpret_cast<uint16 const *>(&PAGE_H);
ffffffff81007f55:	48 39 c8             	cmp    %rcx,%rax
ffffffff81007f58:	73 0a                	jae    ffffffff81007f64 <_ZN3Hip9add_checkEv+0x32>
ffffffff81007f5a:	48 83 c0 02          	add    $0x2,%rax
ffffffff81007f5e:	66 2b 50 fe          	sub    -0x2(%rax),%dx
ffffffff81007f62:	eb f1                	jmp    ffffffff81007f55 <_ZN3Hip9add_checkEv+0x23>
                       ptr < reinterpret_cast<uint16 const *>(&PAGE_H + h->length);
                       c = static_cast<uint16>(c - *ptr++)) ;

    h->checksum = c;
ffffffff81007f64:	66 89 15 99 f0 15 00 	mov    %dx,0x15f099(%rip)        # ffffffff81167004 <PAGE_H+0x4>
ffffffff81007f6b:	c3                   	retq   

ffffffff81007f6c <_GLOBAL__sub_I.00102__ZN4Hpet5cacheE>:
 */

#include "hpet.hpp"

INIT_PRIORITY (PRIO_SLAB)
Slab_cache Hpet::cache (sizeof (Hpet), 8);
ffffffff81007f6c:	ba 08 00 00 00       	mov    $0x8,%edx
ffffffff81007f71:	be 18 00 00 00       	mov    $0x18,%esi
ffffffff81007f76:	48 c7 c7 60 2d 16 81 	mov    $0xffffffff81162d60,%rdi
ffffffff81007f7d:	e9 1e d9 00 00       	jmpq   ffffffff810158a0 <_ZN10Slab_cacheC1Emj>

ffffffff81007f82 <_ZN3Hpt9sync_fromER5QuotaS_mm>:

#include "assert.hpp"
#include "bits.hpp"
#include "hpt.hpp"

bool Hpt::sync_from(Quota &quota, Hpt src, mword v, mword o) {
ffffffff81007f82:	41 56                	push   %r14
ffffffff81007f84:	41 55                	push   %r13

ALWAYS_INLINE
inline long int bit_scan_reverse (mword val)
{
    if (EXPECT_FALSE (!val))
        return -1;
ffffffff81007f86:	48 83 c8 ff          	or     $0xffffffffffffffff,%rax
ffffffff81007f8a:	41 54                	push   %r12
ffffffff81007f8c:	55                   	push   %rbp
ffffffff81007f8d:	49 89 fd             	mov    %rdi,%r13
ffffffff81007f90:	53                   	push   %rbx
ffffffff81007f91:	49 89 f6             	mov    %rsi,%r14
ffffffff81007f94:	48 89 cd             	mov    %rcx,%rbp
ffffffff81007f97:	48 83 ec 10          	sub    $0x10,%rsp
#include "util.hpp"

ALWAYS_INLINE
inline long int bit_scan_reverse (mword val)
{
    if (EXPECT_FALSE (!val))
ffffffff81007f9b:	49 31 c8             	xor    %rcx,%r8
ffffffff81007f9e:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
ffffffff81007fa3:	74 04                	je     ffffffff81007fa9 <_ZN3Hpt9sync_fromER5QuotaS_mm+0x27>
        return -1;

    asm volatile ("bsr %1, %0" : "=r" (val) : "rm" (val));

    return val;
ffffffff81007fa5:	49 0f bd c0          	bsr    %r8,%rax
    mword l = (bit_scan_reverse(v ^ o) - PAGE_BITS) / bpl();
ffffffff81007fa9:	48 83 e8 0c          	sub    $0xc,%rax
ffffffff81007fad:	b9 09 00 00 00       	mov    $0x9,%ecx

    Hpt *s = static_cast<Hpt *> (src.walk(quota, v, l, false));
ffffffff81007fb2:	48 8d 7c 24 08       	lea    0x8(%rsp),%rdi
#include "assert.hpp"
#include "bits.hpp"
#include "hpt.hpp"

bool Hpt::sync_from(Quota &quota, Hpt src, mword v, mword o) {
    mword l = (bit_scan_reverse(v ^ o) - PAGE_BITS) / bpl();
ffffffff81007fb7:	48 99                	cqto   

    Hpt *s = static_cast<Hpt *> (src.walk(quota, v, l, false));
ffffffff81007fb9:	45 31 c0             	xor    %r8d,%r8d
ffffffff81007fbc:	4c 89 f6             	mov    %r14,%rsi
#include "assert.hpp"
#include "bits.hpp"
#include "hpt.hpp"

bool Hpt::sync_from(Quota &quota, Hpt src, mword v, mword o) {
    mword l = (bit_scan_reverse(v ^ o) - PAGE_BITS) / bpl();
ffffffff81007fbf:	48 f7 f9             	idiv   %rcx

    Hpt *s = static_cast<Hpt *> (src.walk(quota, v, l, false));
ffffffff81007fc2:	48 89 ea             	mov    %rbp,%rdx
ffffffff81007fc5:	48 89 c1             	mov    %rax,%rcx
#include "assert.hpp"
#include "bits.hpp"
#include "hpt.hpp"

bool Hpt::sync_from(Quota &quota, Hpt src, mword v, mword o) {
    mword l = (bit_scan_reverse(v ^ o) - PAGE_BITS) / bpl();
ffffffff81007fc8:	48 89 c3             	mov    %rax,%rbx

    Hpt *s = static_cast<Hpt *> (src.walk(quota, v, l, false));
ffffffff81007fcb:	e8 36 aa 00 00       	callq  ffffffff81012a06 <_ZN3PteI3HptmLj4ELj9ELb0EE4walkER5Quotammb>
    if (!s)
ffffffff81007fd0:	48 85 c0             	test   %rax,%rax
#include "hpt.hpp"

bool Hpt::sync_from(Quota &quota, Hpt src, mword v, mword o) {
    mword l = (bit_scan_reverse(v ^ o) - PAGE_BITS) / bpl();

    Hpt *s = static_cast<Hpt *> (src.walk(quota, v, l, false));
ffffffff81007fd3:	49 89 c4             	mov    %rax,%r12
    if (!s)
ffffffff81007fd6:	75 04                	jne    ffffffff81007fdc <_ZN3Hpt9sync_fromER5QuotaS_mm+0x5a>
        return false;
ffffffff81007fd8:	31 c0                	xor    %eax,%eax
ffffffff81007fda:	eb 55                	jmp    ffffffff81008031 <_ZN3Hpt9sync_fromER5QuotaS_mm+0xaf>

    Hpt *d = static_cast<Hpt *> (walk(quota, v, l));
ffffffff81007fdc:	48 89 ea             	mov    %rbp,%rdx
ffffffff81007fdf:	41 b8 01 00 00 00    	mov    $0x1,%r8d
ffffffff81007fe5:	48 89 d9             	mov    %rbx,%rcx
ffffffff81007fe8:	4c 89 f6             	mov    %r14,%rsi
ffffffff81007feb:	4c 89 ef             	mov    %r13,%rdi
ffffffff81007fee:	e8 13 aa 00 00       	callq  ffffffff81012a06 <_ZN3PteI3HptmLj4ELj9ELb0EE4walkER5Quotammb>
    assert(d);
ffffffff81007ff3:	48 85 c0             	test   %rax,%rax

    Hpt *s = static_cast<Hpt *> (src.walk(quota, v, l, false));
    if (!s)
        return false;

    Hpt *d = static_cast<Hpt *> (walk(quota, v, l));
ffffffff81007ff6:	48 89 c2             	mov    %rax,%rdx
    assert(d);
ffffffff81007ff9:	75 28                	jne    ffffffff81008023 <_ZN3Hpt9sync_fromER5QuotaS_mm+0xa1>
ffffffff81007ffb:	49 c7 c0 20 e5 01 81 	mov    $0xffffffff8101e520,%r8
ffffffff81008002:	b9 22 00 00 00       	mov    $0x22,%ecx
ffffffff81008007:	48 c7 c2 83 e4 01 81 	mov    $0xffffffff8101e483,%rdx
ffffffff8100800e:	48 c7 c6 1c d1 01 81 	mov    $0xffffffff8101d11c,%rsi
ffffffff81008015:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100801c:	31 c0                	xor    %eax,%eax
ffffffff8100801e:	e8 2d 9f ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

    if (d->val == s->val)
ffffffff81008023:	49 8b 04 24          	mov    (%r12),%rax
ffffffff81008027:	48 39 02             	cmp    %rax,(%rdx)
ffffffff8100802a:	74 ac                	je     ffffffff81007fd8 <_ZN3Hpt9sync_fromER5QuotaS_mm+0x56>
        return false;

    d->val = s->val;
ffffffff8100802c:	48 89 02             	mov    %rax,(%rdx)

    return true;
ffffffff8100802f:	b0 01                	mov    $0x1,%al
}
ffffffff81008031:	48 83 c4 10          	add    $0x10,%rsp
ffffffff81008035:	5b                   	pop    %rbx
ffffffff81008036:	5d                   	pop    %rbp
ffffffff81008037:	41 5c                	pop    %r12
ffffffff81008039:	41 5d                	pop    %r13
ffffffff8100803b:	41 5e                	pop    %r14
ffffffff8100803d:	c3                   	retq   

ffffffff8100803e <_ZN3Hpt17sync_master_rangeER5Quotamm>:

void Hpt::sync_master_range(Quota & quota, mword s, mword e) {
ffffffff8100803e:	41 56                	push   %r14
inline long int bit_scan_reverse (mword val)
{
    if (EXPECT_FALSE (!val))
        return -1;

    asm volatile ("bsr %1, %0" : "=r" (val) : "rm" (val));
ffffffff81008040:	b8 00 00 e0 3e       	mov    $0x3ee00000,%eax
ffffffff81008045:	41 55                	push   %r13
ffffffff81008047:	49 89 d5             	mov    %rdx,%r13
ffffffff8100804a:	41 54                	push   %r12
ffffffff8100804c:	49 89 f4             	mov    %rsi,%r12
ffffffff8100804f:	55                   	push   %rbp
ffffffff81008050:	48 89 fd             	mov    %rdi,%rbp
ffffffff81008053:	53                   	push   %rbx
ffffffff81008054:	48 89 cb             	mov    %rcx,%rbx
ffffffff81008057:	48 0f bd c0          	bsr    %rax,%rax
    for (mword l = (bit_scan_reverse(LINK_ADDR ^ CPU_LOCAL) - PAGE_BITS) / bpl(); s < e; s += 1UL << (l * bpl() + PAGE_BITS))
ffffffff8100805b:	48 83 e8 0c          	sub    $0xc,%rax
ffffffff8100805f:	be 09 00 00 00       	mov    $0x9,%esi
ffffffff81008064:	41 be 01 00 00 00    	mov    $0x1,%r14d
ffffffff8100806a:	48 99                	cqto   
ffffffff8100806c:	48 f7 fe             	idiv   %rsi
ffffffff8100806f:	8d 04 c0             	lea    (%rax,%rax,8),%eax
ffffffff81008072:	8d 48 0c             	lea    0xc(%rax),%ecx
ffffffff81008075:	49 d3 e6             	shl    %cl,%r14
ffffffff81008078:	49 39 dd             	cmp    %rbx,%r13
ffffffff8100807b:	73 21                	jae    ffffffff8100809e <_ZN3Hpt17sync_master_rangeER5Quotamm+0x60>
        sync_from(quota, Hptp(reinterpret_cast<mword> (&PDBR)), s, CPU_LOCAL);
ffffffff8100807d:	4c 89 e9             	mov    %r13,%rcx
ffffffff81008080:	49 c7 c0 00 00 e0 bf 	mov    $0xffffffffbfe00000,%r8
ffffffff81008087:	48 c7 c2 00 80 56 00 	mov    $0x568000,%rdx
ffffffff8100808e:	4c 89 e6             	mov    %r12,%rsi
ffffffff81008091:	48 89 ef             	mov    %rbp,%rdi

    return true;
}

void Hpt::sync_master_range(Quota & quota, mword s, mword e) {
    for (mword l = (bit_scan_reverse(LINK_ADDR ^ CPU_LOCAL) - PAGE_BITS) / bpl(); s < e; s += 1UL << (l * bpl() + PAGE_BITS))
ffffffff81008094:	4d 01 f5             	add    %r14,%r13
        sync_from(quota, Hptp(reinterpret_cast<mword> (&PDBR)), s, CPU_LOCAL);
ffffffff81008097:	e8 e6 fe ff ff       	callq  ffffffff81007f82 <_ZN3Hpt9sync_fromER5QuotaS_mm>
ffffffff8100809c:	eb da                	jmp    ffffffff81008078 <_ZN3Hpt17sync_master_rangeER5Quotamm+0x3a>
}
ffffffff8100809e:	5b                   	pop    %rbx
ffffffff8100809f:	5d                   	pop    %rbp
ffffffff810080a0:	41 5c                	pop    %r12
ffffffff810080a2:	41 5d                	pop    %r13
ffffffff810080a4:	41 5e                	pop    %r14
ffffffff810080a6:	c3                   	retq   
ffffffff810080a7:	90                   	nop

ffffffff810080a8 <_ZN3Hpt7replaceER5Quotamm>:

Paddr Hpt::replace(Quota &quota, mword v, mword p) {
ffffffff810080a8:	55                   	push   %rbp
ffffffff810080a9:	53                   	push   %rbx
ffffffff810080aa:	48 89 cd             	mov    %rcx,%rbp
ffffffff810080ad:	41 50                	push   %r8
    Hpt o, *e = walk(quota, v, 0);
ffffffff810080af:	31 c9                	xor    %ecx,%ecx
ffffffff810080b1:	41 b8 01 00 00 00    	mov    $0x1,%r8d
void Hpt::sync_master_range(Quota & quota, mword s, mword e) {
    for (mword l = (bit_scan_reverse(LINK_ADDR ^ CPU_LOCAL) - PAGE_BITS) / bpl(); s < e; s += 1UL << (l * bpl() + PAGE_BITS))
        sync_from(quota, Hptp(reinterpret_cast<mword> (&PDBR)), s, CPU_LOCAL);
}

Paddr Hpt::replace(Quota &quota, mword v, mword p) {
ffffffff810080b7:	48 89 d3             	mov    %rdx,%rbx
    Hpt o, *e = walk(quota, v, 0);
ffffffff810080ba:	e8 47 a9 00 00       	callq  ffffffff81012a06 <_ZN3PteI3HptmLj4ELj9ELb0EE4walkER5Quotammb>
    assert(e);
ffffffff810080bf:	48 85 c0             	test   %rax,%rax
    for (mword l = (bit_scan_reverse(LINK_ADDR ^ CPU_LOCAL) - PAGE_BITS) / bpl(); s < e; s += 1UL << (l * bpl() + PAGE_BITS))
        sync_from(quota, Hptp(reinterpret_cast<mword> (&PDBR)), s, CPU_LOCAL);
}

Paddr Hpt::replace(Quota &quota, mword v, mword p) {
    Hpt o, *e = walk(quota, v, 0);
ffffffff810080c2:	48 89 c6             	mov    %rax,%rsi
    assert(e);
ffffffff810080c5:	75 33                	jne    ffffffff810080fa <_ZN3Hpt7replaceER5Quotamm+0x52>
ffffffff810080c7:	49 c7 c0 f0 e4 01 81 	mov    $0xffffffff8101e4f0,%r8
ffffffff810080ce:	b9 33 00 00 00       	mov    $0x33,%ecx
ffffffff810080d3:	48 c7 c2 83 e4 01 81 	mov    $0xffffffff8101e483,%rdx
ffffffff810080da:	48 c7 c6 4e e2 01 81 	mov    $0xffffffff8101e24e,%rsi
ffffffff810080e1:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff810080e8:	31 c0                	xor    %eax,%eax
ffffffff810080ea:	e8 61 9e ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

    do o = *e; while (o.val != p && !(o.attr() & HPT_W) && !e->set(o.val, p));
ffffffff810080ef:	a8 02                	test   $0x2,%al
ffffffff810080f1:	75 0f                	jne    ffffffff81008102 <_ZN3Hpt7replaceER5Quotamm+0x5a>
ffffffff810080f3:	f0 48 0f b1 2e       	lock cmpxchg %rbp,(%rsi)
ffffffff810080f8:	74 08                	je     ffffffff81008102 <_ZN3Hpt7replaceER5Quotamm+0x5a>
ffffffff810080fa:	48 8b 06             	mov    (%rsi),%rax
ffffffff810080fd:	48 39 e8             	cmp    %rbp,%rax
ffffffff81008100:	75 ed                	jne    ffffffff810080ef <_ZN3Hpt7replaceER5Quotamm+0x47>
ffffffff81008102:	0f 01 3b             	invlpg (%rbx)
        PTE_U = HPT_U,
    };

    ALWAYS_INLINE
    inline Paddr addr() const {
        return static_cast<Paddr> (val) & ~PAGE_MASK;
ffffffff81008105:	48 8b 06             	mov    (%rsi),%rax

    flush(v);
    return e->addr();
}
ffffffff81008108:	5a                   	pop    %rdx
ffffffff81008109:	5b                   	pop    %rbx
ffffffff8100810a:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81008110:	5d                   	pop    %rbp
ffffffff81008111:	c3                   	retq   

ffffffff81008112 <_ZN3Hpt5remapER5Quotam>:

void *Hpt::remap(Quota &quota, Paddr phys) {
ffffffff81008112:	41 54                	push   %r12
ffffffff81008114:	55                   	push   %rbp
ffffffff81008115:	48 89 fd             	mov    %rdi,%rbp
ffffffff81008118:	53                   	push   %rbx
ffffffff81008119:	48 83 ec 20          	sub    $0x20,%rsp
    }

    ALWAYS_INLINE
    static inline mword current() {
        mword addr;
        asm volatile ("mov %%cr3, %0" : "=r" (addr));
ffffffff8100811d:	0f 20 d8             	mov    %cr3,%rax

    phys &= ~offset;

    Paddr old;
    mword attr;
    if (hpt.lookup(SPC_LOCAL_REMAP, old, attr)) {
ffffffff81008120:	48 8d 4c 24 18       	lea    0x18(%rsp),%rcx
ffffffff81008125:	48 8d 54 24 10       	lea    0x10(%rsp),%rdx
ffffffff8100812a:	48 8d 7c 24 08       	lea    0x8(%rsp),%rdi

    size_t size = 1UL << (bpl() + PAGE_BITS);

    mword offset = phys & (size - 1);

    phys &= ~offset;
ffffffff8100812f:	49 89 f4             	mov    %rsi,%r12
ffffffff81008132:	48 89 f3             	mov    %rsi,%rbx

    Paddr old;
    mword attr;
    if (hpt.lookup(SPC_LOCAL_REMAP, old, attr)) {
ffffffff81008135:	48 c7 c6 00 00 00 df 	mov    $0xffffffffdf000000,%rsi
class Hptp : public Hpt {
public:

    ALWAYS_INLINE
    inline explicit Hptp(mword v = 0) {
        val = v;
ffffffff8100813c:	48 89 44 24 08       	mov    %rax,0x8(%rsp)

    size_t size = 1UL << (bpl() + PAGE_BITS);

    mword offset = phys & (size - 1);

    phys &= ~offset;
ffffffff81008141:	41 81 e4 ff ff 1f 00 	and    $0x1fffff,%r12d
ffffffff81008148:	48 81 e3 00 00 e0 ff 	and    $0xffffffffffe00000,%rbx

    Paddr old;
    mword attr;
    if (hpt.lookup(SPC_LOCAL_REMAP, old, attr)) {
ffffffff8100814f:	e8 80 aa 00 00       	callq  ffffffff81012bd4 <_ZN3PteI3HptmLj4ELj9ELb0EE6lookupEmRmS2_>
ffffffff81008154:	48 85 c0             	test   %rax,%rax
ffffffff81008157:	74 5a                	je     ffffffff810081b3 <_ZN3Hpt5remapER5Quotam+0xa1>
        hpt.update(quota, SPC_LOCAL_REMAP, bpl(), 0, 0, Hpt::TYPE_DN);
ffffffff81008159:	6a 00                	pushq  $0x0
ffffffff8100815b:	6a 01                	pushq  $0x1
ffffffff8100815d:	45 31 c9             	xor    %r9d,%r9d
ffffffff81008160:	45 31 c0             	xor    %r8d,%r8d
ffffffff81008163:	b9 09 00 00 00       	mov    $0x9,%ecx
ffffffff81008168:	48 c7 c2 00 00 00 df 	mov    $0xffffffffdf000000,%rdx
ffffffff8100816f:	48 8d 7c 24 18       	lea    0x18(%rsp),%rdi
ffffffff81008174:	48 89 ee             	mov    %rbp,%rsi
ffffffff81008177:	e8 9a ab 00 00       	callq  ffffffff81012d16 <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb>

public:

    ALWAYS_INLINE
    static inline void flush(mword addr) {
        asm volatile ("invlpg %0" : : "m" (*reinterpret_cast<mword *> (addr)));
ffffffff8100817c:	0f 01 3c 25 00 00 00 	invlpg 0xffffffffdf000000
ffffffff81008183:	df 
        flush(SPC_LOCAL_REMAP);
        hpt.update(quota, SPC_LOCAL_REMAP + size, bpl(), 0, 0, Hpt::TYPE_DN);
ffffffff81008184:	6a 00                	pushq  $0x0
ffffffff81008186:	6a 01                	pushq  $0x1
ffffffff81008188:	45 31 c9             	xor    %r9d,%r9d
ffffffff8100818b:	45 31 c0             	xor    %r8d,%r8d
ffffffff8100818e:	b9 09 00 00 00       	mov    $0x9,%ecx
ffffffff81008193:	48 c7 c2 00 00 20 df 	mov    $0xffffffffdf200000,%rdx
ffffffff8100819a:	48 8d 7c 24 28       	lea    0x28(%rsp),%rdi
ffffffff8100819f:	48 89 ee             	mov    %rbp,%rsi
ffffffff810081a2:	e8 6f ab 00 00       	callq  ffffffff81012d16 <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb>
ffffffff810081a7:	0f 01 3c 25 00 00 20 	invlpg 0xffffffffdf200000
ffffffff810081ae:	df 
ffffffff810081af:	48 83 c4 20          	add    $0x20,%rsp
        flush(SPC_LOCAL_REMAP + size);
    }

    hpt.update(quota, SPC_LOCAL_REMAP, bpl(), phys, HPT_W | HPT_P);
ffffffff810081b3:	6a 00                	pushq  $0x0
ffffffff810081b5:	6a 00                	pushq  $0x0
ffffffff810081b7:	49 89 d8             	mov    %rbx,%r8
ffffffff810081ba:	48 89 ee             	mov    %rbp,%rsi
ffffffff810081bd:	41 b9 03 00 00 00    	mov    $0x3,%r9d
ffffffff810081c3:	b9 09 00 00 00       	mov    $0x9,%ecx
ffffffff810081c8:	48 8d 7c 24 18       	lea    0x18(%rsp),%rdi
ffffffff810081cd:	48 c7 c2 00 00 00 df 	mov    $0xffffffffdf000000,%rdx
ffffffff810081d4:	e8 3d ab 00 00       	callq  ffffffff81012d16 <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb>
    hpt.update(quota, SPC_LOCAL_REMAP + size, bpl(), phys + size, HPT_W | HPT_P);
ffffffff810081d9:	6a 00                	pushq  $0x0
ffffffff810081db:	6a 00                	pushq  $0x0
ffffffff810081dd:	4c 8d 83 00 00 20 00 	lea    0x200000(%rbx),%r8
ffffffff810081e4:	48 89 ee             	mov    %rbp,%rsi
ffffffff810081e7:	41 b9 03 00 00 00    	mov    $0x3,%r9d
ffffffff810081ed:	b9 09 00 00 00       	mov    $0x9,%ecx
ffffffff810081f2:	48 8d 7c 24 28       	lea    0x28(%rsp),%rdi
ffffffff810081f7:	48 c7 c2 00 00 20 df 	mov    $0xffffffffdf200000,%rdx
ffffffff810081fe:	e8 13 ab 00 00       	callq  ffffffff81012d16 <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb>

    return reinterpret_cast<void *> (SPC_LOCAL_REMAP + offset);
}
ffffffff81008203:	48 83 c4 40          	add    $0x40,%rsp
    }

    hpt.update(quota, SPC_LOCAL_REMAP, bpl(), phys, HPT_W | HPT_P);
    hpt.update(quota, SPC_LOCAL_REMAP + size, bpl(), phys + size, HPT_W | HPT_P);

    return reinterpret_cast<void *> (SPC_LOCAL_REMAP + offset);
ffffffff81008207:	49 8d 84 24 00 00 00 	lea    -0x21000000(%r12),%rax
ffffffff8100820e:	df 
}
ffffffff8100820f:	5b                   	pop    %rbx
ffffffff81008210:	5d                   	pop    %rbp
ffffffff81008211:	41 5c                	pop    %r12
ffffffff81008213:	c3                   	retq   

ffffffff81008214 <_ZN3Hpt9remap_cowER5Quotamm>:

void *Hpt::remap_cow(Quota &quota, Paddr phys, mword addr) {
ffffffff81008214:	55                   	push   %rbp
ffffffff81008215:	53                   	push   %rbx
ffffffff81008216:	49 89 f0             	mov    %rsi,%r8
ffffffff81008219:	48 89 d5             	mov    %rdx,%rbp
ffffffff8100821c:	48 83 ec 18          	sub    $0x18,%rsp
    }

    ALWAYS_INLINE
    static inline mword current() {
        mword addr;
        asm volatile ("mov %%cr3, %0" : "=r" (addr));
ffffffff81008220:	0f 20 d8             	mov    %cr3,%rax
class Hptp : public Hpt {
public:

    ALWAYS_INLINE
    inline explicit Hptp(mword v = 0) {
        val = v;
ffffffff81008223:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    Hptp hpt(current());
    addr += COW_ADDR;
    hpt.update(quota, addr, 0, phys, Hpt::HPT_W | Hpt::HPT_P, Hpt::TYPE_UP);
ffffffff81008228:	6a 00                	pushq  $0x0
    return reinterpret_cast<void *> (SPC_LOCAL_REMAP + offset);
}

void *Hpt::remap_cow(Quota &quota, Paddr phys, mword addr) {
    Hptp hpt(current());
    addr += COW_ADDR;
ffffffff8100822a:	48 8d 9a 00 00 00 de 	lea    -0x22000000(%rdx),%rbx
    hpt.update(quota, addr, 0, phys, Hpt::HPT_W | Hpt::HPT_P, Hpt::TYPE_UP);
ffffffff81008231:	6a 00                	pushq  $0x0
ffffffff81008233:	48 89 fe             	mov    %rdi,%rsi
ffffffff81008236:	41 b9 03 00 00 00    	mov    $0x3,%r9d
ffffffff8100823c:	31 c9                	xor    %ecx,%ecx
ffffffff8100823e:	48 89 da             	mov    %rbx,%rdx
ffffffff81008241:	48 8d 7c 24 18       	lea    0x18(%rsp),%rdi
ffffffff81008246:	e8 cb aa 00 00       	callq  ffffffff81012d16 <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb>

public:

    ALWAYS_INLINE
    static inline void flush(mword addr) {
        asm volatile ("invlpg %0" : : "m" (*reinterpret_cast<mword *> (addr)));
ffffffff8100824b:	0f 01 bd 00 00 00 de 	invlpg -0x22000000(%rbp)
    Hpt::cow_flush(addr);
    return reinterpret_cast<void *> (addr);
}
ffffffff81008252:	48 83 c4 28          	add    $0x28,%rsp
ffffffff81008256:	48 89 d8             	mov    %rbx,%rax
ffffffff81008259:	5b                   	pop    %rbx
ffffffff8100825a:	5d                   	pop    %rbp
ffffffff8100825b:	c3                   	retq   

ffffffff8100825c <_ZN3Cow10initializeEv>:

    Cow();
    //    Cow(const Cow& orig);
    virtual ~Cow();

    static void initialize() {
ffffffff8100825c:	53                   	push   %rbx
ffffffff8100825d:	31 db                	xor    %ebx,%ebx
        // Allocate NB_COW_FRAME cow frames
        for (uint64 i = 0; i < NB_COW_FRAME; i++)
            cow_frames[i].phys_addr = Buddy::ptr_to_phys(Buddy::allocator.alloc(0, Pd::kern.quota, Buddy::FILL_0));
ffffffff8100825f:	31 f6                	xor    %esi,%esi
ffffffff81008261:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff81008266:	48 c7 c2 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rdx
ffffffff8100826d:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff81008274:	e8 79 96 ff ff       	callq  ffffffff810018f2 <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
ffffffff81008279:	48 2d 00 00 c0 80    	sub    $0xffffffff80c00000,%rax
ffffffff8100827f:	48 89 83 80 1f 02 81 	mov    %rax,-0x7efde080(%rbx)
ffffffff81008286:	48 83 c3 10          	add    $0x10,%rbx
    //    Cow(const Cow& orig);
    virtual ~Cow();

    static void initialize() {
        // Allocate NB_COW_FRAME cow frames
        for (uint64 i = 0; i < NB_COW_FRAME; i++)
ffffffff8100828a:	48 81 fb 00 00 04 00 	cmp    $0x40000,%rbx
ffffffff81008291:	75 cc                	jne    ffffffff8100825f <_ZN3Cow10initializeEv+0x3>
            cow_frames[i].phys_addr = Buddy::ptr_to_phys(Buddy::allocator.alloc(0, Pd::kern.quota, Buddy::FILL_0));

        // calculate the physical address space for the RAM
        Hip_mem *mem_desc = Hip::get_mem_desc();
        uint32 num_mem_desc = (Hip::get_length() - Hip::get_mem_offset()) / Hip::get_mem_size();
ffffffff81008293:	0f b7 15 72 ed 15 00 	movzwl 0x15ed72(%rip),%edx        # ffffffff8116700c <PAGE_H+0xc>
ffffffff8100829a:	0f b7 05 65 ed 15 00 	movzwl 0x15ed65(%rip),%eax        # ffffffff81167006 <PAGE_H+0x6>
ffffffff810082a1:	49 c7 c0 00 70 16 81 	mov    $0xffffffff81167000,%r8
ffffffff810082a8:	0f b7 0d 5f ed 15 00 	movzwl 0x15ed5f(%rip),%ecx        # ffffffff8116700e <PAGE_H+0xe>
        for (uint32 i = 0; i < num_mem_desc; i++, mem_desc++) {
ffffffff810082af:	45 31 d2             	xor    %r10d,%r10d
        for (uint64 i = 0; i < NB_COW_FRAME; i++)
            cow_frames[i].phys_addr = Buddy::ptr_to_phys(Buddy::allocator.alloc(0, Pd::kern.quota, Buddy::FILL_0));

        // calculate the physical address space for the RAM
        Hip_mem *mem_desc = Hip::get_mem_desc();
        uint32 num_mem_desc = (Hip::get_length() - Hip::get_mem_offset()) / Hip::get_mem_size();
ffffffff810082b2:	29 d0                	sub    %edx,%eax
ffffffff810082b4:	99                   	cltd   
ffffffff810082b5:	f7 f9                	idiv   %ecx
        for (uint32 i = 0; i < num_mem_desc; i++, mem_desc++) {
ffffffff810082b7:	48 8b 0d 3a 9b 01 00 	mov    0x19b3a(%rip),%rcx        # ffffffff81021df8 <_ZN3Cow12ram_mem_listE>
ffffffff810082be:	41 39 c2             	cmp    %eax,%r10d
ffffffff810082c1:	0f 84 98 00 00 00    	je     ffffffff8100835f <_ZN3Cow10initializeEv+0x103>
            if (mem_desc->type == AVAILABLE_MEMORY) {
ffffffff810082c7:	41 83 b8 48 02 00 00 	cmpl   $0x1,0x248(%r8)
ffffffff810082ce:	01 
ffffffff810082cf:	49 89 c9             	mov    %rcx,%r9
ffffffff810082d2:	75 7c                	jne    ffffffff81008350 <_ZN3Cow10initializeEv+0xf4>
ffffffff810082d4:	31 ff                	xor    %edi,%edi
ffffffff810082d6:	48 89 fa             	mov    %rdi,%rdx
        }
    }

    static struct block* get_new_block_elt() {
        for (uint16 i = 0; i < NB_BLOCK_ELT; i++) {
            if (!block_elts[i].used) {
ffffffff810082d9:	48 63 f7             	movslq %edi,%rsi
ffffffff810082dc:	48 c1 e2 05          	shl    $0x5,%rdx
ffffffff810082e0:	80 ba 10 1e 02 81 00 	cmpb   $0x0,-0x7efde1f0(%rdx)
ffffffff810082e7:	75 49                	jne    ffffffff81008332 <_ZN3Cow10initializeEv+0xd6>
        Hip_mem *mem_desc = Hip::get_mem_desc();
        uint32 num_mem_desc = (Hip::get_length() - Hip::get_mem_offset()) / Hip::get_mem_size();
        for (uint32 i = 0; i < num_mem_desc; i++, mem_desc++) {
            if (mem_desc->type == AVAILABLE_MEMORY) {
                struct block *b = get_new_block_elt(), *tampon = ram_mem_list;
                b->start = align_up(static_cast<Paddr> (mem_desc->addr), PAGE_SIZE); // Core rounds the start to the upper page boundary
ffffffff810082e9:	49 8b b8 38 02 00 00 	mov    0x238(%r8),%rdi
    }

    static struct block* get_new_block_elt() {
        for (uint16 i = 0; i < NB_BLOCK_ELT; i++) {
            if (!block_elts[i].used) {
                block_elts[i].used = true;
ffffffff810082f0:	48 c1 e6 05          	shl    $0x5,%rsi
ffffffff810082f4:	4c 8d 8e 00 1e 02 81 	lea    -0x7efde200(%rsi),%r9
ffffffff810082fb:	c6 86 10 1e 02 81 01 	movb   $0x1,-0x7efde1f0(%rsi)
}

ALWAYS_INLINE
static inline mword align_up (mword val, mword align)
{
    val += (align - 1);                 // Expect power-of-2
ffffffff81008302:	48 8d 97 ff 0f 00 00 	lea    0xfff(%rdi),%rdx
        uint32 num_mem_desc = (Hip::get_length() - Hip::get_mem_offset()) / Hip::get_mem_size();
        for (uint32 i = 0; i < num_mem_desc; i++, mem_desc++) {
            if (mem_desc->type == AVAILABLE_MEMORY) {
                struct block *b = get_new_block_elt(), *tampon = ram_mem_list;
                b->start = align_up(static_cast<Paddr> (mem_desc->addr), PAGE_SIZE); // Core rounds the start to the upper page boundary
                b->end = align_dn(static_cast<Paddr> (mem_desc->addr + mem_desc->size), PAGE_SIZE); // Core truncate the size to the lower page boundary
ffffffff81008309:	49 03 b8 40 02 00 00 	add    0x240(%r8),%rdi
                ram_mem_list = b;
                b->next = tampon;
ffffffff81008310:	49 89 49 18          	mov    %rcx,0x18(%r9)
}

ALWAYS_INLINE
static inline mword align_dn (mword val, mword align)
{
    val &= ~(align - 1);                // Expect power-of-2
ffffffff81008314:	48 81 e2 00 f0 ff ff 	and    $0xfffffffffffff000,%rdx
ffffffff8100831b:	48 89 96 00 1e 02 81 	mov    %rdx,-0x7efde200(%rsi)
ffffffff81008322:	48 81 e7 00 f0 ff ff 	and    $0xfffffffffffff000,%rdi
ffffffff81008329:	48 89 be 08 1e 02 81 	mov    %rdi,-0x7efde1f8(%rsi)
ffffffff81008330:	eb 1e                	jmp    ffffffff81008350 <_ZN3Cow10initializeEv+0xf4>
ffffffff81008332:	48 ff c7             	inc    %rdi
            b = b->next;
        }
    }

    static struct block* get_new_block_elt() {
        for (uint16 i = 0; i < NB_BLOCK_ELT; i++) {
ffffffff81008335:	48 83 ff 0a          	cmp    $0xa,%rdi
ffffffff81008339:	75 9b                	jne    ffffffff810082d6 <_ZN3Cow10initializeEv+0x7a>
ffffffff8100833b:	48 89 0d b6 9a 01 00 	mov    %rcx,0x19ab6(%rip)        # ffffffff81021df8 <_ZN3Cow12ram_mem_listE>
        Hip_mem *mem_desc = Hip::get_mem_desc();
        uint32 num_mem_desc = (Hip::get_length() - Hip::get_mem_offset()) / Hip::get_mem_size();
        for (uint32 i = 0; i < num_mem_desc; i++, mem_desc++) {
            if (mem_desc->type == AVAILABLE_MEMORY) {
                struct block *b = get_new_block_elt(), *tampon = ram_mem_list;
                b->start = align_up(static_cast<Paddr> (mem_desc->addr), PAGE_SIZE); // Core rounds the start to the upper page boundary
ffffffff81008342:	48 c7 04 25 00 00 00 	movq   $0x0,0x0
ffffffff81008349:	00 00 00 00 00 
ffffffff8100834e:	0f 0b                	ud2    
            cow_frames[i].phys_addr = Buddy::ptr_to_phys(Buddy::allocator.alloc(0, Pd::kern.quota, Buddy::FILL_0));

        // calculate the physical address space for the RAM
        Hip_mem *mem_desc = Hip::get_mem_desc();
        uint32 num_mem_desc = (Hip::get_length() - Hip::get_mem_offset()) / Hip::get_mem_size();
        for (uint32 i = 0; i < num_mem_desc; i++, mem_desc++) {
ffffffff81008350:	41 ff c2             	inc    %r10d
ffffffff81008353:	49 83 c0 18          	add    $0x18,%r8
ffffffff81008357:	4c 89 c9             	mov    %r9,%rcx
ffffffff8100835a:	e9 5f ff ff ff       	jmpq   ffffffff810082be <_ZN3Cow10initializeEv+0x62>
ffffffff8100835f:	48 89 0d 92 9a 01 00 	mov    %rcx,0x19a92(%rip)        # ffffffff81021df8 <_ZN3Cow12ram_mem_listE>
                ram_mem_list = b;
                b->next = tampon;
            }
        }
        struct block *b = ram_mem_list;
        while (b != nullptr) {
ffffffff81008366:	48 85 c9             	test   %rcx,%rcx
ffffffff81008369:	74 13                	je     ffffffff8100837e <_ZN3Cow10initializeEv+0x122>
            if (b->start == 0x0UL) {
ffffffff8100836b:	48 83 39 00          	cmpq   $0x0,(%rcx)
ffffffff8100836f:	75 07                	jne    ffffffff81008378 <_ZN3Cow10initializeEv+0x11c>
                b->start = 0x1000UL; // Core : [0 - 1000[ is needed as I/O memory by the VESA driver, remove it from Ram space */
ffffffff81008371:	48 c7 01 00 10 00 00 	movq   $0x1000,(%rcx)
            }
            //                        Console::print("deb: %08lx  fin: %08lx", b->start, b->end);
            b = b->next;
ffffffff81008378:	48 8b 49 18          	mov    0x18(%rcx),%rcx
ffffffff8100837c:	eb e8                	jmp    ffffffff81008366 <_ZN3Cow10initializeEv+0x10a>
        }
    }
ffffffff8100837e:	5b                   	pop    %rbx
ffffffff8100837f:	c3                   	retq   

ffffffff81008380 <_GLOBAL__sub_I.00102__ZN6Ioapic5cacheE>:
#include "ioapic.hpp"
#include "pd.hpp"
#include "stdio.hpp"

INIT_PRIORITY (PRIO_SLAB)
Slab_cache Ioapic::cache (sizeof (Ioapic), 8);
ffffffff81008380:	ba 08 00 00 00       	mov    $0x8,%edx
ffffffff81008385:	be 20 00 00 00       	mov    $0x20,%esi
ffffffff8100838a:	48 c7 c7 40 38 16 81 	mov    $0xffffffff81163840,%rdi
ffffffff81008391:	e9 0a d5 00 00       	jmpq   ffffffff810158a0 <_ZN10Slab_cacheC1Emj>

ffffffff81008396 <_ZN4Keyb9interruptEv>:
}

void Keyb::interrupt()
{
ffffffff81008396:	53                   	push   %rbx
ffffffff81008397:	b3 0c                	mov    $0xc,%bl
        template <typename T>
        ALWAYS_INLINE
        static inline unsigned in (unsigned port)
        {
            T val;
            asm volatile ("in %w1, %0" : "=a" (val) : "Nd" (port));
ffffffff81008399:	e4 64                	in     $0x64,%al
    unsigned sts;

    while ((sts = status()) & STS_OUTB) {
ffffffff8100839b:	a8 01                	test   $0x1,%al
ffffffff8100839d:	88 c1                	mov    %al,%cl
ffffffff8100839f:	74 63                	je     ffffffff81008404 <_ZN4Keyb9interruptEv+0x6e>
ffffffff810083a1:	e4 60                	in     $0x60,%al

        unsigned out = output();

        if (sts & STS_AUXB)
ffffffff810083a3:	80 e1 20             	and    $0x20,%cl
ffffffff810083a6:	75 f1                	jne    ffffffff81008399 <_ZN4Keyb9interruptEv+0x3>
            continue;

        if (out & 0x80)
ffffffff810083a8:	84 c0                	test   %al,%al
            return val;
ffffffff810083aa:	0f b6 c8             	movzbl %al,%ecx
ffffffff810083ad:	78 ea                	js     ffffffff81008399 <_ZN4Keyb9interruptEv+0x3>
            continue;

        switch (out) {
ffffffff810083af:	3c 2e                	cmp    $0x2e,%al
ffffffff810083b1:	74 47                	je     ffffffff810083fa <_ZN4Keyb9interruptEv+0x64>
ffffffff810083b3:	77 12                	ja     ffffffff810083c7 <_ZN4Keyb9interruptEv+0x31>
ffffffff810083b5:	fe c8                	dec    %al
ffffffff810083b7:	75 e0                	jne    ffffffff81008399 <_ZN4Keyb9interruptEv+0x3>
            case 0x1:               // esc
                Acpi::reset();
ffffffff810083b9:	e8 7e 8a ff ff       	callq  ffffffff81000e3c <_ZN4Acpi5resetEv>

        template <typename T>
        ALWAYS_INLINE
        static inline void out (unsigned port, T val)
        {
            asm volatile ("out %0, %w1" : : "a" (val), "Nd" (port));
ffffffff810083be:	ba f9 0c 00 00       	mov    $0xcf9,%edx
ffffffff810083c3:	b0 06                	mov    $0x6,%al
ffffffff810083c5:	eb 3a                	jmp    ffffffff81008401 <_ZN4Keyb9interruptEv+0x6b>
            continue;

        if (out & 0x80)
            continue;

        switch (out) {
ffffffff810083c7:	8d 50 c5             	lea    -0x3b(%rax),%edx
ffffffff810083ca:	80 fa 07             	cmp    $0x7,%dl
ffffffff810083cd:	77 ca                	ja     ffffffff81008399 <_ZN4Keyb9interruptEv+0x3>
ffffffff810083cf:	bf d4 03 00 00       	mov    $0x3d4,%edi
ffffffff810083d4:	88 d8                	mov    %bl,%al
ffffffff810083d6:	89 fa                	mov    %edi,%edx
ffffffff810083d8:	ee                   	out    %al,(%dx)
        }

        ALWAYS_INLINE
        static inline void set_page (unsigned page)
        {
            page <<= 11;    // due to odd/even addressing
ffffffff810083d9:	8d 0c cd 28 fe ff 00 	lea    0xfffe28(,%rcx,8),%ecx
ffffffff810083e0:	be d5 03 00 00       	mov    $0x3d5,%esi
ffffffff810083e5:	89 f2                	mov    %esi,%edx
            write (START_ADDR_HI, static_cast<uint8>(page >> 8));
ffffffff810083e7:	89 c8                	mov    %ecx,%eax
ffffffff810083e9:	25 f8 ff ff 00       	and    $0xfffff8,%eax
ffffffff810083ee:	ee                   	out    %al,(%dx)
ffffffff810083ef:	b0 0d                	mov    $0xd,%al
ffffffff810083f1:	89 fa                	mov    %edi,%edx
ffffffff810083f3:	ee                   	out    %al,(%dx)
ffffffff810083f4:	31 c0                	xor    %eax,%eax
ffffffff810083f6:	89 f2                	mov    %esi,%edx
ffffffff810083f8:	eb 07                	jmp    ffffffff81008401 <_ZN4Keyb9interruptEv+0x6b>
            case 0x1:               // esc
                Acpi::reset();
                Io::out<uint8>(0xcf9, 0x6);
                break;
            case 0x2e:              // c
                Counter::dump();
ffffffff810083fa:	e8 e5 9e ff ff       	callq  ffffffff810022e4 <_ZN7Counter4dumpEv>
                break;
ffffffff810083ff:	eb 98                	jmp    ffffffff81008399 <_ZN4Keyb9interruptEv+0x3>
ffffffff81008401:	ee                   	out    %al,(%dx)
ffffffff81008402:	eb 95                	jmp    ffffffff81008399 <_ZN4Keyb9interruptEv+0x3>
            case 0x3b ... 0x42:     // f1-f8
                Console_vga::con.set_page (out - 0x3b);
                break;
        }
    }
}
ffffffff81008404:	5b                   	pop    %rbx
ffffffff81008405:	c3                   	retq   

ffffffff81008406 <_ZN7Counter5printILj1ELj16EEEvmN11Console_vga5ColorEj.part.4>:
ffffffff81008406:	8b 05 84 73 ff 3e    	mov    0x3eff7384(%rip),%eax        # ffffffffbffff790 <_ZN3Cpu3rowE>
ffffffff8100840c:	89 d2                	mov    %edx,%edx
ffffffff8100840e:	83 e7 0f             	and    $0xf,%edi
        inline unsigned spinner (unsigned id) { return id < 25 - num ? 24 - id : 0; }

        ALWAYS_INLINE
        inline void put (unsigned long r, unsigned long c, Color color, int x)
        {
            *reinterpret_cast<unsigned short volatile *>(HV_GLOBAL_FBUF + r * 160 + c * 2) = static_cast<unsigned short>(color << 8 | x);
ffffffff81008411:	c1 e6 08             	shl    $0x8,%esi
ffffffff81008414:	48 6b c0 50          	imul   $0x50,%rax,%rax
ffffffff81008418:	48 01 c2             	add    %rax,%rdx
ffffffff8100841b:	66 0f be 87 d8 d7 01 	movsbw -0x7efe2828(%rdi),%ax
ffffffff81008422:	81 
ffffffff81008423:	09 c6                	or     %eax,%esi
ffffffff81008425:	66 89 b4 12 00 f0 df 	mov    %si,-0x40201000(%rdx,%rdx,1)
ffffffff8100842c:	bf 
ffffffff8100842d:	c3                   	retq   

ffffffff8100842e <_ZN5Lapic8send_ipiEjjNS_13Delivery_modeENS_9ShorthandE>:
        };

        ALWAYS_INLINE
        static inline uint32 read (Register reg)
        {
            return *reinterpret_cast<uint32 volatile *>(CPU_LOCAL_APIC + (reg << 4));
ffffffff8100842e:	8b 04 25 00 e3 ff bf 	mov    0xffffffffbfffe300,%eax
    trace (TRACE_APIC, "APIC:%#lx ID:%#x VER:%#x LVT:%#x (%s Mode)", apic_base & ~PAGE_MASK, id(), version(), lvt_max(), freq_bus ? "OS" : "DL");
}

void Lapic::send_ipi (unsigned cpu, unsigned vector, Delivery_mode dlv, Shorthand dsh)
{
    while (EXPECT_FALSE (read (LAPIC_ICR_LO) & 1U << 12))
ffffffff81008435:	f6 c4 10             	test   $0x10,%ah
ffffffff81008438:	74 04                	je     ffffffff8100843e <_ZN5Lapic8send_ipiEjjNS_13Delivery_modeENS_9ShorthandE+0x10>
}

ALWAYS_INLINE
static inline void pause()
{
    asm volatile ("pause" : : : "memory");
ffffffff8100843a:	f3 90                	pause  
ffffffff8100843c:	eb f0                	jmp    ffffffff8100842e <_ZN5Lapic8send_ipiEjjNS_13Delivery_modeENS_9ShorthandE>
        pause();

    write (LAPIC_ICR_HI, Cpu::apic_id[cpu] << 24);
ffffffff8100843e:	89 ff                	mov    %edi,%edi
ffffffff81008440:	81 ce 00 40 00 00    	or     $0x4000,%esi
ffffffff81008446:	0f b6 87 c0 1f 16 81 	movzbl -0x7ee9e040(%rdi),%eax
ffffffff8100844d:	09 f2                	or     %esi,%edx
    write (LAPIC_ICR_LO, dsh | 1U << 14 | dlv | vector);
ffffffff8100844f:	09 d1                	or     %edx,%ecx
void Lapic::send_ipi (unsigned cpu, unsigned vector, Delivery_mode dlv, Shorthand dsh)
{
    while (EXPECT_FALSE (read (LAPIC_ICR_LO) & 1U << 12))
        pause();

    write (LAPIC_ICR_HI, Cpu::apic_id[cpu] << 24);
ffffffff81008451:	c1 e0 18             	shl    $0x18,%eax
        }

        ALWAYS_INLINE
        static inline void write (Register reg, uint32 val)
        {
            *reinterpret_cast<uint32 volatile *>(CPU_LOCAL_APIC + (reg << 4)) = val;
ffffffff81008454:	89 04 25 10 e3 ff bf 	mov    %eax,0xffffffffbfffe310
ffffffff8100845b:	89 0c 25 00 e3 ff bf 	mov    %ecx,0xffffffffbfffe300
ffffffff81008462:	c3                   	retq   
ffffffff81008463:	90                   	nop

ffffffff81008464 <_ZN5Lapic4initEv>:

unsigned    Lapic::freq_tsc;
unsigned    Lapic::freq_bus;

void Lapic::init()
{
ffffffff81008464:	55                   	push   %rbp
ffffffff81008465:	53                   	push   %rbx
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
ffffffff81008466:	bd 1b 00 00 00       	mov    $0x1b,%ebp
ffffffff8100846b:	89 e9                	mov    %ebp,%ecx
ffffffff8100846d:	48 83 ec 28          	sub    $0x28,%rsp
ffffffff81008471:	0f 32                	rdmsr  
            return static_cast<T>(static_cast<uint64>(h) << 32 | l);
ffffffff81008473:	48 c1 e2 20          	shl    $0x20,%rdx
    Paddr apic_base = Msr::read<Paddr>(Msr::IA32_APIC_BASE);

    Pd::kern.Space_mem::delreg (Pd::kern.quota, apic_base & ~PAGE_MASK);
ffffffff81008477:	48 c7 c6 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rsi
ffffffff8100847e:	48 c7 c7 30 3d 16 81 	mov    $0xffffffff81163d30,%rdi
ffffffff81008485:	48 89 d3             	mov    %rdx,%rbx
ffffffff81008488:	48 09 c3             	or     %rax,%rbx
ffffffff8100848b:	49 89 d9             	mov    %rbx,%r9
ffffffff8100848e:	49 81 e1 00 f0 ff ff 	and    $0xfffffffffffff000,%r9
ffffffff81008495:	4c 89 ca             	mov    %r9,%rdx
ffffffff81008498:	4c 89 4c 24 08       	mov    %r9,0x8(%rsp)
ffffffff8100849d:	e8 ec aa ff ff       	callq  ffffffff81002f8e <_ZN5Space6delregER5Quotam>
    }

    ALWAYS_INLINE
    static inline mword current() {
        mword addr;
        asm volatile ("mov %%cr3, %0" : "=r" (addr));
ffffffff810084a2:	0f 20 d8             	mov    %cr3,%rax
class Hptp : public Hpt {
public:

    ALWAYS_INLINE
    inline explicit Hptp(mword v = 0) {
        val = v;
ffffffff810084a5:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    Hptp (Hpt::current()).update (Pd::kern.quota, CPU_LOCAL_APIC, 0, Hpt::HPT_NX | Hpt::HPT_G | Hpt::HPT_UC | Hpt::HPT_W | Hpt::HPT_P, apic_base & ~PAGE_MASK);
ffffffff810084aa:	6a 00                	pushq  $0x0
ffffffff810084ac:	31 c9                	xor    %ecx,%ecx
ffffffff810084ae:	6a 00                	pushq  $0x0
ffffffff810084b0:	4c 8b 4c 24 18       	mov    0x18(%rsp),%r9
ffffffff810084b5:	41 b8 13 01 00 00    	mov    $0x113,%r8d
ffffffff810084bb:	48 c7 c2 00 e0 ff bf 	mov    $0xffffffffbfffe000,%rdx
ffffffff810084c2:	48 c7 c6 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rsi
ffffffff810084c9:	48 8d 7c 24 28       	lea    0x28(%rsp),%rdi
ffffffff810084ce:	e8 43 a8 00 00       	callq  ffffffff81012d16 <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb>

    Msr::write (Msr::IA32_APIC_BASE, apic_base | 0x800);
ffffffff810084d3:	48 89 d8             	mov    %rbx,%rax

        template <typename T>
        ALWAYS_INLINE
        static inline void write (Register msr, T val)
        {
            asm volatile ("wrmsr" : : "a" (static_cast<mword>(val)), "d" (static_cast<mword>(static_cast<uint64>(val) >> 32)), "c" (msr));
ffffffff810084d6:	89 e9                	mov    %ebp,%ecx
ffffffff810084d8:	80 cc 08             	or     $0x8,%ah
ffffffff810084db:	48 89 c2             	mov    %rax,%rdx
ffffffff810084de:	48 c1 ea 20          	shr    $0x20,%rdx
ffffffff810084e2:	0f 30                	wrmsr  
        };

        ALWAYS_INLINE
        static inline uint32 read (Register reg)
        {
            return *reinterpret_cast<uint32 volatile *>(CPU_LOCAL_APIC + (reg << 4));
ffffffff810084e4:	8b 04 25 f0 e0 ff bf 	mov    0xffffffffbfffe0f0,%eax

    uint32 svr = read (LAPIC_SVR);
    if (!(svr & 0x100))
ffffffff810084eb:	5a                   	pop    %rdx
ffffffff810084ec:	59                   	pop    %rcx
ffffffff810084ed:	f6 c4 01             	test   $0x1,%ah
ffffffff810084f0:	75 0a                	jne    ffffffff810084fc <_ZN5Lapic4initEv+0x98>
        write (LAPIC_SVR, svr | 0x100);
ffffffff810084f2:	80 cc 01             	or     $0x1,%ah
        }

        ALWAYS_INLINE
        static inline void write (Register reg, uint32 val)
        {
            *reinterpret_cast<uint32 volatile *>(CPU_LOCAL_APIC + (reg << 4)) = val;
ffffffff810084f5:	89 04 25 f0 e0 ff bf 	mov    %eax,0xffffffffbfffe0f0

    bool dl = Cpu::feature (Cpu::FEAT_TSC_DEADLINE) && !Cmdline::nodl;
ffffffff810084fc:	31 d2                	xor    %edx,%edx
ffffffff810084fe:	f6 05 42 72 ff 3e 01 	testb  $0x1,0x3eff7242(%rip)        # ffffffffbffff747 <_ZN3Cpu8featuresE+0x7>
ffffffff81008505:	74 09                	je     ffffffff81008510 <_ZN5Lapic4initEv+0xac>
ffffffff81008507:	8a 15 8e 98 01 00    	mov    0x1988e(%rip),%dl        # ffffffff81021d9b <_ZN7Cmdline4nodlE>
ffffffff8100850d:	83 f2 01             	xor    $0x1,%edx
        };

        ALWAYS_INLINE
        static inline uint32 read (Register reg)
        {
            return *reinterpret_cast<uint32 volatile *>(CPU_LOCAL_APIC + (reg << 4));
ffffffff81008510:	8b 04 25 30 e0 ff bf 	mov    0xffffffffbfffe030,%eax
        }

        ALWAYS_INLINE
        static inline unsigned lvt_max()
        {
            return read (LAPIC_LVR) >> 16 & 0xff;
ffffffff81008517:	c1 e8 10             	shr    $0x10,%eax
ffffffff8100851a:	0f b6 c0             	movzbl %al,%eax

    switch (lvt_max()) {
ffffffff8100851d:	83 f8 04             	cmp    $0x4,%eax
ffffffff81008520:	77 07                	ja     ffffffff81008529 <_ZN5Lapic4initEv+0xc5>
ffffffff81008522:	ff 24 c5 a8 e5 01 81 	jmpq   *-0x7efe1a58(,%rax,8)
        }

        ALWAYS_INLINE
        static inline void write (Register reg, uint32 val)
        {
            *reinterpret_cast<uint32 volatile *>(CPU_LOCAL_APIC + (reg << 4)) = val;
ffffffff81008529:	c7 04 25 30 e3 ff bf 	movl   $0xa5,0xffffffffbfffe330
ffffffff81008530:	a5 00 00 00 
ffffffff81008534:	c7 04 25 40 e3 ff bf 	movl   $0xa4,0xffffffffbfffe340
ffffffff8100853b:	a4 00 00 00 
ffffffff8100853f:	c7 04 25 70 e3 ff bf 	movl   $0xa3,0xffffffffbfffe370
ffffffff81008546:	a3 00 00 00 
ffffffff8100854a:	c7 04 25 60 e3 ff bf 	movl   $0x400,0xffffffffbfffe360
ffffffff81008551:	00 04 00 00 
ffffffff81008555:	c7 04 25 50 e3 ff bf 	movl   $0x10700,0xffffffffbfffe350
ffffffff8100855c:	00 07 01 00 
        case 2:
            set_lvt (LAPIC_LVT_LINT1, DLV_NMI, 0);
        case 1:
            set_lvt (LAPIC_LVT_LINT0, DLV_EXTINT, 0, 1U << 16);
        case 0:
            set_lvt (LAPIC_LVT_TIMER, DLV_FIXED, VEC_LVT_TIMER, dl ? 2U << 17 : 0);
ffffffff81008560:	80 fa 01             	cmp    $0x1,%dl
ffffffff81008563:	19 c0                	sbb    %eax,%eax
ffffffff81008565:	f7 d0                	not    %eax
ffffffff81008567:	25 00 00 04 00       	and    $0x40000,%eax
        }

        ALWAYS_INLINE
        static inline void set_lvt (Register reg, Delivery_mode dlv, unsigned vector, unsigned misc = 0)
        {
            write (reg, misc | dlv | vector);
ffffffff8100856c:	0c a0                	or     $0xa0,%al
        }

        ALWAYS_INLINE
        static inline void write (Register reg, uint32 val)
        {
            *reinterpret_cast<uint32 volatile *>(CPU_LOCAL_APIC + (reg << 4)) = val;
ffffffff8100856e:	89 04 25 20 e3 ff bf 	mov    %eax,0xffffffffbfffe320
ffffffff81008575:	c7 04 25 80 e0 ff bf 	movl   $0x10,0xffffffffbfffe080
ffffffff8100857c:	10 00 00 00 
        static unsigned freq_bus;

        ALWAYS_INLINE
        static inline unsigned id()
        {
            return read (LAPIC_IDR) >> 24 & 0xff;
ffffffff81008580:	31 c0                	xor    %eax,%eax
        }

        ALWAYS_INLINE
        static inline void write (Register reg, uint32 val)
        {
            *reinterpret_cast<uint32 volatile *>(CPU_LOCAL_APIC + (reg << 4)) = val;
ffffffff81008582:	c7 04 25 e0 e3 ff bf 	movl   $0xb,0xffffffffbfffe3e0
ffffffff81008589:	0b 00 00 00 
        };

        ALWAYS_INLINE
        static inline uint32 read (Register reg)
        {
            return *reinterpret_cast<uint32 volatile *>(CPU_LOCAL_APIC + (reg << 4));
ffffffff8100858d:	8b 14 25 20 e0 ff bf 	mov    0xffffffffbfffe020,%edx
        static unsigned freq_bus;

        ALWAYS_INLINE
        static inline unsigned id()
        {
            return read (LAPIC_IDR) >> 24 & 0xff;
ffffffff81008594:	c1 ea 18             	shr    $0x18,%edx

        ALWAYS_INLINE
        static unsigned find_by_apic_id (unsigned x)
        {
            for (unsigned i = 0; i < NUM_CPU; i++)
                if (apic_id[i] == x)
ffffffff81008597:	0f b6 88 c0 1f 16 81 	movzbl -0x7ee9e040(%rax),%ecx
ffffffff8100859e:	39 d1                	cmp    %edx,%ecx
ffffffff810085a0:	74 0c                	je     ffffffff810085ae <_ZN5Lapic4initEv+0x14a>
ffffffff810085a2:	48 ff c0             	inc    %rax
        }

        ALWAYS_INLINE
        static unsigned find_by_apic_id (unsigned x)
        {
            for (unsigned i = 0; i < NUM_CPU; i++)
ffffffff810085a5:	48 83 f8 40          	cmp    $0x40,%rax
ffffffff810085a9:	75 ec                	jne    ffffffff81008597 <_ZN5Lapic4initEv+0x133>
                if (apic_id[i] == x)
                    return i;

            return ~0U;
ffffffff810085ab:	83 c8 ff             	or     $0xffffffff,%eax
    write (LAPIC_TPR, 0x10);
    write (LAPIC_TMR_DCR, 0xb);

    Cpu::id = Cpu::find_by_apic_id (id());

    if ((Cpu::bsp = apic_base & 0x100)) {
ffffffff810085ae:	48 c1 eb 08          	shr    $0x8,%rbx
    }

    write (LAPIC_TPR, 0x10);
    write (LAPIC_TMR_DCR, 0xb);

    Cpu::id = Cpu::find_by_apic_id (id());
ffffffff810085b2:	89 05 4c 6a ff 3e    	mov    %eax,0x3eff6a4c(%rip)        # ffffffffbffff004 <_ZN3Cpu2idE>

    if ((Cpu::bsp = apic_base & 0x100)) {
ffffffff810085b8:	83 e3 01             	and    $0x1,%ebx
ffffffff810085bb:	84 db                	test   %bl,%bl
ffffffff810085bd:	88 1d 6e 71 ff 3e    	mov    %bl,0x3eff716e(%rip)        # ffffffffbffff731 <_ZN3Cpu3bspE>
ffffffff810085c3:	0f 84 92 00 00 00    	je     ffffffff8100865b <_ZN5Lapic4initEv+0x1f7>

        send_ipi (0, 0, DLV_INIT, DSH_EXC_SELF);
ffffffff810085c9:	b9 00 00 0c 00       	mov    $0xc0000,%ecx
ffffffff810085ce:	ba 00 05 00 00       	mov    $0x500,%edx
ffffffff810085d3:	31 f6                	xor    %esi,%esi
ffffffff810085d5:	31 ff                	xor    %edi,%edi
ffffffff810085d7:	e8 52 fe ff ff       	callq  ffffffff8100842e <_ZN5Lapic8send_ipiEjjNS_13Delivery_modeENS_9ShorthandE>
        }

        ALWAYS_INLINE
        static inline void write (Register reg, uint32 val)
        {
            *reinterpret_cast<uint32 volatile *>(CPU_LOCAL_APIC + (reg << 4)) = val;
ffffffff810085dc:	c7 04 25 80 e3 ff bf 	movl   $0xffffffff,0xffffffffbfffe380
ffffffff810085e3:	ff ff ff ff 
        };

        ALWAYS_INLINE
        static inline uint32 read (Register reg)
        {
            return *reinterpret_cast<uint32 volatile *>(CPU_LOCAL_APIC + (reg << 4));
ffffffff810085e7:	8b 1c 25 90 e3 ff bf 	mov    0xffffffffbfffe390,%ebx

ALWAYS_INLINE
static inline uint64 rdtsc()
{
    mword h, l;
    asm volatile ("rdtsc" : "=a" (l), "=d" (h));
ffffffff810085ee:	0f 31                	rdtsc  

        write (LAPIC_TMR_ICR, ~0U);

        uint32 v1 = read (LAPIC_TMR_CCR);
        uint32 t1 = static_cast<uint32>(rdtsc());
        Acpi::delay (10);
ffffffff810085f0:	bf 0a 00 00 00       	mov    $0xa,%edi
ffffffff810085f5:	48 89 c5             	mov    %rax,%rbp
ffffffff810085f8:	e8 b3 86 ff ff       	callq  ffffffff81000cb0 <_ZN4Acpi5delayEj>
ffffffff810085fd:	8b 34 25 90 e3 ff bf 	mov    0xffffffffbfffe390,%esi
ffffffff81008604:	0f 31                	rdtsc  
        uint32 v2 = read (LAPIC_TMR_CCR);
        uint32 t2 = static_cast<uint32>(rdtsc());

        freq_tsc = (t2 - t1) / 10;
ffffffff81008606:	b9 0a 00 00 00       	mov    $0xa,%ecx
ffffffff8100860b:	29 e8                	sub    %ebp,%eax
ffffffff8100860d:	31 d2                	xor    %edx,%edx
ffffffff8100860f:	f7 f1                	div    %ecx
        freq_bus = (v1 - v2) / 10;
ffffffff81008611:	31 d2                	xor    %edx,%edx

        trace (TRACE_APIC, "TSC:%u kHz BUS:%u kHz", freq_tsc, freq_bus);

        send_ipi (0, 1, DLV_SIPI, DSH_EXC_SELF);
ffffffff81008613:	31 ff                	xor    %edi,%edi
        uint32 t1 = static_cast<uint32>(rdtsc());
        Acpi::delay (10);
        uint32 v2 = read (LAPIC_TMR_CCR);
        uint32 t2 = static_cast<uint32>(rdtsc());

        freq_tsc = (t2 - t1) / 10;
ffffffff81008615:	89 05 59 b2 15 00    	mov    %eax,0x15b259(%rip)        # ffffffff81163874 <_ZN5Lapic8freq_tscE>
        freq_bus = (v1 - v2) / 10;
ffffffff8100861b:	89 d8                	mov    %ebx,%eax
ffffffff8100861d:	29 f0                	sub    %esi,%eax

        trace (TRACE_APIC, "TSC:%u kHz BUS:%u kHz", freq_tsc, freq_bus);

        send_ipi (0, 1, DLV_SIPI, DSH_EXC_SELF);
ffffffff8100861f:	be 01 00 00 00       	mov    $0x1,%esi
        Acpi::delay (10);
        uint32 v2 = read (LAPIC_TMR_CCR);
        uint32 t2 = static_cast<uint32>(rdtsc());

        freq_tsc = (t2 - t1) / 10;
        freq_bus = (v1 - v2) / 10;
ffffffff81008624:	f7 f1                	div    %ecx

        trace (TRACE_APIC, "TSC:%u kHz BUS:%u kHz", freq_tsc, freq_bus);

        send_ipi (0, 1, DLV_SIPI, DSH_EXC_SELF);
ffffffff81008626:	b9 00 00 0c 00       	mov    $0xc0000,%ecx
ffffffff8100862b:	ba 00 06 00 00       	mov    $0x600,%edx
        Acpi::delay (10);
        uint32 v2 = read (LAPIC_TMR_CCR);
        uint32 t2 = static_cast<uint32>(rdtsc());

        freq_tsc = (t2 - t1) / 10;
        freq_bus = (v1 - v2) / 10;
ffffffff81008630:	89 05 3a b2 15 00    	mov    %eax,0x15b23a(%rip)        # ffffffff81163870 <_ZN5Lapic8freq_busE>

        trace (TRACE_APIC, "TSC:%u kHz BUS:%u kHz", freq_tsc, freq_bus);

        send_ipi (0, 1, DLV_SIPI, DSH_EXC_SELF);
ffffffff81008636:	e8 f3 fd ff ff       	callq  ffffffff8100842e <_ZN5Lapic8send_ipiEjjNS_13Delivery_modeENS_9ShorthandE>
        Acpi::delay (1);
ffffffff8100863b:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff81008640:	e8 6b 86 ff ff       	callq  ffffffff81000cb0 <_ZN4Acpi5delayEj>
        send_ipi (0, 1, DLV_SIPI, DSH_EXC_SELF);
ffffffff81008645:	b9 00 00 0c 00       	mov    $0xc0000,%ecx
ffffffff8100864a:	ba 00 06 00 00       	mov    $0x600,%edx
ffffffff8100864f:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff81008654:	31 ff                	xor    %edi,%edi
ffffffff81008656:	e8 d3 fd ff ff       	callq  ffffffff8100842e <_ZN5Lapic8send_ipiEjjNS_13Delivery_modeENS_9ShorthandE>
        }

        ALWAYS_INLINE
        static inline void write (Register reg, uint32 val)
        {
            *reinterpret_cast<uint32 volatile *>(CPU_LOCAL_APIC + (reg << 4)) = val;
ffffffff8100865b:	c7 04 25 80 e3 ff bf 	movl   $0x0,0xffffffffbfffe380
ffffffff81008662:	00 00 00 00 
    }

    write (LAPIC_TMR_ICR, 0);

    trace (TRACE_APIC, "APIC:%#lx ID:%#x VER:%#x LVT:%#x (%s Mode)", apic_base & ~PAGE_MASK, id(), version(), lvt_max(), freq_bus ? "OS" : "DL");
}
ffffffff81008666:	48 83 c4 28          	add    $0x28,%rsp
ffffffff8100866a:	5b                   	pop    %rbx
ffffffff8100866b:	5d                   	pop    %rbp
ffffffff8100866c:	c3                   	retq   
ffffffff8100866d:	90                   	nop

ffffffff8100866e <lvt_vector>:

void Lapic::lvt_vector (unsigned vector)
{
    unsigned lvt = vector - VEC_LVT;

    switch (vector) {
ffffffff8100866e:	81 ff a0 00 00 00    	cmp    $0xa0,%edi

    Rcu::update();
}

void Lapic::lvt_vector (unsigned vector)
{
ffffffff81008674:	55                   	push   %rbp
ffffffff81008675:	53                   	push   %rbx
    unsigned lvt = vector - VEC_LVT;
ffffffff81008676:	8d af 60 ff ff ff    	lea    -0xa0(%rdi),%ebp

    Rcu::update();
}

void Lapic::lvt_vector (unsigned vector)
{
ffffffff8100867c:	56                   	push   %rsi
ffffffff8100867d:	89 fb                	mov    %edi,%ebx
    unsigned lvt = vector - VEC_LVT;

    switch (vector) {
ffffffff8100867f:	74 20                	je     ffffffff810086a1 <lvt_vector+0x33>
ffffffff81008681:	81 ff a3 00 00 00    	cmp    $0xa3,%edi
ffffffff81008687:	75 4e                	jne    ffffffff810086d7 <lvt_vector+0x69>
ffffffff81008689:	c7 04 25 80 e2 ff bf 	movl   $0x0,0xffffffffbfffe280
ffffffff81008690:	00 00 00 00 
ffffffff81008694:	c7 04 25 80 e2 ff bf 	movl   $0x0,0xffffffffbfffe280
ffffffff8100869b:	00 00 00 00 
ffffffff8100869f:	eb 36                	jmp    ffffffff810086d7 <lvt_vector+0x69>
    write (LAPIC_ESR, 0);
}

void Lapic::timer_handler()
{
    bool expired = (freq_bus ? read (LAPIC_TMR_CCR) : Msr::read<uint64>(Msr::IA32_TSC_DEADLINE)) == 0;
ffffffff810086a1:	83 3d c8 b1 15 00 00 	cmpl   $0x0,0x15b1c8(%rip)        # ffffffff81163870 <_ZN5Lapic8freq_busE>
ffffffff810086a8:	74 0b                	je     ffffffff810086b5 <lvt_vector+0x47>
        };

        ALWAYS_INLINE
        static inline uint32 read (Register reg)
        {
            return *reinterpret_cast<uint32 volatile *>(CPU_LOCAL_APIC + (reg << 4));
ffffffff810086aa:	8b 04 25 90 e3 ff bf 	mov    0xffffffffbfffe390,%eax
ffffffff810086b1:	85 c0                	test   %eax,%eax
ffffffff810086b3:	eb 11                	jmp    ffffffff810086c6 <lvt_vector+0x58>
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
ffffffff810086b5:	b9 e0 06 00 00       	mov    $0x6e0,%ecx
ffffffff810086ba:	0f 32                	rdmsr  
            return static_cast<T>(static_cast<uint64>(h) << 32 | l);
ffffffff810086bc:	48 89 d1             	mov    %rdx,%rcx
ffffffff810086bf:	48 c1 e1 20          	shl    $0x20,%rcx
ffffffff810086c3:	48 09 c1             	or     %rax,%rcx
ffffffff810086c6:	0f 94 c0             	sete   %al
    if (expired)
ffffffff810086c9:	84 c0                	test   %al,%al
ffffffff810086cb:	74 05                	je     ffffffff810086d2 <lvt_vector+0x64>
        Timeout::check();
ffffffff810086cd:	e8 dc 23 01 00       	callq  ffffffff8101aaae <_ZN7Timeout5checkEv>

    Rcu::update();
ffffffff810086d2:	e8 c3 a8 00 00       	callq  ffffffff81012f9a <_ZN3Rcu6updateEv>
        case VEC_LVT_THERM: therm_handler(); break;
    }

    eoi();

    Counter::print<1,16> (++Counter::lvt[lvt], Console_vga::COLOR_LIGHT_BLUE, lvt + SPN_LVT);
ffffffff810086d7:	89 ea                	mov    %ebp,%edx
        }

        ALWAYS_INLINE
        static inline void write (Register reg, uint32 val)
        {
            *reinterpret_cast<uint32 volatile *>(CPU_LOCAL_APIC + (reg << 4)) = val;
ffffffff810086d9:	c7 04 25 b0 e0 ff bf 	movl   $0x0,0xffffffffbfffe0b0
ffffffff810086e0:	00 00 00 00 
ffffffff810086e4:	8b 04 95 00 f7 ff bf 	mov    -0x40000900(,%rdx,4),%eax
ffffffff810086eb:	ff c0                	inc    %eax
        }

        template <unsigned D, unsigned B>
        static void print (mword val, Console_vga::Color c, unsigned col)
        {
            if (EXPECT_FALSE (Cpu::row))
ffffffff810086ed:	83 3d 9c 70 ff 3e 00 	cmpl   $0x0,0x3eff709c(%rip)        # ffffffffbffff790 <_ZN3Cpu3rowE>
ffffffff810086f4:	89 04 95 00 f7 ff bf 	mov    %eax,-0x40000900(,%rdx,4)
ffffffff810086fb:	74 15                	je     ffffffff81008712 <lvt_vector+0xa4>
}
ffffffff810086fd:	59                   	pop    %rcx
        case VEC_LVT_THERM: therm_handler(); break;
    }

    eoi();

    Counter::print<1,16> (++Counter::lvt[lvt], Console_vga::COLOR_LIGHT_BLUE, lvt + SPN_LVT);
ffffffff810086fe:	8d 93 67 ff ff ff    	lea    -0x99(%rbx),%edx
ffffffff81008704:	89 c7                	mov    %eax,%edi
ffffffff81008706:	be 09 00 00 00       	mov    $0x9,%esi
}
ffffffff8100870b:	5b                   	pop    %rbx
ffffffff8100870c:	5d                   	pop    %rbp
ffffffff8100870d:	e9 f4 fc ff ff       	jmpq   ffffffff81008406 <_ZN7Counter5printILj1ELj16EEEvmN11Console_vga5ColorEj.part.4>
ffffffff81008712:	58                   	pop    %rax
ffffffff81008713:	5b                   	pop    %rbx
ffffffff81008714:	5d                   	pop    %rbp
ffffffff81008715:	c3                   	retq   

ffffffff81008716 <ipi_vector>:

void Lapic::ipi_vector (unsigned vector)
{
    unsigned ipi = vector - VEC_IPI;

    switch (vector) {
ffffffff81008716:	81 ff a8 00 00 00    	cmp    $0xa8,%edi

    Counter::print<1,16> (++Counter::lvt[lvt], Console_vga::COLOR_LIGHT_BLUE, lvt + SPN_LVT);
}

void Lapic::ipi_vector (unsigned vector)
{
ffffffff8100871c:	55                   	push   %rbp
ffffffff8100871d:	53                   	push   %rbx
    unsigned ipi = vector - VEC_IPI;
ffffffff8100871e:	8d af 59 ff ff ff    	lea    -0xa7(%rdi),%ebp

    Counter::print<1,16> (++Counter::lvt[lvt], Console_vga::COLOR_LIGHT_BLUE, lvt + SPN_LVT);
}

void Lapic::ipi_vector (unsigned vector)
{
ffffffff81008724:	56                   	push   %rsi
ffffffff81008725:	89 fb                	mov    %edi,%ebx
    unsigned ipi = vector - VEC_IPI;

    switch (vector) {
ffffffff81008727:	74 17                	je     ffffffff81008740 <ipi_vector+0x2a>
ffffffff81008729:	81 ff a9 00 00 00    	cmp    $0xa9,%edi
ffffffff8100872f:	74 16                	je     ffffffff81008747 <ipi_vector+0x31>
ffffffff81008731:	81 ff a7 00 00 00    	cmp    $0xa7,%edi
ffffffff81008737:	75 13                	jne    ffffffff8100874c <ipi_vector+0x36>
        case VEC_IPI_RRQ: Sc::rrq_handler(); break;
ffffffff81008739:	e8 b4 c4 00 00       	callq  ffffffff81014bf2 <_ZN2Sc11rrq_handlerEv>
ffffffff8100873e:	eb 0c                	jmp    ffffffff8100874c <ipi_vector+0x36>
        case VEC_IPI_RKE: Sc::rke_handler(); break;
ffffffff81008740:	e8 c3 c5 00 00       	callq  ffffffff81014d08 <_ZN2Sc11rke_handlerEv>
ffffffff81008745:	eb 05                	jmp    ffffffff8100874c <ipi_vector+0x36>
        case VEC_IPI_IDL: Ec::idl_handler(); break;
ffffffff81008747:	e8 d0 d0 ff ff       	callq  ffffffff8100581c <_ZN2Ec11idl_handlerEv>
    }

    eoi();

    Counter::print<1,16> (++Counter::ipi[ipi], Console_vga::COLOR_LIGHT_GREEN, ipi + SPN_IPI);
ffffffff8100874c:	89 e8                	mov    %ebp,%eax
ffffffff8100874e:	c7 04 25 b0 e0 ff bf 	movl   $0x0,0xffffffffbfffe0b0
ffffffff81008755:	00 00 00 00 
ffffffff81008759:	83 3d 30 70 ff 3e 00 	cmpl   $0x0,0x3eff7030(%rip)        # ffffffffbffff790 <_ZN3Cpu3rowE>
ffffffff81008760:	8b 0c 85 18 f7 ff bf 	mov    -0x400008e8(,%rax,4),%ecx
ffffffff81008767:	8d 79 01             	lea    0x1(%rcx),%edi
ffffffff8100876a:	89 3c 85 18 f7 ff bf 	mov    %edi,-0x400008e8(,%rax,4)
ffffffff81008771:	74 13                	je     ffffffff81008786 <ipi_vector+0x70>
}
ffffffff81008773:	59                   	pop    %rcx
        case VEC_IPI_IDL: Ec::idl_handler(); break;
    }

    eoi();

    Counter::print<1,16> (++Counter::ipi[ipi], Console_vga::COLOR_LIGHT_GREEN, ipi + SPN_IPI);
ffffffff81008774:	8d 93 66 ff ff ff    	lea    -0x9a(%rbx),%edx
ffffffff8100877a:	be 0a 00 00 00       	mov    $0xa,%esi
}
ffffffff8100877f:	5b                   	pop    %rbx
ffffffff81008780:	5d                   	pop    %rbp
ffffffff81008781:	e9 80 fc ff ff       	jmpq   ffffffff81008406 <_ZN7Counter5printILj1ELj16EEEvmN11Console_vga5ColorEj.part.4>
ffffffff81008786:	58                   	pop    %rax
ffffffff81008787:	5b                   	pop    %rbx
ffffffff81008788:	5d                   	pop    %rbp
ffffffff81008789:	c3                   	retq   

ffffffff8100878a <_ZN3Mca4initEv>:
        static void init();

        ALWAYS_INLINE
        static inline bool feature (Feature f)
        {
            return features[f / 32] & 1U << f % 32;
ffffffff8100878a:	8b 15 b0 6f ff 3e    	mov    0x3eff6fb0(%rip),%edx        # ffffffffbffff740 <_ZN3Cpu8featuresE>

unsigned Mca::banks;

void Mca::init()
{
    if (EXPECT_FALSE (!Cpu::feature (Cpu::FEAT_MCE)))
ffffffff81008790:	f6 c2 80             	test   $0x80,%dl
ffffffff81008793:	0f 84 a7 00 00 00    	je     ffffffff81008840 <_ZN3Mca4initEv+0xb6>

ALWAYS_INLINE
static inline mword get_cr4()
{
    mword cr4;
    asm volatile ("mov %%cr4, %0" : "=r" (cr4));
ffffffff81008799:	0f 20 e0             	mov    %cr4,%rax
        return;

    set_cr4 (get_cr4() | Cpu::CR4_MCE);
ffffffff8100879c:	48 83 c8 40          	or     $0x40,%rax
}

ALWAYS_INLINE
static inline void set_cr4 (mword cr4)
{
    asm volatile ("mov %0, %%cr4" : : "r" (cr4));
ffffffff810087a0:	0f 22 e0             	mov    %rax,%cr4

    if (EXPECT_FALSE (!Cpu::feature (Cpu::FEAT_MCA)))
ffffffff810087a3:	80 e6 40             	and    $0x40,%dh
ffffffff810087a6:	0f 84 94 00 00 00    	je     ffffffff81008840 <_ZN3Mca4initEv+0xb6>
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
ffffffff810087ac:	b9 79 01 00 00       	mov    $0x179,%ecx
ffffffff810087b1:	0f 32                	rdmsr  
ffffffff810087b3:	48 89 c6             	mov    %rax,%rsi

        template <typename T>
        ALWAYS_INLINE
        static inline void write (Register msr, T val)
        {
            asm volatile ("wrmsr" : : "a" (static_cast<mword>(val)), "d" (static_cast<mword>(static_cast<uint64>(val) >> 32)), "c" (msr));
ffffffff810087b6:	31 c0                	xor    %eax,%eax
ffffffff810087b8:	b1 7a                	mov    $0x7a,%cl
ffffffff810087ba:	48 89 c2             	mov    %rax,%rdx
ffffffff810087bd:	0f 30                	wrmsr  

    uint32 cap = Msr::read<uint32>(Msr::IA32_MCG_CAP);

    Msr::write<uint32>(Msr::IA32_MCG_STATUS, 0);

    if (cap & 0x100)
ffffffff810087bf:	f7 c6 00 01 00 00    	test   $0x100,%esi
ffffffff810087c5:	74 0d                	je     ffffffff810087d4 <_ZN3Mca4initEv+0x4a>
ffffffff810087c7:	b1 7b                	mov    $0x7b,%cl
ffffffff810087c9:	ba ff ff ff ff       	mov    $0xffffffff,%edx
ffffffff810087ce:	48 83 c8 ff          	or     $0xffffffffffffffff,%rax
ffffffff810087d2:	0f 30                	wrmsr  
        Msr::write<uint64>(Msr::IA32_MCG_CTL, ~0ULL);

    banks = cap & 0xff;

    for (unsigned i = (Cpu::vendor == Cpu::INTEL && Cpu::family == 6 && Cpu::model < 0x1a); i < banks; i++) {
ffffffff810087d4:	31 ff                	xor    %edi,%edi
ffffffff810087d6:	83 3d cf 6f ff 3e 01 	cmpl   $0x1,0x3eff6fcf(%rip)        # ffffffffbffff7ac <_ZN3Cpu6vendorE>
    Msr::write<uint32>(Msr::IA32_MCG_STATUS, 0);

    if (cap & 0x100)
        Msr::write<uint64>(Msr::IA32_MCG_CTL, ~0ULL);

    banks = cap & 0xff;
ffffffff810087dd:	40 0f b6 f6          	movzbl %sil,%esi
ffffffff810087e1:	89 35 31 70 ff 3e    	mov    %esi,0x3eff7031(%rip)        # ffffffffbffff818 <_ZN3Mca5banksE>

    for (unsigned i = (Cpu::vendor == Cpu::INTEL && Cpu::family == 6 && Cpu::model < 0x1a); i < banks; i++) {
ffffffff810087e7:	75 14                	jne    ffffffff810087fd <_ZN3Mca4initEv+0x73>
ffffffff810087e9:	83 3d b4 6f ff 3e 06 	cmpl   $0x6,0x3eff6fb4(%rip)        # ffffffffbffff7a4 <_ZN3Cpu6familyE>
ffffffff810087f0:	75 0b                	jne    ffffffff810087fd <_ZN3Mca4initEv+0x73>
ffffffff810087f2:	83 3d a7 6f ff 3e 19 	cmpl   $0x19,0x3eff6fa7(%rip)        # ffffffffbffff7a0 <_ZN3Cpu5modelE>
ffffffff810087f9:	40 0f 96 c7          	setbe  %dil
ffffffff810087fd:	40 0f b6 ff          	movzbl %dil,%edi
ffffffff81008801:	49 83 ca ff          	or     $0xffffffffffffffff,%r10
ffffffff81008805:	41 bb ff ff ff ff    	mov    $0xffffffff,%r11d
ffffffff8100880b:	44 8d 04 bd 00 00 00 	lea    0x0(,%rdi,4),%r8d
ffffffff81008812:	00 
ffffffff81008813:	45 31 c9             	xor    %r9d,%r9d
ffffffff81008816:	41 81 c0 01 04 00 00 	add    $0x401,%r8d
ffffffff8100881d:	39 f7                	cmp    %esi,%edi
ffffffff8100881f:	73 1f                	jae    ffffffff81008840 <_ZN3Mca4initEv+0xb6>
        Msr::write<uint64>(Msr::Register (4 * i + Msr::IA32_MCI_CTL), ~0ULL);
ffffffff81008821:	41 8d 48 ff          	lea    -0x1(%r8),%ecx
ffffffff81008825:	4c 89 d0             	mov    %r10,%rax
ffffffff81008828:	4c 89 da             	mov    %r11,%rdx
ffffffff8100882b:	0f 30                	wrmsr  
ffffffff8100882d:	4c 89 c8             	mov    %r9,%rax
ffffffff81008830:	4c 89 ca             	mov    %r9,%rdx
ffffffff81008833:	44 89 c1             	mov    %r8d,%ecx
ffffffff81008836:	0f 30                	wrmsr  
    if (cap & 0x100)
        Msr::write<uint64>(Msr::IA32_MCG_CTL, ~0ULL);

    banks = cap & 0xff;

    for (unsigned i = (Cpu::vendor == Cpu::INTEL && Cpu::family == 6 && Cpu::model < 0x1a); i < banks; i++) {
ffffffff81008838:	ff c7                	inc    %edi
ffffffff8100883a:	41 83 c0 04          	add    $0x4,%r8d
ffffffff8100883e:	eb dd                	jmp    ffffffff8100881d <_ZN3Mca4initEv+0x93>
ffffffff81008840:	c3                   	retq   
ffffffff81008841:	90                   	nop

ffffffff81008842 <_ZN3Mca6vectorEv>:
        Msr::write<uint64>(Msr::Register (4 * i + Msr::IA32_MCI_STATUS), 0);
    }
}

void Mca::vector()
{
ffffffff81008842:	41 55                	push   %r13
ffffffff81008844:	41 54                	push   %r12
    uint64 sts;

    for (unsigned i = 0; i < banks; i++)
        if ((sts = Msr::read<uint64>(Msr::Register (4 * i + Msr::IA32_MCI_STATUS))) & 1ULL << 63)
            trace (TRACE_ERROR, "Machine Check B%u: %#018llx", i, sts);
ffffffff81008846:	49 83 cd ff          	or     $0xffffffffffffffff,%r13
        Msr::write<uint64>(Msr::Register (4 * i + Msr::IA32_MCI_STATUS), 0);
    }
}

void Mca::vector()
{
ffffffff8100884a:	55                   	push   %rbp
ffffffff8100884b:	53                   	push   %rbx
    uint64 sts;

    for (unsigned i = 0; i < banks; i++)
ffffffff8100884c:	bd 01 04 00 00       	mov    $0x401,%ebp
ffffffff81008851:	31 db                	xor    %ebx,%ebx
        Msr::write<uint64>(Msr::Register (4 * i + Msr::IA32_MCI_STATUS), 0);
    }
}

void Mca::vector()
{
ffffffff81008853:	48 83 ec 18          	sub    $0x18,%rsp
    uint64 sts;

    for (unsigned i = 0; i < banks; i++)
        if ((sts = Msr::read<uint64>(Msr::Register (4 * i + Msr::IA32_MCI_STATUS))) & 1ULL << 63)
            trace (TRACE_ERROR, "Machine Check B%u: %#018llx", i, sts);
ffffffff81008857:	4c 8d 64 24 07       	lea    0x7(%rsp),%r12
ffffffff8100885c:	49 81 e4 00 f0 ff ff 	and    $0xfffffffffffff000,%r12

void Mca::vector()
{
    uint64 sts;

    for (unsigned i = 0; i < banks; i++)
ffffffff81008863:	3b 1d af 6f ff 3e    	cmp    0x3eff6faf(%rip),%ebx        # ffffffffbffff818 <_ZN3Mca5banksE>
ffffffff81008869:	73 38                	jae    ffffffff810088a3 <_ZN3Mca6vectorEv+0x61>
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
ffffffff8100886b:	89 e9                	mov    %ebp,%ecx
ffffffff8100886d:	0f 32                	rdmsr  
            return static_cast<T>(static_cast<uint64>(h) << 32 | l);
ffffffff8100886f:	48 c1 e2 20          	shl    $0x20,%rdx
ffffffff81008873:	48 89 d1             	mov    %rdx,%rcx
        if ((sts = Msr::read<uint64>(Msr::Register (4 * i + Msr::IA32_MCI_STATUS))) & 1ULL << 63)
ffffffff81008876:	48 09 c1             	or     %rax,%rcx
ffffffff81008879:	79 21                	jns    ffffffff8100889c <_ZN3Mca6vectorEv+0x5a>
            trace (TRACE_ERROR, "Machine Check B%u: %#018llx", i, sts);
ffffffff8100887b:	8b 35 83 67 ff 3e    	mov    0x3eff6783(%rip),%esi        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81008881:	49 81 fc 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%r12
ffffffff81008888:	89 da                	mov    %ebx,%edx
ffffffff8100888a:	48 c7 c7 d0 e5 01 81 	mov    $0xffffffff8101e5d0,%rdi
ffffffff81008891:	49 0f 45 f5          	cmovne %r13,%rsi
ffffffff81008895:	31 c0                	xor    %eax,%eax
ffffffff81008897:	e8 f0 97 ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>

void Mca::vector()
{
    uint64 sts;

    for (unsigned i = 0; i < banks; i++)
ffffffff8100889c:	ff c3                	inc    %ebx
ffffffff8100889e:	83 c5 04             	add    $0x4,%ebp
ffffffff810088a1:	eb c0                	jmp    ffffffff81008863 <_ZN3Mca6vectorEv+0x21>
        if ((sts = Msr::read<uint64>(Msr::Register (4 * i + Msr::IA32_MCI_STATUS))) & 1ULL << 63)
            trace (TRACE_ERROR, "Machine Check B%u: %#018llx", i, sts);
}
ffffffff810088a3:	48 83 c4 18          	add    $0x18,%rsp
ffffffff810088a7:	5b                   	pop    %rbx
ffffffff810088a8:	5d                   	pop    %rbp
ffffffff810088a9:	41 5c                	pop    %r12
ffffffff810088ab:	41 5d                	pop    %r13
ffffffff810088ad:	c3                   	retq   

ffffffff810088ae <_ZN3Mdb11insert_nodeEPS_m>:
Slab_cache Mdb::cache (sizeof (Mdb), 16);

Spinlock Mdb::lock;

bool Mdb::insert_node (Mdb *p, mword a)
{
ffffffff810088ae:	41 55                	push   %r13
ffffffff810088b0:	41 54                	push   %r12
ffffffff810088b2:	49 89 d4             	mov    %rdx,%r12
ffffffff810088b5:	55                   	push   %rbp
ffffffff810088b6:	48 89 fd             	mov    %rdi,%rbp
ffffffff810088b9:	53                   	push   %rbx
ffffffff810088ba:	48 89 f3             	mov    %rsi,%rbx
ffffffff810088bd:	51                   	push   %rcx

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff810088be:	9c                   	pushfq 
ffffffff810088bf:	58                   	pop    %rax
            return flags & 0x200;
ffffffff810088c0:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff810088c4:	41 88 c5             	mov    %al,%r13b
ffffffff810088c7:	41 80 e5 01          	and    $0x1,%r13b
ffffffff810088cb:	74 30                	je     ffffffff810088fd <_ZN3Mdb11insert_nodeEPS_m+0x4f>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff810088cd:	80 3d 5c 6e ff 3e 00 	cmpb   $0x0,0x3eff6e5c(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff810088d4:	75 1f                	jne    ffffffff810088f5 <_ZN3Mdb11insert_nodeEPS_m+0x47>
ffffffff810088d6:	49 c7 c0 30 e6 01 81 	mov    $0xffffffff8101e630,%r8
ffffffff810088dd:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff810088e2:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff810088e9:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff810088f0:	e9 92 00 00 00       	jmpq   ffffffff81008987 <_ZN3Mdb11insert_nodeEPS_m+0xd9>

            asm volatile ("cli" : : : "memory");
ffffffff810088f5:	fa                   	cli    
            preemption = false;
ffffffff810088f6:	c6 05 33 6e ff 3e 00 	movb   $0x0,0x3eff6e33(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff810088fd:	48 c7 c7 78 38 16 81 	mov    $0xffffffff81163878,%rdi
ffffffff81008904:	e8 85 85 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
{
    private:
        static Slab_cache   cache;
        static Spinlock     lock;

        bool alive() const { return prev->next == this && next->prev == this; }
ffffffff81008909:	48 8b 43 38          	mov    0x38(%rbx),%rax
ffffffff8100890d:	48 39 58 40          	cmp    %rbx,0x40(%rax)
ffffffff81008911:	74 04                	je     ffffffff81008917 <_ZN3Mdb11insert_nodeEPS_m+0x69>
    Lock_guard <Spinlock> guard (lock);

    if (!p->alive())
        return false;
ffffffff81008913:	31 c0                	xor    %eax,%eax
ffffffff81008915:	eb 42                	jmp    ffffffff81008959 <_ZN3Mdb11insert_nodeEPS_m+0xab>
ffffffff81008917:	48 8b 43 40          	mov    0x40(%rbx),%rax
ffffffff8100891b:	48 39 58 38          	cmp    %rbx,0x38(%rax)
ffffffff8100891f:	75 f2                	jne    ffffffff81008913 <_ZN3Mdb11insert_nodeEPS_m+0x65>

    if (!(node_attr = p->node_attr & a))
ffffffff81008921:	4c 89 e2             	mov    %r12,%rdx
ffffffff81008924:	48 23 53 70          	and    0x70(%rbx),%rdx
ffffffff81008928:	48 85 d2             	test   %rdx,%rdx
ffffffff8100892b:	48 89 55 70          	mov    %rdx,0x70(%rbp)
ffffffff8100892f:	74 e2                	je     ffffffff81008913 <_ZN3Mdb11insert_nodeEPS_m+0x65>
        return false;

    prev = prnt = p;
ffffffff81008931:	48 89 5d 48          	mov    %rbx,0x48(%rbp)
ffffffff81008935:	48 89 5d 38          	mov    %rbx,0x38(%rbp)
    next = p->next;
ffffffff81008939:	48 8b 43 40          	mov    0x40(%rbx),%rax
ffffffff8100893d:	48 89 45 40          	mov    %rax,0x40(%rbp)
    dpth = static_cast<uint16>(p->dpth + 1);
ffffffff81008941:	66 8b 43 32          	mov    0x32(%rbx),%ax
ffffffff81008945:	ff c0                	inc    %eax
ffffffff81008947:	66 89 45 32          	mov    %ax,0x32(%rbp)
    p->next = p->next->prev = this;
ffffffff8100894b:	48 8b 43 40          	mov    0x40(%rbx),%rax
ffffffff8100894f:	48 89 68 38          	mov    %rbp,0x38(%rax)
ffffffff81008953:	48 89 6b 40          	mov    %rbp,0x40(%rbx)

    return true;
ffffffff81008957:	b0 01                	mov    $0x1,%al
ffffffff81008959:	fe 05 19 af 15 00    	incb   0x15af19(%rip)        # ffffffff81163878 <_ZN3Mdb4lockE>
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff8100895f:	45 84 ed             	test   %r13b,%r13b
ffffffff81008962:	74 39                	je     ffffffff8100899d <_ZN3Mdb11insert_nodeEPS_m+0xef>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81008964:	80 3d c5 6d ff 3e 00 	cmpb   $0x0,0x3eff6dc5(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100896b:	74 28                	je     ffffffff81008995 <_ZN3Mdb11insert_nodeEPS_m+0xe7>
ffffffff8100896d:	49 c7 c0 00 e6 01 81 	mov    $0xffffffff8101e600,%r8
ffffffff81008974:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff81008979:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81008980:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff81008987:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100898e:	31 c0                	xor    %eax,%eax
ffffffff81008990:	e8 bb 95 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            preemption = true;
ffffffff81008995:	c6 05 94 6d ff 3e 01 	movb   $0x1,0x3eff6d94(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100899c:	fb                   	sti    
}
ffffffff8100899d:	5a                   	pop    %rdx
ffffffff8100899e:	5b                   	pop    %rbx
ffffffff8100899f:	5d                   	pop    %rbp
ffffffff810089a0:	41 5c                	pop    %r12
ffffffff810089a2:	41 5d                	pop    %r13
ffffffff810089a4:	c3                   	retq   
ffffffff810089a5:	90                   	nop

ffffffff810089a6 <_ZN3Mdb11demote_nodeEm>:

void Mdb::demote_node (mword a)
{
ffffffff810089a6:	41 54                	push   %r12
ffffffff810089a8:	49 89 fc             	mov    %rdi,%r12
ffffffff810089ab:	55                   	push   %rbp
ffffffff810089ac:	48 89 f5             	mov    %rsi,%rbp
ffffffff810089af:	53                   	push   %rbx

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff810089b0:	9c                   	pushfq 
ffffffff810089b1:	58                   	pop    %rax
            return flags & 0x200;
ffffffff810089b2:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff810089b6:	88 c3                	mov    %al,%bl
ffffffff810089b8:	80 e3 01             	and    $0x1,%bl
ffffffff810089bb:	74 2d                	je     ffffffff810089ea <_ZN3Mdb11demote_nodeEm+0x44>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff810089bd:	80 3d 6c 6d ff 3e 00 	cmpb   $0x0,0x3eff6d6c(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff810089c4:	75 1c                	jne    ffffffff810089e2 <_ZN3Mdb11demote_nodeEm+0x3c>
ffffffff810089c6:	49 c7 c0 30 e6 01 81 	mov    $0xffffffff8101e630,%r8
ffffffff810089cd:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff810089d2:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff810089d9:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff810089e0:	eb 49                	jmp    ffffffff81008a2b <_ZN3Mdb11demote_nodeEm+0x85>

            asm volatile ("cli" : : : "memory");
ffffffff810089e2:	fa                   	cli    
            preemption = false;
ffffffff810089e3:	c6 05 46 6d ff 3e 00 	movb   $0x0,0x3eff6d46(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff810089ea:	48 c7 c7 78 38 16 81 	mov    $0xffffffff81163878,%rdi
    Lock_guard <Spinlock> guard (lock);

    node_attr &= ~a;
ffffffff810089f1:	48 f7 d5             	not    %rbp
ffffffff810089f4:	e8 95 84 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
ffffffff810089f9:	49 21 6c 24 70       	and    %rbp,0x70(%r12)
ffffffff810089fe:	fe 05 74 ae 15 00    	incb   0x15ae74(%rip)        # ffffffff81163878 <_ZN3Mdb4lockE>
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81008a04:	84 db                	test   %bl,%bl
ffffffff81008a06:	74 39                	je     ffffffff81008a41 <_ZN3Mdb11demote_nodeEm+0x9b>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81008a08:	80 3d 21 6d ff 3e 00 	cmpb   $0x0,0x3eff6d21(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81008a0f:	74 28                	je     ffffffff81008a39 <_ZN3Mdb11demote_nodeEm+0x93>
ffffffff81008a11:	49 c7 c0 00 e6 01 81 	mov    $0xffffffff8101e600,%r8
ffffffff81008a18:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff81008a1d:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81008a24:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff81008a2b:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81008a32:	31 c0                	xor    %eax,%eax
ffffffff81008a34:	e8 17 95 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            preemption = true;
ffffffff81008a39:	c6 05 f0 6c ff 3e 01 	movb   $0x1,0x3eff6cf0(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81008a40:	fb                   	sti    
}
ffffffff81008a41:	5b                   	pop    %rbx
ffffffff81008a42:	5d                   	pop    %rbp
ffffffff81008a43:	41 5c                	pop    %r12
ffffffff81008a45:	c3                   	retq   

ffffffff81008a46 <_ZN3Mdb11remove_nodeEv>:

bool Mdb::remove_node()
{
    if (node_attr)
ffffffff81008a46:	48 83 7f 70 00       	cmpq   $0x0,0x70(%rdi)
ffffffff81008a4b:	0f 85 d2 00 00 00    	jne    ffffffff81008b23 <_ZN3Mdb11remove_nodeEv+0xdd>

    node_attr &= ~a;
}

bool Mdb::remove_node()
{
ffffffff81008a51:	55                   	push   %rbp
ffffffff81008a52:	53                   	push   %rbx
ffffffff81008a53:	48 89 fb             	mov    %rdi,%rbx
ffffffff81008a56:	51                   	push   %rcx

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81008a57:	9c                   	pushfq 
ffffffff81008a58:	58                   	pop    %rax
            return flags & 0x200;
ffffffff81008a59:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff81008a5d:	40 88 c5             	mov    %al,%bpl
ffffffff81008a60:	40 80 e5 01          	and    $0x1,%bpl
ffffffff81008a64:	74 39                	je     ffffffff81008a9f <_ZN3Mdb11remove_nodeEv+0x59>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81008a66:	80 3d c3 6c ff 3e 00 	cmpb   $0x0,0x3eff6cc3(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81008a6d:	75 28                	jne    ffffffff81008a97 <_ZN3Mdb11remove_nodeEv+0x51>
ffffffff81008a6f:	49 c7 c0 30 e6 01 81 	mov    $0xffffffff8101e630,%r8
ffffffff81008a76:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff81008a7b:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81008a82:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff81008a89:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81008a90:	31 c0                	xor    %eax,%eax
ffffffff81008a92:	e8 b9 94 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            asm volatile ("cli" : : : "memory");
ffffffff81008a97:	fa                   	cli    
            preemption = false;
ffffffff81008a98:	c6 05 91 6c ff 3e 00 	movb   $0x0,0x3eff6c91(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff81008a9f:	48 c7 c7 78 38 16 81 	mov    $0xffffffff81163878,%rdi
ffffffff81008aa6:	e8 e3 83 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
ffffffff81008aab:	48 8b 4b 38          	mov    0x38(%rbx),%rcx
        return false;

    Lock_guard <Spinlock> guard (lock);

    if (!alive())
        return false;
ffffffff81008aaf:	31 c0                	xor    %eax,%eax
ffffffff81008ab1:	48 39 59 40          	cmp    %rbx,0x40(%rcx)
ffffffff81008ab5:	75 26                	jne    ffffffff81008add <_ZN3Mdb11remove_nodeEv+0x97>
ffffffff81008ab7:	48 8b 53 40          	mov    0x40(%rbx),%rdx
ffffffff81008abb:	48 39 5a 38          	cmp    %rbx,0x38(%rdx)
ffffffff81008abf:	75 1c                	jne    ffffffff81008add <_ZN3Mdb11remove_nodeEv+0x97>

    if (next->dpth > dpth)
ffffffff81008ac1:	66 8b 73 32          	mov    0x32(%rbx),%si
ffffffff81008ac5:	66 39 72 32          	cmp    %si,0x32(%rdx)
ffffffff81008ac9:	77 12                	ja     ffffffff81008add <_ZN3Mdb11remove_nodeEv+0x97>
        return false;

    next->prev = prev;
ffffffff81008acb:	48 89 4a 38          	mov    %rcx,0x38(%rdx)
    prev->next = next;
ffffffff81008acf:	48 8b 43 38          	mov    0x38(%rbx),%rax
ffffffff81008ad3:	48 8b 53 40          	mov    0x40(%rbx),%rdx
ffffffff81008ad7:	48 89 50 40          	mov    %rdx,0x40(%rax)

    return true;
ffffffff81008adb:	b0 01                	mov    $0x1,%al
ffffffff81008add:	fe 05 95 ad 15 00    	incb   0x15ad95(%rip)        # ffffffff81163878 <_ZN3Mdb4lockE>
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81008ae3:	40 84 ed             	test   %bpl,%bpl
ffffffff81008ae6:	74 3e                	je     ffffffff81008b26 <_ZN3Mdb11remove_nodeEv+0xe0>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81008ae8:	80 3d 41 6c ff 3e 00 	cmpb   $0x0,0x3eff6c41(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81008aef:	74 28                	je     ffffffff81008b19 <_ZN3Mdb11remove_nodeEv+0xd3>
ffffffff81008af1:	49 c7 c0 00 e6 01 81 	mov    $0xffffffff8101e600,%r8
ffffffff81008af8:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff81008afd:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81008b04:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff81008b0b:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81008b12:	31 c0                	xor    %eax,%eax
ffffffff81008b14:	e8 37 94 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            preemption = true;
ffffffff81008b19:	c6 05 10 6c ff 3e 01 	movb   $0x1,0x3eff6c10(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81008b20:	fb                   	sti    
ffffffff81008b21:	eb 03                	jmp    ffffffff81008b26 <_ZN3Mdb11remove_nodeEv+0xe0>
}

bool Mdb::remove_node()
{
    if (node_attr)
        return false;
ffffffff81008b23:	31 c0                	xor    %eax,%eax

    next->prev = prev;
    prev->next = next;

    return true;
}
ffffffff81008b25:	c3                   	retq   
ffffffff81008b26:	5a                   	pop    %rdx
ffffffff81008b27:	5b                   	pop    %rbx
ffffffff81008b28:	5d                   	pop    %rbp
ffffffff81008b29:	c3                   	retq   

ffffffff81008b2a <_GLOBAL__sub_I.00102__ZN3Mdb5cacheE>:
#include "assert.hpp"
#include "lock_guard.hpp"
#include "mdb.hpp"

INIT_PRIORITY (PRIO_SLAB)
Slab_cache Mdb::cache (sizeof (Mdb), 16);
ffffffff81008b2a:	ba 10 00 00 00       	mov    $0x10,%edx
ffffffff81008b2f:	be 88 00 00 00       	mov    $0x88,%esi
ffffffff81008b34:	48 c7 c7 80 38 16 81 	mov    $0xffffffff81163880,%rdi
ffffffff81008b3b:	e9 60 cd 00 00       	jmpq   ffffffff810158a0 <_ZN10Slab_cacheC1Emj>

ffffffff81008b40 <_GLOBAL__sub_I__ZN3Mdb5cacheE>:
    private:
        uint16 val;

    public:
        ALWAYS_INLINE
        inline Spinlock() : val (0) {}
ffffffff81008b40:	66 c7 05 2f ad 15 00 	movw   $0x0,0x15ad2f(%rip)        # ffffffff81163878 <_ZN3Mdb4lockE>
ffffffff81008b47:	00 00 
ffffffff81008b49:	c3                   	retq   

ffffffff81008b4a <_GLOBAL__sub_I.00102__ZN4Mtrr5countE>:
unsigned Mtrr::count;
unsigned Mtrr::dtype;
Mtrr *   Mtrr::list;

INIT_PRIORITY (PRIO_SLAB)
Slab_cache Mtrr::cache (sizeof (Mtrr), 8);
ffffffff81008b4a:	ba 08 00 00 00       	mov    $0x8,%edx
ffffffff81008b4f:	be 18 00 00 00       	mov    $0x18,%esi
ffffffff81008b54:	48 c7 c7 b0 38 16 81 	mov    $0xffffffff811638b0,%rdi
ffffffff81008b5b:	e9 40 cd 00 00       	jmpq   ffffffff810158a0 <_ZN10Slab_cacheC1Emj>

ffffffff81008b60 <_ZN2ScD1Ev>:
        inline Refptr (T *p) : ptr (p->add_ref() ? p : nullptr) {}

        ALWAYS_INLINE
        inline ~Refptr()
        {
            if (ptr && ptr->del_ref())
ffffffff81008b60:	48 8b 97 90 00 00 00 	mov    0x90(%rdi),%rdx

#include "compiler.hpp"

class Ec;

class Sc : public Kobject, public Refex<~0U>
ffffffff81008b67:	48 89 f8             	mov    %rdi,%rax
ffffffff81008b6a:	48 85 d2             	test   %rdx,%rdx
ffffffff81008b6d:	74 47                	je     ffffffff81008bb6 <_ZN2ScD1Ev+0x56>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff81008b6f:	83 c9 ff             	or     $0xffffffff,%ecx
ffffffff81008b72:	f0 0f c1 8a 8c 00 00 	lock xadd %ecx,0x8c(%rdx)
ffffffff81008b79:	00 
ffffffff81008b7a:	ff c9                	dec    %ecx
ffffffff81008b7c:	74 01                	je     ffffffff81008b7f <_ZN2ScD1Ev+0x1f>
ffffffff81008b7e:	c3                   	retq   
                delete ptr;
ffffffff81008b7f:	48 8b bf 90 00 00 00 	mov    0x90(%rdi),%rdi
ffffffff81008b86:	48 85 ff             	test   %rdi,%rdi
ffffffff81008b89:	74 2b                	je     ffffffff81008bb6 <_ZN2ScD1Ev+0x56>
ffffffff81008b8b:	53                   	push   %rbx
ffffffff81008b8c:	48 89 c3             	mov    %rax,%rbx
ffffffff81008b8f:	e8 a8 b8 ff ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
ffffffff81008b94:	48 8b b3 90 00 00 00 	mov    0x90(%rbx),%rsi
ffffffff81008b9b:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff81008ba2:	5b                   	pop    %rbx
ffffffff81008ba3:	48 8b 86 98 02 00 00 	mov    0x298(%rsi),%rax
ffffffff81008baa:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff81008bb1:	e9 b4 ce 00 00       	jmpq   ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
ffffffff81008bb6:	c3                   	retq   
ffffffff81008bb7:	90                   	nop

ffffffff81008bb8 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv>:

    die ("XCPU OOM error");
}

template <void (*C)()>
void Ec::oom_xcpu_return()
ffffffff81008bb8:	41 54                	push   %r12
ffffffff81008bba:	55                   	push   %rbp
ffffffff81008bbb:	53                   	push   %rbx
ffffffff81008bbc:	48 83 ec 10          	sub    $0x10,%rsp
{
    assert (current->xcpu_sm);
ffffffff81008bc0:	48 8b 05 41 64 ff 3e 	mov    0x3eff6441(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81008bc7:	48 8b a8 30 03 00 00 	mov    0x330(%rax),%rbp
ffffffff81008bce:	48 85 ed             	test   %rbp,%rbp
ffffffff81008bd1:	75 1c                	jne    ffffffff81008bef <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x37>
ffffffff81008bd3:	49 c7 c0 40 fc 01 81 	mov    $0xffffffff8101fc40,%r8
ffffffff81008bda:	b9 87 00 00 00       	mov    $0x87,%ecx
ffffffff81008bdf:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff81008be6:	48 c7 c6 cc de 01 81 	mov    $0xffffffff8101decc,%rsi
ffffffff81008bed:	eb 24                	jmp    ffffffff81008c13 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x5b>
    assert (current->rcap);
ffffffff81008bef:	48 83 b8 88 02 00 00 	cmpq   $0x0,0x288(%rax)
ffffffff81008bf6:	00 
ffffffff81008bf7:	75 28                	jne    ffffffff81008c21 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x69>
ffffffff81008bf9:	49 c7 c0 40 fc 01 81 	mov    $0xffffffff8101fc40,%r8
ffffffff81008c00:	b9 88 00 00 00       	mov    $0x88,%ecx
ffffffff81008c05:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff81008c0c:	48 c7 c6 dd de 01 81 	mov    $0xffffffff8101dedd,%rsi
ffffffff81008c13:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81008c1a:	31 c0                	xor    %eax,%eax
ffffffff81008c1c:	e8 2f 93 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
    assert (current->utcb);
ffffffff81008c21:	48 83 b8 90 02 00 00 	cmpq   $0x0,0x290(%rax)
ffffffff81008c28:	00 
ffffffff81008c29:	75 1c                	jne    ffffffff81008c47 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x8f>
ffffffff81008c2b:	49 c7 c0 40 fc 01 81 	mov    $0xffffffff8101fc40,%r8
ffffffff81008c32:	b9 89 00 00 00       	mov    $0x89,%ecx
ffffffff81008c37:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff81008c3e:	48 c7 c6 eb de 01 81 	mov    $0xffffffff8101deeb,%rsi
ffffffff81008c45:	eb cc                	jmp    ffffffff81008c13 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x5b>
{
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
ffffffff81008c47:	48 8b 15 ca 63 ff 3e 	mov    0x3eff63ca(%rip),%rdx        # ffffffffbffff018 <_ZN2Sc7currentE>
    assert (Sc::current->ec == current);
ffffffff81008c4e:	48 39 82 90 00 00 00 	cmp    %rax,0x90(%rdx)
ffffffff81008c55:	74 1c                	je     ffffffff81008c73 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0xbb>
ffffffff81008c57:	49 c7 c0 40 fc 01 81 	mov    $0xffffffff8101fc40,%r8
ffffffff81008c5e:	b9 8a 00 00 00       	mov    $0x8a,%ecx
ffffffff81008c63:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff81008c6a:	48 c7 c6 f9 de 01 81 	mov    $0xffffffff8101def9,%rsi
ffffffff81008c71:	eb a0                	jmp    ffffffff81008c13 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x5b>
        ALWAYS_INLINE
        inline void up (void (*c)() = nullptr, Sm * si = nullptr)
        {
            Ec *ec;

            {   Lock_guard <Spinlock> guard (lock);
ffffffff81008c73:	48 8d bd 8a 00 00 00 	lea    0x8a(%rbp),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81008c7a:	9c                   	pushfq 
ffffffff81008c7b:	41 5c                	pop    %r12
            return flags & 0x200;
ffffffff81008c7d:	49 c1 ec 09          	shr    $0x9,%r12

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff81008c81:	41 80 e4 01          	and    $0x1,%r12b
ffffffff81008c85:	74 30                	je     ffffffff81008cb7 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0xff>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81008c87:	80 3d a2 6a ff 3e 00 	cmpb   $0x0,0x3eff6aa2(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81008c8e:	75 1f                	jne    ffffffff81008caf <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0xf7>
ffffffff81008c90:	49 c7 c0 40 fb 01 81 	mov    $0xffffffff8101fb40,%r8
ffffffff81008c97:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff81008c9c:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81008ca3:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff81008caa:	e9 64 ff ff ff       	jmpq   ffffffff81008c13 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x5b>

            asm volatile ("cli" : : : "memory");
ffffffff81008caf:	fa                   	cli    
            preemption = false;
ffffffff81008cb0:	c6 05 79 6a ff 3e 00 	movb   $0x0,0x3eff6a79(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff81008cb7:	e8 d2 81 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff81008cbc:	48 8b 9d 90 00 00 00 	mov    0x90(%rbp),%rbx
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff81008cc3:	48 85 db             	test   %rbx,%rbx
ffffffff81008cc6:	0f 84 ea 01 00 00    	je     ffffffff81008eb6 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x2fe>
ffffffff81008ccc:	48 8b 83 b0 02 00 00 	mov    0x2b0(%rbx),%rax
ffffffff81008cd3:	48 85 c0             	test   %rax,%rax
ffffffff81008cd6:	0f 84 da 01 00 00    	je     ffffffff81008eb6 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x2fe>
ffffffff81008cdc:	48 8b 93 a8 02 00 00 	mov    0x2a8(%rbx),%rdx
ffffffff81008ce3:	48 85 d2             	test   %rdx,%rdx
ffffffff81008ce6:	0f 84 ca 01 00 00    	je     ffffffff81008eb6 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x2fe>
                return false;

            if (t == t->next)
ffffffff81008cec:	48 39 c3             	cmp    %rax,%rbx
ffffffff81008cef:	75 0d                	jne    ffffffff81008cfe <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x146>
                headptr = nullptr;
ffffffff81008cf1:	48 c7 85 90 00 00 00 	movq   $0x0,0x90(%rbp)
ffffffff81008cf8:	00 00 00 00 
ffffffff81008cfc:	eb 33                	jmp    ffffffff81008d31 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x179>

            else {
                t->next->prev = t->prev;
ffffffff81008cfe:	48 89 90 a8 02 00 00 	mov    %rdx,0x2a8(%rax)
                t->prev->next = t->next;
ffffffff81008d05:	48 8b 83 a8 02 00 00 	mov    0x2a8(%rbx),%rax
ffffffff81008d0c:	48 8b 93 b0 02 00 00 	mov    0x2b0(%rbx),%rdx
ffffffff81008d13:	48 89 90 b0 02 00 00 	mov    %rdx,0x2b0(%rax)
                if (t == headptr)
ffffffff81008d1a:	48 3b 9d 90 00 00 00 	cmp    0x90(%rbp),%rbx
ffffffff81008d21:	75 0e                	jne    ffffffff81008d31 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x179>
                    headptr = t->next;
ffffffff81008d23:	48 8b 83 b0 02 00 00 	mov    0x2b0(%rbx),%rax
ffffffff81008d2a:	48 89 85 90 00 00 00 	mov    %rax,0x90(%rbp)
            }

            t->next = t->prev = nullptr;
ffffffff81008d31:	48 c7 83 a8 02 00 00 	movq   $0x0,0x2a8(%rbx)
ffffffff81008d38:	00 00 00 00 
ffffffff81008d3c:	48 c7 83 b0 02 00 00 	movq   $0x0,0x2b0(%rbx)
ffffffff81008d43:	00 00 00 00 
ffffffff81008d47:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff81008d4a:	f0 0f c1 83 8c 00 00 	lock xadd %eax,0x8c(%rbx)
ffffffff81008d51:	00 

                    counter++;
                    return;
                }

                if (EXPECT_FALSE(ec->del_ref())) {
ffffffff81008d52:	ff c8                	dec    %eax
ffffffff81008d54:	75 2a                	jne    ffffffff81008d80 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x1c8>
                    delete ec;
ffffffff81008d56:	48 89 df             	mov    %rbx,%rdi
ffffffff81008d59:	e8 de b6 ff ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
ffffffff81008d5e:	48 8b 83 98 02 00 00 	mov    0x298(%rbx),%rax
ffffffff81008d65:	48 89 de             	mov    %rbx,%rsi
ffffffff81008d68:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff81008d6f:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff81008d76:	e8 ef cc 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
ffffffff81008d7b:	e9 3c ff ff ff       	jmpq   ffffffff81008cbc <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x104>
        }

        ALWAYS_INLINE
        inline void unlock()
        {
            asm volatile ("incb %0" : "=m" (val) : : "memory");
ffffffff81008d80:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81008d86:	45 84 e4             	test   %r12b,%r12b
ffffffff81008d89:	74 30                	je     ffffffff81008dbb <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x203>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81008d8b:	80 3d 9e 69 ff 3e 00 	cmpb   $0x0,0x3eff699e(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81008d92:	74 1f                	je     ffffffff81008db3 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x1fb>
ffffffff81008d94:	49 c7 c0 10 fb 01 81 	mov    $0xffffffff8101fb10,%r8
ffffffff81008d9b:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff81008da0:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81008da7:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff81008dae:	e9 60 fe ff ff       	jmpq   ffffffff81008c13 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x5b>

            preemption = true;
ffffffff81008db3:	c6 05 76 69 ff 3e 01 	movb   $0x1,0x3eff6976(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81008dba:	fb                   	sti    
        Sc::schedule(true);
    }

    ALWAYS_INLINE
    inline void release(void (*c)()) {
        if (c)
ffffffff81008dbb:	48 c7 c0 7e bb 00 81 	mov    $0xffffffff8100bb7e,%rax
ffffffff81008dc2:	48 85 c0             	test   %rax,%rax
ffffffff81008dc5:	74 07                	je     ffffffff81008dce <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x216>
            cont = c;
ffffffff81008dc7:	48 89 83 a0 00 00 00 	mov    %rax,0xa0(%rbx)

        Lock_guard <Spinlock> guard(lock);
ffffffff81008dce:	48 8d bb 8a 00 00 00 	lea    0x8a(%rbx),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81008dd5:	9c                   	pushfq 
ffffffff81008dd6:	58                   	pop    %rax
            return flags & 0x200;
ffffffff81008dd7:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff81008ddb:	41 88 c4             	mov    %al,%r12b
ffffffff81008dde:	41 80 e4 01          	and    $0x1,%r12b
ffffffff81008de2:	74 15                	je     ffffffff81008df9 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x241>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81008de4:	80 3d 45 69 ff 3e 00 	cmpb   $0x0,0x3eff6945(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81008deb:	0f 84 9f fe ff ff    	je     ffffffff81008c90 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0xd8>

            asm volatile ("cli" : : : "memory");
ffffffff81008df1:	fa                   	cli    
            preemption = false;
ffffffff81008df2:	c6 05 37 69 ff 3e 00 	movb   $0x0,0x3eff6937(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff81008df9:	e8 90 80 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff81008dfe:	48 8b ab 90 00 00 00 	mov    0x90(%rbx),%rbp
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff81008e05:	48 85 ed             	test   %rbp,%rbp
ffffffff81008e08:	0f 84 c4 00 00 00    	je     ffffffff81008ed2 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x31a>
ffffffff81008e0e:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff81008e15:	48 85 c0             	test   %rax,%rax
ffffffff81008e18:	0f 84 b4 00 00 00    	je     ffffffff81008ed2 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x31a>
ffffffff81008e1e:	48 8b 95 b8 00 00 00 	mov    0xb8(%rbp),%rdx
ffffffff81008e25:	48 85 d2             	test   %rdx,%rdx
ffffffff81008e28:	0f 84 a4 00 00 00    	je     ffffffff81008ed2 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x31a>
                return false;

            if (t == t->next)
ffffffff81008e2e:	48 39 c5             	cmp    %rax,%rbp
ffffffff81008e31:	75 0d                	jne    ffffffff81008e40 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x288>
                headptr = nullptr;
ffffffff81008e33:	48 c7 83 90 00 00 00 	movq   $0x0,0x90(%rbx)
ffffffff81008e3a:	00 00 00 00 
ffffffff81008e3e:	eb 33                	jmp    ffffffff81008e73 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x2bb>

            else {
                t->next->prev = t->prev;
ffffffff81008e40:	48 89 90 b8 00 00 00 	mov    %rdx,0xb8(%rax)
                t->prev->next = t->next;
ffffffff81008e47:	48 8b 85 b8 00 00 00 	mov    0xb8(%rbp),%rax
ffffffff81008e4e:	48 8b 95 c0 00 00 00 	mov    0xc0(%rbp),%rdx
ffffffff81008e55:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
                if (t == headptr)
ffffffff81008e5c:	48 3b ab 90 00 00 00 	cmp    0x90(%rbx),%rbp
ffffffff81008e63:	75 0e                	jne    ffffffff81008e73 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x2bb>
                    headptr = t->next;
ffffffff81008e65:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff81008e6c:	48 89 83 90 00 00 00 	mov    %rax,0x90(%rbx)
            }

            t->next = t->prev = nullptr;
ffffffff81008e73:	48 c7 85 b8 00 00 00 	movq   $0x0,0xb8(%rbp)
ffffffff81008e7a:	00 00 00 00 
ffffffff81008e7e:	48 c7 85 c0 00 00 00 	movq   $0x0,0xc0(%rbp)
ffffffff81008e85:	00 00 00 00 
ffffffff81008e89:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff81008e8c:	f0 0f c1 85 8c 00 00 	lock xadd %eax,0x8c(%rbp)
ffffffff81008e93:	00 

        for (Sc *s; dequeue(s = head());) {
            if (EXPECT_FALSE(s->del_ref()) && (this == s->ec)) {
ffffffff81008e94:	ff c8                	dec    %eax
ffffffff81008e96:	75 2d                	jne    ffffffff81008ec5 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x30d>
ffffffff81008e98:	48 3b 9d 90 00 00 00 	cmp    0x90(%rbp),%rbx
ffffffff81008e9f:	75 24                	jne    ffffffff81008ec5 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x30d>
                delete s;
ffffffff81008ea1:	48 89 ef             	mov    %rbp,%rdi
ffffffff81008ea4:	e8 b7 fc ff ff       	callq  ffffffff81008b60 <_ZN2ScD1Ev>
ffffffff81008ea9:	48 89 ef             	mov    %rbp,%rdi
ffffffff81008eac:	e8 79 be 00 00       	callq  ffffffff81014d2a <_ZN2ScdlEPv>
ffffffff81008eb1:	e9 48 ff ff ff       	jmpq   ffffffff81008dfe <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x246>
                    if (si) {
                       if (si->queued()) return;
                       Queue<Si>::enqueue(si);
                    }

                    counter++;
ffffffff81008eb6:	48 ff 85 c0 00 00 00 	incq   0xc0(%rbp)
ffffffff81008ebd:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
ffffffff81008ec3:	eb 13                	jmp    ffffffff81008ed8 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x320>
                continue;
            }
            s->remote_enqueue();
ffffffff81008ec5:	48 89 ef             	mov    %rbp,%rdi
ffffffff81008ec8:	e8 93 bb 00 00       	callq  ffffffff81014a60 <_ZN2Sc14remote_enqueueEv>
ffffffff81008ecd:	e9 2c ff ff ff       	jmpq   ffffffff81008dfe <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x246>
ffffffff81008ed2:	fe 83 8a 00 00 00    	incb   0x8a(%rbx)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81008ed8:	45 84 e4             	test   %r12b,%r12b
ffffffff81008edb:	74 15                	je     ffffffff81008ef2 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x33a>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81008edd:	80 3d 4c 68 ff 3e 00 	cmpb   $0x0,0x3eff684c(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81008ee4:	0f 85 aa fe ff ff    	jne    ffffffff81008d94 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x1dc>

            preemption = true;
ffffffff81008eea:	c6 05 3f 68 ff 3e 01 	movb   $0x1,0x3eff683f(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81008ef1:	fb                   	sti    

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
ffffffff81008ef2:	48 8b 1d 0f 61 ff 3e 	mov    0x3eff610f(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81008ef9:	48 8b 43 28          	mov    0x28(%rbx),%rax
ffffffff81008efd:	48 c7 83 88 02 00 00 	movq   $0x0,0x288(%rbx)
ffffffff81008f04:	00 00 00 00 
    current->utcb    = nullptr;
    current->fpu     = nullptr;

    Rcu::call(current);
ffffffff81008f08:	48 8d 6b 18          	lea    0x18(%rbx),%rbp
    assert (Sc::current->ec == current);

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
    current->utcb    = nullptr;
ffffffff81008f0c:	48 c7 83 90 02 00 00 	movq   $0x0,0x290(%rbx)
ffffffff81008f13:	00 00 00 00 
    current->fpu     = nullptr;
ffffffff81008f17:	48 c7 83 b8 02 00 00 	movq   $0x0,0x2b8(%rbx)
ffffffff81008f1e:	00 00 00 00 
ffffffff81008f22:	48 85 c0             	test   %rax,%rax
ffffffff81008f25:	74 05                	je     ffffffff81008f2c <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x374>
                e->pre_func(e);
ffffffff81008f27:	48 89 ef             	mov    %rbp,%rdi
ffffffff81008f2a:	ff d0                	callq  *%rax
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
ffffffff81008f2c:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
ffffffff81008f31:	75 0c                	jne    ffffffff81008f3f <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x387>
ffffffff81008f33:	48 8b 05 2e 69 ff 3e 	mov    0x3eff692e(%rip),%rax        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff81008f3a:	48 39 e8             	cmp    %rbp,%rax
ffffffff81008f3d:	75 2f                	jne    ffffffff81008f6e <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x3b6>
                trace (0, "warning: rcu element already enqueued");
ffffffff81008f3f:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff81008f44:	8b 15 ba 60 ff 3e    	mov    0x3eff60ba(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81008f4a:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81008f4e:	48 c7 c7 14 df 01 81 	mov    $0xffffffff8101df14,%rdi
ffffffff81008f55:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81008f5b:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff81008f61:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff81008f65:	31 c0                	xor    %eax,%eax
ffffffff81008f67:	e8 20 91 ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff81008f6c:	eb 11                	jmp    ffffffff81008f7f <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x3c7>
                return;
            }

            count ++;
ffffffff81008f6e:	48 ff 05 fb 68 ff 3e 	incq   0x3eff68fb(%rip)        # ffffffffbffff870 <_ZN3Rcu4nextE+0x10>

           *tail = e;
ffffffff81008f75:	48 89 28             	mov    %rbp,(%rax)
            tail = &e->next;
ffffffff81008f78:	48 89 2d e9 68 ff 3e 	mov    %rbp,0x3eff68e9(%rip)        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>

    Rcu::call(current);
    Rcu::call(Sc::current);
ffffffff81008f7f:	48 8b 2d 92 60 ff 3e 	mov    0x3eff6092(%rip),%rbp        # ffffffffbffff018 <_ZN2Sc7currentE>
ffffffff81008f86:	48 85 ed             	test   %rbp,%rbp
ffffffff81008f89:	74 74                	je     ffffffff81008fff <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x447>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
ffffffff81008f8b:	48 8b 45 28          	mov    0x28(%rbp),%rax
ffffffff81008f8f:	48 8d 5d 18          	lea    0x18(%rbp),%rbx
ffffffff81008f93:	48 85 c0             	test   %rax,%rax
ffffffff81008f96:	74 05                	je     ffffffff81008f9d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x3e5>
                e->pre_func(e);
ffffffff81008f98:	48 89 df             	mov    %rbx,%rdi
ffffffff81008f9b:	ff d0                	callq  *%rax
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
ffffffff81008f9d:	48 83 7d 18 00       	cmpq   $0x0,0x18(%rbp)
ffffffff81008fa2:	75 0c                	jne    ffffffff81008fb0 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x3f8>
ffffffff81008fa4:	48 8b 05 bd 68 ff 3e 	mov    0x3eff68bd(%rip),%rax        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff81008fab:	48 39 d8             	cmp    %rbx,%rax
ffffffff81008fae:	75 2f                	jne    ffffffff81008fdf <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x427>
                trace (0, "warning: rcu element already enqueued");
ffffffff81008fb0:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff81008fb5:	8b 15 49 60 ff 3e    	mov    0x3eff6049(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81008fbb:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81008fbf:	48 c7 c7 14 df 01 81 	mov    $0xffffffff8101df14,%rdi
ffffffff81008fc6:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81008fcc:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff81008fd2:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff81008fd6:	31 c0                	xor    %eax,%eax
ffffffff81008fd8:	e8 af 90 ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff81008fdd:	eb 11                	jmp    ffffffff81008ff0 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvvEEEEvv+0x438>
                return;
            }

            count ++;
ffffffff81008fdf:	48 ff 05 8a 68 ff 3e 	incq   0x3eff688a(%rip)        # ffffffffbffff870 <_ZN3Rcu4nextE+0x10>

           *tail = e;
ffffffff81008fe6:	48 89 18             	mov    %rbx,(%rax)
            tail = &e->next;
ffffffff81008fe9:	48 89 1d 78 68 ff 3e 	mov    %rbx,0x3eff6878(%rip)        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>

    Sc::schedule(true);
ffffffff81008ff0:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff81008ff5:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff81008ffa:	e8 b5 bd 00 00       	callq  ffffffff81014db4 <_ZN2Sc8scheduleEbb>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
ffffffff81008fff:	48 8b 04 25 10 00 00 	mov    0x10,%rax
ffffffff81009006:	00 
ffffffff81009007:	0f 0b                	ud2    
ffffffff81009009:	90                   	nop

ffffffff8100900a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv>:

    die ("XCPU OOM error");
}

template <void (*C)()>
void Ec::oom_xcpu_return()
ffffffff8100900a:	41 54                	push   %r12
ffffffff8100900c:	55                   	push   %rbp
ffffffff8100900d:	53                   	push   %rbx
ffffffff8100900e:	48 83 ec 10          	sub    $0x10,%rsp
{
    assert (current->xcpu_sm);
ffffffff81009012:	48 8b 05 ef 5f ff 3e 	mov    0x3eff5fef(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81009019:	48 8b a8 30 03 00 00 	mov    0x330(%rax),%rbp
ffffffff81009020:	48 85 ed             	test   %rbp,%rbp
ffffffff81009023:	75 1c                	jne    ffffffff81009041 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x37>
ffffffff81009025:	49 c7 c0 40 f9 01 81 	mov    $0xffffffff8101f940,%r8
ffffffff8100902c:	b9 87 00 00 00       	mov    $0x87,%ecx
ffffffff81009031:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff81009038:	48 c7 c6 cc de 01 81 	mov    $0xffffffff8101decc,%rsi
ffffffff8100903f:	eb 24                	jmp    ffffffff81009065 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x5b>
    assert (current->rcap);
ffffffff81009041:	48 83 b8 88 02 00 00 	cmpq   $0x0,0x288(%rax)
ffffffff81009048:	00 
ffffffff81009049:	75 28                	jne    ffffffff81009073 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x69>
ffffffff8100904b:	49 c7 c0 40 f9 01 81 	mov    $0xffffffff8101f940,%r8
ffffffff81009052:	b9 88 00 00 00       	mov    $0x88,%ecx
ffffffff81009057:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100905e:	48 c7 c6 dd de 01 81 	mov    $0xffffffff8101dedd,%rsi
ffffffff81009065:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100906c:	31 c0                	xor    %eax,%eax
ffffffff8100906e:	e8 dd 8e ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
    assert (current->utcb);
ffffffff81009073:	48 83 b8 90 02 00 00 	cmpq   $0x0,0x290(%rax)
ffffffff8100907a:	00 
ffffffff8100907b:	75 1c                	jne    ffffffff81009099 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x8f>
ffffffff8100907d:	49 c7 c0 40 f9 01 81 	mov    $0xffffffff8101f940,%r8
ffffffff81009084:	b9 89 00 00 00       	mov    $0x89,%ecx
ffffffff81009089:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff81009090:	48 c7 c6 eb de 01 81 	mov    $0xffffffff8101deeb,%rsi
ffffffff81009097:	eb cc                	jmp    ffffffff81009065 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x5b>
ffffffff81009099:	48 8b 15 78 5f ff 3e 	mov    0x3eff5f78(%rip),%rdx        # ffffffffbffff018 <_ZN2Sc7currentE>
    assert (Sc::current->ec == current);
ffffffff810090a0:	48 39 82 90 00 00 00 	cmp    %rax,0x90(%rdx)
ffffffff810090a7:	74 1c                	je     ffffffff810090c5 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0xbb>
ffffffff810090a9:	49 c7 c0 40 f9 01 81 	mov    $0xffffffff8101f940,%r8
ffffffff810090b0:	b9 8a 00 00 00       	mov    $0x8a,%ecx
ffffffff810090b5:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff810090bc:	48 c7 c6 f9 de 01 81 	mov    $0xffffffff8101def9,%rsi
ffffffff810090c3:	eb a0                	jmp    ffffffff81009065 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x5b>
        ALWAYS_INLINE
        inline void up (void (*c)() = nullptr, Sm * si = nullptr)
        {
            Ec *ec;

            {   Lock_guard <Spinlock> guard (lock);
ffffffff810090c5:	48 8d bd 8a 00 00 00 	lea    0x8a(%rbp),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff810090cc:	9c                   	pushfq 
ffffffff810090cd:	41 5c                	pop    %r12
            return flags & 0x200;
ffffffff810090cf:	49 c1 ec 09          	shr    $0x9,%r12

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff810090d3:	41 80 e4 01          	and    $0x1,%r12b
ffffffff810090d7:	74 30                	je     ffffffff81009109 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0xff>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff810090d9:	80 3d 50 66 ff 3e 00 	cmpb   $0x0,0x3eff6650(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff810090e0:	75 1f                	jne    ffffffff81009101 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0xf7>
ffffffff810090e2:	49 c7 c0 40 fb 01 81 	mov    $0xffffffff8101fb40,%r8
ffffffff810090e9:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff810090ee:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff810090f5:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff810090fc:	e9 64 ff ff ff       	jmpq   ffffffff81009065 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x5b>

            asm volatile ("cli" : : : "memory");
ffffffff81009101:	fa                   	cli    
            preemption = false;
ffffffff81009102:	c6 05 27 66 ff 3e 00 	movb   $0x0,0x3eff6627(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff81009109:	e8 80 7d ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff8100910e:	48 8b 9d 90 00 00 00 	mov    0x90(%rbp),%rbx
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff81009115:	48 85 db             	test   %rbx,%rbx
ffffffff81009118:	0f 84 ea 01 00 00    	je     ffffffff81009308 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x2fe>
ffffffff8100911e:	48 8b 83 b0 02 00 00 	mov    0x2b0(%rbx),%rax
ffffffff81009125:	48 85 c0             	test   %rax,%rax
ffffffff81009128:	0f 84 da 01 00 00    	je     ffffffff81009308 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x2fe>
ffffffff8100912e:	48 8b 93 a8 02 00 00 	mov    0x2a8(%rbx),%rdx
ffffffff81009135:	48 85 d2             	test   %rdx,%rdx
ffffffff81009138:	0f 84 ca 01 00 00    	je     ffffffff81009308 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x2fe>
                return false;

            if (t == t->next)
ffffffff8100913e:	48 39 c3             	cmp    %rax,%rbx
ffffffff81009141:	75 0d                	jne    ffffffff81009150 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x146>
                headptr = nullptr;
ffffffff81009143:	48 c7 85 90 00 00 00 	movq   $0x0,0x90(%rbp)
ffffffff8100914a:	00 00 00 00 
ffffffff8100914e:	eb 33                	jmp    ffffffff81009183 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x179>

            else {
                t->next->prev = t->prev;
ffffffff81009150:	48 89 90 a8 02 00 00 	mov    %rdx,0x2a8(%rax)
                t->prev->next = t->next;
ffffffff81009157:	48 8b 83 a8 02 00 00 	mov    0x2a8(%rbx),%rax
ffffffff8100915e:	48 8b 93 b0 02 00 00 	mov    0x2b0(%rbx),%rdx
ffffffff81009165:	48 89 90 b0 02 00 00 	mov    %rdx,0x2b0(%rax)
                if (t == headptr)
ffffffff8100916c:	48 3b 9d 90 00 00 00 	cmp    0x90(%rbp),%rbx
ffffffff81009173:	75 0e                	jne    ffffffff81009183 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x179>
                    headptr = t->next;
ffffffff81009175:	48 8b 83 b0 02 00 00 	mov    0x2b0(%rbx),%rax
ffffffff8100917c:	48 89 85 90 00 00 00 	mov    %rax,0x90(%rbp)
            }

            t->next = t->prev = nullptr;
ffffffff81009183:	48 c7 83 a8 02 00 00 	movq   $0x0,0x2a8(%rbx)
ffffffff8100918a:	00 00 00 00 
ffffffff8100918e:	48 c7 83 b0 02 00 00 	movq   $0x0,0x2b0(%rbx)
ffffffff81009195:	00 00 00 00 
ffffffff81009199:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff8100919c:	f0 0f c1 83 8c 00 00 	lock xadd %eax,0x8c(%rbx)
ffffffff810091a3:	00 

                    counter++;
                    return;
                }

                if (EXPECT_FALSE(ec->del_ref())) {
ffffffff810091a4:	ff c8                	dec    %eax
ffffffff810091a6:	75 2a                	jne    ffffffff810091d2 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x1c8>
                    delete ec;
ffffffff810091a8:	48 89 df             	mov    %rbx,%rdi
ffffffff810091ab:	e8 8c b2 ff ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff810091b0:	48 8b 83 98 02 00 00 	mov    0x298(%rbx),%rax
ffffffff810091b7:	48 89 de             	mov    %rbx,%rsi
ffffffff810091ba:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff810091c1:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff810091c8:	e8 9d c8 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
ffffffff810091cd:	e9 3c ff ff ff       	jmpq   ffffffff8100910e <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x104>
ffffffff810091d2:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff810091d8:	45 84 e4             	test   %r12b,%r12b
ffffffff810091db:	74 30                	je     ffffffff8100920d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x203>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff810091dd:	80 3d 4c 65 ff 3e 00 	cmpb   $0x0,0x3eff654c(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff810091e4:	74 1f                	je     ffffffff81009205 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x1fb>
ffffffff810091e6:	49 c7 c0 10 fb 01 81 	mov    $0xffffffff8101fb10,%r8
ffffffff810091ed:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff810091f2:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff810091f9:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff81009200:	e9 60 fe ff ff       	jmpq   ffffffff81009065 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x5b>

            preemption = true;
ffffffff81009205:	c6 05 24 65 ff 3e 01 	movb   $0x1,0x3eff6524(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100920c:	fb                   	sti    
        Sc::schedule(true);
    }

    ALWAYS_INLINE
    inline void release(void (*c)()) {
        if (c)
ffffffff8100920d:	48 c7 c0 9e bd 00 81 	mov    $0xffffffff8100bd9e,%rax
ffffffff81009214:	48 85 c0             	test   %rax,%rax
ffffffff81009217:	74 07                	je     ffffffff81009220 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x216>
            cont = c;
ffffffff81009219:	48 89 83 a0 00 00 00 	mov    %rax,0xa0(%rbx)

        Lock_guard <Spinlock> guard(lock);
ffffffff81009220:	48 8d bb 8a 00 00 00 	lea    0x8a(%rbx),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81009227:	9c                   	pushfq 
ffffffff81009228:	58                   	pop    %rax
            return flags & 0x200;
ffffffff81009229:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8100922d:	41 88 c4             	mov    %al,%r12b
ffffffff81009230:	41 80 e4 01          	and    $0x1,%r12b
ffffffff81009234:	74 15                	je     ffffffff8100924b <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x241>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81009236:	80 3d f3 64 ff 3e 00 	cmpb   $0x0,0x3eff64f3(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100923d:	0f 84 9f fe ff ff    	je     ffffffff810090e2 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0xd8>

            asm volatile ("cli" : : : "memory");
ffffffff81009243:	fa                   	cli    
            preemption = false;
ffffffff81009244:	c6 05 e5 64 ff 3e 00 	movb   $0x0,0x3eff64e5(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff8100924b:	e8 3e 7c ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff81009250:	48 8b ab 90 00 00 00 	mov    0x90(%rbx),%rbp
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff81009257:	48 85 ed             	test   %rbp,%rbp
ffffffff8100925a:	0f 84 c4 00 00 00    	je     ffffffff81009324 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x31a>
ffffffff81009260:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff81009267:	48 85 c0             	test   %rax,%rax
ffffffff8100926a:	0f 84 b4 00 00 00    	je     ffffffff81009324 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x31a>
ffffffff81009270:	48 8b 95 b8 00 00 00 	mov    0xb8(%rbp),%rdx
ffffffff81009277:	48 85 d2             	test   %rdx,%rdx
ffffffff8100927a:	0f 84 a4 00 00 00    	je     ffffffff81009324 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x31a>
                return false;

            if (t == t->next)
ffffffff81009280:	48 39 c5             	cmp    %rax,%rbp
ffffffff81009283:	75 0d                	jne    ffffffff81009292 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x288>
                headptr = nullptr;
ffffffff81009285:	48 c7 83 90 00 00 00 	movq   $0x0,0x90(%rbx)
ffffffff8100928c:	00 00 00 00 
ffffffff81009290:	eb 33                	jmp    ffffffff810092c5 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x2bb>

            else {
                t->next->prev = t->prev;
ffffffff81009292:	48 89 90 b8 00 00 00 	mov    %rdx,0xb8(%rax)
                t->prev->next = t->next;
ffffffff81009299:	48 8b 85 b8 00 00 00 	mov    0xb8(%rbp),%rax
ffffffff810092a0:	48 8b 95 c0 00 00 00 	mov    0xc0(%rbp),%rdx
ffffffff810092a7:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
                if (t == headptr)
ffffffff810092ae:	48 3b ab 90 00 00 00 	cmp    0x90(%rbx),%rbp
ffffffff810092b5:	75 0e                	jne    ffffffff810092c5 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x2bb>
                    headptr = t->next;
ffffffff810092b7:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff810092be:	48 89 83 90 00 00 00 	mov    %rax,0x90(%rbx)
            }

            t->next = t->prev = nullptr;
ffffffff810092c5:	48 c7 85 b8 00 00 00 	movq   $0x0,0xb8(%rbp)
ffffffff810092cc:	00 00 00 00 
ffffffff810092d0:	48 c7 85 c0 00 00 00 	movq   $0x0,0xc0(%rbp)
ffffffff810092d7:	00 00 00 00 
ffffffff810092db:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff810092de:	f0 0f c1 85 8c 00 00 	lock xadd %eax,0x8c(%rbp)
ffffffff810092e5:	00 

        for (Sc *s; dequeue(s = head());) {
            if (EXPECT_FALSE(s->del_ref()) && (this == s->ec)) {
ffffffff810092e6:	ff c8                	dec    %eax
ffffffff810092e8:	75 2d                	jne    ffffffff81009317 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x30d>
ffffffff810092ea:	48 3b 9d 90 00 00 00 	cmp    0x90(%rbp),%rbx
ffffffff810092f1:	75 24                	jne    ffffffff81009317 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x30d>
                delete s;
ffffffff810092f3:	48 89 ef             	mov    %rbp,%rdi
ffffffff810092f6:	e8 65 f8 ff ff       	callq  ffffffff81008b60 <_ZN2ScD1Ev>
ffffffff810092fb:	48 89 ef             	mov    %rbp,%rdi
ffffffff810092fe:	e8 27 ba 00 00       	callq  ffffffff81014d2a <_ZN2ScdlEPv>
ffffffff81009303:	e9 48 ff ff ff       	jmpq   ffffffff81009250 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x246>
                    if (si) {
                       if (si->queued()) return;
                       Queue<Si>::enqueue(si);
                    }

                    counter++;
ffffffff81009308:	48 ff 85 c0 00 00 00 	incq   0xc0(%rbp)
ffffffff8100930f:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
ffffffff81009315:	eb 13                	jmp    ffffffff8100932a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x320>
                continue;
            }
            s->remote_enqueue();
ffffffff81009317:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100931a:	e8 41 b7 00 00       	callq  ffffffff81014a60 <_ZN2Sc14remote_enqueueEv>
ffffffff8100931f:	e9 2c ff ff ff       	jmpq   ffffffff81009250 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x246>
ffffffff81009324:	fe 83 8a 00 00 00    	incb   0x8a(%rbx)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff8100932a:	45 84 e4             	test   %r12b,%r12b
ffffffff8100932d:	74 15                	je     ffffffff81009344 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x33a>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100932f:	80 3d fa 63 ff 3e 00 	cmpb   $0x0,0x3eff63fa(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81009336:	0f 85 aa fe ff ff    	jne    ffffffff810091e6 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x1dc>

            preemption = true;
ffffffff8100933c:	c6 05 ed 63 ff 3e 01 	movb   $0x1,0x3eff63ed(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81009343:	fb                   	sti    

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
ffffffff81009344:	48 8b 1d bd 5c ff 3e 	mov    0x3eff5cbd(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100934b:	48 8b 43 28          	mov    0x28(%rbx),%rax
ffffffff8100934f:	48 c7 83 88 02 00 00 	movq   $0x0,0x288(%rbx)
ffffffff81009356:	00 00 00 00 
    current->utcb    = nullptr;
    current->fpu     = nullptr;

    Rcu::call(current);
ffffffff8100935a:	48 8d 6b 18          	lea    0x18(%rbx),%rbp
    assert (Sc::current->ec == current);

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
    current->utcb    = nullptr;
ffffffff8100935e:	48 c7 83 90 02 00 00 	movq   $0x0,0x290(%rbx)
ffffffff81009365:	00 00 00 00 
    current->fpu     = nullptr;
ffffffff81009369:	48 c7 83 b8 02 00 00 	movq   $0x0,0x2b8(%rbx)
ffffffff81009370:	00 00 00 00 
ffffffff81009374:	48 85 c0             	test   %rax,%rax
ffffffff81009377:	74 05                	je     ffffffff8100937e <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x374>
                e->pre_func(e);
ffffffff81009379:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100937c:	ff d0                	callq  *%rax
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
ffffffff8100937e:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
ffffffff81009383:	75 0c                	jne    ffffffff81009391 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x387>
ffffffff81009385:	48 8b 05 dc 64 ff 3e 	mov    0x3eff64dc(%rip),%rax        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff8100938c:	48 39 e8             	cmp    %rbp,%rax
ffffffff8100938f:	75 2f                	jne    ffffffff810093c0 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x3b6>
                trace (0, "warning: rcu element already enqueued");
ffffffff81009391:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff81009396:	8b 15 68 5c ff 3e    	mov    0x3eff5c68(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100939c:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff810093a0:	48 c7 c7 14 df 01 81 	mov    $0xffffffff8101df14,%rdi
ffffffff810093a7:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff810093ad:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff810093b3:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff810093b7:	31 c0                	xor    %eax,%eax
ffffffff810093b9:	e8 ce 8c ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff810093be:	eb 11                	jmp    ffffffff810093d1 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x3c7>
                return;
            }

            count ++;
ffffffff810093c0:	48 ff 05 a9 64 ff 3e 	incq   0x3eff64a9(%rip)        # ffffffffbffff870 <_ZN3Rcu4nextE+0x10>

           *tail = e;
ffffffff810093c7:	48 89 28             	mov    %rbp,(%rax)
            tail = &e->next;
ffffffff810093ca:	48 89 2d 97 64 ff 3e 	mov    %rbp,0x3eff6497(%rip)        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>

    Rcu::call(current);
    Rcu::call(Sc::current);
ffffffff810093d1:	48 8b 2d 40 5c ff 3e 	mov    0x3eff5c40(%rip),%rbp        # ffffffffbffff018 <_ZN2Sc7currentE>
ffffffff810093d8:	48 85 ed             	test   %rbp,%rbp
ffffffff810093db:	74 74                	je     ffffffff81009451 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x447>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
ffffffff810093dd:	48 8b 45 28          	mov    0x28(%rbp),%rax
ffffffff810093e1:	48 8d 5d 18          	lea    0x18(%rbp),%rbx
ffffffff810093e5:	48 85 c0             	test   %rax,%rax
ffffffff810093e8:	74 05                	je     ffffffff810093ef <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x3e5>
                e->pre_func(e);
ffffffff810093ea:	48 89 df             	mov    %rbx,%rdi
ffffffff810093ed:	ff d0                	callq  *%rax
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
ffffffff810093ef:	48 83 7d 18 00       	cmpq   $0x0,0x18(%rbp)
ffffffff810093f4:	75 0c                	jne    ffffffff81009402 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x3f8>
ffffffff810093f6:	48 8b 05 6b 64 ff 3e 	mov    0x3eff646b(%rip),%rax        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff810093fd:	48 39 d8             	cmp    %rbx,%rax
ffffffff81009400:	75 2f                	jne    ffffffff81009431 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x427>
                trace (0, "warning: rcu element already enqueued");
ffffffff81009402:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff81009407:	8b 15 f7 5b ff 3e    	mov    0x3eff5bf7(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100940d:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81009411:	48 c7 c7 14 df 01 81 	mov    $0xffffffff8101df14,%rdi
ffffffff81009418:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8100941e:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff81009424:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff81009428:	31 c0                	xor    %eax,%eax
ffffffff8100942a:	e8 5d 8c ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff8100942f:	eb 11                	jmp    ffffffff81009442 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvvEEEEvv+0x438>
                return;
            }

            count ++;
ffffffff81009431:	48 ff 05 38 64 ff 3e 	incq   0x3eff6438(%rip)        # ffffffffbffff870 <_ZN3Rcu4nextE+0x10>

           *tail = e;
ffffffff81009438:	48 89 18             	mov    %rbx,(%rax)
            tail = &e->next;
ffffffff8100943b:	48 89 1d 26 64 ff 3e 	mov    %rbx,0x3eff6426(%rip)        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>

    Sc::schedule(true);
ffffffff81009442:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff81009447:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff8100944c:	e8 63 b9 00 00       	callq  ffffffff81014db4 <_ZN2Sc8scheduleEbb>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
ffffffff81009451:	48 8b 04 25 10 00 00 	mov    0x10,%rax
ffffffff81009458:	00 
ffffffff81009459:	0f 0b                	ud2    
ffffffff8100945b:	90                   	nop

ffffffff8100945c <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv>:

    die ("XCPU OOM error");
}

template <void (*C)()>
void Ec::oom_xcpu_return()
ffffffff8100945c:	41 54                	push   %r12
ffffffff8100945e:	55                   	push   %rbp
ffffffff8100945f:	53                   	push   %rbx
ffffffff81009460:	48 83 ec 10          	sub    $0x10,%rsp
{
    assert (current->xcpu_sm);
ffffffff81009464:	48 8b 05 9d 5b ff 3e 	mov    0x3eff5b9d(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100946b:	48 8b a8 30 03 00 00 	mov    0x330(%rax),%rbp
ffffffff81009472:	48 85 ed             	test   %rbp,%rbp
ffffffff81009475:	75 1c                	jne    ffffffff81009493 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x37>
ffffffff81009477:	49 c7 c0 40 f7 01 81 	mov    $0xffffffff8101f740,%r8
ffffffff8100947e:	b9 87 00 00 00       	mov    $0x87,%ecx
ffffffff81009483:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100948a:	48 c7 c6 cc de 01 81 	mov    $0xffffffff8101decc,%rsi
ffffffff81009491:	eb 24                	jmp    ffffffff810094b7 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x5b>
    assert (current->rcap);
ffffffff81009493:	48 83 b8 88 02 00 00 	cmpq   $0x0,0x288(%rax)
ffffffff8100949a:	00 
ffffffff8100949b:	75 28                	jne    ffffffff810094c5 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x69>
ffffffff8100949d:	49 c7 c0 40 f7 01 81 	mov    $0xffffffff8101f740,%r8
ffffffff810094a4:	b9 88 00 00 00       	mov    $0x88,%ecx
ffffffff810094a9:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff810094b0:	48 c7 c6 dd de 01 81 	mov    $0xffffffff8101dedd,%rsi
ffffffff810094b7:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff810094be:	31 c0                	xor    %eax,%eax
ffffffff810094c0:	e8 8b 8a ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
    assert (current->utcb);
ffffffff810094c5:	48 83 b8 90 02 00 00 	cmpq   $0x0,0x290(%rax)
ffffffff810094cc:	00 
ffffffff810094cd:	75 1c                	jne    ffffffff810094eb <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x8f>
ffffffff810094cf:	49 c7 c0 40 f7 01 81 	mov    $0xffffffff8101f740,%r8
ffffffff810094d6:	b9 89 00 00 00       	mov    $0x89,%ecx
ffffffff810094db:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff810094e2:	48 c7 c6 eb de 01 81 	mov    $0xffffffff8101deeb,%rsi
ffffffff810094e9:	eb cc                	jmp    ffffffff810094b7 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x5b>
ffffffff810094eb:	48 8b 15 26 5b ff 3e 	mov    0x3eff5b26(%rip),%rdx        # ffffffffbffff018 <_ZN2Sc7currentE>
    assert (Sc::current->ec == current);
ffffffff810094f2:	48 39 82 90 00 00 00 	cmp    %rax,0x90(%rdx)
ffffffff810094f9:	74 1c                	je     ffffffff81009517 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0xbb>
ffffffff810094fb:	49 c7 c0 40 f7 01 81 	mov    $0xffffffff8101f740,%r8
ffffffff81009502:	b9 8a 00 00 00       	mov    $0x8a,%ecx
ffffffff81009507:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100950e:	48 c7 c6 f9 de 01 81 	mov    $0xffffffff8101def9,%rsi
ffffffff81009515:	eb a0                	jmp    ffffffff810094b7 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x5b>
        ALWAYS_INLINE
        inline void up (void (*c)() = nullptr, Sm * si = nullptr)
        {
            Ec *ec;

            {   Lock_guard <Spinlock> guard (lock);
ffffffff81009517:	48 8d bd 8a 00 00 00 	lea    0x8a(%rbp),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff8100951e:	9c                   	pushfq 
ffffffff8100951f:	41 5c                	pop    %r12
            return flags & 0x200;
ffffffff81009521:	49 c1 ec 09          	shr    $0x9,%r12

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff81009525:	41 80 e4 01          	and    $0x1,%r12b
ffffffff81009529:	74 30                	je     ffffffff8100955b <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0xff>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff8100952b:	80 3d fe 61 ff 3e 00 	cmpb   $0x0,0x3eff61fe(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81009532:	75 1f                	jne    ffffffff81009553 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0xf7>
ffffffff81009534:	49 c7 c0 40 fb 01 81 	mov    $0xffffffff8101fb40,%r8
ffffffff8100953b:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff81009540:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81009547:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff8100954e:	e9 64 ff ff ff       	jmpq   ffffffff810094b7 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x5b>

            asm volatile ("cli" : : : "memory");
ffffffff81009553:	fa                   	cli    
            preemption = false;
ffffffff81009554:	c6 05 d5 61 ff 3e 00 	movb   $0x0,0x3eff61d5(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff8100955b:	e8 2e 79 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff81009560:	48 8b 9d 90 00 00 00 	mov    0x90(%rbp),%rbx
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff81009567:	48 85 db             	test   %rbx,%rbx
ffffffff8100956a:	0f 84 ea 01 00 00    	je     ffffffff8100975a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x2fe>
ffffffff81009570:	48 8b 83 b0 02 00 00 	mov    0x2b0(%rbx),%rax
ffffffff81009577:	48 85 c0             	test   %rax,%rax
ffffffff8100957a:	0f 84 da 01 00 00    	je     ffffffff8100975a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x2fe>
ffffffff81009580:	48 8b 93 a8 02 00 00 	mov    0x2a8(%rbx),%rdx
ffffffff81009587:	48 85 d2             	test   %rdx,%rdx
ffffffff8100958a:	0f 84 ca 01 00 00    	je     ffffffff8100975a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x2fe>
                return false;

            if (t == t->next)
ffffffff81009590:	48 39 c3             	cmp    %rax,%rbx
ffffffff81009593:	75 0d                	jne    ffffffff810095a2 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x146>
                headptr = nullptr;
ffffffff81009595:	48 c7 85 90 00 00 00 	movq   $0x0,0x90(%rbp)
ffffffff8100959c:	00 00 00 00 
ffffffff810095a0:	eb 33                	jmp    ffffffff810095d5 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x179>

            else {
                t->next->prev = t->prev;
ffffffff810095a2:	48 89 90 a8 02 00 00 	mov    %rdx,0x2a8(%rax)
                t->prev->next = t->next;
ffffffff810095a9:	48 8b 83 a8 02 00 00 	mov    0x2a8(%rbx),%rax
ffffffff810095b0:	48 8b 93 b0 02 00 00 	mov    0x2b0(%rbx),%rdx
ffffffff810095b7:	48 89 90 b0 02 00 00 	mov    %rdx,0x2b0(%rax)
                if (t == headptr)
ffffffff810095be:	48 3b 9d 90 00 00 00 	cmp    0x90(%rbp),%rbx
ffffffff810095c5:	75 0e                	jne    ffffffff810095d5 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x179>
                    headptr = t->next;
ffffffff810095c7:	48 8b 83 b0 02 00 00 	mov    0x2b0(%rbx),%rax
ffffffff810095ce:	48 89 85 90 00 00 00 	mov    %rax,0x90(%rbp)
            }

            t->next = t->prev = nullptr;
ffffffff810095d5:	48 c7 83 a8 02 00 00 	movq   $0x0,0x2a8(%rbx)
ffffffff810095dc:	00 00 00 00 
ffffffff810095e0:	48 c7 83 b0 02 00 00 	movq   $0x0,0x2b0(%rbx)
ffffffff810095e7:	00 00 00 00 
ffffffff810095eb:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff810095ee:	f0 0f c1 83 8c 00 00 	lock xadd %eax,0x8c(%rbx)
ffffffff810095f5:	00 

                    counter++;
                    return;
                }

                if (EXPECT_FALSE(ec->del_ref())) {
ffffffff810095f6:	ff c8                	dec    %eax
ffffffff810095f8:	75 2a                	jne    ffffffff81009624 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x1c8>
                    delete ec;
ffffffff810095fa:	48 89 df             	mov    %rbx,%rdi
ffffffff810095fd:	e8 3a ae ff ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff81009602:	48 8b 83 98 02 00 00 	mov    0x298(%rbx),%rax
ffffffff81009609:	48 89 de             	mov    %rbx,%rsi
ffffffff8100960c:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff81009613:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff8100961a:	e8 4b c4 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
ffffffff8100961f:	e9 3c ff ff ff       	jmpq   ffffffff81009560 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x104>
ffffffff81009624:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff8100962a:	45 84 e4             	test   %r12b,%r12b
ffffffff8100962d:	74 30                	je     ffffffff8100965f <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x203>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100962f:	80 3d fa 60 ff 3e 00 	cmpb   $0x0,0x3eff60fa(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81009636:	74 1f                	je     ffffffff81009657 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x1fb>
ffffffff81009638:	49 c7 c0 10 fb 01 81 	mov    $0xffffffff8101fb10,%r8
ffffffff8100963f:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff81009644:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100964b:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff81009652:	e9 60 fe ff ff       	jmpq   ffffffff810094b7 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x5b>

            preemption = true;
ffffffff81009657:	c6 05 d2 60 ff 3e 01 	movb   $0x1,0x3eff60d2(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100965e:	fb                   	sti    
        Sc::schedule(true);
    }

    ALWAYS_INLINE
    inline void release(void (*c)()) {
        if (c)
ffffffff8100965f:	48 c7 c0 be bf 00 81 	mov    $0xffffffff8100bfbe,%rax
ffffffff81009666:	48 85 c0             	test   %rax,%rax
ffffffff81009669:	74 07                	je     ffffffff81009672 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x216>
            cont = c;
ffffffff8100966b:	48 89 83 a0 00 00 00 	mov    %rax,0xa0(%rbx)

        Lock_guard <Spinlock> guard(lock);
ffffffff81009672:	48 8d bb 8a 00 00 00 	lea    0x8a(%rbx),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81009679:	9c                   	pushfq 
ffffffff8100967a:	58                   	pop    %rax
            return flags & 0x200;
ffffffff8100967b:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8100967f:	41 88 c4             	mov    %al,%r12b
ffffffff81009682:	41 80 e4 01          	and    $0x1,%r12b
ffffffff81009686:	74 15                	je     ffffffff8100969d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x241>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81009688:	80 3d a1 60 ff 3e 00 	cmpb   $0x0,0x3eff60a1(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100968f:	0f 84 9f fe ff ff    	je     ffffffff81009534 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0xd8>

            asm volatile ("cli" : : : "memory");
ffffffff81009695:	fa                   	cli    
            preemption = false;
ffffffff81009696:	c6 05 93 60 ff 3e 00 	movb   $0x0,0x3eff6093(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff8100969d:	e8 ec 77 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff810096a2:	48 8b ab 90 00 00 00 	mov    0x90(%rbx),%rbp
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff810096a9:	48 85 ed             	test   %rbp,%rbp
ffffffff810096ac:	0f 84 c4 00 00 00    	je     ffffffff81009776 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x31a>
ffffffff810096b2:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff810096b9:	48 85 c0             	test   %rax,%rax
ffffffff810096bc:	0f 84 b4 00 00 00    	je     ffffffff81009776 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x31a>
ffffffff810096c2:	48 8b 95 b8 00 00 00 	mov    0xb8(%rbp),%rdx
ffffffff810096c9:	48 85 d2             	test   %rdx,%rdx
ffffffff810096cc:	0f 84 a4 00 00 00    	je     ffffffff81009776 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x31a>
                return false;

            if (t == t->next)
ffffffff810096d2:	48 39 c5             	cmp    %rax,%rbp
ffffffff810096d5:	75 0d                	jne    ffffffff810096e4 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x288>
                headptr = nullptr;
ffffffff810096d7:	48 c7 83 90 00 00 00 	movq   $0x0,0x90(%rbx)
ffffffff810096de:	00 00 00 00 
ffffffff810096e2:	eb 33                	jmp    ffffffff81009717 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x2bb>

            else {
                t->next->prev = t->prev;
ffffffff810096e4:	48 89 90 b8 00 00 00 	mov    %rdx,0xb8(%rax)
                t->prev->next = t->next;
ffffffff810096eb:	48 8b 85 b8 00 00 00 	mov    0xb8(%rbp),%rax
ffffffff810096f2:	48 8b 95 c0 00 00 00 	mov    0xc0(%rbp),%rdx
ffffffff810096f9:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
                if (t == headptr)
ffffffff81009700:	48 3b ab 90 00 00 00 	cmp    0x90(%rbx),%rbp
ffffffff81009707:	75 0e                	jne    ffffffff81009717 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x2bb>
                    headptr = t->next;
ffffffff81009709:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff81009710:	48 89 83 90 00 00 00 	mov    %rax,0x90(%rbx)
            }

            t->next = t->prev = nullptr;
ffffffff81009717:	48 c7 85 b8 00 00 00 	movq   $0x0,0xb8(%rbp)
ffffffff8100971e:	00 00 00 00 
ffffffff81009722:	48 c7 85 c0 00 00 00 	movq   $0x0,0xc0(%rbp)
ffffffff81009729:	00 00 00 00 
ffffffff8100972d:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff81009730:	f0 0f c1 85 8c 00 00 	lock xadd %eax,0x8c(%rbp)
ffffffff81009737:	00 

        for (Sc *s; dequeue(s = head());) {
            if (EXPECT_FALSE(s->del_ref()) && (this == s->ec)) {
ffffffff81009738:	ff c8                	dec    %eax
ffffffff8100973a:	75 2d                	jne    ffffffff81009769 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x30d>
ffffffff8100973c:	48 3b 9d 90 00 00 00 	cmp    0x90(%rbp),%rbx
ffffffff81009743:	75 24                	jne    ffffffff81009769 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x30d>
                delete s;
ffffffff81009745:	48 89 ef             	mov    %rbp,%rdi
ffffffff81009748:	e8 13 f4 ff ff       	callq  ffffffff81008b60 <_ZN2ScD1Ev>
ffffffff8100974d:	48 89 ef             	mov    %rbp,%rdi
ffffffff81009750:	e8 d5 b5 00 00       	callq  ffffffff81014d2a <_ZN2ScdlEPv>
ffffffff81009755:	e9 48 ff ff ff       	jmpq   ffffffff810096a2 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x246>
                    if (si) {
                       if (si->queued()) return;
                       Queue<Si>::enqueue(si);
                    }

                    counter++;
ffffffff8100975a:	48 ff 85 c0 00 00 00 	incq   0xc0(%rbp)
ffffffff81009761:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
ffffffff81009767:	eb 13                	jmp    ffffffff8100977c <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x320>
                continue;
            }
            s->remote_enqueue();
ffffffff81009769:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100976c:	e8 ef b2 00 00       	callq  ffffffff81014a60 <_ZN2Sc14remote_enqueueEv>
ffffffff81009771:	e9 2c ff ff ff       	jmpq   ffffffff810096a2 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x246>
ffffffff81009776:	fe 83 8a 00 00 00    	incb   0x8a(%rbx)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff8100977c:	45 84 e4             	test   %r12b,%r12b
ffffffff8100977f:	74 15                	je     ffffffff81009796 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x33a>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81009781:	80 3d a8 5f ff 3e 00 	cmpb   $0x0,0x3eff5fa8(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81009788:	0f 85 aa fe ff ff    	jne    ffffffff81009638 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x1dc>

            preemption = true;
ffffffff8100978e:	c6 05 9b 5f ff 3e 01 	movb   $0x1,0x3eff5f9b(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81009795:	fb                   	sti    

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
ffffffff81009796:	48 8b 1d 6b 58 ff 3e 	mov    0x3eff586b(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100979d:	48 8b 43 28          	mov    0x28(%rbx),%rax
ffffffff810097a1:	48 c7 83 88 02 00 00 	movq   $0x0,0x288(%rbx)
ffffffff810097a8:	00 00 00 00 
    current->utcb    = nullptr;
    current->fpu     = nullptr;

    Rcu::call(current);
ffffffff810097ac:	48 8d 6b 18          	lea    0x18(%rbx),%rbp
    assert (Sc::current->ec == current);

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
    current->utcb    = nullptr;
ffffffff810097b0:	48 c7 83 90 02 00 00 	movq   $0x0,0x290(%rbx)
ffffffff810097b7:	00 00 00 00 
    current->fpu     = nullptr;
ffffffff810097bb:	48 c7 83 b8 02 00 00 	movq   $0x0,0x2b8(%rbx)
ffffffff810097c2:	00 00 00 00 
ffffffff810097c6:	48 85 c0             	test   %rax,%rax
ffffffff810097c9:	74 05                	je     ffffffff810097d0 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x374>
                e->pre_func(e);
ffffffff810097cb:	48 89 ef             	mov    %rbp,%rdi
ffffffff810097ce:	ff d0                	callq  *%rax
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
ffffffff810097d0:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
ffffffff810097d5:	75 0c                	jne    ffffffff810097e3 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x387>
ffffffff810097d7:	48 8b 05 8a 60 ff 3e 	mov    0x3eff608a(%rip),%rax        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff810097de:	48 39 e8             	cmp    %rbp,%rax
ffffffff810097e1:	75 2f                	jne    ffffffff81009812 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x3b6>
                trace (0, "warning: rcu element already enqueued");
ffffffff810097e3:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff810097e8:	8b 15 16 58 ff 3e    	mov    0x3eff5816(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff810097ee:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff810097f2:	48 c7 c7 14 df 01 81 	mov    $0xffffffff8101df14,%rdi
ffffffff810097f9:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff810097ff:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff81009805:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff81009809:	31 c0                	xor    %eax,%eax
ffffffff8100980b:	e8 7c 88 ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff81009810:	eb 11                	jmp    ffffffff81009823 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x3c7>
                return;
            }

            count ++;
ffffffff81009812:	48 ff 05 57 60 ff 3e 	incq   0x3eff6057(%rip)        # ffffffffbffff870 <_ZN3Rcu4nextE+0x10>

           *tail = e;
ffffffff81009819:	48 89 28             	mov    %rbp,(%rax)
            tail = &e->next;
ffffffff8100981c:	48 89 2d 45 60 ff 3e 	mov    %rbp,0x3eff6045(%rip)        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>

    Rcu::call(current);
    Rcu::call(Sc::current);
ffffffff81009823:	48 8b 2d ee 57 ff 3e 	mov    0x3eff57ee(%rip),%rbp        # ffffffffbffff018 <_ZN2Sc7currentE>
ffffffff8100982a:	48 85 ed             	test   %rbp,%rbp
ffffffff8100982d:	74 74                	je     ffffffff810098a3 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x447>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
ffffffff8100982f:	48 8b 45 28          	mov    0x28(%rbp),%rax
ffffffff81009833:	48 8d 5d 18          	lea    0x18(%rbp),%rbx
ffffffff81009837:	48 85 c0             	test   %rax,%rax
ffffffff8100983a:	74 05                	je     ffffffff81009841 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x3e5>
                e->pre_func(e);
ffffffff8100983c:	48 89 df             	mov    %rbx,%rdi
ffffffff8100983f:	ff d0                	callq  *%rax
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
ffffffff81009841:	48 83 7d 18 00       	cmpq   $0x0,0x18(%rbp)
ffffffff81009846:	75 0c                	jne    ffffffff81009854 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x3f8>
ffffffff81009848:	48 8b 05 19 60 ff 3e 	mov    0x3eff6019(%rip),%rax        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff8100984f:	48 39 d8             	cmp    %rbx,%rax
ffffffff81009852:	75 2f                	jne    ffffffff81009883 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x427>
                trace (0, "warning: rcu element already enqueued");
ffffffff81009854:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff81009859:	8b 15 a5 57 ff 3e    	mov    0x3eff57a5(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100985f:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81009863:	48 c7 c7 14 df 01 81 	mov    $0xffffffff8101df14,%rdi
ffffffff8100986a:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81009870:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff81009876:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff8100987a:	31 c0                	xor    %eax,%eax
ffffffff8100987c:	e8 0b 88 ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff81009881:	eb 11                	jmp    ffffffff81009894 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvvEEEEvv+0x438>
                return;
            }

            count ++;
ffffffff81009883:	48 ff 05 e6 5f ff 3e 	incq   0x3eff5fe6(%rip)        # ffffffffbffff870 <_ZN3Rcu4nextE+0x10>

           *tail = e;
ffffffff8100988a:	48 89 18             	mov    %rbx,(%rax)
            tail = &e->next;
ffffffff8100988d:	48 89 1d d4 5f ff 3e 	mov    %rbx,0x3eff5fd4(%rip)        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>

    Sc::schedule(true);
ffffffff81009894:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff81009899:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff8100989e:	e8 11 b5 00 00       	callq  ffffffff81014db4 <_ZN2Sc8scheduleEbb>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
ffffffff810098a3:	48 8b 04 25 10 00 00 	mov    0x10,%rax
ffffffff810098aa:	00 
ffffffff810098ab:	0f 0b                	ud2    
ffffffff810098ad:	90                   	nop

ffffffff810098ae <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv>:

    die ("XCPU OOM error");
}

template <void (*C)()>
void Ec::oom_xcpu_return()
ffffffff810098ae:	41 54                	push   %r12
ffffffff810098b0:	55                   	push   %rbp
ffffffff810098b1:	53                   	push   %rbx
ffffffff810098b2:	48 83 ec 10          	sub    $0x10,%rsp
{
    assert (current->xcpu_sm);
ffffffff810098b6:	48 8b 05 4b 57 ff 3e 	mov    0x3eff574b(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff810098bd:	48 8b a8 30 03 00 00 	mov    0x330(%rax),%rbp
ffffffff810098c4:	48 85 ed             	test   %rbp,%rbp
ffffffff810098c7:	75 1c                	jne    ffffffff810098e5 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x37>
ffffffff810098c9:	49 c7 c0 40 f5 01 81 	mov    $0xffffffff8101f540,%r8
ffffffff810098d0:	b9 87 00 00 00       	mov    $0x87,%ecx
ffffffff810098d5:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff810098dc:	48 c7 c6 cc de 01 81 	mov    $0xffffffff8101decc,%rsi
ffffffff810098e3:	eb 24                	jmp    ffffffff81009909 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x5b>
    assert (current->rcap);
ffffffff810098e5:	48 83 b8 88 02 00 00 	cmpq   $0x0,0x288(%rax)
ffffffff810098ec:	00 
ffffffff810098ed:	75 28                	jne    ffffffff81009917 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x69>
ffffffff810098ef:	49 c7 c0 40 f5 01 81 	mov    $0xffffffff8101f540,%r8
ffffffff810098f6:	b9 88 00 00 00       	mov    $0x88,%ecx
ffffffff810098fb:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff81009902:	48 c7 c6 dd de 01 81 	mov    $0xffffffff8101dedd,%rsi
ffffffff81009909:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81009910:	31 c0                	xor    %eax,%eax
ffffffff81009912:	e8 39 86 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
    assert (current->utcb);
ffffffff81009917:	48 83 b8 90 02 00 00 	cmpq   $0x0,0x290(%rax)
ffffffff8100991e:	00 
ffffffff8100991f:	75 1c                	jne    ffffffff8100993d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x8f>
ffffffff81009921:	49 c7 c0 40 f5 01 81 	mov    $0xffffffff8101f540,%r8
ffffffff81009928:	b9 89 00 00 00       	mov    $0x89,%ecx
ffffffff8100992d:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff81009934:	48 c7 c6 eb de 01 81 	mov    $0xffffffff8101deeb,%rsi
ffffffff8100993b:	eb cc                	jmp    ffffffff81009909 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x5b>
ffffffff8100993d:	48 8b 15 d4 56 ff 3e 	mov    0x3eff56d4(%rip),%rdx        # ffffffffbffff018 <_ZN2Sc7currentE>
    assert (Sc::current->ec == current);
ffffffff81009944:	48 39 82 90 00 00 00 	cmp    %rax,0x90(%rdx)
ffffffff8100994b:	74 1c                	je     ffffffff81009969 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0xbb>
ffffffff8100994d:	49 c7 c0 40 f5 01 81 	mov    $0xffffffff8101f540,%r8
ffffffff81009954:	b9 8a 00 00 00       	mov    $0x8a,%ecx
ffffffff81009959:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff81009960:	48 c7 c6 f9 de 01 81 	mov    $0xffffffff8101def9,%rsi
ffffffff81009967:	eb a0                	jmp    ffffffff81009909 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x5b>
        ALWAYS_INLINE
        inline void up (void (*c)() = nullptr, Sm * si = nullptr)
        {
            Ec *ec;

            {   Lock_guard <Spinlock> guard (lock);
ffffffff81009969:	48 8d bd 8a 00 00 00 	lea    0x8a(%rbp),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81009970:	9c                   	pushfq 
ffffffff81009971:	41 5c                	pop    %r12
            return flags & 0x200;
ffffffff81009973:	49 c1 ec 09          	shr    $0x9,%r12

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff81009977:	41 80 e4 01          	and    $0x1,%r12b
ffffffff8100997b:	74 30                	je     ffffffff810099ad <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0xff>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff8100997d:	80 3d ac 5d ff 3e 00 	cmpb   $0x0,0x3eff5dac(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81009984:	75 1f                	jne    ffffffff810099a5 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0xf7>
ffffffff81009986:	49 c7 c0 40 fb 01 81 	mov    $0xffffffff8101fb40,%r8
ffffffff8100998d:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff81009992:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81009999:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff810099a0:	e9 64 ff ff ff       	jmpq   ffffffff81009909 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x5b>

            asm volatile ("cli" : : : "memory");
ffffffff810099a5:	fa                   	cli    
            preemption = false;
ffffffff810099a6:	c6 05 83 5d ff 3e 00 	movb   $0x0,0x3eff5d83(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff810099ad:	e8 dc 74 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff810099b2:	48 8b 9d 90 00 00 00 	mov    0x90(%rbp),%rbx
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff810099b9:	48 85 db             	test   %rbx,%rbx
ffffffff810099bc:	0f 84 ea 01 00 00    	je     ffffffff81009bac <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x2fe>
ffffffff810099c2:	48 8b 83 b0 02 00 00 	mov    0x2b0(%rbx),%rax
ffffffff810099c9:	48 85 c0             	test   %rax,%rax
ffffffff810099cc:	0f 84 da 01 00 00    	je     ffffffff81009bac <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x2fe>
ffffffff810099d2:	48 8b 93 a8 02 00 00 	mov    0x2a8(%rbx),%rdx
ffffffff810099d9:	48 85 d2             	test   %rdx,%rdx
ffffffff810099dc:	0f 84 ca 01 00 00    	je     ffffffff81009bac <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x2fe>
                return false;

            if (t == t->next)
ffffffff810099e2:	48 39 c3             	cmp    %rax,%rbx
ffffffff810099e5:	75 0d                	jne    ffffffff810099f4 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x146>
                headptr = nullptr;
ffffffff810099e7:	48 c7 85 90 00 00 00 	movq   $0x0,0x90(%rbp)
ffffffff810099ee:	00 00 00 00 
ffffffff810099f2:	eb 33                	jmp    ffffffff81009a27 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x179>

            else {
                t->next->prev = t->prev;
ffffffff810099f4:	48 89 90 a8 02 00 00 	mov    %rdx,0x2a8(%rax)
                t->prev->next = t->next;
ffffffff810099fb:	48 8b 83 a8 02 00 00 	mov    0x2a8(%rbx),%rax
ffffffff81009a02:	48 8b 93 b0 02 00 00 	mov    0x2b0(%rbx),%rdx
ffffffff81009a09:	48 89 90 b0 02 00 00 	mov    %rdx,0x2b0(%rax)
                if (t == headptr)
ffffffff81009a10:	48 3b 9d 90 00 00 00 	cmp    0x90(%rbp),%rbx
ffffffff81009a17:	75 0e                	jne    ffffffff81009a27 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x179>
                    headptr = t->next;
ffffffff81009a19:	48 8b 83 b0 02 00 00 	mov    0x2b0(%rbx),%rax
ffffffff81009a20:	48 89 85 90 00 00 00 	mov    %rax,0x90(%rbp)
            }

            t->next = t->prev = nullptr;
ffffffff81009a27:	48 c7 83 a8 02 00 00 	movq   $0x0,0x2a8(%rbx)
ffffffff81009a2e:	00 00 00 00 
ffffffff81009a32:	48 c7 83 b0 02 00 00 	movq   $0x0,0x2b0(%rbx)
ffffffff81009a39:	00 00 00 00 
ffffffff81009a3d:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff81009a40:	f0 0f c1 83 8c 00 00 	lock xadd %eax,0x8c(%rbx)
ffffffff81009a47:	00 

                    counter++;
                    return;
                }

                if (EXPECT_FALSE(ec->del_ref())) {
ffffffff81009a48:	ff c8                	dec    %eax
ffffffff81009a4a:	75 2a                	jne    ffffffff81009a76 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x1c8>
                    delete ec;
ffffffff81009a4c:	48 89 df             	mov    %rbx,%rdi
ffffffff81009a4f:	e8 e8 a9 ff ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff81009a54:	48 8b 83 98 02 00 00 	mov    0x298(%rbx),%rax
ffffffff81009a5b:	48 89 de             	mov    %rbx,%rsi
ffffffff81009a5e:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff81009a65:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff81009a6c:	e8 f9 bf 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
ffffffff81009a71:	e9 3c ff ff ff       	jmpq   ffffffff810099b2 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x104>
ffffffff81009a76:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81009a7c:	45 84 e4             	test   %r12b,%r12b
ffffffff81009a7f:	74 30                	je     ffffffff81009ab1 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x203>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81009a81:	80 3d a8 5c ff 3e 00 	cmpb   $0x0,0x3eff5ca8(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81009a88:	74 1f                	je     ffffffff81009aa9 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x1fb>
ffffffff81009a8a:	49 c7 c0 10 fb 01 81 	mov    $0xffffffff8101fb10,%r8
ffffffff81009a91:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff81009a96:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81009a9d:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff81009aa4:	e9 60 fe ff ff       	jmpq   ffffffff81009909 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x5b>

            preemption = true;
ffffffff81009aa9:	c6 05 80 5c ff 3e 01 	movb   $0x1,0x3eff5c80(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81009ab0:	fb                   	sti    
        Sc::schedule(true);
    }

    ALWAYS_INLINE
    inline void release(void (*c)()) {
        if (c)
ffffffff81009ab1:	48 c7 c0 de c1 00 81 	mov    $0xffffffff8100c1de,%rax
ffffffff81009ab8:	48 85 c0             	test   %rax,%rax
ffffffff81009abb:	74 07                	je     ffffffff81009ac4 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x216>
            cont = c;
ffffffff81009abd:	48 89 83 a0 00 00 00 	mov    %rax,0xa0(%rbx)

        Lock_guard <Spinlock> guard(lock);
ffffffff81009ac4:	48 8d bb 8a 00 00 00 	lea    0x8a(%rbx),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81009acb:	9c                   	pushfq 
ffffffff81009acc:	58                   	pop    %rax
            return flags & 0x200;
ffffffff81009acd:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff81009ad1:	41 88 c4             	mov    %al,%r12b
ffffffff81009ad4:	41 80 e4 01          	and    $0x1,%r12b
ffffffff81009ad8:	74 15                	je     ffffffff81009aef <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x241>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81009ada:	80 3d 4f 5c ff 3e 00 	cmpb   $0x0,0x3eff5c4f(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81009ae1:	0f 84 9f fe ff ff    	je     ffffffff81009986 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0xd8>

            asm volatile ("cli" : : : "memory");
ffffffff81009ae7:	fa                   	cli    
            preemption = false;
ffffffff81009ae8:	c6 05 41 5c ff 3e 00 	movb   $0x0,0x3eff5c41(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff81009aef:	e8 9a 73 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff81009af4:	48 8b ab 90 00 00 00 	mov    0x90(%rbx),%rbp
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff81009afb:	48 85 ed             	test   %rbp,%rbp
ffffffff81009afe:	0f 84 c4 00 00 00    	je     ffffffff81009bc8 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x31a>
ffffffff81009b04:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff81009b0b:	48 85 c0             	test   %rax,%rax
ffffffff81009b0e:	0f 84 b4 00 00 00    	je     ffffffff81009bc8 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x31a>
ffffffff81009b14:	48 8b 95 b8 00 00 00 	mov    0xb8(%rbp),%rdx
ffffffff81009b1b:	48 85 d2             	test   %rdx,%rdx
ffffffff81009b1e:	0f 84 a4 00 00 00    	je     ffffffff81009bc8 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x31a>
                return false;

            if (t == t->next)
ffffffff81009b24:	48 39 c5             	cmp    %rax,%rbp
ffffffff81009b27:	75 0d                	jne    ffffffff81009b36 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x288>
                headptr = nullptr;
ffffffff81009b29:	48 c7 83 90 00 00 00 	movq   $0x0,0x90(%rbx)
ffffffff81009b30:	00 00 00 00 
ffffffff81009b34:	eb 33                	jmp    ffffffff81009b69 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x2bb>

            else {
                t->next->prev = t->prev;
ffffffff81009b36:	48 89 90 b8 00 00 00 	mov    %rdx,0xb8(%rax)
                t->prev->next = t->next;
ffffffff81009b3d:	48 8b 85 b8 00 00 00 	mov    0xb8(%rbp),%rax
ffffffff81009b44:	48 8b 95 c0 00 00 00 	mov    0xc0(%rbp),%rdx
ffffffff81009b4b:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
                if (t == headptr)
ffffffff81009b52:	48 3b ab 90 00 00 00 	cmp    0x90(%rbx),%rbp
ffffffff81009b59:	75 0e                	jne    ffffffff81009b69 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x2bb>
                    headptr = t->next;
ffffffff81009b5b:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff81009b62:	48 89 83 90 00 00 00 	mov    %rax,0x90(%rbx)
            }

            t->next = t->prev = nullptr;
ffffffff81009b69:	48 c7 85 b8 00 00 00 	movq   $0x0,0xb8(%rbp)
ffffffff81009b70:	00 00 00 00 
ffffffff81009b74:	48 c7 85 c0 00 00 00 	movq   $0x0,0xc0(%rbp)
ffffffff81009b7b:	00 00 00 00 
ffffffff81009b7f:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff81009b82:	f0 0f c1 85 8c 00 00 	lock xadd %eax,0x8c(%rbp)
ffffffff81009b89:	00 

        for (Sc *s; dequeue(s = head());) {
            if (EXPECT_FALSE(s->del_ref()) && (this == s->ec)) {
ffffffff81009b8a:	ff c8                	dec    %eax
ffffffff81009b8c:	75 2d                	jne    ffffffff81009bbb <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x30d>
ffffffff81009b8e:	48 3b 9d 90 00 00 00 	cmp    0x90(%rbp),%rbx
ffffffff81009b95:	75 24                	jne    ffffffff81009bbb <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x30d>
                delete s;
ffffffff81009b97:	48 89 ef             	mov    %rbp,%rdi
ffffffff81009b9a:	e8 c1 ef ff ff       	callq  ffffffff81008b60 <_ZN2ScD1Ev>
ffffffff81009b9f:	48 89 ef             	mov    %rbp,%rdi
ffffffff81009ba2:	e8 83 b1 00 00       	callq  ffffffff81014d2a <_ZN2ScdlEPv>
ffffffff81009ba7:	e9 48 ff ff ff       	jmpq   ffffffff81009af4 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x246>
                    if (si) {
                       if (si->queued()) return;
                       Queue<Si>::enqueue(si);
                    }

                    counter++;
ffffffff81009bac:	48 ff 85 c0 00 00 00 	incq   0xc0(%rbp)
ffffffff81009bb3:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
ffffffff81009bb9:	eb 13                	jmp    ffffffff81009bce <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x320>
                continue;
            }
            s->remote_enqueue();
ffffffff81009bbb:	48 89 ef             	mov    %rbp,%rdi
ffffffff81009bbe:	e8 9d ae 00 00       	callq  ffffffff81014a60 <_ZN2Sc14remote_enqueueEv>
ffffffff81009bc3:	e9 2c ff ff ff       	jmpq   ffffffff81009af4 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x246>
ffffffff81009bc8:	fe 83 8a 00 00 00    	incb   0x8a(%rbx)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81009bce:	45 84 e4             	test   %r12b,%r12b
ffffffff81009bd1:	74 15                	je     ffffffff81009be8 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x33a>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81009bd3:	80 3d 56 5b ff 3e 00 	cmpb   $0x0,0x3eff5b56(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81009bda:	0f 85 aa fe ff ff    	jne    ffffffff81009a8a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x1dc>

            preemption = true;
ffffffff81009be0:	c6 05 49 5b ff 3e 01 	movb   $0x1,0x3eff5b49(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81009be7:	fb                   	sti    

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
ffffffff81009be8:	48 8b 1d 19 54 ff 3e 	mov    0x3eff5419(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81009bef:	48 8b 43 28          	mov    0x28(%rbx),%rax
ffffffff81009bf3:	48 c7 83 88 02 00 00 	movq   $0x0,0x288(%rbx)
ffffffff81009bfa:	00 00 00 00 
    current->utcb    = nullptr;
    current->fpu     = nullptr;

    Rcu::call(current);
ffffffff81009bfe:	48 8d 6b 18          	lea    0x18(%rbx),%rbp
    assert (Sc::current->ec == current);

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
    current->utcb    = nullptr;
ffffffff81009c02:	48 c7 83 90 02 00 00 	movq   $0x0,0x290(%rbx)
ffffffff81009c09:	00 00 00 00 
    current->fpu     = nullptr;
ffffffff81009c0d:	48 c7 83 b8 02 00 00 	movq   $0x0,0x2b8(%rbx)
ffffffff81009c14:	00 00 00 00 
ffffffff81009c18:	48 85 c0             	test   %rax,%rax
ffffffff81009c1b:	74 05                	je     ffffffff81009c22 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x374>
                e->pre_func(e);
ffffffff81009c1d:	48 89 ef             	mov    %rbp,%rdi
ffffffff81009c20:	ff d0                	callq  *%rax
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
ffffffff81009c22:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
ffffffff81009c27:	75 0c                	jne    ffffffff81009c35 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x387>
ffffffff81009c29:	48 8b 05 38 5c ff 3e 	mov    0x3eff5c38(%rip),%rax        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff81009c30:	48 39 e8             	cmp    %rbp,%rax
ffffffff81009c33:	75 2f                	jne    ffffffff81009c64 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x3b6>
                trace (0, "warning: rcu element already enqueued");
ffffffff81009c35:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff81009c3a:	8b 15 c4 53 ff 3e    	mov    0x3eff53c4(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81009c40:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81009c44:	48 c7 c7 14 df 01 81 	mov    $0xffffffff8101df14,%rdi
ffffffff81009c4b:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81009c51:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff81009c57:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff81009c5b:	31 c0                	xor    %eax,%eax
ffffffff81009c5d:	e8 2a 84 ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff81009c62:	eb 11                	jmp    ffffffff81009c75 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x3c7>
                return;
            }

            count ++;
ffffffff81009c64:	48 ff 05 05 5c ff 3e 	incq   0x3eff5c05(%rip)        # ffffffffbffff870 <_ZN3Rcu4nextE+0x10>

           *tail = e;
ffffffff81009c6b:	48 89 28             	mov    %rbp,(%rax)
            tail = &e->next;
ffffffff81009c6e:	48 89 2d f3 5b ff 3e 	mov    %rbp,0x3eff5bf3(%rip)        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>

    Rcu::call(current);
    Rcu::call(Sc::current);
ffffffff81009c75:	48 8b 2d 9c 53 ff 3e 	mov    0x3eff539c(%rip),%rbp        # ffffffffbffff018 <_ZN2Sc7currentE>
ffffffff81009c7c:	48 85 ed             	test   %rbp,%rbp
ffffffff81009c7f:	74 74                	je     ffffffff81009cf5 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x447>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
ffffffff81009c81:	48 8b 45 28          	mov    0x28(%rbp),%rax
ffffffff81009c85:	48 8d 5d 18          	lea    0x18(%rbp),%rbx
ffffffff81009c89:	48 85 c0             	test   %rax,%rax
ffffffff81009c8c:	74 05                	je     ffffffff81009c93 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x3e5>
                e->pre_func(e);
ffffffff81009c8e:	48 89 df             	mov    %rbx,%rdi
ffffffff81009c91:	ff d0                	callq  *%rax
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
ffffffff81009c93:	48 83 7d 18 00       	cmpq   $0x0,0x18(%rbp)
ffffffff81009c98:	75 0c                	jne    ffffffff81009ca6 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x3f8>
ffffffff81009c9a:	48 8b 05 c7 5b ff 3e 	mov    0x3eff5bc7(%rip),%rax        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff81009ca1:	48 39 d8             	cmp    %rbx,%rax
ffffffff81009ca4:	75 2f                	jne    ffffffff81009cd5 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x427>
                trace (0, "warning: rcu element already enqueued");
ffffffff81009ca6:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff81009cab:	8b 15 53 53 ff 3e    	mov    0x3eff5353(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81009cb1:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81009cb5:	48 c7 c7 14 df 01 81 	mov    $0xffffffff8101df14,%rdi
ffffffff81009cbc:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81009cc2:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff81009cc8:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff81009ccc:	31 c0                	xor    %eax,%eax
ffffffff81009cce:	e8 b9 83 ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff81009cd3:	eb 11                	jmp    ffffffff81009ce6 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvvEEEEvv+0x438>
                return;
            }

            count ++;
ffffffff81009cd5:	48 ff 05 94 5b ff 3e 	incq   0x3eff5b94(%rip)        # ffffffffbffff870 <_ZN3Rcu4nextE+0x10>

           *tail = e;
ffffffff81009cdc:	48 89 18             	mov    %rbx,(%rax)
            tail = &e->next;
ffffffff81009cdf:	48 89 1d 82 5b ff 3e 	mov    %rbx,0x3eff5b82(%rip)        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>

    Sc::schedule(true);
ffffffff81009ce6:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff81009ceb:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff81009cf0:	e8 bf b0 00 00       	callq  ffffffff81014db4 <_ZN2Sc8scheduleEbb>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
ffffffff81009cf5:	48 8b 04 25 10 00 00 	mov    0x10,%rax
ffffffff81009cfc:	00 
ffffffff81009cfd:	0f 0b                	ud2    
ffffffff81009cff:	90                   	nop

ffffffff81009d00 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv>:

    die ("XCPU OOM error");
}

template <void (*C)()>
void Ec::oom_xcpu_return()
ffffffff81009d00:	41 54                	push   %r12
ffffffff81009d02:	55                   	push   %rbp
ffffffff81009d03:	53                   	push   %rbx
ffffffff81009d04:	48 83 ec 10          	sub    $0x10,%rsp
{
    assert (current->xcpu_sm);
ffffffff81009d08:	48 8b 05 f9 52 ff 3e 	mov    0x3eff52f9(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81009d0f:	48 8b a8 30 03 00 00 	mov    0x330(%rax),%rbp
ffffffff81009d16:	48 85 ed             	test   %rbp,%rbp
ffffffff81009d19:	75 1c                	jne    ffffffff81009d37 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x37>
ffffffff81009d1b:	49 c7 c0 40 f3 01 81 	mov    $0xffffffff8101f340,%r8
ffffffff81009d22:	b9 87 00 00 00       	mov    $0x87,%ecx
ffffffff81009d27:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff81009d2e:	48 c7 c6 cc de 01 81 	mov    $0xffffffff8101decc,%rsi
ffffffff81009d35:	eb 24                	jmp    ffffffff81009d5b <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x5b>
    assert (current->rcap);
ffffffff81009d37:	48 83 b8 88 02 00 00 	cmpq   $0x0,0x288(%rax)
ffffffff81009d3e:	00 
ffffffff81009d3f:	75 28                	jne    ffffffff81009d69 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x69>
ffffffff81009d41:	49 c7 c0 40 f3 01 81 	mov    $0xffffffff8101f340,%r8
ffffffff81009d48:	b9 88 00 00 00       	mov    $0x88,%ecx
ffffffff81009d4d:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff81009d54:	48 c7 c6 dd de 01 81 	mov    $0xffffffff8101dedd,%rsi
ffffffff81009d5b:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81009d62:	31 c0                	xor    %eax,%eax
ffffffff81009d64:	e8 e7 81 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
    assert (current->utcb);
ffffffff81009d69:	48 83 b8 90 02 00 00 	cmpq   $0x0,0x290(%rax)
ffffffff81009d70:	00 
ffffffff81009d71:	75 1c                	jne    ffffffff81009d8f <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x8f>
ffffffff81009d73:	49 c7 c0 40 f3 01 81 	mov    $0xffffffff8101f340,%r8
ffffffff81009d7a:	b9 89 00 00 00       	mov    $0x89,%ecx
ffffffff81009d7f:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff81009d86:	48 c7 c6 eb de 01 81 	mov    $0xffffffff8101deeb,%rsi
ffffffff81009d8d:	eb cc                	jmp    ffffffff81009d5b <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x5b>
ffffffff81009d8f:	48 8b 15 82 52 ff 3e 	mov    0x3eff5282(%rip),%rdx        # ffffffffbffff018 <_ZN2Sc7currentE>
    assert (Sc::current->ec == current);
ffffffff81009d96:	48 39 82 90 00 00 00 	cmp    %rax,0x90(%rdx)
ffffffff81009d9d:	74 1c                	je     ffffffff81009dbb <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0xbb>
ffffffff81009d9f:	49 c7 c0 40 f3 01 81 	mov    $0xffffffff8101f340,%r8
ffffffff81009da6:	b9 8a 00 00 00       	mov    $0x8a,%ecx
ffffffff81009dab:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff81009db2:	48 c7 c6 f9 de 01 81 	mov    $0xffffffff8101def9,%rsi
ffffffff81009db9:	eb a0                	jmp    ffffffff81009d5b <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x5b>
        ALWAYS_INLINE
        inline void up (void (*c)() = nullptr, Sm * si = nullptr)
        {
            Ec *ec;

            {   Lock_guard <Spinlock> guard (lock);
ffffffff81009dbb:	48 8d bd 8a 00 00 00 	lea    0x8a(%rbp),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81009dc2:	9c                   	pushfq 
ffffffff81009dc3:	41 5c                	pop    %r12
            return flags & 0x200;
ffffffff81009dc5:	49 c1 ec 09          	shr    $0x9,%r12

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff81009dc9:	41 80 e4 01          	and    $0x1,%r12b
ffffffff81009dcd:	74 30                	je     ffffffff81009dff <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0xff>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81009dcf:	80 3d 5a 59 ff 3e 00 	cmpb   $0x0,0x3eff595a(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81009dd6:	75 1f                	jne    ffffffff81009df7 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0xf7>
ffffffff81009dd8:	49 c7 c0 40 fb 01 81 	mov    $0xffffffff8101fb40,%r8
ffffffff81009ddf:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff81009de4:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81009deb:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff81009df2:	e9 64 ff ff ff       	jmpq   ffffffff81009d5b <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x5b>

            asm volatile ("cli" : : : "memory");
ffffffff81009df7:	fa                   	cli    
            preemption = false;
ffffffff81009df8:	c6 05 31 59 ff 3e 00 	movb   $0x0,0x3eff5931(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff81009dff:	e8 8a 70 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff81009e04:	48 8b 9d 90 00 00 00 	mov    0x90(%rbp),%rbx
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff81009e0b:	48 85 db             	test   %rbx,%rbx
ffffffff81009e0e:	0f 84 ea 01 00 00    	je     ffffffff81009ffe <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x2fe>
ffffffff81009e14:	48 8b 83 b0 02 00 00 	mov    0x2b0(%rbx),%rax
ffffffff81009e1b:	48 85 c0             	test   %rax,%rax
ffffffff81009e1e:	0f 84 da 01 00 00    	je     ffffffff81009ffe <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x2fe>
ffffffff81009e24:	48 8b 93 a8 02 00 00 	mov    0x2a8(%rbx),%rdx
ffffffff81009e2b:	48 85 d2             	test   %rdx,%rdx
ffffffff81009e2e:	0f 84 ca 01 00 00    	je     ffffffff81009ffe <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x2fe>
                return false;

            if (t == t->next)
ffffffff81009e34:	48 39 c3             	cmp    %rax,%rbx
ffffffff81009e37:	75 0d                	jne    ffffffff81009e46 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x146>
                headptr = nullptr;
ffffffff81009e39:	48 c7 85 90 00 00 00 	movq   $0x0,0x90(%rbp)
ffffffff81009e40:	00 00 00 00 
ffffffff81009e44:	eb 33                	jmp    ffffffff81009e79 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x179>

            else {
                t->next->prev = t->prev;
ffffffff81009e46:	48 89 90 a8 02 00 00 	mov    %rdx,0x2a8(%rax)
                t->prev->next = t->next;
ffffffff81009e4d:	48 8b 83 a8 02 00 00 	mov    0x2a8(%rbx),%rax
ffffffff81009e54:	48 8b 93 b0 02 00 00 	mov    0x2b0(%rbx),%rdx
ffffffff81009e5b:	48 89 90 b0 02 00 00 	mov    %rdx,0x2b0(%rax)
                if (t == headptr)
ffffffff81009e62:	48 3b 9d 90 00 00 00 	cmp    0x90(%rbp),%rbx
ffffffff81009e69:	75 0e                	jne    ffffffff81009e79 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x179>
                    headptr = t->next;
ffffffff81009e6b:	48 8b 83 b0 02 00 00 	mov    0x2b0(%rbx),%rax
ffffffff81009e72:	48 89 85 90 00 00 00 	mov    %rax,0x90(%rbp)
            }

            t->next = t->prev = nullptr;
ffffffff81009e79:	48 c7 83 a8 02 00 00 	movq   $0x0,0x2a8(%rbx)
ffffffff81009e80:	00 00 00 00 
ffffffff81009e84:	48 c7 83 b0 02 00 00 	movq   $0x0,0x2b0(%rbx)
ffffffff81009e8b:	00 00 00 00 
ffffffff81009e8f:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff81009e92:	f0 0f c1 83 8c 00 00 	lock xadd %eax,0x8c(%rbx)
ffffffff81009e99:	00 

                    counter++;
                    return;
                }

                if (EXPECT_FALSE(ec->del_ref())) {
ffffffff81009e9a:	ff c8                	dec    %eax
ffffffff81009e9c:	75 2a                	jne    ffffffff81009ec8 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x1c8>
                    delete ec;
ffffffff81009e9e:	48 89 df             	mov    %rbx,%rdi
ffffffff81009ea1:	e8 96 a5 ff ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff81009ea6:	48 8b 83 98 02 00 00 	mov    0x298(%rbx),%rax
ffffffff81009ead:	48 89 de             	mov    %rbx,%rsi
ffffffff81009eb0:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff81009eb7:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff81009ebe:	e8 a7 bb 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
ffffffff81009ec3:	e9 3c ff ff ff       	jmpq   ffffffff81009e04 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x104>
ffffffff81009ec8:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81009ece:	45 84 e4             	test   %r12b,%r12b
ffffffff81009ed1:	74 30                	je     ffffffff81009f03 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x203>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81009ed3:	80 3d 56 58 ff 3e 00 	cmpb   $0x0,0x3eff5856(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81009eda:	74 1f                	je     ffffffff81009efb <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x1fb>
ffffffff81009edc:	49 c7 c0 10 fb 01 81 	mov    $0xffffffff8101fb10,%r8
ffffffff81009ee3:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff81009ee8:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81009eef:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff81009ef6:	e9 60 fe ff ff       	jmpq   ffffffff81009d5b <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x5b>

            preemption = true;
ffffffff81009efb:	c6 05 2e 58 ff 3e 01 	movb   $0x1,0x3eff582e(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81009f02:	fb                   	sti    
        Sc::schedule(true);
    }

    ALWAYS_INLINE
    inline void release(void (*c)()) {
        if (c)
ffffffff81009f03:	48 c7 c0 fe c3 00 81 	mov    $0xffffffff8100c3fe,%rax
ffffffff81009f0a:	48 85 c0             	test   %rax,%rax
ffffffff81009f0d:	74 07                	je     ffffffff81009f16 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x216>
            cont = c;
ffffffff81009f0f:	48 89 83 a0 00 00 00 	mov    %rax,0xa0(%rbx)

        Lock_guard <Spinlock> guard(lock);
ffffffff81009f16:	48 8d bb 8a 00 00 00 	lea    0x8a(%rbx),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81009f1d:	9c                   	pushfq 
ffffffff81009f1e:	58                   	pop    %rax
            return flags & 0x200;
ffffffff81009f1f:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff81009f23:	41 88 c4             	mov    %al,%r12b
ffffffff81009f26:	41 80 e4 01          	and    $0x1,%r12b
ffffffff81009f2a:	74 15                	je     ffffffff81009f41 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x241>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81009f2c:	80 3d fd 57 ff 3e 00 	cmpb   $0x0,0x3eff57fd(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81009f33:	0f 84 9f fe ff ff    	je     ffffffff81009dd8 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0xd8>

            asm volatile ("cli" : : : "memory");
ffffffff81009f39:	fa                   	cli    
            preemption = false;
ffffffff81009f3a:	c6 05 ef 57 ff 3e 00 	movb   $0x0,0x3eff57ef(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff81009f41:	e8 48 6f ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff81009f46:	48 8b ab 90 00 00 00 	mov    0x90(%rbx),%rbp
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff81009f4d:	48 85 ed             	test   %rbp,%rbp
ffffffff81009f50:	0f 84 c4 00 00 00    	je     ffffffff8100a01a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x31a>
ffffffff81009f56:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff81009f5d:	48 85 c0             	test   %rax,%rax
ffffffff81009f60:	0f 84 b4 00 00 00    	je     ffffffff8100a01a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x31a>
ffffffff81009f66:	48 8b 95 b8 00 00 00 	mov    0xb8(%rbp),%rdx
ffffffff81009f6d:	48 85 d2             	test   %rdx,%rdx
ffffffff81009f70:	0f 84 a4 00 00 00    	je     ffffffff8100a01a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x31a>
                return false;

            if (t == t->next)
ffffffff81009f76:	48 39 c5             	cmp    %rax,%rbp
ffffffff81009f79:	75 0d                	jne    ffffffff81009f88 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x288>
                headptr = nullptr;
ffffffff81009f7b:	48 c7 83 90 00 00 00 	movq   $0x0,0x90(%rbx)
ffffffff81009f82:	00 00 00 00 
ffffffff81009f86:	eb 33                	jmp    ffffffff81009fbb <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x2bb>

            else {
                t->next->prev = t->prev;
ffffffff81009f88:	48 89 90 b8 00 00 00 	mov    %rdx,0xb8(%rax)
                t->prev->next = t->next;
ffffffff81009f8f:	48 8b 85 b8 00 00 00 	mov    0xb8(%rbp),%rax
ffffffff81009f96:	48 8b 95 c0 00 00 00 	mov    0xc0(%rbp),%rdx
ffffffff81009f9d:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
                if (t == headptr)
ffffffff81009fa4:	48 3b ab 90 00 00 00 	cmp    0x90(%rbx),%rbp
ffffffff81009fab:	75 0e                	jne    ffffffff81009fbb <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x2bb>
                    headptr = t->next;
ffffffff81009fad:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff81009fb4:	48 89 83 90 00 00 00 	mov    %rax,0x90(%rbx)
            }

            t->next = t->prev = nullptr;
ffffffff81009fbb:	48 c7 85 b8 00 00 00 	movq   $0x0,0xb8(%rbp)
ffffffff81009fc2:	00 00 00 00 
ffffffff81009fc6:	48 c7 85 c0 00 00 00 	movq   $0x0,0xc0(%rbp)
ffffffff81009fcd:	00 00 00 00 
ffffffff81009fd1:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff81009fd4:	f0 0f c1 85 8c 00 00 	lock xadd %eax,0x8c(%rbp)
ffffffff81009fdb:	00 

        for (Sc *s; dequeue(s = head());) {
            if (EXPECT_FALSE(s->del_ref()) && (this == s->ec)) {
ffffffff81009fdc:	ff c8                	dec    %eax
ffffffff81009fde:	75 2d                	jne    ffffffff8100a00d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x30d>
ffffffff81009fe0:	48 3b 9d 90 00 00 00 	cmp    0x90(%rbp),%rbx
ffffffff81009fe7:	75 24                	jne    ffffffff8100a00d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x30d>
                delete s;
ffffffff81009fe9:	48 89 ef             	mov    %rbp,%rdi
ffffffff81009fec:	e8 6f eb ff ff       	callq  ffffffff81008b60 <_ZN2ScD1Ev>
ffffffff81009ff1:	48 89 ef             	mov    %rbp,%rdi
ffffffff81009ff4:	e8 31 ad 00 00       	callq  ffffffff81014d2a <_ZN2ScdlEPv>
ffffffff81009ff9:	e9 48 ff ff ff       	jmpq   ffffffff81009f46 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x246>
                    if (si) {
                       if (si->queued()) return;
                       Queue<Si>::enqueue(si);
                    }

                    counter++;
ffffffff81009ffe:	48 ff 85 c0 00 00 00 	incq   0xc0(%rbp)
ffffffff8100a005:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
ffffffff8100a00b:	eb 13                	jmp    ffffffff8100a020 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x320>
                continue;
            }
            s->remote_enqueue();
ffffffff8100a00d:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100a010:	e8 4b aa 00 00       	callq  ffffffff81014a60 <_ZN2Sc14remote_enqueueEv>
ffffffff8100a015:	e9 2c ff ff ff       	jmpq   ffffffff81009f46 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x246>
ffffffff8100a01a:	fe 83 8a 00 00 00    	incb   0x8a(%rbx)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff8100a020:	45 84 e4             	test   %r12b,%r12b
ffffffff8100a023:	74 15                	je     ffffffff8100a03a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x33a>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100a025:	80 3d 04 57 ff 3e 00 	cmpb   $0x0,0x3eff5704(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100a02c:	0f 85 aa fe ff ff    	jne    ffffffff81009edc <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x1dc>

            preemption = true;
ffffffff8100a032:	c6 05 f7 56 ff 3e 01 	movb   $0x1,0x3eff56f7(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100a039:	fb                   	sti    

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
ffffffff8100a03a:	48 8b 1d c7 4f ff 3e 	mov    0x3eff4fc7(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100a041:	48 8b 43 28          	mov    0x28(%rbx),%rax
ffffffff8100a045:	48 c7 83 88 02 00 00 	movq   $0x0,0x288(%rbx)
ffffffff8100a04c:	00 00 00 00 
    current->utcb    = nullptr;
    current->fpu     = nullptr;

    Rcu::call(current);
ffffffff8100a050:	48 8d 6b 18          	lea    0x18(%rbx),%rbp
    assert (Sc::current->ec == current);

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
    current->utcb    = nullptr;
ffffffff8100a054:	48 c7 83 90 02 00 00 	movq   $0x0,0x290(%rbx)
ffffffff8100a05b:	00 00 00 00 
    current->fpu     = nullptr;
ffffffff8100a05f:	48 c7 83 b8 02 00 00 	movq   $0x0,0x2b8(%rbx)
ffffffff8100a066:	00 00 00 00 
ffffffff8100a06a:	48 85 c0             	test   %rax,%rax
ffffffff8100a06d:	74 05                	je     ffffffff8100a074 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x374>
                e->pre_func(e);
ffffffff8100a06f:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100a072:	ff d0                	callq  *%rax
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
ffffffff8100a074:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
ffffffff8100a079:	75 0c                	jne    ffffffff8100a087 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x387>
ffffffff8100a07b:	48 8b 05 e6 57 ff 3e 	mov    0x3eff57e6(%rip),%rax        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff8100a082:	48 39 e8             	cmp    %rbp,%rax
ffffffff8100a085:	75 2f                	jne    ffffffff8100a0b6 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x3b6>
                trace (0, "warning: rcu element already enqueued");
ffffffff8100a087:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff8100a08c:	8b 15 72 4f ff 3e    	mov    0x3eff4f72(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100a092:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff8100a096:	48 c7 c7 14 df 01 81 	mov    $0xffffffff8101df14,%rdi
ffffffff8100a09d:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8100a0a3:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff8100a0a9:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff8100a0ad:	31 c0                	xor    %eax,%eax
ffffffff8100a0af:	e8 d8 7f ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff8100a0b4:	eb 11                	jmp    ffffffff8100a0c7 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x3c7>
                return;
            }

            count ++;
ffffffff8100a0b6:	48 ff 05 b3 57 ff 3e 	incq   0x3eff57b3(%rip)        # ffffffffbffff870 <_ZN3Rcu4nextE+0x10>

           *tail = e;
ffffffff8100a0bd:	48 89 28             	mov    %rbp,(%rax)
            tail = &e->next;
ffffffff8100a0c0:	48 89 2d a1 57 ff 3e 	mov    %rbp,0x3eff57a1(%rip)        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>

    Rcu::call(current);
    Rcu::call(Sc::current);
ffffffff8100a0c7:	48 8b 2d 4a 4f ff 3e 	mov    0x3eff4f4a(%rip),%rbp        # ffffffffbffff018 <_ZN2Sc7currentE>
ffffffff8100a0ce:	48 85 ed             	test   %rbp,%rbp
ffffffff8100a0d1:	74 74                	je     ffffffff8100a147 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x447>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
ffffffff8100a0d3:	48 8b 45 28          	mov    0x28(%rbp),%rax
ffffffff8100a0d7:	48 8d 5d 18          	lea    0x18(%rbp),%rbx
ffffffff8100a0db:	48 85 c0             	test   %rax,%rax
ffffffff8100a0de:	74 05                	je     ffffffff8100a0e5 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x3e5>
                e->pre_func(e);
ffffffff8100a0e0:	48 89 df             	mov    %rbx,%rdi
ffffffff8100a0e3:	ff d0                	callq  *%rax
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
ffffffff8100a0e5:	48 83 7d 18 00       	cmpq   $0x0,0x18(%rbp)
ffffffff8100a0ea:	75 0c                	jne    ffffffff8100a0f8 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x3f8>
ffffffff8100a0ec:	48 8b 05 75 57 ff 3e 	mov    0x3eff5775(%rip),%rax        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff8100a0f3:	48 39 d8             	cmp    %rbx,%rax
ffffffff8100a0f6:	75 2f                	jne    ffffffff8100a127 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x427>
                trace (0, "warning: rcu element already enqueued");
ffffffff8100a0f8:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff8100a0fd:	8b 15 01 4f ff 3e    	mov    0x3eff4f01(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100a103:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff8100a107:	48 c7 c7 14 df 01 81 	mov    $0xffffffff8101df14,%rdi
ffffffff8100a10e:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8100a114:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff8100a11a:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff8100a11e:	31 c0                	xor    %eax,%eax
ffffffff8100a120:	e8 67 7f ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff8100a125:	eb 11                	jmp    ffffffff8100a138 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvvEEEEvv+0x438>
                return;
            }

            count ++;
ffffffff8100a127:	48 ff 05 42 57 ff 3e 	incq   0x3eff5742(%rip)        # ffffffffbffff870 <_ZN3Rcu4nextE+0x10>

           *tail = e;
ffffffff8100a12e:	48 89 18             	mov    %rbx,(%rax)
            tail = &e->next;
ffffffff8100a131:	48 89 1d 30 57 ff 3e 	mov    %rbx,0x3eff5730(%rip)        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>

    Sc::schedule(true);
ffffffff8100a138:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff8100a13d:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff8100a142:	e8 6d ac 00 00       	callq  ffffffff81014db4 <_ZN2Sc8scheduleEbb>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
ffffffff8100a147:	48 8b 04 25 10 00 00 	mov    0x10,%rax
ffffffff8100a14e:	00 
ffffffff8100a14f:	0f 0b                	ud2    
ffffffff8100a151:	90                   	nop

ffffffff8100a152 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv>:

    die ("XCPU OOM error");
}

template <void (*C)()>
void Ec::oom_xcpu_return()
ffffffff8100a152:	41 54                	push   %r12
ffffffff8100a154:	55                   	push   %rbp
ffffffff8100a155:	53                   	push   %rbx
ffffffff8100a156:	48 83 ec 10          	sub    $0x10,%rsp
{
    assert (current->xcpu_sm);
ffffffff8100a15a:	48 8b 05 a7 4e ff 3e 	mov    0x3eff4ea7(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100a161:	48 8b a8 30 03 00 00 	mov    0x330(%rax),%rbp
ffffffff8100a168:	48 85 ed             	test   %rbp,%rbp
ffffffff8100a16b:	75 1c                	jne    ffffffff8100a189 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x37>
ffffffff8100a16d:	49 c7 c0 40 f1 01 81 	mov    $0xffffffff8101f140,%r8
ffffffff8100a174:	b9 87 00 00 00       	mov    $0x87,%ecx
ffffffff8100a179:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100a180:	48 c7 c6 cc de 01 81 	mov    $0xffffffff8101decc,%rsi
ffffffff8100a187:	eb 24                	jmp    ffffffff8100a1ad <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x5b>
    assert (current->rcap);
ffffffff8100a189:	48 83 b8 88 02 00 00 	cmpq   $0x0,0x288(%rax)
ffffffff8100a190:	00 
ffffffff8100a191:	75 28                	jne    ffffffff8100a1bb <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x69>
ffffffff8100a193:	49 c7 c0 40 f1 01 81 	mov    $0xffffffff8101f140,%r8
ffffffff8100a19a:	b9 88 00 00 00       	mov    $0x88,%ecx
ffffffff8100a19f:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100a1a6:	48 c7 c6 dd de 01 81 	mov    $0xffffffff8101dedd,%rsi
ffffffff8100a1ad:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100a1b4:	31 c0                	xor    %eax,%eax
ffffffff8100a1b6:	e8 95 7d ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
    assert (current->utcb);
ffffffff8100a1bb:	48 83 b8 90 02 00 00 	cmpq   $0x0,0x290(%rax)
ffffffff8100a1c2:	00 
ffffffff8100a1c3:	75 1c                	jne    ffffffff8100a1e1 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x8f>
ffffffff8100a1c5:	49 c7 c0 40 f1 01 81 	mov    $0xffffffff8101f140,%r8
ffffffff8100a1cc:	b9 89 00 00 00       	mov    $0x89,%ecx
ffffffff8100a1d1:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100a1d8:	48 c7 c6 eb de 01 81 	mov    $0xffffffff8101deeb,%rsi
ffffffff8100a1df:	eb cc                	jmp    ffffffff8100a1ad <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x5b>
ffffffff8100a1e1:	48 8b 15 30 4e ff 3e 	mov    0x3eff4e30(%rip),%rdx        # ffffffffbffff018 <_ZN2Sc7currentE>
    assert (Sc::current->ec == current);
ffffffff8100a1e8:	48 39 82 90 00 00 00 	cmp    %rax,0x90(%rdx)
ffffffff8100a1ef:	74 1c                	je     ffffffff8100a20d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0xbb>
ffffffff8100a1f1:	49 c7 c0 40 f1 01 81 	mov    $0xffffffff8101f140,%r8
ffffffff8100a1f8:	b9 8a 00 00 00       	mov    $0x8a,%ecx
ffffffff8100a1fd:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100a204:	48 c7 c6 f9 de 01 81 	mov    $0xffffffff8101def9,%rsi
ffffffff8100a20b:	eb a0                	jmp    ffffffff8100a1ad <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x5b>
        ALWAYS_INLINE
        inline void up (void (*c)() = nullptr, Sm * si = nullptr)
        {
            Ec *ec;

            {   Lock_guard <Spinlock> guard (lock);
ffffffff8100a20d:	48 8d bd 8a 00 00 00 	lea    0x8a(%rbp),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff8100a214:	9c                   	pushfq 
ffffffff8100a215:	41 5c                	pop    %r12
            return flags & 0x200;
ffffffff8100a217:	49 c1 ec 09          	shr    $0x9,%r12

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8100a21b:	41 80 e4 01          	and    $0x1,%r12b
ffffffff8100a21f:	74 30                	je     ffffffff8100a251 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0xff>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff8100a221:	80 3d 08 55 ff 3e 00 	cmpb   $0x0,0x3eff5508(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100a228:	75 1f                	jne    ffffffff8100a249 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0xf7>
ffffffff8100a22a:	49 c7 c0 40 fb 01 81 	mov    $0xffffffff8101fb40,%r8
ffffffff8100a231:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff8100a236:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100a23d:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff8100a244:	e9 64 ff ff ff       	jmpq   ffffffff8100a1ad <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x5b>

            asm volatile ("cli" : : : "memory");
ffffffff8100a249:	fa                   	cli    
            preemption = false;
ffffffff8100a24a:	c6 05 df 54 ff 3e 00 	movb   $0x0,0x3eff54df(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff8100a251:	e8 38 6c ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff8100a256:	48 8b 9d 90 00 00 00 	mov    0x90(%rbp),%rbx
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff8100a25d:	48 85 db             	test   %rbx,%rbx
ffffffff8100a260:	0f 84 ea 01 00 00    	je     ffffffff8100a450 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x2fe>
ffffffff8100a266:	48 8b 83 b0 02 00 00 	mov    0x2b0(%rbx),%rax
ffffffff8100a26d:	48 85 c0             	test   %rax,%rax
ffffffff8100a270:	0f 84 da 01 00 00    	je     ffffffff8100a450 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x2fe>
ffffffff8100a276:	48 8b 93 a8 02 00 00 	mov    0x2a8(%rbx),%rdx
ffffffff8100a27d:	48 85 d2             	test   %rdx,%rdx
ffffffff8100a280:	0f 84 ca 01 00 00    	je     ffffffff8100a450 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x2fe>
                return false;

            if (t == t->next)
ffffffff8100a286:	48 39 c3             	cmp    %rax,%rbx
ffffffff8100a289:	75 0d                	jne    ffffffff8100a298 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x146>
                headptr = nullptr;
ffffffff8100a28b:	48 c7 85 90 00 00 00 	movq   $0x0,0x90(%rbp)
ffffffff8100a292:	00 00 00 00 
ffffffff8100a296:	eb 33                	jmp    ffffffff8100a2cb <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x179>

            else {
                t->next->prev = t->prev;
ffffffff8100a298:	48 89 90 a8 02 00 00 	mov    %rdx,0x2a8(%rax)
                t->prev->next = t->next;
ffffffff8100a29f:	48 8b 83 a8 02 00 00 	mov    0x2a8(%rbx),%rax
ffffffff8100a2a6:	48 8b 93 b0 02 00 00 	mov    0x2b0(%rbx),%rdx
ffffffff8100a2ad:	48 89 90 b0 02 00 00 	mov    %rdx,0x2b0(%rax)
                if (t == headptr)
ffffffff8100a2b4:	48 3b 9d 90 00 00 00 	cmp    0x90(%rbp),%rbx
ffffffff8100a2bb:	75 0e                	jne    ffffffff8100a2cb <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x179>
                    headptr = t->next;
ffffffff8100a2bd:	48 8b 83 b0 02 00 00 	mov    0x2b0(%rbx),%rax
ffffffff8100a2c4:	48 89 85 90 00 00 00 	mov    %rax,0x90(%rbp)
            }

            t->next = t->prev = nullptr;
ffffffff8100a2cb:	48 c7 83 a8 02 00 00 	movq   $0x0,0x2a8(%rbx)
ffffffff8100a2d2:	00 00 00 00 
ffffffff8100a2d6:	48 c7 83 b0 02 00 00 	movq   $0x0,0x2b0(%rbx)
ffffffff8100a2dd:	00 00 00 00 
ffffffff8100a2e1:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff8100a2e4:	f0 0f c1 83 8c 00 00 	lock xadd %eax,0x8c(%rbx)
ffffffff8100a2eb:	00 

                    counter++;
                    return;
                }

                if (EXPECT_FALSE(ec->del_ref())) {
ffffffff8100a2ec:	ff c8                	dec    %eax
ffffffff8100a2ee:	75 2a                	jne    ffffffff8100a31a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x1c8>
                    delete ec;
ffffffff8100a2f0:	48 89 df             	mov    %rbx,%rdi
ffffffff8100a2f3:	e8 44 a1 ff ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff8100a2f8:	48 8b 83 98 02 00 00 	mov    0x298(%rbx),%rax
ffffffff8100a2ff:	48 89 de             	mov    %rbx,%rsi
ffffffff8100a302:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff8100a309:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff8100a310:	e8 55 b7 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
ffffffff8100a315:	e9 3c ff ff ff       	jmpq   ffffffff8100a256 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x104>
ffffffff8100a31a:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff8100a320:	45 84 e4             	test   %r12b,%r12b
ffffffff8100a323:	74 30                	je     ffffffff8100a355 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x203>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100a325:	80 3d 04 54 ff 3e 00 	cmpb   $0x0,0x3eff5404(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100a32c:	74 1f                	je     ffffffff8100a34d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x1fb>
ffffffff8100a32e:	49 c7 c0 10 fb 01 81 	mov    $0xffffffff8101fb10,%r8
ffffffff8100a335:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff8100a33a:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100a341:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff8100a348:	e9 60 fe ff ff       	jmpq   ffffffff8100a1ad <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x5b>

            preemption = true;
ffffffff8100a34d:	c6 05 dc 53 ff 3e 01 	movb   $0x1,0x3eff53dc(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100a354:	fb                   	sti    
        Sc::schedule(true);
    }

    ALWAYS_INLINE
    inline void release(void (*c)()) {
        if (c)
ffffffff8100a355:	48 c7 c0 1e c6 00 81 	mov    $0xffffffff8100c61e,%rax
ffffffff8100a35c:	48 85 c0             	test   %rax,%rax
ffffffff8100a35f:	74 07                	je     ffffffff8100a368 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x216>
            cont = c;
ffffffff8100a361:	48 89 83 a0 00 00 00 	mov    %rax,0xa0(%rbx)

        Lock_guard <Spinlock> guard(lock);
ffffffff8100a368:	48 8d bb 8a 00 00 00 	lea    0x8a(%rbx),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff8100a36f:	9c                   	pushfq 
ffffffff8100a370:	58                   	pop    %rax
            return flags & 0x200;
ffffffff8100a371:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8100a375:	41 88 c4             	mov    %al,%r12b
ffffffff8100a378:	41 80 e4 01          	and    $0x1,%r12b
ffffffff8100a37c:	74 15                	je     ffffffff8100a393 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x241>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff8100a37e:	80 3d ab 53 ff 3e 00 	cmpb   $0x0,0x3eff53ab(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100a385:	0f 84 9f fe ff ff    	je     ffffffff8100a22a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0xd8>

            asm volatile ("cli" : : : "memory");
ffffffff8100a38b:	fa                   	cli    
            preemption = false;
ffffffff8100a38c:	c6 05 9d 53 ff 3e 00 	movb   $0x0,0x3eff539d(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff8100a393:	e8 f6 6a ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff8100a398:	48 8b ab 90 00 00 00 	mov    0x90(%rbx),%rbp
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff8100a39f:	48 85 ed             	test   %rbp,%rbp
ffffffff8100a3a2:	0f 84 c4 00 00 00    	je     ffffffff8100a46c <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x31a>
ffffffff8100a3a8:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff8100a3af:	48 85 c0             	test   %rax,%rax
ffffffff8100a3b2:	0f 84 b4 00 00 00    	je     ffffffff8100a46c <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x31a>
ffffffff8100a3b8:	48 8b 95 b8 00 00 00 	mov    0xb8(%rbp),%rdx
ffffffff8100a3bf:	48 85 d2             	test   %rdx,%rdx
ffffffff8100a3c2:	0f 84 a4 00 00 00    	je     ffffffff8100a46c <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x31a>
                return false;

            if (t == t->next)
ffffffff8100a3c8:	48 39 c5             	cmp    %rax,%rbp
ffffffff8100a3cb:	75 0d                	jne    ffffffff8100a3da <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x288>
                headptr = nullptr;
ffffffff8100a3cd:	48 c7 83 90 00 00 00 	movq   $0x0,0x90(%rbx)
ffffffff8100a3d4:	00 00 00 00 
ffffffff8100a3d8:	eb 33                	jmp    ffffffff8100a40d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x2bb>

            else {
                t->next->prev = t->prev;
ffffffff8100a3da:	48 89 90 b8 00 00 00 	mov    %rdx,0xb8(%rax)
                t->prev->next = t->next;
ffffffff8100a3e1:	48 8b 85 b8 00 00 00 	mov    0xb8(%rbp),%rax
ffffffff8100a3e8:	48 8b 95 c0 00 00 00 	mov    0xc0(%rbp),%rdx
ffffffff8100a3ef:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
                if (t == headptr)
ffffffff8100a3f6:	48 3b ab 90 00 00 00 	cmp    0x90(%rbx),%rbp
ffffffff8100a3fd:	75 0e                	jne    ffffffff8100a40d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x2bb>
                    headptr = t->next;
ffffffff8100a3ff:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff8100a406:	48 89 83 90 00 00 00 	mov    %rax,0x90(%rbx)
            }

            t->next = t->prev = nullptr;
ffffffff8100a40d:	48 c7 85 b8 00 00 00 	movq   $0x0,0xb8(%rbp)
ffffffff8100a414:	00 00 00 00 
ffffffff8100a418:	48 c7 85 c0 00 00 00 	movq   $0x0,0xc0(%rbp)
ffffffff8100a41f:	00 00 00 00 
ffffffff8100a423:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff8100a426:	f0 0f c1 85 8c 00 00 	lock xadd %eax,0x8c(%rbp)
ffffffff8100a42d:	00 

        for (Sc *s; dequeue(s = head());) {
            if (EXPECT_FALSE(s->del_ref()) && (this == s->ec)) {
ffffffff8100a42e:	ff c8                	dec    %eax
ffffffff8100a430:	75 2d                	jne    ffffffff8100a45f <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x30d>
ffffffff8100a432:	48 3b 9d 90 00 00 00 	cmp    0x90(%rbp),%rbx
ffffffff8100a439:	75 24                	jne    ffffffff8100a45f <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x30d>
                delete s;
ffffffff8100a43b:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100a43e:	e8 1d e7 ff ff       	callq  ffffffff81008b60 <_ZN2ScD1Ev>
ffffffff8100a443:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100a446:	e8 df a8 00 00       	callq  ffffffff81014d2a <_ZN2ScdlEPv>
ffffffff8100a44b:	e9 48 ff ff ff       	jmpq   ffffffff8100a398 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x246>
                    if (si) {
                       if (si->queued()) return;
                       Queue<Si>::enqueue(si);
                    }

                    counter++;
ffffffff8100a450:	48 ff 85 c0 00 00 00 	incq   0xc0(%rbp)
ffffffff8100a457:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
ffffffff8100a45d:	eb 13                	jmp    ffffffff8100a472 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x320>
                continue;
            }
            s->remote_enqueue();
ffffffff8100a45f:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100a462:	e8 f9 a5 00 00       	callq  ffffffff81014a60 <_ZN2Sc14remote_enqueueEv>
ffffffff8100a467:	e9 2c ff ff ff       	jmpq   ffffffff8100a398 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x246>
ffffffff8100a46c:	fe 83 8a 00 00 00    	incb   0x8a(%rbx)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff8100a472:	45 84 e4             	test   %r12b,%r12b
ffffffff8100a475:	74 15                	je     ffffffff8100a48c <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x33a>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100a477:	80 3d b2 52 ff 3e 00 	cmpb   $0x0,0x3eff52b2(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100a47e:	0f 85 aa fe ff ff    	jne    ffffffff8100a32e <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x1dc>

            preemption = true;
ffffffff8100a484:	c6 05 a5 52 ff 3e 01 	movb   $0x1,0x3eff52a5(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100a48b:	fb                   	sti    

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
ffffffff8100a48c:	48 8b 1d 75 4b ff 3e 	mov    0x3eff4b75(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100a493:	48 8b 43 28          	mov    0x28(%rbx),%rax
ffffffff8100a497:	48 c7 83 88 02 00 00 	movq   $0x0,0x288(%rbx)
ffffffff8100a49e:	00 00 00 00 
    current->utcb    = nullptr;
    current->fpu     = nullptr;

    Rcu::call(current);
ffffffff8100a4a2:	48 8d 6b 18          	lea    0x18(%rbx),%rbp
    assert (Sc::current->ec == current);

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
    current->utcb    = nullptr;
ffffffff8100a4a6:	48 c7 83 90 02 00 00 	movq   $0x0,0x290(%rbx)
ffffffff8100a4ad:	00 00 00 00 
    current->fpu     = nullptr;
ffffffff8100a4b1:	48 c7 83 b8 02 00 00 	movq   $0x0,0x2b8(%rbx)
ffffffff8100a4b8:	00 00 00 00 
ffffffff8100a4bc:	48 85 c0             	test   %rax,%rax
ffffffff8100a4bf:	74 05                	je     ffffffff8100a4c6 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x374>
                e->pre_func(e);
ffffffff8100a4c1:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100a4c4:	ff d0                	callq  *%rax
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
ffffffff8100a4c6:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
ffffffff8100a4cb:	75 0c                	jne    ffffffff8100a4d9 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x387>
ffffffff8100a4cd:	48 8b 05 94 53 ff 3e 	mov    0x3eff5394(%rip),%rax        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff8100a4d4:	48 39 e8             	cmp    %rbp,%rax
ffffffff8100a4d7:	75 2f                	jne    ffffffff8100a508 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x3b6>
                trace (0, "warning: rcu element already enqueued");
ffffffff8100a4d9:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff8100a4de:	8b 15 20 4b ff 3e    	mov    0x3eff4b20(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100a4e4:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff8100a4e8:	48 c7 c7 14 df 01 81 	mov    $0xffffffff8101df14,%rdi
ffffffff8100a4ef:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8100a4f5:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff8100a4fb:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff8100a4ff:	31 c0                	xor    %eax,%eax
ffffffff8100a501:	e8 86 7b ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff8100a506:	eb 11                	jmp    ffffffff8100a519 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x3c7>
                return;
            }

            count ++;
ffffffff8100a508:	48 ff 05 61 53 ff 3e 	incq   0x3eff5361(%rip)        # ffffffffbffff870 <_ZN3Rcu4nextE+0x10>

           *tail = e;
ffffffff8100a50f:	48 89 28             	mov    %rbp,(%rax)
            tail = &e->next;
ffffffff8100a512:	48 89 2d 4f 53 ff 3e 	mov    %rbp,0x3eff534f(%rip)        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>

    Rcu::call(current);
    Rcu::call(Sc::current);
ffffffff8100a519:	48 8b 2d f8 4a ff 3e 	mov    0x3eff4af8(%rip),%rbp        # ffffffffbffff018 <_ZN2Sc7currentE>
ffffffff8100a520:	48 85 ed             	test   %rbp,%rbp
ffffffff8100a523:	74 74                	je     ffffffff8100a599 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x447>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
ffffffff8100a525:	48 8b 45 28          	mov    0x28(%rbp),%rax
ffffffff8100a529:	48 8d 5d 18          	lea    0x18(%rbp),%rbx
ffffffff8100a52d:	48 85 c0             	test   %rax,%rax
ffffffff8100a530:	74 05                	je     ffffffff8100a537 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x3e5>
                e->pre_func(e);
ffffffff8100a532:	48 89 df             	mov    %rbx,%rdi
ffffffff8100a535:	ff d0                	callq  *%rax
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
ffffffff8100a537:	48 83 7d 18 00       	cmpq   $0x0,0x18(%rbp)
ffffffff8100a53c:	75 0c                	jne    ffffffff8100a54a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x3f8>
ffffffff8100a53e:	48 8b 05 23 53 ff 3e 	mov    0x3eff5323(%rip),%rax        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff8100a545:	48 39 d8             	cmp    %rbx,%rax
ffffffff8100a548:	75 2f                	jne    ffffffff8100a579 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x427>
                trace (0, "warning: rcu element already enqueued");
ffffffff8100a54a:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff8100a54f:	8b 15 af 4a ff 3e    	mov    0x3eff4aaf(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100a555:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff8100a559:	48 c7 c7 14 df 01 81 	mov    $0xffffffff8101df14,%rdi
ffffffff8100a560:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8100a566:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff8100a56c:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff8100a570:	31 c0                	xor    %eax,%eax
ffffffff8100a572:	e8 15 7b ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff8100a577:	eb 11                	jmp    ffffffff8100a58a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvvEEEEvv+0x438>
                return;
            }

            count ++;
ffffffff8100a579:	48 ff 05 f0 52 ff 3e 	incq   0x3eff52f0(%rip)        # ffffffffbffff870 <_ZN3Rcu4nextE+0x10>

           *tail = e;
ffffffff8100a580:	48 89 18             	mov    %rbx,(%rax)
            tail = &e->next;
ffffffff8100a583:	48 89 1d de 52 ff 3e 	mov    %rbx,0x3eff52de(%rip)        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>

    Sc::schedule(true);
ffffffff8100a58a:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff8100a58f:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff8100a594:	e8 1b a8 00 00       	callq  ffffffff81014db4 <_ZN2Sc8scheduleEbb>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
ffffffff8100a599:	48 8b 04 25 10 00 00 	mov    0x10,%rax
ffffffff8100a5a0:	00 
ffffffff8100a5a1:	0f 0b                	ud2    
ffffffff8100a5a3:	90                   	nop

ffffffff8100a5a4 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv>:

    die ("XCPU OOM error");
}

template <void (*C)()>
void Ec::oom_xcpu_return()
ffffffff8100a5a4:	41 54                	push   %r12
ffffffff8100a5a6:	55                   	push   %rbp
ffffffff8100a5a7:	53                   	push   %rbx
ffffffff8100a5a8:	48 83 ec 10          	sub    $0x10,%rsp
{
    assert (current->xcpu_sm);
ffffffff8100a5ac:	48 8b 05 55 4a ff 3e 	mov    0x3eff4a55(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100a5b3:	48 8b a8 30 03 00 00 	mov    0x330(%rax),%rbp
ffffffff8100a5ba:	48 85 ed             	test   %rbp,%rbp
ffffffff8100a5bd:	75 1c                	jne    ffffffff8100a5db <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x37>
ffffffff8100a5bf:	49 c7 c0 40 ef 01 81 	mov    $0xffffffff8101ef40,%r8
ffffffff8100a5c6:	b9 87 00 00 00       	mov    $0x87,%ecx
ffffffff8100a5cb:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100a5d2:	48 c7 c6 cc de 01 81 	mov    $0xffffffff8101decc,%rsi
ffffffff8100a5d9:	eb 24                	jmp    ffffffff8100a5ff <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x5b>
    assert (current->rcap);
ffffffff8100a5db:	48 83 b8 88 02 00 00 	cmpq   $0x0,0x288(%rax)
ffffffff8100a5e2:	00 
ffffffff8100a5e3:	75 28                	jne    ffffffff8100a60d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x69>
ffffffff8100a5e5:	49 c7 c0 40 ef 01 81 	mov    $0xffffffff8101ef40,%r8
ffffffff8100a5ec:	b9 88 00 00 00       	mov    $0x88,%ecx
ffffffff8100a5f1:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100a5f8:	48 c7 c6 dd de 01 81 	mov    $0xffffffff8101dedd,%rsi
ffffffff8100a5ff:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100a606:	31 c0                	xor    %eax,%eax
ffffffff8100a608:	e8 43 79 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
    assert (current->utcb);
ffffffff8100a60d:	48 83 b8 90 02 00 00 	cmpq   $0x0,0x290(%rax)
ffffffff8100a614:	00 
ffffffff8100a615:	75 1c                	jne    ffffffff8100a633 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x8f>
ffffffff8100a617:	49 c7 c0 40 ef 01 81 	mov    $0xffffffff8101ef40,%r8
ffffffff8100a61e:	b9 89 00 00 00       	mov    $0x89,%ecx
ffffffff8100a623:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100a62a:	48 c7 c6 eb de 01 81 	mov    $0xffffffff8101deeb,%rsi
ffffffff8100a631:	eb cc                	jmp    ffffffff8100a5ff <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x5b>
ffffffff8100a633:	48 8b 15 de 49 ff 3e 	mov    0x3eff49de(%rip),%rdx        # ffffffffbffff018 <_ZN2Sc7currentE>
    assert (Sc::current->ec == current);
ffffffff8100a63a:	48 39 82 90 00 00 00 	cmp    %rax,0x90(%rdx)
ffffffff8100a641:	74 1c                	je     ffffffff8100a65f <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0xbb>
ffffffff8100a643:	49 c7 c0 40 ef 01 81 	mov    $0xffffffff8101ef40,%r8
ffffffff8100a64a:	b9 8a 00 00 00       	mov    $0x8a,%ecx
ffffffff8100a64f:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100a656:	48 c7 c6 f9 de 01 81 	mov    $0xffffffff8101def9,%rsi
ffffffff8100a65d:	eb a0                	jmp    ffffffff8100a5ff <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x5b>
        ALWAYS_INLINE
        inline void up (void (*c)() = nullptr, Sm * si = nullptr)
        {
            Ec *ec;

            {   Lock_guard <Spinlock> guard (lock);
ffffffff8100a65f:	48 8d bd 8a 00 00 00 	lea    0x8a(%rbp),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff8100a666:	9c                   	pushfq 
ffffffff8100a667:	41 5c                	pop    %r12
            return flags & 0x200;
ffffffff8100a669:	49 c1 ec 09          	shr    $0x9,%r12

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8100a66d:	41 80 e4 01          	and    $0x1,%r12b
ffffffff8100a671:	74 30                	je     ffffffff8100a6a3 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0xff>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff8100a673:	80 3d b6 50 ff 3e 00 	cmpb   $0x0,0x3eff50b6(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100a67a:	75 1f                	jne    ffffffff8100a69b <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0xf7>
ffffffff8100a67c:	49 c7 c0 40 fb 01 81 	mov    $0xffffffff8101fb40,%r8
ffffffff8100a683:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff8100a688:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100a68f:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff8100a696:	e9 64 ff ff ff       	jmpq   ffffffff8100a5ff <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x5b>

            asm volatile ("cli" : : : "memory");
ffffffff8100a69b:	fa                   	cli    
            preemption = false;
ffffffff8100a69c:	c6 05 8d 50 ff 3e 00 	movb   $0x0,0x3eff508d(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff8100a6a3:	e8 e6 67 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff8100a6a8:	48 8b 9d 90 00 00 00 	mov    0x90(%rbp),%rbx
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff8100a6af:	48 85 db             	test   %rbx,%rbx
ffffffff8100a6b2:	0f 84 ea 01 00 00    	je     ffffffff8100a8a2 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x2fe>
ffffffff8100a6b8:	48 8b 83 b0 02 00 00 	mov    0x2b0(%rbx),%rax
ffffffff8100a6bf:	48 85 c0             	test   %rax,%rax
ffffffff8100a6c2:	0f 84 da 01 00 00    	je     ffffffff8100a8a2 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x2fe>
ffffffff8100a6c8:	48 8b 93 a8 02 00 00 	mov    0x2a8(%rbx),%rdx
ffffffff8100a6cf:	48 85 d2             	test   %rdx,%rdx
ffffffff8100a6d2:	0f 84 ca 01 00 00    	je     ffffffff8100a8a2 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x2fe>
                return false;

            if (t == t->next)
ffffffff8100a6d8:	48 39 c3             	cmp    %rax,%rbx
ffffffff8100a6db:	75 0d                	jne    ffffffff8100a6ea <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x146>
                headptr = nullptr;
ffffffff8100a6dd:	48 c7 85 90 00 00 00 	movq   $0x0,0x90(%rbp)
ffffffff8100a6e4:	00 00 00 00 
ffffffff8100a6e8:	eb 33                	jmp    ffffffff8100a71d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x179>

            else {
                t->next->prev = t->prev;
ffffffff8100a6ea:	48 89 90 a8 02 00 00 	mov    %rdx,0x2a8(%rax)
                t->prev->next = t->next;
ffffffff8100a6f1:	48 8b 83 a8 02 00 00 	mov    0x2a8(%rbx),%rax
ffffffff8100a6f8:	48 8b 93 b0 02 00 00 	mov    0x2b0(%rbx),%rdx
ffffffff8100a6ff:	48 89 90 b0 02 00 00 	mov    %rdx,0x2b0(%rax)
                if (t == headptr)
ffffffff8100a706:	48 3b 9d 90 00 00 00 	cmp    0x90(%rbp),%rbx
ffffffff8100a70d:	75 0e                	jne    ffffffff8100a71d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x179>
                    headptr = t->next;
ffffffff8100a70f:	48 8b 83 b0 02 00 00 	mov    0x2b0(%rbx),%rax
ffffffff8100a716:	48 89 85 90 00 00 00 	mov    %rax,0x90(%rbp)
            }

            t->next = t->prev = nullptr;
ffffffff8100a71d:	48 c7 83 a8 02 00 00 	movq   $0x0,0x2a8(%rbx)
ffffffff8100a724:	00 00 00 00 
ffffffff8100a728:	48 c7 83 b0 02 00 00 	movq   $0x0,0x2b0(%rbx)
ffffffff8100a72f:	00 00 00 00 
ffffffff8100a733:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff8100a736:	f0 0f c1 83 8c 00 00 	lock xadd %eax,0x8c(%rbx)
ffffffff8100a73d:	00 

                    counter++;
                    return;
                }

                if (EXPECT_FALSE(ec->del_ref())) {
ffffffff8100a73e:	ff c8                	dec    %eax
ffffffff8100a740:	75 2a                	jne    ffffffff8100a76c <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x1c8>
                    delete ec;
ffffffff8100a742:	48 89 df             	mov    %rbx,%rdi
ffffffff8100a745:	e8 f2 9c ff ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff8100a74a:	48 8b 83 98 02 00 00 	mov    0x298(%rbx),%rax
ffffffff8100a751:	48 89 de             	mov    %rbx,%rsi
ffffffff8100a754:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff8100a75b:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff8100a762:	e8 03 b3 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
ffffffff8100a767:	e9 3c ff ff ff       	jmpq   ffffffff8100a6a8 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x104>
ffffffff8100a76c:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff8100a772:	45 84 e4             	test   %r12b,%r12b
ffffffff8100a775:	74 30                	je     ffffffff8100a7a7 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x203>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100a777:	80 3d b2 4f ff 3e 00 	cmpb   $0x0,0x3eff4fb2(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100a77e:	74 1f                	je     ffffffff8100a79f <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x1fb>
ffffffff8100a780:	49 c7 c0 10 fb 01 81 	mov    $0xffffffff8101fb10,%r8
ffffffff8100a787:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff8100a78c:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100a793:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff8100a79a:	e9 60 fe ff ff       	jmpq   ffffffff8100a5ff <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x5b>

            preemption = true;
ffffffff8100a79f:	c6 05 8a 4f ff 3e 01 	movb   $0x1,0x3eff4f8a(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100a7a6:	fb                   	sti    
        Sc::schedule(true);
    }

    ALWAYS_INLINE
    inline void release(void (*c)()) {
        if (c)
ffffffff8100a7a7:	48 c7 c0 3e c8 00 81 	mov    $0xffffffff8100c83e,%rax
ffffffff8100a7ae:	48 85 c0             	test   %rax,%rax
ffffffff8100a7b1:	74 07                	je     ffffffff8100a7ba <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x216>
            cont = c;
ffffffff8100a7b3:	48 89 83 a0 00 00 00 	mov    %rax,0xa0(%rbx)

        Lock_guard <Spinlock> guard(lock);
ffffffff8100a7ba:	48 8d bb 8a 00 00 00 	lea    0x8a(%rbx),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff8100a7c1:	9c                   	pushfq 
ffffffff8100a7c2:	58                   	pop    %rax
            return flags & 0x200;
ffffffff8100a7c3:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8100a7c7:	41 88 c4             	mov    %al,%r12b
ffffffff8100a7ca:	41 80 e4 01          	and    $0x1,%r12b
ffffffff8100a7ce:	74 15                	je     ffffffff8100a7e5 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x241>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff8100a7d0:	80 3d 59 4f ff 3e 00 	cmpb   $0x0,0x3eff4f59(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100a7d7:	0f 84 9f fe ff ff    	je     ffffffff8100a67c <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0xd8>

            asm volatile ("cli" : : : "memory");
ffffffff8100a7dd:	fa                   	cli    
            preemption = false;
ffffffff8100a7de:	c6 05 4b 4f ff 3e 00 	movb   $0x0,0x3eff4f4b(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff8100a7e5:	e8 a4 66 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff8100a7ea:	48 8b ab 90 00 00 00 	mov    0x90(%rbx),%rbp
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff8100a7f1:	48 85 ed             	test   %rbp,%rbp
ffffffff8100a7f4:	0f 84 c4 00 00 00    	je     ffffffff8100a8be <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x31a>
ffffffff8100a7fa:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff8100a801:	48 85 c0             	test   %rax,%rax
ffffffff8100a804:	0f 84 b4 00 00 00    	je     ffffffff8100a8be <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x31a>
ffffffff8100a80a:	48 8b 95 b8 00 00 00 	mov    0xb8(%rbp),%rdx
ffffffff8100a811:	48 85 d2             	test   %rdx,%rdx
ffffffff8100a814:	0f 84 a4 00 00 00    	je     ffffffff8100a8be <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x31a>
                return false;

            if (t == t->next)
ffffffff8100a81a:	48 39 c5             	cmp    %rax,%rbp
ffffffff8100a81d:	75 0d                	jne    ffffffff8100a82c <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x288>
                headptr = nullptr;
ffffffff8100a81f:	48 c7 83 90 00 00 00 	movq   $0x0,0x90(%rbx)
ffffffff8100a826:	00 00 00 00 
ffffffff8100a82a:	eb 33                	jmp    ffffffff8100a85f <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x2bb>

            else {
                t->next->prev = t->prev;
ffffffff8100a82c:	48 89 90 b8 00 00 00 	mov    %rdx,0xb8(%rax)
                t->prev->next = t->next;
ffffffff8100a833:	48 8b 85 b8 00 00 00 	mov    0xb8(%rbp),%rax
ffffffff8100a83a:	48 8b 95 c0 00 00 00 	mov    0xc0(%rbp),%rdx
ffffffff8100a841:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
                if (t == headptr)
ffffffff8100a848:	48 3b ab 90 00 00 00 	cmp    0x90(%rbx),%rbp
ffffffff8100a84f:	75 0e                	jne    ffffffff8100a85f <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x2bb>
                    headptr = t->next;
ffffffff8100a851:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff8100a858:	48 89 83 90 00 00 00 	mov    %rax,0x90(%rbx)
            }

            t->next = t->prev = nullptr;
ffffffff8100a85f:	48 c7 85 b8 00 00 00 	movq   $0x0,0xb8(%rbp)
ffffffff8100a866:	00 00 00 00 
ffffffff8100a86a:	48 c7 85 c0 00 00 00 	movq   $0x0,0xc0(%rbp)
ffffffff8100a871:	00 00 00 00 
ffffffff8100a875:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff8100a878:	f0 0f c1 85 8c 00 00 	lock xadd %eax,0x8c(%rbp)
ffffffff8100a87f:	00 

        for (Sc *s; dequeue(s = head());) {
            if (EXPECT_FALSE(s->del_ref()) && (this == s->ec)) {
ffffffff8100a880:	ff c8                	dec    %eax
ffffffff8100a882:	75 2d                	jne    ffffffff8100a8b1 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x30d>
ffffffff8100a884:	48 3b 9d 90 00 00 00 	cmp    0x90(%rbp),%rbx
ffffffff8100a88b:	75 24                	jne    ffffffff8100a8b1 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x30d>
                delete s;
ffffffff8100a88d:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100a890:	e8 cb e2 ff ff       	callq  ffffffff81008b60 <_ZN2ScD1Ev>
ffffffff8100a895:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100a898:	e8 8d a4 00 00       	callq  ffffffff81014d2a <_ZN2ScdlEPv>
ffffffff8100a89d:	e9 48 ff ff ff       	jmpq   ffffffff8100a7ea <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x246>
                    if (si) {
                       if (si->queued()) return;
                       Queue<Si>::enqueue(si);
                    }

                    counter++;
ffffffff8100a8a2:	48 ff 85 c0 00 00 00 	incq   0xc0(%rbp)
ffffffff8100a8a9:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
ffffffff8100a8af:	eb 13                	jmp    ffffffff8100a8c4 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x320>
                continue;
            }
            s->remote_enqueue();
ffffffff8100a8b1:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100a8b4:	e8 a7 a1 00 00       	callq  ffffffff81014a60 <_ZN2Sc14remote_enqueueEv>
ffffffff8100a8b9:	e9 2c ff ff ff       	jmpq   ffffffff8100a7ea <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x246>
ffffffff8100a8be:	fe 83 8a 00 00 00    	incb   0x8a(%rbx)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff8100a8c4:	45 84 e4             	test   %r12b,%r12b
ffffffff8100a8c7:	74 15                	je     ffffffff8100a8de <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x33a>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100a8c9:	80 3d 60 4e ff 3e 00 	cmpb   $0x0,0x3eff4e60(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100a8d0:	0f 85 aa fe ff ff    	jne    ffffffff8100a780 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x1dc>

            preemption = true;
ffffffff8100a8d6:	c6 05 53 4e ff 3e 01 	movb   $0x1,0x3eff4e53(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100a8dd:	fb                   	sti    

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
ffffffff8100a8de:	48 8b 1d 23 47 ff 3e 	mov    0x3eff4723(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100a8e5:	48 8b 43 28          	mov    0x28(%rbx),%rax
ffffffff8100a8e9:	48 c7 83 88 02 00 00 	movq   $0x0,0x288(%rbx)
ffffffff8100a8f0:	00 00 00 00 
    current->utcb    = nullptr;
    current->fpu     = nullptr;

    Rcu::call(current);
ffffffff8100a8f4:	48 8d 6b 18          	lea    0x18(%rbx),%rbp
    assert (Sc::current->ec == current);

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
    current->utcb    = nullptr;
ffffffff8100a8f8:	48 c7 83 90 02 00 00 	movq   $0x0,0x290(%rbx)
ffffffff8100a8ff:	00 00 00 00 
    current->fpu     = nullptr;
ffffffff8100a903:	48 c7 83 b8 02 00 00 	movq   $0x0,0x2b8(%rbx)
ffffffff8100a90a:	00 00 00 00 
ffffffff8100a90e:	48 85 c0             	test   %rax,%rax
ffffffff8100a911:	74 05                	je     ffffffff8100a918 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x374>
                e->pre_func(e);
ffffffff8100a913:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100a916:	ff d0                	callq  *%rax
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
ffffffff8100a918:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
ffffffff8100a91d:	75 0c                	jne    ffffffff8100a92b <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x387>
ffffffff8100a91f:	48 8b 05 42 4f ff 3e 	mov    0x3eff4f42(%rip),%rax        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff8100a926:	48 39 e8             	cmp    %rbp,%rax
ffffffff8100a929:	75 2f                	jne    ffffffff8100a95a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x3b6>
                trace (0, "warning: rcu element already enqueued");
ffffffff8100a92b:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff8100a930:	8b 15 ce 46 ff 3e    	mov    0x3eff46ce(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100a936:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff8100a93a:	48 c7 c7 14 df 01 81 	mov    $0xffffffff8101df14,%rdi
ffffffff8100a941:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8100a947:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff8100a94d:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff8100a951:	31 c0                	xor    %eax,%eax
ffffffff8100a953:	e8 34 77 ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff8100a958:	eb 11                	jmp    ffffffff8100a96b <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x3c7>
                return;
            }

            count ++;
ffffffff8100a95a:	48 ff 05 0f 4f ff 3e 	incq   0x3eff4f0f(%rip)        # ffffffffbffff870 <_ZN3Rcu4nextE+0x10>

           *tail = e;
ffffffff8100a961:	48 89 28             	mov    %rbp,(%rax)
            tail = &e->next;
ffffffff8100a964:	48 89 2d fd 4e ff 3e 	mov    %rbp,0x3eff4efd(%rip)        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>

    Rcu::call(current);
    Rcu::call(Sc::current);
ffffffff8100a96b:	48 8b 2d a6 46 ff 3e 	mov    0x3eff46a6(%rip),%rbp        # ffffffffbffff018 <_ZN2Sc7currentE>
ffffffff8100a972:	48 85 ed             	test   %rbp,%rbp
ffffffff8100a975:	74 74                	je     ffffffff8100a9eb <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x447>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
ffffffff8100a977:	48 8b 45 28          	mov    0x28(%rbp),%rax
ffffffff8100a97b:	48 8d 5d 18          	lea    0x18(%rbp),%rbx
ffffffff8100a97f:	48 85 c0             	test   %rax,%rax
ffffffff8100a982:	74 05                	je     ffffffff8100a989 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x3e5>
                e->pre_func(e);
ffffffff8100a984:	48 89 df             	mov    %rbx,%rdi
ffffffff8100a987:	ff d0                	callq  *%rax
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
ffffffff8100a989:	48 83 7d 18 00       	cmpq   $0x0,0x18(%rbp)
ffffffff8100a98e:	75 0c                	jne    ffffffff8100a99c <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x3f8>
ffffffff8100a990:	48 8b 05 d1 4e ff 3e 	mov    0x3eff4ed1(%rip),%rax        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff8100a997:	48 39 d8             	cmp    %rbx,%rax
ffffffff8100a99a:	75 2f                	jne    ffffffff8100a9cb <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x427>
                trace (0, "warning: rcu element already enqueued");
ffffffff8100a99c:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff8100a9a1:	8b 15 5d 46 ff 3e    	mov    0x3eff465d(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100a9a7:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff8100a9ab:	48 c7 c7 14 df 01 81 	mov    $0xffffffff8101df14,%rdi
ffffffff8100a9b2:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8100a9b8:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff8100a9be:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff8100a9c2:	31 c0                	xor    %eax,%eax
ffffffff8100a9c4:	e8 c3 76 ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff8100a9c9:	eb 11                	jmp    ffffffff8100a9dc <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvvEEEEvv+0x438>
                return;
            }

            count ++;
ffffffff8100a9cb:	48 ff 05 9e 4e ff 3e 	incq   0x3eff4e9e(%rip)        # ffffffffbffff870 <_ZN3Rcu4nextE+0x10>

           *tail = e;
ffffffff8100a9d2:	48 89 18             	mov    %rbx,(%rax)
            tail = &e->next;
ffffffff8100a9d5:	48 89 1d 8c 4e ff 3e 	mov    %rbx,0x3eff4e8c(%rip)        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>

    Sc::schedule(true);
ffffffff8100a9dc:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff8100a9e1:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff8100a9e6:	e8 c9 a3 00 00       	callq  ffffffff81014db4 <_ZN2Sc8scheduleEbb>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
ffffffff8100a9eb:	48 8b 04 25 10 00 00 	mov    0x10,%rax
ffffffff8100a9f2:	00 
ffffffff8100a9f3:	0f 0b                	ud2    
ffffffff8100a9f5:	90                   	nop

ffffffff8100a9f6 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv>:

    die ("XCPU OOM error");
}

template <void (*C)()>
void Ec::oom_xcpu_return()
ffffffff8100a9f6:	41 54                	push   %r12
ffffffff8100a9f8:	55                   	push   %rbp
ffffffff8100a9f9:	53                   	push   %rbx
ffffffff8100a9fa:	48 83 ec 10          	sub    $0x10,%rsp
{
    assert (current->xcpu_sm);
ffffffff8100a9fe:	48 8b 05 03 46 ff 3e 	mov    0x3eff4603(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100aa05:	48 8b a8 30 03 00 00 	mov    0x330(%rax),%rbp
ffffffff8100aa0c:	48 85 ed             	test   %rbp,%rbp
ffffffff8100aa0f:	75 1c                	jne    ffffffff8100aa2d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x37>
ffffffff8100aa11:	49 c7 c0 40 ed 01 81 	mov    $0xffffffff8101ed40,%r8
ffffffff8100aa18:	b9 87 00 00 00       	mov    $0x87,%ecx
ffffffff8100aa1d:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100aa24:	48 c7 c6 cc de 01 81 	mov    $0xffffffff8101decc,%rsi
ffffffff8100aa2b:	eb 24                	jmp    ffffffff8100aa51 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x5b>
    assert (current->rcap);
ffffffff8100aa2d:	48 83 b8 88 02 00 00 	cmpq   $0x0,0x288(%rax)
ffffffff8100aa34:	00 
ffffffff8100aa35:	75 28                	jne    ffffffff8100aa5f <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x69>
ffffffff8100aa37:	49 c7 c0 40 ed 01 81 	mov    $0xffffffff8101ed40,%r8
ffffffff8100aa3e:	b9 88 00 00 00       	mov    $0x88,%ecx
ffffffff8100aa43:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100aa4a:	48 c7 c6 dd de 01 81 	mov    $0xffffffff8101dedd,%rsi
ffffffff8100aa51:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100aa58:	31 c0                	xor    %eax,%eax
ffffffff8100aa5a:	e8 f1 74 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
    assert (current->utcb);
ffffffff8100aa5f:	48 83 b8 90 02 00 00 	cmpq   $0x0,0x290(%rax)
ffffffff8100aa66:	00 
ffffffff8100aa67:	75 1c                	jne    ffffffff8100aa85 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x8f>
ffffffff8100aa69:	49 c7 c0 40 ed 01 81 	mov    $0xffffffff8101ed40,%r8
ffffffff8100aa70:	b9 89 00 00 00       	mov    $0x89,%ecx
ffffffff8100aa75:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100aa7c:	48 c7 c6 eb de 01 81 	mov    $0xffffffff8101deeb,%rsi
ffffffff8100aa83:	eb cc                	jmp    ffffffff8100aa51 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x5b>
ffffffff8100aa85:	48 8b 15 8c 45 ff 3e 	mov    0x3eff458c(%rip),%rdx        # ffffffffbffff018 <_ZN2Sc7currentE>
    assert (Sc::current->ec == current);
ffffffff8100aa8c:	48 39 82 90 00 00 00 	cmp    %rax,0x90(%rdx)
ffffffff8100aa93:	74 1c                	je     ffffffff8100aab1 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0xbb>
ffffffff8100aa95:	49 c7 c0 40 ed 01 81 	mov    $0xffffffff8101ed40,%r8
ffffffff8100aa9c:	b9 8a 00 00 00       	mov    $0x8a,%ecx
ffffffff8100aaa1:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100aaa8:	48 c7 c6 f9 de 01 81 	mov    $0xffffffff8101def9,%rsi
ffffffff8100aaaf:	eb a0                	jmp    ffffffff8100aa51 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x5b>
        ALWAYS_INLINE
        inline void up (void (*c)() = nullptr, Sm * si = nullptr)
        {
            Ec *ec;

            {   Lock_guard <Spinlock> guard (lock);
ffffffff8100aab1:	48 8d bd 8a 00 00 00 	lea    0x8a(%rbp),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff8100aab8:	9c                   	pushfq 
ffffffff8100aab9:	41 5c                	pop    %r12
            return flags & 0x200;
ffffffff8100aabb:	49 c1 ec 09          	shr    $0x9,%r12

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8100aabf:	41 80 e4 01          	and    $0x1,%r12b
ffffffff8100aac3:	74 30                	je     ffffffff8100aaf5 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0xff>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff8100aac5:	80 3d 64 4c ff 3e 00 	cmpb   $0x0,0x3eff4c64(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100aacc:	75 1f                	jne    ffffffff8100aaed <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0xf7>
ffffffff8100aace:	49 c7 c0 40 fb 01 81 	mov    $0xffffffff8101fb40,%r8
ffffffff8100aad5:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff8100aada:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100aae1:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff8100aae8:	e9 64 ff ff ff       	jmpq   ffffffff8100aa51 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x5b>

            asm volatile ("cli" : : : "memory");
ffffffff8100aaed:	fa                   	cli    
            preemption = false;
ffffffff8100aaee:	c6 05 3b 4c ff 3e 00 	movb   $0x0,0x3eff4c3b(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff8100aaf5:	e8 94 63 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff8100aafa:	48 8b 9d 90 00 00 00 	mov    0x90(%rbp),%rbx
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff8100ab01:	48 85 db             	test   %rbx,%rbx
ffffffff8100ab04:	0f 84 ea 01 00 00    	je     ffffffff8100acf4 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x2fe>
ffffffff8100ab0a:	48 8b 83 b0 02 00 00 	mov    0x2b0(%rbx),%rax
ffffffff8100ab11:	48 85 c0             	test   %rax,%rax
ffffffff8100ab14:	0f 84 da 01 00 00    	je     ffffffff8100acf4 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x2fe>
ffffffff8100ab1a:	48 8b 93 a8 02 00 00 	mov    0x2a8(%rbx),%rdx
ffffffff8100ab21:	48 85 d2             	test   %rdx,%rdx
ffffffff8100ab24:	0f 84 ca 01 00 00    	je     ffffffff8100acf4 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x2fe>
                return false;

            if (t == t->next)
ffffffff8100ab2a:	48 39 c3             	cmp    %rax,%rbx
ffffffff8100ab2d:	75 0d                	jne    ffffffff8100ab3c <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x146>
                headptr = nullptr;
ffffffff8100ab2f:	48 c7 85 90 00 00 00 	movq   $0x0,0x90(%rbp)
ffffffff8100ab36:	00 00 00 00 
ffffffff8100ab3a:	eb 33                	jmp    ffffffff8100ab6f <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x179>

            else {
                t->next->prev = t->prev;
ffffffff8100ab3c:	48 89 90 a8 02 00 00 	mov    %rdx,0x2a8(%rax)
                t->prev->next = t->next;
ffffffff8100ab43:	48 8b 83 a8 02 00 00 	mov    0x2a8(%rbx),%rax
ffffffff8100ab4a:	48 8b 93 b0 02 00 00 	mov    0x2b0(%rbx),%rdx
ffffffff8100ab51:	48 89 90 b0 02 00 00 	mov    %rdx,0x2b0(%rax)
                if (t == headptr)
ffffffff8100ab58:	48 3b 9d 90 00 00 00 	cmp    0x90(%rbp),%rbx
ffffffff8100ab5f:	75 0e                	jne    ffffffff8100ab6f <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x179>
                    headptr = t->next;
ffffffff8100ab61:	48 8b 83 b0 02 00 00 	mov    0x2b0(%rbx),%rax
ffffffff8100ab68:	48 89 85 90 00 00 00 	mov    %rax,0x90(%rbp)
            }

            t->next = t->prev = nullptr;
ffffffff8100ab6f:	48 c7 83 a8 02 00 00 	movq   $0x0,0x2a8(%rbx)
ffffffff8100ab76:	00 00 00 00 
ffffffff8100ab7a:	48 c7 83 b0 02 00 00 	movq   $0x0,0x2b0(%rbx)
ffffffff8100ab81:	00 00 00 00 
ffffffff8100ab85:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff8100ab88:	f0 0f c1 83 8c 00 00 	lock xadd %eax,0x8c(%rbx)
ffffffff8100ab8f:	00 

                    counter++;
                    return;
                }

                if (EXPECT_FALSE(ec->del_ref())) {
ffffffff8100ab90:	ff c8                	dec    %eax
ffffffff8100ab92:	75 2a                	jne    ffffffff8100abbe <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x1c8>
                    delete ec;
ffffffff8100ab94:	48 89 df             	mov    %rbx,%rdi
ffffffff8100ab97:	e8 a0 98 ff ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff8100ab9c:	48 8b 83 98 02 00 00 	mov    0x298(%rbx),%rax
ffffffff8100aba3:	48 89 de             	mov    %rbx,%rsi
ffffffff8100aba6:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff8100abad:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff8100abb4:	e8 b1 ae 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
ffffffff8100abb9:	e9 3c ff ff ff       	jmpq   ffffffff8100aafa <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x104>
ffffffff8100abbe:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff8100abc4:	45 84 e4             	test   %r12b,%r12b
ffffffff8100abc7:	74 30                	je     ffffffff8100abf9 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x203>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100abc9:	80 3d 60 4b ff 3e 00 	cmpb   $0x0,0x3eff4b60(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100abd0:	74 1f                	je     ffffffff8100abf1 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x1fb>
ffffffff8100abd2:	49 c7 c0 10 fb 01 81 	mov    $0xffffffff8101fb10,%r8
ffffffff8100abd9:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff8100abde:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100abe5:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff8100abec:	e9 60 fe ff ff       	jmpq   ffffffff8100aa51 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x5b>

            preemption = true;
ffffffff8100abf1:	c6 05 38 4b ff 3e 01 	movb   $0x1,0x3eff4b38(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100abf8:	fb                   	sti    
        Sc::schedule(true);
    }

    ALWAYS_INLINE
    inline void release(void (*c)()) {
        if (c)
ffffffff8100abf9:	48 c7 c0 5e ca 00 81 	mov    $0xffffffff8100ca5e,%rax
ffffffff8100ac00:	48 85 c0             	test   %rax,%rax
ffffffff8100ac03:	74 07                	je     ffffffff8100ac0c <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x216>
            cont = c;
ffffffff8100ac05:	48 89 83 a0 00 00 00 	mov    %rax,0xa0(%rbx)

        Lock_guard <Spinlock> guard(lock);
ffffffff8100ac0c:	48 8d bb 8a 00 00 00 	lea    0x8a(%rbx),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff8100ac13:	9c                   	pushfq 
ffffffff8100ac14:	58                   	pop    %rax
            return flags & 0x200;
ffffffff8100ac15:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8100ac19:	41 88 c4             	mov    %al,%r12b
ffffffff8100ac1c:	41 80 e4 01          	and    $0x1,%r12b
ffffffff8100ac20:	74 15                	je     ffffffff8100ac37 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x241>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff8100ac22:	80 3d 07 4b ff 3e 00 	cmpb   $0x0,0x3eff4b07(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100ac29:	0f 84 9f fe ff ff    	je     ffffffff8100aace <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0xd8>

            asm volatile ("cli" : : : "memory");
ffffffff8100ac2f:	fa                   	cli    
            preemption = false;
ffffffff8100ac30:	c6 05 f9 4a ff 3e 00 	movb   $0x0,0x3eff4af9(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff8100ac37:	e8 52 62 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff8100ac3c:	48 8b ab 90 00 00 00 	mov    0x90(%rbx),%rbp
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff8100ac43:	48 85 ed             	test   %rbp,%rbp
ffffffff8100ac46:	0f 84 c4 00 00 00    	je     ffffffff8100ad10 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x31a>
ffffffff8100ac4c:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff8100ac53:	48 85 c0             	test   %rax,%rax
ffffffff8100ac56:	0f 84 b4 00 00 00    	je     ffffffff8100ad10 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x31a>
ffffffff8100ac5c:	48 8b 95 b8 00 00 00 	mov    0xb8(%rbp),%rdx
ffffffff8100ac63:	48 85 d2             	test   %rdx,%rdx
ffffffff8100ac66:	0f 84 a4 00 00 00    	je     ffffffff8100ad10 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x31a>
                return false;

            if (t == t->next)
ffffffff8100ac6c:	48 39 c5             	cmp    %rax,%rbp
ffffffff8100ac6f:	75 0d                	jne    ffffffff8100ac7e <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x288>
                headptr = nullptr;
ffffffff8100ac71:	48 c7 83 90 00 00 00 	movq   $0x0,0x90(%rbx)
ffffffff8100ac78:	00 00 00 00 
ffffffff8100ac7c:	eb 33                	jmp    ffffffff8100acb1 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x2bb>

            else {
                t->next->prev = t->prev;
ffffffff8100ac7e:	48 89 90 b8 00 00 00 	mov    %rdx,0xb8(%rax)
                t->prev->next = t->next;
ffffffff8100ac85:	48 8b 85 b8 00 00 00 	mov    0xb8(%rbp),%rax
ffffffff8100ac8c:	48 8b 95 c0 00 00 00 	mov    0xc0(%rbp),%rdx
ffffffff8100ac93:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
                if (t == headptr)
ffffffff8100ac9a:	48 3b ab 90 00 00 00 	cmp    0x90(%rbx),%rbp
ffffffff8100aca1:	75 0e                	jne    ffffffff8100acb1 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x2bb>
                    headptr = t->next;
ffffffff8100aca3:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff8100acaa:	48 89 83 90 00 00 00 	mov    %rax,0x90(%rbx)
            }

            t->next = t->prev = nullptr;
ffffffff8100acb1:	48 c7 85 b8 00 00 00 	movq   $0x0,0xb8(%rbp)
ffffffff8100acb8:	00 00 00 00 
ffffffff8100acbc:	48 c7 85 c0 00 00 00 	movq   $0x0,0xc0(%rbp)
ffffffff8100acc3:	00 00 00 00 
ffffffff8100acc7:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff8100acca:	f0 0f c1 85 8c 00 00 	lock xadd %eax,0x8c(%rbp)
ffffffff8100acd1:	00 

        for (Sc *s; dequeue(s = head());) {
            if (EXPECT_FALSE(s->del_ref()) && (this == s->ec)) {
ffffffff8100acd2:	ff c8                	dec    %eax
ffffffff8100acd4:	75 2d                	jne    ffffffff8100ad03 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x30d>
ffffffff8100acd6:	48 3b 9d 90 00 00 00 	cmp    0x90(%rbp),%rbx
ffffffff8100acdd:	75 24                	jne    ffffffff8100ad03 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x30d>
                delete s;
ffffffff8100acdf:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100ace2:	e8 79 de ff ff       	callq  ffffffff81008b60 <_ZN2ScD1Ev>
ffffffff8100ace7:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100acea:	e8 3b a0 00 00       	callq  ffffffff81014d2a <_ZN2ScdlEPv>
ffffffff8100acef:	e9 48 ff ff ff       	jmpq   ffffffff8100ac3c <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x246>
                    if (si) {
                       if (si->queued()) return;
                       Queue<Si>::enqueue(si);
                    }

                    counter++;
ffffffff8100acf4:	48 ff 85 c0 00 00 00 	incq   0xc0(%rbp)
ffffffff8100acfb:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
ffffffff8100ad01:	eb 13                	jmp    ffffffff8100ad16 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x320>
                continue;
            }
            s->remote_enqueue();
ffffffff8100ad03:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100ad06:	e8 55 9d 00 00       	callq  ffffffff81014a60 <_ZN2Sc14remote_enqueueEv>
ffffffff8100ad0b:	e9 2c ff ff ff       	jmpq   ffffffff8100ac3c <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x246>
ffffffff8100ad10:	fe 83 8a 00 00 00    	incb   0x8a(%rbx)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff8100ad16:	45 84 e4             	test   %r12b,%r12b
ffffffff8100ad19:	74 15                	je     ffffffff8100ad30 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x33a>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100ad1b:	80 3d 0e 4a ff 3e 00 	cmpb   $0x0,0x3eff4a0e(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100ad22:	0f 85 aa fe ff ff    	jne    ffffffff8100abd2 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x1dc>

            preemption = true;
ffffffff8100ad28:	c6 05 01 4a ff 3e 01 	movb   $0x1,0x3eff4a01(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100ad2f:	fb                   	sti    

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
ffffffff8100ad30:	48 8b 1d d1 42 ff 3e 	mov    0x3eff42d1(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100ad37:	48 8b 43 28          	mov    0x28(%rbx),%rax
ffffffff8100ad3b:	48 c7 83 88 02 00 00 	movq   $0x0,0x288(%rbx)
ffffffff8100ad42:	00 00 00 00 
    current->utcb    = nullptr;
    current->fpu     = nullptr;

    Rcu::call(current);
ffffffff8100ad46:	48 8d 6b 18          	lea    0x18(%rbx),%rbp
    assert (Sc::current->ec == current);

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
    current->utcb    = nullptr;
ffffffff8100ad4a:	48 c7 83 90 02 00 00 	movq   $0x0,0x290(%rbx)
ffffffff8100ad51:	00 00 00 00 
    current->fpu     = nullptr;
ffffffff8100ad55:	48 c7 83 b8 02 00 00 	movq   $0x0,0x2b8(%rbx)
ffffffff8100ad5c:	00 00 00 00 
ffffffff8100ad60:	48 85 c0             	test   %rax,%rax
ffffffff8100ad63:	74 05                	je     ffffffff8100ad6a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x374>
                e->pre_func(e);
ffffffff8100ad65:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100ad68:	ff d0                	callq  *%rax
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
ffffffff8100ad6a:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
ffffffff8100ad6f:	75 0c                	jne    ffffffff8100ad7d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x387>
ffffffff8100ad71:	48 8b 05 f0 4a ff 3e 	mov    0x3eff4af0(%rip),%rax        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff8100ad78:	48 39 e8             	cmp    %rbp,%rax
ffffffff8100ad7b:	75 2f                	jne    ffffffff8100adac <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x3b6>
                trace (0, "warning: rcu element already enqueued");
ffffffff8100ad7d:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff8100ad82:	8b 15 7c 42 ff 3e    	mov    0x3eff427c(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100ad88:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff8100ad8c:	48 c7 c7 14 df 01 81 	mov    $0xffffffff8101df14,%rdi
ffffffff8100ad93:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8100ad99:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff8100ad9f:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff8100ada3:	31 c0                	xor    %eax,%eax
ffffffff8100ada5:	e8 e2 72 ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff8100adaa:	eb 11                	jmp    ffffffff8100adbd <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x3c7>
                return;
            }

            count ++;
ffffffff8100adac:	48 ff 05 bd 4a ff 3e 	incq   0x3eff4abd(%rip)        # ffffffffbffff870 <_ZN3Rcu4nextE+0x10>

           *tail = e;
ffffffff8100adb3:	48 89 28             	mov    %rbp,(%rax)
            tail = &e->next;
ffffffff8100adb6:	48 89 2d ab 4a ff 3e 	mov    %rbp,0x3eff4aab(%rip)        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>

    Rcu::call(current);
    Rcu::call(Sc::current);
ffffffff8100adbd:	48 8b 2d 54 42 ff 3e 	mov    0x3eff4254(%rip),%rbp        # ffffffffbffff018 <_ZN2Sc7currentE>
ffffffff8100adc4:	48 85 ed             	test   %rbp,%rbp
ffffffff8100adc7:	74 74                	je     ffffffff8100ae3d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x447>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
ffffffff8100adc9:	48 8b 45 28          	mov    0x28(%rbp),%rax
ffffffff8100adcd:	48 8d 5d 18          	lea    0x18(%rbp),%rbx
ffffffff8100add1:	48 85 c0             	test   %rax,%rax
ffffffff8100add4:	74 05                	je     ffffffff8100addb <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x3e5>
                e->pre_func(e);
ffffffff8100add6:	48 89 df             	mov    %rbx,%rdi
ffffffff8100add9:	ff d0                	callq  *%rax
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
ffffffff8100addb:	48 83 7d 18 00       	cmpq   $0x0,0x18(%rbp)
ffffffff8100ade0:	75 0c                	jne    ffffffff8100adee <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x3f8>
ffffffff8100ade2:	48 8b 05 7f 4a ff 3e 	mov    0x3eff4a7f(%rip),%rax        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff8100ade9:	48 39 d8             	cmp    %rbx,%rax
ffffffff8100adec:	75 2f                	jne    ffffffff8100ae1d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x427>
                trace (0, "warning: rcu element already enqueued");
ffffffff8100adee:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff8100adf3:	8b 15 0b 42 ff 3e    	mov    0x3eff420b(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100adf9:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff8100adfd:	48 c7 c7 14 df 01 81 	mov    $0xffffffff8101df14,%rdi
ffffffff8100ae04:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8100ae0a:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff8100ae10:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff8100ae14:	31 c0                	xor    %eax,%eax
ffffffff8100ae16:	e8 71 72 ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff8100ae1b:	eb 11                	jmp    ffffffff8100ae2e <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvvEEEEvv+0x438>
                return;
            }

            count ++;
ffffffff8100ae1d:	48 ff 05 4c 4a ff 3e 	incq   0x3eff4a4c(%rip)        # ffffffffbffff870 <_ZN3Rcu4nextE+0x10>

           *tail = e;
ffffffff8100ae24:	48 89 18             	mov    %rbx,(%rax)
            tail = &e->next;
ffffffff8100ae27:	48 89 1d 3a 4a ff 3e 	mov    %rbx,0x3eff4a3a(%rip)        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>

    Sc::schedule(true);
ffffffff8100ae2e:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff8100ae33:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff8100ae38:	e8 77 9f 00 00       	callq  ffffffff81014db4 <_ZN2Sc8scheduleEbb>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
ffffffff8100ae3d:	48 8b 04 25 10 00 00 	mov    0x10,%rax
ffffffff8100ae44:	00 
ffffffff8100ae45:	0f 0b                	ud2    
ffffffff8100ae47:	90                   	nop

ffffffff8100ae48 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv>:

    die ("XCPU OOM error");
}

template <void (*C)()>
void Ec::oom_xcpu_return()
ffffffff8100ae48:	41 54                	push   %r12
ffffffff8100ae4a:	55                   	push   %rbp
ffffffff8100ae4b:	53                   	push   %rbx
ffffffff8100ae4c:	48 83 ec 10          	sub    $0x10,%rsp
{
    assert (current->xcpu_sm);
ffffffff8100ae50:	48 8b 05 b1 41 ff 3e 	mov    0x3eff41b1(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100ae57:	48 8b a8 30 03 00 00 	mov    0x330(%rax),%rbp
ffffffff8100ae5e:	48 85 ed             	test   %rbp,%rbp
ffffffff8100ae61:	75 1c                	jne    ffffffff8100ae7f <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x37>
ffffffff8100ae63:	49 c7 c0 40 eb 01 81 	mov    $0xffffffff8101eb40,%r8
ffffffff8100ae6a:	b9 87 00 00 00       	mov    $0x87,%ecx
ffffffff8100ae6f:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100ae76:	48 c7 c6 cc de 01 81 	mov    $0xffffffff8101decc,%rsi
ffffffff8100ae7d:	eb 24                	jmp    ffffffff8100aea3 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x5b>
    assert (current->rcap);
ffffffff8100ae7f:	48 83 b8 88 02 00 00 	cmpq   $0x0,0x288(%rax)
ffffffff8100ae86:	00 
ffffffff8100ae87:	75 28                	jne    ffffffff8100aeb1 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x69>
ffffffff8100ae89:	49 c7 c0 40 eb 01 81 	mov    $0xffffffff8101eb40,%r8
ffffffff8100ae90:	b9 88 00 00 00       	mov    $0x88,%ecx
ffffffff8100ae95:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100ae9c:	48 c7 c6 dd de 01 81 	mov    $0xffffffff8101dedd,%rsi
ffffffff8100aea3:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100aeaa:	31 c0                	xor    %eax,%eax
ffffffff8100aeac:	e8 9f 70 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
    assert (current->utcb);
ffffffff8100aeb1:	48 83 b8 90 02 00 00 	cmpq   $0x0,0x290(%rax)
ffffffff8100aeb8:	00 
ffffffff8100aeb9:	75 1c                	jne    ffffffff8100aed7 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x8f>
ffffffff8100aebb:	49 c7 c0 40 eb 01 81 	mov    $0xffffffff8101eb40,%r8
ffffffff8100aec2:	b9 89 00 00 00       	mov    $0x89,%ecx
ffffffff8100aec7:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100aece:	48 c7 c6 eb de 01 81 	mov    $0xffffffff8101deeb,%rsi
ffffffff8100aed5:	eb cc                	jmp    ffffffff8100aea3 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x5b>
ffffffff8100aed7:	48 8b 15 3a 41 ff 3e 	mov    0x3eff413a(%rip),%rdx        # ffffffffbffff018 <_ZN2Sc7currentE>
    assert (Sc::current->ec == current);
ffffffff8100aede:	48 39 82 90 00 00 00 	cmp    %rax,0x90(%rdx)
ffffffff8100aee5:	74 1c                	je     ffffffff8100af03 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0xbb>
ffffffff8100aee7:	49 c7 c0 40 eb 01 81 	mov    $0xffffffff8101eb40,%r8
ffffffff8100aeee:	b9 8a 00 00 00       	mov    $0x8a,%ecx
ffffffff8100aef3:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100aefa:	48 c7 c6 f9 de 01 81 	mov    $0xffffffff8101def9,%rsi
ffffffff8100af01:	eb a0                	jmp    ffffffff8100aea3 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x5b>
        ALWAYS_INLINE
        inline void up (void (*c)() = nullptr, Sm * si = nullptr)
        {
            Ec *ec;

            {   Lock_guard <Spinlock> guard (lock);
ffffffff8100af03:	48 8d bd 8a 00 00 00 	lea    0x8a(%rbp),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff8100af0a:	9c                   	pushfq 
ffffffff8100af0b:	41 5c                	pop    %r12
            return flags & 0x200;
ffffffff8100af0d:	49 c1 ec 09          	shr    $0x9,%r12

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8100af11:	41 80 e4 01          	and    $0x1,%r12b
ffffffff8100af15:	74 30                	je     ffffffff8100af47 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0xff>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff8100af17:	80 3d 12 48 ff 3e 00 	cmpb   $0x0,0x3eff4812(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100af1e:	75 1f                	jne    ffffffff8100af3f <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0xf7>
ffffffff8100af20:	49 c7 c0 40 fb 01 81 	mov    $0xffffffff8101fb40,%r8
ffffffff8100af27:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff8100af2c:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100af33:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff8100af3a:	e9 64 ff ff ff       	jmpq   ffffffff8100aea3 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x5b>

            asm volatile ("cli" : : : "memory");
ffffffff8100af3f:	fa                   	cli    
            preemption = false;
ffffffff8100af40:	c6 05 e9 47 ff 3e 00 	movb   $0x0,0x3eff47e9(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff8100af47:	e8 42 5f ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff8100af4c:	48 8b 9d 90 00 00 00 	mov    0x90(%rbp),%rbx
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff8100af53:	48 85 db             	test   %rbx,%rbx
ffffffff8100af56:	0f 84 ea 01 00 00    	je     ffffffff8100b146 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x2fe>
ffffffff8100af5c:	48 8b 83 b0 02 00 00 	mov    0x2b0(%rbx),%rax
ffffffff8100af63:	48 85 c0             	test   %rax,%rax
ffffffff8100af66:	0f 84 da 01 00 00    	je     ffffffff8100b146 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x2fe>
ffffffff8100af6c:	48 8b 93 a8 02 00 00 	mov    0x2a8(%rbx),%rdx
ffffffff8100af73:	48 85 d2             	test   %rdx,%rdx
ffffffff8100af76:	0f 84 ca 01 00 00    	je     ffffffff8100b146 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x2fe>
                return false;

            if (t == t->next)
ffffffff8100af7c:	48 39 c3             	cmp    %rax,%rbx
ffffffff8100af7f:	75 0d                	jne    ffffffff8100af8e <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x146>
                headptr = nullptr;
ffffffff8100af81:	48 c7 85 90 00 00 00 	movq   $0x0,0x90(%rbp)
ffffffff8100af88:	00 00 00 00 
ffffffff8100af8c:	eb 33                	jmp    ffffffff8100afc1 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x179>

            else {
                t->next->prev = t->prev;
ffffffff8100af8e:	48 89 90 a8 02 00 00 	mov    %rdx,0x2a8(%rax)
                t->prev->next = t->next;
ffffffff8100af95:	48 8b 83 a8 02 00 00 	mov    0x2a8(%rbx),%rax
ffffffff8100af9c:	48 8b 93 b0 02 00 00 	mov    0x2b0(%rbx),%rdx
ffffffff8100afa3:	48 89 90 b0 02 00 00 	mov    %rdx,0x2b0(%rax)
                if (t == headptr)
ffffffff8100afaa:	48 3b 9d 90 00 00 00 	cmp    0x90(%rbp),%rbx
ffffffff8100afb1:	75 0e                	jne    ffffffff8100afc1 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x179>
                    headptr = t->next;
ffffffff8100afb3:	48 8b 83 b0 02 00 00 	mov    0x2b0(%rbx),%rax
ffffffff8100afba:	48 89 85 90 00 00 00 	mov    %rax,0x90(%rbp)
            }

            t->next = t->prev = nullptr;
ffffffff8100afc1:	48 c7 83 a8 02 00 00 	movq   $0x0,0x2a8(%rbx)
ffffffff8100afc8:	00 00 00 00 
ffffffff8100afcc:	48 c7 83 b0 02 00 00 	movq   $0x0,0x2b0(%rbx)
ffffffff8100afd3:	00 00 00 00 
ffffffff8100afd7:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff8100afda:	f0 0f c1 83 8c 00 00 	lock xadd %eax,0x8c(%rbx)
ffffffff8100afe1:	00 

                    counter++;
                    return;
                }

                if (EXPECT_FALSE(ec->del_ref())) {
ffffffff8100afe2:	ff c8                	dec    %eax
ffffffff8100afe4:	75 2a                	jne    ffffffff8100b010 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x1c8>
                    delete ec;
ffffffff8100afe6:	48 89 df             	mov    %rbx,%rdi
ffffffff8100afe9:	e8 4e 94 ff ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff8100afee:	48 8b 83 98 02 00 00 	mov    0x298(%rbx),%rax
ffffffff8100aff5:	48 89 de             	mov    %rbx,%rsi
ffffffff8100aff8:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff8100afff:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff8100b006:	e8 5f aa 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
ffffffff8100b00b:	e9 3c ff ff ff       	jmpq   ffffffff8100af4c <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x104>
ffffffff8100b010:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff8100b016:	45 84 e4             	test   %r12b,%r12b
ffffffff8100b019:	74 30                	je     ffffffff8100b04b <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x203>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100b01b:	80 3d 0e 47 ff 3e 00 	cmpb   $0x0,0x3eff470e(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100b022:	74 1f                	je     ffffffff8100b043 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x1fb>
ffffffff8100b024:	49 c7 c0 10 fb 01 81 	mov    $0xffffffff8101fb10,%r8
ffffffff8100b02b:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff8100b030:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100b037:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff8100b03e:	e9 60 fe ff ff       	jmpq   ffffffff8100aea3 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x5b>

            preemption = true;
ffffffff8100b043:	c6 05 e6 46 ff 3e 01 	movb   $0x1,0x3eff46e6(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100b04a:	fb                   	sti    
        Sc::schedule(true);
    }

    ALWAYS_INLINE
    inline void release(void (*c)()) {
        if (c)
ffffffff8100b04b:	48 c7 c0 7e cc 00 81 	mov    $0xffffffff8100cc7e,%rax
ffffffff8100b052:	48 85 c0             	test   %rax,%rax
ffffffff8100b055:	74 07                	je     ffffffff8100b05e <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x216>
            cont = c;
ffffffff8100b057:	48 89 83 a0 00 00 00 	mov    %rax,0xa0(%rbx)

        Lock_guard <Spinlock> guard(lock);
ffffffff8100b05e:	48 8d bb 8a 00 00 00 	lea    0x8a(%rbx),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff8100b065:	9c                   	pushfq 
ffffffff8100b066:	58                   	pop    %rax
            return flags & 0x200;
ffffffff8100b067:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8100b06b:	41 88 c4             	mov    %al,%r12b
ffffffff8100b06e:	41 80 e4 01          	and    $0x1,%r12b
ffffffff8100b072:	74 15                	je     ffffffff8100b089 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x241>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff8100b074:	80 3d b5 46 ff 3e 00 	cmpb   $0x0,0x3eff46b5(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100b07b:	0f 84 9f fe ff ff    	je     ffffffff8100af20 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0xd8>

            asm volatile ("cli" : : : "memory");
ffffffff8100b081:	fa                   	cli    
            preemption = false;
ffffffff8100b082:	c6 05 a7 46 ff 3e 00 	movb   $0x0,0x3eff46a7(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff8100b089:	e8 00 5e ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff8100b08e:	48 8b ab 90 00 00 00 	mov    0x90(%rbx),%rbp
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff8100b095:	48 85 ed             	test   %rbp,%rbp
ffffffff8100b098:	0f 84 c4 00 00 00    	je     ffffffff8100b162 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x31a>
ffffffff8100b09e:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff8100b0a5:	48 85 c0             	test   %rax,%rax
ffffffff8100b0a8:	0f 84 b4 00 00 00    	je     ffffffff8100b162 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x31a>
ffffffff8100b0ae:	48 8b 95 b8 00 00 00 	mov    0xb8(%rbp),%rdx
ffffffff8100b0b5:	48 85 d2             	test   %rdx,%rdx
ffffffff8100b0b8:	0f 84 a4 00 00 00    	je     ffffffff8100b162 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x31a>
                return false;

            if (t == t->next)
ffffffff8100b0be:	48 39 c5             	cmp    %rax,%rbp
ffffffff8100b0c1:	75 0d                	jne    ffffffff8100b0d0 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x288>
                headptr = nullptr;
ffffffff8100b0c3:	48 c7 83 90 00 00 00 	movq   $0x0,0x90(%rbx)
ffffffff8100b0ca:	00 00 00 00 
ffffffff8100b0ce:	eb 33                	jmp    ffffffff8100b103 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x2bb>

            else {
                t->next->prev = t->prev;
ffffffff8100b0d0:	48 89 90 b8 00 00 00 	mov    %rdx,0xb8(%rax)
                t->prev->next = t->next;
ffffffff8100b0d7:	48 8b 85 b8 00 00 00 	mov    0xb8(%rbp),%rax
ffffffff8100b0de:	48 8b 95 c0 00 00 00 	mov    0xc0(%rbp),%rdx
ffffffff8100b0e5:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
                if (t == headptr)
ffffffff8100b0ec:	48 3b ab 90 00 00 00 	cmp    0x90(%rbx),%rbp
ffffffff8100b0f3:	75 0e                	jne    ffffffff8100b103 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x2bb>
                    headptr = t->next;
ffffffff8100b0f5:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff8100b0fc:	48 89 83 90 00 00 00 	mov    %rax,0x90(%rbx)
            }

            t->next = t->prev = nullptr;
ffffffff8100b103:	48 c7 85 b8 00 00 00 	movq   $0x0,0xb8(%rbp)
ffffffff8100b10a:	00 00 00 00 
ffffffff8100b10e:	48 c7 85 c0 00 00 00 	movq   $0x0,0xc0(%rbp)
ffffffff8100b115:	00 00 00 00 
ffffffff8100b119:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff8100b11c:	f0 0f c1 85 8c 00 00 	lock xadd %eax,0x8c(%rbp)
ffffffff8100b123:	00 

        for (Sc *s; dequeue(s = head());) {
            if (EXPECT_FALSE(s->del_ref()) && (this == s->ec)) {
ffffffff8100b124:	ff c8                	dec    %eax
ffffffff8100b126:	75 2d                	jne    ffffffff8100b155 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x30d>
ffffffff8100b128:	48 3b 9d 90 00 00 00 	cmp    0x90(%rbp),%rbx
ffffffff8100b12f:	75 24                	jne    ffffffff8100b155 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x30d>
                delete s;
ffffffff8100b131:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100b134:	e8 27 da ff ff       	callq  ffffffff81008b60 <_ZN2ScD1Ev>
ffffffff8100b139:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100b13c:	e8 e9 9b 00 00       	callq  ffffffff81014d2a <_ZN2ScdlEPv>
ffffffff8100b141:	e9 48 ff ff ff       	jmpq   ffffffff8100b08e <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x246>
                    if (si) {
                       if (si->queued()) return;
                       Queue<Si>::enqueue(si);
                    }

                    counter++;
ffffffff8100b146:	48 ff 85 c0 00 00 00 	incq   0xc0(%rbp)
ffffffff8100b14d:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
ffffffff8100b153:	eb 13                	jmp    ffffffff8100b168 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x320>
                continue;
            }
            s->remote_enqueue();
ffffffff8100b155:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100b158:	e8 03 99 00 00       	callq  ffffffff81014a60 <_ZN2Sc14remote_enqueueEv>
ffffffff8100b15d:	e9 2c ff ff ff       	jmpq   ffffffff8100b08e <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x246>
ffffffff8100b162:	fe 83 8a 00 00 00    	incb   0x8a(%rbx)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff8100b168:	45 84 e4             	test   %r12b,%r12b
ffffffff8100b16b:	74 15                	je     ffffffff8100b182 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x33a>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100b16d:	80 3d bc 45 ff 3e 00 	cmpb   $0x0,0x3eff45bc(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100b174:	0f 85 aa fe ff ff    	jne    ffffffff8100b024 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x1dc>

            preemption = true;
ffffffff8100b17a:	c6 05 af 45 ff 3e 01 	movb   $0x1,0x3eff45af(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100b181:	fb                   	sti    

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
ffffffff8100b182:	48 8b 1d 7f 3e ff 3e 	mov    0x3eff3e7f(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100b189:	48 8b 43 28          	mov    0x28(%rbx),%rax
ffffffff8100b18d:	48 c7 83 88 02 00 00 	movq   $0x0,0x288(%rbx)
ffffffff8100b194:	00 00 00 00 
    current->utcb    = nullptr;
    current->fpu     = nullptr;

    Rcu::call(current);
ffffffff8100b198:	48 8d 6b 18          	lea    0x18(%rbx),%rbp
    assert (Sc::current->ec == current);

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
    current->utcb    = nullptr;
ffffffff8100b19c:	48 c7 83 90 02 00 00 	movq   $0x0,0x290(%rbx)
ffffffff8100b1a3:	00 00 00 00 
    current->fpu     = nullptr;
ffffffff8100b1a7:	48 c7 83 b8 02 00 00 	movq   $0x0,0x2b8(%rbx)
ffffffff8100b1ae:	00 00 00 00 
ffffffff8100b1b2:	48 85 c0             	test   %rax,%rax
ffffffff8100b1b5:	74 05                	je     ffffffff8100b1bc <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x374>
                e->pre_func(e);
ffffffff8100b1b7:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100b1ba:	ff d0                	callq  *%rax
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
ffffffff8100b1bc:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
ffffffff8100b1c1:	75 0c                	jne    ffffffff8100b1cf <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x387>
ffffffff8100b1c3:	48 8b 05 9e 46 ff 3e 	mov    0x3eff469e(%rip),%rax        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff8100b1ca:	48 39 e8             	cmp    %rbp,%rax
ffffffff8100b1cd:	75 2f                	jne    ffffffff8100b1fe <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x3b6>
                trace (0, "warning: rcu element already enqueued");
ffffffff8100b1cf:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff8100b1d4:	8b 15 2a 3e ff 3e    	mov    0x3eff3e2a(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100b1da:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff8100b1de:	48 c7 c7 14 df 01 81 	mov    $0xffffffff8101df14,%rdi
ffffffff8100b1e5:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8100b1eb:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff8100b1f1:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff8100b1f5:	31 c0                	xor    %eax,%eax
ffffffff8100b1f7:	e8 90 6e ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff8100b1fc:	eb 11                	jmp    ffffffff8100b20f <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x3c7>
                return;
            }

            count ++;
ffffffff8100b1fe:	48 ff 05 6b 46 ff 3e 	incq   0x3eff466b(%rip)        # ffffffffbffff870 <_ZN3Rcu4nextE+0x10>

           *tail = e;
ffffffff8100b205:	48 89 28             	mov    %rbp,(%rax)
            tail = &e->next;
ffffffff8100b208:	48 89 2d 59 46 ff 3e 	mov    %rbp,0x3eff4659(%rip)        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>

    Rcu::call(current);
    Rcu::call(Sc::current);
ffffffff8100b20f:	48 8b 2d 02 3e ff 3e 	mov    0x3eff3e02(%rip),%rbp        # ffffffffbffff018 <_ZN2Sc7currentE>
ffffffff8100b216:	48 85 ed             	test   %rbp,%rbp
ffffffff8100b219:	74 74                	je     ffffffff8100b28f <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x447>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
ffffffff8100b21b:	48 8b 45 28          	mov    0x28(%rbp),%rax
ffffffff8100b21f:	48 8d 5d 18          	lea    0x18(%rbp),%rbx
ffffffff8100b223:	48 85 c0             	test   %rax,%rax
ffffffff8100b226:	74 05                	je     ffffffff8100b22d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x3e5>
                e->pre_func(e);
ffffffff8100b228:	48 89 df             	mov    %rbx,%rdi
ffffffff8100b22b:	ff d0                	callq  *%rax
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
ffffffff8100b22d:	48 83 7d 18 00       	cmpq   $0x0,0x18(%rbp)
ffffffff8100b232:	75 0c                	jne    ffffffff8100b240 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x3f8>
ffffffff8100b234:	48 8b 05 2d 46 ff 3e 	mov    0x3eff462d(%rip),%rax        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff8100b23b:	48 39 d8             	cmp    %rbx,%rax
ffffffff8100b23e:	75 2f                	jne    ffffffff8100b26f <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x427>
                trace (0, "warning: rcu element already enqueued");
ffffffff8100b240:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff8100b245:	8b 15 b9 3d ff 3e    	mov    0x3eff3db9(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100b24b:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff8100b24f:	48 c7 c7 14 df 01 81 	mov    $0xffffffff8101df14,%rdi
ffffffff8100b256:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8100b25c:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff8100b262:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff8100b266:	31 c0                	xor    %eax,%eax
ffffffff8100b268:	e8 1f 6e ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff8100b26d:	eb 11                	jmp    ffffffff8100b280 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvvEEEEvv+0x438>
                return;
            }

            count ++;
ffffffff8100b26f:	48 ff 05 fa 45 ff 3e 	incq   0x3eff45fa(%rip)        # ffffffffbffff870 <_ZN3Rcu4nextE+0x10>

           *tail = e;
ffffffff8100b276:	48 89 18             	mov    %rbx,(%rax)
            tail = &e->next;
ffffffff8100b279:	48 89 1d e8 45 ff 3e 	mov    %rbx,0x3eff45e8(%rip)        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>

    Sc::schedule(true);
ffffffff8100b280:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff8100b285:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff8100b28a:	e8 25 9b 00 00       	callq  ffffffff81014db4 <_ZN2Sc8scheduleEbb>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
ffffffff8100b28f:	48 8b 04 25 10 00 00 	mov    0x10,%rax
ffffffff8100b296:	00 
ffffffff8100b297:	0f 0b                	ud2    
ffffffff8100b299:	90                   	nop

ffffffff8100b29a <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv>:

    die ("XCPU OOM error");
}

template <void (*C)()>
void Ec::oom_xcpu_return()
ffffffff8100b29a:	41 54                	push   %r12
ffffffff8100b29c:	55                   	push   %rbp
ffffffff8100b29d:	53                   	push   %rbx
ffffffff8100b29e:	48 83 ec 10          	sub    $0x10,%rsp
{
    assert (current->xcpu_sm);
ffffffff8100b2a2:	48 8b 05 5f 3d ff 3e 	mov    0x3eff3d5f(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100b2a9:	48 8b a8 30 03 00 00 	mov    0x330(%rax),%rbp
ffffffff8100b2b0:	48 85 ed             	test   %rbp,%rbp
ffffffff8100b2b3:	75 1c                	jne    ffffffff8100b2d1 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x37>
ffffffff8100b2b5:	49 c7 c0 40 e9 01 81 	mov    $0xffffffff8101e940,%r8
ffffffff8100b2bc:	b9 87 00 00 00       	mov    $0x87,%ecx
ffffffff8100b2c1:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100b2c8:	48 c7 c6 cc de 01 81 	mov    $0xffffffff8101decc,%rsi
ffffffff8100b2cf:	eb 24                	jmp    ffffffff8100b2f5 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x5b>
    assert (current->rcap);
ffffffff8100b2d1:	48 83 b8 88 02 00 00 	cmpq   $0x0,0x288(%rax)
ffffffff8100b2d8:	00 
ffffffff8100b2d9:	75 28                	jne    ffffffff8100b303 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x69>
ffffffff8100b2db:	49 c7 c0 40 e9 01 81 	mov    $0xffffffff8101e940,%r8
ffffffff8100b2e2:	b9 88 00 00 00       	mov    $0x88,%ecx
ffffffff8100b2e7:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100b2ee:	48 c7 c6 dd de 01 81 	mov    $0xffffffff8101dedd,%rsi
ffffffff8100b2f5:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100b2fc:	31 c0                	xor    %eax,%eax
ffffffff8100b2fe:	e8 4d 6c ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
    assert (current->utcb);
ffffffff8100b303:	48 83 b8 90 02 00 00 	cmpq   $0x0,0x290(%rax)
ffffffff8100b30a:	00 
ffffffff8100b30b:	75 1c                	jne    ffffffff8100b329 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x8f>
ffffffff8100b30d:	49 c7 c0 40 e9 01 81 	mov    $0xffffffff8101e940,%r8
ffffffff8100b314:	b9 89 00 00 00       	mov    $0x89,%ecx
ffffffff8100b319:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100b320:	48 c7 c6 eb de 01 81 	mov    $0xffffffff8101deeb,%rsi
ffffffff8100b327:	eb cc                	jmp    ffffffff8100b2f5 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x5b>
ffffffff8100b329:	48 8b 15 e8 3c ff 3e 	mov    0x3eff3ce8(%rip),%rdx        # ffffffffbffff018 <_ZN2Sc7currentE>
    assert (Sc::current->ec == current);
ffffffff8100b330:	48 39 82 90 00 00 00 	cmp    %rax,0x90(%rdx)
ffffffff8100b337:	74 1c                	je     ffffffff8100b355 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0xbb>
ffffffff8100b339:	49 c7 c0 40 e9 01 81 	mov    $0xffffffff8101e940,%r8
ffffffff8100b340:	b9 8a 00 00 00       	mov    $0x8a,%ecx
ffffffff8100b345:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100b34c:	48 c7 c6 f9 de 01 81 	mov    $0xffffffff8101def9,%rsi
ffffffff8100b353:	eb a0                	jmp    ffffffff8100b2f5 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x5b>
        ALWAYS_INLINE
        inline void up (void (*c)() = nullptr, Sm * si = nullptr)
        {
            Ec *ec;

            {   Lock_guard <Spinlock> guard (lock);
ffffffff8100b355:	48 8d bd 8a 00 00 00 	lea    0x8a(%rbp),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff8100b35c:	9c                   	pushfq 
ffffffff8100b35d:	41 5c                	pop    %r12
            return flags & 0x200;
ffffffff8100b35f:	49 c1 ec 09          	shr    $0x9,%r12

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8100b363:	41 80 e4 01          	and    $0x1,%r12b
ffffffff8100b367:	74 30                	je     ffffffff8100b399 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0xff>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff8100b369:	80 3d c0 43 ff 3e 00 	cmpb   $0x0,0x3eff43c0(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100b370:	75 1f                	jne    ffffffff8100b391 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0xf7>
ffffffff8100b372:	49 c7 c0 40 fb 01 81 	mov    $0xffffffff8101fb40,%r8
ffffffff8100b379:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff8100b37e:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100b385:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff8100b38c:	e9 64 ff ff ff       	jmpq   ffffffff8100b2f5 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x5b>

            asm volatile ("cli" : : : "memory");
ffffffff8100b391:	fa                   	cli    
            preemption = false;
ffffffff8100b392:	c6 05 97 43 ff 3e 00 	movb   $0x0,0x3eff4397(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff8100b399:	e8 f0 5a ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff8100b39e:	48 8b 9d 90 00 00 00 	mov    0x90(%rbp),%rbx
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff8100b3a5:	48 85 db             	test   %rbx,%rbx
ffffffff8100b3a8:	0f 84 ea 01 00 00    	je     ffffffff8100b598 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x2fe>
ffffffff8100b3ae:	48 8b 83 b0 02 00 00 	mov    0x2b0(%rbx),%rax
ffffffff8100b3b5:	48 85 c0             	test   %rax,%rax
ffffffff8100b3b8:	0f 84 da 01 00 00    	je     ffffffff8100b598 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x2fe>
ffffffff8100b3be:	48 8b 93 a8 02 00 00 	mov    0x2a8(%rbx),%rdx
ffffffff8100b3c5:	48 85 d2             	test   %rdx,%rdx
ffffffff8100b3c8:	0f 84 ca 01 00 00    	je     ffffffff8100b598 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x2fe>
                return false;

            if (t == t->next)
ffffffff8100b3ce:	48 39 c3             	cmp    %rax,%rbx
ffffffff8100b3d1:	75 0d                	jne    ffffffff8100b3e0 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x146>
                headptr = nullptr;
ffffffff8100b3d3:	48 c7 85 90 00 00 00 	movq   $0x0,0x90(%rbp)
ffffffff8100b3da:	00 00 00 00 
ffffffff8100b3de:	eb 33                	jmp    ffffffff8100b413 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x179>

            else {
                t->next->prev = t->prev;
ffffffff8100b3e0:	48 89 90 a8 02 00 00 	mov    %rdx,0x2a8(%rax)
                t->prev->next = t->next;
ffffffff8100b3e7:	48 8b 83 a8 02 00 00 	mov    0x2a8(%rbx),%rax
ffffffff8100b3ee:	48 8b 93 b0 02 00 00 	mov    0x2b0(%rbx),%rdx
ffffffff8100b3f5:	48 89 90 b0 02 00 00 	mov    %rdx,0x2b0(%rax)
                if (t == headptr)
ffffffff8100b3fc:	48 3b 9d 90 00 00 00 	cmp    0x90(%rbp),%rbx
ffffffff8100b403:	75 0e                	jne    ffffffff8100b413 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x179>
                    headptr = t->next;
ffffffff8100b405:	48 8b 83 b0 02 00 00 	mov    0x2b0(%rbx),%rax
ffffffff8100b40c:	48 89 85 90 00 00 00 	mov    %rax,0x90(%rbp)
            }

            t->next = t->prev = nullptr;
ffffffff8100b413:	48 c7 83 a8 02 00 00 	movq   $0x0,0x2a8(%rbx)
ffffffff8100b41a:	00 00 00 00 
ffffffff8100b41e:	48 c7 83 b0 02 00 00 	movq   $0x0,0x2b0(%rbx)
ffffffff8100b425:	00 00 00 00 
ffffffff8100b429:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff8100b42c:	f0 0f c1 83 8c 00 00 	lock xadd %eax,0x8c(%rbx)
ffffffff8100b433:	00 

                    counter++;
                    return;
                }

                if (EXPECT_FALSE(ec->del_ref())) {
ffffffff8100b434:	ff c8                	dec    %eax
ffffffff8100b436:	75 2a                	jne    ffffffff8100b462 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x1c8>
                    delete ec;
ffffffff8100b438:	48 89 df             	mov    %rbx,%rdi
ffffffff8100b43b:	e8 fc 8f ff ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff8100b440:	48 8b 83 98 02 00 00 	mov    0x298(%rbx),%rax
ffffffff8100b447:	48 89 de             	mov    %rbx,%rsi
ffffffff8100b44a:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff8100b451:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff8100b458:	e8 0d a6 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
ffffffff8100b45d:	e9 3c ff ff ff       	jmpq   ffffffff8100b39e <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x104>
ffffffff8100b462:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff8100b468:	45 84 e4             	test   %r12b,%r12b
ffffffff8100b46b:	74 30                	je     ffffffff8100b49d <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x203>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100b46d:	80 3d bc 42 ff 3e 00 	cmpb   $0x0,0x3eff42bc(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100b474:	74 1f                	je     ffffffff8100b495 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x1fb>
ffffffff8100b476:	49 c7 c0 10 fb 01 81 	mov    $0xffffffff8101fb10,%r8
ffffffff8100b47d:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff8100b482:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100b489:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff8100b490:	e9 60 fe ff ff       	jmpq   ffffffff8100b2f5 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x5b>

            preemption = true;
ffffffff8100b495:	c6 05 94 42 ff 3e 01 	movb   $0x1,0x3eff4294(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100b49c:	fb                   	sti    
        Sc::schedule(true);
    }

    ALWAYS_INLINE
    inline void release(void (*c)()) {
        if (c)
ffffffff8100b49d:	48 c7 c0 9e ce 00 81 	mov    $0xffffffff8100ce9e,%rax
ffffffff8100b4a4:	48 85 c0             	test   %rax,%rax
ffffffff8100b4a7:	74 07                	je     ffffffff8100b4b0 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x216>
            cont = c;
ffffffff8100b4a9:	48 89 83 a0 00 00 00 	mov    %rax,0xa0(%rbx)

        Lock_guard <Spinlock> guard(lock);
ffffffff8100b4b0:	48 8d bb 8a 00 00 00 	lea    0x8a(%rbx),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff8100b4b7:	9c                   	pushfq 
ffffffff8100b4b8:	58                   	pop    %rax
            return flags & 0x200;
ffffffff8100b4b9:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8100b4bd:	41 88 c4             	mov    %al,%r12b
ffffffff8100b4c0:	41 80 e4 01          	and    $0x1,%r12b
ffffffff8100b4c4:	74 15                	je     ffffffff8100b4db <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x241>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff8100b4c6:	80 3d 63 42 ff 3e 00 	cmpb   $0x0,0x3eff4263(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100b4cd:	0f 84 9f fe ff ff    	je     ffffffff8100b372 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0xd8>

            asm volatile ("cli" : : : "memory");
ffffffff8100b4d3:	fa                   	cli    
            preemption = false;
ffffffff8100b4d4:	c6 05 55 42 ff 3e 00 	movb   $0x0,0x3eff4255(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff8100b4db:	e8 ae 59 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff8100b4e0:	48 8b ab 90 00 00 00 	mov    0x90(%rbx),%rbp
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff8100b4e7:	48 85 ed             	test   %rbp,%rbp
ffffffff8100b4ea:	0f 84 c4 00 00 00    	je     ffffffff8100b5b4 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x31a>
ffffffff8100b4f0:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff8100b4f7:	48 85 c0             	test   %rax,%rax
ffffffff8100b4fa:	0f 84 b4 00 00 00    	je     ffffffff8100b5b4 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x31a>
ffffffff8100b500:	48 8b 95 b8 00 00 00 	mov    0xb8(%rbp),%rdx
ffffffff8100b507:	48 85 d2             	test   %rdx,%rdx
ffffffff8100b50a:	0f 84 a4 00 00 00    	je     ffffffff8100b5b4 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x31a>
                return false;

            if (t == t->next)
ffffffff8100b510:	48 39 c5             	cmp    %rax,%rbp
ffffffff8100b513:	75 0d                	jne    ffffffff8100b522 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x288>
                headptr = nullptr;
ffffffff8100b515:	48 c7 83 90 00 00 00 	movq   $0x0,0x90(%rbx)
ffffffff8100b51c:	00 00 00 00 
ffffffff8100b520:	eb 33                	jmp    ffffffff8100b555 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x2bb>

            else {
                t->next->prev = t->prev;
ffffffff8100b522:	48 89 90 b8 00 00 00 	mov    %rdx,0xb8(%rax)
                t->prev->next = t->next;
ffffffff8100b529:	48 8b 85 b8 00 00 00 	mov    0xb8(%rbp),%rax
ffffffff8100b530:	48 8b 95 c0 00 00 00 	mov    0xc0(%rbp),%rdx
ffffffff8100b537:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
                if (t == headptr)
ffffffff8100b53e:	48 3b ab 90 00 00 00 	cmp    0x90(%rbx),%rbp
ffffffff8100b545:	75 0e                	jne    ffffffff8100b555 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x2bb>
                    headptr = t->next;
ffffffff8100b547:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff8100b54e:	48 89 83 90 00 00 00 	mov    %rax,0x90(%rbx)
            }

            t->next = t->prev = nullptr;
ffffffff8100b555:	48 c7 85 b8 00 00 00 	movq   $0x0,0xb8(%rbp)
ffffffff8100b55c:	00 00 00 00 
ffffffff8100b560:	48 c7 85 c0 00 00 00 	movq   $0x0,0xc0(%rbp)
ffffffff8100b567:	00 00 00 00 
ffffffff8100b56b:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff8100b56e:	f0 0f c1 85 8c 00 00 	lock xadd %eax,0x8c(%rbp)
ffffffff8100b575:	00 

        for (Sc *s; dequeue(s = head());) {
            if (EXPECT_FALSE(s->del_ref()) && (this == s->ec)) {
ffffffff8100b576:	ff c8                	dec    %eax
ffffffff8100b578:	75 2d                	jne    ffffffff8100b5a7 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x30d>
ffffffff8100b57a:	48 3b 9d 90 00 00 00 	cmp    0x90(%rbp),%rbx
ffffffff8100b581:	75 24                	jne    ffffffff8100b5a7 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x30d>
                delete s;
ffffffff8100b583:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100b586:	e8 d5 d5 ff ff       	callq  ffffffff81008b60 <_ZN2ScD1Ev>
ffffffff8100b58b:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100b58e:	e8 97 97 00 00       	callq  ffffffff81014d2a <_ZN2ScdlEPv>
ffffffff8100b593:	e9 48 ff ff ff       	jmpq   ffffffff8100b4e0 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x246>
                    if (si) {
                       if (si->queued()) return;
                       Queue<Si>::enqueue(si);
                    }

                    counter++;
ffffffff8100b598:	48 ff 85 c0 00 00 00 	incq   0xc0(%rbp)
ffffffff8100b59f:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
ffffffff8100b5a5:	eb 13                	jmp    ffffffff8100b5ba <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x320>
                continue;
            }
            s->remote_enqueue();
ffffffff8100b5a7:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100b5aa:	e8 b1 94 00 00       	callq  ffffffff81014a60 <_ZN2Sc14remote_enqueueEv>
ffffffff8100b5af:	e9 2c ff ff ff       	jmpq   ffffffff8100b4e0 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x246>
ffffffff8100b5b4:	fe 83 8a 00 00 00    	incb   0x8a(%rbx)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff8100b5ba:	45 84 e4             	test   %r12b,%r12b
ffffffff8100b5bd:	74 15                	je     ffffffff8100b5d4 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x33a>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100b5bf:	80 3d 6a 41 ff 3e 00 	cmpb   $0x0,0x3eff416a(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100b5c6:	0f 85 aa fe ff ff    	jne    ffffffff8100b476 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x1dc>

            preemption = true;
ffffffff8100b5cc:	c6 05 5d 41 ff 3e 01 	movb   $0x1,0x3eff415d(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100b5d3:	fb                   	sti    

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
ffffffff8100b5d4:	48 8b 1d 2d 3a ff 3e 	mov    0x3eff3a2d(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100b5db:	48 8b 43 28          	mov    0x28(%rbx),%rax
ffffffff8100b5df:	48 c7 83 88 02 00 00 	movq   $0x0,0x288(%rbx)
ffffffff8100b5e6:	00 00 00 00 
    current->utcb    = nullptr;
    current->fpu     = nullptr;

    Rcu::call(current);
ffffffff8100b5ea:	48 8d 6b 18          	lea    0x18(%rbx),%rbp
    assert (Sc::current->ec == current);

    current->xcpu_sm->up (C);

    current->rcap    = nullptr;
    current->utcb    = nullptr;
ffffffff8100b5ee:	48 c7 83 90 02 00 00 	movq   $0x0,0x290(%rbx)
ffffffff8100b5f5:	00 00 00 00 
    current->fpu     = nullptr;
ffffffff8100b5f9:	48 c7 83 b8 02 00 00 	movq   $0x0,0x2b8(%rbx)
ffffffff8100b600:	00 00 00 00 
ffffffff8100b604:	48 85 c0             	test   %rax,%rax
ffffffff8100b607:	74 05                	je     ffffffff8100b60e <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x374>
                e->pre_func(e);
ffffffff8100b609:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100b60c:	ff d0                	callq  *%rax
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
ffffffff8100b60e:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
ffffffff8100b613:	75 0c                	jne    ffffffff8100b621 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x387>
ffffffff8100b615:	48 8b 05 4c 42 ff 3e 	mov    0x3eff424c(%rip),%rax        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff8100b61c:	48 39 e8             	cmp    %rbp,%rax
ffffffff8100b61f:	75 2f                	jne    ffffffff8100b650 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x3b6>
                trace (0, "warning: rcu element already enqueued");
ffffffff8100b621:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff8100b626:	8b 15 d8 39 ff 3e    	mov    0x3eff39d8(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100b62c:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff8100b630:	48 c7 c7 14 df 01 81 	mov    $0xffffffff8101df14,%rdi
ffffffff8100b637:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8100b63d:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff8100b643:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff8100b647:	31 c0                	xor    %eax,%eax
ffffffff8100b649:	e8 3e 6a ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff8100b64e:	eb 11                	jmp    ffffffff8100b661 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x3c7>
                return;
            }

            count ++;
ffffffff8100b650:	48 ff 05 19 42 ff 3e 	incq   0x3eff4219(%rip)        # ffffffffbffff870 <_ZN3Rcu4nextE+0x10>

           *tail = e;
ffffffff8100b657:	48 89 28             	mov    %rbp,(%rax)
            tail = &e->next;
ffffffff8100b65a:	48 89 2d 07 42 ff 3e 	mov    %rbp,0x3eff4207(%rip)        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>

    Rcu::call(current);
    Rcu::call(Sc::current);
ffffffff8100b661:	48 8b 2d b0 39 ff 3e 	mov    0x3eff39b0(%rip),%rbp        # ffffffffbffff018 <_ZN2Sc7currentE>
ffffffff8100b668:	48 85 ed             	test   %rbp,%rbp
ffffffff8100b66b:	74 74                	je     ffffffff8100b6e1 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x447>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
ffffffff8100b66d:	48 8b 45 28          	mov    0x28(%rbp),%rax
ffffffff8100b671:	48 8d 5d 18          	lea    0x18(%rbp),%rbx
ffffffff8100b675:	48 85 c0             	test   %rax,%rax
ffffffff8100b678:	74 05                	je     ffffffff8100b67f <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x3e5>
                e->pre_func(e);
ffffffff8100b67a:	48 89 df             	mov    %rbx,%rdi
ffffffff8100b67d:	ff d0                	callq  *%rax
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
ffffffff8100b67f:	48 83 7d 18 00       	cmpq   $0x0,0x18(%rbp)
ffffffff8100b684:	75 0c                	jne    ffffffff8100b692 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x3f8>
ffffffff8100b686:	48 8b 05 db 41 ff 3e 	mov    0x3eff41db(%rip),%rax        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff8100b68d:	48 39 d8             	cmp    %rbx,%rax
ffffffff8100b690:	75 2f                	jne    ffffffff8100b6c1 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x427>
                trace (0, "warning: rcu element already enqueued");
ffffffff8100b692:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff8100b697:	8b 15 67 39 ff 3e    	mov    0x3eff3967(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100b69d:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff8100b6a1:	48 c7 c7 14 df 01 81 	mov    $0xffffffff8101df14,%rdi
ffffffff8100b6a8:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8100b6ae:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff8100b6b4:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff8100b6b8:	31 c0                	xor    %eax,%eax
ffffffff8100b6ba:	e8 cd 69 ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff8100b6bf:	eb 11                	jmp    ffffffff8100b6d2 <_ZN2Ec15oom_xcpu_returnIXadL_ZNS_18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvvEEEEvv+0x438>
                return;
            }

            count ++;
ffffffff8100b6c1:	48 ff 05 a8 41 ff 3e 	incq   0x3eff41a8(%rip)        # ffffffffbffff870 <_ZN3Rcu4nextE+0x10>

           *tail = e;
ffffffff8100b6c8:	48 89 18             	mov    %rbx,(%rax)
            tail = &e->next;
ffffffff8100b6cb:	48 89 1d 96 41 ff 3e 	mov    %rbx,0x3eff4196(%rip)        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>

    Sc::schedule(true);
ffffffff8100b6d2:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff8100b6d7:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff8100b6dc:	e8 d3 96 00 00       	callq  ffffffff81014db4 <_ZN2Sc8scheduleEbb>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
ffffffff8100b6e1:	48 8b 04 25 10 00 00 	mov    0x10,%rax
ffffffff8100b6e8:	00 
ffffffff8100b6e9:	0f 0b                	ud2    
ffffffff8100b6eb:	90                   	nop

ffffffff8100b6ec <_ZN2Ec4helpEPFvvE>:
        return *reinterpret_cast<volatile typeof current *> (reinterpret_cast<mword> (&current) - CPU_LOCAL_DATA + HV_GLOBAL_CPUS + c * PAGE_SIZE);
    }

    NOINLINE
    void help(void (*c)()) {
        if (EXPECT_TRUE(cont != dead)) {
ffffffff8100b6ec:	48 81 bf a0 00 00 00 	cmpq   $0xffffffff81005136,0xa0(%rdi)
ffffffff8100b6f3:	36 51 00 81 
ffffffff8100b6f7:	74 73                	je     ffffffff8100b76c <_ZN2Ec4helpEPFvvE+0x80>
    static inline Ec *remote(unsigned c) {
        return *reinterpret_cast<volatile typeof current *> (reinterpret_cast<mword> (&current) - CPU_LOCAL_DATA + HV_GLOBAL_CPUS + c * PAGE_SIZE);
    }

    NOINLINE
    void help(void (*c)()) {
ffffffff8100b6f9:	50                   	push   %rax
        if (EXPECT_TRUE(cont != dead)) {

            Counter::print<1, 16> (++Counter::helping, Console_vga::COLOR_LIGHT_WHITE, SPN_HLP);
ffffffff8100b6fa:	8b 05 48 39 ff 3e    	mov    0x3eff3948(%rip),%eax        # ffffffffbffff048 <_ZN7Counter7helpingE>
ffffffff8100b700:	8d 50 01             	lea    0x1(%rax),%edx
ffffffff8100b703:	8b 05 87 40 ff 3e    	mov    0x3eff4087(%rip),%eax        # ffffffffbffff790 <_ZN3Cpu3rowE>
ffffffff8100b709:	89 15 39 39 ff 3e    	mov    %edx,0x3eff3939(%rip)        # ffffffffbffff048 <_ZN7Counter7helpingE>
ffffffff8100b70f:	85 c0                	test   %eax,%eax
ffffffff8100b711:	75 3a                	jne    ffffffff8100b74d <_ZN2Ec4helpEPFvvE+0x61>
            current->cont = c;

            if (EXPECT_TRUE(++Sc::ctr_loop < 100))
ffffffff8100b713:	8b 0d e7 45 ff 3e    	mov    0x3eff45e7(%rip),%ecx        # ffffffffbffffd00 <_ZN2Sc8ctr_loopE>
    NOINLINE
    void help(void (*c)()) {
        if (EXPECT_TRUE(cont != dead)) {

            Counter::print<1, 16> (++Counter::helping, Console_vga::COLOR_LIGHT_WHITE, SPN_HLP);
            current->cont = c;
ffffffff8100b719:	48 8b 05 e8 38 ff 3e 	mov    0x3eff38e8(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>

            if (EXPECT_TRUE(++Sc::ctr_loop < 100))
ffffffff8100b720:	8d 51 01             	lea    0x1(%rcx),%edx
    NOINLINE
    void help(void (*c)()) {
        if (EXPECT_TRUE(cont != dead)) {

            Counter::print<1, 16> (++Counter::helping, Console_vga::COLOR_LIGHT_WHITE, SPN_HLP);
            current->cont = c;
ffffffff8100b723:	48 89 b0 a0 00 00 00 	mov    %rsi,0xa0(%rax)

            if (EXPECT_TRUE(++Sc::ctr_loop < 100))
ffffffff8100b72a:	83 fa 63             	cmp    $0x63,%edx
ffffffff8100b72d:	89 15 cd 45 ff 3e    	mov    %edx,0x3eff45cd(%rip)        # ffffffffbffffd00 <_ZN2Sc8ctr_loopE>
ffffffff8100b733:	77 05                	ja     ffffffff8100b73a <_ZN2Ec4helpEPFvvE+0x4e>
                activate();
ffffffff8100b735:	e8 3c bd 00 00       	callq  ffffffff81017476 <_ZN2Ec8activateEv>

            die("Livelock");
ffffffff8100b73a:	48 8d b0 a8 00 00 00 	lea    0xa8(%rax),%rsi
ffffffff8100b741:	48 c7 c7 be e6 01 81 	mov    $0xffffffff8101e6be,%rdi
ffffffff8100b748:	e8 bd 94 ff ff       	callq  ffffffff81004c0a <_ZN2Ec3dieEPKcP8Exc_regs>
                for (unsigned i = 0; i < D; i++, val /= B)
                    Console_vga::con.put (Cpu::row, col - i, c, !i || val ? (val % B)["0123456789ABCDEF"] : ' ');
ffffffff8100b74d:	83 e2 0f             	and    $0xf,%edx
ffffffff8100b750:	48 6b c0 50          	imul   $0x50,%rax,%rax
ffffffff8100b754:	66 0f be 92 d8 d7 01 	movsbw -0x7efe2828(%rdx),%dx
ffffffff8100b75b:	81 
ffffffff8100b75c:	48 ff c0             	inc    %rax
ffffffff8100b75f:	80 ce 0f             	or     $0xf,%dh
ffffffff8100b762:	66 89 94 00 00 f0 df 	mov    %dx,-0x40201000(%rax,%rax,1)
ffffffff8100b769:	bf 
ffffffff8100b76a:	eb a7                	jmp    ffffffff8100b713 <_ZN2Ec4helpEPFvvE+0x27>
ffffffff8100b76c:	c3                   	retq   
ffffffff8100b76d:	90                   	nop

ffffffff8100b76e <_ZN2Ec8block_scEv>:
        }
    }

    NOINLINE
    void block_sc() {
ffffffff8100b76e:	55                   	push   %rbp
ffffffff8100b76f:	53                   	push   %rbx
ffffffff8100b770:	48 89 fb             	mov    %rdi,%rbx
ffffffff8100b773:	52                   	push   %rdx
        {
            Lock_guard <Spinlock> guard(lock);
ffffffff8100b774:	48 8d bf 8a 00 00 00 	lea    0x8a(%rdi),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff8100b77b:	9c                   	pushfq 
ffffffff8100b77c:	5d                   	pop    %rbp
            return flags & 0x200;
ffffffff8100b77d:	48 c1 ed 09          	shr    $0x9,%rbp

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8100b781:	40 80 e5 01          	and    $0x1,%bpl
ffffffff8100b785:	74 2d                	je     ffffffff8100b7b4 <_ZN2Ec8block_scEv+0x46>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff8100b787:	80 3d a2 3f ff 3e 00 	cmpb   $0x0,0x3eff3fa2(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100b78e:	75 1c                	jne    ffffffff8100b7ac <_ZN2Ec8block_scEv+0x3e>
ffffffff8100b790:	49 c7 c0 40 fb 01 81 	mov    $0xffffffff8101fb40,%r8
ffffffff8100b797:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff8100b79c:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100b7a3:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff8100b7aa:	eb 53                	jmp    ffffffff8100b7ff <_ZN2Ec8block_scEv+0x91>

            asm volatile ("cli" : : : "memory");
ffffffff8100b7ac:	fa                   	cli    
            preemption = false;
ffffffff8100b7ad:	c6 05 7c 3f ff 3e 00 	movb   $0x0,0x3eff3f7c(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff8100b7b4:	e8 d5 56 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
        regs.add_tsc_offset(tsc);
    }

    ALWAYS_INLINE
    inline bool blocked() const {
        return next || !cont;
ffffffff8100b7b9:	48 83 bb b0 02 00 00 	cmpq   $0x0,0x2b0(%rbx)
ffffffff8100b7c0:	00 
ffffffff8100b7c1:	75 57                	jne    ffffffff8100b81a <_ZN2Ec8block_scEv+0xac>
ffffffff8100b7c3:	48 83 bb a0 00 00 00 	cmpq   $0x0,0xa0(%rbx)
ffffffff8100b7ca:	00 
ffffffff8100b7cb:	74 4d                	je     ffffffff8100b81a <_ZN2Ec8block_scEv+0xac>
ffffffff8100b7cd:	fe 83 8a 00 00 00    	incb   0x8a(%rbx)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff8100b7d3:	40 84 ed             	test   %bpl,%bpl
ffffffff8100b7d6:	0f 84 e0 00 00 00    	je     ffffffff8100b8bc <_ZN2Ec8block_scEv+0x14e>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100b7dc:	80 3d 4d 3f ff 3e 00 	cmpb   $0x0,0x3eff3f4d(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100b7e3:	74 28                	je     ffffffff8100b80d <_ZN2Ec8block_scEv+0x9f>
ffffffff8100b7e5:	49 c7 c0 10 fb 01 81 	mov    $0xffffffff8101fb10,%r8
ffffffff8100b7ec:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff8100b7f1:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100b7f8:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff8100b7ff:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100b806:	31 c0                	xor    %eax,%eax
ffffffff8100b808:	e8 43 67 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            preemption = true;
ffffffff8100b80d:	c6 05 1c 3f ff 3e 01 	movb   $0x1,0x3eff3f1c(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100b814:	fb                   	sti    
ffffffff8100b815:	e9 a2 00 00 00       	jmpq   ffffffff8100b8bc <_ZN2Ec8block_scEv+0x14e>
            Lock_guard <Spinlock> guard(lock);

            if (!blocked())
                return;

            Sc::current->add_ref();
ffffffff8100b81a:	48 8b 15 f7 37 ff 3e 	mov    0x3eff37f7(%rip),%rdx        # ffffffffbffff018 <_ZN2Sc7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100b821:	8b 82 8c 00 00 00    	mov    0x8c(%rdx),%eax
ffffffff8100b827:	83 f8 ff             	cmp    $0xffffffff,%eax
ffffffff8100b82a:	74 0d                	je     ffffffff8100b839 <_ZN2Ec8block_scEv+0xcb>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8100b82c:	8d 48 01             	lea    0x1(%rax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff8100b82f:	f0 0f b1 8a 8c 00 00 	lock cmpxchg %ecx,0x8c(%rdx)
ffffffff8100b836:	00 
ffffffff8100b837:	75 e8                	jne    ffffffff8100b821 <_ZN2Ec8block_scEv+0xb3>
        inline T *head() const { return headptr; }

        ALWAYS_INLINE
        inline void enqueue (T *t)
        {
            if (!headptr)
ffffffff8100b839:	48 8b 93 90 00 00 00 	mov    0x90(%rbx),%rdx
            enqueue(Sc::current);
ffffffff8100b840:	48 8b 05 d1 37 ff 3e 	mov    0x3eff37d1(%rip),%rax        # ffffffffbffff018 <_ZN2Sc7currentE>
ffffffff8100b847:	48 85 d2             	test   %rdx,%rdx
ffffffff8100b84a:	75 17                	jne    ffffffff8100b863 <_ZN2Ec8block_scEv+0xf5>
                headptr = t->prev = t->next = t;
ffffffff8100b84c:	48 89 80 c0 00 00 00 	mov    %rax,0xc0(%rax)
ffffffff8100b853:	48 89 80 b8 00 00 00 	mov    %rax,0xb8(%rax)
ffffffff8100b85a:	48 89 83 90 00 00 00 	mov    %rax,0x90(%rbx)
ffffffff8100b861:	eb 2a                	jmp    ffffffff8100b88d <_ZN2Ec8block_scEv+0x11f>
            else {
                t->next = headptr;
ffffffff8100b863:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
                t->prev = headptr->prev;
ffffffff8100b86a:	48 8b 8b 90 00 00 00 	mov    0x90(%rbx),%rcx
ffffffff8100b871:	48 8b 89 b8 00 00 00 	mov    0xb8(%rcx),%rcx
ffffffff8100b878:	48 89 88 b8 00 00 00 	mov    %rcx,0xb8(%rax)
                t->next->prev = t->prev->next = t;
ffffffff8100b87f:	48 89 81 c0 00 00 00 	mov    %rax,0xc0(%rcx)
ffffffff8100b886:	48 89 82 b8 00 00 00 	mov    %rax,0xb8(%rdx)
ffffffff8100b88d:	fe 83 8a 00 00 00    	incb   0x8a(%rbx)
ffffffff8100b893:	40 84 ed             	test   %bpl,%bpl
ffffffff8100b896:	74 15                	je     ffffffff8100b8ad <_ZN2Ec8block_scEv+0x13f>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100b898:	80 3d 91 3e ff 3e 00 	cmpb   $0x0,0x3eff3e91(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100b89f:	0f 85 40 ff ff ff    	jne    ffffffff8100b7e5 <_ZN2Ec8block_scEv+0x77>

            preemption = true;
ffffffff8100b8a5:	c6 05 84 3e ff 3e 01 	movb   $0x1,0x3eff3e84(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100b8ac:	fb                   	sti    
        }

        Sc::schedule(true);
ffffffff8100b8ad:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff8100b8b2:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff8100b8b7:	e8 f8 94 00 00       	callq  ffffffff81014db4 <_ZN2Sc8scheduleEbb>
    }
ffffffff8100b8bc:	58                   	pop    %rax
ffffffff8100b8bd:	5b                   	pop    %rbx
ffffffff8100b8be:	5d                   	pop    %rbp
ffffffff8100b8bf:	c3                   	retq   

ffffffff8100b8c0 <_ZN2SmD1Ev>:
            if (l) lock.unlock();
            return c;
        }

        Sm (Pd *, mword, mword = 0, Sm * = nullptr, mword = 0);
        ~Sm ()
ffffffff8100b8c0:	41 56                	push   %r14
ffffffff8100b8c2:	41 55                	push   %r13
        ALWAYS_INLINE
        inline void up (void (*c)() = nullptr, Sm * si = nullptr)
        {
            Ec *ec;

            {   Lock_guard <Spinlock> guard (lock);
ffffffff8100b8c4:	4c 8d af 8a 00 00 00 	lea    0x8a(%rdi),%r13
            if (l) lock.unlock();
            return c;
        }

        Sm (Pd *, mword, mword = 0, Sm * = nullptr, mword = 0);
        ~Sm ()
ffffffff8100b8cb:	41 54                	push   %r12
ffffffff8100b8cd:	55                   	push   %rbp
ffffffff8100b8ce:	49 89 fc             	mov    %rdi,%r12
ffffffff8100b8d1:	53                   	push   %rbx
        {
            while (!counter)
ffffffff8100b8d2:	49 83 bc 24 c0 00 00 	cmpq   $0x0,0xc0(%r12)
ffffffff8100b8d9:	00 00 
ffffffff8100b8db:	0f 85 41 02 00 00    	jne    ffffffff8100bb22 <_ZN2SmD1Ev+0x262>

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff8100b8e1:	9c                   	pushfq 
ffffffff8100b8e2:	5d                   	pop    %rbp
            return flags & 0x200;
ffffffff8100b8e3:	48 c1 ed 09          	shr    $0x9,%rbp

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8100b8e7:	40 80 e5 01          	and    $0x1,%bpl
ffffffff8100b8eb:	74 30                	je     ffffffff8100b91d <_ZN2SmD1Ev+0x5d>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff8100b8ed:	80 3d 3c 3e ff 3e 00 	cmpb   $0x0,0x3eff3e3c(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100b8f4:	75 1f                	jne    ffffffff8100b915 <_ZN2SmD1Ev+0x55>
ffffffff8100b8f6:	49 c7 c0 40 fb 01 81 	mov    $0xffffffff8101fb40,%r8
ffffffff8100b8fd:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff8100b902:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100b909:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff8100b910:	e9 04 01 00 00       	jmpq   ffffffff8100ba19 <_ZN2SmD1Ev+0x159>

            asm volatile ("cli" : : : "memory");
ffffffff8100b915:	fa                   	cli    
            preemption = false;
ffffffff8100b916:	c6 05 13 3e ff 3e 00 	movb   $0x0,0x3eff3e13(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff8100b91d:	4c 89 ef             	mov    %r13,%rdi
ffffffff8100b920:	e8 69 55 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff8100b925:	49 8b 9c 24 90 00 00 	mov    0x90(%r12),%rbx
ffffffff8100b92c:	00 
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff8100b92d:	48 85 db             	test   %rbx,%rbx
ffffffff8100b930:	0f 84 01 02 00 00    	je     ffffffff8100bb37 <_ZN2SmD1Ev+0x277>
ffffffff8100b936:	48 8b 83 b0 02 00 00 	mov    0x2b0(%rbx),%rax
ffffffff8100b93d:	48 85 c0             	test   %rax,%rax
ffffffff8100b940:	0f 84 f1 01 00 00    	je     ffffffff8100bb37 <_ZN2SmD1Ev+0x277>
ffffffff8100b946:	48 8b 93 a8 02 00 00 	mov    0x2a8(%rbx),%rdx
ffffffff8100b94d:	48 85 d2             	test   %rdx,%rdx
ffffffff8100b950:	0f 84 e1 01 00 00    	je     ffffffff8100bb37 <_ZN2SmD1Ev+0x277>
                return false;

            if (t == t->next)
ffffffff8100b956:	48 39 c3             	cmp    %rax,%rbx
ffffffff8100b959:	75 0e                	jne    ffffffff8100b969 <_ZN2SmD1Ev+0xa9>
                headptr = nullptr;
ffffffff8100b95b:	49 c7 84 24 90 00 00 	movq   $0x0,0x90(%r12)
ffffffff8100b962:	00 00 00 00 00 
ffffffff8100b967:	eb 35                	jmp    ffffffff8100b99e <_ZN2SmD1Ev+0xde>

            else {
                t->next->prev = t->prev;
ffffffff8100b969:	48 89 90 a8 02 00 00 	mov    %rdx,0x2a8(%rax)
                t->prev->next = t->next;
ffffffff8100b970:	48 8b 83 a8 02 00 00 	mov    0x2a8(%rbx),%rax
ffffffff8100b977:	48 8b 93 b0 02 00 00 	mov    0x2b0(%rbx),%rdx
ffffffff8100b97e:	48 89 90 b0 02 00 00 	mov    %rdx,0x2b0(%rax)
                if (t == headptr)
ffffffff8100b985:	49 3b 9c 24 90 00 00 	cmp    0x90(%r12),%rbx
ffffffff8100b98c:	00 
ffffffff8100b98d:	75 0f                	jne    ffffffff8100b99e <_ZN2SmD1Ev+0xde>
                    headptr = t->next;
ffffffff8100b98f:	48 8b 83 b0 02 00 00 	mov    0x2b0(%rbx),%rax
ffffffff8100b996:	49 89 84 24 90 00 00 	mov    %rax,0x90(%r12)
ffffffff8100b99d:	00 
            }

            t->next = t->prev = nullptr;
ffffffff8100b99e:	48 c7 83 a8 02 00 00 	movq   $0x0,0x2a8(%rbx)
ffffffff8100b9a5:	00 00 00 00 
ffffffff8100b9a9:	48 c7 83 b0 02 00 00 	movq   $0x0,0x2b0(%rbx)
ffffffff8100b9b0:	00 00 00 00 
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff8100b9b4:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff8100b9b7:	f0 0f c1 83 8c 00 00 	lock xadd %eax,0x8c(%rbx)
ffffffff8100b9be:	00 

                    counter++;
                    return;
                }

                if (EXPECT_FALSE(ec->del_ref())) {
ffffffff8100b9bf:	ff c8                	dec    %eax
ffffffff8100b9c1:	75 2a                	jne    ffffffff8100b9ed <_ZN2SmD1Ev+0x12d>
                    delete ec;
ffffffff8100b9c3:	48 89 df             	mov    %rbx,%rdi
ffffffff8100b9c6:	e8 71 8a ff ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff8100b9cb:	48 8b 83 98 02 00 00 	mov    0x298(%rbx),%rax
ffffffff8100b9d2:	48 89 de             	mov    %rbx,%rsi
ffffffff8100b9d5:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff8100b9dc:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff8100b9e3:	e8 82 a0 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
ffffffff8100b9e8:	e9 38 ff ff ff       	jmpq   ffffffff8100b925 <_ZN2SmD1Ev+0x65>
ffffffff8100b9ed:	41 fe 45 00          	incb   0x0(%r13)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff8100b9f1:	40 84 ed             	test   %bpl,%bpl
ffffffff8100b9f4:	74 39                	je     ffffffff8100ba2f <_ZN2SmD1Ev+0x16f>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100b9f6:	80 3d 33 3d ff 3e 00 	cmpb   $0x0,0x3eff3d33(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100b9fd:	74 28                	je     ffffffff8100ba27 <_ZN2SmD1Ev+0x167>
ffffffff8100b9ff:	49 c7 c0 10 fb 01 81 	mov    $0xffffffff8101fb10,%r8
ffffffff8100ba06:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff8100ba0b:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100ba12:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff8100ba19:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100ba20:	31 c0                	xor    %eax,%eax
ffffffff8100ba22:	e8 29 65 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            preemption = true;
ffffffff8100ba27:	c6 05 02 3d ff 3e 01 	movb   $0x1,0x3eff3d02(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100ba2e:	fb                   	sti    
    }

    ALWAYS_INLINE
    inline void release(void (*c)()) {
        if (c)
            cont = c;
ffffffff8100ba2f:	48 c7 83 a0 00 00 00 	movq   $0xffffffff810170dc,0xa0(%rbx)
ffffffff8100ba36:	dc 70 01 81 

        Lock_guard <Spinlock> guard(lock);
ffffffff8100ba3a:	48 8d bb 8a 00 00 00 	lea    0x8a(%rbx),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff8100ba41:	9c                   	pushfq 
ffffffff8100ba42:	58                   	pop    %rax
            return flags & 0x200;
ffffffff8100ba43:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8100ba47:	41 88 c6             	mov    %al,%r14b
ffffffff8100ba4a:	41 80 e6 01          	and    $0x1,%r14b
ffffffff8100ba4e:	74 15                	je     ffffffff8100ba65 <_ZN2SmD1Ev+0x1a5>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff8100ba50:	80 3d d9 3c ff 3e 00 	cmpb   $0x0,0x3eff3cd9(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100ba57:	0f 84 99 fe ff ff    	je     ffffffff8100b8f6 <_ZN2SmD1Ev+0x36>

            asm volatile ("cli" : : : "memory");
ffffffff8100ba5d:	fa                   	cli    
            preemption = false;
ffffffff8100ba5e:	c6 05 cb 3c ff 3e 00 	movb   $0x0,0x3eff3ccb(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff8100ba65:	e8 24 54 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff8100ba6a:	48 8b ab 90 00 00 00 	mov    0x90(%rbx),%rbp
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff8100ba71:	48 85 ed             	test   %rbp,%rbp
ffffffff8100ba74:	0f 84 db 00 00 00    	je     ffffffff8100bb55 <_ZN2SmD1Ev+0x295>
ffffffff8100ba7a:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff8100ba81:	48 85 c0             	test   %rax,%rax
ffffffff8100ba84:	0f 84 cb 00 00 00    	je     ffffffff8100bb55 <_ZN2SmD1Ev+0x295>
ffffffff8100ba8a:	48 8b 95 b8 00 00 00 	mov    0xb8(%rbp),%rdx
ffffffff8100ba91:	48 85 d2             	test   %rdx,%rdx
ffffffff8100ba94:	0f 84 bb 00 00 00    	je     ffffffff8100bb55 <_ZN2SmD1Ev+0x295>
                return false;

            if (t == t->next)
ffffffff8100ba9a:	48 39 c5             	cmp    %rax,%rbp
ffffffff8100ba9d:	75 0d                	jne    ffffffff8100baac <_ZN2SmD1Ev+0x1ec>
                headptr = nullptr;
ffffffff8100ba9f:	48 c7 83 90 00 00 00 	movq   $0x0,0x90(%rbx)
ffffffff8100baa6:	00 00 00 00 
ffffffff8100baaa:	eb 33                	jmp    ffffffff8100badf <_ZN2SmD1Ev+0x21f>

            else {
                t->next->prev = t->prev;
ffffffff8100baac:	48 89 90 b8 00 00 00 	mov    %rdx,0xb8(%rax)
                t->prev->next = t->next;
ffffffff8100bab3:	48 8b 85 b8 00 00 00 	mov    0xb8(%rbp),%rax
ffffffff8100baba:	48 8b 95 c0 00 00 00 	mov    0xc0(%rbp),%rdx
ffffffff8100bac1:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
                if (t == headptr)
ffffffff8100bac8:	48 3b ab 90 00 00 00 	cmp    0x90(%rbx),%rbp
ffffffff8100bacf:	75 0e                	jne    ffffffff8100badf <_ZN2SmD1Ev+0x21f>
                    headptr = t->next;
ffffffff8100bad1:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff8100bad8:	48 89 83 90 00 00 00 	mov    %rax,0x90(%rbx)
            }

            t->next = t->prev = nullptr;
ffffffff8100badf:	48 c7 85 b8 00 00 00 	movq   $0x0,0xb8(%rbp)
ffffffff8100bae6:	00 00 00 00 
ffffffff8100baea:	48 c7 85 c0 00 00 00 	movq   $0x0,0xc0(%rbp)
ffffffff8100baf1:	00 00 00 00 
ffffffff8100baf5:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff8100baf8:	f0 0f c1 85 8c 00 00 	lock xadd %eax,0x8c(%rbp)
ffffffff8100baff:	00 

        for (Sc *s; dequeue(s = head());) {
            if (EXPECT_FALSE(s->del_ref()) && (this == s->ec)) {
ffffffff8100bb00:	ff c8                	dec    %eax
ffffffff8100bb02:	75 44                	jne    ffffffff8100bb48 <_ZN2SmD1Ev+0x288>
ffffffff8100bb04:	48 3b 9d 90 00 00 00 	cmp    0x90(%rbp),%rbx
ffffffff8100bb0b:	75 3b                	jne    ffffffff8100bb48 <_ZN2SmD1Ev+0x288>
                delete s;
ffffffff8100bb0d:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100bb10:	e8 4b d0 ff ff       	callq  ffffffff81008b60 <_ZN2ScD1Ev>
ffffffff8100bb15:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100bb18:	e8 0d 92 00 00       	callq  ffffffff81014d2a <_ZN2ScdlEPv>
ffffffff8100bb1d:	e9 48 ff ff ff       	jmpq   ffffffff8100ba6a <_ZN2SmD1Ev+0x1aa>
        Sm (Pd *, mword, mword = 0, Sm * = nullptr, mword = 0);
        ~Sm ()
        {
            while (!counter)
                up (Ec::sys_finish<Sys_regs::BAD_CAP, true>);
        }
ffffffff8100bb22:	5b                   	pop    %rbx
            return c;
        }

        Sm (Pd *, mword, mword = 0, Sm * = nullptr, mword = 0);
        ~Sm ()
        {
ffffffff8100bb23:	49 8d bc 24 a0 00 00 	lea    0xa0(%r12),%rdi
ffffffff8100bb2a:	00 
            while (!counter)
                up (Ec::sys_finish<Sys_regs::BAD_CAP, true>);
        }
ffffffff8100bb2b:	5d                   	pop    %rbp
ffffffff8100bb2c:	41 5c                	pop    %r12
ffffffff8100bb2e:	41 5d                	pop    %r13
ffffffff8100bb30:	41 5e                	pop    %r14
            return c;
        }

        Sm (Pd *, mword, mword = 0, Sm * = nullptr, mword = 0);
        ~Sm ()
        {
ffffffff8100bb32:	e9 9b 94 00 00       	jmpq   ffffffff81014fd2 <_ZN2SiD1Ev>
                    if (si) {
                       if (si->queued()) return;
                       Queue<Si>::enqueue(si);
                    }

                    counter++;
ffffffff8100bb37:	49 ff 84 24 c0 00 00 	incq   0xc0(%r12)
ffffffff8100bb3e:	00 
ffffffff8100bb3f:	41 fe 45 00          	incb   0x0(%r13)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff8100bb43:	40 84 ed             	test   %bpl,%bpl
ffffffff8100bb46:	eb 16                	jmp    ffffffff8100bb5e <_ZN2SmD1Ev+0x29e>
                continue;
            }
            s->remote_enqueue();
ffffffff8100bb48:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100bb4b:	e8 10 8f 00 00       	callq  ffffffff81014a60 <_ZN2Sc14remote_enqueueEv>
ffffffff8100bb50:	e9 15 ff ff ff       	jmpq   ffffffff8100ba6a <_ZN2SmD1Ev+0x1aa>
ffffffff8100bb55:	fe 83 8a 00 00 00    	incb   0x8a(%rbx)
ffffffff8100bb5b:	45 84 f6             	test   %r14b,%r14b
ffffffff8100bb5e:	0f 84 6e fd ff ff    	je     ffffffff8100b8d2 <_ZN2SmD1Ev+0x12>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100bb64:	80 3d c5 3b ff 3e 00 	cmpb   $0x0,0x3eff3bc5(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100bb6b:	0f 85 8e fe ff ff    	jne    ffffffff8100b9ff <_ZN2SmD1Ev+0x13f>

            preemption = true;
ffffffff8100bb71:	c6 05 b8 3b ff 3e 01 	movb   $0x1,0x3eff3bb8(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100bb78:	fb                   	sti    
ffffffff8100bb79:	e9 54 fd ff ff       	jmpq   ffffffff8100b8d2 <_ZN2SmD1Ev+0x12>

ffffffff8100bb7e <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvv>:
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
{
    assert (current->xcpu_sm);
ffffffff8100bb7e:	48 8b 05 83 34 ff 3e 	mov    0x3eff3483(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>

    Sc::schedule(true);
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
ffffffff8100bb85:	41 54                	push   %r12
ffffffff8100bb87:	55                   	push   %rbp
ffffffff8100bb88:	53                   	push   %rbx
{
    assert (current->xcpu_sm);
ffffffff8100bb89:	48 8b 98 30 03 00 00 	mov    0x330(%rax),%rbx
ffffffff8100bb90:	48 85 db             	test   %rbx,%rbx
ffffffff8100bb93:	75 1f                	jne    ffffffff8100bbb4 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvv+0x36>
ffffffff8100bb95:	49 c7 c0 c0 fb 01 81 	mov    $0xffffffff8101fbc0,%r8
ffffffff8100bb9c:	b9 9b 00 00 00       	mov    $0x9b,%ecx
ffffffff8100bba1:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100bba8:	48 c7 c6 cc de 01 81 	mov    $0xffffffff8101decc,%rsi
ffffffff8100bbaf:	e9 42 01 00 00       	jmpq   ffffffff8100bcf6 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvv+0x178>

    Sm::destroy(current->xcpu_sm, Pd::current->quota);
ffffffff8100bbb4:	48 8b 05 55 34 ff 3e 	mov    0x3eff3455(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void destroy(Sm *obj, Quota &quota) { obj->~Sm(); cache.free (obj, quota); }
ffffffff8100bbbb:	48 89 df             	mov    %rbx,%rdi
ffffffff8100bbbe:	48 8d a8 08 03 00 00 	lea    0x308(%rax),%rbp
ffffffff8100bbc5:	e8 f6 fc ff ff       	callq  ffffffff8100b8c0 <_ZN2SmD1Ev>
ffffffff8100bbca:	48 89 ea             	mov    %rbp,%rdx
ffffffff8100bbcd:	48 89 de             	mov    %rbx,%rsi
ffffffff8100bbd0:	48 c7 c7 80 40 16 81 	mov    $0xffffffff81164080,%rdi
ffffffff8100bbd7:	e8 8e 9e 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
    current->xcpu_sm = nullptr;
ffffffff8100bbdc:	48 8b 1d 25 34 ff 3e 	mov    0x3eff3425(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100bbe3:	83 c8 ff             	or     $0xffffffff,%eax
        }

        ALWAYS_INLINE
        inline bool del_ref()
        {
            return Atomic::sub (ref, 1U) == 0;
ffffffff8100bbe6:	48 8d ab 8c 00 00 00 	lea    0x8c(%rbx),%rbp
ffffffff8100bbed:	48 c7 83 30 03 00 00 	movq   $0x0,0x330(%rbx)
ffffffff8100bbf4:	00 00 00 00 

    current->cont = C;
ffffffff8100bbf8:	48 c7 83 a0 00 00 00 	movq   $0xffffffff81000680,0xa0(%rbx)
ffffffff8100bbff:	80 06 00 81 
ffffffff8100bc03:	f0 0f c1 45 00       	lock xadd %eax,0x0(%rbp)
        regs.ARG_3 = cnt;
    }

    ALWAYS_INLINE NORETURN
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
ffffffff8100bc08:	ff c8                	dec    %eax
ffffffff8100bc0a:	75 32                	jne    ffffffff8100bc3e <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvv+0xc0>
            delete current;
ffffffff8100bc0c:	4c 8b 25 f5 33 ff 3e 	mov    0x3eff33f5(%rip),%r12        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100bc13:	4d 85 e4             	test   %r12,%r12
ffffffff8100bc16:	74 26                	je     ffffffff8100bc3e <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvv+0xc0>
ffffffff8100bc18:	4c 89 e7             	mov    %r12,%rdi
ffffffff8100bc1b:	e8 1c 88 ff ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff8100bc20:	49 8b 84 24 98 02 00 	mov    0x298(%r12),%rax
ffffffff8100bc27:	00 
ffffffff8100bc28:	4c 89 e6             	mov    %r12,%rsi
ffffffff8100bc2b:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff8100bc32:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff8100bc39:	e8 2c 9e 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
            delete current;
        }

        current = this;
ffffffff8100bc3e:	48 89 1d c3 33 ff 3e 	mov    %rbx,0x3eff33c3(%rip)        # ffffffffbffff008 <_ZN2Ec7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100bc45:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff8100bc4b:	85 c0                	test   %eax,%eax
ffffffff8100bc4d:	74 0a                	je     ffffffff8100bc59 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvv+0xdb>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8100bc4f:	8d 50 01             	lea    0x1(%rax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff8100bc52:	f0 0f b1 55 00       	lock cmpxchg %edx,0x0(%rbp)
ffffffff8100bc57:	75 ec                	jne    ffffffff8100bc45 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvv+0xc7>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
ffffffff8100bc59:	48 8b 93 98 02 00 00 	mov    0x298(%rbx),%rdx

        current->add_ref();

        Tss::run.sp0 = reinterpret_cast<mword> (exc_regs() + 1);
ffffffff8100bc60:	48 8d 83 80 01 00 00 	lea    0x180(%rbx),%rax
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
ffffffff8100bc67:	8b 0d 97 33 ff 3e    	mov    0x3eff3397(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100bc6d:	48 89 05 58 41 ff 3e 	mov    %rax,0x3eff4158(%rip)        # ffffffffbffffdcc <tss_run+0x4>
ffffffff8100bc74:	48 8b 82 c8 02 00 00 	mov    0x2c8(%rdx),%rax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
ffffffff8100bc7b:	48 8b b2 b8 02 00 00 	mov    0x2b8(%rdx),%rsi

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
ffffffff8100bc82:	48 0f a3 c8          	bt     %rcx,%rax
ffffffff8100bc86:	73 14                	jae    ffffffff8100bc9c <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvv+0x11e>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
ffffffff8100bc88:	48 c7 c0 fe ff ff ff 	mov    $0xfffffffffffffffe,%rax
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
ffffffff8100bc8f:	48 d3 c0             	rol    %cl,%rax
ffffffff8100bc92:	f0 48 21 82 c8 02 00 	lock and %rax,0x2c8(%rdx)
ffffffff8100bc99:	00 
ffffffff8100bc9a:	eb 20                	jmp    ffffffff8100bcbc <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvv+0x13e>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
ffffffff8100bc9c:	48 39 15 6d 33 ff 3e 	cmp    %rdx,0x3eff336d(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100bca3:	0f 84 e5 00 00 00    	je     ffffffff8100bd8e <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvv+0x210>
                    return;

                if (pcid != NO_PCID)
ffffffff8100bca9:	48 83 fe 02          	cmp    $0x2,%rsi
ffffffff8100bcad:	74 0d                	je     ffffffff8100bcbc <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvv+0x13e>
                    pcid |= static_cast<mword>(1ULL << 63);
ffffffff8100bcaf:	48 b8 00 00 00 00 00 	movabs $0x8000000000000000,%rax
ffffffff8100bcb6:	00 00 80 
ffffffff8100bcb9:	48 09 c6             	or     %rax,%rsi
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff8100bcbc:	48 8b 05 4d 33 ff 3e 	mov    0x3eff334d(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100bcc3:	83 c9 ff             	or     $0xffffffff,%ecx
ffffffff8100bcc6:	f0 0f c1 88 8c 00 00 	lock xadd %ecx,0x8c(%rax)
ffffffff8100bccd:	00 
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
ffffffff8100bcce:	83 f9 01             	cmp    $0x1,%ecx
ffffffff8100bcd1:	75 31                	jne    ffffffff8100bd04 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvv+0x186>
                assert (current != this);
ffffffff8100bcd3:	48 8b 2d 36 33 ff 3e 	mov    0x3eff3336(%rip),%rbp        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100bcda:	48 39 d5             	cmp    %rdx,%rbp
ffffffff8100bcdd:	75 27                	jne    ffffffff8100bd06 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvv+0x188>
ffffffff8100bcdf:	49 c7 c0 70 fb 01 81 	mov    $0xffffffff8101fb70,%r8
ffffffff8100bce6:	b1 5e                	mov    $0x5e,%cl
ffffffff8100bce8:	48 c7 c2 c7 e6 01 81 	mov    $0xffffffff8101e6c7,%rdx
ffffffff8100bcef:	48 c7 c6 35 e7 01 81 	mov    $0xffffffff8101e735,%rsi
ffffffff8100bcf6:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100bcfd:	31 c0                	xor    %eax,%eax
ffffffff8100bcff:	e8 4c 62 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
ffffffff8100bd04:	31 ed                	xor    %ebp,%ebp
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
ffffffff8100bd06:	48 89 15 03 33 ff 3e 	mov    %rdx,0x3eff3303(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100bd0d:	8b 82 8c 00 00 00    	mov    0x8c(%rdx),%eax
ffffffff8100bd13:	85 c0                	test   %eax,%eax
ffffffff8100bd15:	74 0d                	je     ffffffff8100bd24 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvv+0x1a6>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8100bd17:	8d 48 01             	lea    0x1(%rax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff8100bd1a:	f0 0f b1 8a 8c 00 00 	lock cmpxchg %ecx,0x8c(%rdx)
ffffffff8100bd21:	00 
ffffffff8100bd22:	75 e9                	jne    ffffffff8100bd0d <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvv+0x18f>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
ffffffff8100bd24:	f6 05 1b 3a ff 3e 02 	testb  $0x2,0x3eff3a1b(%rip)        # ffffffffbffff746 <_ZN3Cpu8featuresE+0x6>
        return addr;
    }

    ALWAYS_INLINE
    inline void make_current(mword pcid) {
        asm volatile ("mov %0, %%cr3" : : "r" (val | pcid) : "memory");
ffffffff8100bd2b:	8b 0d d3 32 ff 3e    	mov    0x3eff32d3(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100bd31:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff8100bd36:	48 0f 45 c6          	cmovne %rsi,%rax
ffffffff8100bd3a:	48 0b 84 ca a0 00 00 	or     0xa0(%rdx,%rcx,8),%rax
ffffffff8100bd41:	00 
ffffffff8100bd42:	0f 22 d8             	mov    %rax,%cr3

            if (del_pd)
ffffffff8100bd45:	48 85 ed             	test   %rbp,%rbp
ffffffff8100bd48:	74 44                	je     ffffffff8100bd8e <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_9sys_replyEvEEEEvv+0x210>
                delete del_pd;
ffffffff8100bd4a:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100bd4d:	e8 d6 52 00 00       	callq  ffffffff81011028 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff8100bd52:	48 8b 45 50          	mov    0x50(%rbp),%rax
ffffffff8100bd56:	31 d2                	xor    %edx,%edx

            pd_del->quota.free_up(pd_to->quota);
ffffffff8100bd58:	48 8d bd 08 03 00 00 	lea    0x308(%rbp),%rdi

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff8100bd5f:	48 8d 88 08 fd ff ff 	lea    -0x2f8(%rax),%rcx
ffffffff8100bd66:	48 85 c0             	test   %rax,%rax
ffffffff8100bd69:	48 0f 45 d1          	cmovne %rcx,%rdx

            pd_del->quota.free_up(pd_to->quota);
ffffffff8100bd6d:	4c 8d a2 08 03 00 00 	lea    0x308(%rdx),%r12
ffffffff8100bd74:	4c 89 e6             	mov    %r12,%rsi
ffffffff8100bd77:	e8 48 78 ff ff       	callq  ffffffff810035c4 <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
ffffffff8100bd7c:	4c 89 e2             	mov    %r12,%rdx
ffffffff8100bd7f:	48 89 ee             	mov    %rbp,%rsi
ffffffff8100bd82:	48 c7 c7 d0 3f 16 81 	mov    $0xffffffff81163fd0,%rdi
ffffffff8100bd89:	e8 dc 9c 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>

        pd->make_current();

        asm volatile ("mov %0," EXPAND(PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory");
ffffffff8100bd8e:	48 8b 83 a0 00 00 00 	mov    0xa0(%rbx),%rax
ffffffff8100bd95:	48 c7 c4 00 e0 ff bf 	mov    $0xffffffffbfffe000,%rsp
ffffffff8100bd9c:	ff e0                	jmpq   *%rax

ffffffff8100bd9e <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvv>:
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
{
    assert (current->xcpu_sm);
ffffffff8100bd9e:	48 8b 05 63 32 ff 3e 	mov    0x3eff3263(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>

    Sc::schedule(true);
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
ffffffff8100bda5:	41 54                	push   %r12
ffffffff8100bda7:	55                   	push   %rbp
ffffffff8100bda8:	53                   	push   %rbx
{
    assert (current->xcpu_sm);
ffffffff8100bda9:	48 8b 98 30 03 00 00 	mov    0x330(%rax),%rbx
ffffffff8100bdb0:	48 85 db             	test   %rbx,%rbx
ffffffff8100bdb3:	75 1f                	jne    ffffffff8100bdd4 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvv+0x36>
ffffffff8100bdb5:	49 c7 c0 c0 f8 01 81 	mov    $0xffffffff8101f8c0,%r8
ffffffff8100bdbc:	b9 9b 00 00 00       	mov    $0x9b,%ecx
ffffffff8100bdc1:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100bdc8:	48 c7 c6 cc de 01 81 	mov    $0xffffffff8101decc,%rsi
ffffffff8100bdcf:	e9 42 01 00 00       	jmpq   ffffffff8100bf16 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvv+0x178>

    Sm::destroy(current->xcpu_sm, Pd::current->quota);
ffffffff8100bdd4:	48 8b 05 35 32 ff 3e 	mov    0x3eff3235(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100bddb:	48 89 df             	mov    %rbx,%rdi
ffffffff8100bdde:	48 8d a8 08 03 00 00 	lea    0x308(%rax),%rbp
ffffffff8100bde5:	e8 d6 fa ff ff       	callq  ffffffff8100b8c0 <_ZN2SmD1Ev>
ffffffff8100bdea:	48 89 ea             	mov    %rbp,%rdx
ffffffff8100bded:	48 89 de             	mov    %rbx,%rsi
ffffffff8100bdf0:	48 c7 c7 80 40 16 81 	mov    $0xffffffff81164080,%rdi
ffffffff8100bdf7:	e8 6e 9c 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
    current->xcpu_sm = nullptr;
ffffffff8100bdfc:	48 8b 1d 05 32 ff 3e 	mov    0x3eff3205(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff8100be03:	83 c8 ff             	or     $0xffffffff,%eax
        }

        ALWAYS_INLINE
        inline bool del_ref()
        {
            return Atomic::sub (ref, 1U) == 0;
ffffffff8100be06:	48 8d ab 8c 00 00 00 	lea    0x8c(%rbx),%rbp
ffffffff8100be0d:	48 c7 83 30 03 00 00 	movq   $0x0,0x330(%rbx)
ffffffff8100be14:	00 00 00 00 

    current->cont = C;
ffffffff8100be18:	48 c7 83 a0 00 00 00 	movq   $0xffffffff810008ae,0xa0(%rbx)
ffffffff8100be1f:	ae 08 00 81 
ffffffff8100be23:	f0 0f c1 45 00       	lock xadd %eax,0x0(%rbp)
        regs.ARG_3 = cnt;
    }

    ALWAYS_INLINE NORETURN
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
ffffffff8100be28:	ff c8                	dec    %eax
ffffffff8100be2a:	75 32                	jne    ffffffff8100be5e <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvv+0xc0>
            delete current;
ffffffff8100be2c:	4c 8b 25 d5 31 ff 3e 	mov    0x3eff31d5(%rip),%r12        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100be33:	4d 85 e4             	test   %r12,%r12
ffffffff8100be36:	74 26                	je     ffffffff8100be5e <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvv+0xc0>
ffffffff8100be38:	4c 89 e7             	mov    %r12,%rdi
ffffffff8100be3b:	e8 fc 85 ff ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff8100be40:	49 8b 84 24 98 02 00 	mov    0x298(%r12),%rax
ffffffff8100be47:	00 
ffffffff8100be48:	4c 89 e6             	mov    %r12,%rsi
ffffffff8100be4b:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff8100be52:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff8100be59:	e8 0c 9c 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
            delete current;
        }

        current = this;
ffffffff8100be5e:	48 89 1d a3 31 ff 3e 	mov    %rbx,0x3eff31a3(%rip)        # ffffffffbffff008 <_ZN2Ec7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100be65:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff8100be6b:	85 c0                	test   %eax,%eax
ffffffff8100be6d:	74 0a                	je     ffffffff8100be79 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvv+0xdb>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8100be6f:	8d 50 01             	lea    0x1(%rax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff8100be72:	f0 0f b1 55 00       	lock cmpxchg %edx,0x0(%rbp)
ffffffff8100be77:	75 ec                	jne    ffffffff8100be65 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvv+0xc7>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
ffffffff8100be79:	48 8b 93 98 02 00 00 	mov    0x298(%rbx),%rdx

        current->add_ref();

        Tss::run.sp0 = reinterpret_cast<mword> (exc_regs() + 1);
ffffffff8100be80:	48 8d 83 80 01 00 00 	lea    0x180(%rbx),%rax
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
ffffffff8100be87:	8b 0d 77 31 ff 3e    	mov    0x3eff3177(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100be8d:	48 89 05 38 3f ff 3e 	mov    %rax,0x3eff3f38(%rip)        # ffffffffbffffdcc <tss_run+0x4>
ffffffff8100be94:	48 8b 82 c8 02 00 00 	mov    0x2c8(%rdx),%rax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
ffffffff8100be9b:	48 8b b2 b8 02 00 00 	mov    0x2b8(%rdx),%rsi

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
ffffffff8100bea2:	48 0f a3 c8          	bt     %rcx,%rax
ffffffff8100bea6:	73 14                	jae    ffffffff8100bebc <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvv+0x11e>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
ffffffff8100bea8:	48 c7 c0 fe ff ff ff 	mov    $0xfffffffffffffffe,%rax
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
ffffffff8100beaf:	48 d3 c0             	rol    %cl,%rax
ffffffff8100beb2:	f0 48 21 82 c8 02 00 	lock and %rax,0x2c8(%rdx)
ffffffff8100beb9:	00 
ffffffff8100beba:	eb 20                	jmp    ffffffff8100bedc <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvv+0x13e>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
ffffffff8100bebc:	48 39 15 4d 31 ff 3e 	cmp    %rdx,0x3eff314d(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100bec3:	0f 84 e5 00 00 00    	je     ffffffff8100bfae <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvv+0x210>
                    return;

                if (pcid != NO_PCID)
ffffffff8100bec9:	48 83 fe 02          	cmp    $0x2,%rsi
ffffffff8100becd:	74 0d                	je     ffffffff8100bedc <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvv+0x13e>
                    pcid |= static_cast<mword>(1ULL << 63);
ffffffff8100becf:	48 b8 00 00 00 00 00 	movabs $0x8000000000000000,%rax
ffffffff8100bed6:	00 00 80 
ffffffff8100bed9:	48 09 c6             	or     %rax,%rsi
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff8100bedc:	48 8b 05 2d 31 ff 3e 	mov    0x3eff312d(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100bee3:	83 c9 ff             	or     $0xffffffff,%ecx
ffffffff8100bee6:	f0 0f c1 88 8c 00 00 	lock xadd %ecx,0x8c(%rax)
ffffffff8100beed:	00 
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
ffffffff8100beee:	83 f9 01             	cmp    $0x1,%ecx
ffffffff8100bef1:	75 31                	jne    ffffffff8100bf24 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvv+0x186>
                assert (current != this);
ffffffff8100bef3:	48 8b 2d 16 31 ff 3e 	mov    0x3eff3116(%rip),%rbp        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100befa:	48 39 d5             	cmp    %rdx,%rbp
ffffffff8100befd:	75 27                	jne    ffffffff8100bf26 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvv+0x188>
ffffffff8100beff:	49 c7 c0 70 fb 01 81 	mov    $0xffffffff8101fb70,%r8
ffffffff8100bf06:	b1 5e                	mov    $0x5e,%cl
ffffffff8100bf08:	48 c7 c2 c7 e6 01 81 	mov    $0xffffffff8101e6c7,%rdx
ffffffff8100bf0f:	48 c7 c6 35 e7 01 81 	mov    $0xffffffff8101e735,%rsi
ffffffff8100bf16:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100bf1d:	31 c0                	xor    %eax,%eax
ffffffff8100bf1f:	e8 2c 60 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
ffffffff8100bf24:	31 ed                	xor    %ebp,%ebp
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
ffffffff8100bf26:	48 89 15 e3 30 ff 3e 	mov    %rdx,0x3eff30e3(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100bf2d:	8b 82 8c 00 00 00    	mov    0x8c(%rdx),%eax
ffffffff8100bf33:	85 c0                	test   %eax,%eax
ffffffff8100bf35:	74 0d                	je     ffffffff8100bf44 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvv+0x1a6>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8100bf37:	8d 48 01             	lea    0x1(%rax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff8100bf3a:	f0 0f b1 8a 8c 00 00 	lock cmpxchg %ecx,0x8c(%rdx)
ffffffff8100bf41:	00 
ffffffff8100bf42:	75 e9                	jne    ffffffff8100bf2d <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvv+0x18f>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
ffffffff8100bf44:	f6 05 fb 37 ff 3e 02 	testb  $0x2,0x3eff37fb(%rip)        # ffffffffbffff746 <_ZN3Cpu8featuresE+0x6>
ffffffff8100bf4b:	8b 0d b3 30 ff 3e    	mov    0x3eff30b3(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100bf51:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff8100bf56:	48 0f 45 c6          	cmovne %rsi,%rax
ffffffff8100bf5a:	48 0b 84 ca a0 00 00 	or     0xa0(%rdx,%rcx,8),%rax
ffffffff8100bf61:	00 
ffffffff8100bf62:	0f 22 d8             	mov    %rax,%cr3

            if (del_pd)
ffffffff8100bf65:	48 85 ed             	test   %rbp,%rbp
ffffffff8100bf68:	74 44                	je     ffffffff8100bfae <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_8sys_callEvEEEEvv+0x210>
                delete del_pd;
ffffffff8100bf6a:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100bf6d:	e8 b6 50 00 00       	callq  ffffffff81011028 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff8100bf72:	48 8b 45 50          	mov    0x50(%rbp),%rax
ffffffff8100bf76:	31 d2                	xor    %edx,%edx

            pd_del->quota.free_up(pd_to->quota);
ffffffff8100bf78:	48 8d bd 08 03 00 00 	lea    0x308(%rbp),%rdi

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff8100bf7f:	48 8d 88 08 fd ff ff 	lea    -0x2f8(%rax),%rcx
ffffffff8100bf86:	48 85 c0             	test   %rax,%rax
ffffffff8100bf89:	48 0f 45 d1          	cmovne %rcx,%rdx

            pd_del->quota.free_up(pd_to->quota);
ffffffff8100bf8d:	4c 8d a2 08 03 00 00 	lea    0x308(%rdx),%r12
ffffffff8100bf94:	4c 89 e6             	mov    %r12,%rsi
ffffffff8100bf97:	e8 28 76 ff ff       	callq  ffffffff810035c4 <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
ffffffff8100bf9c:	4c 89 e2             	mov    %r12,%rdx
ffffffff8100bf9f:	48 89 ee             	mov    %rbp,%rsi
ffffffff8100bfa2:	48 c7 c7 d0 3f 16 81 	mov    $0xffffffff81163fd0,%rdi
ffffffff8100bfa9:	e8 bc 9a 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>

        pd->make_current();

        asm volatile ("mov %0," EXPAND(PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory");
ffffffff8100bfae:	48 8b 83 a0 00 00 00 	mov    0xa0(%rbx),%rax
ffffffff8100bfb5:	48 c7 c4 00 e0 ff bf 	mov    $0xffffffffbfffe000,%rsp
ffffffff8100bfbc:	ff e0                	jmpq   *%rax

ffffffff8100bfbe <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvv>:
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
{
    assert (current->xcpu_sm);
ffffffff8100bfbe:	48 8b 05 43 30 ff 3e 	mov    0x3eff3043(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>

    Sc::schedule(true);
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
ffffffff8100bfc5:	41 54                	push   %r12
ffffffff8100bfc7:	55                   	push   %rbp
ffffffff8100bfc8:	53                   	push   %rbx
{
    assert (current->xcpu_sm);
ffffffff8100bfc9:	48 8b 98 30 03 00 00 	mov    0x330(%rax),%rbx
ffffffff8100bfd0:	48 85 db             	test   %rbx,%rbx
ffffffff8100bfd3:	75 1f                	jne    ffffffff8100bff4 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvv+0x36>
ffffffff8100bfd5:	49 c7 c0 c0 f6 01 81 	mov    $0xffffffff8101f6c0,%r8
ffffffff8100bfdc:	b9 9b 00 00 00       	mov    $0x9b,%ecx
ffffffff8100bfe1:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100bfe8:	48 c7 c6 cc de 01 81 	mov    $0xffffffff8101decc,%rsi
ffffffff8100bfef:	e9 42 01 00 00       	jmpq   ffffffff8100c136 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvv+0x178>

    Sm::destroy(current->xcpu_sm, Pd::current->quota);
ffffffff8100bff4:	48 8b 05 15 30 ff 3e 	mov    0x3eff3015(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100bffb:	48 89 df             	mov    %rbx,%rdi
ffffffff8100bffe:	48 8d a8 08 03 00 00 	lea    0x308(%rax),%rbp
ffffffff8100c005:	e8 b6 f8 ff ff       	callq  ffffffff8100b8c0 <_ZN2SmD1Ev>
ffffffff8100c00a:	48 89 ea             	mov    %rbp,%rdx
ffffffff8100c00d:	48 89 de             	mov    %rbx,%rsi
ffffffff8100c010:	48 c7 c7 80 40 16 81 	mov    $0xffffffff81164080,%rdi
ffffffff8100c017:	e8 4e 9a 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
    current->xcpu_sm = nullptr;
ffffffff8100c01c:	48 8b 1d e5 2f ff 3e 	mov    0x3eff2fe5(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff8100c023:	83 c8 ff             	or     $0xffffffff,%eax
        }

        ALWAYS_INLINE
        inline bool del_ref()
        {
            return Atomic::sub (ref, 1U) == 0;
ffffffff8100c026:	48 8d ab 8c 00 00 00 	lea    0x8c(%rbx),%rbp
ffffffff8100c02d:	48 c7 83 30 03 00 00 	movq   $0x0,0x330(%rbx)
ffffffff8100c034:	00 00 00 00 

    current->cont = C;
ffffffff8100c038:	48 c7 83 a0 00 00 00 	movq   $0xffffffff81018882,0xa0(%rbx)
ffffffff8100c03f:	82 88 01 81 
ffffffff8100c043:	f0 0f c1 45 00       	lock xadd %eax,0x0(%rbp)
        regs.ARG_3 = cnt;
    }

    ALWAYS_INLINE NORETURN
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
ffffffff8100c048:	ff c8                	dec    %eax
ffffffff8100c04a:	75 32                	jne    ffffffff8100c07e <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvv+0xc0>
            delete current;
ffffffff8100c04c:	4c 8b 25 b5 2f ff 3e 	mov    0x3eff2fb5(%rip),%r12        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100c053:	4d 85 e4             	test   %r12,%r12
ffffffff8100c056:	74 26                	je     ffffffff8100c07e <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvv+0xc0>
ffffffff8100c058:	4c 89 e7             	mov    %r12,%rdi
ffffffff8100c05b:	e8 dc 83 ff ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff8100c060:	49 8b 84 24 98 02 00 	mov    0x298(%r12),%rax
ffffffff8100c067:	00 
ffffffff8100c068:	4c 89 e6             	mov    %r12,%rsi
ffffffff8100c06b:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff8100c072:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff8100c079:	e8 ec 99 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
            delete current;
        }

        current = this;
ffffffff8100c07e:	48 89 1d 83 2f ff 3e 	mov    %rbx,0x3eff2f83(%rip)        # ffffffffbffff008 <_ZN2Ec7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100c085:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff8100c08b:	85 c0                	test   %eax,%eax
ffffffff8100c08d:	74 0a                	je     ffffffff8100c099 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvv+0xdb>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8100c08f:	8d 50 01             	lea    0x1(%rax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff8100c092:	f0 0f b1 55 00       	lock cmpxchg %edx,0x0(%rbp)
ffffffff8100c097:	75 ec                	jne    ffffffff8100c085 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvv+0xc7>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
ffffffff8100c099:	48 8b 93 98 02 00 00 	mov    0x298(%rbx),%rdx

        current->add_ref();

        Tss::run.sp0 = reinterpret_cast<mword> (exc_regs() + 1);
ffffffff8100c0a0:	48 8d 83 80 01 00 00 	lea    0x180(%rbx),%rax
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
ffffffff8100c0a7:	8b 0d 57 2f ff 3e    	mov    0x3eff2f57(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100c0ad:	48 89 05 18 3d ff 3e 	mov    %rax,0x3eff3d18(%rip)        # ffffffffbffffdcc <tss_run+0x4>
ffffffff8100c0b4:	48 8b 82 c8 02 00 00 	mov    0x2c8(%rdx),%rax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
ffffffff8100c0bb:	48 8b b2 b8 02 00 00 	mov    0x2b8(%rdx),%rsi

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
ffffffff8100c0c2:	48 0f a3 c8          	bt     %rcx,%rax
ffffffff8100c0c6:	73 14                	jae    ffffffff8100c0dc <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvv+0x11e>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
ffffffff8100c0c8:	48 c7 c0 fe ff ff ff 	mov    $0xfffffffffffffffe,%rax
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
ffffffff8100c0cf:	48 d3 c0             	rol    %cl,%rax
ffffffff8100c0d2:	f0 48 21 82 c8 02 00 	lock and %rax,0x2c8(%rdx)
ffffffff8100c0d9:	00 
ffffffff8100c0da:	eb 20                	jmp    ffffffff8100c0fc <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvv+0x13e>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
ffffffff8100c0dc:	48 39 15 2d 2f ff 3e 	cmp    %rdx,0x3eff2f2d(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100c0e3:	0f 84 e5 00 00 00    	je     ffffffff8100c1ce <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvv+0x210>
                    return;

                if (pcid != NO_PCID)
ffffffff8100c0e9:	48 83 fe 02          	cmp    $0x2,%rsi
ffffffff8100c0ed:	74 0d                	je     ffffffff8100c0fc <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvv+0x13e>
                    pcid |= static_cast<mword>(1ULL << 63);
ffffffff8100c0ef:	48 b8 00 00 00 00 00 	movabs $0x8000000000000000,%rax
ffffffff8100c0f6:	00 00 80 
ffffffff8100c0f9:	48 09 c6             	or     %rax,%rsi
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff8100c0fc:	48 8b 05 0d 2f ff 3e 	mov    0x3eff2f0d(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100c103:	83 c9 ff             	or     $0xffffffff,%ecx
ffffffff8100c106:	f0 0f c1 88 8c 00 00 	lock xadd %ecx,0x8c(%rax)
ffffffff8100c10d:	00 
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
ffffffff8100c10e:	83 f9 01             	cmp    $0x1,%ecx
ffffffff8100c111:	75 31                	jne    ffffffff8100c144 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvv+0x186>
                assert (current != this);
ffffffff8100c113:	48 8b 2d f6 2e ff 3e 	mov    0x3eff2ef6(%rip),%rbp        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100c11a:	48 39 d5             	cmp    %rdx,%rbp
ffffffff8100c11d:	75 27                	jne    ffffffff8100c146 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvv+0x188>
ffffffff8100c11f:	49 c7 c0 70 fb 01 81 	mov    $0xffffffff8101fb70,%r8
ffffffff8100c126:	b1 5e                	mov    $0x5e,%cl
ffffffff8100c128:	48 c7 c2 c7 e6 01 81 	mov    $0xffffffff8101e6c7,%rdx
ffffffff8100c12f:	48 c7 c6 35 e7 01 81 	mov    $0xffffffff8101e735,%rsi
ffffffff8100c136:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100c13d:	31 c0                	xor    %eax,%eax
ffffffff8100c13f:	e8 0c 5e ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
ffffffff8100c144:	31 ed                	xor    %ebp,%ebp
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
ffffffff8100c146:	48 89 15 c3 2e ff 3e 	mov    %rdx,0x3eff2ec3(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100c14d:	8b 82 8c 00 00 00    	mov    0x8c(%rdx),%eax
ffffffff8100c153:	85 c0                	test   %eax,%eax
ffffffff8100c155:	74 0d                	je     ffffffff8100c164 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvv+0x1a6>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8100c157:	8d 48 01             	lea    0x1(%rax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff8100c15a:	f0 0f b1 8a 8c 00 00 	lock cmpxchg %ecx,0x8c(%rdx)
ffffffff8100c161:	00 
ffffffff8100c162:	75 e9                	jne    ffffffff8100c14d <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvv+0x18f>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
ffffffff8100c164:	f6 05 db 35 ff 3e 02 	testb  $0x2,0x3eff35db(%rip)        # ffffffffbffff746 <_ZN3Cpu8featuresE+0x6>
ffffffff8100c16b:	8b 0d 93 2e ff 3e    	mov    0x3eff2e93(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100c171:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff8100c176:	48 0f 45 c6          	cmovne %rsi,%rax
ffffffff8100c17a:	48 0b 84 ca a0 00 00 	or     0xa0(%rdx,%rcx,8),%rax
ffffffff8100c181:	00 
ffffffff8100c182:	0f 22 d8             	mov    %rax,%cr3

            if (del_pd)
ffffffff8100c185:	48 85 ed             	test   %rbp,%rbp
ffffffff8100c188:	74 44                	je     ffffffff8100c1ce <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_10sys_lookupEvEEEEvv+0x210>
                delete del_pd;
ffffffff8100c18a:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100c18d:	e8 96 4e 00 00       	callq  ffffffff81011028 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff8100c192:	48 8b 45 50          	mov    0x50(%rbp),%rax
ffffffff8100c196:	31 d2                	xor    %edx,%edx

            pd_del->quota.free_up(pd_to->quota);
ffffffff8100c198:	48 8d bd 08 03 00 00 	lea    0x308(%rbp),%rdi

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff8100c19f:	48 8d 88 08 fd ff ff 	lea    -0x2f8(%rax),%rcx
ffffffff8100c1a6:	48 85 c0             	test   %rax,%rax
ffffffff8100c1a9:	48 0f 45 d1          	cmovne %rcx,%rdx

            pd_del->quota.free_up(pd_to->quota);
ffffffff8100c1ad:	4c 8d a2 08 03 00 00 	lea    0x308(%rdx),%r12
ffffffff8100c1b4:	4c 89 e6             	mov    %r12,%rsi
ffffffff8100c1b7:	e8 08 74 ff ff       	callq  ffffffff810035c4 <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
ffffffff8100c1bc:	4c 89 e2             	mov    %r12,%rdx
ffffffff8100c1bf:	48 89 ee             	mov    %rbp,%rsi
ffffffff8100c1c2:	48 c7 c7 d0 3f 16 81 	mov    $0xffffffff81163fd0,%rdi
ffffffff8100c1c9:	e8 9c 98 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>

        pd->make_current();

        asm volatile ("mov %0," EXPAND(PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory");
ffffffff8100c1ce:	48 8b 83 a0 00 00 00 	mov    0xa0(%rbx),%rax
ffffffff8100c1d5:	48 c7 c4 00 e0 ff bf 	mov    $0xffffffffbfffe000,%rsp
ffffffff8100c1dc:	ff e0                	jmpq   *%rax

ffffffff8100c1de <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvv>:
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
{
    assert (current->xcpu_sm);
ffffffff8100c1de:	48 8b 05 23 2e ff 3e 	mov    0x3eff2e23(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>

    Sc::schedule(true);
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
ffffffff8100c1e5:	41 54                	push   %r12
ffffffff8100c1e7:	55                   	push   %rbp
ffffffff8100c1e8:	53                   	push   %rbx
{
    assert (current->xcpu_sm);
ffffffff8100c1e9:	48 8b 98 30 03 00 00 	mov    0x330(%rax),%rbx
ffffffff8100c1f0:	48 85 db             	test   %rbx,%rbx
ffffffff8100c1f3:	75 1f                	jne    ffffffff8100c214 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvv+0x36>
ffffffff8100c1f5:	49 c7 c0 c0 f4 01 81 	mov    $0xffffffff8101f4c0,%r8
ffffffff8100c1fc:	b9 9b 00 00 00       	mov    $0x9b,%ecx
ffffffff8100c201:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100c208:	48 c7 c6 cc de 01 81 	mov    $0xffffffff8101decc,%rsi
ffffffff8100c20f:	e9 42 01 00 00       	jmpq   ffffffff8100c356 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvv+0x178>

    Sm::destroy(current->xcpu_sm, Pd::current->quota);
ffffffff8100c214:	48 8b 05 f5 2d ff 3e 	mov    0x3eff2df5(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100c21b:	48 89 df             	mov    %rbx,%rdi
ffffffff8100c21e:	48 8d a8 08 03 00 00 	lea    0x308(%rax),%rbp
ffffffff8100c225:	e8 96 f6 ff ff       	callq  ffffffff8100b8c0 <_ZN2SmD1Ev>
ffffffff8100c22a:	48 89 ea             	mov    %rbp,%rdx
ffffffff8100c22d:	48 89 de             	mov    %rbx,%rsi
ffffffff8100c230:	48 c7 c7 80 40 16 81 	mov    $0xffffffff81164080,%rdi
ffffffff8100c237:	e8 2e 98 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
    current->xcpu_sm = nullptr;
ffffffff8100c23c:	48 8b 1d c5 2d ff 3e 	mov    0x3eff2dc5(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff8100c243:	83 c8 ff             	or     $0xffffffff,%eax
        }

        ALWAYS_INLINE
        inline bool del_ref()
        {
            return Atomic::sub (ref, 1U) == 0;
ffffffff8100c246:	48 8d ab 8c 00 00 00 	lea    0x8c(%rbx),%rbp
ffffffff8100c24d:	48 c7 83 30 03 00 00 	movq   $0x0,0x330(%rbx)
ffffffff8100c254:	00 00 00 00 

    current->cont = C;
ffffffff8100c258:	48 c7 83 a0 00 00 00 	movq   $0xffffffff81018b16,0xa0(%rbx)
ffffffff8100c25f:	16 8b 01 81 
ffffffff8100c263:	f0 0f c1 45 00       	lock xadd %eax,0x0(%rbp)
        regs.ARG_3 = cnt;
    }

    ALWAYS_INLINE NORETURN
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
ffffffff8100c268:	ff c8                	dec    %eax
ffffffff8100c26a:	75 32                	jne    ffffffff8100c29e <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvv+0xc0>
            delete current;
ffffffff8100c26c:	4c 8b 25 95 2d ff 3e 	mov    0x3eff2d95(%rip),%r12        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100c273:	4d 85 e4             	test   %r12,%r12
ffffffff8100c276:	74 26                	je     ffffffff8100c29e <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvv+0xc0>
ffffffff8100c278:	4c 89 e7             	mov    %r12,%rdi
ffffffff8100c27b:	e8 bc 81 ff ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff8100c280:	49 8b 84 24 98 02 00 	mov    0x298(%r12),%rax
ffffffff8100c287:	00 
ffffffff8100c288:	4c 89 e6             	mov    %r12,%rsi
ffffffff8100c28b:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff8100c292:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff8100c299:	e8 cc 97 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
            delete current;
        }

        current = this;
ffffffff8100c29e:	48 89 1d 63 2d ff 3e 	mov    %rbx,0x3eff2d63(%rip)        # ffffffffbffff008 <_ZN2Ec7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100c2a5:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff8100c2ab:	85 c0                	test   %eax,%eax
ffffffff8100c2ad:	74 0a                	je     ffffffff8100c2b9 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvv+0xdb>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8100c2af:	8d 50 01             	lea    0x1(%rax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff8100c2b2:	f0 0f b1 55 00       	lock cmpxchg %edx,0x0(%rbp)
ffffffff8100c2b7:	75 ec                	jne    ffffffff8100c2a5 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvv+0xc7>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
ffffffff8100c2b9:	48 8b 93 98 02 00 00 	mov    0x298(%rbx),%rdx

        current->add_ref();

        Tss::run.sp0 = reinterpret_cast<mword> (exc_regs() + 1);
ffffffff8100c2c0:	48 8d 83 80 01 00 00 	lea    0x180(%rbx),%rax
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
ffffffff8100c2c7:	8b 0d 37 2d ff 3e    	mov    0x3eff2d37(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100c2cd:	48 89 05 f8 3a ff 3e 	mov    %rax,0x3eff3af8(%rip)        # ffffffffbffffdcc <tss_run+0x4>
ffffffff8100c2d4:	48 8b 82 c8 02 00 00 	mov    0x2c8(%rdx),%rax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
ffffffff8100c2db:	48 8b b2 b8 02 00 00 	mov    0x2b8(%rdx),%rsi

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
ffffffff8100c2e2:	48 0f a3 c8          	bt     %rcx,%rax
ffffffff8100c2e6:	73 14                	jae    ffffffff8100c2fc <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvv+0x11e>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
ffffffff8100c2e8:	48 c7 c0 fe ff ff ff 	mov    $0xfffffffffffffffe,%rax
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
ffffffff8100c2ef:	48 d3 c0             	rol    %cl,%rax
ffffffff8100c2f2:	f0 48 21 82 c8 02 00 	lock and %rax,0x2c8(%rdx)
ffffffff8100c2f9:	00 
ffffffff8100c2fa:	eb 20                	jmp    ffffffff8100c31c <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvv+0x13e>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
ffffffff8100c2fc:	48 39 15 0d 2d ff 3e 	cmp    %rdx,0x3eff2d0d(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100c303:	0f 84 e5 00 00 00    	je     ffffffff8100c3ee <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvv+0x210>
                    return;

                if (pcid != NO_PCID)
ffffffff8100c309:	48 83 fe 02          	cmp    $0x2,%rsi
ffffffff8100c30d:	74 0d                	je     ffffffff8100c31c <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvv+0x13e>
                    pcid |= static_cast<mword>(1ULL << 63);
ffffffff8100c30f:	48 b8 00 00 00 00 00 	movabs $0x8000000000000000,%rax
ffffffff8100c316:	00 00 80 
ffffffff8100c319:	48 09 c6             	or     %rax,%rsi
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff8100c31c:	48 8b 05 ed 2c ff 3e 	mov    0x3eff2ced(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100c323:	83 c9 ff             	or     $0xffffffff,%ecx
ffffffff8100c326:	f0 0f c1 88 8c 00 00 	lock xadd %ecx,0x8c(%rax)
ffffffff8100c32d:	00 
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
ffffffff8100c32e:	83 f9 01             	cmp    $0x1,%ecx
ffffffff8100c331:	75 31                	jne    ffffffff8100c364 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvv+0x186>
                assert (current != this);
ffffffff8100c333:	48 8b 2d d6 2c ff 3e 	mov    0x3eff2cd6(%rip),%rbp        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100c33a:	48 39 d5             	cmp    %rdx,%rbp
ffffffff8100c33d:	75 27                	jne    ffffffff8100c366 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvv+0x188>
ffffffff8100c33f:	49 c7 c0 70 fb 01 81 	mov    $0xffffffff8101fb70,%r8
ffffffff8100c346:	b1 5e                	mov    $0x5e,%cl
ffffffff8100c348:	48 c7 c2 c7 e6 01 81 	mov    $0xffffffff8101e6c7,%rdx
ffffffff8100c34f:	48 c7 c6 35 e7 01 81 	mov    $0xffffffff8101e735,%rsi
ffffffff8100c356:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100c35d:	31 c0                	xor    %eax,%eax
ffffffff8100c35f:	e8 ec 5b ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
ffffffff8100c364:	31 ed                	xor    %ebp,%ebp
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
ffffffff8100c366:	48 89 15 a3 2c ff 3e 	mov    %rdx,0x3eff2ca3(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100c36d:	8b 82 8c 00 00 00    	mov    0x8c(%rdx),%eax
ffffffff8100c373:	85 c0                	test   %eax,%eax
ffffffff8100c375:	74 0d                	je     ffffffff8100c384 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvv+0x1a6>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8100c377:	8d 48 01             	lea    0x1(%rax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff8100c37a:	f0 0f b1 8a 8c 00 00 	lock cmpxchg %ecx,0x8c(%rdx)
ffffffff8100c381:	00 
ffffffff8100c382:	75 e9                	jne    ffffffff8100c36d <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvv+0x18f>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
ffffffff8100c384:	f6 05 bb 33 ff 3e 02 	testb  $0x2,0x3eff33bb(%rip)        # ffffffffbffff746 <_ZN3Cpu8featuresE+0x6>
ffffffff8100c38b:	8b 0d 73 2c ff 3e    	mov    0x3eff2c73(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100c391:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff8100c396:	48 0f 45 c6          	cmovne %rsi,%rax
ffffffff8100c39a:	48 0b 84 ca a0 00 00 	or     0xa0(%rdx,%rcx,8),%rax
ffffffff8100c3a1:	00 
ffffffff8100c3a2:	0f 22 d8             	mov    %rax,%cr3

            if (del_pd)
ffffffff8100c3a5:	48 85 ed             	test   %rbp,%rbp
ffffffff8100c3a8:	74 44                	je     ffffffff8100c3ee <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvv+0x210>
                delete del_pd;
ffffffff8100c3aa:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100c3ad:	e8 76 4c 00 00       	callq  ffffffff81011028 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff8100c3b2:	48 8b 45 50          	mov    0x50(%rbp),%rax
ffffffff8100c3b6:	31 d2                	xor    %edx,%edx

            pd_del->quota.free_up(pd_to->quota);
ffffffff8100c3b8:	48 8d bd 08 03 00 00 	lea    0x308(%rbp),%rdi

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff8100c3bf:	48 8d 88 08 fd ff ff 	lea    -0x2f8(%rax),%rcx
ffffffff8100c3c6:	48 85 c0             	test   %rax,%rax
ffffffff8100c3c9:	48 0f 45 d1          	cmovne %rcx,%rdx

            pd_del->quota.free_up(pd_to->quota);
ffffffff8100c3cd:	4c 8d a2 08 03 00 00 	lea    0x308(%rdx),%r12
ffffffff8100c3d4:	4c 89 e6             	mov    %r12,%rsi
ffffffff8100c3d7:	e8 e8 71 ff ff       	callq  ffffffff810035c4 <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
ffffffff8100c3dc:	4c 89 e2             	mov    %r12,%rdx
ffffffff8100c3df:	48 89 ee             	mov    %rbp,%rsi
ffffffff8100c3e2:	48 c7 c7 d0 3f 16 81 	mov    $0xffffffff81163fd0,%rdi
ffffffff8100c3e9:	e8 7c 96 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>

        pd->make_current();

        asm volatile ("mov %0," EXPAND(PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory");
ffffffff8100c3ee:	48 8b 83 a0 00 00 00 	mov    0xa0(%rbx),%rax
ffffffff8100c3f5:	48 c7 c4 00 e0 ff bf 	mov    $0xffffffffbfffe000,%rsp
ffffffff8100c3fc:	ff e0                	jmpq   *%rax

ffffffff8100c3fe <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvv>:
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
{
    assert (current->xcpu_sm);
ffffffff8100c3fe:	48 8b 05 03 2c ff 3e 	mov    0x3eff2c03(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>

    Sc::schedule(true);
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
ffffffff8100c405:	41 54                	push   %r12
ffffffff8100c407:	55                   	push   %rbp
ffffffff8100c408:	53                   	push   %rbx
{
    assert (current->xcpu_sm);
ffffffff8100c409:	48 8b 98 30 03 00 00 	mov    0x330(%rax),%rbx
ffffffff8100c410:	48 85 db             	test   %rbx,%rbx
ffffffff8100c413:	75 1f                	jne    ffffffff8100c434 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvv+0x36>
ffffffff8100c415:	49 c7 c0 c0 f2 01 81 	mov    $0xffffffff8101f2c0,%r8
ffffffff8100c41c:	b9 9b 00 00 00       	mov    $0x9b,%ecx
ffffffff8100c421:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100c428:	48 c7 c6 cc de 01 81 	mov    $0xffffffff8101decc,%rsi
ffffffff8100c42f:	e9 42 01 00 00       	jmpq   ffffffff8100c576 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvv+0x178>

    Sm::destroy(current->xcpu_sm, Pd::current->quota);
ffffffff8100c434:	48 8b 05 d5 2b ff 3e 	mov    0x3eff2bd5(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100c43b:	48 89 df             	mov    %rbx,%rdi
ffffffff8100c43e:	48 8d a8 08 03 00 00 	lea    0x308(%rax),%rbp
ffffffff8100c445:	e8 76 f4 ff ff       	callq  ffffffff8100b8c0 <_ZN2SmD1Ev>
ffffffff8100c44a:	48 89 ea             	mov    %rbp,%rdx
ffffffff8100c44d:	48 89 de             	mov    %rbx,%rsi
ffffffff8100c450:	48 c7 c7 80 40 16 81 	mov    $0xffffffff81164080,%rdi
ffffffff8100c457:	e8 0e 96 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
    current->xcpu_sm = nullptr;
ffffffff8100c45c:	48 8b 1d a5 2b ff 3e 	mov    0x3eff2ba5(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff8100c463:	83 c8 ff             	or     $0xffffffff,%eax
        }

        ALWAYS_INLINE
        inline bool del_ref()
        {
            return Atomic::sub (ref, 1U) == 0;
ffffffff8100c466:	48 8d ab 8c 00 00 00 	lea    0x8c(%rbx),%rbp
ffffffff8100c46d:	48 c7 83 30 03 00 00 	movq   $0x0,0x330(%rbx)
ffffffff8100c474:	00 00 00 00 

    current->cont = C;
ffffffff8100c478:	48 c7 83 a0 00 00 00 	movq   $0xffffffff8101983c,0xa0(%rbx)
ffffffff8100c47f:	3c 98 01 81 
ffffffff8100c483:	f0 0f c1 45 00       	lock xadd %eax,0x0(%rbp)
        regs.ARG_3 = cnt;
    }

    ALWAYS_INLINE NORETURN
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
ffffffff8100c488:	ff c8                	dec    %eax
ffffffff8100c48a:	75 32                	jne    ffffffff8100c4be <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvv+0xc0>
            delete current;
ffffffff8100c48c:	4c 8b 25 75 2b ff 3e 	mov    0x3eff2b75(%rip),%r12        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100c493:	4d 85 e4             	test   %r12,%r12
ffffffff8100c496:	74 26                	je     ffffffff8100c4be <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvv+0xc0>
ffffffff8100c498:	4c 89 e7             	mov    %r12,%rdi
ffffffff8100c49b:	e8 9c 7f ff ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff8100c4a0:	49 8b 84 24 98 02 00 	mov    0x298(%r12),%rax
ffffffff8100c4a7:	00 
ffffffff8100c4a8:	4c 89 e6             	mov    %r12,%rsi
ffffffff8100c4ab:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff8100c4b2:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff8100c4b9:	e8 ac 95 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
            delete current;
        }

        current = this;
ffffffff8100c4be:	48 89 1d 43 2b ff 3e 	mov    %rbx,0x3eff2b43(%rip)        # ffffffffbffff008 <_ZN2Ec7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100c4c5:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff8100c4cb:	85 c0                	test   %eax,%eax
ffffffff8100c4cd:	74 0a                	je     ffffffff8100c4d9 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvv+0xdb>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8100c4cf:	8d 50 01             	lea    0x1(%rax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff8100c4d2:	f0 0f b1 55 00       	lock cmpxchg %edx,0x0(%rbp)
ffffffff8100c4d7:	75 ec                	jne    ffffffff8100c4c5 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvv+0xc7>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
ffffffff8100c4d9:	48 8b 93 98 02 00 00 	mov    0x298(%rbx),%rdx

        current->add_ref();

        Tss::run.sp0 = reinterpret_cast<mword> (exc_regs() + 1);
ffffffff8100c4e0:	48 8d 83 80 01 00 00 	lea    0x180(%rbx),%rax
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
ffffffff8100c4e7:	8b 0d 17 2b ff 3e    	mov    0x3eff2b17(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100c4ed:	48 89 05 d8 38 ff 3e 	mov    %rax,0x3eff38d8(%rip)        # ffffffffbffffdcc <tss_run+0x4>
ffffffff8100c4f4:	48 8b 82 c8 02 00 00 	mov    0x2c8(%rdx),%rax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
ffffffff8100c4fb:	48 8b b2 b8 02 00 00 	mov    0x2b8(%rdx),%rsi

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
ffffffff8100c502:	48 0f a3 c8          	bt     %rcx,%rax
ffffffff8100c506:	73 14                	jae    ffffffff8100c51c <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvv+0x11e>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
ffffffff8100c508:	48 c7 c0 fe ff ff ff 	mov    $0xfffffffffffffffe,%rax
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
ffffffff8100c50f:	48 d3 c0             	rol    %cl,%rax
ffffffff8100c512:	f0 48 21 82 c8 02 00 	lock and %rax,0x2c8(%rdx)
ffffffff8100c519:	00 
ffffffff8100c51a:	eb 20                	jmp    ffffffff8100c53c <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvv+0x13e>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
ffffffff8100c51c:	48 39 15 ed 2a ff 3e 	cmp    %rdx,0x3eff2aed(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100c523:	0f 84 e5 00 00 00    	je     ffffffff8100c60e <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvv+0x210>
                    return;

                if (pcid != NO_PCID)
ffffffff8100c529:	48 83 fe 02          	cmp    $0x2,%rsi
ffffffff8100c52d:	74 0d                	je     ffffffff8100c53c <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvv+0x13e>
                    pcid |= static_cast<mword>(1ULL << 63);
ffffffff8100c52f:	48 b8 00 00 00 00 00 	movabs $0x8000000000000000,%rax
ffffffff8100c536:	00 00 80 
ffffffff8100c539:	48 09 c6             	or     %rax,%rsi
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff8100c53c:	48 8b 05 cd 2a ff 3e 	mov    0x3eff2acd(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100c543:	83 c9 ff             	or     $0xffffffff,%ecx
ffffffff8100c546:	f0 0f c1 88 8c 00 00 	lock xadd %ecx,0x8c(%rax)
ffffffff8100c54d:	00 
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
ffffffff8100c54e:	83 f9 01             	cmp    $0x1,%ecx
ffffffff8100c551:	75 31                	jne    ffffffff8100c584 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvv+0x186>
                assert (current != this);
ffffffff8100c553:	48 8b 2d b6 2a ff 3e 	mov    0x3eff2ab6(%rip),%rbp        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100c55a:	48 39 d5             	cmp    %rdx,%rbp
ffffffff8100c55d:	75 27                	jne    ffffffff8100c586 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvv+0x188>
ffffffff8100c55f:	49 c7 c0 70 fb 01 81 	mov    $0xffffffff8101fb70,%r8
ffffffff8100c566:	b1 5e                	mov    $0x5e,%cl
ffffffff8100c568:	48 c7 c2 c7 e6 01 81 	mov    $0xffffffff8101e6c7,%rdx
ffffffff8100c56f:	48 c7 c6 35 e7 01 81 	mov    $0xffffffff8101e735,%rsi
ffffffff8100c576:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100c57d:	31 c0                	xor    %eax,%eax
ffffffff8100c57f:	e8 cc 59 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
ffffffff8100c584:	31 ed                	xor    %ebp,%ebp
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
ffffffff8100c586:	48 89 15 83 2a ff 3e 	mov    %rdx,0x3eff2a83(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100c58d:	8b 82 8c 00 00 00    	mov    0x8c(%rdx),%eax
ffffffff8100c593:	85 c0                	test   %eax,%eax
ffffffff8100c595:	74 0d                	je     ffffffff8100c5a4 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvv+0x1a6>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8100c597:	8d 48 01             	lea    0x1(%rax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff8100c59a:	f0 0f b1 8a 8c 00 00 	lock cmpxchg %ecx,0x8c(%rdx)
ffffffff8100c5a1:	00 
ffffffff8100c5a2:	75 e9                	jne    ffffffff8100c58d <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvv+0x18f>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
ffffffff8100c5a4:	f6 05 9b 31 ff 3e 02 	testb  $0x2,0x3eff319b(%rip)        # ffffffffbffff746 <_ZN3Cpu8featuresE+0x6>
ffffffff8100c5ab:	8b 0d 53 2a ff 3e    	mov    0x3eff2a53(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100c5b1:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff8100c5b6:	48 0f 45 c6          	cmovne %rsi,%rax
ffffffff8100c5ba:	48 0b 84 ca a0 00 00 	or     0xa0(%rdx,%rcx,8),%rax
ffffffff8100c5c1:	00 
ffffffff8100c5c2:	0f 22 d8             	mov    %rax,%cr3

            if (del_pd)
ffffffff8100c5c5:	48 85 ed             	test   %rbp,%rbp
ffffffff8100c5c8:	74 44                	je     ffffffff8100c60e <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvv+0x210>
                delete del_pd;
ffffffff8100c5ca:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100c5cd:	e8 56 4a 00 00       	callq  ffffffff81011028 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff8100c5d2:	48 8b 45 50          	mov    0x50(%rbp),%rax
ffffffff8100c5d6:	31 d2                	xor    %edx,%edx

            pd_del->quota.free_up(pd_to->quota);
ffffffff8100c5d8:	48 8d bd 08 03 00 00 	lea    0x308(%rbp),%rdi

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff8100c5df:	48 8d 88 08 fd ff ff 	lea    -0x2f8(%rax),%rcx
ffffffff8100c5e6:	48 85 c0             	test   %rax,%rax
ffffffff8100c5e9:	48 0f 45 d1          	cmovne %rcx,%rdx

            pd_del->quota.free_up(pd_to->quota);
ffffffff8100c5ed:	4c 8d a2 08 03 00 00 	lea    0x308(%rdx),%r12
ffffffff8100c5f4:	4c 89 e6             	mov    %r12,%rsi
ffffffff8100c5f7:	e8 c8 6f ff ff       	callq  ffffffff810035c4 <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
ffffffff8100c5fc:	4c 89 e2             	mov    %r12,%rdx
ffffffff8100c5ff:	48 89 ee             	mov    %rbp,%rsi
ffffffff8100c602:	48 c7 c7 d0 3f 16 81 	mov    $0xffffffff81163fd0,%rdi
ffffffff8100c609:	e8 5c 94 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>

        pd->make_current();

        asm volatile ("mov %0," EXPAND(PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory");
ffffffff8100c60e:	48 8b 83 a0 00 00 00 	mov    0xa0(%rbx),%rax
ffffffff8100c615:	48 c7 c4 00 e0 ff bf 	mov    $0xffffffffbfffe000,%rsp
ffffffff8100c61c:	ff e0                	jmpq   *%rax

ffffffff8100c61e <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvv>:
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
{
    assert (current->xcpu_sm);
ffffffff8100c61e:	48 8b 05 e3 29 ff 3e 	mov    0x3eff29e3(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>

    Sc::schedule(true);
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
ffffffff8100c625:	41 54                	push   %r12
ffffffff8100c627:	55                   	push   %rbp
ffffffff8100c628:	53                   	push   %rbx
{
    assert (current->xcpu_sm);
ffffffff8100c629:	48 8b 98 30 03 00 00 	mov    0x330(%rax),%rbx
ffffffff8100c630:	48 85 db             	test   %rbx,%rbx
ffffffff8100c633:	75 1f                	jne    ffffffff8100c654 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvv+0x36>
ffffffff8100c635:	49 c7 c0 c0 f0 01 81 	mov    $0xffffffff8101f0c0,%r8
ffffffff8100c63c:	b9 9b 00 00 00       	mov    $0x9b,%ecx
ffffffff8100c641:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100c648:	48 c7 c6 cc de 01 81 	mov    $0xffffffff8101decc,%rsi
ffffffff8100c64f:	e9 42 01 00 00       	jmpq   ffffffff8100c796 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvv+0x178>

    Sm::destroy(current->xcpu_sm, Pd::current->quota);
ffffffff8100c654:	48 8b 05 b5 29 ff 3e 	mov    0x3eff29b5(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100c65b:	48 89 df             	mov    %rbx,%rdi
ffffffff8100c65e:	48 8d a8 08 03 00 00 	lea    0x308(%rax),%rbp
ffffffff8100c665:	e8 56 f2 ff ff       	callq  ffffffff8100b8c0 <_ZN2SmD1Ev>
ffffffff8100c66a:	48 89 ea             	mov    %rbp,%rdx
ffffffff8100c66d:	48 89 de             	mov    %rbx,%rsi
ffffffff8100c670:	48 c7 c7 80 40 16 81 	mov    $0xffffffff81164080,%rdi
ffffffff8100c677:	e8 ee 93 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
    current->xcpu_sm = nullptr;
ffffffff8100c67c:	48 8b 1d 85 29 ff 3e 	mov    0x3eff2985(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff8100c683:	83 c8 ff             	or     $0xffffffff,%eax
        }

        ALWAYS_INLINE
        inline bool del_ref()
        {
            return Atomic::sub (ref, 1U) == 0;
ffffffff8100c686:	48 8d ab 8c 00 00 00 	lea    0x8c(%rbx),%rbp
ffffffff8100c68d:	48 c7 83 30 03 00 00 	movq   $0x0,0x330(%rbx)
ffffffff8100c694:	00 00 00 00 

    current->cont = C;
ffffffff8100c698:	48 c7 83 a0 00 00 00 	movq   $0xffffffff81018962,0xa0(%rbx)
ffffffff8100c69f:	62 89 01 81 
ffffffff8100c6a3:	f0 0f c1 45 00       	lock xadd %eax,0x0(%rbp)
        regs.ARG_3 = cnt;
    }

    ALWAYS_INLINE NORETURN
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
ffffffff8100c6a8:	ff c8                	dec    %eax
ffffffff8100c6aa:	75 32                	jne    ffffffff8100c6de <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvv+0xc0>
            delete current;
ffffffff8100c6ac:	4c 8b 25 55 29 ff 3e 	mov    0x3eff2955(%rip),%r12        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100c6b3:	4d 85 e4             	test   %r12,%r12
ffffffff8100c6b6:	74 26                	je     ffffffff8100c6de <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvv+0xc0>
ffffffff8100c6b8:	4c 89 e7             	mov    %r12,%rdi
ffffffff8100c6bb:	e8 7c 7d ff ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff8100c6c0:	49 8b 84 24 98 02 00 	mov    0x298(%r12),%rax
ffffffff8100c6c7:	00 
ffffffff8100c6c8:	4c 89 e6             	mov    %r12,%rsi
ffffffff8100c6cb:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff8100c6d2:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff8100c6d9:	e8 8c 93 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
            delete current;
        }

        current = this;
ffffffff8100c6de:	48 89 1d 23 29 ff 3e 	mov    %rbx,0x3eff2923(%rip)        # ffffffffbffff008 <_ZN2Ec7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100c6e5:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff8100c6eb:	85 c0                	test   %eax,%eax
ffffffff8100c6ed:	74 0a                	je     ffffffff8100c6f9 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvv+0xdb>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8100c6ef:	8d 50 01             	lea    0x1(%rax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff8100c6f2:	f0 0f b1 55 00       	lock cmpxchg %edx,0x0(%rbp)
ffffffff8100c6f7:	75 ec                	jne    ffffffff8100c6e5 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvv+0xc7>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
ffffffff8100c6f9:	48 8b 93 98 02 00 00 	mov    0x298(%rbx),%rdx

        current->add_ref();

        Tss::run.sp0 = reinterpret_cast<mword> (exc_regs() + 1);
ffffffff8100c700:	48 8d 83 80 01 00 00 	lea    0x180(%rbx),%rax
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
ffffffff8100c707:	8b 0d f7 28 ff 3e    	mov    0x3eff28f7(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100c70d:	48 89 05 b8 36 ff 3e 	mov    %rax,0x3eff36b8(%rip)        # ffffffffbffffdcc <tss_run+0x4>
ffffffff8100c714:	48 8b 82 c8 02 00 00 	mov    0x2c8(%rdx),%rax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
ffffffff8100c71b:	48 8b b2 b8 02 00 00 	mov    0x2b8(%rdx),%rsi

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
ffffffff8100c722:	48 0f a3 c8          	bt     %rcx,%rax
ffffffff8100c726:	73 14                	jae    ffffffff8100c73c <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvv+0x11e>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
ffffffff8100c728:	48 c7 c0 fe ff ff ff 	mov    $0xfffffffffffffffe,%rax
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
ffffffff8100c72f:	48 d3 c0             	rol    %cl,%rax
ffffffff8100c732:	f0 48 21 82 c8 02 00 	lock and %rax,0x2c8(%rdx)
ffffffff8100c739:	00 
ffffffff8100c73a:	eb 20                	jmp    ffffffff8100c75c <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvv+0x13e>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
ffffffff8100c73c:	48 39 15 cd 28 ff 3e 	cmp    %rdx,0x3eff28cd(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100c743:	0f 84 e5 00 00 00    	je     ffffffff8100c82e <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvv+0x210>
                    return;

                if (pcid != NO_PCID)
ffffffff8100c749:	48 83 fe 02          	cmp    $0x2,%rsi
ffffffff8100c74d:	74 0d                	je     ffffffff8100c75c <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvv+0x13e>
                    pcid |= static_cast<mword>(1ULL << 63);
ffffffff8100c74f:	48 b8 00 00 00 00 00 	movabs $0x8000000000000000,%rax
ffffffff8100c756:	00 00 80 
ffffffff8100c759:	48 09 c6             	or     %rax,%rsi
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff8100c75c:	48 8b 05 ad 28 ff 3e 	mov    0x3eff28ad(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100c763:	83 c9 ff             	or     $0xffffffff,%ecx
ffffffff8100c766:	f0 0f c1 88 8c 00 00 	lock xadd %ecx,0x8c(%rax)
ffffffff8100c76d:	00 
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
ffffffff8100c76e:	83 f9 01             	cmp    $0x1,%ecx
ffffffff8100c771:	75 31                	jne    ffffffff8100c7a4 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvv+0x186>
                assert (current != this);
ffffffff8100c773:	48 8b 2d 96 28 ff 3e 	mov    0x3eff2896(%rip),%rbp        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100c77a:	48 39 d5             	cmp    %rdx,%rbp
ffffffff8100c77d:	75 27                	jne    ffffffff8100c7a6 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvv+0x188>
ffffffff8100c77f:	49 c7 c0 70 fb 01 81 	mov    $0xffffffff8101fb70,%r8
ffffffff8100c786:	b1 5e                	mov    $0x5e,%cl
ffffffff8100c788:	48 c7 c2 c7 e6 01 81 	mov    $0xffffffff8101e6c7,%rdx
ffffffff8100c78f:	48 c7 c6 35 e7 01 81 	mov    $0xffffffff8101e735,%rsi
ffffffff8100c796:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100c79d:	31 c0                	xor    %eax,%eax
ffffffff8100c79f:	e8 ac 57 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
ffffffff8100c7a4:	31 ed                	xor    %ebp,%ebp
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
ffffffff8100c7a6:	48 89 15 63 28 ff 3e 	mov    %rdx,0x3eff2863(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100c7ad:	8b 82 8c 00 00 00    	mov    0x8c(%rdx),%eax
ffffffff8100c7b3:	85 c0                	test   %eax,%eax
ffffffff8100c7b5:	74 0d                	je     ffffffff8100c7c4 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvv+0x1a6>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8100c7b7:	8d 48 01             	lea    0x1(%rax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff8100c7ba:	f0 0f b1 8a 8c 00 00 	lock cmpxchg %ecx,0x8c(%rdx)
ffffffff8100c7c1:	00 
ffffffff8100c7c2:	75 e9                	jne    ffffffff8100c7ad <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvv+0x18f>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
ffffffff8100c7c4:	f6 05 7b 2f ff 3e 02 	testb  $0x2,0x3eff2f7b(%rip)        # ffffffffbffff746 <_ZN3Cpu8featuresE+0x6>
ffffffff8100c7cb:	8b 0d 33 28 ff 3e    	mov    0x3eff2833(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100c7d1:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff8100c7d6:	48 0f 45 c6          	cmovne %rsi,%rax
ffffffff8100c7da:	48 0b 84 ca a0 00 00 	or     0xa0(%rdx,%rcx,8),%rax
ffffffff8100c7e1:	00 
ffffffff8100c7e2:	0f 22 d8             	mov    %rax,%cr3

            if (del_pd)
ffffffff8100c7e5:	48 85 ed             	test   %rbp,%rbp
ffffffff8100c7e8:	74 44                	je     ffffffff8100c82e <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvv+0x210>
                delete del_pd;
ffffffff8100c7ea:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100c7ed:	e8 36 48 00 00       	callq  ffffffff81011028 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff8100c7f2:	48 8b 45 50          	mov    0x50(%rbp),%rax
ffffffff8100c7f6:	31 d2                	xor    %edx,%edx

            pd_del->quota.free_up(pd_to->quota);
ffffffff8100c7f8:	48 8d bd 08 03 00 00 	lea    0x308(%rbp),%rdi

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff8100c7ff:	48 8d 88 08 fd ff ff 	lea    -0x2f8(%rax),%rcx
ffffffff8100c806:	48 85 c0             	test   %rax,%rax
ffffffff8100c809:	48 0f 45 d1          	cmovne %rcx,%rdx

            pd_del->quota.free_up(pd_to->quota);
ffffffff8100c80d:	4c 8d a2 08 03 00 00 	lea    0x308(%rdx),%r12
ffffffff8100c814:	4c 89 e6             	mov    %r12,%rsi
ffffffff8100c817:	e8 a8 6d ff ff       	callq  ffffffff810035c4 <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
ffffffff8100c81c:	4c 89 e2             	mov    %r12,%rdx
ffffffff8100c81f:	48 89 ee             	mov    %rbp,%rsi
ffffffff8100c822:	48 c7 c7 d0 3f 16 81 	mov    $0xffffffff81163fd0,%rdi
ffffffff8100c829:	e8 3c 92 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>

        pd->make_current();

        asm volatile ("mov %0," EXPAND(PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory");
ffffffff8100c82e:	48 8b 83 a0 00 00 00 	mov    0xa0(%rbx),%rax
ffffffff8100c835:	48 c7 c4 00 e0 ff bf 	mov    $0xffffffffbfffe000,%rsp
ffffffff8100c83c:	ff e0                	jmpq   *%rax

ffffffff8100c83e <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvv>:
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
{
    assert (current->xcpu_sm);
ffffffff8100c83e:	48 8b 05 c3 27 ff 3e 	mov    0x3eff27c3(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>

    Sc::schedule(true);
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
ffffffff8100c845:	41 54                	push   %r12
ffffffff8100c847:	55                   	push   %rbp
ffffffff8100c848:	53                   	push   %rbx
{
    assert (current->xcpu_sm);
ffffffff8100c849:	48 8b 98 30 03 00 00 	mov    0x330(%rax),%rbx
ffffffff8100c850:	48 85 db             	test   %rbx,%rbx
ffffffff8100c853:	75 1f                	jne    ffffffff8100c874 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvv+0x36>
ffffffff8100c855:	49 c7 c0 c0 ee 01 81 	mov    $0xffffffff8101eec0,%r8
ffffffff8100c85c:	b9 9b 00 00 00       	mov    $0x9b,%ecx
ffffffff8100c861:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100c868:	48 c7 c6 cc de 01 81 	mov    $0xffffffff8101decc,%rsi
ffffffff8100c86f:	e9 42 01 00 00       	jmpq   ffffffff8100c9b6 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvv+0x178>

    Sm::destroy(current->xcpu_sm, Pd::current->quota);
ffffffff8100c874:	48 8b 05 95 27 ff 3e 	mov    0x3eff2795(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100c87b:	48 89 df             	mov    %rbx,%rdi
ffffffff8100c87e:	48 8d a8 08 03 00 00 	lea    0x308(%rax),%rbp
ffffffff8100c885:	e8 36 f0 ff ff       	callq  ffffffff8100b8c0 <_ZN2SmD1Ev>
ffffffff8100c88a:	48 89 ea             	mov    %rbp,%rdx
ffffffff8100c88d:	48 89 de             	mov    %rbx,%rsi
ffffffff8100c890:	48 c7 c7 80 40 16 81 	mov    $0xffffffff81164080,%rdi
ffffffff8100c897:	e8 ce 91 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
    current->xcpu_sm = nullptr;
ffffffff8100c89c:	48 8b 1d 65 27 ff 3e 	mov    0x3eff2765(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff8100c8a3:	83 c8 ff             	or     $0xffffffff,%eax
        }

        ALWAYS_INLINE
        inline bool del_ref()
        {
            return Atomic::sub (ref, 1U) == 0;
ffffffff8100c8a6:	48 8d ab 8c 00 00 00 	lea    0x8c(%rbx),%rbp
ffffffff8100c8ad:	48 c7 83 30 03 00 00 	movq   $0x0,0x330(%rbx)
ffffffff8100c8b4:	00 00 00 00 

    current->cont = C;
ffffffff8100c8b8:	48 c7 83 a0 00 00 00 	movq   $0xffffffff81018a4a,0xa0(%rbx)
ffffffff8100c8bf:	4a 8a 01 81 
ffffffff8100c8c3:	f0 0f c1 45 00       	lock xadd %eax,0x0(%rbp)
        regs.ARG_3 = cnt;
    }

    ALWAYS_INLINE NORETURN
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
ffffffff8100c8c8:	ff c8                	dec    %eax
ffffffff8100c8ca:	75 32                	jne    ffffffff8100c8fe <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvv+0xc0>
            delete current;
ffffffff8100c8cc:	4c 8b 25 35 27 ff 3e 	mov    0x3eff2735(%rip),%r12        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100c8d3:	4d 85 e4             	test   %r12,%r12
ffffffff8100c8d6:	74 26                	je     ffffffff8100c8fe <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvv+0xc0>
ffffffff8100c8d8:	4c 89 e7             	mov    %r12,%rdi
ffffffff8100c8db:	e8 5c 7b ff ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff8100c8e0:	49 8b 84 24 98 02 00 	mov    0x298(%r12),%rax
ffffffff8100c8e7:	00 
ffffffff8100c8e8:	4c 89 e6             	mov    %r12,%rsi
ffffffff8100c8eb:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff8100c8f2:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff8100c8f9:	e8 6c 91 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
            delete current;
        }

        current = this;
ffffffff8100c8fe:	48 89 1d 03 27 ff 3e 	mov    %rbx,0x3eff2703(%rip)        # ffffffffbffff008 <_ZN2Ec7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100c905:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff8100c90b:	85 c0                	test   %eax,%eax
ffffffff8100c90d:	74 0a                	je     ffffffff8100c919 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvv+0xdb>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8100c90f:	8d 50 01             	lea    0x1(%rax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff8100c912:	f0 0f b1 55 00       	lock cmpxchg %edx,0x0(%rbp)
ffffffff8100c917:	75 ec                	jne    ffffffff8100c905 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvv+0xc7>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
ffffffff8100c919:	48 8b 93 98 02 00 00 	mov    0x298(%rbx),%rdx

        current->add_ref();

        Tss::run.sp0 = reinterpret_cast<mword> (exc_regs() + 1);
ffffffff8100c920:	48 8d 83 80 01 00 00 	lea    0x180(%rbx),%rax
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
ffffffff8100c927:	8b 0d d7 26 ff 3e    	mov    0x3eff26d7(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100c92d:	48 89 05 98 34 ff 3e 	mov    %rax,0x3eff3498(%rip)        # ffffffffbffffdcc <tss_run+0x4>
ffffffff8100c934:	48 8b 82 c8 02 00 00 	mov    0x2c8(%rdx),%rax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
ffffffff8100c93b:	48 8b b2 b8 02 00 00 	mov    0x2b8(%rdx),%rsi

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
ffffffff8100c942:	48 0f a3 c8          	bt     %rcx,%rax
ffffffff8100c946:	73 14                	jae    ffffffff8100c95c <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvv+0x11e>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
ffffffff8100c948:	48 c7 c0 fe ff ff ff 	mov    $0xfffffffffffffffe,%rax
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
ffffffff8100c94f:	48 d3 c0             	rol    %cl,%rax
ffffffff8100c952:	f0 48 21 82 c8 02 00 	lock and %rax,0x2c8(%rdx)
ffffffff8100c959:	00 
ffffffff8100c95a:	eb 20                	jmp    ffffffff8100c97c <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvv+0x13e>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
ffffffff8100c95c:	48 39 15 ad 26 ff 3e 	cmp    %rdx,0x3eff26ad(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100c963:	0f 84 e5 00 00 00    	je     ffffffff8100ca4e <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvv+0x210>
                    return;

                if (pcid != NO_PCID)
ffffffff8100c969:	48 83 fe 02          	cmp    $0x2,%rsi
ffffffff8100c96d:	74 0d                	je     ffffffff8100c97c <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvv+0x13e>
                    pcid |= static_cast<mword>(1ULL << 63);
ffffffff8100c96f:	48 b8 00 00 00 00 00 	movabs $0x8000000000000000,%rax
ffffffff8100c976:	00 00 80 
ffffffff8100c979:	48 09 c6             	or     %rax,%rsi
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff8100c97c:	48 8b 05 8d 26 ff 3e 	mov    0x3eff268d(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100c983:	83 c9 ff             	or     $0xffffffff,%ecx
ffffffff8100c986:	f0 0f c1 88 8c 00 00 	lock xadd %ecx,0x8c(%rax)
ffffffff8100c98d:	00 
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
ffffffff8100c98e:	83 f9 01             	cmp    $0x1,%ecx
ffffffff8100c991:	75 31                	jne    ffffffff8100c9c4 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvv+0x186>
                assert (current != this);
ffffffff8100c993:	48 8b 2d 76 26 ff 3e 	mov    0x3eff2676(%rip),%rbp        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100c99a:	48 39 d5             	cmp    %rdx,%rbp
ffffffff8100c99d:	75 27                	jne    ffffffff8100c9c6 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvv+0x188>
ffffffff8100c99f:	49 c7 c0 70 fb 01 81 	mov    $0xffffffff8101fb70,%r8
ffffffff8100c9a6:	b1 5e                	mov    $0x5e,%cl
ffffffff8100c9a8:	48 c7 c2 c7 e6 01 81 	mov    $0xffffffff8101e6c7,%rdx
ffffffff8100c9af:	48 c7 c6 35 e7 01 81 	mov    $0xffffffff8101e735,%rsi
ffffffff8100c9b6:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100c9bd:	31 c0                	xor    %eax,%eax
ffffffff8100c9bf:	e8 8c 55 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
ffffffff8100c9c4:	31 ed                	xor    %ebp,%ebp
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
ffffffff8100c9c6:	48 89 15 43 26 ff 3e 	mov    %rdx,0x3eff2643(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100c9cd:	8b 82 8c 00 00 00    	mov    0x8c(%rdx),%eax
ffffffff8100c9d3:	85 c0                	test   %eax,%eax
ffffffff8100c9d5:	74 0d                	je     ffffffff8100c9e4 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvv+0x1a6>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8100c9d7:	8d 48 01             	lea    0x1(%rax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff8100c9da:	f0 0f b1 8a 8c 00 00 	lock cmpxchg %ecx,0x8c(%rdx)
ffffffff8100c9e1:	00 
ffffffff8100c9e2:	75 e9                	jne    ffffffff8100c9cd <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvv+0x18f>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
ffffffff8100c9e4:	f6 05 5b 2d ff 3e 02 	testb  $0x2,0x3eff2d5b(%rip)        # ffffffffbffff746 <_ZN3Cpu8featuresE+0x6>
ffffffff8100c9eb:	8b 0d 13 26 ff 3e    	mov    0x3eff2613(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100c9f1:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff8100c9f6:	48 0f 45 c6          	cmovne %rsi,%rax
ffffffff8100c9fa:	48 0b 84 ca a0 00 00 	or     0xa0(%rdx,%rcx,8),%rax
ffffffff8100ca01:	00 
ffffffff8100ca02:	0f 22 d8             	mov    %rax,%cr3

            if (del_pd)
ffffffff8100ca05:	48 85 ed             	test   %rbp,%rbp
ffffffff8100ca08:	74 44                	je     ffffffff8100ca4e <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvv+0x210>
                delete del_pd;
ffffffff8100ca0a:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100ca0d:	e8 16 46 00 00       	callq  ffffffff81011028 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff8100ca12:	48 8b 45 50          	mov    0x50(%rbp),%rax
ffffffff8100ca16:	31 d2                	xor    %edx,%edx

            pd_del->quota.free_up(pd_to->quota);
ffffffff8100ca18:	48 8d bd 08 03 00 00 	lea    0x308(%rbp),%rdi

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff8100ca1f:	48 8d 88 08 fd ff ff 	lea    -0x2f8(%rax),%rcx
ffffffff8100ca26:	48 85 c0             	test   %rax,%rax
ffffffff8100ca29:	48 0f 45 d1          	cmovne %rcx,%rdx

            pd_del->quota.free_up(pd_to->quota);
ffffffff8100ca2d:	4c 8d a2 08 03 00 00 	lea    0x308(%rdx),%r12
ffffffff8100ca34:	4c 89 e6             	mov    %r12,%rsi
ffffffff8100ca37:	e8 88 6b ff ff       	callq  ffffffff810035c4 <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
ffffffff8100ca3c:	4c 89 e2             	mov    %r12,%rdx
ffffffff8100ca3f:	48 89 ee             	mov    %rbp,%rsi
ffffffff8100ca42:	48 c7 c7 d0 3f 16 81 	mov    $0xffffffff81163fd0,%rdi
ffffffff8100ca49:	e8 1c 90 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>

        pd->make_current();

        asm volatile ("mov %0," EXPAND(PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory");
ffffffff8100ca4e:	48 8b 83 a0 00 00 00 	mov    0xa0(%rbx),%rax
ffffffff8100ca55:	48 c7 c4 00 e0 ff bf 	mov    $0xffffffffbfffe000,%rsp
ffffffff8100ca5c:	ff e0                	jmpq   *%rax

ffffffff8100ca5e <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvv>:
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
{
    assert (current->xcpu_sm);
ffffffff8100ca5e:	48 8b 05 a3 25 ff 3e 	mov    0x3eff25a3(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>

    Sc::schedule(true);
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
ffffffff8100ca65:	41 54                	push   %r12
ffffffff8100ca67:	55                   	push   %rbp
ffffffff8100ca68:	53                   	push   %rbx
{
    assert (current->xcpu_sm);
ffffffff8100ca69:	48 8b 98 30 03 00 00 	mov    0x330(%rax),%rbx
ffffffff8100ca70:	48 85 db             	test   %rbx,%rbx
ffffffff8100ca73:	75 1f                	jne    ffffffff8100ca94 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvv+0x36>
ffffffff8100ca75:	49 c7 c0 c0 ec 01 81 	mov    $0xffffffff8101ecc0,%r8
ffffffff8100ca7c:	b9 9b 00 00 00       	mov    $0x9b,%ecx
ffffffff8100ca81:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100ca88:	48 c7 c6 cc de 01 81 	mov    $0xffffffff8101decc,%rsi
ffffffff8100ca8f:	e9 42 01 00 00       	jmpq   ffffffff8100cbd6 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvv+0x178>

    Sm::destroy(current->xcpu_sm, Pd::current->quota);
ffffffff8100ca94:	48 8b 05 75 25 ff 3e 	mov    0x3eff2575(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100ca9b:	48 89 df             	mov    %rbx,%rdi
ffffffff8100ca9e:	48 8d a8 08 03 00 00 	lea    0x308(%rax),%rbp
ffffffff8100caa5:	e8 16 ee ff ff       	callq  ffffffff8100b8c0 <_ZN2SmD1Ev>
ffffffff8100caaa:	48 89 ea             	mov    %rbp,%rdx
ffffffff8100caad:	48 89 de             	mov    %rbx,%rsi
ffffffff8100cab0:	48 c7 c7 80 40 16 81 	mov    $0xffffffff81164080,%rdi
ffffffff8100cab7:	e8 ae 8f 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
    current->xcpu_sm = nullptr;
ffffffff8100cabc:	48 8b 1d 45 25 ff 3e 	mov    0x3eff2545(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff8100cac3:	83 c8 ff             	or     $0xffffffff,%eax
        }

        ALWAYS_INLINE
        inline bool del_ref()
        {
            return Atomic::sub (ref, 1U) == 0;
ffffffff8100cac6:	48 8d ab 8c 00 00 00 	lea    0x8c(%rbx),%rbp
ffffffff8100cacd:	48 c7 83 30 03 00 00 	movq   $0x0,0x330(%rbx)
ffffffff8100cad4:	00 00 00 00 

    current->cont = C;
ffffffff8100cad8:	48 c7 83 a0 00 00 00 	movq   $0xffffffff810193aa,0xa0(%rbx)
ffffffff8100cadf:	aa 93 01 81 
ffffffff8100cae3:	f0 0f c1 45 00       	lock xadd %eax,0x0(%rbp)
        regs.ARG_3 = cnt;
    }

    ALWAYS_INLINE NORETURN
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
ffffffff8100cae8:	ff c8                	dec    %eax
ffffffff8100caea:	75 32                	jne    ffffffff8100cb1e <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvv+0xc0>
            delete current;
ffffffff8100caec:	4c 8b 25 15 25 ff 3e 	mov    0x3eff2515(%rip),%r12        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100caf3:	4d 85 e4             	test   %r12,%r12
ffffffff8100caf6:	74 26                	je     ffffffff8100cb1e <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvv+0xc0>
ffffffff8100caf8:	4c 89 e7             	mov    %r12,%rdi
ffffffff8100cafb:	e8 3c 79 ff ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff8100cb00:	49 8b 84 24 98 02 00 	mov    0x298(%r12),%rax
ffffffff8100cb07:	00 
ffffffff8100cb08:	4c 89 e6             	mov    %r12,%rsi
ffffffff8100cb0b:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff8100cb12:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff8100cb19:	e8 4c 8f 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
            delete current;
        }

        current = this;
ffffffff8100cb1e:	48 89 1d e3 24 ff 3e 	mov    %rbx,0x3eff24e3(%rip)        # ffffffffbffff008 <_ZN2Ec7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100cb25:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff8100cb2b:	85 c0                	test   %eax,%eax
ffffffff8100cb2d:	74 0a                	je     ffffffff8100cb39 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvv+0xdb>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8100cb2f:	8d 50 01             	lea    0x1(%rax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff8100cb32:	f0 0f b1 55 00       	lock cmpxchg %edx,0x0(%rbp)
ffffffff8100cb37:	75 ec                	jne    ffffffff8100cb25 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvv+0xc7>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
ffffffff8100cb39:	48 8b 93 98 02 00 00 	mov    0x298(%rbx),%rdx

        current->add_ref();

        Tss::run.sp0 = reinterpret_cast<mword> (exc_regs() + 1);
ffffffff8100cb40:	48 8d 83 80 01 00 00 	lea    0x180(%rbx),%rax
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
ffffffff8100cb47:	8b 0d b7 24 ff 3e    	mov    0x3eff24b7(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100cb4d:	48 89 05 78 32 ff 3e 	mov    %rax,0x3eff3278(%rip)        # ffffffffbffffdcc <tss_run+0x4>
ffffffff8100cb54:	48 8b 82 c8 02 00 00 	mov    0x2c8(%rdx),%rax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
ffffffff8100cb5b:	48 8b b2 b8 02 00 00 	mov    0x2b8(%rdx),%rsi

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
ffffffff8100cb62:	48 0f a3 c8          	bt     %rcx,%rax
ffffffff8100cb66:	73 14                	jae    ffffffff8100cb7c <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvv+0x11e>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
ffffffff8100cb68:	48 c7 c0 fe ff ff ff 	mov    $0xfffffffffffffffe,%rax
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
ffffffff8100cb6f:	48 d3 c0             	rol    %cl,%rax
ffffffff8100cb72:	f0 48 21 82 c8 02 00 	lock and %rax,0x2c8(%rdx)
ffffffff8100cb79:	00 
ffffffff8100cb7a:	eb 20                	jmp    ffffffff8100cb9c <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvv+0x13e>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
ffffffff8100cb7c:	48 39 15 8d 24 ff 3e 	cmp    %rdx,0x3eff248d(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100cb83:	0f 84 e5 00 00 00    	je     ffffffff8100cc6e <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvv+0x210>
                    return;

                if (pcid != NO_PCID)
ffffffff8100cb89:	48 83 fe 02          	cmp    $0x2,%rsi
ffffffff8100cb8d:	74 0d                	je     ffffffff8100cb9c <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvv+0x13e>
                    pcid |= static_cast<mword>(1ULL << 63);
ffffffff8100cb8f:	48 b8 00 00 00 00 00 	movabs $0x8000000000000000,%rax
ffffffff8100cb96:	00 00 80 
ffffffff8100cb99:	48 09 c6             	or     %rax,%rsi
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff8100cb9c:	48 8b 05 6d 24 ff 3e 	mov    0x3eff246d(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100cba3:	83 c9 ff             	or     $0xffffffff,%ecx
ffffffff8100cba6:	f0 0f c1 88 8c 00 00 	lock xadd %ecx,0x8c(%rax)
ffffffff8100cbad:	00 
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
ffffffff8100cbae:	83 f9 01             	cmp    $0x1,%ecx
ffffffff8100cbb1:	75 31                	jne    ffffffff8100cbe4 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvv+0x186>
                assert (current != this);
ffffffff8100cbb3:	48 8b 2d 56 24 ff 3e 	mov    0x3eff2456(%rip),%rbp        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100cbba:	48 39 d5             	cmp    %rdx,%rbp
ffffffff8100cbbd:	75 27                	jne    ffffffff8100cbe6 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvv+0x188>
ffffffff8100cbbf:	49 c7 c0 70 fb 01 81 	mov    $0xffffffff8101fb70,%r8
ffffffff8100cbc6:	b1 5e                	mov    $0x5e,%cl
ffffffff8100cbc8:	48 c7 c2 c7 e6 01 81 	mov    $0xffffffff8101e6c7,%rdx
ffffffff8100cbcf:	48 c7 c6 35 e7 01 81 	mov    $0xffffffff8101e735,%rsi
ffffffff8100cbd6:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100cbdd:	31 c0                	xor    %eax,%eax
ffffffff8100cbdf:	e8 6c 53 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
ffffffff8100cbe4:	31 ed                	xor    %ebp,%ebp
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
ffffffff8100cbe6:	48 89 15 23 24 ff 3e 	mov    %rdx,0x3eff2423(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100cbed:	8b 82 8c 00 00 00    	mov    0x8c(%rdx),%eax
ffffffff8100cbf3:	85 c0                	test   %eax,%eax
ffffffff8100cbf5:	74 0d                	je     ffffffff8100cc04 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvv+0x1a6>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8100cbf7:	8d 48 01             	lea    0x1(%rax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff8100cbfa:	f0 0f b1 8a 8c 00 00 	lock cmpxchg %ecx,0x8c(%rdx)
ffffffff8100cc01:	00 
ffffffff8100cc02:	75 e9                	jne    ffffffff8100cbed <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvv+0x18f>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
ffffffff8100cc04:	f6 05 3b 2b ff 3e 02 	testb  $0x2,0x3eff2b3b(%rip)        # ffffffffbffff746 <_ZN3Cpu8featuresE+0x6>
ffffffff8100cc0b:	8b 0d f3 23 ff 3e    	mov    0x3eff23f3(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100cc11:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff8100cc16:	48 0f 45 c6          	cmovne %rsi,%rax
ffffffff8100cc1a:	48 0b 84 ca a0 00 00 	or     0xa0(%rdx,%rcx,8),%rax
ffffffff8100cc21:	00 
ffffffff8100cc22:	0f 22 d8             	mov    %rax,%cr3

            if (del_pd)
ffffffff8100cc25:	48 85 ed             	test   %rbp,%rbp
ffffffff8100cc28:	74 44                	je     ffffffff8100cc6e <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvv+0x210>
                delete del_pd;
ffffffff8100cc2a:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100cc2d:	e8 f6 43 00 00       	callq  ffffffff81011028 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff8100cc32:	48 8b 45 50          	mov    0x50(%rbp),%rax
ffffffff8100cc36:	31 d2                	xor    %edx,%edx

            pd_del->quota.free_up(pd_to->quota);
ffffffff8100cc38:	48 8d bd 08 03 00 00 	lea    0x308(%rbp),%rdi

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff8100cc3f:	48 8d 88 08 fd ff ff 	lea    -0x2f8(%rax),%rcx
ffffffff8100cc46:	48 85 c0             	test   %rax,%rax
ffffffff8100cc49:	48 0f 45 d1          	cmovne %rcx,%rdx

            pd_del->quota.free_up(pd_to->quota);
ffffffff8100cc4d:	4c 8d a2 08 03 00 00 	lea    0x308(%rdx),%r12
ffffffff8100cc54:	4c 89 e6             	mov    %r12,%rsi
ffffffff8100cc57:	e8 68 69 ff ff       	callq  ffffffff810035c4 <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
ffffffff8100cc5c:	4c 89 e2             	mov    %r12,%rdx
ffffffff8100cc5f:	48 89 ee             	mov    %rbp,%rsi
ffffffff8100cc62:	48 c7 c7 d0 3f 16 81 	mov    $0xffffffff81163fd0,%rdi
ffffffff8100cc69:	e8 fc 8d 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>

        pd->make_current();

        asm volatile ("mov %0," EXPAND(PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory");
ffffffff8100cc6e:	48 8b 83 a0 00 00 00 	mov    0xa0(%rbx),%rax
ffffffff8100cc75:	48 c7 c4 00 e0 ff bf 	mov    $0xffffffffbfffe000,%rsp
ffffffff8100cc7c:	ff e0                	jmpq   *%rax

ffffffff8100cc7e <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvv>:
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
{
    assert (current->xcpu_sm);
ffffffff8100cc7e:	48 8b 05 83 23 ff 3e 	mov    0x3eff2383(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>

    Sc::schedule(true);
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
ffffffff8100cc85:	41 54                	push   %r12
ffffffff8100cc87:	55                   	push   %rbp
ffffffff8100cc88:	53                   	push   %rbx
{
    assert (current->xcpu_sm);
ffffffff8100cc89:	48 8b 98 30 03 00 00 	mov    0x330(%rax),%rbx
ffffffff8100cc90:	48 85 db             	test   %rbx,%rbx
ffffffff8100cc93:	75 1f                	jne    ffffffff8100ccb4 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvv+0x36>
ffffffff8100cc95:	49 c7 c0 c0 ea 01 81 	mov    $0xffffffff8101eac0,%r8
ffffffff8100cc9c:	b9 9b 00 00 00       	mov    $0x9b,%ecx
ffffffff8100cca1:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100cca8:	48 c7 c6 cc de 01 81 	mov    $0xffffffff8101decc,%rsi
ffffffff8100ccaf:	e9 42 01 00 00       	jmpq   ffffffff8100cdf6 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvv+0x178>

    Sm::destroy(current->xcpu_sm, Pd::current->quota);
ffffffff8100ccb4:	48 8b 05 55 23 ff 3e 	mov    0x3eff2355(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100ccbb:	48 89 df             	mov    %rbx,%rdi
ffffffff8100ccbe:	48 8d a8 08 03 00 00 	lea    0x308(%rax),%rbp
ffffffff8100ccc5:	e8 f6 eb ff ff       	callq  ffffffff8100b8c0 <_ZN2SmD1Ev>
ffffffff8100ccca:	48 89 ea             	mov    %rbp,%rdx
ffffffff8100cccd:	48 89 de             	mov    %rbx,%rsi
ffffffff8100ccd0:	48 c7 c7 80 40 16 81 	mov    $0xffffffff81164080,%rdi
ffffffff8100ccd7:	e8 8e 8d 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
    current->xcpu_sm = nullptr;
ffffffff8100ccdc:	48 8b 1d 25 23 ff 3e 	mov    0x3eff2325(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff8100cce3:	83 c8 ff             	or     $0xffffffff,%eax
        }

        ALWAYS_INLINE
        inline bool del_ref()
        {
            return Atomic::sub (ref, 1U) == 0;
ffffffff8100cce6:	48 8d ab 8c 00 00 00 	lea    0x8c(%rbx),%rbp
ffffffff8100cced:	48 c7 83 30 03 00 00 	movq   $0x0,0x330(%rbx)
ffffffff8100ccf4:	00 00 00 00 

    current->cont = C;
ffffffff8100ccf8:	48 c7 83 a0 00 00 00 	movq   $0xffffffff8101a65c,0xa0(%rbx)
ffffffff8100ccff:	5c a6 01 81 
ffffffff8100cd03:	f0 0f c1 45 00       	lock xadd %eax,0x0(%rbp)
        regs.ARG_3 = cnt;
    }

    ALWAYS_INLINE NORETURN
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
ffffffff8100cd08:	ff c8                	dec    %eax
ffffffff8100cd0a:	75 32                	jne    ffffffff8100cd3e <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvv+0xc0>
            delete current;
ffffffff8100cd0c:	4c 8b 25 f5 22 ff 3e 	mov    0x3eff22f5(%rip),%r12        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100cd13:	4d 85 e4             	test   %r12,%r12
ffffffff8100cd16:	74 26                	je     ffffffff8100cd3e <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvv+0xc0>
ffffffff8100cd18:	4c 89 e7             	mov    %r12,%rdi
ffffffff8100cd1b:	e8 1c 77 ff ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff8100cd20:	49 8b 84 24 98 02 00 	mov    0x298(%r12),%rax
ffffffff8100cd27:	00 
ffffffff8100cd28:	4c 89 e6             	mov    %r12,%rsi
ffffffff8100cd2b:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff8100cd32:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff8100cd39:	e8 2c 8d 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
            delete current;
        }

        current = this;
ffffffff8100cd3e:	48 89 1d c3 22 ff 3e 	mov    %rbx,0x3eff22c3(%rip)        # ffffffffbffff008 <_ZN2Ec7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100cd45:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff8100cd4b:	85 c0                	test   %eax,%eax
ffffffff8100cd4d:	74 0a                	je     ffffffff8100cd59 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvv+0xdb>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8100cd4f:	8d 50 01             	lea    0x1(%rax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff8100cd52:	f0 0f b1 55 00       	lock cmpxchg %edx,0x0(%rbp)
ffffffff8100cd57:	75 ec                	jne    ffffffff8100cd45 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvv+0xc7>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
ffffffff8100cd59:	48 8b 93 98 02 00 00 	mov    0x298(%rbx),%rdx

        current->add_ref();

        Tss::run.sp0 = reinterpret_cast<mword> (exc_regs() + 1);
ffffffff8100cd60:	48 8d 83 80 01 00 00 	lea    0x180(%rbx),%rax
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
ffffffff8100cd67:	8b 0d 97 22 ff 3e    	mov    0x3eff2297(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100cd6d:	48 89 05 58 30 ff 3e 	mov    %rax,0x3eff3058(%rip)        # ffffffffbffffdcc <tss_run+0x4>
ffffffff8100cd74:	48 8b 82 c8 02 00 00 	mov    0x2c8(%rdx),%rax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
ffffffff8100cd7b:	48 8b b2 b8 02 00 00 	mov    0x2b8(%rdx),%rsi

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
ffffffff8100cd82:	48 0f a3 c8          	bt     %rcx,%rax
ffffffff8100cd86:	73 14                	jae    ffffffff8100cd9c <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvv+0x11e>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
ffffffff8100cd88:	48 c7 c0 fe ff ff ff 	mov    $0xfffffffffffffffe,%rax
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
ffffffff8100cd8f:	48 d3 c0             	rol    %cl,%rax
ffffffff8100cd92:	f0 48 21 82 c8 02 00 	lock and %rax,0x2c8(%rdx)
ffffffff8100cd99:	00 
ffffffff8100cd9a:	eb 20                	jmp    ffffffff8100cdbc <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvv+0x13e>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
ffffffff8100cd9c:	48 39 15 6d 22 ff 3e 	cmp    %rdx,0x3eff226d(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100cda3:	0f 84 e5 00 00 00    	je     ffffffff8100ce8e <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvv+0x210>
                    return;

                if (pcid != NO_PCID)
ffffffff8100cda9:	48 83 fe 02          	cmp    $0x2,%rsi
ffffffff8100cdad:	74 0d                	je     ffffffff8100cdbc <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvv+0x13e>
                    pcid |= static_cast<mword>(1ULL << 63);
ffffffff8100cdaf:	48 b8 00 00 00 00 00 	movabs $0x8000000000000000,%rax
ffffffff8100cdb6:	00 00 80 
ffffffff8100cdb9:	48 09 c6             	or     %rax,%rsi
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff8100cdbc:	48 8b 05 4d 22 ff 3e 	mov    0x3eff224d(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100cdc3:	83 c9 ff             	or     $0xffffffff,%ecx
ffffffff8100cdc6:	f0 0f c1 88 8c 00 00 	lock xadd %ecx,0x8c(%rax)
ffffffff8100cdcd:	00 
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
ffffffff8100cdce:	83 f9 01             	cmp    $0x1,%ecx
ffffffff8100cdd1:	75 31                	jne    ffffffff8100ce04 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvv+0x186>
                assert (current != this);
ffffffff8100cdd3:	48 8b 2d 36 22 ff 3e 	mov    0x3eff2236(%rip),%rbp        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100cdda:	48 39 d5             	cmp    %rdx,%rbp
ffffffff8100cddd:	75 27                	jne    ffffffff8100ce06 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvv+0x188>
ffffffff8100cddf:	49 c7 c0 70 fb 01 81 	mov    $0xffffffff8101fb70,%r8
ffffffff8100cde6:	b1 5e                	mov    $0x5e,%cl
ffffffff8100cde8:	48 c7 c2 c7 e6 01 81 	mov    $0xffffffff8101e6c7,%rdx
ffffffff8100cdef:	48 c7 c6 35 e7 01 81 	mov    $0xffffffff8101e735,%rsi
ffffffff8100cdf6:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100cdfd:	31 c0                	xor    %eax,%eax
ffffffff8100cdff:	e8 4c 51 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
ffffffff8100ce04:	31 ed                	xor    %ebp,%ebp
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
ffffffff8100ce06:	48 89 15 03 22 ff 3e 	mov    %rdx,0x3eff2203(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100ce0d:	8b 82 8c 00 00 00    	mov    0x8c(%rdx),%eax
ffffffff8100ce13:	85 c0                	test   %eax,%eax
ffffffff8100ce15:	74 0d                	je     ffffffff8100ce24 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvv+0x1a6>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8100ce17:	8d 48 01             	lea    0x1(%rax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff8100ce1a:	f0 0f b1 8a 8c 00 00 	lock cmpxchg %ecx,0x8c(%rdx)
ffffffff8100ce21:	00 
ffffffff8100ce22:	75 e9                	jne    ffffffff8100ce0d <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvv+0x18f>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
ffffffff8100ce24:	f6 05 1b 29 ff 3e 02 	testb  $0x2,0x3eff291b(%rip)        # ffffffffbffff746 <_ZN3Cpu8featuresE+0x6>
ffffffff8100ce2b:	8b 0d d3 21 ff 3e    	mov    0x3eff21d3(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100ce31:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff8100ce36:	48 0f 45 c6          	cmovne %rsi,%rax
ffffffff8100ce3a:	48 0b 84 ca a0 00 00 	or     0xa0(%rdx,%rcx,8),%rax
ffffffff8100ce41:	00 
ffffffff8100ce42:	0f 22 d8             	mov    %rax,%cr3

            if (del_pd)
ffffffff8100ce45:	48 85 ed             	test   %rbp,%rbp
ffffffff8100ce48:	74 44                	je     ffffffff8100ce8e <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvv+0x210>
                delete del_pd;
ffffffff8100ce4a:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100ce4d:	e8 d6 41 00 00       	callq  ffffffff81011028 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff8100ce52:	48 8b 45 50          	mov    0x50(%rbp),%rax
ffffffff8100ce56:	31 d2                	xor    %edx,%edx

            pd_del->quota.free_up(pd_to->quota);
ffffffff8100ce58:	48 8d bd 08 03 00 00 	lea    0x308(%rbp),%rdi

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff8100ce5f:	48 8d 88 08 fd ff ff 	lea    -0x2f8(%rax),%rcx
ffffffff8100ce66:	48 85 c0             	test   %rax,%rax
ffffffff8100ce69:	48 0f 45 d1          	cmovne %rcx,%rdx

            pd_del->quota.free_up(pd_to->quota);
ffffffff8100ce6d:	4c 8d a2 08 03 00 00 	lea    0x308(%rdx),%r12
ffffffff8100ce74:	4c 89 e6             	mov    %r12,%rsi
ffffffff8100ce77:	e8 48 67 ff ff       	callq  ffffffff810035c4 <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
ffffffff8100ce7c:	4c 89 e2             	mov    %r12,%rdx
ffffffff8100ce7f:	48 89 ee             	mov    %rbp,%rsi
ffffffff8100ce82:	48 c7 c7 d0 3f 16 81 	mov    $0xffffffff81163fd0,%rdi
ffffffff8100ce89:	e8 dc 8b 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>

        pd->make_current();

        asm volatile ("mov %0," EXPAND(PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory");
ffffffff8100ce8e:	48 8b 83 a0 00 00 00 	mov    0xa0(%rbx),%rax
ffffffff8100ce95:	48 c7 c4 00 e0 ff bf 	mov    $0xffffffffbfffe000,%rsp
ffffffff8100ce9c:	ff e0                	jmpq   *%rax

ffffffff8100ce9e <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvv>:
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
{
    assert (current->xcpu_sm);
ffffffff8100ce9e:	48 8b 05 63 21 ff 3e 	mov    0x3eff2163(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>

    Sc::schedule(true);
}

template <void (*C)()>
void Ec::ret_xcpu_reply_oom()
ffffffff8100cea5:	41 54                	push   %r12
ffffffff8100cea7:	55                   	push   %rbp
ffffffff8100cea8:	53                   	push   %rbx
{
    assert (current->xcpu_sm);
ffffffff8100cea9:	48 8b 98 30 03 00 00 	mov    0x330(%rax),%rbx
ffffffff8100ceb0:	48 85 db             	test   %rbx,%rbx
ffffffff8100ceb3:	75 1f                	jne    ffffffff8100ced4 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvv+0x36>
ffffffff8100ceb5:	49 c7 c0 c0 e8 01 81 	mov    $0xffffffff8101e8c0,%r8
ffffffff8100cebc:	b9 9b 00 00 00       	mov    $0x9b,%ecx
ffffffff8100cec1:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100cec8:	48 c7 c6 cc de 01 81 	mov    $0xffffffff8101decc,%rsi
ffffffff8100cecf:	e9 42 01 00 00       	jmpq   ffffffff8100d016 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvv+0x178>

    Sm::destroy(current->xcpu_sm, Pd::current->quota);
ffffffff8100ced4:	48 8b 05 35 21 ff 3e 	mov    0x3eff2135(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100cedb:	48 89 df             	mov    %rbx,%rdi
ffffffff8100cede:	48 8d a8 08 03 00 00 	lea    0x308(%rax),%rbp
ffffffff8100cee5:	e8 d6 e9 ff ff       	callq  ffffffff8100b8c0 <_ZN2SmD1Ev>
ffffffff8100ceea:	48 89 ea             	mov    %rbp,%rdx
ffffffff8100ceed:	48 89 de             	mov    %rbx,%rsi
ffffffff8100cef0:	48 c7 c7 80 40 16 81 	mov    $0xffffffff81164080,%rdi
ffffffff8100cef7:	e8 6e 8b 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
    current->xcpu_sm = nullptr;
ffffffff8100cefc:	48 8b 1d 05 21 ff 3e 	mov    0x3eff2105(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff8100cf03:	83 c8 ff             	or     $0xffffffff,%eax
        }

        ALWAYS_INLINE
        inline bool del_ref()
        {
            return Atomic::sub (ref, 1U) == 0;
ffffffff8100cf06:	48 8d ab 8c 00 00 00 	lea    0x8c(%rbx),%rbp
ffffffff8100cf0d:	48 c7 83 30 03 00 00 	movq   $0x0,0x330(%rbx)
ffffffff8100cf14:	00 00 00 00 

    current->cont = C;
ffffffff8100cf18:	48 c7 83 a0 00 00 00 	movq   $0xffffffff8101a49a,0xa0(%rbx)
ffffffff8100cf1f:	9a a4 01 81 
ffffffff8100cf23:	f0 0f c1 45 00       	lock xadd %eax,0x0(%rbp)
        regs.ARG_3 = cnt;
    }

    ALWAYS_INLINE NORETURN
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
ffffffff8100cf28:	ff c8                	dec    %eax
ffffffff8100cf2a:	75 32                	jne    ffffffff8100cf5e <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvv+0xc0>
            delete current;
ffffffff8100cf2c:	4c 8b 25 d5 20 ff 3e 	mov    0x3eff20d5(%rip),%r12        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100cf33:	4d 85 e4             	test   %r12,%r12
ffffffff8100cf36:	74 26                	je     ffffffff8100cf5e <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvv+0xc0>
ffffffff8100cf38:	4c 89 e7             	mov    %r12,%rdi
ffffffff8100cf3b:	e8 fc 74 ff ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff8100cf40:	49 8b 84 24 98 02 00 	mov    0x298(%r12),%rax
ffffffff8100cf47:	00 
ffffffff8100cf48:	4c 89 e6             	mov    %r12,%rsi
ffffffff8100cf4b:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff8100cf52:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff8100cf59:	e8 0c 8b 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
            delete current;
        }

        current = this;
ffffffff8100cf5e:	48 89 1d a3 20 ff 3e 	mov    %rbx,0x3eff20a3(%rip)        # ffffffffbffff008 <_ZN2Ec7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100cf65:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff8100cf6b:	85 c0                	test   %eax,%eax
ffffffff8100cf6d:	74 0a                	je     ffffffff8100cf79 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvv+0xdb>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8100cf6f:	8d 50 01             	lea    0x1(%rax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff8100cf72:	f0 0f b1 55 00       	lock cmpxchg %edx,0x0(%rbp)
ffffffff8100cf77:	75 ec                	jne    ffffffff8100cf65 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvv+0xc7>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
ffffffff8100cf79:	48 8b 93 98 02 00 00 	mov    0x298(%rbx),%rdx

        current->add_ref();

        Tss::run.sp0 = reinterpret_cast<mword> (exc_regs() + 1);
ffffffff8100cf80:	48 8d 83 80 01 00 00 	lea    0x180(%rbx),%rax
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
ffffffff8100cf87:	8b 0d 77 20 ff 3e    	mov    0x3eff2077(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100cf8d:	48 89 05 38 2e ff 3e 	mov    %rax,0x3eff2e38(%rip)        # ffffffffbffffdcc <tss_run+0x4>
ffffffff8100cf94:	48 8b 82 c8 02 00 00 	mov    0x2c8(%rdx),%rax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
ffffffff8100cf9b:	48 8b b2 b8 02 00 00 	mov    0x2b8(%rdx),%rsi

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
ffffffff8100cfa2:	48 0f a3 c8          	bt     %rcx,%rax
ffffffff8100cfa6:	73 14                	jae    ffffffff8100cfbc <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvv+0x11e>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
ffffffff8100cfa8:	48 c7 c0 fe ff ff ff 	mov    $0xfffffffffffffffe,%rax
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
ffffffff8100cfaf:	48 d3 c0             	rol    %cl,%rax
ffffffff8100cfb2:	f0 48 21 82 c8 02 00 	lock and %rax,0x2c8(%rdx)
ffffffff8100cfb9:	00 
ffffffff8100cfba:	eb 20                	jmp    ffffffff8100cfdc <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvv+0x13e>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
ffffffff8100cfbc:	48 39 15 4d 20 ff 3e 	cmp    %rdx,0x3eff204d(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100cfc3:	0f 84 e5 00 00 00    	je     ffffffff8100d0ae <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvv+0x210>
                    return;

                if (pcid != NO_PCID)
ffffffff8100cfc9:	48 83 fe 02          	cmp    $0x2,%rsi
ffffffff8100cfcd:	74 0d                	je     ffffffff8100cfdc <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvv+0x13e>
                    pcid |= static_cast<mword>(1ULL << 63);
ffffffff8100cfcf:	48 b8 00 00 00 00 00 	movabs $0x8000000000000000,%rax
ffffffff8100cfd6:	00 00 80 
ffffffff8100cfd9:	48 09 c6             	or     %rax,%rsi
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff8100cfdc:	48 8b 05 2d 20 ff 3e 	mov    0x3eff202d(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100cfe3:	83 c9 ff             	or     $0xffffffff,%ecx
ffffffff8100cfe6:	f0 0f c1 88 8c 00 00 	lock xadd %ecx,0x8c(%rax)
ffffffff8100cfed:	00 
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
ffffffff8100cfee:	83 f9 01             	cmp    $0x1,%ecx
ffffffff8100cff1:	75 31                	jne    ffffffff8100d024 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvv+0x186>
                assert (current != this);
ffffffff8100cff3:	48 8b 2d 16 20 ff 3e 	mov    0x3eff2016(%rip),%rbp        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100cffa:	48 39 d5             	cmp    %rdx,%rbp
ffffffff8100cffd:	75 27                	jne    ffffffff8100d026 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvv+0x188>
ffffffff8100cfff:	49 c7 c0 70 fb 01 81 	mov    $0xffffffff8101fb70,%r8
ffffffff8100d006:	b1 5e                	mov    $0x5e,%cl
ffffffff8100d008:	48 c7 c2 c7 e6 01 81 	mov    $0xffffffff8101e6c7,%rdx
ffffffff8100d00f:	48 c7 c6 35 e7 01 81 	mov    $0xffffffff8101e735,%rsi
ffffffff8100d016:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100d01d:	31 c0                	xor    %eax,%eax
ffffffff8100d01f:	e8 2c 4f ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
ffffffff8100d024:	31 ed                	xor    %ebp,%ebp
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
ffffffff8100d026:	48 89 15 e3 1f ff 3e 	mov    %rdx,0x3eff1fe3(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100d02d:	8b 82 8c 00 00 00    	mov    0x8c(%rdx),%eax
ffffffff8100d033:	85 c0                	test   %eax,%eax
ffffffff8100d035:	74 0d                	je     ffffffff8100d044 <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvv+0x1a6>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8100d037:	8d 48 01             	lea    0x1(%rax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff8100d03a:	f0 0f b1 8a 8c 00 00 	lock cmpxchg %ecx,0x8c(%rdx)
ffffffff8100d041:	00 
ffffffff8100d042:	75 e9                	jne    ffffffff8100d02d <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvv+0x18f>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
ffffffff8100d044:	f6 05 fb 26 ff 3e 02 	testb  $0x2,0x3eff26fb(%rip)        # ffffffffbffff746 <_ZN3Cpu8featuresE+0x6>
ffffffff8100d04b:	8b 0d b3 1f ff 3e    	mov    0x3eff1fb3(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100d051:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff8100d056:	48 0f 45 c6          	cmovne %rsi,%rax
ffffffff8100d05a:	48 0b 84 ca a0 00 00 	or     0xa0(%rdx,%rcx,8),%rax
ffffffff8100d061:	00 
ffffffff8100d062:	0f 22 d8             	mov    %rax,%cr3

            if (del_pd)
ffffffff8100d065:	48 85 ed             	test   %rbp,%rbp
ffffffff8100d068:	74 44                	je     ffffffff8100d0ae <_ZN2Ec18ret_xcpu_reply_oomIXadL_ZNS_14sys_assign_pciEvEEEEvv+0x210>
                delete del_pd;
ffffffff8100d06a:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100d06d:	e8 b6 3f 00 00       	callq  ffffffff81011028 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff8100d072:	48 8b 45 50          	mov    0x50(%rbp),%rax
ffffffff8100d076:	31 d2                	xor    %edx,%edx

            pd_del->quota.free_up(pd_to->quota);
ffffffff8100d078:	48 8d bd 08 03 00 00 	lea    0x308(%rbp),%rdi

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff8100d07f:	48 8d 88 08 fd ff ff 	lea    -0x2f8(%rax),%rcx
ffffffff8100d086:	48 85 c0             	test   %rax,%rax
ffffffff8100d089:	48 0f 45 d1          	cmovne %rcx,%rdx

            pd_del->quota.free_up(pd_to->quota);
ffffffff8100d08d:	4c 8d a2 08 03 00 00 	lea    0x308(%rdx),%r12
ffffffff8100d094:	4c 89 e6             	mov    %r12,%rsi
ffffffff8100d097:	e8 28 65 ff ff       	callq  ffffffff810035c4 <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
ffffffff8100d09c:	4c 89 e2             	mov    %r12,%rdx
ffffffff8100d09f:	48 89 ee             	mov    %rbp,%rsi
ffffffff8100d0a2:	48 c7 c7 d0 3f 16 81 	mov    $0xffffffff81163fd0,%rdi
ffffffff8100d0a9:	e8 bc 89 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>

        pd->make_current();

        asm volatile ("mov %0," EXPAND(PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory");
ffffffff8100d0ae:	48 8b 83 a0 00 00 00 	mov    0xa0(%rbx),%rax
ffffffff8100d0b5:	48 c7 c4 00 e0 ff bf 	mov    $0xffffffffbfffe000,%rsp
ffffffff8100d0bc:	ff e0                	jmpq   *%rax

ffffffff8100d0be <_ZN2Ec8oom_callEP2PtmmPFvvES3_>:

    chg->oom_call(dst_pt, src_pd_id, oom_state, c, c);
}

void Ec::oom_call(Pt * pt, mword src, mword state, void (*CC)(), void (*HELP)())
{
ffffffff8100d0be:	41 56                	push   %r14
ffffffff8100d0c0:	41 55                	push   %r13
ffffffff8100d0c2:	41 54                	push   %r12
ffffffff8100d0c4:	55                   	push   %rbp
ffffffff8100d0c5:	49 89 f4             	mov    %rsi,%r12
ffffffff8100d0c8:	53                   	push   %rbx
ffffffff8100d0c9:	48 89 fd             	mov    %rdi,%rbp
ffffffff8100d0cc:	48 83 ec 10          	sub    $0x10,%rsp
    Ec *ec = pt->ec;

    assert (!this->partner);
ffffffff8100d0d0:	48 83 bf a0 02 00 00 	cmpq   $0x0,0x2a0(%rdi)
ffffffff8100d0d7:	00 
{
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
ffffffff8100d0d8:	48 8b 9e 90 00 00 00 	mov    0x90(%rsi),%rbx
ffffffff8100d0df:	74 1c                	je     ffffffff8100d0fd <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x3f>
ffffffff8100d0e1:	49 c7 c0 b0 fa 01 81 	mov    $0xffffffff8101fab0,%r8
ffffffff8100d0e8:	b9 5e 00 00 00       	mov    $0x5e,%ecx
ffffffff8100d0ed:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100d0f4:	48 c7 c6 45 e7 01 81 	mov    $0xffffffff8101e745,%rsi
ffffffff8100d0fb:	eb 29                	jmp    ffffffff8100d126 <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x68>
    assert (this->cpu == ec->xcpu);
ffffffff8100d0fd:	0f b7 87 f0 02 00 00 	movzwl 0x2f0(%rdi),%eax
ffffffff8100d104:	3b 83 f0 02 00 00    	cmp    0x2f0(%rbx),%eax
ffffffff8100d10a:	74 28                	je     ffffffff8100d134 <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x76>
ffffffff8100d10c:	49 c7 c0 b0 fa 01 81 	mov    $0xffffffff8101fab0,%r8
ffffffff8100d113:	b9 5f 00 00 00       	mov    $0x5f,%ecx
ffffffff8100d118:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100d11f:	48 c7 c6 54 e7 01 81 	mov    $0xffffffff8101e754,%rsi
ffffffff8100d126:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100d12d:	31 c0                	xor    %eax,%eax
ffffffff8100d12f:	e8 1c 4e ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

    if (this != ec) {
ffffffff8100d134:	48 39 df             	cmp    %rbx,%rdi
ffffffff8100d137:	49 89 d5             	mov    %rdx,%r13
ffffffff8100d13a:	49 89 ce             	mov    %rcx,%r14
ffffffff8100d13d:	74 7d                	je     ffffffff8100d1bc <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0xfe>
        if (ec->cont)
ffffffff8100d13f:	48 83 bb a0 00 00 00 	cmpq   $0x0,0xa0(%rbx)
ffffffff8100d146:	00 
ffffffff8100d147:	74 15                	je     ffffffff8100d15e <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0xa0>
            ec->help (HELP);
ffffffff8100d149:	4c 89 ce             	mov    %r9,%rsi
ffffffff8100d14c:	48 89 df             	mov    %rbx,%rdi
ffffffff8100d14f:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
ffffffff8100d154:	e8 93 e5 ff ff       	callq  ffffffff8100b6ec <_ZN2Ec4helpEPFvvE>
ffffffff8100d159:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
        return &regs;
    }

    ALWAYS_INLINE
    inline void set_partner(Ec *p) {
        partner = p;
ffffffff8100d15e:	48 89 9d a0 02 00 00 	mov    %rbx,0x2a0(%rbp)
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100d165:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff8100d16b:	85 c0                	test   %eax,%eax
ffffffff8100d16d:	74 0d                	je     ffffffff8100d17c <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0xbe>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8100d16f:	8d 50 01             	lea    0x1(%rax),%edx
ffffffff8100d172:	f0 0f b1 93 8c 00 00 	lock cmpxchg %edx,0x8c(%rbx)
ffffffff8100d179:	00 
ffffffff8100d17a:	75 e9                	jne    ffffffff8100d165 <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0xa7>
        partner->add_ref();
        partner->rcap = this;
ffffffff8100d17c:	48 8b 85 a0 02 00 00 	mov    0x2a0(%rbp),%rax
ffffffff8100d183:	48 89 a8 88 02 00 00 	mov    %rbp,0x288(%rax)
        partner->rcap->add_ref();
ffffffff8100d18a:	48 8b 85 a0 02 00 00 	mov    0x2a0(%rbp),%rax
ffffffff8100d191:	48 8b b0 88 02 00 00 	mov    0x288(%rax),%rsi
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100d198:	8b 86 8c 00 00 00    	mov    0x8c(%rsi),%eax
ffffffff8100d19e:	85 c0                	test   %eax,%eax
ffffffff8100d1a0:	74 0d                	je     ffffffff8100d1af <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0xf1>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8100d1a2:	8d 50 01             	lea    0x1(%rax),%edx
ffffffff8100d1a5:	f0 0f b1 96 8c 00 00 	lock cmpxchg %edx,0x8c(%rsi)
ffffffff8100d1ac:	00 
ffffffff8100d1ad:	75 e9                	jne    ffffffff8100d198 <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0xda>
        Sc::ctr_link++;
ffffffff8100d1af:	ff 05 4f 2b ff 3e    	incl   0x3eff2b4f(%rip)        # ffffffffbffffd04 <_ZN2Sc8ctr_linkE>

        this->set_partner (ec);
        this->cont = CC;
ffffffff8100d1b5:	4c 89 85 a0 00 00 00 	mov    %r8,0xa0(%rbp)
    }

    ec->cont = ret_user_sysexit;
ffffffff8100d1bc:	48 c7 83 a0 00 00 00 	movq   $0xffffffff81000000,0xa0(%rbx)
ffffffff8100d1c3:	00 00 00 81 
    ec->regs.set_pt (pt->id, src, state);
ffffffff8100d1c7:	49 8b 84 24 a8 00 00 	mov    0xa8(%r12),%rax
ffffffff8100d1ce:	00 
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff8100d1cf:	83 ca ff             	or     $0xffffffff,%edx

        ALWAYS_INLINE
        inline void set_pt (mword pt) { ARG_1 = pt; }

        ALWAYS_INLINE
        inline void set_pt (mword pt, mword pt2, mword s) { ARG_1 = pt; ARG_2 = pt2; ARG_3 = s; }
ffffffff8100d1d2:	4c 89 ab f0 00 00 00 	mov    %r13,0xf0(%rbx)
ffffffff8100d1d9:	4c 89 b3 10 01 00 00 	mov    %r14,0x110(%rbx)
ffffffff8100d1e0:	48 89 83 e8 00 00 00 	mov    %rax,0xe8(%rbx)
    ec->regs.set_ip (pt->ip);
ffffffff8100d1e7:	49 8b 84 24 a0 00 00 	mov    0xa0(%r12),%rax
ffffffff8100d1ee:	00 

        ALWAYS_INLINE
        inline void set_ip (mword ip) { ARG_IP = ip; }
ffffffff8100d1ef:	48 89 83 18 01 00 00 	mov    %rax,0x118(%rbx)
ffffffff8100d1f6:	48 8b 05 0b 1e ff 3e 	mov    0x3eff1e0b(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100d1fd:	f0 0f c1 90 8c 00 00 	lock xadd %edx,0x8c(%rax)
ffffffff8100d204:	00 
        regs.ARG_3 = cnt;
    }

    ALWAYS_INLINE NORETURN
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
ffffffff8100d205:	ff ca                	dec    %edx
ffffffff8100d207:	75 31                	jne    ffffffff8100d23a <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x17c>
            delete current;
ffffffff8100d209:	48 8b 2d f8 1d ff 3e 	mov    0x3eff1df8(%rip),%rbp        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100d210:	48 85 ed             	test   %rbp,%rbp
ffffffff8100d213:	74 25                	je     ffffffff8100d23a <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x17c>
ffffffff8100d215:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100d218:	e8 1f 72 ff ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff8100d21d:	48 8b 85 98 02 00 00 	mov    0x298(%rbp),%rax
ffffffff8100d224:	48 89 ee             	mov    %rbp,%rsi
ffffffff8100d227:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff8100d22e:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff8100d235:	e8 30 88 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
            delete current;
        }

        current = this;
ffffffff8100d23a:	48 89 1d c7 1d ff 3e 	mov    %rbx,0x3eff1dc7(%rip)        # ffffffffbffff008 <_ZN2Ec7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100d241:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff8100d247:	85 c0                	test   %eax,%eax
ffffffff8100d249:	74 0d                	je     ffffffff8100d258 <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x19a>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8100d24b:	8d 50 01             	lea    0x1(%rax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff8100d24e:	f0 0f b1 93 8c 00 00 	lock cmpxchg %edx,0x8c(%rbx)
ffffffff8100d255:	00 
ffffffff8100d256:	75 e9                	jne    ffffffff8100d241 <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x183>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
ffffffff8100d258:	48 8b 93 98 02 00 00 	mov    0x298(%rbx),%rdx

        current->add_ref();

        Tss::run.sp0 = reinterpret_cast<mword> (exc_regs() + 1);
ffffffff8100d25f:	48 8d 83 80 01 00 00 	lea    0x180(%rbx),%rax
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
ffffffff8100d266:	8b 0d 98 1d ff 3e    	mov    0x3eff1d98(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100d26c:	48 89 05 59 2b ff 3e 	mov    %rax,0x3eff2b59(%rip)        # ffffffffbffffdcc <tss_run+0x4>
ffffffff8100d273:	48 8b 82 c8 02 00 00 	mov    0x2c8(%rdx),%rax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
ffffffff8100d27a:	48 8b b2 b8 02 00 00 	mov    0x2b8(%rdx),%rsi

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
ffffffff8100d281:	48 0f a3 c8          	bt     %rcx,%rax
ffffffff8100d285:	73 14                	jae    ffffffff8100d29b <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x1dd>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
ffffffff8100d287:	48 c7 c0 fe ff ff ff 	mov    $0xfffffffffffffffe,%rax
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
ffffffff8100d28e:	48 d3 c0             	rol    %cl,%rax
ffffffff8100d291:	f0 48 21 82 c8 02 00 	lock and %rax,0x2c8(%rdx)
ffffffff8100d298:	00 
ffffffff8100d299:	eb 20                	jmp    ffffffff8100d2bb <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x1fd>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
ffffffff8100d29b:	48 39 15 6e 1d ff 3e 	cmp    %rdx,0x3eff1d6e(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100d2a2:	0f 84 dc 00 00 00    	je     ffffffff8100d384 <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x2c6>
                    return;

                if (pcid != NO_PCID)
ffffffff8100d2a8:	48 83 fe 02          	cmp    $0x2,%rsi
ffffffff8100d2ac:	74 0d                	je     ffffffff8100d2bb <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x1fd>
                    pcid |= static_cast<mword>(1ULL << 63);
ffffffff8100d2ae:	48 b8 00 00 00 00 00 	movabs $0x8000000000000000,%rax
ffffffff8100d2b5:	00 00 80 
ffffffff8100d2b8:	48 09 c6             	or     %rax,%rsi
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff8100d2bb:	48 8b 05 4e 1d ff 3e 	mov    0x3eff1d4e(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100d2c2:	83 c9 ff             	or     $0xffffffff,%ecx
ffffffff8100d2c5:	f0 0f c1 88 8c 00 00 	lock xadd %ecx,0x8c(%rax)
ffffffff8100d2cc:	00 
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
ffffffff8100d2cd:	83 f9 01             	cmp    $0x1,%ecx
ffffffff8100d2d0:	75 28                	jne    ffffffff8100d2fa <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x23c>
                assert (current != this);
ffffffff8100d2d2:	48 8b 2d 37 1d ff 3e 	mov    0x3eff1d37(%rip),%rbp        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100d2d9:	48 39 d5             	cmp    %rdx,%rbp
ffffffff8100d2dc:	75 1e                	jne    ffffffff8100d2fc <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x23e>
ffffffff8100d2de:	49 c7 c0 70 fb 01 81 	mov    $0xffffffff8101fb70,%r8
ffffffff8100d2e5:	b1 5e                	mov    $0x5e,%cl
ffffffff8100d2e7:	48 c7 c2 c7 e6 01 81 	mov    $0xffffffff8101e6c7,%rdx
ffffffff8100d2ee:	48 c7 c6 35 e7 01 81 	mov    $0xffffffff8101e735,%rsi
ffffffff8100d2f5:	e9 2c fe ff ff       	jmpq   ffffffff8100d126 <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x68>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
ffffffff8100d2fa:	31 ed                	xor    %ebp,%ebp
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
ffffffff8100d2fc:	48 89 15 0d 1d ff 3e 	mov    %rdx,0x3eff1d0d(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100d303:	8b 82 8c 00 00 00    	mov    0x8c(%rdx),%eax
ffffffff8100d309:	85 c0                	test   %eax,%eax
ffffffff8100d30b:	74 0d                	je     ffffffff8100d31a <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x25c>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8100d30d:	8d 48 01             	lea    0x1(%rax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff8100d310:	f0 0f b1 8a 8c 00 00 	lock cmpxchg %ecx,0x8c(%rdx)
ffffffff8100d317:	00 
ffffffff8100d318:	75 e9                	jne    ffffffff8100d303 <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x245>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
ffffffff8100d31a:	f6 05 25 24 ff 3e 02 	testb  $0x2,0x3eff2425(%rip)        # ffffffffbffff746 <_ZN3Cpu8featuresE+0x6>
ffffffff8100d321:	8b 0d dd 1c ff 3e    	mov    0x3eff1cdd(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8100d327:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff8100d32c:	48 0f 45 c6          	cmovne %rsi,%rax
ffffffff8100d330:	48 0b 84 ca a0 00 00 	or     0xa0(%rdx,%rcx,8),%rax
ffffffff8100d337:	00 
ffffffff8100d338:	0f 22 d8             	mov    %rax,%cr3

            if (del_pd)
ffffffff8100d33b:	48 85 ed             	test   %rbp,%rbp
ffffffff8100d33e:	74 44                	je     ffffffff8100d384 <_ZN2Ec8oom_callEP2PtmmPFvvES3_+0x2c6>
                delete del_pd;
ffffffff8100d340:	48 89 ef             	mov    %rbp,%rdi
ffffffff8100d343:	e8 e0 3c 00 00       	callq  ffffffff81011028 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff8100d348:	48 8b 45 50          	mov    0x50(%rbp),%rax
ffffffff8100d34c:	31 d2                	xor    %edx,%edx

            pd_del->quota.free_up(pd_to->quota);
ffffffff8100d34e:	48 8d bd 08 03 00 00 	lea    0x308(%rbp),%rdi

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff8100d355:	48 8d 88 08 fd ff ff 	lea    -0x2f8(%rax),%rcx
ffffffff8100d35c:	48 85 c0             	test   %rax,%rax
ffffffff8100d35f:	48 0f 45 d1          	cmovne %rcx,%rdx

            pd_del->quota.free_up(pd_to->quota);
ffffffff8100d363:	4c 8d a2 08 03 00 00 	lea    0x308(%rdx),%r12
ffffffff8100d36a:	4c 89 e6             	mov    %r12,%rsi
ffffffff8100d36d:	e8 52 62 ff ff       	callq  ffffffff810035c4 <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
ffffffff8100d372:	4c 89 e2             	mov    %r12,%rdx
ffffffff8100d375:	48 89 ee             	mov    %rbp,%rsi
ffffffff8100d378:	48 c7 c7 d0 3f 16 81 	mov    $0xffffffff81163fd0,%rdi
ffffffff8100d37f:	e8 e6 86 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>

        pd->make_current();

        asm volatile ("mov %0," EXPAND(PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory");
ffffffff8100d384:	48 8b 83 a0 00 00 00 	mov    0xa0(%rbx),%rax
ffffffff8100d38b:	48 c7 c4 00 e0 ff bf 	mov    $0xffffffffbfffe000,%rsp
ffffffff8100d392:	ff e0                	jmpq   *%rax

ffffffff8100d394 <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_9sys_replyEvEEEEvv>:
    current->cont = C;
    current->make_current();
}

template <void (*C)()>
void Ec::sys_xcpu_call_oom()
ffffffff8100d394:	50                   	push   %rax
{
    assert (current->xcpu_sm);
ffffffff8100d395:	48 8b 3d 6c 1c ff 3e 	mov    0x3eff1c6c(%rip),%rdi        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100d39c:	48 83 bf 30 03 00 00 	cmpq   $0x0,0x330(%rdi)
ffffffff8100d3a3:	00 
ffffffff8100d3a4:	75 28                	jne    ffffffff8100d3ce <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_9sys_replyEvEEEEvv+0x3a>
ffffffff8100d3a6:	49 c7 c0 c0 fc 01 81 	mov    $0xffffffff8101fcc0,%r8
ffffffff8100d3ad:	b9 a7 00 00 00       	mov    $0xa7,%ecx
ffffffff8100d3b2:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100d3b9:	48 c7 c6 cc de 01 81 	mov    $0xffffffff8101decc,%rsi
ffffffff8100d3c0:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100d3c7:	31 c0                	xor    %eax,%eax
ffffffff8100d3c9:	e8 82 4b ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

    Sys_regs *s  = current->sys_regs();
    Pt       *pt = reinterpret_cast<Pt *>(s->ARG_1);
    current->oom_call(pt, s->ARG_2, s->ARG_3, oom_xcpu_return<ret_xcpu_reply_oom<C>>, sys_xcpu_call_oom<C>);
ffffffff8100d3ce:	48 8b 8f 10 01 00 00 	mov    0x110(%rdi),%rcx
ffffffff8100d3d5:	48 8b 97 f0 00 00 00 	mov    0xf0(%rdi),%rdx
ffffffff8100d3dc:	49 c7 c1 94 d3 00 81 	mov    $0xffffffff8100d394,%r9
ffffffff8100d3e3:	48 8b b7 e8 00 00 00 	mov    0xe8(%rdi),%rsi
ffffffff8100d3ea:	49 c7 c0 b8 8b 00 81 	mov    $0xffffffff81008bb8,%r8
ffffffff8100d3f1:	e8 c8 fc ff ff       	callq  ffffffff8100d0be <_ZN2Ec8oom_callEP2PtmmPFvvES3_>

ffffffff8100d3f6 <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_8sys_callEvEEEEvv>:
    current->cont = C;
    current->make_current();
}

template <void (*C)()>
void Ec::sys_xcpu_call_oom()
ffffffff8100d3f6:	50                   	push   %rax
{
    assert (current->xcpu_sm);
ffffffff8100d3f7:	48 8b 3d 0a 1c ff 3e 	mov    0x3eff1c0a(%rip),%rdi        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100d3fe:	48 83 bf 30 03 00 00 	cmpq   $0x0,0x330(%rdi)
ffffffff8100d405:	00 
ffffffff8100d406:	75 28                	jne    ffffffff8100d430 <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_8sys_callEvEEEEvv+0x3a>
ffffffff8100d408:	49 c7 c0 c0 f9 01 81 	mov    $0xffffffff8101f9c0,%r8
ffffffff8100d40f:	b9 a7 00 00 00       	mov    $0xa7,%ecx
ffffffff8100d414:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100d41b:	48 c7 c6 cc de 01 81 	mov    $0xffffffff8101decc,%rsi
ffffffff8100d422:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100d429:	31 c0                	xor    %eax,%eax
ffffffff8100d42b:	e8 20 4b ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

    Sys_regs *s  = current->sys_regs();
    Pt       *pt = reinterpret_cast<Pt *>(s->ARG_1);
    current->oom_call(pt, s->ARG_2, s->ARG_3, oom_xcpu_return<ret_xcpu_reply_oom<C>>, sys_xcpu_call_oom<C>);
ffffffff8100d430:	48 8b 8f 10 01 00 00 	mov    0x110(%rdi),%rcx
ffffffff8100d437:	48 8b 97 f0 00 00 00 	mov    0xf0(%rdi),%rdx
ffffffff8100d43e:	49 c7 c1 f6 d3 00 81 	mov    $0xffffffff8100d3f6,%r9
ffffffff8100d445:	48 8b b7 e8 00 00 00 	mov    0xe8(%rdi),%rsi
ffffffff8100d44c:	49 c7 c0 0a 90 00 81 	mov    $0xffffffff8100900a,%r8
ffffffff8100d453:	e8 66 fc ff ff       	callq  ffffffff8100d0be <_ZN2Ec8oom_callEP2PtmmPFvvES3_>

ffffffff8100d458 <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_10sys_lookupEvEEEEvv>:
    current->cont = C;
    current->make_current();
}

template <void (*C)()>
void Ec::sys_xcpu_call_oom()
ffffffff8100d458:	50                   	push   %rax
{
    assert (current->xcpu_sm);
ffffffff8100d459:	48 8b 3d a8 1b ff 3e 	mov    0x3eff1ba8(%rip),%rdi        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100d460:	48 83 bf 30 03 00 00 	cmpq   $0x0,0x330(%rdi)
ffffffff8100d467:	00 
ffffffff8100d468:	75 28                	jne    ffffffff8100d492 <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_10sys_lookupEvEEEEvv+0x3a>
ffffffff8100d46a:	49 c7 c0 c0 f7 01 81 	mov    $0xffffffff8101f7c0,%r8
ffffffff8100d471:	b9 a7 00 00 00       	mov    $0xa7,%ecx
ffffffff8100d476:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100d47d:	48 c7 c6 cc de 01 81 	mov    $0xffffffff8101decc,%rsi
ffffffff8100d484:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100d48b:	31 c0                	xor    %eax,%eax
ffffffff8100d48d:	e8 be 4a ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

    Sys_regs *s  = current->sys_regs();
    Pt       *pt = reinterpret_cast<Pt *>(s->ARG_1);
    current->oom_call(pt, s->ARG_2, s->ARG_3, oom_xcpu_return<ret_xcpu_reply_oom<C>>, sys_xcpu_call_oom<C>);
ffffffff8100d492:	48 8b 8f 10 01 00 00 	mov    0x110(%rdi),%rcx
ffffffff8100d499:	48 8b 97 f0 00 00 00 	mov    0xf0(%rdi),%rdx
ffffffff8100d4a0:	49 c7 c1 58 d4 00 81 	mov    $0xffffffff8100d458,%r9
ffffffff8100d4a7:	48 8b b7 e8 00 00 00 	mov    0xe8(%rdi),%rsi
ffffffff8100d4ae:	49 c7 c0 5c 94 00 81 	mov    $0xffffffff8100945c,%r8
ffffffff8100d4b5:	e8 04 fc ff ff       	callq  ffffffff8100d0be <_ZN2Ec8oom_callEP2PtmmPFvvES3_>

ffffffff8100d4ba <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvv>:
    current->cont = C;
    current->make_current();
}

template <void (*C)()>
void Ec::sys_xcpu_call_oom()
ffffffff8100d4ba:	50                   	push   %rax
{
    assert (current->xcpu_sm);
ffffffff8100d4bb:	48 8b 3d 46 1b ff 3e 	mov    0x3eff1b46(%rip),%rdi        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100d4c2:	48 83 bf 30 03 00 00 	cmpq   $0x0,0x330(%rdi)
ffffffff8100d4c9:	00 
ffffffff8100d4ca:	75 28                	jne    ffffffff8100d4f4 <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_11sys_sm_ctrlEvEEEEvv+0x3a>
ffffffff8100d4cc:	49 c7 c0 c0 f5 01 81 	mov    $0xffffffff8101f5c0,%r8
ffffffff8100d4d3:	b9 a7 00 00 00       	mov    $0xa7,%ecx
ffffffff8100d4d8:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100d4df:	48 c7 c6 cc de 01 81 	mov    $0xffffffff8101decc,%rsi
ffffffff8100d4e6:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100d4ed:	31 c0                	xor    %eax,%eax
ffffffff8100d4ef:	e8 5c 4a ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

    Sys_regs *s  = current->sys_regs();
    Pt       *pt = reinterpret_cast<Pt *>(s->ARG_1);
    current->oom_call(pt, s->ARG_2, s->ARG_3, oom_xcpu_return<ret_xcpu_reply_oom<C>>, sys_xcpu_call_oom<C>);
ffffffff8100d4f4:	48 8b 8f 10 01 00 00 	mov    0x110(%rdi),%rcx
ffffffff8100d4fb:	48 8b 97 f0 00 00 00 	mov    0xf0(%rdi),%rdx
ffffffff8100d502:	49 c7 c1 ba d4 00 81 	mov    $0xffffffff8100d4ba,%r9
ffffffff8100d509:	48 8b b7 e8 00 00 00 	mov    0xe8(%rdi),%rsi
ffffffff8100d510:	49 c7 c0 ae 98 00 81 	mov    $0xffffffff810098ae,%r8
ffffffff8100d517:	e8 a2 fb ff ff       	callq  ffffffff8100d0be <_ZN2Ec8oom_callEP2PtmmPFvvES3_>

ffffffff8100d51c <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvv>:
    current->cont = C;
    current->make_current();
}

template <void (*C)()>
void Ec::sys_xcpu_call_oom()
ffffffff8100d51c:	50                   	push   %rax
{
    assert (current->xcpu_sm);
ffffffff8100d51d:	48 8b 3d e4 1a ff 3e 	mov    0x3eff1ae4(%rip),%rdi        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100d524:	48 83 bf 30 03 00 00 	cmpq   $0x0,0x330(%rdi)
ffffffff8100d52b:	00 
ffffffff8100d52c:	75 28                	jne    ffffffff8100d556 <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_11sys_ec_ctrlEvEEEEvv+0x3a>
ffffffff8100d52e:	49 c7 c0 c0 f3 01 81 	mov    $0xffffffff8101f3c0,%r8
ffffffff8100d535:	b9 a7 00 00 00       	mov    $0xa7,%ecx
ffffffff8100d53a:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100d541:	48 c7 c6 cc de 01 81 	mov    $0xffffffff8101decc,%rsi
ffffffff8100d548:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100d54f:	31 c0                	xor    %eax,%eax
ffffffff8100d551:	e8 fa 49 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

    Sys_regs *s  = current->sys_regs();
    Pt       *pt = reinterpret_cast<Pt *>(s->ARG_1);
    current->oom_call(pt, s->ARG_2, s->ARG_3, oom_xcpu_return<ret_xcpu_reply_oom<C>>, sys_xcpu_call_oom<C>);
ffffffff8100d556:	48 8b 8f 10 01 00 00 	mov    0x110(%rdi),%rcx
ffffffff8100d55d:	48 8b 97 f0 00 00 00 	mov    0xf0(%rdi),%rdx
ffffffff8100d564:	49 c7 c1 1c d5 00 81 	mov    $0xffffffff8100d51c,%r9
ffffffff8100d56b:	48 8b b7 e8 00 00 00 	mov    0xe8(%rdi),%rsi
ffffffff8100d572:	49 c7 c0 00 9d 00 81 	mov    $0xffffffff81009d00,%r8
ffffffff8100d579:	e8 40 fb ff ff       	callq  ffffffff8100d0be <_ZN2Ec8oom_callEP2PtmmPFvvES3_>

ffffffff8100d57e <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvv>:
    current->cont = C;
    current->make_current();
}

template <void (*C)()>
void Ec::sys_xcpu_call_oom()
ffffffff8100d57e:	50                   	push   %rax
{
    assert (current->xcpu_sm);
ffffffff8100d57f:	48 8b 3d 82 1a ff 3e 	mov    0x3eff1a82(%rip),%rdi        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100d586:	48 83 bf 30 03 00 00 	cmpq   $0x0,0x330(%rdi)
ffffffff8100d58d:	00 
ffffffff8100d58e:	75 28                	jne    ffffffff8100d5b8 <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_11sys_sc_ctrlEvEEEEvv+0x3a>
ffffffff8100d590:	49 c7 c0 c0 f1 01 81 	mov    $0xffffffff8101f1c0,%r8
ffffffff8100d597:	b9 a7 00 00 00       	mov    $0xa7,%ecx
ffffffff8100d59c:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100d5a3:	48 c7 c6 cc de 01 81 	mov    $0xffffffff8101decc,%rsi
ffffffff8100d5aa:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100d5b1:	31 c0                	xor    %eax,%eax
ffffffff8100d5b3:	e8 98 49 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

    Sys_regs *s  = current->sys_regs();
    Pt       *pt = reinterpret_cast<Pt *>(s->ARG_1);
    current->oom_call(pt, s->ARG_2, s->ARG_3, oom_xcpu_return<ret_xcpu_reply_oom<C>>, sys_xcpu_call_oom<C>);
ffffffff8100d5b8:	48 8b 8f 10 01 00 00 	mov    0x110(%rdi),%rcx
ffffffff8100d5bf:	48 8b 97 f0 00 00 00 	mov    0xf0(%rdi),%rdx
ffffffff8100d5c6:	49 c7 c1 7e d5 00 81 	mov    $0xffffffff8100d57e,%r9
ffffffff8100d5cd:	48 8b b7 e8 00 00 00 	mov    0xe8(%rdi),%rsi
ffffffff8100d5d4:	49 c7 c0 52 a1 00 81 	mov    $0xffffffff8100a152,%r8
ffffffff8100d5db:	e8 de fa ff ff       	callq  ffffffff8100d0be <_ZN2Ec8oom_callEP2PtmmPFvvES3_>

ffffffff8100d5e0 <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvv>:
    current->cont = C;
    current->make_current();
}

template <void (*C)()>
void Ec::sys_xcpu_call_oom()
ffffffff8100d5e0:	50                   	push   %rax
{
    assert (current->xcpu_sm);
ffffffff8100d5e1:	48 8b 3d 20 1a ff 3e 	mov    0x3eff1a20(%rip),%rdi        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100d5e8:	48 83 bf 30 03 00 00 	cmpq   $0x0,0x330(%rdi)
ffffffff8100d5ef:	00 
ffffffff8100d5f0:	75 28                	jne    ffffffff8100d61a <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_11sys_pt_ctrlEvEEEEvv+0x3a>
ffffffff8100d5f2:	49 c7 c0 c0 ef 01 81 	mov    $0xffffffff8101efc0,%r8
ffffffff8100d5f9:	b9 a7 00 00 00       	mov    $0xa7,%ecx
ffffffff8100d5fe:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100d605:	48 c7 c6 cc de 01 81 	mov    $0xffffffff8101decc,%rsi
ffffffff8100d60c:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100d613:	31 c0                	xor    %eax,%eax
ffffffff8100d615:	e8 36 49 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

    Sys_regs *s  = current->sys_regs();
    Pt       *pt = reinterpret_cast<Pt *>(s->ARG_1);
    current->oom_call(pt, s->ARG_2, s->ARG_3, oom_xcpu_return<ret_xcpu_reply_oom<C>>, sys_xcpu_call_oom<C>);
ffffffff8100d61a:	48 8b 8f 10 01 00 00 	mov    0x110(%rdi),%rcx
ffffffff8100d621:	48 8b 97 f0 00 00 00 	mov    0xf0(%rdi),%rdx
ffffffff8100d628:	49 c7 c1 e0 d5 00 81 	mov    $0xffffffff8100d5e0,%r9
ffffffff8100d62f:	48 8b b7 e8 00 00 00 	mov    0xe8(%rdi),%rsi
ffffffff8100d636:	49 c7 c0 a4 a5 00 81 	mov    $0xffffffff8100a5a4,%r8
ffffffff8100d63d:	e8 7c fa ff ff       	callq  ffffffff8100d0be <_ZN2Ec8oom_callEP2PtmmPFvvES3_>

ffffffff8100d642 <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvv>:
    current->cont = C;
    current->make_current();
}

template <void (*C)()>
void Ec::sys_xcpu_call_oom()
ffffffff8100d642:	50                   	push   %rax
{
    assert (current->xcpu_sm);
ffffffff8100d643:	48 8b 3d be 19 ff 3e 	mov    0x3eff19be(%rip),%rdi        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100d64a:	48 83 bf 30 03 00 00 	cmpq   $0x0,0x330(%rdi)
ffffffff8100d651:	00 
ffffffff8100d652:	75 28                	jne    ffffffff8100d67c <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_11sys_pd_ctrlEvEEEEvv+0x3a>
ffffffff8100d654:	49 c7 c0 c0 ed 01 81 	mov    $0xffffffff8101edc0,%r8
ffffffff8100d65b:	b9 a7 00 00 00       	mov    $0xa7,%ecx
ffffffff8100d660:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100d667:	48 c7 c6 cc de 01 81 	mov    $0xffffffff8101decc,%rsi
ffffffff8100d66e:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100d675:	31 c0                	xor    %eax,%eax
ffffffff8100d677:	e8 d4 48 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

    Sys_regs *s  = current->sys_regs();
    Pt       *pt = reinterpret_cast<Pt *>(s->ARG_1);
    current->oom_call(pt, s->ARG_2, s->ARG_3, oom_xcpu_return<ret_xcpu_reply_oom<C>>, sys_xcpu_call_oom<C>);
ffffffff8100d67c:	48 8b 8f 10 01 00 00 	mov    0x110(%rdi),%rcx
ffffffff8100d683:	48 8b 97 f0 00 00 00 	mov    0xf0(%rdi),%rdx
ffffffff8100d68a:	49 c7 c1 42 d6 00 81 	mov    $0xffffffff8100d642,%r9
ffffffff8100d691:	48 8b b7 e8 00 00 00 	mov    0xe8(%rdi),%rsi
ffffffff8100d698:	49 c7 c0 f6 a9 00 81 	mov    $0xffffffff8100a9f6,%r8
ffffffff8100d69f:	e8 1a fa ff ff       	callq  ffffffff8100d0be <_ZN2Ec8oom_callEP2PtmmPFvvES3_>

ffffffff8100d6a4 <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvv>:
    current->cont = C;
    current->make_current();
}

template <void (*C)()>
void Ec::sys_xcpu_call_oom()
ffffffff8100d6a4:	50                   	push   %rax
{
    assert (current->xcpu_sm);
ffffffff8100d6a5:	48 8b 3d 5c 19 ff 3e 	mov    0x3eff195c(%rip),%rdi        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100d6ac:	48 83 bf 30 03 00 00 	cmpq   $0x0,0x330(%rdi)
ffffffff8100d6b3:	00 
ffffffff8100d6b4:	75 28                	jne    ffffffff8100d6de <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_14sys_assign_gsiEvEEEEvv+0x3a>
ffffffff8100d6b6:	49 c7 c0 c0 eb 01 81 	mov    $0xffffffff8101ebc0,%r8
ffffffff8100d6bd:	b9 a7 00 00 00       	mov    $0xa7,%ecx
ffffffff8100d6c2:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100d6c9:	48 c7 c6 cc de 01 81 	mov    $0xffffffff8101decc,%rsi
ffffffff8100d6d0:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100d6d7:	31 c0                	xor    %eax,%eax
ffffffff8100d6d9:	e8 72 48 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

    Sys_regs *s  = current->sys_regs();
    Pt       *pt = reinterpret_cast<Pt *>(s->ARG_1);
    current->oom_call(pt, s->ARG_2, s->ARG_3, oom_xcpu_return<ret_xcpu_reply_oom<C>>, sys_xcpu_call_oom<C>);
ffffffff8100d6de:	48 8b 8f 10 01 00 00 	mov    0x110(%rdi),%rcx
ffffffff8100d6e5:	48 8b 97 f0 00 00 00 	mov    0xf0(%rdi),%rdx
ffffffff8100d6ec:	49 c7 c1 a4 d6 00 81 	mov    $0xffffffff8100d6a4,%r9
ffffffff8100d6f3:	48 8b b7 e8 00 00 00 	mov    0xe8(%rdi),%rsi
ffffffff8100d6fa:	49 c7 c0 48 ae 00 81 	mov    $0xffffffff8100ae48,%r8
ffffffff8100d701:	e8 b8 f9 ff ff       	callq  ffffffff8100d0be <_ZN2Ec8oom_callEP2PtmmPFvvES3_>

ffffffff8100d706 <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_14sys_assign_pciEvEEEEvv>:
    current->cont = C;
    current->make_current();
}

template <void (*C)()>
void Ec::sys_xcpu_call_oom()
ffffffff8100d706:	50                   	push   %rax
{
    assert (current->xcpu_sm);
ffffffff8100d707:	48 8b 3d fa 18 ff 3e 	mov    0x3eff18fa(%rip),%rdi        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100d70e:	48 83 bf 30 03 00 00 	cmpq   $0x0,0x330(%rdi)
ffffffff8100d715:	00 
ffffffff8100d716:	75 28                	jne    ffffffff8100d740 <_ZN2Ec17sys_xcpu_call_oomIXadL_ZNS_14sys_assign_pciEvEEEEvv+0x3a>
ffffffff8100d718:	49 c7 c0 c0 e9 01 81 	mov    $0xffffffff8101e9c0,%r8
ffffffff8100d71f:	b9 a7 00 00 00       	mov    $0xa7,%ecx
ffffffff8100d724:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100d72b:	48 c7 c6 cc de 01 81 	mov    $0xffffffff8101decc,%rsi
ffffffff8100d732:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100d739:	31 c0                	xor    %eax,%eax
ffffffff8100d73b:	e8 10 48 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

    Sys_regs *s  = current->sys_regs();
    Pt       *pt = reinterpret_cast<Pt *>(s->ARG_1);
    current->oom_call(pt, s->ARG_2, s->ARG_3, oom_xcpu_return<ret_xcpu_reply_oom<C>>, sys_xcpu_call_oom<C>);
ffffffff8100d740:	48 8b 8f 10 01 00 00 	mov    0x110(%rdi),%rcx
ffffffff8100d747:	48 8b 97 f0 00 00 00 	mov    0xf0(%rdi),%rdx
ffffffff8100d74e:	49 c7 c1 06 d7 00 81 	mov    $0xffffffff8100d706,%r9
ffffffff8100d755:	48 8b b7 e8 00 00 00 	mov    0xe8(%rdi),%rsi
ffffffff8100d75c:	49 c7 c0 9a b2 00 81 	mov    $0xffffffff8100b29a,%r8
ffffffff8100d763:	e8 56 f9 ff ff       	callq  ffffffff8100d0be <_ZN2Ec8oom_callEP2PtmmPFvvES3_>

ffffffff8100d768 <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm>:
    ec->regs.set_ip (pt->ip);
    ec->make_current();
}

template <void (*C)()>
void Ec::oom_xcpu(Pt * pt, mword src_pd_id, mword oom_state)
ffffffff8100d768:	41 56                	push   %r14
ffffffff8100d76a:	41 55                	push   %r13
ffffffff8100d76c:	41 54                	push   %r12
ffffffff8100d76e:	55                   	push   %rbp
ffffffff8100d76f:	53                   	push   %rbx
ffffffff8100d770:	48 83 ec 10          	sub    $0x10,%rsp
{
    assert(current == this);
ffffffff8100d774:	48 8b 2d 8d 18 ff 3e 	mov    0x3eff188d(%rip),%rbp        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100d77b:	48 39 fd             	cmp    %rdi,%rbp
ffffffff8100d77e:	74 1c                	je     ffffffff8100d79c <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x34>
ffffffff8100d780:	49 c7 c0 40 fd 01 81 	mov    $0xffffffff8101fd40,%r8
ffffffff8100d787:	b9 72 00 00 00       	mov    $0x72,%ecx
ffffffff8100d78c:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100d793:	48 c7 c6 6a e7 01 81 	mov    $0xffffffff8101e76a,%rsi
ffffffff8100d79a:	eb 24                	jmp    ffffffff8100d7c0 <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x58>
    assert(!this->xcpu_sm);
ffffffff8100d79c:	48 83 bd 30 03 00 00 	cmpq   $0x0,0x330(%rbp)
ffffffff8100d7a3:	00 
ffffffff8100d7a4:	74 28                	je     ffffffff8100d7ce <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x66>
ffffffff8100d7a6:	49 c7 c0 40 fd 01 81 	mov    $0xffffffff8101fd40,%r8
ffffffff8100d7ad:	b9 73 00 00 00       	mov    $0x73,%ecx
ffffffff8100d7b2:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100d7b9:	48 c7 c6 7a e7 01 81 	mov    $0xffffffff8101e77a,%rsi
ffffffff8100d7c0:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100d7c7:	31 c0                	xor    %eax,%eax
ffffffff8100d7c9:	e8 82 47 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

    enum { UNUSED = 0, CNT = 0 };

    this->xcpu_sm = new (Pd::current->quota) Sm (Pd::current, UNUSED, CNT);
ffffffff8100d7ce:	48 8b 05 3b 18 ff 3e 	mov    0x3eff183b(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100d7d5:	49 89 f4             	mov    %rsi,%r12

            call_rcu(true);
        }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
ffffffff8100d7d8:	48 c7 c7 80 40 16 81 	mov    $0xffffffff81164080,%rdi
ffffffff8100d7df:	49 89 d6             	mov    %rdx,%r14
ffffffff8100d7e2:	49 89 cd             	mov    %rcx,%r13
ffffffff8100d7e5:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff8100d7ec:	e8 3d 81 00 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff8100d7f1:	48 8b 35 18 18 ff 3e 	mov    0x3eff1818(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100d7f8:	48 89 c3             	mov    %rax,%rbx
ffffffff8100d7fb:	45 31 c9             	xor    %r9d,%r9d
ffffffff8100d7fe:	31 c9                	xor    %ecx,%ecx
ffffffff8100d800:	31 d2                	xor    %edx,%edx
ffffffff8100d802:	45 31 c0             	xor    %r8d,%r8d
ffffffff8100d805:	48 89 c7             	mov    %rax,%rdi
ffffffff8100d808:	e8 55 87 00 00       	callq  ffffffff81015f62 <_ZN2SmC1EP2PdmmPS_m>
ffffffff8100d80d:	48 89 9d 30 03 00 00 	mov    %rbx,0x330(%rbp)

    Ec *xcpu_ec = new (Pd::current->quota) Ec (Pd::current, Pd::current, sys_xcpu_call_oom<C>, pt->ec->cpu, this);
ffffffff8100d814:	49 8b 84 24 90 00 00 	mov    0x90(%r12),%rax
ffffffff8100d81b:	00 

    static void idl_handler();

    ALWAYS_INLINE
    static inline void *operator new (size_t, Quota &quota) {
        return cache.alloc(quota);
ffffffff8100d81c:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff8100d823:	44 0f b7 80 f0 02 00 	movzwl 0x2f0(%rax),%r8d
ffffffff8100d82a:	00 
ffffffff8100d82b:	48 8b 05 de 17 ff 3e 	mov    0x3eff17de(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100d832:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff8100d839:	44 89 44 24 0c       	mov    %r8d,0xc(%rsp)
ffffffff8100d83e:	e8 eb 80 00 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff8100d843:	48 8b 35 c6 17 ff 3e 	mov    0x3eff17c6(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100d84a:	44 8b 44 24 0c       	mov    0xc(%rsp),%r8d
ffffffff8100d84f:	49 89 e9             	mov    %rbp,%r9
ffffffff8100d852:	48 c7 c1 94 d3 00 81 	mov    $0xffffffff8100d394,%rcx
ffffffff8100d859:	48 89 c7             	mov    %rax,%rdi
ffffffff8100d85c:	48 89 c3             	mov    %rax,%rbx
ffffffff8100d85f:	48 89 f2             	mov    %rsi,%rdx
ffffffff8100d862:	e8 b7 69 ff ff       	callq  ffffffff8100421e <_ZN2EcC1EP2PdS1_PFvvEjPS_>
    xcpu_ec->regs.set_pt (reinterpret_cast<mword>(pt), src_pd_id, oom_state);

    Sc *xcpu_sc = new (Pd::current->quota) Sc (Pd::current, xcpu_ec, xcpu_ec->cpu, Sc::current);
ffffffff8100d867:	48 8b 05 a2 17 ff 3e 	mov    0x3eff17a2(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>

        ALWAYS_INLINE
        inline void set_pt (mword pt) { ARG_1 = pt; }

        ALWAYS_INLINE
        inline void set_pt (mword pt, mword pt2, mword s) { ARG_1 = pt; ARG_2 = pt2; ARG_3 = s; }
ffffffff8100d86e:	4c 89 a3 e8 00 00 00 	mov    %r12,0xe8(%rbx)

        NORETURN
        static void schedule (bool = false, bool = true);

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
ffffffff8100d875:	48 c7 c7 40 40 16 81 	mov    $0xffffffff81164040,%rdi
ffffffff8100d87c:	4c 89 b3 f0 00 00 00 	mov    %r14,0xf0(%rbx)
ffffffff8100d883:	4c 89 ab 10 01 00 00 	mov    %r13,0x110(%rbx)
ffffffff8100d88a:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff8100d891:	e8 98 80 00 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff8100d896:	0f b7 8b f0 02 00 00 	movzwl 0x2f0(%rbx),%ecx
ffffffff8100d89d:	4c 8b 05 74 17 ff 3e 	mov    0x3eff1774(%rip),%r8        # ffffffffbffff018 <_ZN2Sc7currentE>
ffffffff8100d8a4:	49 89 c4             	mov    %rax,%r12
ffffffff8100d8a7:	48 8b 35 62 17 ff 3e 	mov    0x3eff1762(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100d8ae:	48 89 da             	mov    %rbx,%rdx
ffffffff8100d8b1:	48 89 c7             	mov    %rax,%rdi
ffffffff8100d8b4:	e8 19 6e 00 00       	callq  ffffffff810146d2 <_ZN2ScC1EP2PdP2EcjPS_>

    xcpu_sc->remote_enqueue();
ffffffff8100d8b9:	4c 89 e7             	mov    %r12,%rdi
ffffffff8100d8bc:	e8 9f 71 00 00       	callq  ffffffff81014a60 <_ZN2Sc14remote_enqueueEv>
    this->xcpu_sm->dn (false, 0);
ffffffff8100d8c1:	48 8b ad 30 03 00 00 	mov    0x330(%rbp),%rbp
ffffffff8100d8c8:	48 8b 1d 39 17 ff 3e 	mov    0x3eff1739(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>
        }

        ALWAYS_INLINE
        inline void dn (bool zero, uint64 t, Ec *ec = Ec::current, bool block = true)
        {
            {   Lock_guard <Spinlock> guard (lock);
ffffffff8100d8cf:	48 8d bd 8a 00 00 00 	lea    0x8a(%rbp),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff8100d8d6:	9c                   	pushfq 
ffffffff8100d8d7:	41 5c                	pop    %r12
            return flags & 0x200;
ffffffff8100d8d9:	49 c1 ec 09          	shr    $0x9,%r12

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8100d8dd:	41 80 e4 01          	and    $0x1,%r12b
ffffffff8100d8e1:	74 30                	je     ffffffff8100d913 <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x1ab>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff8100d8e3:	80 3d 46 1e ff 3e 00 	cmpb   $0x0,0x3eff1e46(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100d8ea:	75 1f                	jne    ffffffff8100d90b <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x1a3>
ffffffff8100d8ec:	49 c7 c0 40 fb 01 81 	mov    $0xffffffff8101fb40,%r8
ffffffff8100d8f3:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff8100d8f8:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100d8ff:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff8100d906:	e9 b5 fe ff ff       	jmpq   ffffffff8100d7c0 <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x58>

            asm volatile ("cli" : : : "memory");
ffffffff8100d90b:	fa                   	cli    
            preemption = false;
ffffffff8100d90c:	c6 05 1d 1e ff 3e 00 	movb   $0x0,0x3eff1e1d(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff8100d913:	e8 76 35 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>

                if (counter) {
ffffffff8100d918:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff8100d91f:	48 85 c0             	test   %rax,%rax
ffffffff8100d922:	0f 84 aa 00 00 00    	je     ffffffff8100d9d2 <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x26a>
                    counter = zero ? 0 : counter - 1;
ffffffff8100d928:	48 ff c8             	dec    %rax
ffffffff8100d92b:	48 89 85 c0 00 00 00 	mov    %rax,0xc0(%rbp)
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff8100d932:	48 8b 85 98 00 00 00 	mov    0x98(%rbp),%rax
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff8100d939:	48 85 c0             	test   %rax,%rax
ffffffff8100d93c:	0f 84 24 01 00 00    	je     ffffffff8100da66 <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x2fe>
ffffffff8100d942:	48 8b 50 10          	mov    0x10(%rax),%rdx
ffffffff8100d946:	48 85 d2             	test   %rdx,%rdx
ffffffff8100d949:	0f 84 17 01 00 00    	je     ffffffff8100da66 <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x2fe>
ffffffff8100d94f:	48 8b 48 08          	mov    0x8(%rax),%rcx
ffffffff8100d953:	48 85 c9             	test   %rcx,%rcx
ffffffff8100d956:	0f 84 0a 01 00 00    	je     ffffffff8100da66 <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x2fe>
                return false;

            if (t == t->next)
ffffffff8100d95c:	48 39 d0             	cmp    %rdx,%rax
ffffffff8100d95f:	75 0d                	jne    ffffffff8100d96e <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x206>
                headptr = nullptr;
ffffffff8100d961:	48 c7 85 98 00 00 00 	movq   $0x0,0x98(%rbp)
ffffffff8100d968:	00 00 00 00 
ffffffff8100d96c:	eb 24                	jmp    ffffffff8100d992 <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x22a>

            else {
                t->next->prev = t->prev;
ffffffff8100d96e:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
                t->prev->next = t->next;
ffffffff8100d972:	48 8b 50 08          	mov    0x8(%rax),%rdx
ffffffff8100d976:	48 8b 48 10          	mov    0x10(%rax),%rcx
ffffffff8100d97a:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
                if (t == headptr)
ffffffff8100d97e:	48 3b 85 98 00 00 00 	cmp    0x98(%rbp),%rax
ffffffff8100d985:	75 0b                	jne    ffffffff8100d992 <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x22a>
                    headptr = t->next;
ffffffff8100d987:	48 8b 50 10          	mov    0x10(%rax),%rdx
ffffffff8100d98b:	48 89 95 98 00 00 00 	mov    %rdx,0x98(%rbp)

    public:

        mword reset(bool l = false) {
            if (l) lock.lock();
            mword c = counter;
ffffffff8100d992:	48 8b 50 20          	mov    0x20(%rax),%rdx
            }

            t->next = t->prev = nullptr;
ffffffff8100d996:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
ffffffff8100d99d:	00 
ffffffff8100d99e:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
ffffffff8100d9a5:	00 
            counter = 0;
ffffffff8100d9a6:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
ffffffff8100d9ad:	00 
                if (counter) {
                    counter = zero ? 0 : counter - 1;

                    Si * si;
                    if (Queue<Si>::dequeue(si = Queue<Si>::head()))
                        ec->set_si_regs(si->value, static_cast <Sm *>(si)->reset());
ffffffff8100d9ae:	48 8b 40 18          	mov    0x18(%rax),%rax
    }

    ALWAYS_INLINE
    inline void set_si_regs(mword sig, mword cnt) {
        regs.ARG_2 = sig;
        regs.ARG_3 = cnt;
ffffffff8100d9b2:	48 89 93 10 01 00 00 	mov    %rdx,0x110(%rbx)
            timeout.dequeue();
    }

    ALWAYS_INLINE
    inline void set_si_regs(mword sig, mword cnt) {
        regs.ARG_2 = sig;
ffffffff8100d9b9:	48 89 83 f0 00 00 00 	mov    %rax,0xf0(%rbx)
ffffffff8100d9c0:	e9 a1 00 00 00       	jmpq   ffffffff8100da66 <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x2fe>
ffffffff8100d9c5:	8d 50 01             	lea    0x1(%rax),%edx
ffffffff8100d9c8:	f0 0f b1 93 8c 00 00 	lock cmpxchg %edx,0x8c(%rbx)
ffffffff8100d9cf:	00 
ffffffff8100d9d0:	74 0a                	je     ffffffff8100d9dc <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x274>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100d9d2:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff8100d9d8:	85 c0                	test   %eax,%eax
ffffffff8100d9da:	75 e9                	jne    ffffffff8100d9c5 <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x25d>
        inline T *head() const { return headptr; }

        ALWAYS_INLINE
        inline void enqueue (T *t)
        {
            if (!headptr)
ffffffff8100d9dc:	48 8b 85 90 00 00 00 	mov    0x90(%rbp),%rax
ffffffff8100d9e3:	48 85 c0             	test   %rax,%rax
ffffffff8100d9e6:	75 17                	jne    ffffffff8100d9ff <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x297>
                headptr = t->prev = t->next = t;
ffffffff8100d9e8:	48 89 9b b0 02 00 00 	mov    %rbx,0x2b0(%rbx)
ffffffff8100d9ef:	48 89 9b a8 02 00 00 	mov    %rbx,0x2a8(%rbx)
ffffffff8100d9f6:	48 89 9d 90 00 00 00 	mov    %rbx,0x90(%rbp)
ffffffff8100d9fd:	eb 2a                	jmp    ffffffff8100da29 <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x2c1>
            else {
                t->next = headptr;
ffffffff8100d9ff:	48 89 83 b0 02 00 00 	mov    %rax,0x2b0(%rbx)
                t->prev = headptr->prev;
ffffffff8100da06:	48 8b 95 90 00 00 00 	mov    0x90(%rbp),%rdx
ffffffff8100da0d:	48 8b 92 a8 02 00 00 	mov    0x2a8(%rdx),%rdx
ffffffff8100da14:	48 89 93 a8 02 00 00 	mov    %rdx,0x2a8(%rbx)
                t->next->prev = t->prev->next = t;
ffffffff8100da1b:	48 89 9a b0 02 00 00 	mov    %rbx,0x2b0(%rdx)
ffffffff8100da22:	48 89 98 a8 02 00 00 	mov    %rbx,0x2a8(%rax)
ffffffff8100da29:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff8100da2f:	45 84 e4             	test   %r12b,%r12b
ffffffff8100da32:	74 50                	je     ffffffff8100da84 <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x31c>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100da34:	80 3d f5 1c ff 3e 00 	cmpb   $0x0,0x3eff1cf5(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100da3b:	74 1f                	je     ffffffff8100da5c <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x2f4>
ffffffff8100da3d:	49 c7 c0 10 fb 01 81 	mov    $0xffffffff8101fb10,%r8
ffffffff8100da44:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff8100da49:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100da50:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff8100da57:	e9 64 fd ff ff       	jmpq   ffffffff8100d7c0 <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x58>

            preemption = true;
ffffffff8100da5c:	c6 05 cd 1c ff 3e 01 	movb   $0x1,0x3eff1ccd(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100da63:	fb                   	sti    
ffffffff8100da64:	eb 1e                	jmp    ffffffff8100da84 <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x31c>
ffffffff8100da66:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
ffffffff8100da6c:	45 84 e4             	test   %r12b,%r12b
ffffffff8100da6f:	74 1b                	je     ffffffff8100da8c <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x324>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100da71:	80 3d b8 1c ff 3e 00 	cmpb   $0x0,0x3eff1cb8(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100da78:	75 c3                	jne    ffffffff8100da3d <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x2d5>

            preemption = true;
ffffffff8100da7a:	c6 05 af 1c ff 3e 01 	movb   $0x1,0x3eff1caf(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100da81:	fb                   	sti    
ffffffff8100da82:	eb 08                	jmp    ffffffff8100da8c <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm+0x324>
            if (!block)
                Sc::schedule (false);

            ec->set_timeout (t, this);

            ec->block_sc();
ffffffff8100da84:	48 89 df             	mov    %rbx,%rdi
ffffffff8100da87:	e8 e2 dc ff ff       	callq  ffffffff8100b76e <_ZN2Ec8block_scEv>

    die ("XCPU OOM error");
ffffffff8100da8c:	48 8b 05 75 15 ff 3e 	mov    0x3eff1575(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100da93:	48 c7 c7 89 e7 01 81 	mov    $0xffffffff8101e789,%rdi
ffffffff8100da9a:	48 8d b0 a8 00 00 00 	lea    0xa8(%rax),%rsi
ffffffff8100daa1:	e8 64 71 ff ff       	callq  ffffffff81004c0a <_ZN2Ec3dieEPKcP8Exc_regs>

ffffffff8100daa6 <_ZN2Ec12oom_delegateEPS_S0_S0_bb>:
#include "pt.hpp"
#include "utcb.hpp"
#include "sm.hpp"

void Ec::oom_delegate(Ec * dst_ec, Ec * rep_ec, Ec * src_ec, bool user, bool C)
{
ffffffff8100daa6:	41 57                	push   %r15
ffffffff8100daa8:	41 56                	push   %r14
ffffffff8100daaa:	48 89 f0             	mov    %rsi,%rax
ffffffff8100daad:	41 55                	push   %r13
ffffffff8100daaf:	41 54                	push   %r12
ffffffff8100dab1:	49 89 ca             	mov    %rcx,%r10
ffffffff8100dab4:	55                   	push   %rbp
ffffffff8100dab5:	53                   	push   %rbx
ffffffff8100dab6:	48 83 ec 18          	sub    $0x18,%rsp
    Pt * const dst_pt = dst_ec->pt_oom;
ffffffff8100daba:	4c 8b ae 38 03 00 00 	mov    0x338(%rsi),%r13
    Pt * const src_pt = src_ec->pt_oom;
ffffffff8100dac1:	4c 8b b9 38 03 00 00 	mov    0x338(%rcx),%r15

    if (!dst_pt) {
ffffffff8100dac8:	4d 85 ed             	test   %r13,%r13
ffffffff8100dacb:	75 32                	jne    ffffffff8100daff <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x59>
{
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
ffffffff8100dacd:	48 8b b6 98 02 00 00 	mov    0x298(%rsi),%rsi
        dst_ec->pd->quota.dump(dst_ec->pd);
ffffffff8100dad4:	ba 01 00 00 00       	mov    $0x1,%edx
ffffffff8100dad9:	48 8d be 08 03 00 00 	lea    0x308(%rsi),%rdi
ffffffff8100dae0:	e8 cd 3c ff ff       	callq  ffffffff810017b2 <_ZN5Quota4dumpEPvb>
        die ("PT not found - OOM");
ffffffff8100dae5:	48 8b 05 1c 15 ff 3e 	mov    0x3eff151c(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100daec:	48 c7 c7 98 e7 01 81 	mov    $0xffffffff8101e798,%rdi
ffffffff8100daf3:	48 8d b0 a8 00 00 00 	lea    0xa8(%rax),%rsi
ffffffff8100dafa:	e9 03 02 00 00       	jmpq   ffffffff8100dd02 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x25c>
    }

    if (user) {
ffffffff8100daff:	45 84 c0             	test   %r8b,%r8b
ffffffff8100db02:	48 89 d3             	mov    %rdx,%rbx
ffffffff8100db05:	45 89 cc             	mov    %r9d,%r12d
ffffffff8100db08:	0f 84 ac 00 00 00    	je     ffffffff8100dbba <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x114>
        if (C) {
ffffffff8100db0e:	45 84 c9             	test   %r9b,%r9b
ffffffff8100db11:	74 40                	je     ffffffff8100db53 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0xad>
             assert (rep_ec->cont == ret_user_sysexit || rep_ec->cont == xcpu_return);
ffffffff8100db13:	48 8b 92 a0 00 00 00 	mov    0xa0(%rdx),%rdx
ffffffff8100db1a:	48 81 fa 00 00 00 81 	cmp    $0xffffffff81000000,%rdx
ffffffff8100db21:	0f 84 b7 02 00 00    	je     ffffffff8100ddde <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x338>
ffffffff8100db27:	48 81 fa 76 53 00 81 	cmp    $0xffffffff81005376,%rdx
ffffffff8100db2e:	0f 84 aa 02 00 00    	je     ffffffff8100ddde <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x338>
ffffffff8100db34:	49 c7 c0 b0 fd 01 81 	mov    $0xffffffff8101fdb0,%r8
ffffffff8100db3b:	b9 24 00 00 00       	mov    $0x24,%ecx
ffffffff8100db40:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100db47:	48 c7 c6 1e e8 01 81 	mov    $0xffffffff8101e81e,%rsi
ffffffff8100db4e:	e9 d2 02 00 00       	jmpq   ffffffff8100de25 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x37f>
             assert (dst_ec->cont == recv_user);
        } else 
             assert (dst_ec->cont == ret_user_sysexit || dst_ec->cont == xcpu_return);
ffffffff8100db53:	48 8b 96 a0 00 00 00 	mov    0xa0(%rsi),%rdx
ffffffff8100db5a:	48 81 fa 00 00 00 81 	cmp    $0xffffffff81000000,%rdx
ffffffff8100db61:	74 0d                	je     ffffffff8100db70 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0xca>
ffffffff8100db63:	48 81 fa 76 53 00 81 	cmp    $0xffffffff81005376,%rdx
ffffffff8100db6a:	0f 85 9b 02 00 00    	jne    ffffffff8100de0b <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x365>

        assert(dst_ec->utcb);
ffffffff8100db70:	48 8b 90 90 02 00 00 	mov    0x290(%rax),%rdx
ffffffff8100db77:	48 85 d2             	test   %rdx,%rdx
ffffffff8100db7a:	75 1f                	jne    ffffffff8100db9b <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0xf5>
ffffffff8100db7c:	49 c7 c0 b0 fd 01 81 	mov    $0xffffffff8101fdb0,%r8
ffffffff8100db83:	b9 29 00 00 00       	mov    $0x29,%ecx
ffffffff8100db88:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100db8f:	48 c7 c6 c5 e7 01 81 	mov    $0xffffffff8101e7c5,%rsi
ffffffff8100db96:	e9 8a 02 00 00       	jmpq   ffffffff8100de25 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x37f>

        dst_ec->pd->rev_crd (dst_ec->utcb->del, true, false, false);
ffffffff8100db9b:	48 8b 72 10          	mov    0x10(%rdx),%rsi
ffffffff8100db9f:	48 8b b8 98 02 00 00 	mov    0x298(%rax),%rdi
ffffffff8100dba6:	45 31 c0             	xor    %r8d,%r8d
ffffffff8100dba9:	31 c9                	xor    %ecx,%ecx
ffffffff8100dbab:	ba 01 00 00 00       	mov    $0x1,%edx
ffffffff8100dbb0:	e8 59 36 00 00       	callq  ffffffff8101120e <_ZN2Pd7rev_crdE3Crdbbb>
ffffffff8100dbb5:	e9 a0 00 00 00       	jmpq   ffffffff8100dc5a <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x1b4>
    } else {
        assert(!C);
ffffffff8100dbba:	45 84 c9             	test   %r9b,%r9b
ffffffff8100dbbd:	74 1f                	je     ffffffff8100dbde <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x138>
ffffffff8100dbbf:	49 c7 c0 b0 fd 01 81 	mov    $0xffffffff8101fdb0,%r8
ffffffff8100dbc6:	b9 2d 00 00 00       	mov    $0x2d,%ecx
ffffffff8100dbcb:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100dbd2:	48 c7 c6 d2 e7 01 81 	mov    $0xffffffff8101e7d2,%rsi
ffffffff8100dbd9:	e9 47 02 00 00       	jmpq   ffffffff8100de25 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x37f>
        assert(src_ec->utcb);
ffffffff8100dbde:	48 8b 81 90 02 00 00 	mov    0x290(%rcx),%rax
ffffffff8100dbe5:	48 85 c0             	test   %rax,%rax
ffffffff8100dbe8:	75 1f                	jne    ffffffff8100dc09 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x163>
ffffffff8100dbea:	49 c7 c0 b0 fd 01 81 	mov    $0xffffffff8101fdb0,%r8
ffffffff8100dbf1:	b9 2e 00 00 00       	mov    $0x2e,%ecx
ffffffff8100dbf6:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100dbfd:	48 c7 c6 d5 e7 01 81 	mov    $0xffffffff8101e7d5,%rsi
ffffffff8100dc04:	e9 a3 01 00 00       	jmpq   ffffffff8100ddac <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x306>
        WARN_UNUSED_RESULT bool save_exc (Cpu_regs *);
        WARN_UNUSED_RESULT bool save_vmx (Cpu_regs *);
        WARN_UNUSED_RESULT bool save_svm (Cpu_regs *);

        inline mword ucnt() const { return static_cast<uint16>(items); }
        inline mword tcnt() const { return static_cast<uint16>(items >> 16); }
ffffffff8100dc09:	0f b7 68 02          	movzwl 0x2(%rax),%ebp
                dst->mr[i] = mr[i];
#endif
        }

        ALWAYS_INLINE
        inline Xfer *xfer() { return reinterpret_cast<Xfer *>(this) + PAGE_SIZE / sizeof (Xfer) - 1; }
ffffffff8100dc0d:	4c 8d b0 f0 0f 00 00 	lea    0xff0(%rax),%r14
ffffffff8100dc14:	b8 fe 00 00 00       	mov    $0xfe,%eax
ffffffff8100dc19:	48 81 fd fe 00 00 00 	cmp    $0xfe,%rbp
ffffffff8100dc20:	48 0f 47 e8          	cmova  %rax,%rbp

        Xfer *s = src_ec->utcb->xfer();
        for (unsigned long ti = src_ec->utcb->ti(); ti--; s--) {
ffffffff8100dc24:	48 ff cd             	dec    %rbp
ffffffff8100dc27:	48 83 fd ff          	cmp    $0xffffffffffffffff,%rbp
ffffffff8100dc2b:	74 2d                	je     ffffffff8100dc5a <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x1b4>
            if ((s->flags() >> 8) & 1)
ffffffff8100dc2d:	41 f6 46 09 01       	testb  $0x1,0x9(%r14)
ffffffff8100dc32:	75 20                	jne    ffffffff8100dc54 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x1ae>
                continue;
            src_ec->pd->rev_crd (*s, false, false, false);
ffffffff8100dc34:	49 8b ba 98 02 00 00 	mov    0x298(%r10),%rdi
ffffffff8100dc3b:	49 8b 36             	mov    (%r14),%rsi
ffffffff8100dc3e:	45 31 c0             	xor    %r8d,%r8d
ffffffff8100dc41:	31 c9                	xor    %ecx,%ecx
ffffffff8100dc43:	31 d2                	xor    %edx,%edx
ffffffff8100dc45:	4c 89 54 24 08       	mov    %r10,0x8(%rsp)
ffffffff8100dc4a:	e8 bf 35 00 00       	callq  ffffffff8101120e <_ZN2Pd7rev_crdE3Crdbbb>
ffffffff8100dc4f:	4c 8b 54 24 08       	mov    0x8(%rsp),%r10
    } else {
        assert(!C);
        assert(src_ec->utcb);

        Xfer *s = src_ec->utcb->xfer();
        for (unsigned long ti = src_ec->utcb->ti(); ti--; s--) {
ffffffff8100dc54:	49 83 ee 10          	sub    $0x10,%r14
ffffffff8100dc58:	eb ca                	jmp    ffffffff8100dc24 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x17e>
                continue;
            src_ec->pd->rev_crd (*s, false, false, false);
        }
    }

    mword src_pd_id = !src_pt ? ~0UL : 0;
ffffffff8100dc5a:	48 83 ca ff          	or     $0xffffffffffffffff,%rdx
ffffffff8100dc5e:	4d 85 ff             	test   %r15,%r15
ffffffff8100dc61:	49 8b 85 90 00 00 00 	mov    0x90(%r13),%rax
ffffffff8100dc68:	0f 85 c5 01 00 00    	jne    ffffffff8100de33 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x38d>

    Ec * const ec = dst_pt->ec;

    enum { OOM_SEND = 1, OOM_REPLY = 2, OOM_SELF = 4 };

    mword oom_state = C ? OOM_SEND : OOM_REPLY;
ffffffff8100dc6e:	41 80 fc 01          	cmp    $0x1,%r12b
    if (EXPECT_FALSE (current == ec))
ffffffff8100dc72:	48 8b 3d 8f 13 ff 3e 	mov    0x3eff138f(%rip),%rdi        # ffffffffbffff008 <_ZN2Ec7currentE>

    Ec * const ec = dst_pt->ec;

    enum { OOM_SEND = 1, OOM_REPLY = 2, OOM_SELF = 4 };

    mword oom_state = C ? OOM_SEND : OOM_REPLY;
ffffffff8100dc79:	48 19 c9             	sbb    %rcx,%rcx
ffffffff8100dc7c:	48 f7 d1             	not    %rcx
    if (EXPECT_FALSE (current == ec))
        oom_state += OOM_SELF;
ffffffff8100dc7f:	48 8d 71 06          	lea    0x6(%rcx),%rsi

    Ec * const ec = dst_pt->ec;

    enum { OOM_SEND = 1, OOM_REPLY = 2, OOM_SELF = 4 };

    mword oom_state = C ? OOM_SEND : OOM_REPLY;
ffffffff8100dc83:	48 83 c1 02          	add    $0x2,%rcx
    if (EXPECT_FALSE (current == ec))
        oom_state += OOM_SELF;
ffffffff8100dc87:	48 39 c7             	cmp    %rax,%rdi
ffffffff8100dc8a:	48 0f 44 ce          	cmove  %rsi,%rcx

    if (!C && current->cpu != ec->xcpu) {
ffffffff8100dc8e:	45 84 e4             	test   %r12b,%r12b
ffffffff8100dc91:	0f b7 b7 f0 02 00 00 	movzwl 0x2f0(%rdi),%esi
ffffffff8100dc98:	75 39                	jne    ffffffff8100dcd3 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x22d>
ffffffff8100dc9a:	3b b0 f0 02 00 00    	cmp    0x2f0(%rax),%esi
ffffffff8100dca0:	74 31                	je     ffffffff8100dcd3 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x22d>
        assert (!current->partner);
ffffffff8100dca2:	48 83 bf a0 02 00 00 	cmpq   $0x0,0x2a0(%rdi)
ffffffff8100dca9:	00 
ffffffff8100dcaa:	74 1f                	je     ffffffff8100dccb <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x225>
ffffffff8100dcac:	49 c7 c0 b0 fd 01 81 	mov    $0xffffffff8101fdb0,%r8
ffffffff8100dcb3:	b9 45 00 00 00       	mov    $0x45,%ecx
ffffffff8100dcb8:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100dcbf:	48 c7 c6 e2 e7 01 81 	mov    $0xffffffff8101e7e2,%rsi
ffffffff8100dcc6:	e9 5a 01 00 00       	jmpq   ffffffff8100de25 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x37f>
        current->oom_xcpu<Ec::sys_reply>(dst_pt, src_pd_id, oom_state);
ffffffff8100dccb:	4c 89 ee             	mov    %r13,%rsi
ffffffff8100dcce:	e8 95 fa ff ff       	callq  ffffffff8100d768 <_ZN2Ec8oom_xcpuIXadL_ZNS_9sys_replyEvEEEEvP2Ptmm>
    }

    if (EXPECT_FALSE (current->cpu != ec->xcpu) || (current->cont == xcpu_return) || (current->cont == ret_xcpu_reply))
ffffffff8100dcd3:	3b b0 f0 02 00 00    	cmp    0x2f0(%rax),%esi
ffffffff8100dcd9:	75 19                	jne    ffffffff8100dcf4 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x24e>
ffffffff8100dcdb:	48 8b b7 a0 00 00 00 	mov    0xa0(%rdi),%rsi
ffffffff8100dce2:	48 81 fe 76 53 00 81 	cmp    $0xffffffff81005376,%rsi
ffffffff8100dce9:	74 09                	je     ffffffff8100dcf4 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x24e>
ffffffff8100dceb:	48 81 fe 34 72 01 81 	cmp    $0xffffffff81017234,%rsi
ffffffff8100dcf2:	75 13                	jne    ffffffff8100dd07 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x261>
        die ("PT wrong CPU - OOM");
ffffffff8100dcf4:	48 8d b7 a8 00 00 00 	lea    0xa8(%rdi),%rsi
ffffffff8100dcfb:	48 c7 c7 f4 e7 01 81 	mov    $0xffffffff8101e7f4,%rdi
ffffffff8100dd02:	e8 03 6f ff ff       	callq  ffffffff81004c0a <_ZN2Ec3dieEPKcP8Exc_regs>

    if (C && current != ec) {
ffffffff8100dd07:	45 84 e4             	test   %r12b,%r12b
ffffffff8100dd0a:	0f 84 bc 00 00 00    	je     ffffffff8100ddcc <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x326>
ffffffff8100dd10:	48 39 c7             	cmp    %rax,%rdi
ffffffff8100dd13:	0f 84 43 01 00 00    	je     ffffffff8100de5c <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x3b6>
        Sc::ctr_link++;
    }

    ALWAYS_INLINE
    inline unsigned clr_partner() {
        assert(partner == current);
ffffffff8100dd19:	48 39 bb a0 02 00 00 	cmp    %rdi,0x2a0(%rbx)
ffffffff8100dd20:	74 1f                	je     ffffffff8100dd41 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x29b>
ffffffff8100dd22:	49 c7 c0 f0 fa 01 81 	mov    $0xffffffff8101faf0,%r8
ffffffff8100dd29:	b9 b6 00 00 00       	mov    $0xb6,%ecx
ffffffff8100dd2e:	48 c7 c2 d3 da 01 81 	mov    $0xffffffff8101dad3,%rdx
ffffffff8100dd35:	48 c7 c6 07 e8 01 81 	mov    $0xffffffff8101e807,%rsi
ffffffff8100dd3c:	e9 e4 00 00 00       	jmpq   ffffffff8100de25 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x37f>
        if (partner->rcap) {
ffffffff8100dd41:	48 8b 87 88 02 00 00 	mov    0x288(%rdi),%rax
ffffffff8100dd48:	48 85 c0             	test   %rax,%rax
ffffffff8100dd4b:	74 19                	je     ffffffff8100dd66 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x2c0>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff8100dd4d:	f0 ff 88 8c 00 00 00 	lock decl 0x8c(%rax)
            partner->rcap->del_ref();
            partner->rcap = nullptr;
ffffffff8100dd54:	48 8b 83 a0 02 00 00 	mov    0x2a0(%rbx),%rax
ffffffff8100dd5b:	48 c7 80 88 02 00 00 	movq   $0x0,0x288(%rax)
ffffffff8100dd62:	00 00 00 00 
ffffffff8100dd66:	48 8b 83 a0 02 00 00 	mov    0x2a0(%rbx),%rax
ffffffff8100dd6d:	f0 ff 88 8c 00 00 00 	lock decl 0x8c(%rax)
        }
        partner->del_ref();
        partner = nullptr;
        return Sc::ctr_link--;
ffffffff8100dd74:	8b 05 8a 1f ff 3e    	mov    0x3eff1f8a(%rip),%eax        # ffffffffbffffd04 <_ZN2Sc8ctr_linkE>
        if (partner->rcap) {
            partner->rcap->del_ref();
            partner->rcap = nullptr;
        }
        partner->del_ref();
        partner = nullptr;
ffffffff8100dd7a:	48 c7 83 a0 02 00 00 	movq   $0x0,0x2a0(%rbx)
ffffffff8100dd81:	00 00 00 00 
        return Sc::ctr_link--;
ffffffff8100dd85:	8d 70 ff             	lea    -0x1(%rax),%esi
        bool clr = rep_ec->clr_partner();
        assert(clr);
ffffffff8100dd88:	85 c0                	test   %eax,%eax
ffffffff8100dd8a:	89 35 74 1f ff 3e    	mov    %esi,0x3eff1f74(%rip)        # ffffffffbffffd04 <_ZN2Sc8ctr_linkE>
ffffffff8100dd90:	75 23                	jne    ffffffff8100ddb5 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x30f>
ffffffff8100dd92:	49 c7 c0 b0 fd 01 81 	mov    $0xffffffff8101fdb0,%r8
ffffffff8100dd99:	b9 4e 00 00 00       	mov    $0x4e,%ecx
ffffffff8100dd9e:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100dda5:	48 c7 c6 1a e8 01 81 	mov    $0xffffffff8101e81a,%rsi
ffffffff8100ddac:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100ddb3:	eb 79                	jmp    ffffffff8100de2e <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x388>

        /* current thread has no IPC relation to dst anymore */
        current->cont = nullptr;
ffffffff8100ddb5:	48 8b 05 4c 12 ff 3e 	mov    0x3eff124c(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100ddbc:	48 c7 80 a0 00 00 00 	movq   $0x0,0xa0(%rax)
ffffffff8100ddc3:	00 00 00 00 
ffffffff8100ddc7:	e9 90 00 00 00       	jmpq   ffffffff8100de5c <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x3b6>
    }

    Ec * chg = C ? rep_ec : current;
    void (*c)() = C ? sys_call : sys_reply;
ffffffff8100ddcc:	49 c7 c0 80 06 00 81 	mov    $0xffffffff81000680,%r8

    chg->oom_call(dst_pt, src_pd_id, oom_state, c, c);
ffffffff8100ddd3:	4d 89 c1             	mov    %r8,%r9
ffffffff8100ddd6:	4c 89 ee             	mov    %r13,%rsi
ffffffff8100ddd9:	e8 e0 f2 ff ff       	callq  ffffffff8100d0be <_ZN2Ec8oom_callEP2PtmmPFvvES3_>
    }

    if (user) {
        if (C) {
             assert (rep_ec->cont == ret_user_sysexit || rep_ec->cont == xcpu_return);
             assert (dst_ec->cont == recv_user);
ffffffff8100ddde:	48 81 b8 a0 00 00 00 	cmpq   $0xffffffff8100061a,0xa0(%rax)
ffffffff8100dde5:	1a 06 00 81 
ffffffff8100dde9:	0f 84 81 fd ff ff    	je     ffffffff8100db70 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0xca>
ffffffff8100ddef:	49 c7 c0 b0 fd 01 81 	mov    $0xffffffff8101fdb0,%r8
ffffffff8100ddf6:	b9 25 00 00 00       	mov    $0x25,%ecx
ffffffff8100ddfb:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100de02:	48 c7 c6 ab e7 01 81 	mov    $0xffffffff8101e7ab,%rsi
ffffffff8100de09:	eb 1a                	jmp    ffffffff8100de25 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x37f>
        } else 
             assert (dst_ec->cont == ret_user_sysexit || dst_ec->cont == xcpu_return);
ffffffff8100de0b:	49 c7 c0 b0 fd 01 81 	mov    $0xffffffff8101fdb0,%r8
ffffffff8100de12:	b9 27 00 00 00       	mov    $0x27,%ecx
ffffffff8100de17:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100de1e:	48 c7 c6 5e e8 01 81 	mov    $0xffffffff8101e85e,%rsi
ffffffff8100de25:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100de2c:	31 c0                	xor    %eax,%eax
ffffffff8100de2e:	e8 1d 41 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
ffffffff8100de33:	49 8b 8f 90 00 00 00 	mov    0x90(%r15),%rcx
                continue;
            src_ec->pd->rev_crd (*s, false, false, false);
        }
    }

    mword src_pd_id = !src_pt ? ~0UL : 0;
ffffffff8100de3a:	31 d2                	xor    %edx,%edx
    if (src_pt && src_pt->ec->pd == dst_pt->ec->pd)
ffffffff8100de3c:	48 8b b8 98 02 00 00 	mov    0x298(%rax),%rdi
ffffffff8100de43:	48 39 b9 98 02 00 00 	cmp    %rdi,0x298(%rcx)
ffffffff8100de4a:	0f 85 1e fe ff ff    	jne    ffffffff8100dc6e <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x1c8>
        src_pd_id = src_pt->id;
ffffffff8100de50:	49 8b 97 a8 00 00 00 	mov    0xa8(%r15),%rdx
ffffffff8100de57:	e9 12 fe ff ff       	jmpq   ffffffff8100dc6e <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x1c8>
        /* current thread has no IPC relation to dst anymore */
        current->cont = nullptr;
    }

    Ec * chg = C ? rep_ec : current;
    void (*c)() = C ? sys_call : sys_reply;
ffffffff8100de5c:	48 89 df             	mov    %rbx,%rdi
ffffffff8100de5f:	49 c7 c0 ae 08 00 81 	mov    $0xffffffff810008ae,%r8
ffffffff8100de66:	e9 68 ff ff ff       	jmpq   ffffffff8100ddd3 <_ZN2Ec12oom_delegateEPS_S0_S0_bb+0x32d>
ffffffff8100de6b:	90                   	nop

ffffffff8100de6c <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm>:
    ec->regs.set_ip (pt->ip);
    ec->make_current();
}

template <void (*C)()>
void Ec::oom_xcpu(Pt * pt, mword src_pd_id, mword oom_state)
ffffffff8100de6c:	41 56                	push   %r14
ffffffff8100de6e:	41 55                	push   %r13
ffffffff8100de70:	41 54                	push   %r12
ffffffff8100de72:	55                   	push   %rbp
ffffffff8100de73:	53                   	push   %rbx
ffffffff8100de74:	48 83 ec 10          	sub    $0x10,%rsp
{
    assert(current == this);
ffffffff8100de78:	48 8b 2d 89 11 ff 3e 	mov    0x3eff1189(%rip),%rbp        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100de7f:	48 39 fd             	cmp    %rdi,%rbp
ffffffff8100de82:	74 1c                	je     ffffffff8100dea0 <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x34>
ffffffff8100de84:	49 c7 c0 40 fa 01 81 	mov    $0xffffffff8101fa40,%r8
ffffffff8100de8b:	b9 72 00 00 00       	mov    $0x72,%ecx
ffffffff8100de90:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100de97:	48 c7 c6 6a e7 01 81 	mov    $0xffffffff8101e76a,%rsi
ffffffff8100de9e:	eb 24                	jmp    ffffffff8100dec4 <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x58>
    assert(!this->xcpu_sm);
ffffffff8100dea0:	48 83 bd 30 03 00 00 	cmpq   $0x0,0x330(%rbp)
ffffffff8100dea7:	00 
ffffffff8100dea8:	74 28                	je     ffffffff8100ded2 <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x66>
ffffffff8100deaa:	49 c7 c0 40 fa 01 81 	mov    $0xffffffff8101fa40,%r8
ffffffff8100deb1:	b9 73 00 00 00       	mov    $0x73,%ecx
ffffffff8100deb6:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100debd:	48 c7 c6 7a e7 01 81 	mov    $0xffffffff8101e77a,%rsi
ffffffff8100dec4:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100decb:	31 c0                	xor    %eax,%eax
ffffffff8100decd:	e8 7e 40 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

    enum { UNUSED = 0, CNT = 0 };

    this->xcpu_sm = new (Pd::current->quota) Sm (Pd::current, UNUSED, CNT);
ffffffff8100ded2:	48 8b 05 37 11 ff 3e 	mov    0x3eff1137(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100ded9:	49 89 f4             	mov    %rsi,%r12

            call_rcu(true);
        }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
ffffffff8100dedc:	48 c7 c7 80 40 16 81 	mov    $0xffffffff81164080,%rdi
ffffffff8100dee3:	49 89 d6             	mov    %rdx,%r14
ffffffff8100dee6:	49 89 cd             	mov    %rcx,%r13
ffffffff8100dee9:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff8100def0:	e8 39 7a 00 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff8100def5:	48 8b 35 14 11 ff 3e 	mov    0x3eff1114(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100defc:	48 89 c3             	mov    %rax,%rbx
ffffffff8100deff:	45 31 c9             	xor    %r9d,%r9d
ffffffff8100df02:	31 c9                	xor    %ecx,%ecx
ffffffff8100df04:	31 d2                	xor    %edx,%edx
ffffffff8100df06:	45 31 c0             	xor    %r8d,%r8d
ffffffff8100df09:	48 89 c7             	mov    %rax,%rdi
ffffffff8100df0c:	e8 51 80 00 00       	callq  ffffffff81015f62 <_ZN2SmC1EP2PdmmPS_m>
ffffffff8100df11:	48 89 9d 30 03 00 00 	mov    %rbx,0x330(%rbp)

    Ec *xcpu_ec = new (Pd::current->quota) Ec (Pd::current, Pd::current, sys_xcpu_call_oom<C>, pt->ec->cpu, this);
ffffffff8100df18:	49 8b 84 24 90 00 00 	mov    0x90(%r12),%rax
ffffffff8100df1f:	00 

    static void idl_handler();

    ALWAYS_INLINE
    static inline void *operator new (size_t, Quota &quota) {
        return cache.alloc(quota);
ffffffff8100df20:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff8100df27:	44 0f b7 80 f0 02 00 	movzwl 0x2f0(%rax),%r8d
ffffffff8100df2e:	00 
ffffffff8100df2f:	48 8b 05 da 10 ff 3e 	mov    0x3eff10da(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100df36:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff8100df3d:	44 89 44 24 0c       	mov    %r8d,0xc(%rsp)
ffffffff8100df42:	e8 e7 79 00 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff8100df47:	48 8b 35 c2 10 ff 3e 	mov    0x3eff10c2(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100df4e:	44 8b 44 24 0c       	mov    0xc(%rsp),%r8d
ffffffff8100df53:	49 89 e9             	mov    %rbp,%r9
ffffffff8100df56:	48 c7 c1 f6 d3 00 81 	mov    $0xffffffff8100d3f6,%rcx
ffffffff8100df5d:	48 89 c7             	mov    %rax,%rdi
ffffffff8100df60:	48 89 c3             	mov    %rax,%rbx
ffffffff8100df63:	48 89 f2             	mov    %rsi,%rdx
ffffffff8100df66:	e8 b3 62 ff ff       	callq  ffffffff8100421e <_ZN2EcC1EP2PdS1_PFvvEjPS_>
    xcpu_ec->regs.set_pt (reinterpret_cast<mword>(pt), src_pd_id, oom_state);

    Sc *xcpu_sc = new (Pd::current->quota) Sc (Pd::current, xcpu_ec, xcpu_ec->cpu, Sc::current);
ffffffff8100df6b:	48 8b 05 9e 10 ff 3e 	mov    0x3eff109e(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100df72:	4c 89 a3 e8 00 00 00 	mov    %r12,0xe8(%rbx)
ffffffff8100df79:	48 c7 c7 40 40 16 81 	mov    $0xffffffff81164040,%rdi
ffffffff8100df80:	4c 89 b3 f0 00 00 00 	mov    %r14,0xf0(%rbx)
ffffffff8100df87:	4c 89 ab 10 01 00 00 	mov    %r13,0x110(%rbx)
ffffffff8100df8e:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff8100df95:	e8 94 79 00 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff8100df9a:	0f b7 8b f0 02 00 00 	movzwl 0x2f0(%rbx),%ecx
ffffffff8100dfa1:	4c 8b 05 70 10 ff 3e 	mov    0x3eff1070(%rip),%r8        # ffffffffbffff018 <_ZN2Sc7currentE>
ffffffff8100dfa8:	49 89 c4             	mov    %rax,%r12
ffffffff8100dfab:	48 8b 35 5e 10 ff 3e 	mov    0x3eff105e(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100dfb2:	48 89 da             	mov    %rbx,%rdx
ffffffff8100dfb5:	48 89 c7             	mov    %rax,%rdi
ffffffff8100dfb8:	e8 15 67 00 00       	callq  ffffffff810146d2 <_ZN2ScC1EP2PdP2EcjPS_>

    xcpu_sc->remote_enqueue();
ffffffff8100dfbd:	4c 89 e7             	mov    %r12,%rdi
ffffffff8100dfc0:	e8 9b 6a 00 00       	callq  ffffffff81014a60 <_ZN2Sc14remote_enqueueEv>
    this->xcpu_sm->dn (false, 0);
ffffffff8100dfc5:	48 8b ad 30 03 00 00 	mov    0x330(%rbp),%rbp
ffffffff8100dfcc:	48 8b 1d 35 10 ff 3e 	mov    0x3eff1035(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>
        }

        ALWAYS_INLINE
        inline void dn (bool zero, uint64 t, Ec *ec = Ec::current, bool block = true)
        {
            {   Lock_guard <Spinlock> guard (lock);
ffffffff8100dfd3:	48 8d bd 8a 00 00 00 	lea    0x8a(%rbp),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff8100dfda:	9c                   	pushfq 
ffffffff8100dfdb:	41 5c                	pop    %r12
            return flags & 0x200;
ffffffff8100dfdd:	49 c1 ec 09          	shr    $0x9,%r12

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8100dfe1:	41 80 e4 01          	and    $0x1,%r12b
ffffffff8100dfe5:	74 30                	je     ffffffff8100e017 <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x1ab>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff8100dfe7:	80 3d 42 17 ff 3e 00 	cmpb   $0x0,0x3eff1742(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100dfee:	75 1f                	jne    ffffffff8100e00f <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x1a3>
ffffffff8100dff0:	49 c7 c0 40 fb 01 81 	mov    $0xffffffff8101fb40,%r8
ffffffff8100dff7:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff8100dffc:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100e003:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff8100e00a:	e9 b5 fe ff ff       	jmpq   ffffffff8100dec4 <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x58>

            asm volatile ("cli" : : : "memory");
ffffffff8100e00f:	fa                   	cli    
            preemption = false;
ffffffff8100e010:	c6 05 19 17 ff 3e 00 	movb   $0x0,0x3eff1719(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff8100e017:	e8 72 2e ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>

                if (counter) {
ffffffff8100e01c:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff8100e023:	48 85 c0             	test   %rax,%rax
ffffffff8100e026:	0f 84 aa 00 00 00    	je     ffffffff8100e0d6 <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x26a>
                    counter = zero ? 0 : counter - 1;
ffffffff8100e02c:	48 ff c8             	dec    %rax
ffffffff8100e02f:	48 89 85 c0 00 00 00 	mov    %rax,0xc0(%rbp)
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff8100e036:	48 8b 85 98 00 00 00 	mov    0x98(%rbp),%rax
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff8100e03d:	48 85 c0             	test   %rax,%rax
ffffffff8100e040:	0f 84 24 01 00 00    	je     ffffffff8100e16a <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x2fe>
ffffffff8100e046:	48 8b 50 10          	mov    0x10(%rax),%rdx
ffffffff8100e04a:	48 85 d2             	test   %rdx,%rdx
ffffffff8100e04d:	0f 84 17 01 00 00    	je     ffffffff8100e16a <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x2fe>
ffffffff8100e053:	48 8b 48 08          	mov    0x8(%rax),%rcx
ffffffff8100e057:	48 85 c9             	test   %rcx,%rcx
ffffffff8100e05a:	0f 84 0a 01 00 00    	je     ffffffff8100e16a <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x2fe>
                return false;

            if (t == t->next)
ffffffff8100e060:	48 39 d0             	cmp    %rdx,%rax
ffffffff8100e063:	75 0d                	jne    ffffffff8100e072 <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x206>
                headptr = nullptr;
ffffffff8100e065:	48 c7 85 98 00 00 00 	movq   $0x0,0x98(%rbp)
ffffffff8100e06c:	00 00 00 00 
ffffffff8100e070:	eb 24                	jmp    ffffffff8100e096 <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x22a>

            else {
                t->next->prev = t->prev;
ffffffff8100e072:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
                t->prev->next = t->next;
ffffffff8100e076:	48 8b 50 08          	mov    0x8(%rax),%rdx
ffffffff8100e07a:	48 8b 48 10          	mov    0x10(%rax),%rcx
ffffffff8100e07e:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
                if (t == headptr)
ffffffff8100e082:	48 3b 85 98 00 00 00 	cmp    0x98(%rbp),%rax
ffffffff8100e089:	75 0b                	jne    ffffffff8100e096 <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x22a>
                    headptr = t->next;
ffffffff8100e08b:	48 8b 50 10          	mov    0x10(%rax),%rdx
ffffffff8100e08f:	48 89 95 98 00 00 00 	mov    %rdx,0x98(%rbp)

    public:

        mword reset(bool l = false) {
            if (l) lock.lock();
            mword c = counter;
ffffffff8100e096:	48 8b 50 20          	mov    0x20(%rax),%rdx
            }

            t->next = t->prev = nullptr;
ffffffff8100e09a:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
ffffffff8100e0a1:	00 
ffffffff8100e0a2:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
ffffffff8100e0a9:	00 
            counter = 0;
ffffffff8100e0aa:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
ffffffff8100e0b1:	00 
                if (counter) {
                    counter = zero ? 0 : counter - 1;

                    Si * si;
                    if (Queue<Si>::dequeue(si = Queue<Si>::head()))
                        ec->set_si_regs(si->value, static_cast <Sm *>(si)->reset());
ffffffff8100e0b2:	48 8b 40 18          	mov    0x18(%rax),%rax
    }

    ALWAYS_INLINE
    inline void set_si_regs(mword sig, mword cnt) {
        regs.ARG_2 = sig;
        regs.ARG_3 = cnt;
ffffffff8100e0b6:	48 89 93 10 01 00 00 	mov    %rdx,0x110(%rbx)
            timeout.dequeue();
    }

    ALWAYS_INLINE
    inline void set_si_regs(mword sig, mword cnt) {
        regs.ARG_2 = sig;
ffffffff8100e0bd:	48 89 83 f0 00 00 00 	mov    %rax,0xf0(%rbx)
ffffffff8100e0c4:	e9 a1 00 00 00       	jmpq   ffffffff8100e16a <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x2fe>

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8100e0c9:	8d 50 01             	lea    0x1(%rax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff8100e0cc:	f0 0f b1 93 8c 00 00 	lock cmpxchg %edx,0x8c(%rbx)
ffffffff8100e0d3:	00 
ffffffff8100e0d4:	74 0a                	je     ffffffff8100e0e0 <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x274>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100e0d6:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff8100e0dc:	85 c0                	test   %eax,%eax
ffffffff8100e0de:	75 e9                	jne    ffffffff8100e0c9 <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x25d>
        inline T *head() const { return headptr; }

        ALWAYS_INLINE
        inline void enqueue (T *t)
        {
            if (!headptr)
ffffffff8100e0e0:	48 8b 85 90 00 00 00 	mov    0x90(%rbp),%rax
ffffffff8100e0e7:	48 85 c0             	test   %rax,%rax
ffffffff8100e0ea:	75 17                	jne    ffffffff8100e103 <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x297>
                headptr = t->prev = t->next = t;
ffffffff8100e0ec:	48 89 9b b0 02 00 00 	mov    %rbx,0x2b0(%rbx)
ffffffff8100e0f3:	48 89 9b a8 02 00 00 	mov    %rbx,0x2a8(%rbx)
ffffffff8100e0fa:	48 89 9d 90 00 00 00 	mov    %rbx,0x90(%rbp)
ffffffff8100e101:	eb 2a                	jmp    ffffffff8100e12d <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x2c1>
            else {
                t->next = headptr;
ffffffff8100e103:	48 89 83 b0 02 00 00 	mov    %rax,0x2b0(%rbx)
                t->prev = headptr->prev;
ffffffff8100e10a:	48 8b 95 90 00 00 00 	mov    0x90(%rbp),%rdx
ffffffff8100e111:	48 8b 92 a8 02 00 00 	mov    0x2a8(%rdx),%rdx
ffffffff8100e118:	48 89 93 a8 02 00 00 	mov    %rdx,0x2a8(%rbx)
                t->next->prev = t->prev->next = t;
ffffffff8100e11f:	48 89 9a b0 02 00 00 	mov    %rbx,0x2b0(%rdx)
ffffffff8100e126:	48 89 98 a8 02 00 00 	mov    %rbx,0x2a8(%rax)
ffffffff8100e12d:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff8100e133:	45 84 e4             	test   %r12b,%r12b
ffffffff8100e136:	74 50                	je     ffffffff8100e188 <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x31c>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100e138:	80 3d f1 15 ff 3e 00 	cmpb   $0x0,0x3eff15f1(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100e13f:	74 1f                	je     ffffffff8100e160 <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x2f4>
ffffffff8100e141:	49 c7 c0 10 fb 01 81 	mov    $0xffffffff8101fb10,%r8
ffffffff8100e148:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff8100e14d:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100e154:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff8100e15b:	e9 64 fd ff ff       	jmpq   ffffffff8100dec4 <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x58>

            preemption = true;
ffffffff8100e160:	c6 05 c9 15 ff 3e 01 	movb   $0x1,0x3eff15c9(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100e167:	fb                   	sti    
ffffffff8100e168:	eb 1e                	jmp    ffffffff8100e188 <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x31c>
ffffffff8100e16a:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
ffffffff8100e170:	45 84 e4             	test   %r12b,%r12b
ffffffff8100e173:	74 1b                	je     ffffffff8100e190 <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x324>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100e175:	80 3d b4 15 ff 3e 00 	cmpb   $0x0,0x3eff15b4(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100e17c:	75 c3                	jne    ffffffff8100e141 <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x2d5>

            preemption = true;
ffffffff8100e17e:	c6 05 ab 15 ff 3e 01 	movb   $0x1,0x3eff15ab(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100e185:	fb                   	sti    
ffffffff8100e186:	eb 08                	jmp    ffffffff8100e190 <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm+0x324>
            if (!block)
                Sc::schedule (false);

            ec->set_timeout (t, this);

            ec->block_sc();
ffffffff8100e188:	48 89 df             	mov    %rbx,%rdi
ffffffff8100e18b:	e8 de d5 ff ff       	callq  ffffffff8100b76e <_ZN2Ec8block_scEv>

    die ("XCPU OOM error");
ffffffff8100e190:	48 8b 05 71 0e ff 3e 	mov    0x3eff0e71(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100e197:	48 c7 c7 89 e7 01 81 	mov    $0xffffffff8101e789,%rdi
ffffffff8100e19e:	48 8d b0 a8 00 00 00 	lea    0xa8(%rax),%rsi
ffffffff8100e1a5:	e8 60 6a ff ff       	callq  ffffffff81004c0a <_ZN2Ec3dieEPKcP8Exc_regs>

ffffffff8100e1aa <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm>:
    ec->regs.set_ip (pt->ip);
    ec->make_current();
}

template <void (*C)()>
void Ec::oom_xcpu(Pt * pt, mword src_pd_id, mword oom_state)
ffffffff8100e1aa:	41 56                	push   %r14
ffffffff8100e1ac:	41 55                	push   %r13
ffffffff8100e1ae:	41 54                	push   %r12
ffffffff8100e1b0:	55                   	push   %rbp
ffffffff8100e1b1:	53                   	push   %rbx
ffffffff8100e1b2:	48 83 ec 10          	sub    $0x10,%rsp
{
    assert(current == this);
ffffffff8100e1b6:	48 8b 2d 4b 0e ff 3e 	mov    0x3eff0e4b(%rip),%rbp        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100e1bd:	48 39 fd             	cmp    %rdi,%rbp
ffffffff8100e1c0:	74 1c                	je     ffffffff8100e1de <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x34>
ffffffff8100e1c2:	49 c7 c0 40 f8 01 81 	mov    $0xffffffff8101f840,%r8
ffffffff8100e1c9:	b9 72 00 00 00       	mov    $0x72,%ecx
ffffffff8100e1ce:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100e1d5:	48 c7 c6 6a e7 01 81 	mov    $0xffffffff8101e76a,%rsi
ffffffff8100e1dc:	eb 24                	jmp    ffffffff8100e202 <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x58>
    assert(!this->xcpu_sm);
ffffffff8100e1de:	48 83 bd 30 03 00 00 	cmpq   $0x0,0x330(%rbp)
ffffffff8100e1e5:	00 
ffffffff8100e1e6:	74 28                	je     ffffffff8100e210 <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x66>
ffffffff8100e1e8:	49 c7 c0 40 f8 01 81 	mov    $0xffffffff8101f840,%r8
ffffffff8100e1ef:	b9 73 00 00 00       	mov    $0x73,%ecx
ffffffff8100e1f4:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100e1fb:	48 c7 c6 7a e7 01 81 	mov    $0xffffffff8101e77a,%rsi
ffffffff8100e202:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100e209:	31 c0                	xor    %eax,%eax
ffffffff8100e20b:	e8 40 3d ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

    enum { UNUSED = 0, CNT = 0 };

    this->xcpu_sm = new (Pd::current->quota) Sm (Pd::current, UNUSED, CNT);
ffffffff8100e210:	48 8b 05 f9 0d ff 3e 	mov    0x3eff0df9(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100e217:	49 89 f4             	mov    %rsi,%r12

            call_rcu(true);
        }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
ffffffff8100e21a:	48 c7 c7 80 40 16 81 	mov    $0xffffffff81164080,%rdi
ffffffff8100e221:	49 89 d6             	mov    %rdx,%r14
ffffffff8100e224:	49 89 cd             	mov    %rcx,%r13
ffffffff8100e227:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff8100e22e:	e8 fb 76 00 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff8100e233:	48 8b 35 d6 0d ff 3e 	mov    0x3eff0dd6(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100e23a:	48 89 c3             	mov    %rax,%rbx
ffffffff8100e23d:	45 31 c9             	xor    %r9d,%r9d
ffffffff8100e240:	31 c9                	xor    %ecx,%ecx
ffffffff8100e242:	31 d2                	xor    %edx,%edx
ffffffff8100e244:	45 31 c0             	xor    %r8d,%r8d
ffffffff8100e247:	48 89 c7             	mov    %rax,%rdi
ffffffff8100e24a:	e8 13 7d 00 00       	callq  ffffffff81015f62 <_ZN2SmC1EP2PdmmPS_m>
ffffffff8100e24f:	48 89 9d 30 03 00 00 	mov    %rbx,0x330(%rbp)

    Ec *xcpu_ec = new (Pd::current->quota) Ec (Pd::current, Pd::current, sys_xcpu_call_oom<C>, pt->ec->cpu, this);
ffffffff8100e256:	49 8b 84 24 90 00 00 	mov    0x90(%r12),%rax
ffffffff8100e25d:	00 

    static void idl_handler();

    ALWAYS_INLINE
    static inline void *operator new (size_t, Quota &quota) {
        return cache.alloc(quota);
ffffffff8100e25e:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff8100e265:	44 0f b7 80 f0 02 00 	movzwl 0x2f0(%rax),%r8d
ffffffff8100e26c:	00 
ffffffff8100e26d:	48 8b 05 9c 0d ff 3e 	mov    0x3eff0d9c(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100e274:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff8100e27b:	44 89 44 24 0c       	mov    %r8d,0xc(%rsp)
ffffffff8100e280:	e8 a9 76 00 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff8100e285:	48 8b 35 84 0d ff 3e 	mov    0x3eff0d84(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100e28c:	44 8b 44 24 0c       	mov    0xc(%rsp),%r8d
ffffffff8100e291:	49 89 e9             	mov    %rbp,%r9
ffffffff8100e294:	48 c7 c1 58 d4 00 81 	mov    $0xffffffff8100d458,%rcx
ffffffff8100e29b:	48 89 c7             	mov    %rax,%rdi
ffffffff8100e29e:	48 89 c3             	mov    %rax,%rbx
ffffffff8100e2a1:	48 89 f2             	mov    %rsi,%rdx
ffffffff8100e2a4:	e8 75 5f ff ff       	callq  ffffffff8100421e <_ZN2EcC1EP2PdS1_PFvvEjPS_>
    xcpu_ec->regs.set_pt (reinterpret_cast<mword>(pt), src_pd_id, oom_state);

    Sc *xcpu_sc = new (Pd::current->quota) Sc (Pd::current, xcpu_ec, xcpu_ec->cpu, Sc::current);
ffffffff8100e2a9:	48 8b 05 60 0d ff 3e 	mov    0x3eff0d60(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100e2b0:	4c 89 a3 e8 00 00 00 	mov    %r12,0xe8(%rbx)
ffffffff8100e2b7:	48 c7 c7 40 40 16 81 	mov    $0xffffffff81164040,%rdi
ffffffff8100e2be:	4c 89 b3 f0 00 00 00 	mov    %r14,0xf0(%rbx)
ffffffff8100e2c5:	4c 89 ab 10 01 00 00 	mov    %r13,0x110(%rbx)
ffffffff8100e2cc:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff8100e2d3:	e8 56 76 00 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff8100e2d8:	0f b7 8b f0 02 00 00 	movzwl 0x2f0(%rbx),%ecx
ffffffff8100e2df:	4c 8b 05 32 0d ff 3e 	mov    0x3eff0d32(%rip),%r8        # ffffffffbffff018 <_ZN2Sc7currentE>
ffffffff8100e2e6:	49 89 c4             	mov    %rax,%r12
ffffffff8100e2e9:	48 8b 35 20 0d ff 3e 	mov    0x3eff0d20(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100e2f0:	48 89 da             	mov    %rbx,%rdx
ffffffff8100e2f3:	48 89 c7             	mov    %rax,%rdi
ffffffff8100e2f6:	e8 d7 63 00 00       	callq  ffffffff810146d2 <_ZN2ScC1EP2PdP2EcjPS_>

    xcpu_sc->remote_enqueue();
ffffffff8100e2fb:	4c 89 e7             	mov    %r12,%rdi
ffffffff8100e2fe:	e8 5d 67 00 00       	callq  ffffffff81014a60 <_ZN2Sc14remote_enqueueEv>
    this->xcpu_sm->dn (false, 0);
ffffffff8100e303:	48 8b ad 30 03 00 00 	mov    0x330(%rbp),%rbp
ffffffff8100e30a:	48 8b 1d f7 0c ff 3e 	mov    0x3eff0cf7(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>
        }

        ALWAYS_INLINE
        inline void dn (bool zero, uint64 t, Ec *ec = Ec::current, bool block = true)
        {
            {   Lock_guard <Spinlock> guard (lock);
ffffffff8100e311:	48 8d bd 8a 00 00 00 	lea    0x8a(%rbp),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff8100e318:	9c                   	pushfq 
ffffffff8100e319:	41 5c                	pop    %r12
            return flags & 0x200;
ffffffff8100e31b:	49 c1 ec 09          	shr    $0x9,%r12

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8100e31f:	41 80 e4 01          	and    $0x1,%r12b
ffffffff8100e323:	74 30                	je     ffffffff8100e355 <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x1ab>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff8100e325:	80 3d 04 14 ff 3e 00 	cmpb   $0x0,0x3eff1404(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100e32c:	75 1f                	jne    ffffffff8100e34d <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x1a3>
ffffffff8100e32e:	49 c7 c0 40 fb 01 81 	mov    $0xffffffff8101fb40,%r8
ffffffff8100e335:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff8100e33a:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100e341:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff8100e348:	e9 b5 fe ff ff       	jmpq   ffffffff8100e202 <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x58>

            asm volatile ("cli" : : : "memory");
ffffffff8100e34d:	fa                   	cli    
            preemption = false;
ffffffff8100e34e:	c6 05 db 13 ff 3e 00 	movb   $0x0,0x3eff13db(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff8100e355:	e8 34 2b ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>

                if (counter) {
ffffffff8100e35a:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff8100e361:	48 85 c0             	test   %rax,%rax
ffffffff8100e364:	0f 84 aa 00 00 00    	je     ffffffff8100e414 <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x26a>
                    counter = zero ? 0 : counter - 1;
ffffffff8100e36a:	48 ff c8             	dec    %rax
ffffffff8100e36d:	48 89 85 c0 00 00 00 	mov    %rax,0xc0(%rbp)
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff8100e374:	48 8b 85 98 00 00 00 	mov    0x98(%rbp),%rax
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff8100e37b:	48 85 c0             	test   %rax,%rax
ffffffff8100e37e:	0f 84 24 01 00 00    	je     ffffffff8100e4a8 <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x2fe>
ffffffff8100e384:	48 8b 50 10          	mov    0x10(%rax),%rdx
ffffffff8100e388:	48 85 d2             	test   %rdx,%rdx
ffffffff8100e38b:	0f 84 17 01 00 00    	je     ffffffff8100e4a8 <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x2fe>
ffffffff8100e391:	48 8b 48 08          	mov    0x8(%rax),%rcx
ffffffff8100e395:	48 85 c9             	test   %rcx,%rcx
ffffffff8100e398:	0f 84 0a 01 00 00    	je     ffffffff8100e4a8 <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x2fe>
                return false;

            if (t == t->next)
ffffffff8100e39e:	48 39 d0             	cmp    %rdx,%rax
ffffffff8100e3a1:	75 0d                	jne    ffffffff8100e3b0 <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x206>
                headptr = nullptr;
ffffffff8100e3a3:	48 c7 85 98 00 00 00 	movq   $0x0,0x98(%rbp)
ffffffff8100e3aa:	00 00 00 00 
ffffffff8100e3ae:	eb 24                	jmp    ffffffff8100e3d4 <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x22a>

            else {
                t->next->prev = t->prev;
ffffffff8100e3b0:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
                t->prev->next = t->next;
ffffffff8100e3b4:	48 8b 50 08          	mov    0x8(%rax),%rdx
ffffffff8100e3b8:	48 8b 48 10          	mov    0x10(%rax),%rcx
ffffffff8100e3bc:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
                if (t == headptr)
ffffffff8100e3c0:	48 3b 85 98 00 00 00 	cmp    0x98(%rbp),%rax
ffffffff8100e3c7:	75 0b                	jne    ffffffff8100e3d4 <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x22a>
                    headptr = t->next;
ffffffff8100e3c9:	48 8b 50 10          	mov    0x10(%rax),%rdx
ffffffff8100e3cd:	48 89 95 98 00 00 00 	mov    %rdx,0x98(%rbp)

    public:

        mword reset(bool l = false) {
            if (l) lock.lock();
            mword c = counter;
ffffffff8100e3d4:	48 8b 50 20          	mov    0x20(%rax),%rdx
            }

            t->next = t->prev = nullptr;
ffffffff8100e3d8:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
ffffffff8100e3df:	00 
ffffffff8100e3e0:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
ffffffff8100e3e7:	00 
            counter = 0;
ffffffff8100e3e8:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
ffffffff8100e3ef:	00 
                if (counter) {
                    counter = zero ? 0 : counter - 1;

                    Si * si;
                    if (Queue<Si>::dequeue(si = Queue<Si>::head()))
                        ec->set_si_regs(si->value, static_cast <Sm *>(si)->reset());
ffffffff8100e3f0:	48 8b 40 18          	mov    0x18(%rax),%rax
    }

    ALWAYS_INLINE
    inline void set_si_regs(mword sig, mword cnt) {
        regs.ARG_2 = sig;
        regs.ARG_3 = cnt;
ffffffff8100e3f4:	48 89 93 10 01 00 00 	mov    %rdx,0x110(%rbx)
            timeout.dequeue();
    }

    ALWAYS_INLINE
    inline void set_si_regs(mword sig, mword cnt) {
        regs.ARG_2 = sig;
ffffffff8100e3fb:	48 89 83 f0 00 00 00 	mov    %rax,0xf0(%rbx)
ffffffff8100e402:	e9 a1 00 00 00       	jmpq   ffffffff8100e4a8 <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x2fe>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8100e407:	8d 50 01             	lea    0x1(%rax),%edx
ffffffff8100e40a:	f0 0f b1 93 8c 00 00 	lock cmpxchg %edx,0x8c(%rbx)
ffffffff8100e411:	00 
ffffffff8100e412:	74 0a                	je     ffffffff8100e41e <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x274>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100e414:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff8100e41a:	85 c0                	test   %eax,%eax
ffffffff8100e41c:	75 e9                	jne    ffffffff8100e407 <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x25d>
        inline T *head() const { return headptr; }

        ALWAYS_INLINE
        inline void enqueue (T *t)
        {
            if (!headptr)
ffffffff8100e41e:	48 8b 85 90 00 00 00 	mov    0x90(%rbp),%rax
ffffffff8100e425:	48 85 c0             	test   %rax,%rax
ffffffff8100e428:	75 17                	jne    ffffffff8100e441 <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x297>
                headptr = t->prev = t->next = t;
ffffffff8100e42a:	48 89 9b b0 02 00 00 	mov    %rbx,0x2b0(%rbx)
ffffffff8100e431:	48 89 9b a8 02 00 00 	mov    %rbx,0x2a8(%rbx)
ffffffff8100e438:	48 89 9d 90 00 00 00 	mov    %rbx,0x90(%rbp)
ffffffff8100e43f:	eb 2a                	jmp    ffffffff8100e46b <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x2c1>
            else {
                t->next = headptr;
ffffffff8100e441:	48 89 83 b0 02 00 00 	mov    %rax,0x2b0(%rbx)
                t->prev = headptr->prev;
ffffffff8100e448:	48 8b 95 90 00 00 00 	mov    0x90(%rbp),%rdx
ffffffff8100e44f:	48 8b 92 a8 02 00 00 	mov    0x2a8(%rdx),%rdx
ffffffff8100e456:	48 89 93 a8 02 00 00 	mov    %rdx,0x2a8(%rbx)
                t->next->prev = t->prev->next = t;
ffffffff8100e45d:	48 89 9a b0 02 00 00 	mov    %rbx,0x2b0(%rdx)
ffffffff8100e464:	48 89 98 a8 02 00 00 	mov    %rbx,0x2a8(%rax)
ffffffff8100e46b:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff8100e471:	45 84 e4             	test   %r12b,%r12b
ffffffff8100e474:	74 50                	je     ffffffff8100e4c6 <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x31c>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100e476:	80 3d b3 12 ff 3e 00 	cmpb   $0x0,0x3eff12b3(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100e47d:	74 1f                	je     ffffffff8100e49e <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x2f4>
ffffffff8100e47f:	49 c7 c0 10 fb 01 81 	mov    $0xffffffff8101fb10,%r8
ffffffff8100e486:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff8100e48b:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100e492:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff8100e499:	e9 64 fd ff ff       	jmpq   ffffffff8100e202 <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x58>

            preemption = true;
ffffffff8100e49e:	c6 05 8b 12 ff 3e 01 	movb   $0x1,0x3eff128b(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100e4a5:	fb                   	sti    
ffffffff8100e4a6:	eb 1e                	jmp    ffffffff8100e4c6 <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x31c>
ffffffff8100e4a8:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
ffffffff8100e4ae:	45 84 e4             	test   %r12b,%r12b
ffffffff8100e4b1:	74 1b                	je     ffffffff8100e4ce <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x324>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100e4b3:	80 3d 76 12 ff 3e 00 	cmpb   $0x0,0x3eff1276(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100e4ba:	75 c3                	jne    ffffffff8100e47f <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x2d5>

            preemption = true;
ffffffff8100e4bc:	c6 05 6d 12 ff 3e 01 	movb   $0x1,0x3eff126d(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100e4c3:	fb                   	sti    
ffffffff8100e4c4:	eb 08                	jmp    ffffffff8100e4ce <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm+0x324>
            if (!block)
                Sc::schedule (false);

            ec->set_timeout (t, this);

            ec->block_sc();
ffffffff8100e4c6:	48 89 df             	mov    %rbx,%rdi
ffffffff8100e4c9:	e8 a0 d2 ff ff       	callq  ffffffff8100b76e <_ZN2Ec8block_scEv>

    die ("XCPU OOM error");
ffffffff8100e4ce:	48 8b 05 33 0b ff 3e 	mov    0x3eff0b33(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100e4d5:	48 c7 c7 89 e7 01 81 	mov    $0xffffffff8101e789,%rdi
ffffffff8100e4dc:	48 8d b0 a8 00 00 00 	lea    0xa8(%rax),%rsi
ffffffff8100e4e3:	e8 22 67 ff ff       	callq  ffffffff81004c0a <_ZN2Ec3dieEPKcP8Exc_regs>

ffffffff8100e4e8 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm>:
    ec->regs.set_ip (pt->ip);
    ec->make_current();
}

template <void (*C)()>
void Ec::oom_xcpu(Pt * pt, mword src_pd_id, mword oom_state)
ffffffff8100e4e8:	41 56                	push   %r14
ffffffff8100e4ea:	41 55                	push   %r13
ffffffff8100e4ec:	41 54                	push   %r12
ffffffff8100e4ee:	55                   	push   %rbp
ffffffff8100e4ef:	53                   	push   %rbx
ffffffff8100e4f0:	48 83 ec 10          	sub    $0x10,%rsp
{
    assert(current == this);
ffffffff8100e4f4:	48 8b 2d 0d 0b ff 3e 	mov    0x3eff0b0d(%rip),%rbp        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100e4fb:	48 39 fd             	cmp    %rdi,%rbp
ffffffff8100e4fe:	74 1c                	je     ffffffff8100e51c <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x34>
ffffffff8100e500:	49 c7 c0 40 f6 01 81 	mov    $0xffffffff8101f640,%r8
ffffffff8100e507:	b9 72 00 00 00       	mov    $0x72,%ecx
ffffffff8100e50c:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100e513:	48 c7 c6 6a e7 01 81 	mov    $0xffffffff8101e76a,%rsi
ffffffff8100e51a:	eb 24                	jmp    ffffffff8100e540 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x58>
    assert(!this->xcpu_sm);
ffffffff8100e51c:	48 83 bd 30 03 00 00 	cmpq   $0x0,0x330(%rbp)
ffffffff8100e523:	00 
ffffffff8100e524:	74 28                	je     ffffffff8100e54e <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x66>
ffffffff8100e526:	49 c7 c0 40 f6 01 81 	mov    $0xffffffff8101f640,%r8
ffffffff8100e52d:	b9 73 00 00 00       	mov    $0x73,%ecx
ffffffff8100e532:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100e539:	48 c7 c6 7a e7 01 81 	mov    $0xffffffff8101e77a,%rsi
ffffffff8100e540:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100e547:	31 c0                	xor    %eax,%eax
ffffffff8100e549:	e8 02 3a ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

    enum { UNUSED = 0, CNT = 0 };

    this->xcpu_sm = new (Pd::current->quota) Sm (Pd::current, UNUSED, CNT);
ffffffff8100e54e:	48 8b 05 bb 0a ff 3e 	mov    0x3eff0abb(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100e555:	49 89 f4             	mov    %rsi,%r12

            call_rcu(true);
        }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
ffffffff8100e558:	48 c7 c7 80 40 16 81 	mov    $0xffffffff81164080,%rdi
ffffffff8100e55f:	49 89 d6             	mov    %rdx,%r14
ffffffff8100e562:	49 89 cd             	mov    %rcx,%r13
ffffffff8100e565:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff8100e56c:	e8 bd 73 00 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff8100e571:	48 8b 35 98 0a ff 3e 	mov    0x3eff0a98(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100e578:	48 89 c3             	mov    %rax,%rbx
ffffffff8100e57b:	45 31 c9             	xor    %r9d,%r9d
ffffffff8100e57e:	31 c9                	xor    %ecx,%ecx
ffffffff8100e580:	31 d2                	xor    %edx,%edx
ffffffff8100e582:	45 31 c0             	xor    %r8d,%r8d
ffffffff8100e585:	48 89 c7             	mov    %rax,%rdi
ffffffff8100e588:	e8 d5 79 00 00       	callq  ffffffff81015f62 <_ZN2SmC1EP2PdmmPS_m>
ffffffff8100e58d:	48 89 9d 30 03 00 00 	mov    %rbx,0x330(%rbp)

    Ec *xcpu_ec = new (Pd::current->quota) Ec (Pd::current, Pd::current, sys_xcpu_call_oom<C>, pt->ec->cpu, this);
ffffffff8100e594:	49 8b 84 24 90 00 00 	mov    0x90(%r12),%rax
ffffffff8100e59b:	00 

    static void idl_handler();

    ALWAYS_INLINE
    static inline void *operator new (size_t, Quota &quota) {
        return cache.alloc(quota);
ffffffff8100e59c:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff8100e5a3:	44 0f b7 80 f0 02 00 	movzwl 0x2f0(%rax),%r8d
ffffffff8100e5aa:	00 
ffffffff8100e5ab:	48 8b 05 5e 0a ff 3e 	mov    0x3eff0a5e(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100e5b2:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff8100e5b9:	44 89 44 24 0c       	mov    %r8d,0xc(%rsp)
ffffffff8100e5be:	e8 6b 73 00 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff8100e5c3:	48 8b 35 46 0a ff 3e 	mov    0x3eff0a46(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100e5ca:	44 8b 44 24 0c       	mov    0xc(%rsp),%r8d
ffffffff8100e5cf:	49 89 e9             	mov    %rbp,%r9
ffffffff8100e5d2:	48 c7 c1 ba d4 00 81 	mov    $0xffffffff8100d4ba,%rcx
ffffffff8100e5d9:	48 89 c7             	mov    %rax,%rdi
ffffffff8100e5dc:	48 89 c3             	mov    %rax,%rbx
ffffffff8100e5df:	48 89 f2             	mov    %rsi,%rdx
ffffffff8100e5e2:	e8 37 5c ff ff       	callq  ffffffff8100421e <_ZN2EcC1EP2PdS1_PFvvEjPS_>
    xcpu_ec->regs.set_pt (reinterpret_cast<mword>(pt), src_pd_id, oom_state);

    Sc *xcpu_sc = new (Pd::current->quota) Sc (Pd::current, xcpu_ec, xcpu_ec->cpu, Sc::current);
ffffffff8100e5e7:	48 8b 05 22 0a ff 3e 	mov    0x3eff0a22(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100e5ee:	4c 89 a3 e8 00 00 00 	mov    %r12,0xe8(%rbx)
ffffffff8100e5f5:	48 c7 c7 40 40 16 81 	mov    $0xffffffff81164040,%rdi
ffffffff8100e5fc:	4c 89 b3 f0 00 00 00 	mov    %r14,0xf0(%rbx)
ffffffff8100e603:	4c 89 ab 10 01 00 00 	mov    %r13,0x110(%rbx)
ffffffff8100e60a:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff8100e611:	e8 18 73 00 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff8100e616:	0f b7 8b f0 02 00 00 	movzwl 0x2f0(%rbx),%ecx
ffffffff8100e61d:	4c 8b 05 f4 09 ff 3e 	mov    0x3eff09f4(%rip),%r8        # ffffffffbffff018 <_ZN2Sc7currentE>
ffffffff8100e624:	49 89 c4             	mov    %rax,%r12
ffffffff8100e627:	48 8b 35 e2 09 ff 3e 	mov    0x3eff09e2(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100e62e:	48 89 da             	mov    %rbx,%rdx
ffffffff8100e631:	48 89 c7             	mov    %rax,%rdi
ffffffff8100e634:	e8 99 60 00 00       	callq  ffffffff810146d2 <_ZN2ScC1EP2PdP2EcjPS_>

    xcpu_sc->remote_enqueue();
ffffffff8100e639:	4c 89 e7             	mov    %r12,%rdi
ffffffff8100e63c:	e8 1f 64 00 00       	callq  ffffffff81014a60 <_ZN2Sc14remote_enqueueEv>
    this->xcpu_sm->dn (false, 0);
ffffffff8100e641:	48 8b ad 30 03 00 00 	mov    0x330(%rbp),%rbp
ffffffff8100e648:	48 8b 1d b9 09 ff 3e 	mov    0x3eff09b9(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>
        }

        ALWAYS_INLINE
        inline void dn (bool zero, uint64 t, Ec *ec = Ec::current, bool block = true)
        {
            {   Lock_guard <Spinlock> guard (lock);
ffffffff8100e64f:	48 8d bd 8a 00 00 00 	lea    0x8a(%rbp),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff8100e656:	9c                   	pushfq 
ffffffff8100e657:	41 5c                	pop    %r12
            return flags & 0x200;
ffffffff8100e659:	49 c1 ec 09          	shr    $0x9,%r12

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8100e65d:	41 80 e4 01          	and    $0x1,%r12b
ffffffff8100e661:	74 30                	je     ffffffff8100e693 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x1ab>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff8100e663:	80 3d c6 10 ff 3e 00 	cmpb   $0x0,0x3eff10c6(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100e66a:	75 1f                	jne    ffffffff8100e68b <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x1a3>
ffffffff8100e66c:	49 c7 c0 40 fb 01 81 	mov    $0xffffffff8101fb40,%r8
ffffffff8100e673:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff8100e678:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100e67f:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff8100e686:	e9 b5 fe ff ff       	jmpq   ffffffff8100e540 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x58>

            asm volatile ("cli" : : : "memory");
ffffffff8100e68b:	fa                   	cli    
            preemption = false;
ffffffff8100e68c:	c6 05 9d 10 ff 3e 00 	movb   $0x0,0x3eff109d(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff8100e693:	e8 f6 27 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>

                if (counter) {
ffffffff8100e698:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff8100e69f:	48 85 c0             	test   %rax,%rax
ffffffff8100e6a2:	0f 84 aa 00 00 00    	je     ffffffff8100e752 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x26a>
                    counter = zero ? 0 : counter - 1;
ffffffff8100e6a8:	48 ff c8             	dec    %rax
ffffffff8100e6ab:	48 89 85 c0 00 00 00 	mov    %rax,0xc0(%rbp)
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff8100e6b2:	48 8b 85 98 00 00 00 	mov    0x98(%rbp),%rax
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff8100e6b9:	48 85 c0             	test   %rax,%rax
ffffffff8100e6bc:	0f 84 24 01 00 00    	je     ffffffff8100e7e6 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x2fe>
ffffffff8100e6c2:	48 8b 50 10          	mov    0x10(%rax),%rdx
ffffffff8100e6c6:	48 85 d2             	test   %rdx,%rdx
ffffffff8100e6c9:	0f 84 17 01 00 00    	je     ffffffff8100e7e6 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x2fe>
ffffffff8100e6cf:	48 8b 48 08          	mov    0x8(%rax),%rcx
ffffffff8100e6d3:	48 85 c9             	test   %rcx,%rcx
ffffffff8100e6d6:	0f 84 0a 01 00 00    	je     ffffffff8100e7e6 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x2fe>
                return false;

            if (t == t->next)
ffffffff8100e6dc:	48 39 d0             	cmp    %rdx,%rax
ffffffff8100e6df:	75 0d                	jne    ffffffff8100e6ee <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x206>
                headptr = nullptr;
ffffffff8100e6e1:	48 c7 85 98 00 00 00 	movq   $0x0,0x98(%rbp)
ffffffff8100e6e8:	00 00 00 00 
ffffffff8100e6ec:	eb 24                	jmp    ffffffff8100e712 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x22a>

            else {
                t->next->prev = t->prev;
ffffffff8100e6ee:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
                t->prev->next = t->next;
ffffffff8100e6f2:	48 8b 50 08          	mov    0x8(%rax),%rdx
ffffffff8100e6f6:	48 8b 48 10          	mov    0x10(%rax),%rcx
ffffffff8100e6fa:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
                if (t == headptr)
ffffffff8100e6fe:	48 3b 85 98 00 00 00 	cmp    0x98(%rbp),%rax
ffffffff8100e705:	75 0b                	jne    ffffffff8100e712 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x22a>
                    headptr = t->next;
ffffffff8100e707:	48 8b 50 10          	mov    0x10(%rax),%rdx
ffffffff8100e70b:	48 89 95 98 00 00 00 	mov    %rdx,0x98(%rbp)

    public:

        mword reset(bool l = false) {
            if (l) lock.lock();
            mword c = counter;
ffffffff8100e712:	48 8b 50 20          	mov    0x20(%rax),%rdx
            }

            t->next = t->prev = nullptr;
ffffffff8100e716:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
ffffffff8100e71d:	00 
ffffffff8100e71e:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
ffffffff8100e725:	00 
            counter = 0;
ffffffff8100e726:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
ffffffff8100e72d:	00 
                if (counter) {
                    counter = zero ? 0 : counter - 1;

                    Si * si;
                    if (Queue<Si>::dequeue(si = Queue<Si>::head()))
                        ec->set_si_regs(si->value, static_cast <Sm *>(si)->reset());
ffffffff8100e72e:	48 8b 40 18          	mov    0x18(%rax),%rax
    }

    ALWAYS_INLINE
    inline void set_si_regs(mword sig, mword cnt) {
        regs.ARG_2 = sig;
        regs.ARG_3 = cnt;
ffffffff8100e732:	48 89 93 10 01 00 00 	mov    %rdx,0x110(%rbx)
            timeout.dequeue();
    }

    ALWAYS_INLINE
    inline void set_si_regs(mword sig, mword cnt) {
        regs.ARG_2 = sig;
ffffffff8100e739:	48 89 83 f0 00 00 00 	mov    %rax,0xf0(%rbx)
ffffffff8100e740:	e9 a1 00 00 00       	jmpq   ffffffff8100e7e6 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x2fe>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8100e745:	8d 50 01             	lea    0x1(%rax),%edx
ffffffff8100e748:	f0 0f b1 93 8c 00 00 	lock cmpxchg %edx,0x8c(%rbx)
ffffffff8100e74f:	00 
ffffffff8100e750:	74 0a                	je     ffffffff8100e75c <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x274>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100e752:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff8100e758:	85 c0                	test   %eax,%eax
ffffffff8100e75a:	75 e9                	jne    ffffffff8100e745 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x25d>
        inline T *head() const { return headptr; }

        ALWAYS_INLINE
        inline void enqueue (T *t)
        {
            if (!headptr)
ffffffff8100e75c:	48 8b 85 90 00 00 00 	mov    0x90(%rbp),%rax
ffffffff8100e763:	48 85 c0             	test   %rax,%rax
ffffffff8100e766:	75 17                	jne    ffffffff8100e77f <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x297>
                headptr = t->prev = t->next = t;
ffffffff8100e768:	48 89 9b b0 02 00 00 	mov    %rbx,0x2b0(%rbx)
ffffffff8100e76f:	48 89 9b a8 02 00 00 	mov    %rbx,0x2a8(%rbx)
ffffffff8100e776:	48 89 9d 90 00 00 00 	mov    %rbx,0x90(%rbp)
ffffffff8100e77d:	eb 2a                	jmp    ffffffff8100e7a9 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x2c1>
            else {
                t->next = headptr;
ffffffff8100e77f:	48 89 83 b0 02 00 00 	mov    %rax,0x2b0(%rbx)
                t->prev = headptr->prev;
ffffffff8100e786:	48 8b 95 90 00 00 00 	mov    0x90(%rbp),%rdx
ffffffff8100e78d:	48 8b 92 a8 02 00 00 	mov    0x2a8(%rdx),%rdx
ffffffff8100e794:	48 89 93 a8 02 00 00 	mov    %rdx,0x2a8(%rbx)
                t->next->prev = t->prev->next = t;
ffffffff8100e79b:	48 89 9a b0 02 00 00 	mov    %rbx,0x2b0(%rdx)
ffffffff8100e7a2:	48 89 98 a8 02 00 00 	mov    %rbx,0x2a8(%rax)
ffffffff8100e7a9:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff8100e7af:	45 84 e4             	test   %r12b,%r12b
ffffffff8100e7b2:	74 50                	je     ffffffff8100e804 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x31c>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100e7b4:	80 3d 75 0f ff 3e 00 	cmpb   $0x0,0x3eff0f75(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100e7bb:	74 1f                	je     ffffffff8100e7dc <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x2f4>
ffffffff8100e7bd:	49 c7 c0 10 fb 01 81 	mov    $0xffffffff8101fb10,%r8
ffffffff8100e7c4:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff8100e7c9:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100e7d0:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff8100e7d7:	e9 64 fd ff ff       	jmpq   ffffffff8100e540 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x58>

            preemption = true;
ffffffff8100e7dc:	c6 05 4d 0f ff 3e 01 	movb   $0x1,0x3eff0f4d(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100e7e3:	fb                   	sti    
ffffffff8100e7e4:	eb 1e                	jmp    ffffffff8100e804 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x31c>
ffffffff8100e7e6:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
ffffffff8100e7ec:	45 84 e4             	test   %r12b,%r12b
ffffffff8100e7ef:	74 1b                	je     ffffffff8100e80c <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x324>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100e7f1:	80 3d 38 0f ff 3e 00 	cmpb   $0x0,0x3eff0f38(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100e7f8:	75 c3                	jne    ffffffff8100e7bd <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x2d5>

            preemption = true;
ffffffff8100e7fa:	c6 05 2f 0f ff 3e 01 	movb   $0x1,0x3eff0f2f(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100e801:	fb                   	sti    
ffffffff8100e802:	eb 08                	jmp    ffffffff8100e80c <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm+0x324>
            if (!block)
                Sc::schedule (false);

            ec->set_timeout (t, this);

            ec->block_sc();
ffffffff8100e804:	48 89 df             	mov    %rbx,%rdi
ffffffff8100e807:	e8 62 cf ff ff       	callq  ffffffff8100b76e <_ZN2Ec8block_scEv>

    die ("XCPU OOM error");
ffffffff8100e80c:	48 8b 05 f5 07 ff 3e 	mov    0x3eff07f5(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100e813:	48 c7 c7 89 e7 01 81 	mov    $0xffffffff8101e789,%rdi
ffffffff8100e81a:	48 8d b0 a8 00 00 00 	lea    0xa8(%rax),%rsi
ffffffff8100e821:	e8 e4 63 ff ff       	callq  ffffffff81004c0a <_ZN2Ec3dieEPKcP8Exc_regs>

ffffffff8100e826 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm>:
    ec->regs.set_ip (pt->ip);
    ec->make_current();
}

template <void (*C)()>
void Ec::oom_xcpu(Pt * pt, mword src_pd_id, mword oom_state)
ffffffff8100e826:	41 56                	push   %r14
ffffffff8100e828:	41 55                	push   %r13
ffffffff8100e82a:	41 54                	push   %r12
ffffffff8100e82c:	55                   	push   %rbp
ffffffff8100e82d:	53                   	push   %rbx
ffffffff8100e82e:	48 83 ec 10          	sub    $0x10,%rsp
{
    assert(current == this);
ffffffff8100e832:	48 8b 2d cf 07 ff 3e 	mov    0x3eff07cf(%rip),%rbp        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100e839:	48 39 fd             	cmp    %rdi,%rbp
ffffffff8100e83c:	74 1c                	je     ffffffff8100e85a <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x34>
ffffffff8100e83e:	49 c7 c0 40 f4 01 81 	mov    $0xffffffff8101f440,%r8
ffffffff8100e845:	b9 72 00 00 00       	mov    $0x72,%ecx
ffffffff8100e84a:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100e851:	48 c7 c6 6a e7 01 81 	mov    $0xffffffff8101e76a,%rsi
ffffffff8100e858:	eb 24                	jmp    ffffffff8100e87e <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x58>
    assert(!this->xcpu_sm);
ffffffff8100e85a:	48 83 bd 30 03 00 00 	cmpq   $0x0,0x330(%rbp)
ffffffff8100e861:	00 
ffffffff8100e862:	74 28                	je     ffffffff8100e88c <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x66>
ffffffff8100e864:	49 c7 c0 40 f4 01 81 	mov    $0xffffffff8101f440,%r8
ffffffff8100e86b:	b9 73 00 00 00       	mov    $0x73,%ecx
ffffffff8100e870:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100e877:	48 c7 c6 7a e7 01 81 	mov    $0xffffffff8101e77a,%rsi
ffffffff8100e87e:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100e885:	31 c0                	xor    %eax,%eax
ffffffff8100e887:	e8 c4 36 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

    enum { UNUSED = 0, CNT = 0 };

    this->xcpu_sm = new (Pd::current->quota) Sm (Pd::current, UNUSED, CNT);
ffffffff8100e88c:	48 8b 05 7d 07 ff 3e 	mov    0x3eff077d(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100e893:	49 89 f4             	mov    %rsi,%r12

            call_rcu(true);
        }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
ffffffff8100e896:	48 c7 c7 80 40 16 81 	mov    $0xffffffff81164080,%rdi
ffffffff8100e89d:	49 89 d6             	mov    %rdx,%r14
ffffffff8100e8a0:	49 89 cd             	mov    %rcx,%r13
ffffffff8100e8a3:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff8100e8aa:	e8 7f 70 00 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff8100e8af:	48 8b 35 5a 07 ff 3e 	mov    0x3eff075a(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100e8b6:	48 89 c3             	mov    %rax,%rbx
ffffffff8100e8b9:	45 31 c9             	xor    %r9d,%r9d
ffffffff8100e8bc:	31 c9                	xor    %ecx,%ecx
ffffffff8100e8be:	31 d2                	xor    %edx,%edx
ffffffff8100e8c0:	45 31 c0             	xor    %r8d,%r8d
ffffffff8100e8c3:	48 89 c7             	mov    %rax,%rdi
ffffffff8100e8c6:	e8 97 76 00 00       	callq  ffffffff81015f62 <_ZN2SmC1EP2PdmmPS_m>
ffffffff8100e8cb:	48 89 9d 30 03 00 00 	mov    %rbx,0x330(%rbp)

    Ec *xcpu_ec = new (Pd::current->quota) Ec (Pd::current, Pd::current, sys_xcpu_call_oom<C>, pt->ec->cpu, this);
ffffffff8100e8d2:	49 8b 84 24 90 00 00 	mov    0x90(%r12),%rax
ffffffff8100e8d9:	00 

    static void idl_handler();

    ALWAYS_INLINE
    static inline void *operator new (size_t, Quota &quota) {
        return cache.alloc(quota);
ffffffff8100e8da:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff8100e8e1:	44 0f b7 80 f0 02 00 	movzwl 0x2f0(%rax),%r8d
ffffffff8100e8e8:	00 
ffffffff8100e8e9:	48 8b 05 20 07 ff 3e 	mov    0x3eff0720(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100e8f0:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff8100e8f7:	44 89 44 24 0c       	mov    %r8d,0xc(%rsp)
ffffffff8100e8fc:	e8 2d 70 00 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff8100e901:	48 8b 35 08 07 ff 3e 	mov    0x3eff0708(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100e908:	44 8b 44 24 0c       	mov    0xc(%rsp),%r8d
ffffffff8100e90d:	49 89 e9             	mov    %rbp,%r9
ffffffff8100e910:	48 c7 c1 1c d5 00 81 	mov    $0xffffffff8100d51c,%rcx
ffffffff8100e917:	48 89 c7             	mov    %rax,%rdi
ffffffff8100e91a:	48 89 c3             	mov    %rax,%rbx
ffffffff8100e91d:	48 89 f2             	mov    %rsi,%rdx
ffffffff8100e920:	e8 f9 58 ff ff       	callq  ffffffff8100421e <_ZN2EcC1EP2PdS1_PFvvEjPS_>
    xcpu_ec->regs.set_pt (reinterpret_cast<mword>(pt), src_pd_id, oom_state);

    Sc *xcpu_sc = new (Pd::current->quota) Sc (Pd::current, xcpu_ec, xcpu_ec->cpu, Sc::current);
ffffffff8100e925:	48 8b 05 e4 06 ff 3e 	mov    0x3eff06e4(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100e92c:	4c 89 a3 e8 00 00 00 	mov    %r12,0xe8(%rbx)
ffffffff8100e933:	48 c7 c7 40 40 16 81 	mov    $0xffffffff81164040,%rdi
ffffffff8100e93a:	4c 89 b3 f0 00 00 00 	mov    %r14,0xf0(%rbx)
ffffffff8100e941:	4c 89 ab 10 01 00 00 	mov    %r13,0x110(%rbx)
ffffffff8100e948:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff8100e94f:	e8 da 6f 00 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff8100e954:	0f b7 8b f0 02 00 00 	movzwl 0x2f0(%rbx),%ecx
ffffffff8100e95b:	4c 8b 05 b6 06 ff 3e 	mov    0x3eff06b6(%rip),%r8        # ffffffffbffff018 <_ZN2Sc7currentE>
ffffffff8100e962:	49 89 c4             	mov    %rax,%r12
ffffffff8100e965:	48 8b 35 a4 06 ff 3e 	mov    0x3eff06a4(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100e96c:	48 89 da             	mov    %rbx,%rdx
ffffffff8100e96f:	48 89 c7             	mov    %rax,%rdi
ffffffff8100e972:	e8 5b 5d 00 00       	callq  ffffffff810146d2 <_ZN2ScC1EP2PdP2EcjPS_>

    xcpu_sc->remote_enqueue();
ffffffff8100e977:	4c 89 e7             	mov    %r12,%rdi
ffffffff8100e97a:	e8 e1 60 00 00       	callq  ffffffff81014a60 <_ZN2Sc14remote_enqueueEv>
    this->xcpu_sm->dn (false, 0);
ffffffff8100e97f:	48 8b ad 30 03 00 00 	mov    0x330(%rbp),%rbp
ffffffff8100e986:	48 8b 1d 7b 06 ff 3e 	mov    0x3eff067b(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>
        }

        ALWAYS_INLINE
        inline void dn (bool zero, uint64 t, Ec *ec = Ec::current, bool block = true)
        {
            {   Lock_guard <Spinlock> guard (lock);
ffffffff8100e98d:	48 8d bd 8a 00 00 00 	lea    0x8a(%rbp),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff8100e994:	9c                   	pushfq 
ffffffff8100e995:	41 5c                	pop    %r12
            return flags & 0x200;
ffffffff8100e997:	49 c1 ec 09          	shr    $0x9,%r12

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8100e99b:	41 80 e4 01          	and    $0x1,%r12b
ffffffff8100e99f:	74 30                	je     ffffffff8100e9d1 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x1ab>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff8100e9a1:	80 3d 88 0d ff 3e 00 	cmpb   $0x0,0x3eff0d88(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100e9a8:	75 1f                	jne    ffffffff8100e9c9 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x1a3>
ffffffff8100e9aa:	49 c7 c0 40 fb 01 81 	mov    $0xffffffff8101fb40,%r8
ffffffff8100e9b1:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff8100e9b6:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100e9bd:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff8100e9c4:	e9 b5 fe ff ff       	jmpq   ffffffff8100e87e <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x58>

            asm volatile ("cli" : : : "memory");
ffffffff8100e9c9:	fa                   	cli    
            preemption = false;
ffffffff8100e9ca:	c6 05 5f 0d ff 3e 00 	movb   $0x0,0x3eff0d5f(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff8100e9d1:	e8 b8 24 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>

                if (counter) {
ffffffff8100e9d6:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff8100e9dd:	48 85 c0             	test   %rax,%rax
ffffffff8100e9e0:	0f 84 aa 00 00 00    	je     ffffffff8100ea90 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x26a>
                    counter = zero ? 0 : counter - 1;
ffffffff8100e9e6:	48 ff c8             	dec    %rax
ffffffff8100e9e9:	48 89 85 c0 00 00 00 	mov    %rax,0xc0(%rbp)
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff8100e9f0:	48 8b 85 98 00 00 00 	mov    0x98(%rbp),%rax
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff8100e9f7:	48 85 c0             	test   %rax,%rax
ffffffff8100e9fa:	0f 84 24 01 00 00    	je     ffffffff8100eb24 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x2fe>
ffffffff8100ea00:	48 8b 50 10          	mov    0x10(%rax),%rdx
ffffffff8100ea04:	48 85 d2             	test   %rdx,%rdx
ffffffff8100ea07:	0f 84 17 01 00 00    	je     ffffffff8100eb24 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x2fe>
ffffffff8100ea0d:	48 8b 48 08          	mov    0x8(%rax),%rcx
ffffffff8100ea11:	48 85 c9             	test   %rcx,%rcx
ffffffff8100ea14:	0f 84 0a 01 00 00    	je     ffffffff8100eb24 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x2fe>
                return false;

            if (t == t->next)
ffffffff8100ea1a:	48 39 d0             	cmp    %rdx,%rax
ffffffff8100ea1d:	75 0d                	jne    ffffffff8100ea2c <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x206>
                headptr = nullptr;
ffffffff8100ea1f:	48 c7 85 98 00 00 00 	movq   $0x0,0x98(%rbp)
ffffffff8100ea26:	00 00 00 00 
ffffffff8100ea2a:	eb 24                	jmp    ffffffff8100ea50 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x22a>

            else {
                t->next->prev = t->prev;
ffffffff8100ea2c:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
                t->prev->next = t->next;
ffffffff8100ea30:	48 8b 50 08          	mov    0x8(%rax),%rdx
ffffffff8100ea34:	48 8b 48 10          	mov    0x10(%rax),%rcx
ffffffff8100ea38:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
                if (t == headptr)
ffffffff8100ea3c:	48 3b 85 98 00 00 00 	cmp    0x98(%rbp),%rax
ffffffff8100ea43:	75 0b                	jne    ffffffff8100ea50 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x22a>
                    headptr = t->next;
ffffffff8100ea45:	48 8b 50 10          	mov    0x10(%rax),%rdx
ffffffff8100ea49:	48 89 95 98 00 00 00 	mov    %rdx,0x98(%rbp)

    public:

        mword reset(bool l = false) {
            if (l) lock.lock();
            mword c = counter;
ffffffff8100ea50:	48 8b 50 20          	mov    0x20(%rax),%rdx
            }

            t->next = t->prev = nullptr;
ffffffff8100ea54:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
ffffffff8100ea5b:	00 
ffffffff8100ea5c:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
ffffffff8100ea63:	00 
            counter = 0;
ffffffff8100ea64:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
ffffffff8100ea6b:	00 
                if (counter) {
                    counter = zero ? 0 : counter - 1;

                    Si * si;
                    if (Queue<Si>::dequeue(si = Queue<Si>::head()))
                        ec->set_si_regs(si->value, static_cast <Sm *>(si)->reset());
ffffffff8100ea6c:	48 8b 40 18          	mov    0x18(%rax),%rax
    }

    ALWAYS_INLINE
    inline void set_si_regs(mword sig, mword cnt) {
        regs.ARG_2 = sig;
        regs.ARG_3 = cnt;
ffffffff8100ea70:	48 89 93 10 01 00 00 	mov    %rdx,0x110(%rbx)
            timeout.dequeue();
    }

    ALWAYS_INLINE
    inline void set_si_regs(mword sig, mword cnt) {
        regs.ARG_2 = sig;
ffffffff8100ea77:	48 89 83 f0 00 00 00 	mov    %rax,0xf0(%rbx)
ffffffff8100ea7e:	e9 a1 00 00 00       	jmpq   ffffffff8100eb24 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x2fe>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8100ea83:	8d 50 01             	lea    0x1(%rax),%edx
ffffffff8100ea86:	f0 0f b1 93 8c 00 00 	lock cmpxchg %edx,0x8c(%rbx)
ffffffff8100ea8d:	00 
ffffffff8100ea8e:	74 0a                	je     ffffffff8100ea9a <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x274>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100ea90:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff8100ea96:	85 c0                	test   %eax,%eax
ffffffff8100ea98:	75 e9                	jne    ffffffff8100ea83 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x25d>
        inline T *head() const { return headptr; }

        ALWAYS_INLINE
        inline void enqueue (T *t)
        {
            if (!headptr)
ffffffff8100ea9a:	48 8b 85 90 00 00 00 	mov    0x90(%rbp),%rax
ffffffff8100eaa1:	48 85 c0             	test   %rax,%rax
ffffffff8100eaa4:	75 17                	jne    ffffffff8100eabd <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x297>
                headptr = t->prev = t->next = t;
ffffffff8100eaa6:	48 89 9b b0 02 00 00 	mov    %rbx,0x2b0(%rbx)
ffffffff8100eaad:	48 89 9b a8 02 00 00 	mov    %rbx,0x2a8(%rbx)
ffffffff8100eab4:	48 89 9d 90 00 00 00 	mov    %rbx,0x90(%rbp)
ffffffff8100eabb:	eb 2a                	jmp    ffffffff8100eae7 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x2c1>
            else {
                t->next = headptr;
ffffffff8100eabd:	48 89 83 b0 02 00 00 	mov    %rax,0x2b0(%rbx)
                t->prev = headptr->prev;
ffffffff8100eac4:	48 8b 95 90 00 00 00 	mov    0x90(%rbp),%rdx
ffffffff8100eacb:	48 8b 92 a8 02 00 00 	mov    0x2a8(%rdx),%rdx
ffffffff8100ead2:	48 89 93 a8 02 00 00 	mov    %rdx,0x2a8(%rbx)
                t->next->prev = t->prev->next = t;
ffffffff8100ead9:	48 89 9a b0 02 00 00 	mov    %rbx,0x2b0(%rdx)
ffffffff8100eae0:	48 89 98 a8 02 00 00 	mov    %rbx,0x2a8(%rax)
ffffffff8100eae7:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff8100eaed:	45 84 e4             	test   %r12b,%r12b
ffffffff8100eaf0:	74 50                	je     ffffffff8100eb42 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x31c>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100eaf2:	80 3d 37 0c ff 3e 00 	cmpb   $0x0,0x3eff0c37(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100eaf9:	74 1f                	je     ffffffff8100eb1a <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x2f4>
ffffffff8100eafb:	49 c7 c0 10 fb 01 81 	mov    $0xffffffff8101fb10,%r8
ffffffff8100eb02:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff8100eb07:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100eb0e:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff8100eb15:	e9 64 fd ff ff       	jmpq   ffffffff8100e87e <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x58>

            preemption = true;
ffffffff8100eb1a:	c6 05 0f 0c ff 3e 01 	movb   $0x1,0x3eff0c0f(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100eb21:	fb                   	sti    
ffffffff8100eb22:	eb 1e                	jmp    ffffffff8100eb42 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x31c>
ffffffff8100eb24:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
ffffffff8100eb2a:	45 84 e4             	test   %r12b,%r12b
ffffffff8100eb2d:	74 1b                	je     ffffffff8100eb4a <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x324>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100eb2f:	80 3d fa 0b ff 3e 00 	cmpb   $0x0,0x3eff0bfa(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100eb36:	75 c3                	jne    ffffffff8100eafb <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x2d5>

            preemption = true;
ffffffff8100eb38:	c6 05 f1 0b ff 3e 01 	movb   $0x1,0x3eff0bf1(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100eb3f:	fb                   	sti    
ffffffff8100eb40:	eb 08                	jmp    ffffffff8100eb4a <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm+0x324>
            if (!block)
                Sc::schedule (false);

            ec->set_timeout (t, this);

            ec->block_sc();
ffffffff8100eb42:	48 89 df             	mov    %rbx,%rdi
ffffffff8100eb45:	e8 24 cc ff ff       	callq  ffffffff8100b76e <_ZN2Ec8block_scEv>

    die ("XCPU OOM error");
ffffffff8100eb4a:	48 8b 05 b7 04 ff 3e 	mov    0x3eff04b7(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100eb51:	48 c7 c7 89 e7 01 81 	mov    $0xffffffff8101e789,%rdi
ffffffff8100eb58:	48 8d b0 a8 00 00 00 	lea    0xa8(%rax),%rsi
ffffffff8100eb5f:	e8 a6 60 ff ff       	callq  ffffffff81004c0a <_ZN2Ec3dieEPKcP8Exc_regs>

ffffffff8100eb64 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm>:
    ec->regs.set_ip (pt->ip);
    ec->make_current();
}

template <void (*C)()>
void Ec::oom_xcpu(Pt * pt, mword src_pd_id, mword oom_state)
ffffffff8100eb64:	41 56                	push   %r14
ffffffff8100eb66:	41 55                	push   %r13
ffffffff8100eb68:	41 54                	push   %r12
ffffffff8100eb6a:	55                   	push   %rbp
ffffffff8100eb6b:	53                   	push   %rbx
ffffffff8100eb6c:	48 83 ec 10          	sub    $0x10,%rsp
{
    assert(current == this);
ffffffff8100eb70:	48 8b 2d 91 04 ff 3e 	mov    0x3eff0491(%rip),%rbp        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100eb77:	48 39 fd             	cmp    %rdi,%rbp
ffffffff8100eb7a:	74 1c                	je     ffffffff8100eb98 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x34>
ffffffff8100eb7c:	49 c7 c0 40 f2 01 81 	mov    $0xffffffff8101f240,%r8
ffffffff8100eb83:	b9 72 00 00 00       	mov    $0x72,%ecx
ffffffff8100eb88:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100eb8f:	48 c7 c6 6a e7 01 81 	mov    $0xffffffff8101e76a,%rsi
ffffffff8100eb96:	eb 24                	jmp    ffffffff8100ebbc <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x58>
    assert(!this->xcpu_sm);
ffffffff8100eb98:	48 83 bd 30 03 00 00 	cmpq   $0x0,0x330(%rbp)
ffffffff8100eb9f:	00 
ffffffff8100eba0:	74 28                	je     ffffffff8100ebca <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x66>
ffffffff8100eba2:	49 c7 c0 40 f2 01 81 	mov    $0xffffffff8101f240,%r8
ffffffff8100eba9:	b9 73 00 00 00       	mov    $0x73,%ecx
ffffffff8100ebae:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100ebb5:	48 c7 c6 7a e7 01 81 	mov    $0xffffffff8101e77a,%rsi
ffffffff8100ebbc:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100ebc3:	31 c0                	xor    %eax,%eax
ffffffff8100ebc5:	e8 86 33 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

    enum { UNUSED = 0, CNT = 0 };

    this->xcpu_sm = new (Pd::current->quota) Sm (Pd::current, UNUSED, CNT);
ffffffff8100ebca:	48 8b 05 3f 04 ff 3e 	mov    0x3eff043f(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100ebd1:	49 89 f4             	mov    %rsi,%r12

            call_rcu(true);
        }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
ffffffff8100ebd4:	48 c7 c7 80 40 16 81 	mov    $0xffffffff81164080,%rdi
ffffffff8100ebdb:	49 89 d6             	mov    %rdx,%r14
ffffffff8100ebde:	49 89 cd             	mov    %rcx,%r13
ffffffff8100ebe1:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff8100ebe8:	e8 41 6d 00 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff8100ebed:	48 8b 35 1c 04 ff 3e 	mov    0x3eff041c(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100ebf4:	48 89 c3             	mov    %rax,%rbx
ffffffff8100ebf7:	45 31 c9             	xor    %r9d,%r9d
ffffffff8100ebfa:	31 c9                	xor    %ecx,%ecx
ffffffff8100ebfc:	31 d2                	xor    %edx,%edx
ffffffff8100ebfe:	45 31 c0             	xor    %r8d,%r8d
ffffffff8100ec01:	48 89 c7             	mov    %rax,%rdi
ffffffff8100ec04:	e8 59 73 00 00       	callq  ffffffff81015f62 <_ZN2SmC1EP2PdmmPS_m>
ffffffff8100ec09:	48 89 9d 30 03 00 00 	mov    %rbx,0x330(%rbp)

    Ec *xcpu_ec = new (Pd::current->quota) Ec (Pd::current, Pd::current, sys_xcpu_call_oom<C>, pt->ec->cpu, this);
ffffffff8100ec10:	49 8b 84 24 90 00 00 	mov    0x90(%r12),%rax
ffffffff8100ec17:	00 

    static void idl_handler();

    ALWAYS_INLINE
    static inline void *operator new (size_t, Quota &quota) {
        return cache.alloc(quota);
ffffffff8100ec18:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff8100ec1f:	44 0f b7 80 f0 02 00 	movzwl 0x2f0(%rax),%r8d
ffffffff8100ec26:	00 
ffffffff8100ec27:	48 8b 05 e2 03 ff 3e 	mov    0x3eff03e2(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100ec2e:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff8100ec35:	44 89 44 24 0c       	mov    %r8d,0xc(%rsp)
ffffffff8100ec3a:	e8 ef 6c 00 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff8100ec3f:	48 8b 35 ca 03 ff 3e 	mov    0x3eff03ca(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100ec46:	44 8b 44 24 0c       	mov    0xc(%rsp),%r8d
ffffffff8100ec4b:	49 89 e9             	mov    %rbp,%r9
ffffffff8100ec4e:	48 c7 c1 7e d5 00 81 	mov    $0xffffffff8100d57e,%rcx
ffffffff8100ec55:	48 89 c7             	mov    %rax,%rdi
ffffffff8100ec58:	48 89 c3             	mov    %rax,%rbx
ffffffff8100ec5b:	48 89 f2             	mov    %rsi,%rdx
ffffffff8100ec5e:	e8 bb 55 ff ff       	callq  ffffffff8100421e <_ZN2EcC1EP2PdS1_PFvvEjPS_>
    xcpu_ec->regs.set_pt (reinterpret_cast<mword>(pt), src_pd_id, oom_state);

    Sc *xcpu_sc = new (Pd::current->quota) Sc (Pd::current, xcpu_ec, xcpu_ec->cpu, Sc::current);
ffffffff8100ec63:	48 8b 05 a6 03 ff 3e 	mov    0x3eff03a6(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100ec6a:	4c 89 a3 e8 00 00 00 	mov    %r12,0xe8(%rbx)
ffffffff8100ec71:	48 c7 c7 40 40 16 81 	mov    $0xffffffff81164040,%rdi
ffffffff8100ec78:	4c 89 b3 f0 00 00 00 	mov    %r14,0xf0(%rbx)
ffffffff8100ec7f:	4c 89 ab 10 01 00 00 	mov    %r13,0x110(%rbx)
ffffffff8100ec86:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff8100ec8d:	e8 9c 6c 00 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff8100ec92:	0f b7 8b f0 02 00 00 	movzwl 0x2f0(%rbx),%ecx
ffffffff8100ec99:	4c 8b 05 78 03 ff 3e 	mov    0x3eff0378(%rip),%r8        # ffffffffbffff018 <_ZN2Sc7currentE>
ffffffff8100eca0:	49 89 c4             	mov    %rax,%r12
ffffffff8100eca3:	48 8b 35 66 03 ff 3e 	mov    0x3eff0366(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100ecaa:	48 89 da             	mov    %rbx,%rdx
ffffffff8100ecad:	48 89 c7             	mov    %rax,%rdi
ffffffff8100ecb0:	e8 1d 5a 00 00       	callq  ffffffff810146d2 <_ZN2ScC1EP2PdP2EcjPS_>

    xcpu_sc->remote_enqueue();
ffffffff8100ecb5:	4c 89 e7             	mov    %r12,%rdi
ffffffff8100ecb8:	e8 a3 5d 00 00       	callq  ffffffff81014a60 <_ZN2Sc14remote_enqueueEv>
    this->xcpu_sm->dn (false, 0);
ffffffff8100ecbd:	48 8b ad 30 03 00 00 	mov    0x330(%rbp),%rbp
ffffffff8100ecc4:	48 8b 1d 3d 03 ff 3e 	mov    0x3eff033d(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>
        }

        ALWAYS_INLINE
        inline void dn (bool zero, uint64 t, Ec *ec = Ec::current, bool block = true)
        {
            {   Lock_guard <Spinlock> guard (lock);
ffffffff8100eccb:	48 8d bd 8a 00 00 00 	lea    0x8a(%rbp),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff8100ecd2:	9c                   	pushfq 
ffffffff8100ecd3:	41 5c                	pop    %r12
            return flags & 0x200;
ffffffff8100ecd5:	49 c1 ec 09          	shr    $0x9,%r12

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8100ecd9:	41 80 e4 01          	and    $0x1,%r12b
ffffffff8100ecdd:	74 30                	je     ffffffff8100ed0f <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x1ab>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff8100ecdf:	80 3d 4a 0a ff 3e 00 	cmpb   $0x0,0x3eff0a4a(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100ece6:	75 1f                	jne    ffffffff8100ed07 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x1a3>
ffffffff8100ece8:	49 c7 c0 40 fb 01 81 	mov    $0xffffffff8101fb40,%r8
ffffffff8100ecef:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff8100ecf4:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100ecfb:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff8100ed02:	e9 b5 fe ff ff       	jmpq   ffffffff8100ebbc <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x58>

            asm volatile ("cli" : : : "memory");
ffffffff8100ed07:	fa                   	cli    
            preemption = false;
ffffffff8100ed08:	c6 05 21 0a ff 3e 00 	movb   $0x0,0x3eff0a21(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff8100ed0f:	e8 7a 21 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>

                if (counter) {
ffffffff8100ed14:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff8100ed1b:	48 85 c0             	test   %rax,%rax
ffffffff8100ed1e:	0f 84 aa 00 00 00    	je     ffffffff8100edce <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x26a>
                    counter = zero ? 0 : counter - 1;
ffffffff8100ed24:	48 ff c8             	dec    %rax
ffffffff8100ed27:	48 89 85 c0 00 00 00 	mov    %rax,0xc0(%rbp)
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff8100ed2e:	48 8b 85 98 00 00 00 	mov    0x98(%rbp),%rax
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff8100ed35:	48 85 c0             	test   %rax,%rax
ffffffff8100ed38:	0f 84 24 01 00 00    	je     ffffffff8100ee62 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x2fe>
ffffffff8100ed3e:	48 8b 50 10          	mov    0x10(%rax),%rdx
ffffffff8100ed42:	48 85 d2             	test   %rdx,%rdx
ffffffff8100ed45:	0f 84 17 01 00 00    	je     ffffffff8100ee62 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x2fe>
ffffffff8100ed4b:	48 8b 48 08          	mov    0x8(%rax),%rcx
ffffffff8100ed4f:	48 85 c9             	test   %rcx,%rcx
ffffffff8100ed52:	0f 84 0a 01 00 00    	je     ffffffff8100ee62 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x2fe>
                return false;

            if (t == t->next)
ffffffff8100ed58:	48 39 d0             	cmp    %rdx,%rax
ffffffff8100ed5b:	75 0d                	jne    ffffffff8100ed6a <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x206>
                headptr = nullptr;
ffffffff8100ed5d:	48 c7 85 98 00 00 00 	movq   $0x0,0x98(%rbp)
ffffffff8100ed64:	00 00 00 00 
ffffffff8100ed68:	eb 24                	jmp    ffffffff8100ed8e <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x22a>

            else {
                t->next->prev = t->prev;
ffffffff8100ed6a:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
                t->prev->next = t->next;
ffffffff8100ed6e:	48 8b 50 08          	mov    0x8(%rax),%rdx
ffffffff8100ed72:	48 8b 48 10          	mov    0x10(%rax),%rcx
ffffffff8100ed76:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
                if (t == headptr)
ffffffff8100ed7a:	48 3b 85 98 00 00 00 	cmp    0x98(%rbp),%rax
ffffffff8100ed81:	75 0b                	jne    ffffffff8100ed8e <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x22a>
                    headptr = t->next;
ffffffff8100ed83:	48 8b 50 10          	mov    0x10(%rax),%rdx
ffffffff8100ed87:	48 89 95 98 00 00 00 	mov    %rdx,0x98(%rbp)

    public:

        mword reset(bool l = false) {
            if (l) lock.lock();
            mword c = counter;
ffffffff8100ed8e:	48 8b 50 20          	mov    0x20(%rax),%rdx
            }

            t->next = t->prev = nullptr;
ffffffff8100ed92:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
ffffffff8100ed99:	00 
ffffffff8100ed9a:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
ffffffff8100eda1:	00 
            counter = 0;
ffffffff8100eda2:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
ffffffff8100eda9:	00 
                if (counter) {
                    counter = zero ? 0 : counter - 1;

                    Si * si;
                    if (Queue<Si>::dequeue(si = Queue<Si>::head()))
                        ec->set_si_regs(si->value, static_cast <Sm *>(si)->reset());
ffffffff8100edaa:	48 8b 40 18          	mov    0x18(%rax),%rax
    }

    ALWAYS_INLINE
    inline void set_si_regs(mword sig, mword cnt) {
        regs.ARG_2 = sig;
        regs.ARG_3 = cnt;
ffffffff8100edae:	48 89 93 10 01 00 00 	mov    %rdx,0x110(%rbx)
            timeout.dequeue();
    }

    ALWAYS_INLINE
    inline void set_si_regs(mword sig, mword cnt) {
        regs.ARG_2 = sig;
ffffffff8100edb5:	48 89 83 f0 00 00 00 	mov    %rax,0xf0(%rbx)
ffffffff8100edbc:	e9 a1 00 00 00       	jmpq   ffffffff8100ee62 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x2fe>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8100edc1:	8d 50 01             	lea    0x1(%rax),%edx
ffffffff8100edc4:	f0 0f b1 93 8c 00 00 	lock cmpxchg %edx,0x8c(%rbx)
ffffffff8100edcb:	00 
ffffffff8100edcc:	74 0a                	je     ffffffff8100edd8 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x274>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100edce:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff8100edd4:	85 c0                	test   %eax,%eax
ffffffff8100edd6:	75 e9                	jne    ffffffff8100edc1 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x25d>
        inline T *head() const { return headptr; }

        ALWAYS_INLINE
        inline void enqueue (T *t)
        {
            if (!headptr)
ffffffff8100edd8:	48 8b 85 90 00 00 00 	mov    0x90(%rbp),%rax
ffffffff8100eddf:	48 85 c0             	test   %rax,%rax
ffffffff8100ede2:	75 17                	jne    ffffffff8100edfb <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x297>
                headptr = t->prev = t->next = t;
ffffffff8100ede4:	48 89 9b b0 02 00 00 	mov    %rbx,0x2b0(%rbx)
ffffffff8100edeb:	48 89 9b a8 02 00 00 	mov    %rbx,0x2a8(%rbx)
ffffffff8100edf2:	48 89 9d 90 00 00 00 	mov    %rbx,0x90(%rbp)
ffffffff8100edf9:	eb 2a                	jmp    ffffffff8100ee25 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x2c1>
            else {
                t->next = headptr;
ffffffff8100edfb:	48 89 83 b0 02 00 00 	mov    %rax,0x2b0(%rbx)
                t->prev = headptr->prev;
ffffffff8100ee02:	48 8b 95 90 00 00 00 	mov    0x90(%rbp),%rdx
ffffffff8100ee09:	48 8b 92 a8 02 00 00 	mov    0x2a8(%rdx),%rdx
ffffffff8100ee10:	48 89 93 a8 02 00 00 	mov    %rdx,0x2a8(%rbx)
                t->next->prev = t->prev->next = t;
ffffffff8100ee17:	48 89 9a b0 02 00 00 	mov    %rbx,0x2b0(%rdx)
ffffffff8100ee1e:	48 89 98 a8 02 00 00 	mov    %rbx,0x2a8(%rax)
ffffffff8100ee25:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff8100ee2b:	45 84 e4             	test   %r12b,%r12b
ffffffff8100ee2e:	74 50                	je     ffffffff8100ee80 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x31c>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100ee30:	80 3d f9 08 ff 3e 00 	cmpb   $0x0,0x3eff08f9(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100ee37:	74 1f                	je     ffffffff8100ee58 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x2f4>
ffffffff8100ee39:	49 c7 c0 10 fb 01 81 	mov    $0xffffffff8101fb10,%r8
ffffffff8100ee40:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff8100ee45:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100ee4c:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff8100ee53:	e9 64 fd ff ff       	jmpq   ffffffff8100ebbc <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x58>

            preemption = true;
ffffffff8100ee58:	c6 05 d1 08 ff 3e 01 	movb   $0x1,0x3eff08d1(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100ee5f:	fb                   	sti    
ffffffff8100ee60:	eb 1e                	jmp    ffffffff8100ee80 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x31c>
ffffffff8100ee62:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
ffffffff8100ee68:	45 84 e4             	test   %r12b,%r12b
ffffffff8100ee6b:	74 1b                	je     ffffffff8100ee88 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x324>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100ee6d:	80 3d bc 08 ff 3e 00 	cmpb   $0x0,0x3eff08bc(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100ee74:	75 c3                	jne    ffffffff8100ee39 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x2d5>

            preemption = true;
ffffffff8100ee76:	c6 05 b3 08 ff 3e 01 	movb   $0x1,0x3eff08b3(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100ee7d:	fb                   	sti    
ffffffff8100ee7e:	eb 08                	jmp    ffffffff8100ee88 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm+0x324>
            if (!block)
                Sc::schedule (false);

            ec->set_timeout (t, this);

            ec->block_sc();
ffffffff8100ee80:	48 89 df             	mov    %rbx,%rdi
ffffffff8100ee83:	e8 e6 c8 ff ff       	callq  ffffffff8100b76e <_ZN2Ec8block_scEv>

    die ("XCPU OOM error");
ffffffff8100ee88:	48 8b 05 79 01 ff 3e 	mov    0x3eff0179(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100ee8f:	48 c7 c7 89 e7 01 81 	mov    $0xffffffff8101e789,%rdi
ffffffff8100ee96:	48 8d b0 a8 00 00 00 	lea    0xa8(%rax),%rsi
ffffffff8100ee9d:	e8 68 5d ff ff       	callq  ffffffff81004c0a <_ZN2Ec3dieEPKcP8Exc_regs>

ffffffff8100eea2 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm>:
    ec->regs.set_ip (pt->ip);
    ec->make_current();
}

template <void (*C)()>
void Ec::oom_xcpu(Pt * pt, mword src_pd_id, mword oom_state)
ffffffff8100eea2:	41 56                	push   %r14
ffffffff8100eea4:	41 55                	push   %r13
ffffffff8100eea6:	41 54                	push   %r12
ffffffff8100eea8:	55                   	push   %rbp
ffffffff8100eea9:	53                   	push   %rbx
ffffffff8100eeaa:	48 83 ec 10          	sub    $0x10,%rsp
{
    assert(current == this);
ffffffff8100eeae:	48 8b 2d 53 01 ff 3e 	mov    0x3eff0153(%rip),%rbp        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100eeb5:	48 39 fd             	cmp    %rdi,%rbp
ffffffff8100eeb8:	74 1c                	je     ffffffff8100eed6 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x34>
ffffffff8100eeba:	49 c7 c0 40 f0 01 81 	mov    $0xffffffff8101f040,%r8
ffffffff8100eec1:	b9 72 00 00 00       	mov    $0x72,%ecx
ffffffff8100eec6:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100eecd:	48 c7 c6 6a e7 01 81 	mov    $0xffffffff8101e76a,%rsi
ffffffff8100eed4:	eb 24                	jmp    ffffffff8100eefa <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x58>
    assert(!this->xcpu_sm);
ffffffff8100eed6:	48 83 bd 30 03 00 00 	cmpq   $0x0,0x330(%rbp)
ffffffff8100eedd:	00 
ffffffff8100eede:	74 28                	je     ffffffff8100ef08 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x66>
ffffffff8100eee0:	49 c7 c0 40 f0 01 81 	mov    $0xffffffff8101f040,%r8
ffffffff8100eee7:	b9 73 00 00 00       	mov    $0x73,%ecx
ffffffff8100eeec:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100eef3:	48 c7 c6 7a e7 01 81 	mov    $0xffffffff8101e77a,%rsi
ffffffff8100eefa:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100ef01:	31 c0                	xor    %eax,%eax
ffffffff8100ef03:	e8 48 30 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

    enum { UNUSED = 0, CNT = 0 };

    this->xcpu_sm = new (Pd::current->quota) Sm (Pd::current, UNUSED, CNT);
ffffffff8100ef08:	48 8b 05 01 01 ff 3e 	mov    0x3eff0101(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100ef0f:	49 89 f4             	mov    %rsi,%r12

            call_rcu(true);
        }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
ffffffff8100ef12:	48 c7 c7 80 40 16 81 	mov    $0xffffffff81164080,%rdi
ffffffff8100ef19:	49 89 d6             	mov    %rdx,%r14
ffffffff8100ef1c:	49 89 cd             	mov    %rcx,%r13
ffffffff8100ef1f:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff8100ef26:	e8 03 6a 00 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff8100ef2b:	48 8b 35 de 00 ff 3e 	mov    0x3eff00de(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100ef32:	48 89 c3             	mov    %rax,%rbx
ffffffff8100ef35:	45 31 c9             	xor    %r9d,%r9d
ffffffff8100ef38:	31 c9                	xor    %ecx,%ecx
ffffffff8100ef3a:	31 d2                	xor    %edx,%edx
ffffffff8100ef3c:	45 31 c0             	xor    %r8d,%r8d
ffffffff8100ef3f:	48 89 c7             	mov    %rax,%rdi
ffffffff8100ef42:	e8 1b 70 00 00       	callq  ffffffff81015f62 <_ZN2SmC1EP2PdmmPS_m>
ffffffff8100ef47:	48 89 9d 30 03 00 00 	mov    %rbx,0x330(%rbp)

    Ec *xcpu_ec = new (Pd::current->quota) Ec (Pd::current, Pd::current, sys_xcpu_call_oom<C>, pt->ec->cpu, this);
ffffffff8100ef4e:	49 8b 84 24 90 00 00 	mov    0x90(%r12),%rax
ffffffff8100ef55:	00 

    static void idl_handler();

    ALWAYS_INLINE
    static inline void *operator new (size_t, Quota &quota) {
        return cache.alloc(quota);
ffffffff8100ef56:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff8100ef5d:	44 0f b7 80 f0 02 00 	movzwl 0x2f0(%rax),%r8d
ffffffff8100ef64:	00 
ffffffff8100ef65:	48 8b 05 a4 00 ff 3e 	mov    0x3eff00a4(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100ef6c:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff8100ef73:	44 89 44 24 0c       	mov    %r8d,0xc(%rsp)
ffffffff8100ef78:	e8 b1 69 00 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff8100ef7d:	48 8b 35 8c 00 ff 3e 	mov    0x3eff008c(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100ef84:	44 8b 44 24 0c       	mov    0xc(%rsp),%r8d
ffffffff8100ef89:	49 89 e9             	mov    %rbp,%r9
ffffffff8100ef8c:	48 c7 c1 e0 d5 00 81 	mov    $0xffffffff8100d5e0,%rcx
ffffffff8100ef93:	48 89 c7             	mov    %rax,%rdi
ffffffff8100ef96:	48 89 c3             	mov    %rax,%rbx
ffffffff8100ef99:	48 89 f2             	mov    %rsi,%rdx
ffffffff8100ef9c:	e8 7d 52 ff ff       	callq  ffffffff8100421e <_ZN2EcC1EP2PdS1_PFvvEjPS_>
    xcpu_ec->regs.set_pt (reinterpret_cast<mword>(pt), src_pd_id, oom_state);

    Sc *xcpu_sc = new (Pd::current->quota) Sc (Pd::current, xcpu_ec, xcpu_ec->cpu, Sc::current);
ffffffff8100efa1:	48 8b 05 68 00 ff 3e 	mov    0x3eff0068(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100efa8:	4c 89 a3 e8 00 00 00 	mov    %r12,0xe8(%rbx)
ffffffff8100efaf:	48 c7 c7 40 40 16 81 	mov    $0xffffffff81164040,%rdi
ffffffff8100efb6:	4c 89 b3 f0 00 00 00 	mov    %r14,0xf0(%rbx)
ffffffff8100efbd:	4c 89 ab 10 01 00 00 	mov    %r13,0x110(%rbx)
ffffffff8100efc4:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff8100efcb:	e8 5e 69 00 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff8100efd0:	0f b7 8b f0 02 00 00 	movzwl 0x2f0(%rbx),%ecx
ffffffff8100efd7:	4c 8b 05 3a 00 ff 3e 	mov    0x3eff003a(%rip),%r8        # ffffffffbffff018 <_ZN2Sc7currentE>
ffffffff8100efde:	49 89 c4             	mov    %rax,%r12
ffffffff8100efe1:	48 8b 35 28 00 ff 3e 	mov    0x3eff0028(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100efe8:	48 89 da             	mov    %rbx,%rdx
ffffffff8100efeb:	48 89 c7             	mov    %rax,%rdi
ffffffff8100efee:	e8 df 56 00 00       	callq  ffffffff810146d2 <_ZN2ScC1EP2PdP2EcjPS_>

    xcpu_sc->remote_enqueue();
ffffffff8100eff3:	4c 89 e7             	mov    %r12,%rdi
ffffffff8100eff6:	e8 65 5a 00 00       	callq  ffffffff81014a60 <_ZN2Sc14remote_enqueueEv>
    this->xcpu_sm->dn (false, 0);
ffffffff8100effb:	48 8b ad 30 03 00 00 	mov    0x330(%rbp),%rbp
ffffffff8100f002:	48 8b 1d ff ff fe 3e 	mov    0x3efeffff(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>
        }

        ALWAYS_INLINE
        inline void dn (bool zero, uint64 t, Ec *ec = Ec::current, bool block = true)
        {
            {   Lock_guard <Spinlock> guard (lock);
ffffffff8100f009:	48 8d bd 8a 00 00 00 	lea    0x8a(%rbp),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff8100f010:	9c                   	pushfq 
ffffffff8100f011:	41 5c                	pop    %r12
            return flags & 0x200;
ffffffff8100f013:	49 c1 ec 09          	shr    $0x9,%r12

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8100f017:	41 80 e4 01          	and    $0x1,%r12b
ffffffff8100f01b:	74 30                	je     ffffffff8100f04d <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x1ab>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff8100f01d:	80 3d 0c 07 ff 3e 00 	cmpb   $0x0,0x3eff070c(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100f024:	75 1f                	jne    ffffffff8100f045 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x1a3>
ffffffff8100f026:	49 c7 c0 40 fb 01 81 	mov    $0xffffffff8101fb40,%r8
ffffffff8100f02d:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff8100f032:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100f039:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff8100f040:	e9 b5 fe ff ff       	jmpq   ffffffff8100eefa <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x58>

            asm volatile ("cli" : : : "memory");
ffffffff8100f045:	fa                   	cli    
            preemption = false;
ffffffff8100f046:	c6 05 e3 06 ff 3e 00 	movb   $0x0,0x3eff06e3(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff8100f04d:	e8 3c 1e ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>

                if (counter) {
ffffffff8100f052:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff8100f059:	48 85 c0             	test   %rax,%rax
ffffffff8100f05c:	0f 84 aa 00 00 00    	je     ffffffff8100f10c <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x26a>
                    counter = zero ? 0 : counter - 1;
ffffffff8100f062:	48 ff c8             	dec    %rax
ffffffff8100f065:	48 89 85 c0 00 00 00 	mov    %rax,0xc0(%rbp)
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff8100f06c:	48 8b 85 98 00 00 00 	mov    0x98(%rbp),%rax
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff8100f073:	48 85 c0             	test   %rax,%rax
ffffffff8100f076:	0f 84 24 01 00 00    	je     ffffffff8100f1a0 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x2fe>
ffffffff8100f07c:	48 8b 50 10          	mov    0x10(%rax),%rdx
ffffffff8100f080:	48 85 d2             	test   %rdx,%rdx
ffffffff8100f083:	0f 84 17 01 00 00    	je     ffffffff8100f1a0 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x2fe>
ffffffff8100f089:	48 8b 48 08          	mov    0x8(%rax),%rcx
ffffffff8100f08d:	48 85 c9             	test   %rcx,%rcx
ffffffff8100f090:	0f 84 0a 01 00 00    	je     ffffffff8100f1a0 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x2fe>
                return false;

            if (t == t->next)
ffffffff8100f096:	48 39 d0             	cmp    %rdx,%rax
ffffffff8100f099:	75 0d                	jne    ffffffff8100f0a8 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x206>
                headptr = nullptr;
ffffffff8100f09b:	48 c7 85 98 00 00 00 	movq   $0x0,0x98(%rbp)
ffffffff8100f0a2:	00 00 00 00 
ffffffff8100f0a6:	eb 24                	jmp    ffffffff8100f0cc <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x22a>

            else {
                t->next->prev = t->prev;
ffffffff8100f0a8:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
                t->prev->next = t->next;
ffffffff8100f0ac:	48 8b 50 08          	mov    0x8(%rax),%rdx
ffffffff8100f0b0:	48 8b 48 10          	mov    0x10(%rax),%rcx
ffffffff8100f0b4:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
                if (t == headptr)
ffffffff8100f0b8:	48 3b 85 98 00 00 00 	cmp    0x98(%rbp),%rax
ffffffff8100f0bf:	75 0b                	jne    ffffffff8100f0cc <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x22a>
                    headptr = t->next;
ffffffff8100f0c1:	48 8b 50 10          	mov    0x10(%rax),%rdx
ffffffff8100f0c5:	48 89 95 98 00 00 00 	mov    %rdx,0x98(%rbp)

    public:

        mword reset(bool l = false) {
            if (l) lock.lock();
            mword c = counter;
ffffffff8100f0cc:	48 8b 50 20          	mov    0x20(%rax),%rdx
            }

            t->next = t->prev = nullptr;
ffffffff8100f0d0:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
ffffffff8100f0d7:	00 
ffffffff8100f0d8:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
ffffffff8100f0df:	00 
            counter = 0;
ffffffff8100f0e0:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
ffffffff8100f0e7:	00 
                if (counter) {
                    counter = zero ? 0 : counter - 1;

                    Si * si;
                    if (Queue<Si>::dequeue(si = Queue<Si>::head()))
                        ec->set_si_regs(si->value, static_cast <Sm *>(si)->reset());
ffffffff8100f0e8:	48 8b 40 18          	mov    0x18(%rax),%rax
    }

    ALWAYS_INLINE
    inline void set_si_regs(mword sig, mword cnt) {
        regs.ARG_2 = sig;
        regs.ARG_3 = cnt;
ffffffff8100f0ec:	48 89 93 10 01 00 00 	mov    %rdx,0x110(%rbx)
            timeout.dequeue();
    }

    ALWAYS_INLINE
    inline void set_si_regs(mword sig, mword cnt) {
        regs.ARG_2 = sig;
ffffffff8100f0f3:	48 89 83 f0 00 00 00 	mov    %rax,0xf0(%rbx)
ffffffff8100f0fa:	e9 a1 00 00 00       	jmpq   ffffffff8100f1a0 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x2fe>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8100f0ff:	8d 50 01             	lea    0x1(%rax),%edx
ffffffff8100f102:	f0 0f b1 93 8c 00 00 	lock cmpxchg %edx,0x8c(%rbx)
ffffffff8100f109:	00 
ffffffff8100f10a:	74 0a                	je     ffffffff8100f116 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x274>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100f10c:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff8100f112:	85 c0                	test   %eax,%eax
ffffffff8100f114:	75 e9                	jne    ffffffff8100f0ff <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x25d>
        inline T *head() const { return headptr; }

        ALWAYS_INLINE
        inline void enqueue (T *t)
        {
            if (!headptr)
ffffffff8100f116:	48 8b 85 90 00 00 00 	mov    0x90(%rbp),%rax
ffffffff8100f11d:	48 85 c0             	test   %rax,%rax
ffffffff8100f120:	75 17                	jne    ffffffff8100f139 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x297>
                headptr = t->prev = t->next = t;
ffffffff8100f122:	48 89 9b b0 02 00 00 	mov    %rbx,0x2b0(%rbx)
ffffffff8100f129:	48 89 9b a8 02 00 00 	mov    %rbx,0x2a8(%rbx)
ffffffff8100f130:	48 89 9d 90 00 00 00 	mov    %rbx,0x90(%rbp)
ffffffff8100f137:	eb 2a                	jmp    ffffffff8100f163 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x2c1>
            else {
                t->next = headptr;
ffffffff8100f139:	48 89 83 b0 02 00 00 	mov    %rax,0x2b0(%rbx)
                t->prev = headptr->prev;
ffffffff8100f140:	48 8b 95 90 00 00 00 	mov    0x90(%rbp),%rdx
ffffffff8100f147:	48 8b 92 a8 02 00 00 	mov    0x2a8(%rdx),%rdx
ffffffff8100f14e:	48 89 93 a8 02 00 00 	mov    %rdx,0x2a8(%rbx)
                t->next->prev = t->prev->next = t;
ffffffff8100f155:	48 89 9a b0 02 00 00 	mov    %rbx,0x2b0(%rdx)
ffffffff8100f15c:	48 89 98 a8 02 00 00 	mov    %rbx,0x2a8(%rax)
ffffffff8100f163:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff8100f169:	45 84 e4             	test   %r12b,%r12b
ffffffff8100f16c:	74 50                	je     ffffffff8100f1be <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x31c>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100f16e:	80 3d bb 05 ff 3e 00 	cmpb   $0x0,0x3eff05bb(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100f175:	74 1f                	je     ffffffff8100f196 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x2f4>
ffffffff8100f177:	49 c7 c0 10 fb 01 81 	mov    $0xffffffff8101fb10,%r8
ffffffff8100f17e:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff8100f183:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100f18a:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff8100f191:	e9 64 fd ff ff       	jmpq   ffffffff8100eefa <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x58>

            preemption = true;
ffffffff8100f196:	c6 05 93 05 ff 3e 01 	movb   $0x1,0x3eff0593(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100f19d:	fb                   	sti    
ffffffff8100f19e:	eb 1e                	jmp    ffffffff8100f1be <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x31c>
ffffffff8100f1a0:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
ffffffff8100f1a6:	45 84 e4             	test   %r12b,%r12b
ffffffff8100f1a9:	74 1b                	je     ffffffff8100f1c6 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x324>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100f1ab:	80 3d 7e 05 ff 3e 00 	cmpb   $0x0,0x3eff057e(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100f1b2:	75 c3                	jne    ffffffff8100f177 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x2d5>

            preemption = true;
ffffffff8100f1b4:	c6 05 75 05 ff 3e 01 	movb   $0x1,0x3eff0575(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100f1bb:	fb                   	sti    
ffffffff8100f1bc:	eb 08                	jmp    ffffffff8100f1c6 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm+0x324>
            if (!block)
                Sc::schedule (false);

            ec->set_timeout (t, this);

            ec->block_sc();
ffffffff8100f1be:	48 89 df             	mov    %rbx,%rdi
ffffffff8100f1c1:	e8 a8 c5 ff ff       	callq  ffffffff8100b76e <_ZN2Ec8block_scEv>

    die ("XCPU OOM error");
ffffffff8100f1c6:	48 8b 05 3b fe fe 3e 	mov    0x3efefe3b(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100f1cd:	48 c7 c7 89 e7 01 81 	mov    $0xffffffff8101e789,%rdi
ffffffff8100f1d4:	48 8d b0 a8 00 00 00 	lea    0xa8(%rax),%rsi
ffffffff8100f1db:	e8 2a 5a ff ff       	callq  ffffffff81004c0a <_ZN2Ec3dieEPKcP8Exc_regs>

ffffffff8100f1e0 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm>:
    ec->regs.set_ip (pt->ip);
    ec->make_current();
}

template <void (*C)()>
void Ec::oom_xcpu(Pt * pt, mword src_pd_id, mword oom_state)
ffffffff8100f1e0:	41 56                	push   %r14
ffffffff8100f1e2:	41 55                	push   %r13
ffffffff8100f1e4:	41 54                	push   %r12
ffffffff8100f1e6:	55                   	push   %rbp
ffffffff8100f1e7:	53                   	push   %rbx
ffffffff8100f1e8:	48 83 ec 10          	sub    $0x10,%rsp
{
    assert(current == this);
ffffffff8100f1ec:	48 8b 2d 15 fe fe 3e 	mov    0x3efefe15(%rip),%rbp        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100f1f3:	48 39 fd             	cmp    %rdi,%rbp
ffffffff8100f1f6:	74 1c                	je     ffffffff8100f214 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x34>
ffffffff8100f1f8:	49 c7 c0 40 ee 01 81 	mov    $0xffffffff8101ee40,%r8
ffffffff8100f1ff:	b9 72 00 00 00       	mov    $0x72,%ecx
ffffffff8100f204:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100f20b:	48 c7 c6 6a e7 01 81 	mov    $0xffffffff8101e76a,%rsi
ffffffff8100f212:	eb 24                	jmp    ffffffff8100f238 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x58>
    assert(!this->xcpu_sm);
ffffffff8100f214:	48 83 bd 30 03 00 00 	cmpq   $0x0,0x330(%rbp)
ffffffff8100f21b:	00 
ffffffff8100f21c:	74 28                	je     ffffffff8100f246 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x66>
ffffffff8100f21e:	49 c7 c0 40 ee 01 81 	mov    $0xffffffff8101ee40,%r8
ffffffff8100f225:	b9 73 00 00 00       	mov    $0x73,%ecx
ffffffff8100f22a:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100f231:	48 c7 c6 7a e7 01 81 	mov    $0xffffffff8101e77a,%rsi
ffffffff8100f238:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100f23f:	31 c0                	xor    %eax,%eax
ffffffff8100f241:	e8 0a 2d ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

    enum { UNUSED = 0, CNT = 0 };

    this->xcpu_sm = new (Pd::current->quota) Sm (Pd::current, UNUSED, CNT);
ffffffff8100f246:	48 8b 05 c3 fd fe 3e 	mov    0x3efefdc3(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100f24d:	49 89 f4             	mov    %rsi,%r12

            call_rcu(true);
        }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
ffffffff8100f250:	48 c7 c7 80 40 16 81 	mov    $0xffffffff81164080,%rdi
ffffffff8100f257:	49 89 d6             	mov    %rdx,%r14
ffffffff8100f25a:	49 89 cd             	mov    %rcx,%r13
ffffffff8100f25d:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff8100f264:	e8 c5 66 00 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff8100f269:	48 8b 35 a0 fd fe 3e 	mov    0x3efefda0(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100f270:	48 89 c3             	mov    %rax,%rbx
ffffffff8100f273:	45 31 c9             	xor    %r9d,%r9d
ffffffff8100f276:	31 c9                	xor    %ecx,%ecx
ffffffff8100f278:	31 d2                	xor    %edx,%edx
ffffffff8100f27a:	45 31 c0             	xor    %r8d,%r8d
ffffffff8100f27d:	48 89 c7             	mov    %rax,%rdi
ffffffff8100f280:	e8 dd 6c 00 00       	callq  ffffffff81015f62 <_ZN2SmC1EP2PdmmPS_m>
ffffffff8100f285:	48 89 9d 30 03 00 00 	mov    %rbx,0x330(%rbp)

    Ec *xcpu_ec = new (Pd::current->quota) Ec (Pd::current, Pd::current, sys_xcpu_call_oom<C>, pt->ec->cpu, this);
ffffffff8100f28c:	49 8b 84 24 90 00 00 	mov    0x90(%r12),%rax
ffffffff8100f293:	00 

    static void idl_handler();

    ALWAYS_INLINE
    static inline void *operator new (size_t, Quota &quota) {
        return cache.alloc(quota);
ffffffff8100f294:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff8100f29b:	44 0f b7 80 f0 02 00 	movzwl 0x2f0(%rax),%r8d
ffffffff8100f2a2:	00 
ffffffff8100f2a3:	48 8b 05 66 fd fe 3e 	mov    0x3efefd66(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100f2aa:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff8100f2b1:	44 89 44 24 0c       	mov    %r8d,0xc(%rsp)
ffffffff8100f2b6:	e8 73 66 00 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff8100f2bb:	48 8b 35 4e fd fe 3e 	mov    0x3efefd4e(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100f2c2:	44 8b 44 24 0c       	mov    0xc(%rsp),%r8d
ffffffff8100f2c7:	49 89 e9             	mov    %rbp,%r9
ffffffff8100f2ca:	48 c7 c1 42 d6 00 81 	mov    $0xffffffff8100d642,%rcx
ffffffff8100f2d1:	48 89 c7             	mov    %rax,%rdi
ffffffff8100f2d4:	48 89 c3             	mov    %rax,%rbx
ffffffff8100f2d7:	48 89 f2             	mov    %rsi,%rdx
ffffffff8100f2da:	e8 3f 4f ff ff       	callq  ffffffff8100421e <_ZN2EcC1EP2PdS1_PFvvEjPS_>
    xcpu_ec->regs.set_pt (reinterpret_cast<mword>(pt), src_pd_id, oom_state);

    Sc *xcpu_sc = new (Pd::current->quota) Sc (Pd::current, xcpu_ec, xcpu_ec->cpu, Sc::current);
ffffffff8100f2df:	48 8b 05 2a fd fe 3e 	mov    0x3efefd2a(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100f2e6:	4c 89 a3 e8 00 00 00 	mov    %r12,0xe8(%rbx)
ffffffff8100f2ed:	48 c7 c7 40 40 16 81 	mov    $0xffffffff81164040,%rdi
ffffffff8100f2f4:	4c 89 b3 f0 00 00 00 	mov    %r14,0xf0(%rbx)
ffffffff8100f2fb:	4c 89 ab 10 01 00 00 	mov    %r13,0x110(%rbx)
ffffffff8100f302:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff8100f309:	e8 20 66 00 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff8100f30e:	0f b7 8b f0 02 00 00 	movzwl 0x2f0(%rbx),%ecx
ffffffff8100f315:	4c 8b 05 fc fc fe 3e 	mov    0x3efefcfc(%rip),%r8        # ffffffffbffff018 <_ZN2Sc7currentE>
ffffffff8100f31c:	49 89 c4             	mov    %rax,%r12
ffffffff8100f31f:	48 8b 35 ea fc fe 3e 	mov    0x3efefcea(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100f326:	48 89 da             	mov    %rbx,%rdx
ffffffff8100f329:	48 89 c7             	mov    %rax,%rdi
ffffffff8100f32c:	e8 a1 53 00 00       	callq  ffffffff810146d2 <_ZN2ScC1EP2PdP2EcjPS_>

    xcpu_sc->remote_enqueue();
ffffffff8100f331:	4c 89 e7             	mov    %r12,%rdi
ffffffff8100f334:	e8 27 57 00 00       	callq  ffffffff81014a60 <_ZN2Sc14remote_enqueueEv>
    this->xcpu_sm->dn (false, 0);
ffffffff8100f339:	48 8b ad 30 03 00 00 	mov    0x330(%rbp),%rbp
ffffffff8100f340:	48 8b 1d c1 fc fe 3e 	mov    0x3efefcc1(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>
        }

        ALWAYS_INLINE
        inline void dn (bool zero, uint64 t, Ec *ec = Ec::current, bool block = true)
        {
            {   Lock_guard <Spinlock> guard (lock);
ffffffff8100f347:	48 8d bd 8a 00 00 00 	lea    0x8a(%rbp),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff8100f34e:	9c                   	pushfq 
ffffffff8100f34f:	41 5c                	pop    %r12
            return flags & 0x200;
ffffffff8100f351:	49 c1 ec 09          	shr    $0x9,%r12

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8100f355:	41 80 e4 01          	and    $0x1,%r12b
ffffffff8100f359:	74 30                	je     ffffffff8100f38b <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x1ab>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff8100f35b:	80 3d ce 03 ff 3e 00 	cmpb   $0x0,0x3eff03ce(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100f362:	75 1f                	jne    ffffffff8100f383 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x1a3>
ffffffff8100f364:	49 c7 c0 40 fb 01 81 	mov    $0xffffffff8101fb40,%r8
ffffffff8100f36b:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff8100f370:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100f377:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff8100f37e:	e9 b5 fe ff ff       	jmpq   ffffffff8100f238 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x58>

            asm volatile ("cli" : : : "memory");
ffffffff8100f383:	fa                   	cli    
            preemption = false;
ffffffff8100f384:	c6 05 a5 03 ff 3e 00 	movb   $0x0,0x3eff03a5(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff8100f38b:	e8 fe 1a ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>

                if (counter) {
ffffffff8100f390:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff8100f397:	48 85 c0             	test   %rax,%rax
ffffffff8100f39a:	0f 84 aa 00 00 00    	je     ffffffff8100f44a <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x26a>
                    counter = zero ? 0 : counter - 1;
ffffffff8100f3a0:	48 ff c8             	dec    %rax
ffffffff8100f3a3:	48 89 85 c0 00 00 00 	mov    %rax,0xc0(%rbp)
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff8100f3aa:	48 8b 85 98 00 00 00 	mov    0x98(%rbp),%rax
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff8100f3b1:	48 85 c0             	test   %rax,%rax
ffffffff8100f3b4:	0f 84 24 01 00 00    	je     ffffffff8100f4de <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x2fe>
ffffffff8100f3ba:	48 8b 50 10          	mov    0x10(%rax),%rdx
ffffffff8100f3be:	48 85 d2             	test   %rdx,%rdx
ffffffff8100f3c1:	0f 84 17 01 00 00    	je     ffffffff8100f4de <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x2fe>
ffffffff8100f3c7:	48 8b 48 08          	mov    0x8(%rax),%rcx
ffffffff8100f3cb:	48 85 c9             	test   %rcx,%rcx
ffffffff8100f3ce:	0f 84 0a 01 00 00    	je     ffffffff8100f4de <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x2fe>
                return false;

            if (t == t->next)
ffffffff8100f3d4:	48 39 d0             	cmp    %rdx,%rax
ffffffff8100f3d7:	75 0d                	jne    ffffffff8100f3e6 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x206>
                headptr = nullptr;
ffffffff8100f3d9:	48 c7 85 98 00 00 00 	movq   $0x0,0x98(%rbp)
ffffffff8100f3e0:	00 00 00 00 
ffffffff8100f3e4:	eb 24                	jmp    ffffffff8100f40a <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x22a>

            else {
                t->next->prev = t->prev;
ffffffff8100f3e6:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
                t->prev->next = t->next;
ffffffff8100f3ea:	48 8b 50 08          	mov    0x8(%rax),%rdx
ffffffff8100f3ee:	48 8b 48 10          	mov    0x10(%rax),%rcx
ffffffff8100f3f2:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
                if (t == headptr)
ffffffff8100f3f6:	48 3b 85 98 00 00 00 	cmp    0x98(%rbp),%rax
ffffffff8100f3fd:	75 0b                	jne    ffffffff8100f40a <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x22a>
                    headptr = t->next;
ffffffff8100f3ff:	48 8b 50 10          	mov    0x10(%rax),%rdx
ffffffff8100f403:	48 89 95 98 00 00 00 	mov    %rdx,0x98(%rbp)

    public:

        mword reset(bool l = false) {
            if (l) lock.lock();
            mword c = counter;
ffffffff8100f40a:	48 8b 50 20          	mov    0x20(%rax),%rdx
            }

            t->next = t->prev = nullptr;
ffffffff8100f40e:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
ffffffff8100f415:	00 
ffffffff8100f416:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
ffffffff8100f41d:	00 
            counter = 0;
ffffffff8100f41e:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
ffffffff8100f425:	00 
                if (counter) {
                    counter = zero ? 0 : counter - 1;

                    Si * si;
                    if (Queue<Si>::dequeue(si = Queue<Si>::head()))
                        ec->set_si_regs(si->value, static_cast <Sm *>(si)->reset());
ffffffff8100f426:	48 8b 40 18          	mov    0x18(%rax),%rax
    }

    ALWAYS_INLINE
    inline void set_si_regs(mword sig, mword cnt) {
        regs.ARG_2 = sig;
        regs.ARG_3 = cnt;
ffffffff8100f42a:	48 89 93 10 01 00 00 	mov    %rdx,0x110(%rbx)
            timeout.dequeue();
    }

    ALWAYS_INLINE
    inline void set_si_regs(mword sig, mword cnt) {
        regs.ARG_2 = sig;
ffffffff8100f431:	48 89 83 f0 00 00 00 	mov    %rax,0xf0(%rbx)
ffffffff8100f438:	e9 a1 00 00 00       	jmpq   ffffffff8100f4de <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x2fe>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8100f43d:	8d 50 01             	lea    0x1(%rax),%edx
ffffffff8100f440:	f0 0f b1 93 8c 00 00 	lock cmpxchg %edx,0x8c(%rbx)
ffffffff8100f447:	00 
ffffffff8100f448:	74 0a                	je     ffffffff8100f454 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x274>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100f44a:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff8100f450:	85 c0                	test   %eax,%eax
ffffffff8100f452:	75 e9                	jne    ffffffff8100f43d <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x25d>
        inline T *head() const { return headptr; }

        ALWAYS_INLINE
        inline void enqueue (T *t)
        {
            if (!headptr)
ffffffff8100f454:	48 8b 85 90 00 00 00 	mov    0x90(%rbp),%rax
ffffffff8100f45b:	48 85 c0             	test   %rax,%rax
ffffffff8100f45e:	75 17                	jne    ffffffff8100f477 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x297>
                headptr = t->prev = t->next = t;
ffffffff8100f460:	48 89 9b b0 02 00 00 	mov    %rbx,0x2b0(%rbx)
ffffffff8100f467:	48 89 9b a8 02 00 00 	mov    %rbx,0x2a8(%rbx)
ffffffff8100f46e:	48 89 9d 90 00 00 00 	mov    %rbx,0x90(%rbp)
ffffffff8100f475:	eb 2a                	jmp    ffffffff8100f4a1 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x2c1>
            else {
                t->next = headptr;
ffffffff8100f477:	48 89 83 b0 02 00 00 	mov    %rax,0x2b0(%rbx)
                t->prev = headptr->prev;
ffffffff8100f47e:	48 8b 95 90 00 00 00 	mov    0x90(%rbp),%rdx
ffffffff8100f485:	48 8b 92 a8 02 00 00 	mov    0x2a8(%rdx),%rdx
ffffffff8100f48c:	48 89 93 a8 02 00 00 	mov    %rdx,0x2a8(%rbx)
                t->next->prev = t->prev->next = t;
ffffffff8100f493:	48 89 9a b0 02 00 00 	mov    %rbx,0x2b0(%rdx)
ffffffff8100f49a:	48 89 98 a8 02 00 00 	mov    %rbx,0x2a8(%rax)
ffffffff8100f4a1:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff8100f4a7:	45 84 e4             	test   %r12b,%r12b
ffffffff8100f4aa:	74 50                	je     ffffffff8100f4fc <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x31c>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100f4ac:	80 3d 7d 02 ff 3e 00 	cmpb   $0x0,0x3eff027d(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100f4b3:	74 1f                	je     ffffffff8100f4d4 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x2f4>
ffffffff8100f4b5:	49 c7 c0 10 fb 01 81 	mov    $0xffffffff8101fb10,%r8
ffffffff8100f4bc:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff8100f4c1:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100f4c8:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff8100f4cf:	e9 64 fd ff ff       	jmpq   ffffffff8100f238 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x58>

            preemption = true;
ffffffff8100f4d4:	c6 05 55 02 ff 3e 01 	movb   $0x1,0x3eff0255(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100f4db:	fb                   	sti    
ffffffff8100f4dc:	eb 1e                	jmp    ffffffff8100f4fc <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x31c>
ffffffff8100f4de:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
ffffffff8100f4e4:	45 84 e4             	test   %r12b,%r12b
ffffffff8100f4e7:	74 1b                	je     ffffffff8100f504 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x324>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100f4e9:	80 3d 40 02 ff 3e 00 	cmpb   $0x0,0x3eff0240(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100f4f0:	75 c3                	jne    ffffffff8100f4b5 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x2d5>

            preemption = true;
ffffffff8100f4f2:	c6 05 37 02 ff 3e 01 	movb   $0x1,0x3eff0237(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100f4f9:	fb                   	sti    
ffffffff8100f4fa:	eb 08                	jmp    ffffffff8100f504 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm+0x324>
            if (!block)
                Sc::schedule (false);

            ec->set_timeout (t, this);

            ec->block_sc();
ffffffff8100f4fc:	48 89 df             	mov    %rbx,%rdi
ffffffff8100f4ff:	e8 6a c2 ff ff       	callq  ffffffff8100b76e <_ZN2Ec8block_scEv>

    die ("XCPU OOM error");
ffffffff8100f504:	48 8b 05 fd fa fe 3e 	mov    0x3efefafd(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100f50b:	48 c7 c7 89 e7 01 81 	mov    $0xffffffff8101e789,%rdi
ffffffff8100f512:	48 8d b0 a8 00 00 00 	lea    0xa8(%rax),%rsi
ffffffff8100f519:	e8 ec 56 ff ff       	callq  ffffffff81004c0a <_ZN2Ec3dieEPKcP8Exc_regs>

ffffffff8100f51e <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm>:
    ec->regs.set_ip (pt->ip);
    ec->make_current();
}

template <void (*C)()>
void Ec::oom_xcpu(Pt * pt, mword src_pd_id, mword oom_state)
ffffffff8100f51e:	41 56                	push   %r14
ffffffff8100f520:	41 55                	push   %r13
ffffffff8100f522:	41 54                	push   %r12
ffffffff8100f524:	55                   	push   %rbp
ffffffff8100f525:	53                   	push   %rbx
ffffffff8100f526:	48 83 ec 10          	sub    $0x10,%rsp
{
    assert(current == this);
ffffffff8100f52a:	48 8b 2d d7 fa fe 3e 	mov    0x3efefad7(%rip),%rbp        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100f531:	48 39 fd             	cmp    %rdi,%rbp
ffffffff8100f534:	74 1c                	je     ffffffff8100f552 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x34>
ffffffff8100f536:	49 c7 c0 40 ec 01 81 	mov    $0xffffffff8101ec40,%r8
ffffffff8100f53d:	b9 72 00 00 00       	mov    $0x72,%ecx
ffffffff8100f542:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100f549:	48 c7 c6 6a e7 01 81 	mov    $0xffffffff8101e76a,%rsi
ffffffff8100f550:	eb 24                	jmp    ffffffff8100f576 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x58>
    assert(!this->xcpu_sm);
ffffffff8100f552:	48 83 bd 30 03 00 00 	cmpq   $0x0,0x330(%rbp)
ffffffff8100f559:	00 
ffffffff8100f55a:	74 28                	je     ffffffff8100f584 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x66>
ffffffff8100f55c:	49 c7 c0 40 ec 01 81 	mov    $0xffffffff8101ec40,%r8
ffffffff8100f563:	b9 73 00 00 00       	mov    $0x73,%ecx
ffffffff8100f568:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100f56f:	48 c7 c6 7a e7 01 81 	mov    $0xffffffff8101e77a,%rsi
ffffffff8100f576:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100f57d:	31 c0                	xor    %eax,%eax
ffffffff8100f57f:	e8 cc 29 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

    enum { UNUSED = 0, CNT = 0 };

    this->xcpu_sm = new (Pd::current->quota) Sm (Pd::current, UNUSED, CNT);
ffffffff8100f584:	48 8b 05 85 fa fe 3e 	mov    0x3efefa85(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100f58b:	49 89 f4             	mov    %rsi,%r12

            call_rcu(true);
        }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
ffffffff8100f58e:	48 c7 c7 80 40 16 81 	mov    $0xffffffff81164080,%rdi
ffffffff8100f595:	49 89 d6             	mov    %rdx,%r14
ffffffff8100f598:	49 89 cd             	mov    %rcx,%r13
ffffffff8100f59b:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff8100f5a2:	e8 87 63 00 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff8100f5a7:	48 8b 35 62 fa fe 3e 	mov    0x3efefa62(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100f5ae:	48 89 c3             	mov    %rax,%rbx
ffffffff8100f5b1:	45 31 c9             	xor    %r9d,%r9d
ffffffff8100f5b4:	31 c9                	xor    %ecx,%ecx
ffffffff8100f5b6:	31 d2                	xor    %edx,%edx
ffffffff8100f5b8:	45 31 c0             	xor    %r8d,%r8d
ffffffff8100f5bb:	48 89 c7             	mov    %rax,%rdi
ffffffff8100f5be:	e8 9f 69 00 00       	callq  ffffffff81015f62 <_ZN2SmC1EP2PdmmPS_m>
ffffffff8100f5c3:	48 89 9d 30 03 00 00 	mov    %rbx,0x330(%rbp)

    Ec *xcpu_ec = new (Pd::current->quota) Ec (Pd::current, Pd::current, sys_xcpu_call_oom<C>, pt->ec->cpu, this);
ffffffff8100f5ca:	49 8b 84 24 90 00 00 	mov    0x90(%r12),%rax
ffffffff8100f5d1:	00 

    static void idl_handler();

    ALWAYS_INLINE
    static inline void *operator new (size_t, Quota &quota) {
        return cache.alloc(quota);
ffffffff8100f5d2:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff8100f5d9:	44 0f b7 80 f0 02 00 	movzwl 0x2f0(%rax),%r8d
ffffffff8100f5e0:	00 
ffffffff8100f5e1:	48 8b 05 28 fa fe 3e 	mov    0x3efefa28(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100f5e8:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff8100f5ef:	44 89 44 24 0c       	mov    %r8d,0xc(%rsp)
ffffffff8100f5f4:	e8 35 63 00 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff8100f5f9:	48 8b 35 10 fa fe 3e 	mov    0x3efefa10(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100f600:	44 8b 44 24 0c       	mov    0xc(%rsp),%r8d
ffffffff8100f605:	49 89 e9             	mov    %rbp,%r9
ffffffff8100f608:	48 c7 c1 a4 d6 00 81 	mov    $0xffffffff8100d6a4,%rcx
ffffffff8100f60f:	48 89 c7             	mov    %rax,%rdi
ffffffff8100f612:	48 89 c3             	mov    %rax,%rbx
ffffffff8100f615:	48 89 f2             	mov    %rsi,%rdx
ffffffff8100f618:	e8 01 4c ff ff       	callq  ffffffff8100421e <_ZN2EcC1EP2PdS1_PFvvEjPS_>
    xcpu_ec->regs.set_pt (reinterpret_cast<mword>(pt), src_pd_id, oom_state);

    Sc *xcpu_sc = new (Pd::current->quota) Sc (Pd::current, xcpu_ec, xcpu_ec->cpu, Sc::current);
ffffffff8100f61d:	48 8b 05 ec f9 fe 3e 	mov    0x3efef9ec(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100f624:	4c 89 a3 e8 00 00 00 	mov    %r12,0xe8(%rbx)
ffffffff8100f62b:	48 c7 c7 40 40 16 81 	mov    $0xffffffff81164040,%rdi
ffffffff8100f632:	4c 89 b3 f0 00 00 00 	mov    %r14,0xf0(%rbx)
ffffffff8100f639:	4c 89 ab 10 01 00 00 	mov    %r13,0x110(%rbx)
ffffffff8100f640:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff8100f647:	e8 e2 62 00 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff8100f64c:	0f b7 8b f0 02 00 00 	movzwl 0x2f0(%rbx),%ecx
ffffffff8100f653:	4c 8b 05 be f9 fe 3e 	mov    0x3efef9be(%rip),%r8        # ffffffffbffff018 <_ZN2Sc7currentE>
ffffffff8100f65a:	49 89 c4             	mov    %rax,%r12
ffffffff8100f65d:	48 8b 35 ac f9 fe 3e 	mov    0x3efef9ac(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100f664:	48 89 da             	mov    %rbx,%rdx
ffffffff8100f667:	48 89 c7             	mov    %rax,%rdi
ffffffff8100f66a:	e8 63 50 00 00       	callq  ffffffff810146d2 <_ZN2ScC1EP2PdP2EcjPS_>

    xcpu_sc->remote_enqueue();
ffffffff8100f66f:	4c 89 e7             	mov    %r12,%rdi
ffffffff8100f672:	e8 e9 53 00 00       	callq  ffffffff81014a60 <_ZN2Sc14remote_enqueueEv>
    this->xcpu_sm->dn (false, 0);
ffffffff8100f677:	48 8b ad 30 03 00 00 	mov    0x330(%rbp),%rbp
ffffffff8100f67e:	48 8b 1d 83 f9 fe 3e 	mov    0x3efef983(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>
        }

        ALWAYS_INLINE
        inline void dn (bool zero, uint64 t, Ec *ec = Ec::current, bool block = true)
        {
            {   Lock_guard <Spinlock> guard (lock);
ffffffff8100f685:	48 8d bd 8a 00 00 00 	lea    0x8a(%rbp),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff8100f68c:	9c                   	pushfq 
ffffffff8100f68d:	41 5c                	pop    %r12
            return flags & 0x200;
ffffffff8100f68f:	49 c1 ec 09          	shr    $0x9,%r12

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8100f693:	41 80 e4 01          	and    $0x1,%r12b
ffffffff8100f697:	74 30                	je     ffffffff8100f6c9 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x1ab>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff8100f699:	80 3d 90 00 ff 3e 00 	cmpb   $0x0,0x3eff0090(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100f6a0:	75 1f                	jne    ffffffff8100f6c1 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x1a3>
ffffffff8100f6a2:	49 c7 c0 40 fb 01 81 	mov    $0xffffffff8101fb40,%r8
ffffffff8100f6a9:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff8100f6ae:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100f6b5:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff8100f6bc:	e9 b5 fe ff ff       	jmpq   ffffffff8100f576 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x58>

            asm volatile ("cli" : : : "memory");
ffffffff8100f6c1:	fa                   	cli    
            preemption = false;
ffffffff8100f6c2:	c6 05 67 00 ff 3e 00 	movb   $0x0,0x3eff0067(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff8100f6c9:	e8 c0 17 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>

                if (counter) {
ffffffff8100f6ce:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff8100f6d5:	48 85 c0             	test   %rax,%rax
ffffffff8100f6d8:	0f 84 aa 00 00 00    	je     ffffffff8100f788 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x26a>
                    counter = zero ? 0 : counter - 1;
ffffffff8100f6de:	48 ff c8             	dec    %rax
ffffffff8100f6e1:	48 89 85 c0 00 00 00 	mov    %rax,0xc0(%rbp)
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff8100f6e8:	48 8b 85 98 00 00 00 	mov    0x98(%rbp),%rax
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff8100f6ef:	48 85 c0             	test   %rax,%rax
ffffffff8100f6f2:	0f 84 24 01 00 00    	je     ffffffff8100f81c <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x2fe>
ffffffff8100f6f8:	48 8b 50 10          	mov    0x10(%rax),%rdx
ffffffff8100f6fc:	48 85 d2             	test   %rdx,%rdx
ffffffff8100f6ff:	0f 84 17 01 00 00    	je     ffffffff8100f81c <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x2fe>
ffffffff8100f705:	48 8b 48 08          	mov    0x8(%rax),%rcx
ffffffff8100f709:	48 85 c9             	test   %rcx,%rcx
ffffffff8100f70c:	0f 84 0a 01 00 00    	je     ffffffff8100f81c <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x2fe>
                return false;

            if (t == t->next)
ffffffff8100f712:	48 39 d0             	cmp    %rdx,%rax
ffffffff8100f715:	75 0d                	jne    ffffffff8100f724 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x206>
                headptr = nullptr;
ffffffff8100f717:	48 c7 85 98 00 00 00 	movq   $0x0,0x98(%rbp)
ffffffff8100f71e:	00 00 00 00 
ffffffff8100f722:	eb 24                	jmp    ffffffff8100f748 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x22a>

            else {
                t->next->prev = t->prev;
ffffffff8100f724:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
                t->prev->next = t->next;
ffffffff8100f728:	48 8b 50 08          	mov    0x8(%rax),%rdx
ffffffff8100f72c:	48 8b 48 10          	mov    0x10(%rax),%rcx
ffffffff8100f730:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
                if (t == headptr)
ffffffff8100f734:	48 3b 85 98 00 00 00 	cmp    0x98(%rbp),%rax
ffffffff8100f73b:	75 0b                	jne    ffffffff8100f748 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x22a>
                    headptr = t->next;
ffffffff8100f73d:	48 8b 50 10          	mov    0x10(%rax),%rdx
ffffffff8100f741:	48 89 95 98 00 00 00 	mov    %rdx,0x98(%rbp)

    public:

        mword reset(bool l = false) {
            if (l) lock.lock();
            mword c = counter;
ffffffff8100f748:	48 8b 50 20          	mov    0x20(%rax),%rdx
            }

            t->next = t->prev = nullptr;
ffffffff8100f74c:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
ffffffff8100f753:	00 
ffffffff8100f754:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
ffffffff8100f75b:	00 
            counter = 0;
ffffffff8100f75c:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
ffffffff8100f763:	00 
                if (counter) {
                    counter = zero ? 0 : counter - 1;

                    Si * si;
                    if (Queue<Si>::dequeue(si = Queue<Si>::head()))
                        ec->set_si_regs(si->value, static_cast <Sm *>(si)->reset());
ffffffff8100f764:	48 8b 40 18          	mov    0x18(%rax),%rax
    }

    ALWAYS_INLINE
    inline void set_si_regs(mword sig, mword cnt) {
        regs.ARG_2 = sig;
        regs.ARG_3 = cnt;
ffffffff8100f768:	48 89 93 10 01 00 00 	mov    %rdx,0x110(%rbx)
            timeout.dequeue();
    }

    ALWAYS_INLINE
    inline void set_si_regs(mword sig, mword cnt) {
        regs.ARG_2 = sig;
ffffffff8100f76f:	48 89 83 f0 00 00 00 	mov    %rax,0xf0(%rbx)
ffffffff8100f776:	e9 a1 00 00 00       	jmpq   ffffffff8100f81c <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x2fe>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8100f77b:	8d 50 01             	lea    0x1(%rax),%edx
ffffffff8100f77e:	f0 0f b1 93 8c 00 00 	lock cmpxchg %edx,0x8c(%rbx)
ffffffff8100f785:	00 
ffffffff8100f786:	74 0a                	je     ffffffff8100f792 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x274>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100f788:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff8100f78e:	85 c0                	test   %eax,%eax
ffffffff8100f790:	75 e9                	jne    ffffffff8100f77b <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x25d>
        inline T *head() const { return headptr; }

        ALWAYS_INLINE
        inline void enqueue (T *t)
        {
            if (!headptr)
ffffffff8100f792:	48 8b 85 90 00 00 00 	mov    0x90(%rbp),%rax
ffffffff8100f799:	48 85 c0             	test   %rax,%rax
ffffffff8100f79c:	75 17                	jne    ffffffff8100f7b5 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x297>
                headptr = t->prev = t->next = t;
ffffffff8100f79e:	48 89 9b b0 02 00 00 	mov    %rbx,0x2b0(%rbx)
ffffffff8100f7a5:	48 89 9b a8 02 00 00 	mov    %rbx,0x2a8(%rbx)
ffffffff8100f7ac:	48 89 9d 90 00 00 00 	mov    %rbx,0x90(%rbp)
ffffffff8100f7b3:	eb 2a                	jmp    ffffffff8100f7df <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x2c1>
            else {
                t->next = headptr;
ffffffff8100f7b5:	48 89 83 b0 02 00 00 	mov    %rax,0x2b0(%rbx)
                t->prev = headptr->prev;
ffffffff8100f7bc:	48 8b 95 90 00 00 00 	mov    0x90(%rbp),%rdx
ffffffff8100f7c3:	48 8b 92 a8 02 00 00 	mov    0x2a8(%rdx),%rdx
ffffffff8100f7ca:	48 89 93 a8 02 00 00 	mov    %rdx,0x2a8(%rbx)
                t->next->prev = t->prev->next = t;
ffffffff8100f7d1:	48 89 9a b0 02 00 00 	mov    %rbx,0x2b0(%rdx)
ffffffff8100f7d8:	48 89 98 a8 02 00 00 	mov    %rbx,0x2a8(%rax)
ffffffff8100f7df:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff8100f7e5:	45 84 e4             	test   %r12b,%r12b
ffffffff8100f7e8:	74 50                	je     ffffffff8100f83a <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x31c>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100f7ea:	80 3d 3f ff fe 3e 00 	cmpb   $0x0,0x3efeff3f(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100f7f1:	74 1f                	je     ffffffff8100f812 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x2f4>
ffffffff8100f7f3:	49 c7 c0 10 fb 01 81 	mov    $0xffffffff8101fb10,%r8
ffffffff8100f7fa:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff8100f7ff:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100f806:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff8100f80d:	e9 64 fd ff ff       	jmpq   ffffffff8100f576 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x58>

            preemption = true;
ffffffff8100f812:	c6 05 17 ff fe 3e 01 	movb   $0x1,0x3efeff17(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100f819:	fb                   	sti    
ffffffff8100f81a:	eb 1e                	jmp    ffffffff8100f83a <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x31c>
ffffffff8100f81c:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
ffffffff8100f822:	45 84 e4             	test   %r12b,%r12b
ffffffff8100f825:	74 1b                	je     ffffffff8100f842 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x324>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100f827:	80 3d 02 ff fe 3e 00 	cmpb   $0x0,0x3efeff02(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100f82e:	75 c3                	jne    ffffffff8100f7f3 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x2d5>

            preemption = true;
ffffffff8100f830:	c6 05 f9 fe fe 3e 01 	movb   $0x1,0x3efefef9(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100f837:	fb                   	sti    
ffffffff8100f838:	eb 08                	jmp    ffffffff8100f842 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm+0x324>
            if (!block)
                Sc::schedule (false);

            ec->set_timeout (t, this);

            ec->block_sc();
ffffffff8100f83a:	48 89 df             	mov    %rbx,%rdi
ffffffff8100f83d:	e8 2c bf ff ff       	callq  ffffffff8100b76e <_ZN2Ec8block_scEv>

    die ("XCPU OOM error");
ffffffff8100f842:	48 8b 05 bf f7 fe 3e 	mov    0x3efef7bf(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100f849:	48 c7 c7 89 e7 01 81 	mov    $0xffffffff8101e789,%rdi
ffffffff8100f850:	48 8d b0 a8 00 00 00 	lea    0xa8(%rax),%rsi
ffffffff8100f857:	e8 ae 53 ff ff       	callq  ffffffff81004c0a <_ZN2Ec3dieEPKcP8Exc_regs>

ffffffff8100f85c <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm>:
    ec->regs.set_ip (pt->ip);
    ec->make_current();
}

template <void (*C)()>
void Ec::oom_xcpu(Pt * pt, mword src_pd_id, mword oom_state)
ffffffff8100f85c:	41 56                	push   %r14
ffffffff8100f85e:	41 55                	push   %r13
ffffffff8100f860:	41 54                	push   %r12
ffffffff8100f862:	55                   	push   %rbp
ffffffff8100f863:	53                   	push   %rbx
ffffffff8100f864:	48 83 ec 10          	sub    $0x10,%rsp
{
    assert(current == this);
ffffffff8100f868:	48 8b 2d 99 f7 fe 3e 	mov    0x3efef799(%rip),%rbp        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100f86f:	48 39 fd             	cmp    %rdi,%rbp
ffffffff8100f872:	74 1c                	je     ffffffff8100f890 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x34>
ffffffff8100f874:	49 c7 c0 40 ea 01 81 	mov    $0xffffffff8101ea40,%r8
ffffffff8100f87b:	b9 72 00 00 00       	mov    $0x72,%ecx
ffffffff8100f880:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100f887:	48 c7 c6 6a e7 01 81 	mov    $0xffffffff8101e76a,%rsi
ffffffff8100f88e:	eb 24                	jmp    ffffffff8100f8b4 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x58>
    assert(!this->xcpu_sm);
ffffffff8100f890:	48 83 bd 30 03 00 00 	cmpq   $0x0,0x330(%rbp)
ffffffff8100f897:	00 
ffffffff8100f898:	74 28                	je     ffffffff8100f8c2 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x66>
ffffffff8100f89a:	49 c7 c0 40 ea 01 81 	mov    $0xffffffff8101ea40,%r8
ffffffff8100f8a1:	b9 73 00 00 00       	mov    $0x73,%ecx
ffffffff8100f8a6:	48 c7 c2 53 e6 01 81 	mov    $0xffffffff8101e653,%rdx
ffffffff8100f8ad:	48 c7 c6 7a e7 01 81 	mov    $0xffffffff8101e77a,%rsi
ffffffff8100f8b4:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100f8bb:	31 c0                	xor    %eax,%eax
ffffffff8100f8bd:	e8 8e 26 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

    enum { UNUSED = 0, CNT = 0 };

    this->xcpu_sm = new (Pd::current->quota) Sm (Pd::current, UNUSED, CNT);
ffffffff8100f8c2:	48 8b 05 47 f7 fe 3e 	mov    0x3efef747(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100f8c9:	49 89 f4             	mov    %rsi,%r12

            call_rcu(true);
        }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
ffffffff8100f8cc:	48 c7 c7 80 40 16 81 	mov    $0xffffffff81164080,%rdi
ffffffff8100f8d3:	49 89 d6             	mov    %rdx,%r14
ffffffff8100f8d6:	49 89 cd             	mov    %rcx,%r13
ffffffff8100f8d9:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff8100f8e0:	e8 49 60 00 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff8100f8e5:	48 8b 35 24 f7 fe 3e 	mov    0x3efef724(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100f8ec:	48 89 c3             	mov    %rax,%rbx
ffffffff8100f8ef:	45 31 c9             	xor    %r9d,%r9d
ffffffff8100f8f2:	31 c9                	xor    %ecx,%ecx
ffffffff8100f8f4:	31 d2                	xor    %edx,%edx
ffffffff8100f8f6:	45 31 c0             	xor    %r8d,%r8d
ffffffff8100f8f9:	48 89 c7             	mov    %rax,%rdi
ffffffff8100f8fc:	e8 61 66 00 00       	callq  ffffffff81015f62 <_ZN2SmC1EP2PdmmPS_m>
ffffffff8100f901:	48 89 9d 30 03 00 00 	mov    %rbx,0x330(%rbp)

    Ec *xcpu_ec = new (Pd::current->quota) Ec (Pd::current, Pd::current, sys_xcpu_call_oom<C>, pt->ec->cpu, this);
ffffffff8100f908:	49 8b 84 24 90 00 00 	mov    0x90(%r12),%rax
ffffffff8100f90f:	00 

    static void idl_handler();

    ALWAYS_INLINE
    static inline void *operator new (size_t, Quota &quota) {
        return cache.alloc(quota);
ffffffff8100f910:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff8100f917:	44 0f b7 80 f0 02 00 	movzwl 0x2f0(%rax),%r8d
ffffffff8100f91e:	00 
ffffffff8100f91f:	48 8b 05 ea f6 fe 3e 	mov    0x3efef6ea(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100f926:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff8100f92d:	44 89 44 24 0c       	mov    %r8d,0xc(%rsp)
ffffffff8100f932:	e8 f7 5f 00 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff8100f937:	48 8b 35 d2 f6 fe 3e 	mov    0x3efef6d2(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100f93e:	44 8b 44 24 0c       	mov    0xc(%rsp),%r8d
ffffffff8100f943:	49 89 e9             	mov    %rbp,%r9
ffffffff8100f946:	48 c7 c1 06 d7 00 81 	mov    $0xffffffff8100d706,%rcx
ffffffff8100f94d:	48 89 c7             	mov    %rax,%rdi
ffffffff8100f950:	48 89 c3             	mov    %rax,%rbx
ffffffff8100f953:	48 89 f2             	mov    %rsi,%rdx
ffffffff8100f956:	e8 c3 48 ff ff       	callq  ffffffff8100421e <_ZN2EcC1EP2PdS1_PFvvEjPS_>
    xcpu_ec->regs.set_pt (reinterpret_cast<mword>(pt), src_pd_id, oom_state);

    Sc *xcpu_sc = new (Pd::current->quota) Sc (Pd::current, xcpu_ec, xcpu_ec->cpu, Sc::current);
ffffffff8100f95b:	48 8b 05 ae f6 fe 3e 	mov    0x3efef6ae(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100f962:	4c 89 a3 e8 00 00 00 	mov    %r12,0xe8(%rbx)
ffffffff8100f969:	48 c7 c7 40 40 16 81 	mov    $0xffffffff81164040,%rdi
ffffffff8100f970:	4c 89 b3 f0 00 00 00 	mov    %r14,0xf0(%rbx)
ffffffff8100f977:	4c 89 ab 10 01 00 00 	mov    %r13,0x110(%rbx)
ffffffff8100f97e:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff8100f985:	e8 a4 5f 00 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff8100f98a:	0f b7 8b f0 02 00 00 	movzwl 0x2f0(%rbx),%ecx
ffffffff8100f991:	4c 8b 05 80 f6 fe 3e 	mov    0x3efef680(%rip),%r8        # ffffffffbffff018 <_ZN2Sc7currentE>
ffffffff8100f998:	49 89 c4             	mov    %rax,%r12
ffffffff8100f99b:	48 8b 35 6e f6 fe 3e 	mov    0x3efef66e(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8100f9a2:	48 89 da             	mov    %rbx,%rdx
ffffffff8100f9a5:	48 89 c7             	mov    %rax,%rdi
ffffffff8100f9a8:	e8 25 4d 00 00       	callq  ffffffff810146d2 <_ZN2ScC1EP2PdP2EcjPS_>

    xcpu_sc->remote_enqueue();
ffffffff8100f9ad:	4c 89 e7             	mov    %r12,%rdi
ffffffff8100f9b0:	e8 ab 50 00 00       	callq  ffffffff81014a60 <_ZN2Sc14remote_enqueueEv>
    this->xcpu_sm->dn (false, 0);
ffffffff8100f9b5:	48 8b ad 30 03 00 00 	mov    0x330(%rbp),%rbp
ffffffff8100f9bc:	48 8b 1d 45 f6 fe 3e 	mov    0x3efef645(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>
        }

        ALWAYS_INLINE
        inline void dn (bool zero, uint64 t, Ec *ec = Ec::current, bool block = true)
        {
            {   Lock_guard <Spinlock> guard (lock);
ffffffff8100f9c3:	48 8d bd 8a 00 00 00 	lea    0x8a(%rbp),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff8100f9ca:	9c                   	pushfq 
ffffffff8100f9cb:	41 5c                	pop    %r12
            return flags & 0x200;
ffffffff8100f9cd:	49 c1 ec 09          	shr    $0x9,%r12

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8100f9d1:	41 80 e4 01          	and    $0x1,%r12b
ffffffff8100f9d5:	74 30                	je     ffffffff8100fa07 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x1ab>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff8100f9d7:	80 3d 52 fd fe 3e 00 	cmpb   $0x0,0x3efefd52(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100f9de:	75 1f                	jne    ffffffff8100f9ff <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x1a3>
ffffffff8100f9e0:	49 c7 c0 40 fb 01 81 	mov    $0xffffffff8101fb40,%r8
ffffffff8100f9e7:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff8100f9ec:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100f9f3:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff8100f9fa:	e9 b5 fe ff ff       	jmpq   ffffffff8100f8b4 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x58>

            asm volatile ("cli" : : : "memory");
ffffffff8100f9ff:	fa                   	cli    
            preemption = false;
ffffffff8100fa00:	c6 05 29 fd fe 3e 00 	movb   $0x0,0x3efefd29(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff8100fa07:	e8 82 14 ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>

                if (counter) {
ffffffff8100fa0c:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff8100fa13:	48 85 c0             	test   %rax,%rax
ffffffff8100fa16:	0f 84 aa 00 00 00    	je     ffffffff8100fac6 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x26a>
                    counter = zero ? 0 : counter - 1;
ffffffff8100fa1c:	48 ff c8             	dec    %rax
ffffffff8100fa1f:	48 89 85 c0 00 00 00 	mov    %rax,0xc0(%rbp)
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff8100fa26:	48 8b 85 98 00 00 00 	mov    0x98(%rbp),%rax
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff8100fa2d:	48 85 c0             	test   %rax,%rax
ffffffff8100fa30:	0f 84 24 01 00 00    	je     ffffffff8100fb5a <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x2fe>
ffffffff8100fa36:	48 8b 50 10          	mov    0x10(%rax),%rdx
ffffffff8100fa3a:	48 85 d2             	test   %rdx,%rdx
ffffffff8100fa3d:	0f 84 17 01 00 00    	je     ffffffff8100fb5a <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x2fe>
ffffffff8100fa43:	48 8b 48 08          	mov    0x8(%rax),%rcx
ffffffff8100fa47:	48 85 c9             	test   %rcx,%rcx
ffffffff8100fa4a:	0f 84 0a 01 00 00    	je     ffffffff8100fb5a <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x2fe>
                return false;

            if (t == t->next)
ffffffff8100fa50:	48 39 d0             	cmp    %rdx,%rax
ffffffff8100fa53:	75 0d                	jne    ffffffff8100fa62 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x206>
                headptr = nullptr;
ffffffff8100fa55:	48 c7 85 98 00 00 00 	movq   $0x0,0x98(%rbp)
ffffffff8100fa5c:	00 00 00 00 
ffffffff8100fa60:	eb 24                	jmp    ffffffff8100fa86 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x22a>

            else {
                t->next->prev = t->prev;
ffffffff8100fa62:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
                t->prev->next = t->next;
ffffffff8100fa66:	48 8b 50 08          	mov    0x8(%rax),%rdx
ffffffff8100fa6a:	48 8b 48 10          	mov    0x10(%rax),%rcx
ffffffff8100fa6e:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
                if (t == headptr)
ffffffff8100fa72:	48 3b 85 98 00 00 00 	cmp    0x98(%rbp),%rax
ffffffff8100fa79:	75 0b                	jne    ffffffff8100fa86 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x22a>
                    headptr = t->next;
ffffffff8100fa7b:	48 8b 50 10          	mov    0x10(%rax),%rdx
ffffffff8100fa7f:	48 89 95 98 00 00 00 	mov    %rdx,0x98(%rbp)

    public:

        mword reset(bool l = false) {
            if (l) lock.lock();
            mword c = counter;
ffffffff8100fa86:	48 8b 50 20          	mov    0x20(%rax),%rdx
            }

            t->next = t->prev = nullptr;
ffffffff8100fa8a:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
ffffffff8100fa91:	00 
ffffffff8100fa92:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
ffffffff8100fa99:	00 
            counter = 0;
ffffffff8100fa9a:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
ffffffff8100faa1:	00 
                if (counter) {
                    counter = zero ? 0 : counter - 1;

                    Si * si;
                    if (Queue<Si>::dequeue(si = Queue<Si>::head()))
                        ec->set_si_regs(si->value, static_cast <Sm *>(si)->reset());
ffffffff8100faa2:	48 8b 40 18          	mov    0x18(%rax),%rax
    }

    ALWAYS_INLINE
    inline void set_si_regs(mword sig, mword cnt) {
        regs.ARG_2 = sig;
        regs.ARG_3 = cnt;
ffffffff8100faa6:	48 89 93 10 01 00 00 	mov    %rdx,0x110(%rbx)
            timeout.dequeue();
    }

    ALWAYS_INLINE
    inline void set_si_regs(mword sig, mword cnt) {
        regs.ARG_2 = sig;
ffffffff8100faad:	48 89 83 f0 00 00 00 	mov    %rax,0xf0(%rbx)
ffffffff8100fab4:	e9 a1 00 00 00       	jmpq   ffffffff8100fb5a <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x2fe>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8100fab9:	8d 50 01             	lea    0x1(%rax),%edx
ffffffff8100fabc:	f0 0f b1 93 8c 00 00 	lock cmpxchg %edx,0x8c(%rbx)
ffffffff8100fac3:	00 
ffffffff8100fac4:	74 0a                	je     ffffffff8100fad0 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x274>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8100fac6:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff8100facc:	85 c0                	test   %eax,%eax
ffffffff8100face:	75 e9                	jne    ffffffff8100fab9 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x25d>
        inline T *head() const { return headptr; }

        ALWAYS_INLINE
        inline void enqueue (T *t)
        {
            if (!headptr)
ffffffff8100fad0:	48 8b 85 90 00 00 00 	mov    0x90(%rbp),%rax
ffffffff8100fad7:	48 85 c0             	test   %rax,%rax
ffffffff8100fada:	75 17                	jne    ffffffff8100faf3 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x297>
                headptr = t->prev = t->next = t;
ffffffff8100fadc:	48 89 9b b0 02 00 00 	mov    %rbx,0x2b0(%rbx)
ffffffff8100fae3:	48 89 9b a8 02 00 00 	mov    %rbx,0x2a8(%rbx)
ffffffff8100faea:	48 89 9d 90 00 00 00 	mov    %rbx,0x90(%rbp)
ffffffff8100faf1:	eb 2a                	jmp    ffffffff8100fb1d <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x2c1>
            else {
                t->next = headptr;
ffffffff8100faf3:	48 89 83 b0 02 00 00 	mov    %rax,0x2b0(%rbx)
                t->prev = headptr->prev;
ffffffff8100fafa:	48 8b 95 90 00 00 00 	mov    0x90(%rbp),%rdx
ffffffff8100fb01:	48 8b 92 a8 02 00 00 	mov    0x2a8(%rdx),%rdx
ffffffff8100fb08:	48 89 93 a8 02 00 00 	mov    %rdx,0x2a8(%rbx)
                t->next->prev = t->prev->next = t;
ffffffff8100fb0f:	48 89 9a b0 02 00 00 	mov    %rbx,0x2b0(%rdx)
ffffffff8100fb16:	48 89 98 a8 02 00 00 	mov    %rbx,0x2a8(%rax)
ffffffff8100fb1d:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff8100fb23:	45 84 e4             	test   %r12b,%r12b
ffffffff8100fb26:	74 50                	je     ffffffff8100fb78 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x31c>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100fb28:	80 3d 01 fc fe 3e 00 	cmpb   $0x0,0x3efefc01(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100fb2f:	74 1f                	je     ffffffff8100fb50 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x2f4>
ffffffff8100fb31:	49 c7 c0 10 fb 01 81 	mov    $0xffffffff8101fb10,%r8
ffffffff8100fb38:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff8100fb3d:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100fb44:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff8100fb4b:	e9 64 fd ff ff       	jmpq   ffffffff8100f8b4 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x58>

            preemption = true;
ffffffff8100fb50:	c6 05 d9 fb fe 3e 01 	movb   $0x1,0x3efefbd9(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100fb57:	fb                   	sti    
ffffffff8100fb58:	eb 1e                	jmp    ffffffff8100fb78 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x31c>
ffffffff8100fb5a:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
ffffffff8100fb60:	45 84 e4             	test   %r12b,%r12b
ffffffff8100fb63:	74 1b                	je     ffffffff8100fb80 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x324>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100fb65:	80 3d c4 fb fe 3e 00 	cmpb   $0x0,0x3efefbc4(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100fb6c:	75 c3                	jne    ffffffff8100fb31 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x2d5>

            preemption = true;
ffffffff8100fb6e:	c6 05 bb fb fe 3e 01 	movb   $0x1,0x3efefbbb(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100fb75:	fb                   	sti    
ffffffff8100fb76:	eb 08                	jmp    ffffffff8100fb80 <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm+0x324>
            if (!block)
                Sc::schedule (false);

            ec->set_timeout (t, this);

            ec->block_sc();
ffffffff8100fb78:	48 89 df             	mov    %rbx,%rdi
ffffffff8100fb7b:	e8 ee bb ff ff       	callq  ffffffff8100b76e <_ZN2Ec8block_scEv>

    die ("XCPU OOM error");
ffffffff8100fb80:	48 8b 05 81 f4 fe 3e 	mov    0x3efef481(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100fb87:	48 c7 c7 89 e7 01 81 	mov    $0xffffffff8101e789,%rdi
ffffffff8100fb8e:	48 8d b0 a8 00 00 00 	lea    0xa8(%rax),%rsi
ffffffff8100fb95:	e8 70 50 ff ff       	callq  ffffffff81004c0a <_ZN2Ec3dieEPKcP8Exc_regs>

ffffffff8100fb9a <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_>:
    Pt       *pt = reinterpret_cast<Pt *>(s->ARG_1);
    current->oom_call(pt, s->ARG_2, s->ARG_3, oom_xcpu_return<ret_xcpu_reply_oom<C>>, sys_xcpu_call_oom<C>);
}

void Ec::oom_call_cpu(Pt * pt, mword src, void (*CC)(), void (*HELP)())
{
ffffffff8100fb9a:	50                   	push   %rax
    enum { OOM_SEND = 1, OOM_REPLY = 2, OOM_SELF = 4 };
    mword s = OOM_SEND | (this == pt->ec) ? OOM_SELF : 0;

    if (this->cpu != pt->ec->xcpu) {
ffffffff8100fb9b:	48 8b 86 90 00 00 00 	mov    0x90(%rsi),%rax
ffffffff8100fba2:	44 0f b7 8f f0 02 00 	movzwl 0x2f0(%rdi),%r9d
ffffffff8100fba9:	00 
ffffffff8100fbaa:	44 3b 88 f0 02 00 00 	cmp    0x2f0(%rax),%r9d
ffffffff8100fbb1:	0f 84 c5 00 00 00    	je     ffffffff8100fc7c <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_+0xe2>
        if (CC == sys_call) this->oom_xcpu<sys_call>(pt, src, s); else
ffffffff8100fbb7:	48 81 f9 ae 08 00 81 	cmp    $0xffffffff810008ae,%rcx
ffffffff8100fbbe:	75 0a                	jne    ffffffff8100fbca <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_+0x30>
ffffffff8100fbc0:	b9 04 00 00 00       	mov    $0x4,%ecx
ffffffff8100fbc5:	e8 a2 e2 ff ff       	callq  ffffffff8100de6c <_ZN2Ec8oom_xcpuIXadL_ZNS_8sys_callEvEEEEvP2Ptmm>
        if (CC == sys_lookup) this->oom_xcpu<sys_lookup>(pt, src, s); else
ffffffff8100fbca:	48 81 f9 82 88 01 81 	cmp    $0xffffffff81018882,%rcx
ffffffff8100fbd1:	75 0a                	jne    ffffffff8100fbdd <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_+0x43>
ffffffff8100fbd3:	b9 04 00 00 00       	mov    $0x4,%ecx
ffffffff8100fbd8:	e8 cd e5 ff ff       	callq  ffffffff8100e1aa <_ZN2Ec8oom_xcpuIXadL_ZNS_10sys_lookupEvEEEEvP2Ptmm>
        if (CC == sys_sm_ctrl) this->oom_xcpu<sys_sm_ctrl>(pt, src, s); else
ffffffff8100fbdd:	48 81 f9 16 8b 01 81 	cmp    $0xffffffff81018b16,%rcx
ffffffff8100fbe4:	75 0a                	jne    ffffffff8100fbf0 <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_+0x56>
ffffffff8100fbe6:	b9 04 00 00 00       	mov    $0x4,%ecx
ffffffff8100fbeb:	e8 f8 e8 ff ff       	callq  ffffffff8100e4e8 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sm_ctrlEvEEEEvP2Ptmm>
        if (CC == sys_ec_ctrl) this->oom_xcpu<sys_ec_ctrl>(pt, src, s); else
ffffffff8100fbf0:	48 81 f9 3c 98 01 81 	cmp    $0xffffffff8101983c,%rcx
ffffffff8100fbf7:	75 0a                	jne    ffffffff8100fc03 <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_+0x69>
ffffffff8100fbf9:	b9 04 00 00 00       	mov    $0x4,%ecx
ffffffff8100fbfe:	e8 23 ec ff ff       	callq  ffffffff8100e826 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_ec_ctrlEvEEEEvP2Ptmm>
        if (CC == sys_sc_ctrl) this->oom_xcpu<sys_sc_ctrl>(pt, src, s); else
ffffffff8100fc03:	48 81 f9 62 89 01 81 	cmp    $0xffffffff81018962,%rcx
ffffffff8100fc0a:	75 0a                	jne    ffffffff8100fc16 <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_+0x7c>
ffffffff8100fc0c:	b9 04 00 00 00       	mov    $0x4,%ecx
ffffffff8100fc11:	e8 4e ef ff ff       	callq  ffffffff8100eb64 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_sc_ctrlEvEEEEvP2Ptmm>
        if (CC == sys_pt_ctrl) this->oom_xcpu<sys_pt_ctrl>(pt, src, s); else
ffffffff8100fc16:	48 81 f9 4a 8a 01 81 	cmp    $0xffffffff81018a4a,%rcx
ffffffff8100fc1d:	75 0a                	jne    ffffffff8100fc29 <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_+0x8f>
ffffffff8100fc1f:	b9 04 00 00 00       	mov    $0x4,%ecx
ffffffff8100fc24:	e8 79 f2 ff ff       	callq  ffffffff8100eea2 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pt_ctrlEvEEEEvP2Ptmm>
        if (CC == sys_pd_ctrl) this->oom_xcpu<sys_pd_ctrl>(pt, src, s); else
ffffffff8100fc29:	48 81 f9 aa 93 01 81 	cmp    $0xffffffff810193aa,%rcx
ffffffff8100fc30:	75 0a                	jne    ffffffff8100fc3c <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_+0xa2>
ffffffff8100fc32:	b9 04 00 00 00       	mov    $0x4,%ecx
ffffffff8100fc37:	e8 a4 f5 ff ff       	callq  ffffffff8100f1e0 <_ZN2Ec8oom_xcpuIXadL_ZNS_11sys_pd_ctrlEvEEEEvP2Ptmm>
        if (CC == sys_assign_gsi) this->oom_xcpu<sys_assign_gsi>(pt, src, s); else
ffffffff8100fc3c:	48 81 f9 5c a6 01 81 	cmp    $0xffffffff8101a65c,%rcx
ffffffff8100fc43:	75 0a                	jne    ffffffff8100fc4f <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_+0xb5>
ffffffff8100fc45:	b9 04 00 00 00       	mov    $0x4,%ecx
ffffffff8100fc4a:	e8 cf f8 ff ff       	callq  ffffffff8100f51e <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_gsiEvEEEEvP2Ptmm>
        if (CC == sys_assign_pci) this->oom_xcpu<sys_assign_pci>(pt, src, s); else
ffffffff8100fc4f:	48 81 f9 9a a4 01 81 	cmp    $0xffffffff8101a49a,%rcx
ffffffff8100fc56:	75 0a                	jne    ffffffff8100fc62 <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_+0xc8>
ffffffff8100fc58:	b9 04 00 00 00       	mov    $0x4,%ecx
ffffffff8100fc5d:	e8 fa fb ff ff       	callq  ffffffff8100f85c <_ZN2Ec8oom_xcpuIXadL_ZNS_14sys_assign_pciEvEEEEvP2Ptmm>
        die ("Unknown oom call");
ffffffff8100fc62:	48 8b 05 9f f3 fe 3e 	mov    0x3efef39f(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8100fc69:	48 c7 c7 9e e8 01 81 	mov    $0xffffffff8101e89e,%rdi
ffffffff8100fc70:	48 8d b0 a8 00 00 00 	lea    0xa8(%rax),%rsi
ffffffff8100fc77:	e8 8e 4f ff ff       	callq  ffffffff81004c0a <_ZN2Ec3dieEPKcP8Exc_regs>
    }

    oom_call(pt, src, s, CC, HELP);
ffffffff8100fc7c:	4d 89 c1             	mov    %r8,%r9
ffffffff8100fc7f:	49 89 c8             	mov    %rcx,%r8
ffffffff8100fc82:	b9 04 00 00 00       	mov    $0x4,%ecx
ffffffff8100fc87:	e8 32 d4 ff ff       	callq  ffffffff8100d0be <_ZN2Ec8oom_callEP2PtmmPFvvES3_>

ffffffff8100fc8c <_GLOBAL__sub_I.00102__ZN3Pci5cacheE>:
#include "pci.hpp"
#include "pd.hpp"
#include "stdio.hpp"

INIT_PRIORITY (PRIO_SLAB)
Slab_cache Pci::cache (sizeof (Pci), 8);
ffffffff8100fc8c:	ba 08 00 00 00       	mov    $0x8,%edx
ffffffff8100fc91:	be 20 00 00 00       	mov    $0x20,%esi
ffffffff8100fc96:	48 c7 c7 10 39 16 81 	mov    $0xffffffff81163910,%rdi
ffffffff8100fc9d:	e9 fe 5b 00 00       	jmpq   ffffffff810158a0 <_ZN10Slab_cacheC1Emj>

ffffffff8100fca2 <_ZN3Hpt8dest_hptEmmj>:
    Paddr replace(Quota &quota, mword, mword);

    static void *remap(Quota &quota, Paddr);

    static bool dest_hpt(Paddr p, mword, unsigned) {
        return (p != reinterpret_cast<Paddr> (&FRAME_0) && p != reinterpret_cast<Paddr> (&FRAME_1));
ffffffff8100fca2:	31 c0                	xor    %eax,%eax
ffffffff8100fca4:	48 81 ff 00 50 56 00 	cmp    $0x565000,%rdi
ffffffff8100fcab:	74 0a                	je     ffffffff8100fcb7 <_ZN3Hpt8dest_hptEmmj+0x15>
ffffffff8100fcad:	48 81 ff 00 60 56 00 	cmp    $0x566000,%rdi
ffffffff8100fcb4:	0f 95 c0             	setne  %al
    }
ffffffff8100fcb7:	c3                   	retq   

ffffffff8100fcb8 <_ZN3Hpt12iter_hpt_levEjm>:

    static bool iter_hpt_lev(unsigned l, mword v) {
#ifdef __x86_64__
        if (sizeof (v) > 4 && (v & (1ULL << 47)))
ffffffff8100fcb8:	48 b8 00 00 00 00 00 	movabs $0x800000000000,%rax
ffffffff8100fcbf:	80 00 00 
ffffffff8100fcc2:	48 85 c6             	test   %rax,%rsi
ffffffff8100fcc5:	74 0d                	je     ffffffff8100fcd4 <_ZN3Hpt12iter_hpt_levEjm+0x1c>
            v |= ~((1ULL << 48) - 1);
ffffffff8100fcc7:	48 b8 00 00 00 00 00 	movabs $0xffff000000000000,%rax
ffffffff8100fcce:	00 ff ff 
ffffffff8100fcd1:	48 09 c6             	or     %rax,%rsi
#endif

        return l >= 2 || (l == 1 && v >= SPC_LOCAL_OBJ);
ffffffff8100fcd4:	83 ff 01             	cmp    $0x1,%edi
ffffffff8100fcd7:	b0 01                	mov    $0x1,%al
ffffffff8100fcd9:	77 0c                	ja     ffffffff8100fce7 <_ZN3Hpt12iter_hpt_levEjm+0x2f>
ffffffff8100fcdb:	48 81 fe ff ff ff df 	cmp    $0xffffffffdfffffff,%rsi
ffffffff8100fce2:	0f 97 c0             	seta   %al
ffffffff8100fce5:	21 f8                	and    %edi,%eax
    }
ffffffff8100fce7:	c3                   	retq   

ffffffff8100fce8 <_ZN3Hpt8dest_locEmmj>:

    static bool dest_loc(Paddr, mword v, unsigned l) {
        return v >= USER_ADDR && l >= 3;
ffffffff8100fce8:	48 b8 ff ef ff ff ff 	movabs $0x7fffffffefff,%rax
ffffffff8100fcef:	7f 00 00 
ffffffff8100fcf2:	48 39 c6             	cmp    %rax,%rsi
ffffffff8100fcf5:	0f 97 c1             	seta   %cl
ffffffff8100fcf8:	83 fa 02             	cmp    $0x2,%edx
ffffffff8100fcfb:	0f 97 c0             	seta   %al
ffffffff8100fcfe:	21 c8                	and    %ecx,%eax
    }
ffffffff8100fd00:	c3                   	retq   

ffffffff8100fd01 <_ZN3Hpt12iter_loc_levEjm>:

    static bool iter_loc_lev(unsigned l, mword) {
        return l > 3;
ffffffff8100fd01:	83 ff 03             	cmp    $0x3,%edi
ffffffff8100fd04:	0f 97 c0             	seta   %al
    }
ffffffff8100fd07:	c3                   	retq   

ffffffff8100fd08 <_Z8free_mdbI9Space_memEvP8Rcu_elem>:
}

template <typename S>
static void free_mdb(Rcu_elem * e)
{
    Mdb *mdb = static_cast<Mdb *>(e);
ffffffff8100fd08:	48 85 ff             	test   %rdi,%rdi
ffffffff8100fd0b:	74 3f                	je     ffffffff8100fd4c <_Z8free_mdbI9Space_memEvP8Rcu_elem+0x44>

        bool removed() const { return sta == REMOVED; }
        bool invalid() const { return sta == STALE || sta == KIM; }
ffffffff8100fd0d:	66 8b 47 fa          	mov    -0x6(%rdi),%ax
ffffffff8100fd11:	48 8d 77 e8          	lea    -0x18(%rdi),%rsi
    Pd  *pd  = &Pd::root;
ffffffff8100fd15:	48 c7 c2 60 39 16 81 	mov    $0xffffffff81163960,%rdx
ffffffff8100fd1c:	83 e8 02             	sub    $0x2,%eax

    if (!mdb->invalid()) {
ffffffff8100fd1f:	66 83 f8 01          	cmp    $0x1,%ax
ffffffff8100fd23:	76 14                	jbe    ffffffff8100fd39 <_Z8free_mdbI9Space_memEvP8Rcu_elem+0x31>
        S *space = static_cast<S *>(mdb->space);
ffffffff8100fd25:	48 8b 47 38          	mov    0x38(%rdi),%rax
        pd = static_cast<Pd *>(space);
ffffffff8100fd29:	31 d2                	xor    %edx,%edx
ffffffff8100fd2b:	48 8d 88 70 ff ff ff 	lea    -0x90(%rax),%rcx
ffffffff8100fd32:	48 85 c0             	test   %rax,%rax
ffffffff8100fd35:	48 0f 45 d1          	cmovne %rcx,%rdx
    }

    Mdb::destroy (mdb, pd->quota);
ffffffff8100fd39:	48 81 c2 08 03 00 00 	add    $0x308,%rdx

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void destroy (Mdb *obj, Quota &quota) { obj->~Mdb(); cache.free (obj, quota); }
ffffffff8100fd40:	48 c7 c7 80 38 16 81 	mov    $0xffffffff81163880,%rdi
ffffffff8100fd47:	e9 1e 5d 00 00       	jmpq   ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
ffffffff8100fd4c:	66 8b 04 25 12 00 00 	mov    0x12,%ax
ffffffff8100fd53:	00 
ffffffff8100fd54:	0f 0b                	ud2    

ffffffff8100fd56 <_Z8free_mdbI9Space_pioEvP8Rcu_elem>:
}

template <typename S>
static void free_mdb(Rcu_elem * e)
{
    Mdb *mdb = static_cast<Mdb *>(e);
ffffffff8100fd56:	48 85 ff             	test   %rdi,%rdi
ffffffff8100fd59:	74 3f                	je     ffffffff8100fd9a <_Z8free_mdbI9Space_pioEvP8Rcu_elem+0x44>
ffffffff8100fd5b:	66 8b 47 fa          	mov    -0x6(%rdi),%ax
ffffffff8100fd5f:	48 8d 77 e8          	lea    -0x18(%rdi),%rsi
    Pd  *pd  = &Pd::root;
ffffffff8100fd63:	48 c7 c2 60 39 16 81 	mov    $0xffffffff81163960,%rdx
ffffffff8100fd6a:	83 e8 02             	sub    $0x2,%eax

    if (!mdb->invalid()) {
ffffffff8100fd6d:	66 83 f8 01          	cmp    $0x1,%ax
ffffffff8100fd71:	76 14                	jbe    ffffffff8100fd87 <_Z8free_mdbI9Space_pioEvP8Rcu_elem+0x31>
        S *space = static_cast<S *>(mdb->space);
ffffffff8100fd73:	48 8b 47 38          	mov    0x38(%rdi),%rax
        pd = static_cast<Pd *>(space);
ffffffff8100fd77:	31 d2                	xor    %edx,%edx
ffffffff8100fd79:	48 8d 88 28 fd ff ff 	lea    -0x2d8(%rax),%rcx
ffffffff8100fd80:	48 85 c0             	test   %rax,%rax
ffffffff8100fd83:	48 0f 45 d1          	cmovne %rcx,%rdx
    }

    Mdb::destroy (mdb, pd->quota);
ffffffff8100fd87:	48 81 c2 08 03 00 00 	add    $0x308,%rdx
ffffffff8100fd8e:	48 c7 c7 80 38 16 81 	mov    $0xffffffff81163880,%rdi
ffffffff8100fd95:	e9 d0 5c 00 00       	jmpq   ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
ffffffff8100fd9a:	66 8b 04 25 12 00 00 	mov    0x12,%ax
ffffffff8100fda1:	00 
ffffffff8100fda2:	0f 0b                	ud2    

ffffffff8100fda4 <_Z8free_mdbI9Space_objEvP8Rcu_elem>:
}

template <typename S>
static void free_mdb(Rcu_elem * e)
{
    Mdb *mdb = static_cast<Mdb *>(e);
ffffffff8100fda4:	48 85 ff             	test   %rdi,%rdi
ffffffff8100fda7:	74 3f                	je     ffffffff8100fde8 <_Z8free_mdbI9Space_objEvP8Rcu_elem+0x44>
ffffffff8100fda9:	66 8b 47 fa          	mov    -0x6(%rdi),%ax
ffffffff8100fdad:	48 8d 77 e8          	lea    -0x18(%rdi),%rsi
    Pd  *pd  = &Pd::root;
ffffffff8100fdb1:	48 c7 c2 60 39 16 81 	mov    $0xffffffff81163960,%rdx
ffffffff8100fdb8:	83 e8 02             	sub    $0x2,%eax

    if (!mdb->invalid()) {
ffffffff8100fdbb:	66 83 f8 01          	cmp    $0x1,%ax
ffffffff8100fdbf:	76 14                	jbe    ffffffff8100fdd5 <_Z8free_mdbI9Space_objEvP8Rcu_elem+0x31>
        S *space = static_cast<S *>(mdb->space);
ffffffff8100fdc1:	48 8b 47 38          	mov    0x38(%rdi),%rax
        pd = static_cast<Pd *>(space);
ffffffff8100fdc5:	31 d2                	xor    %edx,%edx
ffffffff8100fdc7:	48 8d 88 08 fd ff ff 	lea    -0x2f8(%rax),%rcx
ffffffff8100fdce:	48 85 c0             	test   %rax,%rax
ffffffff8100fdd1:	48 0f 45 d1          	cmovne %rcx,%rdx
    }

    Mdb::destroy (mdb, pd->quota);
ffffffff8100fdd5:	48 81 c2 08 03 00 00 	add    $0x308,%rdx
ffffffff8100fddc:	48 c7 c7 80 38 16 81 	mov    $0xffffffff81163880,%rdi
ffffffff8100fde3:	e9 82 5c 00 00       	jmpq   ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
ffffffff8100fde8:	66 8b 04 25 12 00 00 	mov    0x12,%ax
ffffffff8100fdef:	00 
ffffffff8100fdf0:	0f 0b                	ud2    

ffffffff8100fdf2 <_ZN5QuotaC1Ev>:
    private:
        uint16 val;

    public:
        ALWAYS_INLINE
        inline Spinlock() : val (0) {}
ffffffff8100fdf2:	66 c7 07 00 00       	movw   $0x0,(%rdi)

    public:

        static Quota init;

        Quota () : used(0), over(0), upli(0), notr(0) { }
ffffffff8100fdf7:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
ffffffff8100fdfe:	00 
ffffffff8100fdff:	48 c7 47 10 00 00 00 	movq   $0x0,0x10(%rdi)
ffffffff8100fe06:	00 
ffffffff8100fe07:	48 c7 47 18 00 00 00 	movq   $0x0,0x18(%rdi)
ffffffff8100fe0e:	00 
ffffffff8100fe0f:	48 c7 47 20 00 00 00 	movq   $0x0,0x20(%rdi)
ffffffff8100fe16:	00 
ffffffff8100fe17:	c3                   	retq   

ffffffff8100fe18 <_ZN11Quota_guard5checkEm>:
            }
        }

        bool hit_limit(mword free_space = 0)
        {
             if (free_space > upli)
ffffffff8100fe18:	48 8b 47 18          	mov    0x18(%rdi),%rax

    public:

        Quota_guard(Quota &ref) : q(), r(ref) { }

        bool check(mword req)
ffffffff8100fe1c:	49 89 f8             	mov    %rdi,%r8
ffffffff8100fe1f:	48 89 f2             	mov    %rsi,%rdx
            }
        }

        bool hit_limit(mword free_space = 0)
        {
             if (free_space > upli)
ffffffff8100fe22:	48 39 c6             	cmp    %rax,%rsi
ffffffff8100fe25:	77 0c                	ja     ffffffff8100fe33 <_ZN11Quota_guard5checkEm+0x1b>
                 return true;

             return usage() > upli - free_space;
ffffffff8100fe27:	48 89 c1             	mov    %rax,%rcx
ffffffff8100fe2a:	48 29 f1             	sub    %rsi,%rcx

        Quota_guard(Quota &ref) : q(), r(ref) { }

        bool check(mword req)
        {
            if (!q.hit_limit(req))
ffffffff8100fe2d:	48 39 4f 08          	cmp    %rcx,0x8(%rdi)
ffffffff8100fe31:	76 25                	jbe    ffffffff8100fe58 <_ZN11Quota_guard5checkEm+0x40>
ffffffff8100fe33:	49 8b 70 08          	mov    0x8(%r8),%rsi
                return true;

            if (q.limit() <= q.usage())
ffffffff8100fe37:	48 39 f0             	cmp    %rsi,%rax
ffffffff8100fe3a:	77 08                	ja     ffffffff8100fe44 <_ZN11Quota_guard5checkEm+0x2c>
ffffffff8100fe3c:	48 29 c2             	sub    %rax,%rdx
                req += q.usage() - q.limit();
ffffffff8100fe3f:	48 01 f2             	add    %rsi,%rdx
ffffffff8100fe42:	eb 06                	jmp    ffffffff8100fe4a <_ZN11Quota_guard5checkEm+0x32>
            else
                req -= q.limit() - q.usage();
ffffffff8100fe44:	48 29 f0             	sub    %rsi,%rax
ffffffff8100fe47:	48 29 c2             	sub    %rax,%rdx

            return r.transfer_to(q, req, false);
ffffffff8100fe4a:	49 8b 78 28          	mov    0x28(%r8),%rdi
ffffffff8100fe4e:	31 c9                	xor    %ecx,%ecx
ffffffff8100fe50:	4c 89 c6             	mov    %r8,%rsi
ffffffff8100fe53:	e9 ca 38 ff ff       	jmpq   ffffffff81003722 <_ZN5Quota11transfer_toERS_mb>
        }
ffffffff8100fe58:	b0 01                	mov    $0x1,%al
ffffffff8100fe5a:	c3                   	retq   
ffffffff8100fe5b:	90                   	nop

ffffffff8100fe5c <_ZN11Quota_guardD1Ev>:

        operator Quota&() { return q; }

        ~Quota_guard() { q.free_up(r); }
ffffffff8100fe5c:	48 8b 77 28          	mov    0x28(%rdi),%rsi
ffffffff8100fe60:	e9 5f 37 ff ff       	jmpq   ffffffff810035c4 <_ZN5Quota7free_upERS_>
ffffffff8100fe65:	90                   	nop

ffffffff8100fe66 <_ZN5Space11tree_lookupEmb>:
        Avl *       tree;

    public:
        Space() : tree (nullptr) {}

        Mdb *tree_lookup (mword idx, bool next = false)
ffffffff8100fe66:	41 55                	push   %r13
ffffffff8100fe68:	41 54                	push   %r12
ffffffff8100fe6a:	49 89 f5             	mov    %rsi,%r13
ffffffff8100fe6d:	55                   	push   %rbp
ffffffff8100fe6e:	49 89 fc             	mov    %rdi,%r12
ffffffff8100fe71:	53                   	push   %rbx
ffffffff8100fe72:	40 88 d5             	mov    %dl,%bpl
ffffffff8100fe75:	51                   	push   %rcx

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff8100fe76:	9c                   	pushfq 
ffffffff8100fe77:	58                   	pop    %rax
            return flags & 0x200;
ffffffff8100fe78:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8100fe7c:	88 c3                	mov    %al,%bl
ffffffff8100fe7e:	80 e3 01             	and    $0x1,%bl
ffffffff8100fe81:	74 2d                	je     ffffffff8100feb0 <_ZN5Space11tree_lookupEmb+0x4a>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff8100fe83:	80 3d a6 f8 fe 3e 00 	cmpb   $0x0,0x3efef8a6(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100fe8a:	75 1c                	jne    ffffffff8100fea8 <_ZN5Space11tree_lookupEmb+0x42>
ffffffff8100fe8c:	49 c7 c0 50 02 02 81 	mov    $0xffffffff81020250,%r8
ffffffff8100fe93:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff8100fe98:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100fe9f:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff8100fea6:	eb 76                	jmp    ffffffff8100ff1e <_ZN5Space11tree_lookupEmb+0xb8>

            asm volatile ("cli" : : : "memory");
ffffffff8100fea8:	fa                   	cli    
            preemption = false;
ffffffff8100fea9:	c6 05 80 f8 fe 3e 00 	movb   $0x0,0x3efef880(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff8100feb0:	4c 89 e7             	mov    %r12,%rdi
ffffffff8100feb3:	e8 d6 0f ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
        {
            Lock_guard <Spinlock> guard (lock);
            return Mdb::lookup (tree, idx, next);
ffffffff8100feb8:	49 8b 44 24 08       	mov    0x8(%r12),%rax
        NOINLINE
        explicit Mdb (Space *s, void (*f)(Rcu_elem *), mword p, mword b, mword o = 0, mword a = 0, mword t = 0, mword sub = 0) : Rcu_elem (f), dpth (0), prev (this), next (this), prnt (nullptr), space (s), node_phys (p), node_base (b), node_order (o), node_attr (a), node_type (t), node_sub (sub) {}

        static Mdb *lookup (Avl *tree, mword base, bool next)
        {
            Mdb *n = nullptr;
ffffffff8100febd:	31 d2                	xor    %edx,%edx
            bool d;

            for (Mdb *m = static_cast<Mdb *>(tree); m; m = static_cast<Mdb *>(m->lnk[d])) {
ffffffff8100febf:	48 85 c0             	test   %rax,%rax
ffffffff8100fec2:	74 2c                	je     ffffffff8100fef0 <_ZN5Space11tree_lookupEmb+0x8a>

                if ((m->node_base ^ base) >> m->node_order == 0)
ffffffff8100fec4:	48 8b 70 60          	mov    0x60(%rax),%rsi
ffffffff8100fec8:	48 8b 48 68          	mov    0x68(%rax),%rcx
ffffffff8100fecc:	4c 89 ef             	mov    %r13,%rdi
ffffffff8100fecf:	48 31 f7             	xor    %rsi,%rdi
ffffffff8100fed2:	48 d3 ef             	shr    %cl,%rdi
ffffffff8100fed5:	48 85 ff             	test   %rdi,%rdi
ffffffff8100fed8:	74 19                	je     ffffffff8100fef3 <_ZN5Space11tree_lookupEmb+0x8d>
                    return m;

                if ((d = base > m->node_base) == 0 && next)
ffffffff8100feda:	49 39 f5             	cmp    %rsi,%r13
ffffffff8100fedd:	0f 97 c1             	seta   %cl
ffffffff8100fee0:	40 38 e9             	cmp    %bpl,%cl
ffffffff8100fee3:	48 0f 42 d0          	cmovb  %rax,%rdx
        static Mdb *lookup (Avl *tree, mword base, bool next)
        {
            Mdb *n = nullptr;
            bool d;

            for (Mdb *m = static_cast<Mdb *>(tree); m; m = static_cast<Mdb *>(m->lnk[d])) {
ffffffff8100fee7:	83 e1 01             	and    $0x1,%ecx
ffffffff8100feea:	48 8b 04 c8          	mov    (%rax,%rcx,8),%rax
ffffffff8100feee:	eb cf                	jmp    ffffffff8100febf <_ZN5Space11tree_lookupEmb+0x59>

                if ((d = base > m->node_base) == 0 && next)
                    n = m;
            }

            return n;
ffffffff8100fef0:	48 89 d0             	mov    %rdx,%rax
        }

        ALWAYS_INLINE
        inline void unlock()
        {
            asm volatile ("incb %0" : "=m" (val) : : "memory");
ffffffff8100fef3:	41 fe 04 24          	incb   (%r12)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff8100fef7:	84 db                	test   %bl,%bl
ffffffff8100fef9:	74 39                	je     ffffffff8100ff34 <_ZN5Space11tree_lookupEmb+0xce>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100fefb:	80 3d 2e f8 fe 3e 00 	cmpb   $0x0,0x3efef82e(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100ff02:	74 28                	je     ffffffff8100ff2c <_ZN5Space11tree_lookupEmb+0xc6>
ffffffff8100ff04:	49 c7 c0 20 02 02 81 	mov    $0xffffffff81020220,%r8
ffffffff8100ff0b:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff8100ff10:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100ff17:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff8100ff1e:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100ff25:	31 c0                	xor    %eax,%eax
ffffffff8100ff27:	e8 24 20 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            preemption = true;
ffffffff8100ff2c:	c6 05 fd f7 fe 3e 01 	movb   $0x1,0x3efef7fd(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100ff33:	fb                   	sti    
        }
ffffffff8100ff34:	5a                   	pop    %rdx
ffffffff8100ff35:	5b                   	pop    %rbx
ffffffff8100ff36:	5d                   	pop    %rbp
ffffffff8100ff37:	41 5c                	pop    %r12
ffffffff8100ff39:	41 5d                	pop    %r13
ffffffff8100ff3b:	c3                   	retq   

ffffffff8100ff3c <_ZN5Space11tree_insertEP3Mdb>:

        static bool tree_insert (Mdb *node)
ffffffff8100ff3c:	41 54                	push   %r12
ffffffff8100ff3e:	55                   	push   %rbp
ffffffff8100ff3f:	48 89 fd             	mov    %rdi,%rbp
ffffffff8100ff42:	53                   	push   %rbx
        {
            Lock_guard <Spinlock> guard (node->space->lock);
ffffffff8100ff43:	4c 8b 67 50          	mov    0x50(%rdi),%r12

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff8100ff47:	9c                   	pushfq 
ffffffff8100ff48:	58                   	pop    %rax
            return flags & 0x200;
ffffffff8100ff49:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8100ff4d:	88 c3                	mov    %al,%bl
ffffffff8100ff4f:	80 e3 01             	and    $0x1,%bl
ffffffff8100ff52:	74 2d                	je     ffffffff8100ff81 <_ZN5Space11tree_insertEP3Mdb+0x45>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff8100ff54:	80 3d d5 f7 fe 3e 00 	cmpb   $0x0,0x3efef7d5(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100ff5b:	75 1c                	jne    ffffffff8100ff79 <_ZN5Space11tree_insertEP3Mdb+0x3d>
ffffffff8100ff5d:	49 c7 c0 50 02 02 81 	mov    $0xffffffff81020250,%r8
ffffffff8100ff64:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff8100ff69:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100ff70:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff8100ff77:	eb 4b                	jmp    ffffffff8100ffc4 <_ZN5Space11tree_insertEP3Mdb+0x88>

            asm volatile ("cli" : : : "memory");
ffffffff8100ff79:	fa                   	cli    
            preemption = false;
ffffffff8100ff7a:	c6 05 af f7 fe 3e 00 	movb   $0x0,0x3efef7af(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff8100ff81:	4c 89 e7             	mov    %r12,%rdi
ffffffff8100ff84:	e8 05 0f ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
            return Mdb::insert<Mdb> (&node->space->tree, node);
ffffffff8100ff89:	48 8b 45 50          	mov    0x50(%rbp),%rax
ffffffff8100ff8d:	48 89 ee             	mov    %rbp,%rsi
ffffffff8100ff90:	48 8d 78 08          	lea    0x8(%rax),%rdi
ffffffff8100ff94:	e8 ef 0f ff ff       	callq  ffffffff81000f88 <_ZN3Avl6insertI3MdbEEbPPS_S2_>
ffffffff8100ff99:	41 fe 04 24          	incb   (%r12)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff8100ff9d:	84 db                	test   %bl,%bl
ffffffff8100ff9f:	74 39                	je     ffffffff8100ffda <_ZN5Space11tree_insertEP3Mdb+0x9e>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8100ffa1:	80 3d 88 f7 fe 3e 00 	cmpb   $0x0,0x3efef788(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8100ffa8:	74 28                	je     ffffffff8100ffd2 <_ZN5Space11tree_insertEP3Mdb+0x96>
ffffffff8100ffaa:	49 c7 c0 20 02 02 81 	mov    $0xffffffff81020220,%r8
ffffffff8100ffb1:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff8100ffb6:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8100ffbd:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff8100ffc4:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8100ffcb:	31 c0                	xor    %eax,%eax
ffffffff8100ffcd:	e8 7e 1f ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            preemption = true;
ffffffff8100ffd2:	c6 05 57 f7 fe 3e 01 	movb   $0x1,0x3efef757(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8100ffd9:	fb                   	sti    
        }
ffffffff8100ffda:	5b                   	pop    %rbx
ffffffff8100ffdb:	5d                   	pop    %rbp
ffffffff8100ffdc:	41 5c                	pop    %r12
ffffffff8100ffde:	c3                   	retq   

ffffffff8100ffdf <_ZN5Space11tree_removeEP3MdbN3Avl5StateE>:

        static bool tree_remove (Mdb *node, Avl::State state = Avl::State::REMOVED)
ffffffff8100ffdf:	41 55                	push   %r13
ffffffff8100ffe1:	41 54                	push   %r12
ffffffff8100ffe3:	41 89 f5             	mov    %esi,%r13d
ffffffff8100ffe6:	55                   	push   %rbp
ffffffff8100ffe7:	48 89 fd             	mov    %rdi,%rbp
ffffffff8100ffea:	53                   	push   %rbx
ffffffff8100ffeb:	51                   	push   %rcx
        {
            Lock_guard <Spinlock> guard (node->space->lock);
ffffffff8100ffec:	4c 8b 67 50          	mov    0x50(%rdi),%r12

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff8100fff0:	9c                   	pushfq 
ffffffff8100fff1:	58                   	pop    %rax
            return flags & 0x200;
ffffffff8100fff2:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8100fff6:	88 c3                	mov    %al,%bl
ffffffff8100fff8:	80 e3 01             	and    $0x1,%bl
ffffffff8100fffb:	74 2d                	je     ffffffff8101002a <_ZN5Space11tree_removeEP3MdbN3Avl5StateE+0x4b>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff8100fffd:	80 3d 2c f7 fe 3e 00 	cmpb   $0x0,0x3efef72c(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81010004:	75 1c                	jne    ffffffff81010022 <_ZN5Space11tree_removeEP3MdbN3Avl5StateE+0x43>
ffffffff81010006:	49 c7 c0 50 02 02 81 	mov    $0xffffffff81020250,%r8
ffffffff8101000d:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff81010012:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81010019:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff81010020:	eb 4e                	jmp    ffffffff81010070 <_ZN5Space11tree_removeEP3MdbN3Avl5StateE+0x91>

            asm volatile ("cli" : : : "memory");
ffffffff81010022:	fa                   	cli    
            preemption = false;
ffffffff81010023:	c6 05 06 f7 fe 3e 00 	movb   $0x0,0x3efef706(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff8101002a:	4c 89 e7             	mov    %r12,%rdi
ffffffff8101002d:	e8 5c 0e ff ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
            return Mdb::remove<Mdb> (&node->space->tree, node, state);
ffffffff81010032:	48 8b 45 50          	mov    0x50(%rbp),%rax
ffffffff81010036:	44 89 ea             	mov    %r13d,%edx
ffffffff81010039:	48 89 ee             	mov    %rbp,%rsi
ffffffff8101003c:	48 8d 78 08          	lea    0x8(%rax),%rdi
ffffffff81010040:	e8 5d 10 ff ff       	callq  ffffffff810010a2 <_ZN3Avl6removeI3MdbEEbPPS_S2_NS_5StateE>
ffffffff81010045:	41 fe 04 24          	incb   (%r12)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81010049:	84 db                	test   %bl,%bl
ffffffff8101004b:	74 39                	je     ffffffff81010086 <_ZN5Space11tree_removeEP3MdbN3Avl5StateE+0xa7>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8101004d:	80 3d dc f6 fe 3e 00 	cmpb   $0x0,0x3efef6dc(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81010054:	74 28                	je     ffffffff8101007e <_ZN5Space11tree_removeEP3MdbN3Avl5StateE+0x9f>
ffffffff81010056:	49 c7 c0 20 02 02 81 	mov    $0xffffffff81020220,%r8
ffffffff8101005d:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff81010062:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81010069:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff81010070:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81010077:	31 c0                	xor    %eax,%eax
ffffffff81010079:	e8 d2 1e ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            preemption = true;
ffffffff8101007e:	c6 05 ab f6 fe 3e 01 	movb   $0x1,0x3efef6ab(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81010085:	fb                   	sti    
        }
ffffffff81010086:	5a                   	pop    %rdx
ffffffff81010087:	5b                   	pop    %rbx
ffffffff81010088:	5d                   	pop    %rbp
ffffffff81010089:	41 5c                	pop    %r12
ffffffff8101008b:	41 5d                	pop    %r13
ffffffff8101008d:	c3                   	retq   

ffffffff8101008e <_ZN2PdC1EPS_mm>:

    // I/O Ports
    Space_pio::addreg (own->quota, 0, 1UL << 16, 7);
}

Pd::Pd (Pd *own, mword sel, mword a) : Kobject (PD, static_cast<Space_obj *>(own), sel, a, free, pre_free)
ffffffff8101008e:	55                   	push   %rbp
ffffffff8101008f:	53                   	push   %rbx
ffffffff81010090:	48 8d 86 f8 02 00 00 	lea    0x2f8(%rsi),%rax
ffffffff81010097:	49 89 c8             	mov    %rcx,%r8
ffffffff8101009a:	49 c7 c1 6d 11 01 81 	mov    $0xffffffff8101116d,%r9
ffffffff810100a1:	48 89 d1             	mov    %rdx,%rcx
ffffffff810100a4:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff810100a8:	48 85 f6             	test   %rsi,%rsi
ffffffff810100ab:	be 00 00 00 00       	mov    $0x0,%esi
ffffffff810100b0:	68 c2 0f 01 81       	pushq  $0xffffffff81010fc2
ffffffff810100b5:	48 0f 45 f0          	cmovne %rax,%rsi
ffffffff810100b9:	48 89 fa             	mov    %rdi,%rdx
ffffffff810100bc:	48 89 fb             	mov    %rdi,%rbx
ffffffff810100bf:	e8 e8 37 ff ff       	callq  ffffffff810038ac <_ZN3MdbC1EP5SpacemmmPFvP8Rcu_elemES5_>
        }

        ALWAYS_INLINE
        inline Space_mem() : cpus(0), htlb(~0UL), gtlb(~0UL)
ffffffff810100c4:	41 59                	pop    %r9
ffffffff810100c6:	41 5a                	pop    %r10
ffffffff810100c8:	48 8d 93 a0 00 00 00 	lea    0xa0(%rbx),%rdx
ffffffff810100cf:	c6 83 88 00 00 00 00 	movb   $0x0,0x88(%rbx)
    private:
        uint16 val;

    public:
        ALWAYS_INLINE
        inline Spinlock() : val (0) {}
ffffffff810100d6:	66 c7 83 8a 00 00 00 	movw   $0x0,0x8a(%rbx)
ffffffff810100dd:	00 00 
    private:
        uint32 ref;

    public:
        ALWAYS_INLINE
        inline Refex() : ref (1) {}
ffffffff810100df:	c7 83 8c 00 00 00 01 	movl   $0x1,0x8c(%rbx)
ffffffff810100e6:	00 00 00 
ffffffff810100e9:	66 c7 83 90 00 00 00 	movw   $0x0,0x90(%rbx)
ffffffff810100f0:	00 00 
ffffffff810100f2:	31 c0                	xor    %eax,%eax
    private:
        Spinlock    lock;
        Avl *       tree;

    public:
        Space() : tree (nullptr) {}
ffffffff810100f4:	48 c7 83 98 00 00 00 	movq   $0x0,0x98(%rbx)
ffffffff810100fb:	00 00 00 00 

    void free_up(Quota &quota, unsigned l, P *, mword, bool (*) (Paddr, mword, unsigned), bool (*) (unsigned, mword));

public:

    Pte() : val(0) {
ffffffff810100ff:	48 c7 04 02 00 00 00 	movq   $0x0,(%rdx,%rax,1)
ffffffff81010106:	00 
ffffffff81010107:	48 83 c0 08          	add    $0x8,%rax
ffffffff8101010b:	48 3d 00 02 00 00    	cmp    $0x200,%rax
ffffffff81010111:	75 ec                	jne    ffffffff810100ff <_ZN2PdC1EPS_mm+0x71>
        {
            for (mword i = ACCESS_ONCE(did_f), j = 0; j <= LAST_PCID; i++, j++)
ffffffff81010113:	48 8b 05 96 3f 15 00 	mov    0x153f96(%rip),%rax        # ffffffff811640b0 <_ZN9Space_mem5did_fE>
ffffffff8101011a:	48 c7 83 a0 02 00 00 	movq   $0x0,0x2a0(%rbx)
ffffffff81010121:	00 00 00 00 
ffffffff81010125:	31 f6                	xor    %esi,%esi
ffffffff81010127:	48 c7 83 a8 02 00 00 	movq   $0x0,0x2a8(%rbx)
ffffffff8101012e:	00 00 00 00 
    private:
        mword val;

    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}
ffffffff81010132:	48 c7 83 c0 02 00 00 	movq   $0x0,0x2c0(%rbx)
ffffffff81010139:	00 00 00 00 
ffffffff8101013d:	48 c7 83 c8 02 00 00 	movq   $0xffffffffffffffff,0x2c8(%rbx)
ffffffff81010144:	ff ff ff ff 
ffffffff81010148:	48 c7 83 d0 02 00 00 	movq   $0xffffffffffffffff,0x2d0(%rbx)
ffffffff8101014f:	ff ff ff ff 
            {
                i %= (LAST_PCID + 1);
ffffffff81010153:	83 e0 3f             	and    $0x3f,%eax

                if (ACCESS_ONCE(did_c[i]) == ~0UL)
ffffffff81010156:	48 8b 14 c5 c0 40 16 	mov    -0x7ee9bf40(,%rax,8),%rdx
ffffffff8101015d:	81 
ffffffff8101015e:	48 ff c2             	inc    %rdx
ffffffff81010161:	74 63                	je     ffffffff810101c6 <_ZN2PdC1EPS_mm+0x138>
}

ALWAYS_INLINE
inline long int bit_scan_forward (mword val)
{
    if (EXPECT_FALSE (!val))
ffffffff81010163:	48 8b 0c c5 c0 40 16 	mov    -0x7ee9bf40(,%rax,8),%rcx
ffffffff8101016a:	81 
                    continue;

                long b = bit_scan_forward (~did_c[i]);
                if (b == -1) b = 0;
ffffffff8101016b:	31 d2                	xor    %edx,%edx
ffffffff8101016d:	48 83 f1 ff          	xor    $0xffffffffffffffff,%rcx
ffffffff81010171:	74 0c                	je     ffffffff8101017f <_ZN2PdC1EPS_mm+0xf1>
        return -1;

    asm volatile ("bsf %1, %0" : "=r" (val) : "rm" (val));
ffffffff81010173:	48 0f bc c9          	bsf    %rcx,%rcx
ffffffff81010177:	48 83 f9 ff          	cmp    $0xffffffffffffffff,%rcx
ffffffff8101017b:	48 0f 45 d1          	cmovne %rcx,%rdx
        template <typename T>
        ALWAYS_INLINE
        static inline bool test_set_bit (T &val, unsigned long bit)
        {
            bool ret;
            asm volatile ("lock; bts%z1 %2, %1; setc %0" : "=q" (ret), "+m" (val) : "ir" (bit) : "cc");
ffffffff8101017f:	f0 48 0f ab 14 c5 c0 	lock bts %rdx,-0x7ee9bf40(,%rax,8)
ffffffff81010186:	40 16 81 
ffffffff81010189:	0f 92 c1             	setb   %cl

                if (Atomic::test_set_bit (did_c[i], b)) {
ffffffff8101018c:	84 c9                	test   %cl,%cl
ffffffff8101018e:	74 08                	je     ffffffff81010198 <_ZN2PdC1EPS_mm+0x10a>
                    j--;
ffffffff81010190:	48 ff ce             	dec    %rsi
                    i--;
ffffffff81010193:	48 ff c8             	dec    %rax
ffffffff81010196:	eb 2e                	jmp    ffffffff810101c6 <_ZN2PdC1EPS_mm+0x138>
                    continue;
                }

                did = i * sizeof(did_c[0]) * 8 + b;
ffffffff81010198:	48 89 c1             	mov    %rax,%rcx
ffffffff8101019b:	48 c1 e1 06          	shl    $0x6,%rcx
ffffffff8101019f:	48 01 ca             	add    %rcx,%rdx

                if (did_c[i] != ~0UL && did_f != i)
ffffffff810101a2:	48 83 3c c5 c0 40 16 	cmpq   $0xffffffffffffffff,-0x7ee9bf40(,%rax,8)
ffffffff810101a9:	81 ff 
                    j--;
                    i--;
                    continue;
                }

                did = i * sizeof(did_c[0]) * 8 + b;
ffffffff810101ab:	48 89 93 b8 02 00 00 	mov    %rdx,0x2b8(%rbx)

                if (did_c[i] != ~0UL && did_f != i)
ffffffff810101b2:	74 29                	je     ffffffff810101dd <_ZN2PdC1EPS_mm+0x14f>
ffffffff810101b4:	48 39 05 f5 3e 15 00 	cmp    %rax,0x153ef5(%rip)        # ffffffff811640b0 <_ZN9Space_mem5did_fE>
ffffffff810101bb:	74 20                	je     ffffffff810101dd <_ZN2PdC1EPS_mm+0x14f>
                    did_f = i;
ffffffff810101bd:	48 89 05 ec 3e 15 00 	mov    %rax,0x153eec(%rip)        # ffffffff811640b0 <_ZN9Space_mem5did_fE>
ffffffff810101c4:	eb 17                	jmp    ffffffff810101dd <_ZN2PdC1EPS_mm+0x14f>
        }

        ALWAYS_INLINE
        inline Space_mem() : cpus(0), htlb(~0UL), gtlb(~0UL)
        {
            for (mword i = ACCESS_ONCE(did_f), j = 0; j <= LAST_PCID; i++, j++)
ffffffff810101c6:	48 ff c6             	inc    %rsi
ffffffff810101c9:	48 ff c0             	inc    %rax
ffffffff810101cc:	48 83 fe 3f          	cmp    $0x3f,%rsi
ffffffff810101d0:	76 81                	jbe    ffffffff81010153 <_ZN2PdC1EPS_mm+0xc5>
                    did_f = i;

                return;
            }

            did = NO_PCID;
ffffffff810101d2:	48 c7 83 b8 02 00 00 	movq   $0x2,0x2b8(%rbx)
ffffffff810101d9:	02 00 00 00 
ffffffff810101dd:	48 8d ab 08 03 00 00 	lea    0x308(%rbx),%rbp
ffffffff810101e4:	66 c7 83 d8 02 00 00 	movw   $0x0,0x2d8(%rbx)
ffffffff810101eb:	00 00 
ffffffff810101ed:	48 c7 83 e0 02 00 00 	movq   $0x0,0x2e0(%rbx)
ffffffff810101f4:	00 00 00 00 
ffffffff810101f8:	48 c7 83 e8 02 00 00 	movq   $0x0,0x2e8(%rbx)
ffffffff810101ff:	00 00 00 00 
ffffffff81010203:	48 c7 83 f0 02 00 00 	movq   $0x0,0x2f0(%rbx)
ffffffff8101020a:	00 00 00 00 
ffffffff8101020e:	66 c7 83 f8 02 00 00 	movw   $0x0,0x2f8(%rbx)
ffffffff81010215:	00 00 
ffffffff81010217:	48 c7 83 00 03 00 00 	movq   $0x0,0x300(%rbx)
ffffffff8101021e:	00 00 00 00 
ffffffff81010222:	48 89 ef             	mov    %rbp,%rdi
ffffffff81010225:	e8 c8 fb ff ff       	callq  ffffffff8100fdf2 <_ZN5QuotaC1Ev>
{
    if (this == &Pd::root) {
ffffffff8101022a:	48 81 fb 60 39 16 81 	cmp    $0xffffffff81163960,%rbx
ffffffff81010231:	75 45                	jne    ffffffff81010278 <_ZN2PdC1EPS_mm+0x1ea>
        bool res = Quota::init.transfer_to(quota, Quota::init.limit());
ffffffff81010233:	48 8b 15 4e 1b 01 00 	mov    0x11b4e(%rip),%rdx        # ffffffff81021d88 <_ZN5Quota4initE+0x18>
ffffffff8101023a:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff8101023f:	48 89 ee             	mov    %rbp,%rsi
ffffffff81010242:	48 c7 c7 70 1d 02 81 	mov    $0xffffffff81021d70,%rdi
ffffffff81010249:	e8 d4 34 ff ff       	callq  ffffffff81003722 <_ZN5Quota11transfer_toERS_mb>
        assert(res);
ffffffff8101024e:	84 c0                	test   %al,%al
ffffffff81010250:	75 26                	jne    ffffffff81010278 <_ZN2PdC1EPS_mm+0x1ea>
ffffffff81010252:	49 c7 c0 00 02 02 81 	mov    $0xffffffff81020200,%r8
ffffffff81010259:	b9 39 00 00 00       	mov    $0x39,%ecx
ffffffff8101025e:	48 c7 c2 e1 fd 01 81 	mov    $0xffffffff8101fde1,%rdx
ffffffff81010265:	48 c7 c6 d6 dd 01 81 	mov    $0xffffffff8101ddd6,%rsi
ffffffff8101026c:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81010273:	e8 d8 1c ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
    }
}
ffffffff81010278:	58                   	pop    %rax
ffffffff81010279:	5b                   	pop    %rbx
ffffffff8101027a:	5d                   	pop    %rbp
ffffffff8101027b:	c3                   	retq   

ffffffff8101027c <_ZN2Pd5clampEmRmmm>:
    }
}

mword Pd::clamp (mword snd_base, mword &rcv_base, mword snd_ord, mword rcv_ord)
{
    if ((snd_base ^ rcv_base) >> max (snd_ord, rcv_ord))
ffffffff8101027c:	4c 8b 0a             	mov    (%rdx),%r9
        assert (node == mdb);
    }
}

mword Pd::clamp (mword snd_base, mword &rcv_base, mword snd_ord, mword rcv_ord)
{
ffffffff8101027f:	48 89 cf             	mov    %rcx,%rdi
    if ((snd_base ^ rcv_base) >> max (snd_ord, rcv_ord))
ffffffff81010282:	4c 89 c8             	mov    %r9,%rax
ffffffff81010285:	48 31 f0             	xor    %rsi,%rax
ffffffff81010288:	4c 39 c1             	cmp    %r8,%rcx
ffffffff8101028b:	4c 89 c1             	mov    %r8,%rcx
ffffffff8101028e:	48 0f 43 cf          	cmovae %rdi,%rcx
ffffffff81010292:	48 d3 e8             	shr    %cl,%rax
ffffffff81010295:	48 89 c1             	mov    %rax,%rcx
        return ~0UL;
ffffffff81010298:	48 83 c8 ff          	or     $0xffffffffffffffff,%rax
    }
}

mword Pd::clamp (mword snd_base, mword &rcv_base, mword snd_ord, mword rcv_ord)
{
    if ((snd_base ^ rcv_base) >> max (snd_ord, rcv_ord))
ffffffff8101029c:	48 85 c9             	test   %rcx,%rcx
ffffffff8101029f:	75 10                	jne    ffffffff810102b1 <_ZN2Pd5clampEmRmmm+0x35>
        return ~0UL;

    rcv_base |= snd_base;
ffffffff810102a1:	4c 09 ce             	or     %r9,%rsi
ffffffff810102a4:	4c 89 c0             	mov    %r8,%rax
ffffffff810102a7:	4c 39 c7             	cmp    %r8,%rdi
ffffffff810102aa:	48 89 32             	mov    %rsi,(%rdx)
ffffffff810102ad:	48 0f 46 c7          	cmovbe %rdi,%rax

    return min (snd_ord, rcv_ord);
}
ffffffff810102b1:	c3                   	retq   

ffffffff810102b2 <_ZN2Pd5clampERmS0_mmm>:

mword Pd::clamp (mword &snd_base, mword &rcv_base, mword snd_ord, mword rcv_ord, mword h)
{
    assert (snd_ord < sizeof (mword) * 8);
ffffffff810102b2:	48 83 f9 3f          	cmp    $0x3f,%rcx

    return min (snd_ord, rcv_ord);
}

mword Pd::clamp (mword &snd_base, mword &rcv_base, mword snd_ord, mword rcv_ord, mword h)
{
ffffffff810102b6:	53                   	push   %rbx
ffffffff810102b7:	48 89 c8             	mov    %rcx,%rax
    assert (snd_ord < sizeof (mword) * 8);
ffffffff810102ba:	76 1c                	jbe    ffffffff810102d8 <_ZN2Pd5clampERmS0_mmm+0x26>
ffffffff810102bc:	49 c7 c0 10 00 02 81 	mov    $0xffffffff81020010,%r8
ffffffff810102c3:	b9 d2 00 00 00       	mov    $0xd2,%ecx
ffffffff810102c8:	48 c7 c2 e1 fd 01 81 	mov    $0xffffffff8101fde1,%rdx
ffffffff810102cf:	48 c7 c6 4b fe 01 81 	mov    $0xffffffff8101fe4b,%rsi
ffffffff810102d6:	eb 20                	jmp    ffffffff810102f8 <_ZN2Pd5clampERmS0_mmm+0x46>
    assert (rcv_ord < sizeof (mword) * 8);
ffffffff810102d8:	49 83 f8 3f          	cmp    $0x3f,%r8
ffffffff810102dc:	76 28                	jbe    ffffffff81010306 <_ZN2Pd5clampERmS0_mmm+0x54>
ffffffff810102de:	49 c7 c0 10 00 02 81 	mov    $0xffffffff81020010,%r8
ffffffff810102e5:	b9 d3 00 00 00       	mov    $0xd3,%ecx
ffffffff810102ea:	48 c7 c2 e1 fd 01 81 	mov    $0xffffffff8101fde1,%rdx
ffffffff810102f1:	48 c7 c6 68 fe 01 81 	mov    $0xffffffff8101fe68,%rsi
ffffffff810102f8:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff810102ff:	31 c0                	xor    %eax,%eax
ffffffff81010301:	e8 4a 1c ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

    mword s = (1ul << snd_ord) - 1;
ffffffff81010306:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff8101030b:	49 89 fa             	mov    %rdi,%r10
ffffffff8101030e:	49 d3 e2             	shl    %cl,%r10
    mword r = (1ul << rcv_ord) - 1;
ffffffff81010311:	44 88 c1             	mov    %r8b,%cl
ffffffff81010314:	48 d3 e7             	shl    %cl,%rdi
mword Pd::clamp (mword &snd_base, mword &rcv_base, mword snd_ord, mword rcv_ord, mword h)
{
    assert (snd_ord < sizeof (mword) * 8);
    assert (rcv_ord < sizeof (mword) * 8);

    mword s = (1ul << snd_ord) - 1;
ffffffff81010317:	49 ff ca             	dec    %r10
    mword r = (1ul << rcv_ord) - 1;
ffffffff8101031a:	48 ff cf             	dec    %rdi

    snd_base &= ~s;
ffffffff8101031d:	4c 89 d3             	mov    %r10,%rbx
    rcv_base &= ~r;
ffffffff81010320:	49 89 fb             	mov    %rdi,%r11
    assert (rcv_ord < sizeof (mword) * 8);

    mword s = (1ul << snd_ord) - 1;
    mword r = (1ul << rcv_ord) - 1;

    snd_base &= ~s;
ffffffff81010323:	48 f7 d3             	not    %rbx
ffffffff81010326:	48 21 1e             	and    %rbx,(%rsi)
    rcv_base &= ~r;
ffffffff81010329:	49 f7 d3             	not    %r11
ffffffff8101032c:	4c 89 d9             	mov    %r11,%rcx
ffffffff8101032f:	48 23 0a             	and    (%rdx),%rcx

    if (EXPECT_TRUE (s < r)) {
ffffffff81010332:	49 39 fa             	cmp    %rdi,%r10

    mword s = (1ul << snd_ord) - 1;
    mword r = (1ul << rcv_ord) - 1;

    snd_base &= ~s;
    rcv_base &= ~r;
ffffffff81010335:	48 89 0a             	mov    %rcx,(%rdx)

    if (EXPECT_TRUE (s < r)) {
ffffffff81010338:	73 0e                	jae    ffffffff81010348 <_ZN2Pd5clampERmS0_mmm+0x96>
        rcv_base |= h & r & ~s;
ffffffff8101033a:	49 21 f9             	and    %rdi,%r9
ffffffff8101033d:	49 21 d9             	and    %rbx,%r9
ffffffff81010340:	4c 09 c9             	or     %r9,%rcx
ffffffff81010343:	48 89 0a             	mov    %rcx,(%rdx)
        return snd_ord;
ffffffff81010346:	eb 0c                	jmp    ffffffff81010354 <_ZN2Pd5clampERmS0_mmm+0xa2>
ffffffff81010348:	4d 21 da             	and    %r11,%r10
    } else {
        snd_base |= h & s & ~r;
        return rcv_ord;
ffffffff8101034b:	4c 89 c0             	mov    %r8,%rax

    if (EXPECT_TRUE (s < r)) {
        rcv_base |= h & r & ~s;
        return snd_ord;
    } else {
        snd_base |= h & s & ~r;
ffffffff8101034e:	4d 21 d1             	and    %r10,%r9
ffffffff81010351:	4c 09 0e             	or     %r9,(%rsi)
        return rcv_ord;
    }
}
ffffffff81010354:	5b                   	pop    %rbx
ffffffff81010355:	c3                   	retq   

ffffffff81010356 <_ZN2Pd7xlt_crdEPS_3CrdRS1_>:

void Pd::xlt_crd (Pd *pd, Crd xlt, Crd &crd)
{
ffffffff81010356:	41 57                	push   %r15
ffffffff81010358:	41 56                	push   %r14
    Crd::Type t = xlt.type();

    if (t && t == crd.type()) {
ffffffff8101035a:	89 d0                	mov    %edx,%eax
        return rcv_ord;
    }
}

void Pd::xlt_crd (Pd *pd, Crd xlt, Crd &crd)
{
ffffffff8101035c:	41 55                	push   %r13
ffffffff8101035e:	41 54                	push   %r12
ffffffff81010360:	49 89 ce             	mov    %rcx,%r14
ffffffff81010363:	55                   	push   %rbp
ffffffff81010364:	53                   	push   %rbx
ffffffff81010365:	48 83 ec 38          	sub    $0x38,%rsp
    Crd::Type t = xlt.type();

    if (t && t == crd.type()) {
ffffffff81010369:	83 e0 03             	and    $0x3,%eax
ffffffff8101036c:	0f 84 a1 00 00 00    	je     ffffffff81010413 <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0xbd>

        ALWAYS_INLINE
        inline explicit Crd (Type t, mword b = 0, mword o = 0x1f, mword a = 0x1f) : val (b << 12 | o << 7 | a << 2 | t) {}

        ALWAYS_INLINE
        inline Type type() const { return static_cast<Type>(val & 0x3); }
ffffffff81010372:	4c 8b 21             	mov    (%rcx),%r12
ffffffff81010375:	44 89 e1             	mov    %r12d,%ecx
ffffffff81010378:	83 e1 03             	and    $0x3,%ecx
ffffffff8101037b:	39 c8                	cmp    %ecx,%eax
ffffffff8101037d:	0f 85 90 00 00 00    	jne    ffffffff81010413 <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0xbd>
ffffffff81010383:	e9 97 00 00 00       	jmpq   ffffffff8101041f <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0xc9>
        }

        ALWAYS_INLINE
        inline Space *subspace (Crd::Type t)
        {
            switch (t) {
ffffffff81010388:	83 f8 03             	cmp    $0x3,%eax
ffffffff8101038b:	0f 84 ce 00 00 00    	je     ffffffff8101045f <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0x109>
                case Crd::MEM:  return static_cast<Space_mem *>(this);
ffffffff81010391:	48 8d 86 90 00 00 00 	lea    0x90(%rsi),%rax
ffffffff81010398:	4d 8d bd 90 00 00 00 	lea    0x90(%r13),%r15
ffffffff8101039f:	48 89 04 24          	mov    %rax,(%rsp)

        ALWAYS_INLINE
        inline unsigned order() const { return val >> 7 & 0x1f; }

        ALWAYS_INLINE
        inline mword base() const { return val >> 12; }
ffffffff810103a3:	48 89 d0             	mov    %rdx,%rax

        Space *snd = pd->subspace (t), *rcv = subspace (t);
        mword sb = crd.base(), so = crd.order(), rb = xlt.base(), ro = xlt.order();
        Mdb *mdb, *node;

        for (node = mdb = snd->tree_lookup (sb); node; node = node->prnt)
ffffffff810103a6:	48 8b 3c 24          	mov    (%rsp),%rdi

        ALWAYS_INLINE
        inline unsigned attr() const { return val >> 2 & 0x1f; }

        ALWAYS_INLINE
        inline unsigned order() const { return val >> 7 & 0x1f; }
ffffffff810103aa:	48 c1 ea 07          	shr    $0x7,%rdx

        ALWAYS_INLINE
        inline mword base() const { return val >> 12; }
ffffffff810103ae:	4c 89 e6             	mov    %r12,%rsi
    Crd::Type t = xlt.type();

    if (t && t == crd.type()) {

        Space *snd = pd->subspace (t), *rcv = subspace (t);
        mword sb = crd.base(), so = crd.order(), rb = xlt.base(), ro = xlt.order();
ffffffff810103b1:	83 e2 1f             	and    $0x1f,%edx

        ALWAYS_INLINE
        inline unsigned attr() const { return val >> 2 & 0x1f; }

        ALWAYS_INLINE
        inline unsigned order() const { return val >> 7 & 0x1f; }
ffffffff810103b4:	49 c1 ec 07          	shr    $0x7,%r12

        ALWAYS_INLINE
        inline mword base() const { return val >> 12; }
ffffffff810103b8:	48 c1 e8 0c          	shr    $0xc,%rax
ffffffff810103bc:	48 c1 ee 0c          	shr    $0xc,%rsi
ffffffff810103c0:	41 83 e4 1f          	and    $0x1f,%r12d
ffffffff810103c4:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
        Mdb *mdb, *node;

        for (node = mdb = snd->tree_lookup (sb); node; node = node->prnt)
ffffffff810103c9:	31 d2                	xor    %edx,%edx
    Crd::Type t = xlt.type();

    if (t && t == crd.type()) {

        Space *snd = pd->subspace (t), *rcv = subspace (t);
        mword sb = crd.base(), so = crd.order(), rb = xlt.base(), ro = xlt.order();
ffffffff810103cb:	4c 89 64 24 18       	mov    %r12,0x18(%rsp)
ffffffff810103d0:	48 89 74 24 20       	mov    %rsi,0x20(%rsp)
ffffffff810103d5:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
ffffffff810103da:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
        Mdb *mdb, *node;

        for (node = mdb = snd->tree_lookup (sb); node; node = node->prnt)
ffffffff810103df:	e8 82 fa ff ff       	callq  ffffffff8100fe66 <_ZN5Space11tree_lookupEmb>
    Crd::Type t = xlt.type();

    if (t && t == crd.type()) {

        Space *snd = pd->subspace (t), *rcv = subspace (t);
        mword sb = crd.base(), so = crd.order(), rb = xlt.base(), ro = xlt.order();
ffffffff810103e4:	4c 8b 64 24 08       	mov    0x8(%rsp),%r12
        Mdb *mdb, *node;

        for (node = mdb = snd->tree_lookup (sb); node; node = node->prnt)
ffffffff810103e9:	48 89 c5             	mov    %rax,%rbp
ffffffff810103ec:	48 89 c3             	mov    %rax,%rbx
ffffffff810103ef:	48 85 db             	test   %rbx,%rbx
ffffffff810103f2:	75 4e                	jne    ffffffff81010442 <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0xec>
ffffffff810103f4:	49 8b 36             	mov    (%r14),%rsi
        if (!node) {
            /* Special handling on Genode:
             * If a translate of an item inside the same PD (receiver/sender in same PD)
             * are of no success, then return the very same item.
             */
            Mdb *first = snd->tree_lookup (crd.base());
ffffffff810103f7:	48 8b 3c 24          	mov    (%rsp),%rdi
ffffffff810103fb:	31 d2                	xor    %edx,%edx
ffffffff810103fd:	48 c1 ee 0c          	shr    $0xc,%rsi
ffffffff81010401:	e8 60 fa ff ff       	callq  ffffffff8100fe66 <_ZN5Space11tree_lookupEmb>
            if (first && first->space == rcv && first == mdb) {
ffffffff81010406:	48 85 c0             	test   %rax,%rax
        if (!node) {
            /* Special handling on Genode:
             * If a translate of an item inside the same PD (receiver/sender in same PD)
             * are of no success, then return the very same item.
             */
            Mdb *first = snd->tree_lookup (crd.base());
ffffffff81010409:	48 89 c3             	mov    %rax,%rbx
            if (first && first->space == rcv && first == mdb) {
ffffffff8101040c:	74 05                	je     ffffffff81010413 <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0xbd>
ffffffff8101040e:	48 39 eb             	cmp    %rbp,%rbx
ffffffff81010411:	74 63                	je     ffffffff81010476 <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0x120>
                return;
            }
        }
    }

    crd = Crd (0);
ffffffff81010413:	49 c7 06 00 00 00 00 	movq   $0x0,(%r14)
ffffffff8101041a:	e9 28 01 00 00       	jmpq   ffffffff81010547 <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0x1f1>
        }

        ALWAYS_INLINE
        inline Space *subspace (Crd::Type t)
        {
            switch (t) {
ffffffff8101041f:	83 f8 02             	cmp    $0x2,%eax
ffffffff81010422:	49 89 fd             	mov    %rdi,%r13
ffffffff81010425:	0f 85 5d ff ff ff    	jne    ffffffff81010388 <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0x32>
                case Crd::MEM:  return static_cast<Space_mem *>(this);
                case Crd::PIO:  return static_cast<Space_pio *>(this);
ffffffff8101042b:	48 8d 86 d8 02 00 00 	lea    0x2d8(%rsi),%rax
ffffffff81010432:	4d 8d bd d8 02 00 00 	lea    0x2d8(%r13),%r15
ffffffff81010439:	48 89 04 24          	mov    %rax,(%rsp)
ffffffff8101043d:	e9 61 ff ff ff       	jmpq   ffffffff810103a3 <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0x4d>
        Space *snd = pd->subspace (t), *rcv = subspace (t);
        mword sb = crd.base(), so = crd.order(), rb = xlt.base(), ro = xlt.order();
        Mdb *mdb, *node;

        for (node = mdb = snd->tree_lookup (sb); node; node = node->prnt)
            if (node->space == rcv && node != mdb && node->accessible())
ffffffff81010442:	48 39 eb             	cmp    %rbp,%rbx
ffffffff81010445:	74 12                	je     ffffffff81010459 <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0x103>
ffffffff81010447:	4c 39 7b 50          	cmp    %r15,0x50(%rbx)
ffffffff8101044b:	75 0c                	jne    ffffffff81010459 <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0x103>
        static inline void destroy (Mdb *obj, Quota &quota) { obj->~Mdb(); cache.free (obj, quota); }

        template <typename T> void destroy (T *, Quota &);

        ALWAYS_INLINE
        inline bool accessible() const { return !Avl::removed() && !Avl::invalid(); }
ffffffff8101044d:	66 8b 43 12          	mov    0x12(%rbx),%ax
ffffffff81010451:	ff c8                	dec    %eax
ffffffff81010453:	66 83 f8 02          	cmp    $0x2,%ax
ffffffff81010457:	77 55                	ja     ffffffff810104ae <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0x158>

        Space *snd = pd->subspace (t), *rcv = subspace (t);
        mword sb = crd.base(), so = crd.order(), rb = xlt.base(), ro = xlt.order();
        Mdb *mdb, *node;

        for (node = mdb = snd->tree_lookup (sb); node; node = node->prnt)
ffffffff81010459:	48 8b 5b 48          	mov    0x48(%rbx),%rbx
ffffffff8101045d:	eb 90                	jmp    ffffffff810103ef <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0x99>
                case Crd::OBJ:  return static_cast<Space_obj *>(this);
ffffffff8101045f:	48 8d 86 f8 02 00 00 	lea    0x2f8(%rsi),%rax
ffffffff81010466:	4d 8d bd f8 02 00 00 	lea    0x2f8(%r13),%r15
ffffffff8101046d:	48 89 04 24          	mov    %rax,(%rsp)
ffffffff81010471:	e9 2d ff ff ff       	jmpq   ffffffff810103a3 <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0x4d>
            /* Special handling on Genode:
             * If a translate of an item inside the same PD (receiver/sender in same PD)
             * are of no success, then return the very same item.
             */
            Mdb *first = snd->tree_lookup (crd.base());
            if (first && first->space == rcv && first == mdb) {
ffffffff81010476:	4c 39 7b 50          	cmp    %r15,0x50(%rbx)
ffffffff8101047a:	75 97                	jne    ffffffff81010413 <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0xbd>
                rb = xlt.base();
ffffffff8101047c:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
                ro = xlt.order();
                if ((ro = clamp (first->node_base, rb, first->node_order, ro)) != ~0UL)
ffffffff81010481:	48 8b 4b 68          	mov    0x68(%rbx),%rcx
ffffffff81010485:	48 8d 54 24 28       	lea    0x28(%rsp),%rdx
ffffffff8101048a:	48 8b 73 60          	mov    0x60(%rbx),%rsi
ffffffff8101048e:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
ffffffff81010493:	4c 89 ef             	mov    %r13,%rdi
             * If a translate of an item inside the same PD (receiver/sender in same PD)
             * are of no success, then return the very same item.
             */
            Mdb *first = snd->tree_lookup (crd.base());
            if (first && first->space == rcv && first == mdb) {
                rb = xlt.base();
ffffffff81010496:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
                ro = xlt.order();
                if ((ro = clamp (first->node_base, rb, first->node_order, ro)) != ~0UL)
ffffffff8101049b:	e8 dc fd ff ff       	callq  ffffffff8101027c <_ZN2Pd5clampEmRmmm>
ffffffff810104a0:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
ffffffff810104a4:	49 89 c4             	mov    %rax,%r12
ffffffff810104a7:	75 26                	jne    ffffffff810104cf <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0x179>
ffffffff810104a9:	e9 65 ff ff ff       	jmpq   ffffffff81010413 <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0xbd>
        mword sb = crd.base(), so = crd.order(), rb = xlt.base(), ro = xlt.order();
        Mdb *mdb, *node;

        for (node = mdb = snd->tree_lookup (sb); node; node = node->prnt)
            if (node->space == rcv && node != mdb && node->accessible())
                if ((ro = clamp (node->node_base, rb, node->node_order, ro)) != ~0UL)
ffffffff810104ae:	48 8b 4b 68          	mov    0x68(%rbx),%rcx
ffffffff810104b2:	48 8b 73 60          	mov    0x60(%rbx),%rsi
ffffffff810104b6:	48 8d 54 24 28       	lea    0x28(%rsp),%rdx
ffffffff810104bb:	4d 89 e0             	mov    %r12,%r8
ffffffff810104be:	4c 89 ef             	mov    %r13,%rdi
ffffffff810104c1:	e8 b6 fd ff ff       	callq  ffffffff8101027c <_ZN2Pd5clampEmRmmm>
ffffffff810104c6:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
ffffffff810104ca:	49 89 c4             	mov    %rax,%r12
ffffffff810104cd:	74 8a                	je     ffffffff81010459 <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0x103>
           }
        }

        if (node) {

            so = clamp (mdb->node_base, sb, mdb->node_order, so);
ffffffff810104cf:	48 8b 4d 68          	mov    0x68(%rbp),%rcx
ffffffff810104d3:	48 8b 75 60          	mov    0x60(%rbp),%rsi
ffffffff810104d7:	48 8d 54 24 20       	lea    0x20(%rsp),%rdx
ffffffff810104dc:	4c 8b 44 24 18       	mov    0x18(%rsp),%r8
ffffffff810104e1:	4c 89 ef             	mov    %r13,%rdi
ffffffff810104e4:	e8 93 fd ff ff       	callq  ffffffff8101027c <_ZN2Pd5clampEmRmmm>
ffffffff810104e9:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
ffffffff810104ee:	48 03 75 58          	add    0x58(%rbp),%rsi
            sb = (sb - mdb->node_base) + (mdb->node_phys - node->node_phys) + node->node_base;

            if ((ro = clamp (sb, rb, so, ro)) != ~0UL) {
ffffffff810104f2:	48 8d 54 24 28       	lea    0x28(%rsp),%rdx
ffffffff810104f7:	48 03 73 60          	add    0x60(%rbx),%rsi
ffffffff810104fb:	4d 89 e0             	mov    %r12,%r8
ffffffff810104fe:	48 89 c1             	mov    %rax,%rcx
ffffffff81010501:	48 2b 75 60          	sub    0x60(%rbp),%rsi
ffffffff81010505:	4c 89 ef             	mov    %r13,%rdi
        }

        if (node) {

            so = clamp (mdb->node_base, sb, mdb->node_order, so);
            sb = (sb - mdb->node_base) + (mdb->node_phys - node->node_phys) + node->node_base;
ffffffff81010508:	48 2b 73 58          	sub    0x58(%rbx),%rsi
ffffffff8101050c:	48 89 74 24 20       	mov    %rsi,0x20(%rsp)

            if ((ro = clamp (sb, rb, so, ro)) != ~0UL) {
ffffffff81010511:	e8 66 fd ff ff       	callq  ffffffff8101027c <_ZN2Pd5clampEmRmmm>
ffffffff81010516:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
ffffffff8101051a:	0f 84 f3 fe ff ff    	je     ffffffff81010413 <_ZN2Pd7xlt_crdEPS_3CrdRS1_+0xbd>

        ALWAYS_INLINE
        inline explicit Crd (mword v) : val (v) {}

        ALWAYS_INLINE
        inline explicit Crd (Type t, mword b = 0, mword o = 0x1f, mword a = 0x1f) : val (b << 12 | o << 7 | a << 2 | t) {}
ffffffff81010520:	48 8b 55 70          	mov    0x70(%rbp),%rdx
ffffffff81010524:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
ffffffff81010529:	48 c1 e0 07          	shl    $0x7,%rax
ffffffff8101052d:	48 c1 e1 0c          	shl    $0xc,%rcx
ffffffff81010531:	48 c1 e2 02          	shl    $0x2,%rdx
ffffffff81010535:	48 09 ca             	or     %rcx,%rdx
ffffffff81010538:	49 8b 0e             	mov    (%r14),%rcx
ffffffff8101053b:	83 e1 03             	and    $0x3,%ecx
ffffffff8101053e:	48 09 ca             	or     %rcx,%rdx
ffffffff81010541:	48 09 d0             	or     %rdx,%rax
ffffffff81010544:	49 89 06             	mov    %rax,(%r14)
            }
        }
    }

    crd = Crd (0);
}
ffffffff81010547:	48 83 c4 38          	add    $0x38,%rsp
ffffffff8101054b:	5b                   	pop    %rbx
ffffffff8101054c:	5d                   	pop    %rbp
ffffffff8101054d:	41 5c                	pop    %r12
ffffffff8101054f:	41 5d                	pop    %r13
ffffffff81010551:	41 5e                	pop    %r14
ffffffff81010553:	41 5f                	pop    %r15
ffffffff81010555:	c3                   	retq   

ffffffff81010556 <__cxa_atexit>:
    for (unsigned cpu = 0; cpu < NUM_CPU; cpu++)
        if (Hip::cpu_online (cpu))
            Space_mem::loc[cpu].clear(quota, Space_mem::hpt.dest_loc, Space_mem::hpt.iter_loc_lev);
}

extern "C" int __cxa_atexit(void (*)(void *), void *, void *) { return 0; }
ffffffff81010556:	31 c0                	xor    %eax,%eax
ffffffff81010558:	c3                   	retq   
ffffffff81010559:	90                   	nop

ffffffff8101055a <_ZN2Pd6revokeI9Space_memEEvmmmbb>:

    return s;
}

template <typename S>
void Pd::revoke (mword const base, mword const ord, mword const attr, bool self, bool kim)
ffffffff8101055a:	41 57                	push   %r15
ffffffff8101055c:	41 56                	push   %r14

        unsigned d = node->dpth; bool demote = false;

        for (Mdb *ptr;; node = ptr) {

            if (node->dpth == d + !self)
ffffffff8101055e:	41 83 f0 01          	xor    $0x1,%r8d

    return s;
}

template <typename S>
void Pd::revoke (mword const base, mword const ord, mword const attr, bool self, bool kim)
ffffffff81010562:	41 55                	push   %r13
ffffffff81010564:	41 54                	push   %r12

        unsigned d = node->dpth; bool demote = false;

        for (Mdb *ptr;; node = ptr) {

            if (node->dpth == d + !self)
ffffffff81010566:	41 0f b6 c0          	movzbl %r8b,%eax

    return s;
}

template <typename S>
void Pd::revoke (mword const base, mword const ord, mword const attr, bool self, bool kim)
ffffffff8101056a:	55                   	push   %rbp
ffffffff8101056b:	53                   	push   %rbx
ffffffff8101056c:	48 89 fd             	mov    %rdi,%rbp
ffffffff8101056f:	49 89 cd             	mov    %rcx,%r13
ffffffff81010572:	48 83 ec 78          	sub    $0x78,%rsp

        unsigned d = node->dpth; bool demote = false;

        for (Mdb *ptr;; node = ptr) {

            if (node->dpth == d + !self)
ffffffff81010576:	89 44 24 28          	mov    %eax,0x28(%rsp)

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
                trace (0, "warning: rcu element already enqueued");
ffffffff8101057a:	48 8d 44 24 3f       	lea    0x3f(%rsp),%rax

    return s;
}

template <typename S>
void Pd::revoke (mword const base, mword const ord, mword const attr, bool self, bool kim)
ffffffff8101057f:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
ffffffff81010584:	48 89 54 24 10       	mov    %rdx,0x10(%rsp)
ffffffff81010589:	44 88 4c 24 2e       	mov    %r9b,0x2e(%rsp)
ffffffff8101058e:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81010594:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
{
    Mdb *mdb;
    for (mword addr = base; (mdb = S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {
ffffffff81010599:	48 8d bd 90 00 00 00 	lea    0x90(%rbp),%rdi
ffffffff810105a0:	ba 01 00 00 00       	mov    $0x1,%edx
ffffffff810105a5:	e8 bc f8 ff ff       	callq  ffffffff8100fe66 <_ZN5Space11tree_lookupEmb>
ffffffff810105aa:	48 85 c0             	test   %rax,%rax
ffffffff810105ad:	48 89 c3             	mov    %rax,%rbx
ffffffff810105b0:	0f 84 0d 03 00 00    	je     ffffffff810108c3 <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x369>

        mword o, p, b = base;
ffffffff810105b6:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
        if ((o = clamp (mdb->node_base, b, mdb->node_order, ord)) == ~0UL)
ffffffff810105bb:	48 8b 4b 68          	mov    0x68(%rbx),%rcx
ffffffff810105bf:	48 8d 54 24 38       	lea    0x38(%rsp),%rdx
ffffffff810105c4:	48 8b 73 60          	mov    0x60(%rbx),%rsi
ffffffff810105c8:	4c 8b 44 24 10       	mov    0x10(%rsp),%r8
ffffffff810105cd:	48 89 ef             	mov    %rbp,%rdi
void Pd::revoke (mword const base, mword const ord, mword const attr, bool self, bool kim)
{
    Mdb *mdb;
    for (mword addr = base; (mdb = S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {

        mword o, p, b = base;
ffffffff810105d0:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
        if ((o = clamp (mdb->node_base, b, mdb->node_order, ord)) == ~0UL)
ffffffff810105d5:	e8 a2 fc ff ff       	callq  ffffffff8101027c <_ZN2Pd5clampEmRmmm>
ffffffff810105da:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
ffffffff810105de:	49 89 c6             	mov    %rax,%r14
ffffffff810105e1:	0f 84 dc 02 00 00    	je     ffffffff810108c3 <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x369>
            break;

        /* keep in mapping database if requested and at least one child node exists */
        if (kim && (ACCESS_ONCE(mdb->next)->dpth > mdb->dpth)) {
ffffffff810105e7:	80 7c 24 2e 00       	cmpb   $0x0,0x2e(%rsp)
ffffffff810105ec:	74 79                	je     ffffffff81010667 <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x10d>
ffffffff810105ee:	48 8b 43 40          	mov    0x40(%rbx),%rax
ffffffff810105f2:	66 8b 4b 32          	mov    0x32(%rbx),%cx
ffffffff810105f6:	66 39 48 32          	cmp    %cx,0x32(%rax)
ffffffff810105fa:	76 6b                	jbe    ffffffff81010667 <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x10d>
        Quota q;
        Quota &r;

    public:

        Quota_guard(Quota &ref) : q(), r(ref) { }
ffffffff810105fc:	48 8d 7c 24 40       	lea    0x40(%rsp),%rdi
ffffffff81010601:	e8 ec f7 ff ff       	callq  ffffffff8100fdf2 <_ZN5QuotaC1Ev>
            Quota_guard qg(this->quota);
ffffffff81010606:	48 8d 85 08 03 00 00 	lea    0x308(%rbp),%rax
ffffffff8101060d:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
            if (mdb->node_attr & 0x1f) {
ffffffff81010612:	f6 43 70 1f          	testb  $0x1f,0x70(%rbx)
ffffffff81010616:	74 23                	je     ffffffff8101063b <_ZN2Pd6revokeI9Space_memEEvmmmbb+0xe1>
                static_cast<S *>(mdb->space)->update (qg, mdb, 0x1f);
ffffffff81010618:	48 8b 7b 50          	mov    0x50(%rbx),%rdi
ffffffff8101061c:	48 8d 74 24 40       	lea    0x40(%rsp),%rsi
ffffffff81010621:	b9 1f 00 00 00       	mov    $0x1f,%ecx
ffffffff81010626:	48 89 da             	mov    %rbx,%rdx
ffffffff81010629:	e8 7c 5a 00 00       	callq  ffffffff810160aa <_ZN9Space_mem6updateER11Quota_guardP3Mdbm>
                mdb->demote_node (0x1f);
ffffffff8101062e:	be 1f 00 00 00       	mov    $0x1f,%esi
ffffffff81010633:	48 89 df             	mov    %rbx,%rdi
ffffffff81010636:	e8 6b 83 ff ff       	callq  ffffffff810089a6 <_ZN3Mdb11demote_nodeEm>
            }
            static_cast<S *>(mdb->space)->tree_remove (mdb, Avl::State::KIM);
ffffffff8101063b:	48 89 df             	mov    %rbx,%rdi
ffffffff8101063e:	be 02 00 00 00       	mov    $0x2,%esi
ffffffff81010643:	e8 97 f9 ff ff       	callq  ffffffff8100ffdf <_ZN5Space11tree_removeEP3MdbN3Avl5StateE>
            continue;
ffffffff81010648:	48 8d 7c 24 40       	lea    0x40(%rsp),%rdi
ffffffff8101064d:	e8 0a f8 ff ff       	callq  ffffffff8100fe5c <_ZN11Quota_guardD1Ev>

template <typename S>
void Pd::revoke (mword const base, mword const ord, mword const attr, bool self, bool kim)
{
    Mdb *mdb;
    for (mword addr = base; (mdb = S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {
ffffffff81010652:	48 8b 4b 68          	mov    0x68(%rbx),%rcx
ffffffff81010656:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff8101065b:	48 d3 e6             	shl    %cl,%rsi
ffffffff8101065e:	48 03 73 60          	add    0x60(%rbx),%rsi
ffffffff81010662:	e9 32 ff ff ff       	jmpq   ffffffff81010599 <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x3f>
            continue;
        }

        Mdb *node = mdb;

        unsigned d = node->dpth; bool demote = false;
ffffffff81010667:	0f b7 43 32          	movzwl 0x32(%rbx),%eax

            if (node->dpth == d + !self)
                demote = clamp (node->node_phys, p = b - mdb->node_base + mdb->node_phys, node->node_order, o) != ~0UL;

            if (demote && node->node_attr & attr) {
                Quota_guard qg(this->quota);
ffffffff8101066b:	4c 8d bd 08 03 00 00 	lea    0x308(%rbp),%r15
            continue;
        }

        Mdb *node = mdb;

        unsigned d = node->dpth; bool demote = false;
ffffffff81010672:	49 89 dc             	mov    %rbx,%r12
ffffffff81010675:	45 31 c0             	xor    %r8d,%r8d
ffffffff81010678:	89 44 24 18          	mov    %eax,0x18(%rsp)

        for (Mdb *ptr;; node = ptr) {

            if (node->dpth == d + !self)
ffffffff8101067c:	8b 44 24 28          	mov    0x28(%rsp),%eax
ffffffff81010680:	03 44 24 18          	add    0x18(%rsp),%eax
ffffffff81010684:	89 44 24 1c          	mov    %eax,0x1c(%rsp)
ffffffff81010688:	41 0f b7 44 24 32    	movzwl 0x32(%r12),%eax
ffffffff8101068e:	3b 44 24 1c          	cmp    0x1c(%rsp),%eax
ffffffff81010692:	75 33                	jne    ffffffff810106c7 <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x16d>
ffffffff81010694:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
ffffffff81010699:	48 03 43 58          	add    0x58(%rbx),%rax
                demote = clamp (node->node_phys, p = b - mdb->node_base + mdb->node_phys, node->node_order, o) != ~0UL;
ffffffff8101069d:	48 8d 54 24 30       	lea    0x30(%rsp),%rdx
ffffffff810106a2:	48 2b 43 60          	sub    0x60(%rbx),%rax
ffffffff810106a6:	49 8b 4c 24 68       	mov    0x68(%r12),%rcx
ffffffff810106ab:	4d 89 f0             	mov    %r14,%r8
ffffffff810106ae:	49 8b 74 24 58       	mov    0x58(%r12),%rsi
ffffffff810106b3:	48 89 ef             	mov    %rbp,%rdi
ffffffff810106b6:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
ffffffff810106bb:	e8 bc fb ff ff       	callq  ffffffff8101027c <_ZN2Pd5clampEmRmmm>
ffffffff810106c0:	48 ff c0             	inc    %rax
ffffffff810106c3:	41 0f 95 c0          	setne  %r8b

            if (demote && node->node_attr & attr) {
ffffffff810106c7:	45 84 c0             	test   %r8b,%r8b
ffffffff810106ca:	74 4a                	je     ffffffff81010716 <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x1bc>
ffffffff810106cc:	4d 85 6c 24 70       	test   %r13,0x70(%r12)
ffffffff810106d1:	74 43                	je     ffffffff81010716 <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x1bc>
ffffffff810106d3:	48 8d 7c 24 40       	lea    0x40(%rsp),%rdi
ffffffff810106d8:	44 88 44 24 2f       	mov    %r8b,0x2f(%rsp)
ffffffff810106dd:	e8 10 f7 ff ff       	callq  ffffffff8100fdf2 <_ZN5QuotaC1Ev>
                Quota_guard qg(this->quota);
ffffffff810106e2:	4c 89 7c 24 68       	mov    %r15,0x68(%rsp)
                static_cast<S *>(node->space)->update (qg, node, attr);
ffffffff810106e7:	49 8b 7c 24 50       	mov    0x50(%r12),%rdi
ffffffff810106ec:	48 8d 74 24 40       	lea    0x40(%rsp),%rsi
ffffffff810106f1:	4c 89 e9             	mov    %r13,%rcx
ffffffff810106f4:	4c 89 e2             	mov    %r12,%rdx
ffffffff810106f7:	e8 ae 59 00 00       	callq  ffffffff810160aa <_ZN9Space_mem6updateER11Quota_guardP3Mdbm>
                node->demote_node (attr);
ffffffff810106fc:	4c 89 ee             	mov    %r13,%rsi
ffffffff810106ff:	4c 89 e7             	mov    %r12,%rdi
ffffffff81010702:	e8 9f 82 ff ff       	callq  ffffffff810089a6 <_ZN3Mdb11demote_nodeEm>
ffffffff81010707:	48 8d 7c 24 40       	lea    0x40(%rsp),%rdi
ffffffff8101070c:	e8 4b f7 ff ff       	callq  ffffffff8100fe5c <_ZN11Quota_guardD1Ev>
ffffffff81010711:	44 8a 44 24 2f       	mov    0x2f(%rsp),%r8b
            }

            ptr = ACCESS_ONCE (node->next);
ffffffff81010716:	49 8b 44 24 40       	mov    0x40(%r12),%rax

            if (ptr->dpth <= d)
ffffffff8101071b:	0f b7 50 32          	movzwl 0x32(%rax),%edx
ffffffff8101071f:	3b 54 24 18          	cmp    0x18(%rsp),%edx
ffffffff81010723:	76 08                	jbe    ffffffff8101072d <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x1d3>
ffffffff81010725:	49 89 c4             	mov    %rax,%r12
ffffffff81010728:	e9 5b ff ff ff       	jmpq   ffffffff81010688 <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x12e>
                break;
        }

        Mdb *x = ACCESS_ONCE (node->next);
ffffffff8101072d:	49 8b 54 24 40       	mov    0x40(%r12),%rdx
        assert (x->dpth <= d || (x->dpth == node->dpth + 1 && !(x->node_attr & attr)));
ffffffff81010732:	0f b7 4a 32          	movzwl 0x32(%rdx),%ecx
ffffffff81010736:	3b 4c 24 18          	cmp    0x18(%rsp),%ecx
ffffffff8101073a:	76 3a                	jbe    ffffffff81010776 <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x21c>
ffffffff8101073c:	41 0f b7 44 24 32    	movzwl 0x32(%r12),%eax
ffffffff81010742:	ff c0                	inc    %eax
ffffffff81010744:	39 c1                	cmp    %eax,%ecx
ffffffff81010746:	75 06                	jne    ffffffff8101074e <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x1f4>
ffffffff81010748:	4c 85 6a 70          	test   %r13,0x70(%rdx)
ffffffff8101074c:	74 28                	je     ffffffff81010776 <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x21c>
ffffffff8101074e:	49 c7 c0 80 01 02 81 	mov    $0xffffffff81020180,%r8
ffffffff81010755:	b9 ad 00 00 00       	mov    $0xad,%ecx
ffffffff8101075a:	48 c7 c2 e1 fd 01 81 	mov    $0xffffffff8101fde1,%rdx
ffffffff81010761:	48 c7 c6 91 fe 01 81 	mov    $0xffffffff8101fe91,%rsi
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81010768:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8101076f:	31 c0                	xor    %eax,%eax
ffffffff81010771:	e8 da 17 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

        bool preempt = Cpu::preemption;
ffffffff81010776:	44 8a 35 b3 ef fe 3e 	mov    0x3efeefb3(%rip),%r14b        # ffffffffbffff730 <_ZN3Cpu10preemptionE>

        for (Mdb *ptr;; node = ptr) {

            if (preempt)
ffffffff8101077d:	45 84 f6             	test   %r14b,%r14b
ffffffff81010780:	74 2d                	je     ffffffff810107af <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x255>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81010782:	80 3d a7 ef fe 3e 00 	cmpb   $0x0,0x3efeefa7(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81010789:	75 1c                	jne    ffffffff810107a7 <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x24d>
ffffffff8101078b:	49 c7 c0 50 02 02 81 	mov    $0xffffffff81020250,%r8
ffffffff81010792:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff81010797:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8101079e:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff810107a5:	eb c1                	jmp    ffffffff81010768 <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x20e>

            asm volatile ("cli" : : : "memory");
ffffffff810107a7:	fa                   	cli    
            preemption = false;
ffffffff810107a8:	c6 05 81 ef fe 3e 00 	movb   $0x0,0x3efeef81(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            if (node->remove_node() && static_cast<S *>(node->space)->tree_remove (node))
ffffffff810107af:	4c 89 e7             	mov    %r12,%rdi
ffffffff810107b2:	e8 8f 82 ff ff       	callq  ffffffff81008a46 <_ZN3Mdb11remove_nodeEv>
ffffffff810107b7:	84 c0                	test   %al,%al
ffffffff810107b9:	74 62                	je     ffffffff8101081d <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x2c3>
ffffffff810107bb:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff810107c0:	4c 89 e7             	mov    %r12,%rdi
ffffffff810107c3:	e8 17 f8 ff ff       	callq  ffffffff8100ffdf <_ZN5Space11tree_removeEP3MdbN3Avl5StateE>
ffffffff810107c8:	84 c0                	test   %al,%al
ffffffff810107ca:	74 51                	je     ffffffff8101081d <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x2c3>
                Rcu::call (node);
ffffffff810107cc:	4d 85 e4             	test   %r12,%r12
ffffffff810107cf:	0f 84 e4 00 00 00    	je     ffffffff810108b9 <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x35f>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
ffffffff810107d5:	49 8b 54 24 28       	mov    0x28(%r12),%rdx
ffffffff810107da:	4d 8d 7c 24 18       	lea    0x18(%r12),%r15
ffffffff810107df:	48 85 d2             	test   %rdx,%rdx
ffffffff810107e2:	74 05                	je     ffffffff810107e9 <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x28f>
                e->pre_func(e);
ffffffff810107e4:	4c 89 ff             	mov    %r15,%rdi
ffffffff810107e7:	ff d2                	callq  *%rdx
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
ffffffff810107e9:	49 83 7c 24 18 00    	cmpq   $0x0,0x18(%r12)
ffffffff810107ef:	0f 84 9e 00 00 00    	je     ffffffff81010893 <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x339>
                trace (0, "warning: rcu element already enqueued");
ffffffff810107f5:	48 81 7c 24 20 00 d0 	cmpq   $0xffffffffbfffd000,0x20(%rsp)
ffffffff810107fc:	ff bf 
ffffffff810107fe:	8b 35 00 e8 fe 3e    	mov    0x3efee800(%rip),%esi        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81010804:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
ffffffff8101080b:	48 c7 c7 14 df 01 81 	mov    $0xffffffff8101df14,%rdi
ffffffff81010812:	48 0f 45 f0          	cmovne %rax,%rsi
ffffffff81010816:	31 c0                	xor    %eax,%eax
ffffffff81010818:	e8 6f 18 ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>

            if (preempt)
ffffffff8101081d:	45 84 f6             	test   %r14b,%r14b
ffffffff81010820:	74 30                	je     ffffffff81010852 <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x2f8>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81010822:	80 3d 07 ef fe 3e 00 	cmpb   $0x0,0x3efeef07(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81010829:	74 1f                	je     ffffffff8101084a <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x2f0>
ffffffff8101082b:	49 c7 c0 20 02 02 81 	mov    $0xffffffff81020220,%r8
ffffffff81010832:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff81010837:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8101083e:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff81010845:	e9 1e ff ff ff       	jmpq   ffffffff81010768 <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x20e>

            preemption = true;
ffffffff8101084a:	c6 05 df ee fe 3e 01 	movb   $0x1,0x3efeeedf(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81010851:	fb                   	sti    
                Cpu::preempt_enable();

            ptr = ACCESS_ONCE (node->prev);

            if (node->dpth <= d)
ffffffff81010852:	41 0f b7 44 24 32    	movzwl 0x32(%r12),%eax
                Rcu::call (node);

            if (preempt)
                Cpu::preempt_enable();

            ptr = ACCESS_ONCE (node->prev);
ffffffff81010858:	49 8b 54 24 38       	mov    0x38(%r12),%rdx

            if (node->dpth <= d)
ffffffff8101085d:	3b 44 24 18          	cmp    0x18(%rsp),%eax
ffffffff81010861:	76 08                	jbe    ffffffff8101086b <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x311>
        Mdb *x = ACCESS_ONCE (node->next);
        assert (x->dpth <= d || (x->dpth == node->dpth + 1 && !(x->node_attr & attr)));

        bool preempt = Cpu::preemption;

        for (Mdb *ptr;; node = ptr) {
ffffffff81010863:	49 89 d4             	mov    %rdx,%r12
ffffffff81010866:	e9 12 ff ff ff       	jmpq   ffffffff8101077d <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x223>

            if (node->dpth <= d)
                break;
        }

        assert (node == mdb);
ffffffff8101086b:	49 39 dc             	cmp    %rbx,%r12
ffffffff8101086e:	0f 84 de fd ff ff    	je     ffffffff81010652 <_ZN2Pd6revokeI9Space_memEEvmmmbb+0xf8>
ffffffff81010874:	49 c7 c0 80 01 02 81 	mov    $0xffffffff81020180,%r8
ffffffff8101087b:	b9 c2 00 00 00       	mov    $0xc2,%ecx
ffffffff81010880:	48 c7 c2 e1 fd 01 81 	mov    $0xffffffff8101fde1,%rdx
ffffffff81010887:	48 c7 c6 85 fe 01 81 	mov    $0xffffffff8101fe85,%rsi
ffffffff8101088e:	e9 d5 fe ff ff       	jmpq   ffffffff81010768 <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x20e>
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
ffffffff81010893:	48 8b 15 ce ef fe 3e 	mov    0x3efeefce(%rip),%rdx        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff8101089a:	4c 39 fa             	cmp    %r15,%rdx
ffffffff8101089d:	0f 84 52 ff ff ff    	je     ffffffff810107f5 <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x29b>
                trace (0, "warning: rcu element already enqueued");
                return;
            }

            count ++;
ffffffff810108a3:	48 ff 05 c6 ef fe 3e 	incq   0x3efeefc6(%rip)        # ffffffffbffff870 <_ZN3Rcu4nextE+0x10>

           *tail = e;
ffffffff810108aa:	4c 89 3a             	mov    %r15,(%rdx)
            tail = &e->next;
ffffffff810108ad:	4c 89 3d b4 ef fe 3e 	mov    %r15,0x3efeefb4(%rip)        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff810108b4:	e9 64 ff ff ff       	jmpq   ffffffff8101081d <_ZN2Pd6revokeI9Space_memEEvmmmbb+0x2c3>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
ffffffff810108b9:	48 8b 04 25 10 00 00 	mov    0x10,%rax
ffffffff810108c0:	00 
ffffffff810108c1:	0f 0b                	ud2    
    }
}
ffffffff810108c3:	48 83 c4 78          	add    $0x78,%rsp
ffffffff810108c7:	5b                   	pop    %rbx
ffffffff810108c8:	5d                   	pop    %rbp
ffffffff810108c9:	41 5c                	pop    %r12
ffffffff810108cb:	41 5d                	pop    %r13
ffffffff810108cd:	41 5e                	pop    %r14
ffffffff810108cf:	41 5f                	pop    %r15
ffffffff810108d1:	c3                   	retq   

ffffffff810108d2 <_ZN2Pd6revokeI9Space_pioEEvmmmbb>:

    return s;
}

template <typename S>
void Pd::revoke (mword const base, mword const ord, mword const attr, bool self, bool kim)
ffffffff810108d2:	41 57                	push   %r15
ffffffff810108d4:	41 56                	push   %r14

        unsigned d = node->dpth; bool demote = false;

        for (Mdb *ptr;; node = ptr) {

            if (node->dpth == d + !self)
ffffffff810108d6:	41 83 f0 01          	xor    $0x1,%r8d

    return s;
}

template <typename S>
void Pd::revoke (mword const base, mword const ord, mword const attr, bool self, bool kim)
ffffffff810108da:	41 55                	push   %r13
ffffffff810108dc:	41 54                	push   %r12

        unsigned d = node->dpth; bool demote = false;

        for (Mdb *ptr;; node = ptr) {

            if (node->dpth == d + !self)
ffffffff810108de:	41 0f b6 c0          	movzbl %r8b,%eax

    return s;
}

template <typename S>
void Pd::revoke (mword const base, mword const ord, mword const attr, bool self, bool kim)
ffffffff810108e2:	55                   	push   %rbp
ffffffff810108e3:	53                   	push   %rbx
ffffffff810108e4:	48 89 fd             	mov    %rdi,%rbp
ffffffff810108e7:	49 89 cd             	mov    %rcx,%r13
ffffffff810108ea:	48 83 ec 78          	sub    $0x78,%rsp

        unsigned d = node->dpth; bool demote = false;

        for (Mdb *ptr;; node = ptr) {

            if (node->dpth == d + !self)
ffffffff810108ee:	89 44 24 28          	mov    %eax,0x28(%rsp)

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
                trace (0, "warning: rcu element already enqueued");
ffffffff810108f2:	48 8d 44 24 3f       	lea    0x3f(%rsp),%rax

    return s;
}

template <typename S>
void Pd::revoke (mword const base, mword const ord, mword const attr, bool self, bool kim)
ffffffff810108f7:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
ffffffff810108fc:	48 89 54 24 10       	mov    %rdx,0x10(%rsp)
ffffffff81010901:	44 88 4c 24 2e       	mov    %r9b,0x2e(%rsp)
ffffffff81010906:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8101090c:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
{
    Mdb *mdb;
    for (mword addr = base; (mdb = S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {
ffffffff81010911:	48 8d bd d8 02 00 00 	lea    0x2d8(%rbp),%rdi
ffffffff81010918:	ba 01 00 00 00       	mov    $0x1,%edx
ffffffff8101091d:	e8 44 f5 ff ff       	callq  ffffffff8100fe66 <_ZN5Space11tree_lookupEmb>
ffffffff81010922:	48 85 c0             	test   %rax,%rax
ffffffff81010925:	48 89 c3             	mov    %rax,%rbx
ffffffff81010928:	0f 84 0d 03 00 00    	je     ffffffff81010c3b <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x369>

        mword o, p, b = base;
ffffffff8101092e:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
        if ((o = clamp (mdb->node_base, b, mdb->node_order, ord)) == ~0UL)
ffffffff81010933:	48 8b 4b 68          	mov    0x68(%rbx),%rcx
ffffffff81010937:	48 8d 54 24 38       	lea    0x38(%rsp),%rdx
ffffffff8101093c:	48 8b 73 60          	mov    0x60(%rbx),%rsi
ffffffff81010940:	4c 8b 44 24 10       	mov    0x10(%rsp),%r8
ffffffff81010945:	48 89 ef             	mov    %rbp,%rdi
void Pd::revoke (mword const base, mword const ord, mword const attr, bool self, bool kim)
{
    Mdb *mdb;
    for (mword addr = base; (mdb = S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {

        mword o, p, b = base;
ffffffff81010948:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
        if ((o = clamp (mdb->node_base, b, mdb->node_order, ord)) == ~0UL)
ffffffff8101094d:	e8 2a f9 ff ff       	callq  ffffffff8101027c <_ZN2Pd5clampEmRmmm>
ffffffff81010952:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
ffffffff81010956:	49 89 c6             	mov    %rax,%r14
ffffffff81010959:	0f 84 dc 02 00 00    	je     ffffffff81010c3b <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x369>
            break;

        /* keep in mapping database if requested and at least one child node exists */
        if (kim && (ACCESS_ONCE(mdb->next)->dpth > mdb->dpth)) {
ffffffff8101095f:	80 7c 24 2e 00       	cmpb   $0x0,0x2e(%rsp)
ffffffff81010964:	74 79                	je     ffffffff810109df <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x10d>
ffffffff81010966:	48 8b 43 40          	mov    0x40(%rbx),%rax
ffffffff8101096a:	66 8b 4b 32          	mov    0x32(%rbx),%cx
ffffffff8101096e:	66 39 48 32          	cmp    %cx,0x32(%rax)
ffffffff81010972:	76 6b                	jbe    ffffffff810109df <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x10d>
ffffffff81010974:	48 8d 7c 24 40       	lea    0x40(%rsp),%rdi
ffffffff81010979:	e8 74 f4 ff ff       	callq  ffffffff8100fdf2 <_ZN5QuotaC1Ev>
            Quota_guard qg(this->quota);
ffffffff8101097e:	48 8d 85 08 03 00 00 	lea    0x308(%rbp),%rax
ffffffff81010985:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
            if (mdb->node_attr & 0x1f) {
ffffffff8101098a:	f6 43 70 1f          	testb  $0x1f,0x70(%rbx)
ffffffff8101098e:	74 23                	je     ffffffff810109b3 <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0xe1>
                static_cast<S *>(mdb->space)->update (qg, mdb, 0x1f);
ffffffff81010990:	48 8b 7b 50          	mov    0x50(%rbx),%rdi
ffffffff81010994:	48 8d 74 24 40       	lea    0x40(%rsp),%rsi
ffffffff81010999:	b9 1f 00 00 00       	mov    $0x1f,%ecx
ffffffff8101099e:	48 89 da             	mov    %rbx,%rdx
ffffffff810109a1:	e8 ae 62 00 00       	callq  ffffffff81016c54 <_ZN9Space_pio6updateER5QuotaP3Mdbm>
                mdb->demote_node (0x1f);
ffffffff810109a6:	be 1f 00 00 00       	mov    $0x1f,%esi
ffffffff810109ab:	48 89 df             	mov    %rbx,%rdi
ffffffff810109ae:	e8 f3 7f ff ff       	callq  ffffffff810089a6 <_ZN3Mdb11demote_nodeEm>
            }
            static_cast<S *>(mdb->space)->tree_remove (mdb, Avl::State::KIM);
ffffffff810109b3:	48 89 df             	mov    %rbx,%rdi
ffffffff810109b6:	be 02 00 00 00       	mov    $0x2,%esi
ffffffff810109bb:	e8 1f f6 ff ff       	callq  ffffffff8100ffdf <_ZN5Space11tree_removeEP3MdbN3Avl5StateE>
            continue;
ffffffff810109c0:	48 8d 7c 24 40       	lea    0x40(%rsp),%rdi
ffffffff810109c5:	e8 92 f4 ff ff       	callq  ffffffff8100fe5c <_ZN11Quota_guardD1Ev>

template <typename S>
void Pd::revoke (mword const base, mword const ord, mword const attr, bool self, bool kim)
{
    Mdb *mdb;
    for (mword addr = base; (mdb = S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {
ffffffff810109ca:	48 8b 4b 68          	mov    0x68(%rbx),%rcx
ffffffff810109ce:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff810109d3:	48 d3 e6             	shl    %cl,%rsi
ffffffff810109d6:	48 03 73 60          	add    0x60(%rbx),%rsi
ffffffff810109da:	e9 32 ff ff ff       	jmpq   ffffffff81010911 <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x3f>
            continue;
        }

        Mdb *node = mdb;

        unsigned d = node->dpth; bool demote = false;
ffffffff810109df:	0f b7 43 32          	movzwl 0x32(%rbx),%eax

            if (node->dpth == d + !self)
                demote = clamp (node->node_phys, p = b - mdb->node_base + mdb->node_phys, node->node_order, o) != ~0UL;

            if (demote && node->node_attr & attr) {
                Quota_guard qg(this->quota);
ffffffff810109e3:	4c 8d bd 08 03 00 00 	lea    0x308(%rbp),%r15
            continue;
        }

        Mdb *node = mdb;

        unsigned d = node->dpth; bool demote = false;
ffffffff810109ea:	49 89 dc             	mov    %rbx,%r12
ffffffff810109ed:	45 31 c0             	xor    %r8d,%r8d
ffffffff810109f0:	89 44 24 18          	mov    %eax,0x18(%rsp)

        for (Mdb *ptr;; node = ptr) {

            if (node->dpth == d + !self)
ffffffff810109f4:	8b 44 24 28          	mov    0x28(%rsp),%eax
ffffffff810109f8:	03 44 24 18          	add    0x18(%rsp),%eax
ffffffff810109fc:	89 44 24 1c          	mov    %eax,0x1c(%rsp)
ffffffff81010a00:	41 0f b7 44 24 32    	movzwl 0x32(%r12),%eax
ffffffff81010a06:	3b 44 24 1c          	cmp    0x1c(%rsp),%eax
ffffffff81010a0a:	75 33                	jne    ffffffff81010a3f <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x16d>
ffffffff81010a0c:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
ffffffff81010a11:	48 03 43 58          	add    0x58(%rbx),%rax
                demote = clamp (node->node_phys, p = b - mdb->node_base + mdb->node_phys, node->node_order, o) != ~0UL;
ffffffff81010a15:	48 8d 54 24 30       	lea    0x30(%rsp),%rdx
ffffffff81010a1a:	48 2b 43 60          	sub    0x60(%rbx),%rax
ffffffff81010a1e:	49 8b 4c 24 68       	mov    0x68(%r12),%rcx
ffffffff81010a23:	4d 89 f0             	mov    %r14,%r8
ffffffff81010a26:	49 8b 74 24 58       	mov    0x58(%r12),%rsi
ffffffff81010a2b:	48 89 ef             	mov    %rbp,%rdi
ffffffff81010a2e:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
ffffffff81010a33:	e8 44 f8 ff ff       	callq  ffffffff8101027c <_ZN2Pd5clampEmRmmm>
ffffffff81010a38:	48 ff c0             	inc    %rax
ffffffff81010a3b:	41 0f 95 c0          	setne  %r8b

            if (demote && node->node_attr & attr) {
ffffffff81010a3f:	45 84 c0             	test   %r8b,%r8b
ffffffff81010a42:	74 4a                	je     ffffffff81010a8e <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x1bc>
ffffffff81010a44:	4d 85 6c 24 70       	test   %r13,0x70(%r12)
ffffffff81010a49:	74 43                	je     ffffffff81010a8e <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x1bc>
ffffffff81010a4b:	48 8d 7c 24 40       	lea    0x40(%rsp),%rdi
ffffffff81010a50:	44 88 44 24 2f       	mov    %r8b,0x2f(%rsp)
ffffffff81010a55:	e8 98 f3 ff ff       	callq  ffffffff8100fdf2 <_ZN5QuotaC1Ev>
                Quota_guard qg(this->quota);
ffffffff81010a5a:	4c 89 7c 24 68       	mov    %r15,0x68(%rsp)
                static_cast<S *>(node->space)->update (qg, node, attr);
ffffffff81010a5f:	49 8b 7c 24 50       	mov    0x50(%r12),%rdi
ffffffff81010a64:	48 8d 74 24 40       	lea    0x40(%rsp),%rsi
ffffffff81010a69:	4c 89 e9             	mov    %r13,%rcx
ffffffff81010a6c:	4c 89 e2             	mov    %r12,%rdx
ffffffff81010a6f:	e8 e0 61 00 00       	callq  ffffffff81016c54 <_ZN9Space_pio6updateER5QuotaP3Mdbm>
                node->demote_node (attr);
ffffffff81010a74:	4c 89 ee             	mov    %r13,%rsi
ffffffff81010a77:	4c 89 e7             	mov    %r12,%rdi
ffffffff81010a7a:	e8 27 7f ff ff       	callq  ffffffff810089a6 <_ZN3Mdb11demote_nodeEm>
ffffffff81010a7f:	48 8d 7c 24 40       	lea    0x40(%rsp),%rdi
ffffffff81010a84:	e8 d3 f3 ff ff       	callq  ffffffff8100fe5c <_ZN11Quota_guardD1Ev>
ffffffff81010a89:	44 8a 44 24 2f       	mov    0x2f(%rsp),%r8b
            }

            ptr = ACCESS_ONCE (node->next);
ffffffff81010a8e:	49 8b 44 24 40       	mov    0x40(%r12),%rax

            if (ptr->dpth <= d)
ffffffff81010a93:	0f b7 50 32          	movzwl 0x32(%rax),%edx
ffffffff81010a97:	3b 54 24 18          	cmp    0x18(%rsp),%edx
ffffffff81010a9b:	76 08                	jbe    ffffffff81010aa5 <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x1d3>
ffffffff81010a9d:	49 89 c4             	mov    %rax,%r12
ffffffff81010aa0:	e9 5b ff ff ff       	jmpq   ffffffff81010a00 <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x12e>
                break;
        }

        Mdb *x = ACCESS_ONCE (node->next);
ffffffff81010aa5:	49 8b 54 24 40       	mov    0x40(%r12),%rdx
        assert (x->dpth <= d || (x->dpth == node->dpth + 1 && !(x->node_attr & attr)));
ffffffff81010aaa:	0f b7 4a 32          	movzwl 0x32(%rdx),%ecx
ffffffff81010aae:	3b 4c 24 18          	cmp    0x18(%rsp),%ecx
ffffffff81010ab2:	76 3a                	jbe    ffffffff81010aee <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x21c>
ffffffff81010ab4:	41 0f b7 44 24 32    	movzwl 0x32(%r12),%eax
ffffffff81010aba:	ff c0                	inc    %eax
ffffffff81010abc:	39 c1                	cmp    %eax,%ecx
ffffffff81010abe:	75 06                	jne    ffffffff81010ac6 <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x1f4>
ffffffff81010ac0:	4c 85 6a 70          	test   %r13,0x70(%rdx)
ffffffff81010ac4:	74 28                	je     ffffffff81010aee <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x21c>
ffffffff81010ac6:	49 c7 c0 00 01 02 81 	mov    $0xffffffff81020100,%r8
ffffffff81010acd:	b9 ad 00 00 00       	mov    $0xad,%ecx
ffffffff81010ad2:	48 c7 c2 e1 fd 01 81 	mov    $0xffffffff8101fde1,%rdx
ffffffff81010ad9:	48 c7 c6 91 fe 01 81 	mov    $0xffffffff8101fe91,%rsi
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81010ae0:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81010ae7:	31 c0                	xor    %eax,%eax
ffffffff81010ae9:	e8 62 14 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

        bool preempt = Cpu::preemption;
ffffffff81010aee:	44 8a 35 3b ec fe 3e 	mov    0x3efeec3b(%rip),%r14b        # ffffffffbffff730 <_ZN3Cpu10preemptionE>

        for (Mdb *ptr;; node = ptr) {

            if (preempt)
ffffffff81010af5:	45 84 f6             	test   %r14b,%r14b
ffffffff81010af8:	74 2d                	je     ffffffff81010b27 <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x255>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81010afa:	80 3d 2f ec fe 3e 00 	cmpb   $0x0,0x3efeec2f(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81010b01:	75 1c                	jne    ffffffff81010b1f <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x24d>
ffffffff81010b03:	49 c7 c0 50 02 02 81 	mov    $0xffffffff81020250,%r8
ffffffff81010b0a:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff81010b0f:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81010b16:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff81010b1d:	eb c1                	jmp    ffffffff81010ae0 <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x20e>

            asm volatile ("cli" : : : "memory");
ffffffff81010b1f:	fa                   	cli    
            preemption = false;
ffffffff81010b20:	c6 05 09 ec fe 3e 00 	movb   $0x0,0x3efeec09(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            if (node->remove_node() && static_cast<S *>(node->space)->tree_remove (node))
ffffffff81010b27:	4c 89 e7             	mov    %r12,%rdi
ffffffff81010b2a:	e8 17 7f ff ff       	callq  ffffffff81008a46 <_ZN3Mdb11remove_nodeEv>
ffffffff81010b2f:	84 c0                	test   %al,%al
ffffffff81010b31:	74 62                	je     ffffffff81010b95 <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x2c3>
ffffffff81010b33:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff81010b38:	4c 89 e7             	mov    %r12,%rdi
ffffffff81010b3b:	e8 9f f4 ff ff       	callq  ffffffff8100ffdf <_ZN5Space11tree_removeEP3MdbN3Avl5StateE>
ffffffff81010b40:	84 c0                	test   %al,%al
ffffffff81010b42:	74 51                	je     ffffffff81010b95 <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x2c3>
                Rcu::call (node);
ffffffff81010b44:	4d 85 e4             	test   %r12,%r12
ffffffff81010b47:	0f 84 e4 00 00 00    	je     ffffffff81010c31 <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x35f>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
ffffffff81010b4d:	49 8b 54 24 28       	mov    0x28(%r12),%rdx
ffffffff81010b52:	4d 8d 7c 24 18       	lea    0x18(%r12),%r15
ffffffff81010b57:	48 85 d2             	test   %rdx,%rdx
ffffffff81010b5a:	74 05                	je     ffffffff81010b61 <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x28f>
                e->pre_func(e);
ffffffff81010b5c:	4c 89 ff             	mov    %r15,%rdi
ffffffff81010b5f:	ff d2                	callq  *%rdx
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
ffffffff81010b61:	49 83 7c 24 18 00    	cmpq   $0x0,0x18(%r12)
ffffffff81010b67:	0f 84 9e 00 00 00    	je     ffffffff81010c0b <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x339>
                trace (0, "warning: rcu element already enqueued");
ffffffff81010b6d:	48 81 7c 24 20 00 d0 	cmpq   $0xffffffffbfffd000,0x20(%rsp)
ffffffff81010b74:	ff bf 
ffffffff81010b76:	8b 35 88 e4 fe 3e    	mov    0x3efee488(%rip),%esi        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81010b7c:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
ffffffff81010b83:	48 c7 c7 14 df 01 81 	mov    $0xffffffff8101df14,%rdi
ffffffff81010b8a:	48 0f 45 f0          	cmovne %rax,%rsi
ffffffff81010b8e:	31 c0                	xor    %eax,%eax
ffffffff81010b90:	e8 f7 14 ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>

            if (preempt)
ffffffff81010b95:	45 84 f6             	test   %r14b,%r14b
ffffffff81010b98:	74 30                	je     ffffffff81010bca <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x2f8>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81010b9a:	80 3d 8f eb fe 3e 00 	cmpb   $0x0,0x3efeeb8f(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81010ba1:	74 1f                	je     ffffffff81010bc2 <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x2f0>
ffffffff81010ba3:	49 c7 c0 20 02 02 81 	mov    $0xffffffff81020220,%r8
ffffffff81010baa:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff81010baf:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81010bb6:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff81010bbd:	e9 1e ff ff ff       	jmpq   ffffffff81010ae0 <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x20e>

            preemption = true;
ffffffff81010bc2:	c6 05 67 eb fe 3e 01 	movb   $0x1,0x3efeeb67(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81010bc9:	fb                   	sti    
                Cpu::preempt_enable();

            ptr = ACCESS_ONCE (node->prev);

            if (node->dpth <= d)
ffffffff81010bca:	41 0f b7 44 24 32    	movzwl 0x32(%r12),%eax
                Rcu::call (node);

            if (preempt)
                Cpu::preempt_enable();

            ptr = ACCESS_ONCE (node->prev);
ffffffff81010bd0:	49 8b 54 24 38       	mov    0x38(%r12),%rdx

            if (node->dpth <= d)
ffffffff81010bd5:	3b 44 24 18          	cmp    0x18(%rsp),%eax
ffffffff81010bd9:	76 08                	jbe    ffffffff81010be3 <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x311>
        Mdb *x = ACCESS_ONCE (node->next);
        assert (x->dpth <= d || (x->dpth == node->dpth + 1 && !(x->node_attr & attr)));

        bool preempt = Cpu::preemption;

        for (Mdb *ptr;; node = ptr) {
ffffffff81010bdb:	49 89 d4             	mov    %rdx,%r12
ffffffff81010bde:	e9 12 ff ff ff       	jmpq   ffffffff81010af5 <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x223>

            if (node->dpth <= d)
                break;
        }

        assert (node == mdb);
ffffffff81010be3:	49 39 dc             	cmp    %rbx,%r12
ffffffff81010be6:	0f 84 de fd ff ff    	je     ffffffff810109ca <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0xf8>
ffffffff81010bec:	49 c7 c0 00 01 02 81 	mov    $0xffffffff81020100,%r8
ffffffff81010bf3:	b9 c2 00 00 00       	mov    $0xc2,%ecx
ffffffff81010bf8:	48 c7 c2 e1 fd 01 81 	mov    $0xffffffff8101fde1,%rdx
ffffffff81010bff:	48 c7 c6 85 fe 01 81 	mov    $0xffffffff8101fe85,%rsi
ffffffff81010c06:	e9 d5 fe ff ff       	jmpq   ffffffff81010ae0 <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x20e>
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
ffffffff81010c0b:	48 8b 15 56 ec fe 3e 	mov    0x3efeec56(%rip),%rdx        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff81010c12:	4c 39 fa             	cmp    %r15,%rdx
ffffffff81010c15:	0f 84 52 ff ff ff    	je     ffffffff81010b6d <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x29b>
                trace (0, "warning: rcu element already enqueued");
                return;
            }

            count ++;
ffffffff81010c1b:	48 ff 05 4e ec fe 3e 	incq   0x3efeec4e(%rip)        # ffffffffbffff870 <_ZN3Rcu4nextE+0x10>

           *tail = e;
ffffffff81010c22:	4c 89 3a             	mov    %r15,(%rdx)
            tail = &e->next;
ffffffff81010c25:	4c 89 3d 3c ec fe 3e 	mov    %r15,0x3efeec3c(%rip)        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff81010c2c:	e9 64 ff ff ff       	jmpq   ffffffff81010b95 <_ZN2Pd6revokeI9Space_pioEEvmmmbb+0x2c3>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
ffffffff81010c31:	48 8b 04 25 10 00 00 	mov    0x10,%rax
ffffffff81010c38:	00 
ffffffff81010c39:	0f 0b                	ud2    
    }
}
ffffffff81010c3b:	48 83 c4 78          	add    $0x78,%rsp
ffffffff81010c3f:	5b                   	pop    %rbx
ffffffff81010c40:	5d                   	pop    %rbp
ffffffff81010c41:	41 5c                	pop    %r12
ffffffff81010c43:	41 5d                	pop    %r13
ffffffff81010c45:	41 5e                	pop    %r14
ffffffff81010c47:	41 5f                	pop    %r15
ffffffff81010c49:	c3                   	retq   

ffffffff81010c4a <_ZN2Pd6revokeI9Space_objEEvmmmbb>:

    return s;
}

template <typename S>
void Pd::revoke (mword const base, mword const ord, mword const attr, bool self, bool kim)
ffffffff81010c4a:	41 57                	push   %r15
ffffffff81010c4c:	41 56                	push   %r14

        unsigned d = node->dpth; bool demote = false;

        for (Mdb *ptr;; node = ptr) {

            if (node->dpth == d + !self)
ffffffff81010c4e:	41 83 f0 01          	xor    $0x1,%r8d

    return s;
}

template <typename S>
void Pd::revoke (mword const base, mword const ord, mword const attr, bool self, bool kim)
ffffffff81010c52:	41 55                	push   %r13
ffffffff81010c54:	41 54                	push   %r12

        unsigned d = node->dpth; bool demote = false;

        for (Mdb *ptr;; node = ptr) {

            if (node->dpth == d + !self)
ffffffff81010c56:	41 0f b6 c0          	movzbl %r8b,%eax

    return s;
}

template <typename S>
void Pd::revoke (mword const base, mword const ord, mword const attr, bool self, bool kim)
ffffffff81010c5a:	55                   	push   %rbp
ffffffff81010c5b:	53                   	push   %rbx
ffffffff81010c5c:	48 89 fd             	mov    %rdi,%rbp
ffffffff81010c5f:	49 89 cd             	mov    %rcx,%r13
ffffffff81010c62:	48 83 ec 78          	sub    $0x78,%rsp

        unsigned d = node->dpth; bool demote = false;

        for (Mdb *ptr;; node = ptr) {

            if (node->dpth == d + !self)
ffffffff81010c66:	89 44 24 28          	mov    %eax,0x28(%rsp)

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
                trace (0, "warning: rcu element already enqueued");
ffffffff81010c6a:	48 8d 44 24 3f       	lea    0x3f(%rsp),%rax

    return s;
}

template <typename S>
void Pd::revoke (mword const base, mword const ord, mword const attr, bool self, bool kim)
ffffffff81010c6f:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
ffffffff81010c74:	48 89 54 24 10       	mov    %rdx,0x10(%rsp)
ffffffff81010c79:	44 88 4c 24 2e       	mov    %r9b,0x2e(%rsp)
ffffffff81010c7e:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81010c84:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
{
    Mdb *mdb;
    for (mword addr = base; (mdb = S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {
ffffffff81010c89:	48 8d bd f8 02 00 00 	lea    0x2f8(%rbp),%rdi
ffffffff81010c90:	ba 01 00 00 00       	mov    $0x1,%edx
ffffffff81010c95:	e8 cc f1 ff ff       	callq  ffffffff8100fe66 <_ZN5Space11tree_lookupEmb>
ffffffff81010c9a:	48 85 c0             	test   %rax,%rax
ffffffff81010c9d:	48 89 c3             	mov    %rax,%rbx
ffffffff81010ca0:	0f 84 0d 03 00 00    	je     ffffffff81010fb3 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x369>

        mword o, p, b = base;
ffffffff81010ca6:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
        if ((o = clamp (mdb->node_base, b, mdb->node_order, ord)) == ~0UL)
ffffffff81010cab:	48 8b 4b 68          	mov    0x68(%rbx),%rcx
ffffffff81010caf:	48 8d 54 24 38       	lea    0x38(%rsp),%rdx
ffffffff81010cb4:	48 8b 73 60          	mov    0x60(%rbx),%rsi
ffffffff81010cb8:	4c 8b 44 24 10       	mov    0x10(%rsp),%r8
ffffffff81010cbd:	48 89 ef             	mov    %rbp,%rdi
void Pd::revoke (mword const base, mword const ord, mword const attr, bool self, bool kim)
{
    Mdb *mdb;
    for (mword addr = base; (mdb = S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {

        mword o, p, b = base;
ffffffff81010cc0:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
        if ((o = clamp (mdb->node_base, b, mdb->node_order, ord)) == ~0UL)
ffffffff81010cc5:	e8 b2 f5 ff ff       	callq  ffffffff8101027c <_ZN2Pd5clampEmRmmm>
ffffffff81010cca:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
ffffffff81010cce:	49 89 c6             	mov    %rax,%r14
ffffffff81010cd1:	0f 84 dc 02 00 00    	je     ffffffff81010fb3 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x369>
            break;

        /* keep in mapping database if requested and at least one child node exists */
        if (kim && (ACCESS_ONCE(mdb->next)->dpth > mdb->dpth)) {
ffffffff81010cd7:	80 7c 24 2e 00       	cmpb   $0x0,0x2e(%rsp)
ffffffff81010cdc:	74 79                	je     ffffffff81010d57 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x10d>
ffffffff81010cde:	48 8b 43 40          	mov    0x40(%rbx),%rax
ffffffff81010ce2:	66 8b 4b 32          	mov    0x32(%rbx),%cx
ffffffff81010ce6:	66 39 48 32          	cmp    %cx,0x32(%rax)
ffffffff81010cea:	76 6b                	jbe    ffffffff81010d57 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x10d>
ffffffff81010cec:	48 8d 7c 24 40       	lea    0x40(%rsp),%rdi
ffffffff81010cf1:	e8 fc f0 ff ff       	callq  ffffffff8100fdf2 <_ZN5QuotaC1Ev>
            Quota_guard qg(this->quota);
ffffffff81010cf6:	48 8d 85 08 03 00 00 	lea    0x308(%rbp),%rax
ffffffff81010cfd:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
            if (mdb->node_attr & 0x1f) {
ffffffff81010d02:	f6 43 70 1f          	testb  $0x1f,0x70(%rbx)
ffffffff81010d06:	74 23                	je     ffffffff81010d2b <_ZN2Pd6revokeI9Space_objEEvmmmbb+0xe1>
                static_cast<S *>(mdb->space)->update (qg, mdb, 0x1f);
ffffffff81010d08:	48 8b 7b 50          	mov    0x50(%rbx),%rdi
ffffffff81010d0c:	48 8d 74 24 40       	lea    0x40(%rsp),%rsi
ffffffff81010d11:	b9 1f 00 00 00       	mov    $0x1f,%ecx
ffffffff81010d16:	48 89 da             	mov    %rbx,%rdx
ffffffff81010d19:	e8 48 5c 00 00       	callq  ffffffff81016966 <_ZN9Space_obj6updateER5QuotaP3Mdbm>
                mdb->demote_node (0x1f);
ffffffff81010d1e:	be 1f 00 00 00       	mov    $0x1f,%esi
ffffffff81010d23:	48 89 df             	mov    %rbx,%rdi
ffffffff81010d26:	e8 7b 7c ff ff       	callq  ffffffff810089a6 <_ZN3Mdb11demote_nodeEm>
            }
            static_cast<S *>(mdb->space)->tree_remove (mdb, Avl::State::KIM);
ffffffff81010d2b:	48 89 df             	mov    %rbx,%rdi
ffffffff81010d2e:	be 02 00 00 00       	mov    $0x2,%esi
ffffffff81010d33:	e8 a7 f2 ff ff       	callq  ffffffff8100ffdf <_ZN5Space11tree_removeEP3MdbN3Avl5StateE>
            continue;
ffffffff81010d38:	48 8d 7c 24 40       	lea    0x40(%rsp),%rdi
ffffffff81010d3d:	e8 1a f1 ff ff       	callq  ffffffff8100fe5c <_ZN11Quota_guardD1Ev>

template <typename S>
void Pd::revoke (mword const base, mword const ord, mword const attr, bool self, bool kim)
{
    Mdb *mdb;
    for (mword addr = base; (mdb = S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {
ffffffff81010d42:	48 8b 4b 68          	mov    0x68(%rbx),%rcx
ffffffff81010d46:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff81010d4b:	48 d3 e6             	shl    %cl,%rsi
ffffffff81010d4e:	48 03 73 60          	add    0x60(%rbx),%rsi
ffffffff81010d52:	e9 32 ff ff ff       	jmpq   ffffffff81010c89 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x3f>
            continue;
        }

        Mdb *node = mdb;

        unsigned d = node->dpth; bool demote = false;
ffffffff81010d57:	0f b7 43 32          	movzwl 0x32(%rbx),%eax

            if (node->dpth == d + !self)
                demote = clamp (node->node_phys, p = b - mdb->node_base + mdb->node_phys, node->node_order, o) != ~0UL;

            if (demote && node->node_attr & attr) {
                Quota_guard qg(this->quota);
ffffffff81010d5b:	4c 8d bd 08 03 00 00 	lea    0x308(%rbp),%r15
            continue;
        }

        Mdb *node = mdb;

        unsigned d = node->dpth; bool demote = false;
ffffffff81010d62:	49 89 dc             	mov    %rbx,%r12
ffffffff81010d65:	45 31 c0             	xor    %r8d,%r8d
ffffffff81010d68:	89 44 24 18          	mov    %eax,0x18(%rsp)

        for (Mdb *ptr;; node = ptr) {

            if (node->dpth == d + !self)
ffffffff81010d6c:	8b 44 24 28          	mov    0x28(%rsp),%eax
ffffffff81010d70:	03 44 24 18          	add    0x18(%rsp),%eax
ffffffff81010d74:	89 44 24 1c          	mov    %eax,0x1c(%rsp)
ffffffff81010d78:	41 0f b7 44 24 32    	movzwl 0x32(%r12),%eax
ffffffff81010d7e:	3b 44 24 1c          	cmp    0x1c(%rsp),%eax
ffffffff81010d82:	75 33                	jne    ffffffff81010db7 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x16d>
ffffffff81010d84:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
ffffffff81010d89:	48 03 43 58          	add    0x58(%rbx),%rax
                demote = clamp (node->node_phys, p = b - mdb->node_base + mdb->node_phys, node->node_order, o) != ~0UL;
ffffffff81010d8d:	48 8d 54 24 30       	lea    0x30(%rsp),%rdx
ffffffff81010d92:	48 2b 43 60          	sub    0x60(%rbx),%rax
ffffffff81010d96:	49 8b 4c 24 68       	mov    0x68(%r12),%rcx
ffffffff81010d9b:	4d 89 f0             	mov    %r14,%r8
ffffffff81010d9e:	49 8b 74 24 58       	mov    0x58(%r12),%rsi
ffffffff81010da3:	48 89 ef             	mov    %rbp,%rdi
ffffffff81010da6:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
ffffffff81010dab:	e8 cc f4 ff ff       	callq  ffffffff8101027c <_ZN2Pd5clampEmRmmm>
ffffffff81010db0:	48 ff c0             	inc    %rax
ffffffff81010db3:	41 0f 95 c0          	setne  %r8b

            if (demote && node->node_attr & attr) {
ffffffff81010db7:	45 84 c0             	test   %r8b,%r8b
ffffffff81010dba:	74 4a                	je     ffffffff81010e06 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x1bc>
ffffffff81010dbc:	4d 85 6c 24 70       	test   %r13,0x70(%r12)
ffffffff81010dc1:	74 43                	je     ffffffff81010e06 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x1bc>
ffffffff81010dc3:	48 8d 7c 24 40       	lea    0x40(%rsp),%rdi
ffffffff81010dc8:	44 88 44 24 2f       	mov    %r8b,0x2f(%rsp)
ffffffff81010dcd:	e8 20 f0 ff ff       	callq  ffffffff8100fdf2 <_ZN5QuotaC1Ev>
                Quota_guard qg(this->quota);
ffffffff81010dd2:	4c 89 7c 24 68       	mov    %r15,0x68(%rsp)
                static_cast<S *>(node->space)->update (qg, node, attr);
ffffffff81010dd7:	49 8b 7c 24 50       	mov    0x50(%r12),%rdi
ffffffff81010ddc:	48 8d 74 24 40       	lea    0x40(%rsp),%rsi
ffffffff81010de1:	4c 89 e9             	mov    %r13,%rcx
ffffffff81010de4:	4c 89 e2             	mov    %r12,%rdx
ffffffff81010de7:	e8 7a 5b 00 00       	callq  ffffffff81016966 <_ZN9Space_obj6updateER5QuotaP3Mdbm>
                node->demote_node (attr);
ffffffff81010dec:	4c 89 ee             	mov    %r13,%rsi
ffffffff81010def:	4c 89 e7             	mov    %r12,%rdi
ffffffff81010df2:	e8 af 7b ff ff       	callq  ffffffff810089a6 <_ZN3Mdb11demote_nodeEm>
ffffffff81010df7:	48 8d 7c 24 40       	lea    0x40(%rsp),%rdi
ffffffff81010dfc:	e8 5b f0 ff ff       	callq  ffffffff8100fe5c <_ZN11Quota_guardD1Ev>
ffffffff81010e01:	44 8a 44 24 2f       	mov    0x2f(%rsp),%r8b
            }

            ptr = ACCESS_ONCE (node->next);
ffffffff81010e06:	49 8b 44 24 40       	mov    0x40(%r12),%rax

            if (ptr->dpth <= d)
ffffffff81010e0b:	0f b7 50 32          	movzwl 0x32(%rax),%edx
ffffffff81010e0f:	3b 54 24 18          	cmp    0x18(%rsp),%edx
ffffffff81010e13:	76 08                	jbe    ffffffff81010e1d <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x1d3>
ffffffff81010e15:	49 89 c4             	mov    %rax,%r12
ffffffff81010e18:	e9 5b ff ff ff       	jmpq   ffffffff81010d78 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x12e>
                break;
        }

        Mdb *x = ACCESS_ONCE (node->next);
ffffffff81010e1d:	49 8b 54 24 40       	mov    0x40(%r12),%rdx
        assert (x->dpth <= d || (x->dpth == node->dpth + 1 && !(x->node_attr & attr)));
ffffffff81010e22:	0f b7 4a 32          	movzwl 0x32(%rdx),%ecx
ffffffff81010e26:	3b 4c 24 18          	cmp    0x18(%rsp),%ecx
ffffffff81010e2a:	76 3a                	jbe    ffffffff81010e66 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x21c>
ffffffff81010e2c:	41 0f b7 44 24 32    	movzwl 0x32(%r12),%eax
ffffffff81010e32:	ff c0                	inc    %eax
ffffffff81010e34:	39 c1                	cmp    %eax,%ecx
ffffffff81010e36:	75 06                	jne    ffffffff81010e3e <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x1f4>
ffffffff81010e38:	4c 85 6a 70          	test   %r13,0x70(%rdx)
ffffffff81010e3c:	74 28                	je     ffffffff81010e66 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x21c>
ffffffff81010e3e:	49 c7 c0 80 00 02 81 	mov    $0xffffffff81020080,%r8
ffffffff81010e45:	b9 ad 00 00 00       	mov    $0xad,%ecx
ffffffff81010e4a:	48 c7 c2 e1 fd 01 81 	mov    $0xffffffff8101fde1,%rdx
ffffffff81010e51:	48 c7 c6 91 fe 01 81 	mov    $0xffffffff8101fe91,%rsi
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81010e58:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81010e5f:	31 c0                	xor    %eax,%eax
ffffffff81010e61:	e8 ea 10 ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

        bool preempt = Cpu::preemption;
ffffffff81010e66:	44 8a 35 c3 e8 fe 3e 	mov    0x3efee8c3(%rip),%r14b        # ffffffffbffff730 <_ZN3Cpu10preemptionE>

        for (Mdb *ptr;; node = ptr) {

            if (preempt)
ffffffff81010e6d:	45 84 f6             	test   %r14b,%r14b
ffffffff81010e70:	74 2d                	je     ffffffff81010e9f <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x255>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81010e72:	80 3d b7 e8 fe 3e 00 	cmpb   $0x0,0x3efee8b7(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81010e79:	75 1c                	jne    ffffffff81010e97 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x24d>
ffffffff81010e7b:	49 c7 c0 50 02 02 81 	mov    $0xffffffff81020250,%r8
ffffffff81010e82:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff81010e87:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81010e8e:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff81010e95:	eb c1                	jmp    ffffffff81010e58 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x20e>

            asm volatile ("cli" : : : "memory");
ffffffff81010e97:	fa                   	cli    
            preemption = false;
ffffffff81010e98:	c6 05 91 e8 fe 3e 00 	movb   $0x0,0x3efee891(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            if (node->remove_node() && static_cast<S *>(node->space)->tree_remove (node))
ffffffff81010e9f:	4c 89 e7             	mov    %r12,%rdi
ffffffff81010ea2:	e8 9f 7b ff ff       	callq  ffffffff81008a46 <_ZN3Mdb11remove_nodeEv>
ffffffff81010ea7:	84 c0                	test   %al,%al
ffffffff81010ea9:	74 62                	je     ffffffff81010f0d <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x2c3>
ffffffff81010eab:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff81010eb0:	4c 89 e7             	mov    %r12,%rdi
ffffffff81010eb3:	e8 27 f1 ff ff       	callq  ffffffff8100ffdf <_ZN5Space11tree_removeEP3MdbN3Avl5StateE>
ffffffff81010eb8:	84 c0                	test   %al,%al
ffffffff81010eba:	74 51                	je     ffffffff81010f0d <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x2c3>
                Rcu::call (node);
ffffffff81010ebc:	4d 85 e4             	test   %r12,%r12
ffffffff81010ebf:	0f 84 e4 00 00 00    	je     ffffffff81010fa9 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x35f>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
ffffffff81010ec5:	49 8b 54 24 28       	mov    0x28(%r12),%rdx
ffffffff81010eca:	4d 8d 7c 24 18       	lea    0x18(%r12),%r15
ffffffff81010ecf:	48 85 d2             	test   %rdx,%rdx
ffffffff81010ed2:	74 05                	je     ffffffff81010ed9 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x28f>
                e->pre_func(e);
ffffffff81010ed4:	4c 89 ff             	mov    %r15,%rdi
ffffffff81010ed7:	ff d2                	callq  *%rdx
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
ffffffff81010ed9:	49 83 7c 24 18 00    	cmpq   $0x0,0x18(%r12)
ffffffff81010edf:	0f 84 9e 00 00 00    	je     ffffffff81010f83 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x339>
                trace (0, "warning: rcu element already enqueued");
ffffffff81010ee5:	48 81 7c 24 20 00 d0 	cmpq   $0xffffffffbfffd000,0x20(%rsp)
ffffffff81010eec:	ff bf 
ffffffff81010eee:	8b 35 10 e1 fe 3e    	mov    0x3efee110(%rip),%esi        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81010ef4:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
ffffffff81010efb:	48 c7 c7 14 df 01 81 	mov    $0xffffffff8101df14,%rdi
ffffffff81010f02:	48 0f 45 f0          	cmovne %rax,%rsi
ffffffff81010f06:	31 c0                	xor    %eax,%eax
ffffffff81010f08:	e8 7f 11 ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>

            if (preempt)
ffffffff81010f0d:	45 84 f6             	test   %r14b,%r14b
ffffffff81010f10:	74 30                	je     ffffffff81010f42 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x2f8>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81010f12:	80 3d 17 e8 fe 3e 00 	cmpb   $0x0,0x3efee817(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81010f19:	74 1f                	je     ffffffff81010f3a <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x2f0>
ffffffff81010f1b:	49 c7 c0 20 02 02 81 	mov    $0xffffffff81020220,%r8
ffffffff81010f22:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff81010f27:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81010f2e:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff81010f35:	e9 1e ff ff ff       	jmpq   ffffffff81010e58 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x20e>

            preemption = true;
ffffffff81010f3a:	c6 05 ef e7 fe 3e 01 	movb   $0x1,0x3efee7ef(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81010f41:	fb                   	sti    
                Cpu::preempt_enable();

            ptr = ACCESS_ONCE (node->prev);

            if (node->dpth <= d)
ffffffff81010f42:	41 0f b7 44 24 32    	movzwl 0x32(%r12),%eax
                Rcu::call (node);

            if (preempt)
                Cpu::preempt_enable();

            ptr = ACCESS_ONCE (node->prev);
ffffffff81010f48:	49 8b 54 24 38       	mov    0x38(%r12),%rdx

            if (node->dpth <= d)
ffffffff81010f4d:	3b 44 24 18          	cmp    0x18(%rsp),%eax
ffffffff81010f51:	76 08                	jbe    ffffffff81010f5b <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x311>
        Mdb *x = ACCESS_ONCE (node->next);
        assert (x->dpth <= d || (x->dpth == node->dpth + 1 && !(x->node_attr & attr)));

        bool preempt = Cpu::preemption;

        for (Mdb *ptr;; node = ptr) {
ffffffff81010f53:	49 89 d4             	mov    %rdx,%r12
ffffffff81010f56:	e9 12 ff ff ff       	jmpq   ffffffff81010e6d <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x223>

            if (node->dpth <= d)
                break;
        }

        assert (node == mdb);
ffffffff81010f5b:	49 39 dc             	cmp    %rbx,%r12
ffffffff81010f5e:	0f 84 de fd ff ff    	je     ffffffff81010d42 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0xf8>
ffffffff81010f64:	49 c7 c0 80 00 02 81 	mov    $0xffffffff81020080,%r8
ffffffff81010f6b:	b9 c2 00 00 00       	mov    $0xc2,%ecx
ffffffff81010f70:	48 c7 c2 e1 fd 01 81 	mov    $0xffffffff8101fde1,%rdx
ffffffff81010f77:	48 c7 c6 85 fe 01 81 	mov    $0xffffffff8101fe85,%rsi
ffffffff81010f7e:	e9 d5 fe ff ff       	jmpq   ffffffff81010e58 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x20e>
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
ffffffff81010f83:	48 8b 15 de e8 fe 3e 	mov    0x3efee8de(%rip),%rdx        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff81010f8a:	4c 39 fa             	cmp    %r15,%rdx
ffffffff81010f8d:	0f 84 52 ff ff ff    	je     ffffffff81010ee5 <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x29b>
                trace (0, "warning: rcu element already enqueued");
                return;
            }

            count ++;
ffffffff81010f93:	48 ff 05 d6 e8 fe 3e 	incq   0x3efee8d6(%rip)        # ffffffffbffff870 <_ZN3Rcu4nextE+0x10>

           *tail = e;
ffffffff81010f9a:	4c 89 3a             	mov    %r15,(%rdx)
            tail = &e->next;
ffffffff81010f9d:	4c 89 3d c4 e8 fe 3e 	mov    %r15,0x3efee8c4(%rip)        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff81010fa4:	e9 64 ff ff ff       	jmpq   ffffffff81010f0d <_ZN2Pd6revokeI9Space_objEEvmmmbb+0x2c3>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
ffffffff81010fa9:	48 8b 04 25 10 00 00 	mov    0x10,%rax
ffffffff81010fb0:	00 
ffffffff81010fb1:	0f 0b                	ud2    
    }
}
ffffffff81010fb3:	48 83 c4 78          	add    $0x78,%rsp
ffffffff81010fb7:	5b                   	pop    %rbx
ffffffff81010fb8:	5d                   	pop    %rbp
ffffffff81010fb9:	41 5c                	pop    %r12
ffffffff81010fbb:	41 5d                	pop    %r13
ffffffff81010fbd:	41 5e                	pop    %r14
ffffffff81010fbf:	41 5f                	pop    %r15
ffffffff81010fc1:	c3                   	retq   

ffffffff81010fc2 <_ZN2Pd8pre_freeEP8Rcu_elem>:
        WARN_UNUSED_RESULT
        mword clamp (mword &, mword &, mword, mword, mword);

        static void pre_free (Rcu_elem * a)
        {
            Pd * pd = static_cast <Pd *>(a);
ffffffff81010fc2:	48 8d 47 e8          	lea    -0x18(%rdi),%rax
        mword clamp (mword,   mword &, mword, mword);

        WARN_UNUSED_RESULT
        mword clamp (mword &, mword &, mword, mword, mword);

        static void pre_free (Rcu_elem * a)
ffffffff81010fc6:	53                   	push   %rbx
        {
            Pd * pd = static_cast <Pd *>(a);
ffffffff81010fc7:	31 db                	xor    %ebx,%ebx
ffffffff81010fc9:	48 85 ff             	test   %rdi,%rdi

            Crd crd(Crd::MEM);
            pd->revoke<Space_mem>(crd.base(), crd.order(), crd.attr(), true, false);
ffffffff81010fcc:	41 b8 01 00 00 00    	mov    $0x1,%r8d
ffffffff81010fd2:	b9 1f 00 00 00       	mov    $0x1f,%ecx
        WARN_UNUSED_RESULT
        mword clamp (mword &, mword &, mword, mword, mword);

        static void pre_free (Rcu_elem * a)
        {
            Pd * pd = static_cast <Pd *>(a);
ffffffff81010fd7:	48 0f 45 d8          	cmovne %rax,%rbx

            Crd crd(Crd::MEM);
            pd->revoke<Space_mem>(crd.base(), crd.order(), crd.attr(), true, false);
ffffffff81010fdb:	ba 1f 00 00 00       	mov    $0x1f,%edx
ffffffff81010fe0:	45 31 c9             	xor    %r9d,%r9d
ffffffff81010fe3:	48 89 df             	mov    %rbx,%rdi
ffffffff81010fe6:	31 f6                	xor    %esi,%esi
ffffffff81010fe8:	e8 6d f5 ff ff       	callq  ffffffff8101055a <_ZN2Pd6revokeI9Space_memEEvmmmbb>

            crd = Crd(Crd::PIO);
            pd->revoke<Space_pio>(crd.base(), crd.order(), crd.attr(), true, false);
ffffffff81010fed:	48 89 df             	mov    %rbx,%rdi
ffffffff81010ff0:	45 31 c9             	xor    %r9d,%r9d
ffffffff81010ff3:	41 b8 01 00 00 00    	mov    $0x1,%r8d
ffffffff81010ff9:	b9 1f 00 00 00       	mov    $0x1f,%ecx
ffffffff81010ffe:	ba 1f 00 00 00       	mov    $0x1f,%edx
ffffffff81011003:	31 f6                	xor    %esi,%esi
ffffffff81011005:	e8 c8 f8 ff ff       	callq  ffffffff810108d2 <_ZN2Pd6revokeI9Space_pioEEvmmmbb>

            crd = Crd(Crd::OBJ);
            pd->revoke<Space_obj>(crd.base(), crd.order(), crd.attr(), true, false);
ffffffff8101100a:	48 89 df             	mov    %rbx,%rdi
ffffffff8101100d:	45 31 c9             	xor    %r9d,%r9d
ffffffff81011010:	41 b8 01 00 00 00    	mov    $0x1,%r8d
        }
ffffffff81011016:	5b                   	pop    %rbx

            crd = Crd(Crd::PIO);
            pd->revoke<Space_pio>(crd.base(), crd.order(), crd.attr(), true, false);

            crd = Crd(Crd::OBJ);
            pd->revoke<Space_obj>(crd.base(), crd.order(), crd.attr(), true, false);
ffffffff81011017:	b9 1f 00 00 00       	mov    $0x1f,%ecx
ffffffff8101101c:	ba 1f 00 00 00       	mov    $0x1f,%edx
ffffffff81011021:	31 f6                	xor    %esi,%esi
ffffffff81011023:	e9 22 fc ff ff       	jmpq   ffffffff81010c4a <_ZN2Pd6revokeI9Space_objEEvmmmbb>

ffffffff81011028 <_ZN2PdD1Ev>:
        if (d)
            *d-- = Xfer (crd, s->flags() | set_as_del);
    }
}

Pd::~Pd()
ffffffff81011028:	41 54                	push   %r12
ffffffff8101102a:	55                   	push   %rbp
{
    pre_free(this);

    Space_mem::hpt.clear(quota, Space_mem::hpt.dest_hpt, Space_mem::hpt.iter_hpt_lev);
    Space_mem::dpt.clear(quota);
    Space_mem::npt.clear(quota);
ffffffff8101102b:	31 ed                	xor    %ebp,%ebp
        if (d)
            *d-- = Xfer (crd, s->flags() | set_as_del);
    }
}

Pd::~Pd()
ffffffff8101102d:	53                   	push   %rbx
ffffffff8101102e:	48 89 fb             	mov    %rdi,%rbx
{
    pre_free(this);
ffffffff81011031:	48 8d 7f 18          	lea    0x18(%rdi),%rdi

    Space_mem::hpt.clear(quota, Space_mem::hpt.dest_hpt, Space_mem::hpt.iter_hpt_lev);
ffffffff81011035:	4c 8d a3 08 03 00 00 	lea    0x308(%rbx),%r12
    }
}

Pd::~Pd()
{
    pre_free(this);
ffffffff8101103c:	e8 81 ff ff ff       	callq  ffffffff81010fc2 <_ZN2Pd8pre_freeEP8Rcu_elem>

    Space_mem::hpt.clear(quota, Space_mem::hpt.dest_hpt, Space_mem::hpt.iter_hpt_lev);
ffffffff81011041:	48 8d bb a0 02 00 00 	lea    0x2a0(%rbx),%rdi
ffffffff81011048:	48 c7 c1 b8 fc 00 81 	mov    $0xffffffff8100fcb8,%rcx
ffffffff8101104f:	48 c7 c2 a2 fc 00 81 	mov    $0xffffffff8100fca2,%rdx
ffffffff81011056:	4c 89 e6             	mov    %r12,%rsi
ffffffff81011059:	e8 ec 1b 00 00       	callq  ffffffff81012c4a <_ZN3PteI3HptmLj4ELj9ELb0EE5clearER5QuotaPFbmmjEPFbjmE>
    Space_mem::dpt.clear(quota);
ffffffff8101105e:	48 8d bb a8 02 00 00 	lea    0x2a8(%rbx),%rdi
ffffffff81011065:	31 c9                	xor    %ecx,%ecx
ffffffff81011067:	31 d2                	xor    %edx,%edx
ffffffff81011069:	4c 89 e6             	mov    %r12,%rsi
ffffffff8101106c:	e8 23 14 00 00       	callq  ffffffff81012494 <_ZN3PteI3DptyLj4ELj9ELb1EE5clearER5QuotaPFbmmjEPFbjmE>
    Space_mem::npt.clear(quota);
ffffffff81011071:	48 8d bb b0 02 00 00 	lea    0x2b0(%rbx),%rdi
ffffffff81011078:	31 c9                	xor    %ecx,%ecx
ffffffff8101107a:	31 d2                	xor    %edx,%edx
ffffffff8101107c:	4c 89 e6             	mov    %r12,%rsi
ffffffff8101107f:	e8 c6 1b 00 00       	callq  ffffffff81012c4a <_ZN3PteI3HptmLj4ELj9ELb0EE5clearER5QuotaPFbmmjEPFbjmE>
    static void clr_feature(Feature f) {
        Atomic::clr_mask(hip()->api_flg, static_cast<typeof hip()->api_flg> (f));
    }

    static bool cpu_online(unsigned long cpu) {
        return cpu < NUM_CPU && hip()->cpu_desc[cpu].flags & 1;
ffffffff81011084:	f6 85 38 70 16 81 01 	testb  $0x1,-0x7ee98fc8(%rbp)
ffffffff8101108b:	75 3d                	jne    ffffffff810110ca <_ZN2PdD1Ev+0xa2>
ffffffff8101108d:	48 83 c5 08          	add    $0x8,%rbp
    for (unsigned cpu = 0; cpu < NUM_CPU; cpu++)
ffffffff81011091:	48 81 fd 00 02 00 00 	cmp    $0x200,%rbp
ffffffff81011098:	75 ea                	jne    ffffffff81011084 <_ZN2PdD1Ev+0x5c>
        }

        ALWAYS_INLINE
        inline ~Space_mem()
        {
            if (did == NO_PCID)
ffffffff8101109a:	48 8b 83 b8 02 00 00 	mov    0x2b8(%rbx),%rax
ffffffff810110a1:	48 83 f8 02          	cmp    $0x2,%rax
ffffffff810110a5:	0f 84 bd 00 00 00    	je     ffffffff81011168 <_ZN2PdD1Ev+0x140>
               return;

            mword i = did / (sizeof(did_c[0]) * 8);
ffffffff810110ab:	48 89 c2             	mov    %rax,%rdx
            mword b = did % (sizeof(did_c[0]) * 8);
ffffffff810110ae:	83 e0 3f             	and    $0x3f,%eax
        inline ~Space_mem()
        {
            if (did == NO_PCID)
               return;

            mword i = did / (sizeof(did_c[0]) * 8);
ffffffff810110b1:	48 c1 ea 06          	shr    $0x6,%rdx
            mword b = did % (sizeof(did_c[0]) * 8);

            assert (!((i == 0 && b == 0) || (i == 0 && b == 1)));
ffffffff810110b5:	48 89 c1             	mov    %rax,%rcx
ffffffff810110b8:	48 09 d1             	or     %rdx,%rcx
ffffffff810110bb:	74 2d                	je     ffffffff810110ea <_ZN2PdD1Ev+0xc2>
ffffffff810110bd:	48 83 f8 01          	cmp    $0x1,%rax
ffffffff810110c1:	75 4f                	jne    ffffffff81011112 <_ZN2PdD1Ev+0xea>
ffffffff810110c3:	48 85 d2             	test   %rdx,%rdx
ffffffff810110c6:	74 22                	je     ffffffff810110ea <_ZN2PdD1Ev+0xc2>
ffffffff810110c8:	eb 48                	jmp    ffffffff81011112 <_ZN2PdD1Ev+0xea>
ffffffff810110ca:	48 8d bc 2b a0 00 00 	lea    0xa0(%rbx,%rbp,1),%rdi
ffffffff810110d1:	00 
        if (Hip::cpu_online (cpu))
            Space_mem::loc[cpu].clear(quota, Space_mem::hpt.dest_loc, Space_mem::hpt.iter_loc_lev);
ffffffff810110d2:	48 c7 c1 01 fd 00 81 	mov    $0xffffffff8100fd01,%rcx
ffffffff810110d9:	48 c7 c2 e8 fc 00 81 	mov    $0xffffffff8100fce8,%rdx
ffffffff810110e0:	4c 89 e6             	mov    %r12,%rsi
ffffffff810110e3:	e8 62 1b 00 00       	callq  ffffffff81012c4a <_ZN3PteI3HptmLj4ELj9ELb0EE5clearER5QuotaPFbmmjEPFbjmE>
ffffffff810110e8:	eb a3                	jmp    ffffffff8101108d <_ZN2PdD1Ev+0x65>
ffffffff810110ea:	49 c7 c0 f0 ff 01 81 	mov    $0xffffffff8101fff0,%r8
ffffffff810110f1:	b9 64 00 00 00       	mov    $0x64,%ecx
ffffffff810110f6:	48 c7 c2 61 dd 01 81 	mov    $0xffffffff8101dd61,%rdx
ffffffff810110fd:	48 c7 c6 e6 fe 01 81 	mov    $0xffffffff8101fee6,%rsi
ffffffff81011104:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8101110b:	31 c0                	xor    %eax,%eax
            assert (i <= LAST_PCID);

            bool s = Atomic::test_clr_bit (did_c[i], b);
            assert(s);
ffffffff8101110d:	e8 3e 0e ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            mword i = did / (sizeof(did_c[0]) * 8);
            mword b = did % (sizeof(did_c[0]) * 8);

            assert (!((i == 0 && b == 0) || (i == 0 && b == 1)));
            assert (i <= LAST_PCID);
ffffffff81011112:	48 83 fa 3f          	cmp    $0x3f,%rdx
ffffffff81011116:	76 1c                	jbe    ffffffff81011134 <_ZN2PdD1Ev+0x10c>
ffffffff81011118:	49 c7 c0 f0 ff 01 81 	mov    $0xffffffff8101fff0,%r8
ffffffff8101111f:	b9 65 00 00 00       	mov    $0x65,%ecx
ffffffff81011124:	48 c7 c2 61 dd 01 81 	mov    $0xffffffff8101dd61,%rdx
ffffffff8101112b:	48 c7 c6 d7 fe 01 81 	mov    $0xffffffff8101fed7,%rsi
ffffffff81011132:	eb d0                	jmp    ffffffff81011104 <_ZN2PdD1Ev+0xdc>
        template <typename T>
        ALWAYS_INLINE
        static inline bool test_clr_bit (T &val, unsigned long bit)
        {
            bool ret;
            asm volatile ("lock; btr%z1 %2, %1; setc %0" : "=q" (ret), "+m" (val) : "ir" (bit) : "cc");
ffffffff81011134:	f0 48 0f b3 04 d5 c0 	lock btr %rax,-0x7ee9bf40(,%rdx,8)
ffffffff8101113b:	40 16 81 
ffffffff8101113e:	0f 92 c0             	setb   %al

            bool s = Atomic::test_clr_bit (did_c[i], b);
            assert(s);
ffffffff81011141:	84 c0                	test   %al,%al
ffffffff81011143:	75 23                	jne    ffffffff81011168 <_ZN2PdD1Ev+0x140>
ffffffff81011145:	49 c7 c0 f0 ff 01 81 	mov    $0xffffffff8101fff0,%r8
ffffffff8101114c:	b9 68 00 00 00       	mov    $0x68,%ecx
ffffffff81011151:	48 c7 c2 61 dd 01 81 	mov    $0xffffffff8101dd61,%rdx
ffffffff81011158:	48 c7 c6 84 04 02 81 	mov    $0xffffffff81020484,%rsi
ffffffff8101115f:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81011166:	eb a5                	jmp    ffffffff8101110d <_ZN2PdD1Ev+0xe5>
}
ffffffff81011168:	5b                   	pop    %rbx
ffffffff81011169:	5d                   	pop    %rbp
ffffffff8101116a:	41 5c                	pop    %r12
ffffffff8101116c:	c3                   	retq   

ffffffff8101116d <_ZN2Pd4freeEP8Rcu_elem>:
        }

        static void free (Rcu_elem * a) {
            Pd * pd = static_cast <Pd *>(a);
ffffffff8101116d:	48 8d 47 e8          	lea    -0x18(%rdi),%rax

            crd = Crd(Crd::OBJ);
            pd->revoke<Space_obj>(crd.base(), crd.order(), crd.attr(), true, false);
        }

        static void free (Rcu_elem * a) {
ffffffff81011171:	55                   	push   %rbp
ffffffff81011172:	53                   	push   %rbx
            Pd * pd = static_cast <Pd *>(a);
ffffffff81011173:	31 db                	xor    %ebx,%ebx

            crd = Crd(Crd::OBJ);
            pd->revoke<Space_obj>(crd.base(), crd.order(), crd.attr(), true, false);
        }

        static void free (Rcu_elem * a) {
ffffffff81011175:	56                   	push   %rsi
            Pd * pd = static_cast <Pd *>(a);
ffffffff81011176:	48 85 ff             	test   %rdi,%rdi
ffffffff81011179:	48 0f 45 d8          	cmovne %rax,%rbx
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff8101117d:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff81011180:	f0 0f c1 83 8c 00 00 	lock xadd %eax,0x8c(%rbx)
ffffffff81011187:	00 

            if (pd->del_ref()) {
ffffffff81011188:	ff c8                	dec    %eax
ffffffff8101118a:	75 7d                	jne    ffffffff81011209 <_ZN2Pd4freeEP8Rcu_elem+0x9c>
                assert (pd != Pd::current);
ffffffff8101118c:	48 3b 1d 7d de fe 3e 	cmp    0x3efede7d(%rip),%rbx        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81011193:	75 28                	jne    ffffffff810111bd <_ZN2Pd4freeEP8Rcu_elem+0x50>
ffffffff81011195:	49 c7 c0 50 00 02 81 	mov    $0xffffffff81020050,%r8
ffffffff8101119c:	b9 3a 00 00 00       	mov    $0x3a,%ecx
ffffffff810111a1:	48 c7 c2 c7 e6 01 81 	mov    $0xffffffff8101e6c7,%rdx
ffffffff810111a8:	48 c7 c6 12 ff 01 81 	mov    $0xffffffff8101ff12,%rsi
ffffffff810111af:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff810111b6:	31 c0                	xor    %eax,%eax
ffffffff810111b8:	e8 93 0d ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
                delete pd;
ffffffff810111bd:	48 85 db             	test   %rbx,%rbx
ffffffff810111c0:	74 47                	je     ffffffff81011209 <_ZN2Pd4freeEP8Rcu_elem+0x9c>
ffffffff810111c2:	48 89 df             	mov    %rbx,%rdi
ffffffff810111c5:	e8 5e fe ff ff       	callq  ffffffff81011028 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff810111ca:	48 8b 43 50          	mov    0x50(%rbx),%rax
ffffffff810111ce:	31 d2                	xor    %edx,%edx

            pd_del->quota.free_up(pd_to->quota);
ffffffff810111d0:	48 8d bb 08 03 00 00 	lea    0x308(%rbx),%rdi

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff810111d7:	48 8d 88 08 fd ff ff 	lea    -0x2f8(%rax),%rcx
ffffffff810111de:	48 85 c0             	test   %rax,%rax
ffffffff810111e1:	48 0f 45 d1          	cmovne %rcx,%rdx

            pd_del->quota.free_up(pd_to->quota);
ffffffff810111e5:	48 8d aa 08 03 00 00 	lea    0x308(%rdx),%rbp
ffffffff810111ec:	48 89 ee             	mov    %rbp,%rsi
ffffffff810111ef:	e8 d0 23 ff ff       	callq  ffffffff810035c4 <_ZN5Quota7free_upERS_>

            if (pd->del_ref()) {
                assert (pd != Pd::current);
                delete pd;
            }
        }
ffffffff810111f4:	59                   	pop    %rcx
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));

            pd_del->quota.free_up(pd_to->quota);

            cache.free (ptr, pd_to->quota);
ffffffff810111f5:	48 89 ea             	mov    %rbp,%rdx
ffffffff810111f8:	48 89 de             	mov    %rbx,%rsi
ffffffff810111fb:	48 c7 c7 d0 3f 16 81 	mov    $0xffffffff81163fd0,%rdi

            if (pd->del_ref()) {
                assert (pd != Pd::current);
                delete pd;
            }
        }
ffffffff81011202:	5b                   	pop    %rbx
ffffffff81011203:	5d                   	pop    %rbp
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));

            pd_del->quota.free_up(pd_to->quota);

            cache.free (ptr, pd_to->quota);
ffffffff81011204:	e9 61 48 00 00       	jmpq   ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>

            if (pd->del_ref()) {
                assert (pd != Pd::current);
                delete pd;
            }
        }
ffffffff81011209:	58                   	pop    %rax
ffffffff8101120a:	5b                   	pop    %rbx
ffffffff8101120b:	5d                   	pop    %rbp
ffffffff8101120c:	c3                   	retq   
ffffffff8101120d:	90                   	nop

ffffffff8101120e <_ZN2Pd7rev_crdE3Crdbbb>:
        shootdown();
}

void Pd::rev_crd (Crd crd, bool self, bool preempt, bool kim)
{
    if (preempt)
ffffffff8101120e:	84 c9                	test   %cl,%cl
    if (s)
        shootdown();
}

void Pd::rev_crd (Crd crd, bool self, bool preempt, bool kim)
{
ffffffff81011210:	55                   	push   %rbp
ffffffff81011211:	53                   	push   %rbx
ffffffff81011212:	41 89 d2             	mov    %edx,%r10d
ffffffff81011215:	41 51                	push   %r9
ffffffff81011217:	89 cd                	mov    %ecx,%ebp
    if (preempt)
ffffffff81011219:	74 30                	je     ffffffff8101124b <_ZN2Pd7rev_crdE3Crdbbb+0x3d>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8101121b:	80 3d 0e e5 fe 3e 00 	cmpb   $0x0,0x3efee50e(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81011222:	74 1f                	je     ffffffff81011243 <_ZN2Pd7rev_crdE3Crdbbb+0x35>
ffffffff81011224:	49 c7 c0 20 02 02 81 	mov    $0xffffffff81020220,%r8
ffffffff8101122b:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff81011230:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81011237:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff8101123e:	e9 ba 00 00 00       	jmpq   ffffffff810112fd <_ZN2Pd7rev_crdE3Crdbbb+0xef>

            preemption = true;
ffffffff81011243:	c6 05 e6 e4 fe 3e 01 	movb   $0x1,0x3efee4e6(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8101124a:	fb                   	sti    

        ALWAYS_INLINE
        inline Type type() const { return static_cast<Type>(val & 0x3); }
ffffffff8101124b:	89 f3                	mov    %esi,%ebx
ffffffff8101124d:	83 e3 03             	and    $0x3,%ebx
        Cpu::preempt_enable();

    switch (crd.type()) {
ffffffff81011250:	83 fb 02             	cmp    $0x2,%ebx
ffffffff81011253:	74 31                	je     ffffffff81011286 <_ZN2Pd7rev_crdE3Crdbbb+0x78>
ffffffff81011255:	83 fb 03             	cmp    $0x3,%ebx
ffffffff81011258:	74 53                	je     ffffffff810112ad <_ZN2Pd7rev_crdE3Crdbbb+0x9f>
ffffffff8101125a:	83 fb 01             	cmp    $0x1,%ebx
ffffffff8101125d:	75 76                	jne    ffffffff810112d5 <_ZN2Pd7rev_crdE3Crdbbb+0xc7>

        ALWAYS_INLINE
        inline unsigned attr() const { return val >> 2 & 0x1f; }
ffffffff8101125f:	48 89 f1             	mov    %rsi,%rcx

        ALWAYS_INLINE
        inline unsigned order() const { return val >> 7 & 0x1f; }
ffffffff81011262:	48 89 f2             	mov    %rsi,%rdx

        case Crd::MEM:
            trace (TRACE_REV, "REV MEM PD:%p B:%#010lx O:%#04x A:%#04x %s", this, crd.base(), crd.order(), crd.attr(), self ? "+" : "-");
            revoke<Space_mem>(crd.base(), crd.order(), crd.attr(), self, kim);
ffffffff81011265:	45 0f b6 c8          	movzbl %r8b,%r9d

        ALWAYS_INLINE
        inline Type type() const { return static_cast<Type>(val & 0x3); }

        ALWAYS_INLINE
        inline unsigned attr() const { return val >> 2 & 0x1f; }
ffffffff81011269:	48 c1 e9 02          	shr    $0x2,%rcx

        ALWAYS_INLINE
        inline unsigned order() const { return val >> 7 & 0x1f; }
ffffffff8101126d:	48 c1 ea 07          	shr    $0x7,%rdx

        ALWAYS_INLINE
        inline mword base() const { return val >> 12; }
ffffffff81011271:	48 c1 ee 0c          	shr    $0xc,%rsi
ffffffff81011275:	83 e1 1f             	and    $0x1f,%ecx
ffffffff81011278:	83 e2 1f             	and    $0x1f,%edx
ffffffff8101127b:	45 0f b6 c2          	movzbl %r10b,%r8d
ffffffff8101127f:	e8 d6 f2 ff ff       	callq  ffffffff8101055a <_ZN2Pd6revokeI9Space_memEEvmmmbb>
            break;
ffffffff81011284:	eb 4f                	jmp    ffffffff810112d5 <_ZN2Pd7rev_crdE3Crdbbb+0xc7>

        ALWAYS_INLINE
        inline Type type() const { return static_cast<Type>(val & 0x3); }

        ALWAYS_INLINE
        inline unsigned attr() const { return val >> 2 & 0x1f; }
ffffffff81011286:	48 89 f1             	mov    %rsi,%rcx

        ALWAYS_INLINE
        inline unsigned order() const { return val >> 7 & 0x1f; }
ffffffff81011289:	48 89 f2             	mov    %rsi,%rdx

        case Crd::PIO:
            trace (TRACE_REV, "REV I/O PD:%p B:%#010lx O:%#04x A:%#04x %s", this, crd.base(), crd.order(), crd.attr(), self ? "+" : "-");
            revoke<Space_pio>(crd.base(), crd.order(), crd.attr(), self, kim);
ffffffff8101128c:	45 0f b6 c8          	movzbl %r8b,%r9d

        ALWAYS_INLINE
        inline Type type() const { return static_cast<Type>(val & 0x3); }

        ALWAYS_INLINE
        inline unsigned attr() const { return val >> 2 & 0x1f; }
ffffffff81011290:	48 c1 e9 02          	shr    $0x2,%rcx

        ALWAYS_INLINE
        inline unsigned order() const { return val >> 7 & 0x1f; }
ffffffff81011294:	48 c1 ea 07          	shr    $0x7,%rdx

        ALWAYS_INLINE
        inline mword base() const { return val >> 12; }
ffffffff81011298:	48 c1 ee 0c          	shr    $0xc,%rsi
ffffffff8101129c:	83 e1 1f             	and    $0x1f,%ecx
ffffffff8101129f:	83 e2 1f             	and    $0x1f,%edx
ffffffff810112a2:	45 0f b6 c2          	movzbl %r10b,%r8d
ffffffff810112a6:	e8 27 f6 ff ff       	callq  ffffffff810108d2 <_ZN2Pd6revokeI9Space_pioEEvmmmbb>
            break;
ffffffff810112ab:	eb 28                	jmp    ffffffff810112d5 <_ZN2Pd7rev_crdE3Crdbbb+0xc7>

        ALWAYS_INLINE
        inline unsigned attr() const { return val >> 2 & 0x1f; }

        ALWAYS_INLINE
        inline unsigned order() const { return val >> 7 & 0x1f; }
ffffffff810112ad:	48 89 f0             	mov    %rsi,%rax

        ALWAYS_INLINE
        inline Type type() const { return static_cast<Type>(val & 0x3); }

        ALWAYS_INLINE
        inline unsigned attr() const { return val >> 2 & 0x1f; }
ffffffff810112b0:	48 89 f1             	mov    %rsi,%rcx

        case Crd::OBJ:
            trace (TRACE_REV, "REV OBJ PD:%p B:%#010lx O:%#04x A:%#04x %s", this, crd.base(), crd.order(), crd.attr(), self ? "+" : "-");
            revoke<Space_obj>(crd.base(), crd.order(), crd.attr(), self, kim);
ffffffff810112b3:	45 0f b6 c8          	movzbl %r8b,%r9d

        ALWAYS_INLINE
        inline unsigned order() const { return val >> 7 & 0x1f; }
ffffffff810112b7:	48 c1 e8 07          	shr    $0x7,%rax

        ALWAYS_INLINE
        inline Type type() const { return static_cast<Type>(val & 0x3); }

        ALWAYS_INLINE
        inline unsigned attr() const { return val >> 2 & 0x1f; }
ffffffff810112bb:	48 c1 e9 02          	shr    $0x2,%rcx

        ALWAYS_INLINE
        inline unsigned order() const { return val >> 7 & 0x1f; }

        ALWAYS_INLINE
        inline mword base() const { return val >> 12; }
ffffffff810112bf:	48 c1 ee 0c          	shr    $0xc,%rsi
ffffffff810112c3:	83 e0 1f             	and    $0x1f,%eax
ffffffff810112c6:	83 e1 1f             	and    $0x1f,%ecx
ffffffff810112c9:	45 0f b6 c2          	movzbl %r10b,%r8d
ffffffff810112cd:	48 89 c2             	mov    %rax,%rdx
ffffffff810112d0:	e8 75 f9 ff ff       	callq  ffffffff81010c4a <_ZN2Pd6revokeI9Space_objEEvmmmbb>
            break;
    }

    if (preempt)
ffffffff810112d5:	40 84 ed             	test   %bpl,%bpl
ffffffff810112d8:	74 39                	je     ffffffff81011313 <_ZN2Pd7rev_crdE3Crdbbb+0x105>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff810112da:	80 3d 4f e4 fe 3e 00 	cmpb   $0x0,0x3efee44f(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff810112e1:	75 28                	jne    ffffffff8101130b <_ZN2Pd7rev_crdE3Crdbbb+0xfd>
ffffffff810112e3:	49 c7 c0 50 02 02 81 	mov    $0xffffffff81020250,%r8
ffffffff810112ea:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff810112ef:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff810112f6:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff810112fd:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81011304:	31 c0                	xor    %eax,%eax
ffffffff81011306:	e8 45 0c ff ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            asm volatile ("cli" : : : "memory");
ffffffff8101130b:	fa                   	cli    
            preemption = false;
ffffffff8101130c:	c6 05 1d e4 fe 3e 00 	movb   $0x0,0x3efee41d(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
        Cpu::preempt_disable();

    if (crd.type() == Crd::MEM)
ffffffff81011313:	ff cb                	dec    %ebx
ffffffff81011315:	75 08                	jne    ffffffff8101131f <_ZN2Pd7rev_crdE3Crdbbb+0x111>
        shootdown();
}
ffffffff81011317:	5a                   	pop    %rdx
ffffffff81011318:	5b                   	pop    %rbx
ffffffff81011319:	5d                   	pop    %rbp

    if (preempt)
        Cpu::preempt_disable();

    if (crd.type() == Crd::MEM)
        shootdown();
ffffffff8101131a:	e9 5b 53 00 00       	jmpq   ffffffff8101667a <_ZN9Space_mem9shootdownEv>
}
ffffffff8101131f:	58                   	pop    %rax
ffffffff81011320:	5b                   	pop    %rbx
ffffffff81011321:	5d                   	pop    %rbp
ffffffff81011322:	c3                   	retq   
ffffffff81011323:	90                   	nop

ffffffff81011324 <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc>:

    Mdb::destroy (mdb, pd->quota);
}

template <typename S>
bool Pd::delegate (Pd *snd, mword const snd_base, mword const rcv_base, mword const ord, mword const attr, mword const sub, char const * deltype)
ffffffff81011324:	41 57                	push   %r15
ffffffff81011326:	41 56                	push   %r14
ffffffff81011328:	49 89 cf             	mov    %rcx,%r15
ffffffff8101132b:	41 55                	push   %r13
ffffffff8101132d:	41 54                	push   %r12
ffffffff8101132f:	49 89 fc             	mov    %rdi,%r12
ffffffff81011332:	55                   	push   %rbp
ffffffff81011333:	53                   	push   %rbx
ffffffff81011334:	49 89 d6             	mov    %rdx,%r14
ffffffff81011337:	4d 89 cd             	mov    %r9,%r13
ffffffff8101133a:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
ffffffff81011341:	48 8d 5c 24 50       	lea    0x50(%rsp),%rbx
ffffffff81011346:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
ffffffff8101134b:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
ffffffff81011350:	48 89 df             	mov    %rbx,%rdi
ffffffff81011353:	e8 9a ea ff ff       	callq  ffffffff8100fdf2 <_ZN5QuotaC1Ev>
{
    bool s = false;

    Quota_guard qg(this->quota);
ffffffff81011358:	49 8d 84 24 08 03 00 	lea    0x308(%r12),%rax
ffffffff8101135f:	00 

    Mdb *mdb;
    for (mword addr = snd_base; (mdb = snd->S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {
ffffffff81011360:	4c 89 f6             	mov    %r14,%rsi
}

template <typename S>
bool Pd::delegate (Pd *snd, mword const snd_base, mword const rcv_base, mword const ord, mword const attr, mword const sub, char const * deltype)
{
    bool s = false;
ffffffff81011363:	c6 44 24 27 00       	movb   $0x0,0x27(%rsp)
        bool insert_node (Mdb *, mword);
        void demote_node (mword);
        bool remove_node();

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
ffffffff81011368:	48 89 1c 24          	mov    %rbx,(%rsp)

    Quota_guard qg(this->quota);
ffffffff8101136c:	48 89 44 24 78       	mov    %rax,0x78(%rsp)
        }

        if (!node->insert_node (mdb, attr)) {
            S::tree_remove (node);
            Mdb::destroy (node, qg);
            trace (0, "overmap attempt %s - node - PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx SUB:%lx", deltype, snd, this, snd_base, rcv_base, ord, attr, sub);
ffffffff81011371:	48 8d 44 24 47       	lea    0x47(%rsp),%rax
ffffffff81011376:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8101137c:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    bool s = false;

    Quota_guard qg(this->quota);

    Mdb *mdb;
    for (mword addr = snd_base; (mdb = snd->S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {
ffffffff81011381:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
ffffffff81011386:	ba 01 00 00 00       	mov    $0x1,%edx
ffffffff8101138b:	48 8d b8 90 00 00 00 	lea    0x90(%rax),%rdi
ffffffff81011392:	e8 cf ea ff ff       	callq  ffffffff8100fe66 <_ZN5Space11tree_lookupEmb>
ffffffff81011397:	48 85 c0             	test   %rax,%rax
ffffffff8101139a:	48 89 c5             	mov    %rax,%rbp
ffffffff8101139d:	0f 84 4c 02 00 00    	je     ffffffff810115ef <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x2cb>

        mword o, b = snd_base;
        if ((o = clamp (mdb->node_base, b, mdb->node_order, ord)) == ~0UL)
ffffffff810113a3:	48 8b 4d 68          	mov    0x68(%rbp),%rcx
ffffffff810113a7:	48 8b 75 60          	mov    0x60(%rbp),%rsi
ffffffff810113ab:	48 8d 54 24 40       	lea    0x40(%rsp),%rdx
ffffffff810113b0:	4c 8b 44 24 18       	mov    0x18(%rsp),%r8
ffffffff810113b5:	4c 89 e7             	mov    %r12,%rdi
    Quota_guard qg(this->quota);

    Mdb *mdb;
    for (mword addr = snd_base; (mdb = snd->S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {

        mword o, b = snd_base;
ffffffff810113b8:	4c 89 74 24 40       	mov    %r14,0x40(%rsp)
        if ((o = clamp (mdb->node_base, b, mdb->node_order, ord)) == ~0UL)
ffffffff810113bd:	e8 ba ee ff ff       	callq  ffffffff8101027c <_ZN2Pd5clampEmRmmm>
ffffffff810113c2:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
ffffffff810113c6:	0f 84 23 02 00 00    	je     ffffffff810115ef <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x2cb>
            }
        }

        bool hit_limit(mword free_space = 0)
        {
             if (free_space > upli)
ffffffff810113cc:	49 8b 94 24 20 03 00 	mov    0x320(%r12),%rdx
ffffffff810113d3:	00 
ffffffff810113d4:	48 85 d2             	test   %rdx,%rdx
ffffffff810113d7:	0f 84 22 02 00 00    	je     ffffffff810115ff <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x2db>
                 return true;

             return usage() > upli - free_space;
ffffffff810113dd:	48 ff ca             	dec    %rdx
            break;

        if (quota.hit_limit(1)) {
ffffffff810113e0:	49 39 94 24 10 03 00 	cmp    %rdx,0x310(%r12)
ffffffff810113e7:	00 
ffffffff810113e8:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
ffffffff810113ed:	0f 87 0c 02 00 00    	ja     ffffffff810115ff <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x2db>
        static void shootdown();

        void init (Quota &quota, unsigned);

        ALWAYS_INLINE
        inline mword sticky_sub(mword s) { return s & 0x4; }
ffffffff810113f3:	48 8b 85 80 00 00 00 	mov    0x80(%rbp),%rax
ffffffff810113fa:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff810113fe:	48 c7 c7 80 38 16 81 	mov    $0xffffffff81163880,%rdi
ffffffff81011405:	83 e0 04             	and    $0x4,%eax
            Cpu::hazard |= HZD_OOM;
            return s;
        }

        Mdb *node = new (qg) Mdb (static_cast<S *>(this), free_mdb<S>, b - mdb->node_base + mdb->node_phys, b - snd_base + rcv_base, o, 0, mdb->node_type, S::sticky_sub(mdb->node_sub) | sub);
ffffffff81011408:	48 0b 84 24 c0 00 00 	or     0xc0(%rsp),%rax
ffffffff8101140f:	00 
ffffffff81011410:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
ffffffff81011415:	e8 14 45 00 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff8101141a:	48 8b 4c 24 40       	mov    0x40(%rsp),%rcx
ffffffff8101141f:	48 89 c3             	mov    %rax,%rbx
ffffffff81011422:	49 8d 84 24 90 00 00 	lea    0x90(%r12),%rax
ffffffff81011429:	00 
ffffffff8101142a:	48 c7 c2 08 fd 00 81 	mov    $0xffffffff8100fd08,%rdx
ffffffff81011431:	48 89 df             	mov    %rbx,%rdi
ffffffff81011434:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
ffffffff81011439:	50                   	push   %rax
ffffffff8101143a:	4d 8d 04 0f          	lea    (%r15,%rcx,1),%r8
ffffffff8101143e:	48 03 4d 58          	add    0x58(%rbp),%rcx
ffffffff81011442:	48 2b 4d 60          	sub    0x60(%rbp),%rcx
ffffffff81011446:	ff 74 24 38          	pushq  0x38(%rsp)
ffffffff8101144a:	ff 75 78             	pushq  0x78(%rbp)
ffffffff8101144d:	6a 00                	pushq  $0x0
ffffffff8101144f:	4d 29 f0             	sub    %r14,%r8
ffffffff81011452:	4c 8b 4c 24 58       	mov    0x58(%rsp),%r9
ffffffff81011457:	48 8b 74 24 28       	mov    0x28(%rsp),%rsi
ffffffff8101145c:	e8 7b 19 ff ff       	callq  ffffffff81002ddc <_ZN3MdbC1EP5SpacePFvP8Rcu_elemEmmmmmm>

        if (!S::tree_insert (node)) {
ffffffff81011461:	48 83 c4 20          	add    $0x20,%rsp
ffffffff81011465:	48 89 df             	mov    %rbx,%rdi
ffffffff81011468:	e8 cf ea ff ff       	callq  ffffffff8100ff3c <_ZN5Space11tree_insertEP3Mdb>
ffffffff8101146d:	84 c0                	test   %al,%al
ffffffff8101146f:	0f 85 81 00 00 00    	jne    ffffffff810114f6 <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x1d2>

        ALWAYS_INLINE
        static inline void destroy (Mdb *obj, Quota &quota) { obj->~Mdb(); cache.free (obj, quota); }
ffffffff81011475:	48 8b 14 24          	mov    (%rsp),%rdx
ffffffff81011479:	48 89 de             	mov    %rbx,%rsi
ffffffff8101147c:	48 c7 c7 80 38 16 81 	mov    $0xffffffff81163880,%rdi
ffffffff81011483:	e8 e2 45 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
ffffffff81011488:	4c 89 fe             	mov    %r15,%rsi
ffffffff8101148b:	48 03 74 24 40       	add    0x40(%rsp),%rsi
            Mdb::destroy (node, qg);

            Mdb * x = S::tree_lookup(b - snd_base + rcv_base);
ffffffff81011490:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
ffffffff81011495:	31 d2                	xor    %edx,%edx
ffffffff81011497:	4c 29 f6             	sub    %r14,%rsi
ffffffff8101149a:	e8 c7 e9 ff ff       	callq  ffffffff8100fe66 <_ZN5Space11tree_lookupEmb>
            if (!x || x->prnt != mdb || x->node_attr != attr)
ffffffff8101149f:	48 85 c0             	test   %rax,%rax
ffffffff810114a2:	74 10                	je     ffffffff810114b4 <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x190>
ffffffff810114a4:	48 39 68 48          	cmp    %rbp,0x48(%rax)
ffffffff810114a8:	75 0a                	jne    ffffffff810114b4 <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x190>
ffffffff810114aa:	4c 39 68 70          	cmp    %r13,0x70(%rax)
ffffffff810114ae:	0f 84 26 01 00 00    	je     ffffffff810115da <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x2b6>
                trace (0, "overmap attempt %s - tree - PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx SUB:%lx", deltype, snd, this, snd_base, rcv_base, ord, attr, sub);
ffffffff810114b4:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff810114b8:	8b 05 46 db fe 3e    	mov    0x3efedb46(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff810114be:	48 81 7c 24 28 00 d0 	cmpq   $0xffffffffbfffd000,0x28(%rsp)
ffffffff810114c5:	ff bf 
ffffffff810114c7:	4d 89 f1             	mov    %r14,%r9
ffffffff810114ca:	ff b4 24 c0 00 00 00 	pushq  0xc0(%rsp)
ffffffff810114d1:	4d 89 e0             	mov    %r12,%r8
ffffffff810114d4:	41 55                	push   %r13
ffffffff810114d6:	48 c7 c7 24 ff 01 81 	mov    $0xffffffff8101ff24,%rdi
ffffffff810114dd:	ff 74 24 28          	pushq  0x28(%rsp)
ffffffff810114e1:	41 57                	push   %r15
ffffffff810114e3:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
ffffffff810114e8:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff810114ec:	48 8b 94 24 e8 00 00 	mov    0xe8(%rsp),%rdx
ffffffff810114f3:	00 
ffffffff810114f4:	eb 72                	jmp    ffffffff81011568 <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x244>

            continue;
        }

        if (!node->insert_node (mdb, attr)) {
ffffffff810114f6:	4c 89 ea             	mov    %r13,%rdx
ffffffff810114f9:	48 89 ee             	mov    %rbp,%rsi
ffffffff810114fc:	48 89 df             	mov    %rbx,%rdi
ffffffff810114ff:	e8 aa 73 ff ff       	callq  ffffffff810088ae <_ZN3Mdb11insert_nodeEPS_m>
ffffffff81011504:	84 c0                	test   %al,%al
ffffffff81011506:	75 6d                	jne    ffffffff81011575 <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x251>
            S::tree_remove (node);
ffffffff81011508:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff8101150d:	48 89 df             	mov    %rbx,%rdi
ffffffff81011510:	e8 ca ea ff ff       	callq  ffffffff8100ffdf <_ZN5Space11tree_removeEP3MdbN3Avl5StateE>
ffffffff81011515:	48 8b 14 24          	mov    (%rsp),%rdx
ffffffff81011519:	48 89 de             	mov    %rbx,%rsi
ffffffff8101151c:	48 c7 c7 80 38 16 81 	mov    $0xffffffff81163880,%rdi
ffffffff81011523:	e8 42 45 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
            Mdb::destroy (node, qg);
            trace (0, "overmap attempt %s - node - PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx SUB:%lx", deltype, snd, this, snd_base, rcv_base, ord, attr, sub);
ffffffff81011528:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff8101152c:	8b 05 d2 da fe 3e    	mov    0x3efedad2(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81011532:	48 81 7c 24 28 00 d0 	cmpq   $0xffffffffbfffd000,0x28(%rsp)
ffffffff81011539:	ff bf 
ffffffff8101153b:	ff b4 24 c0 00 00 00 	pushq  0xc0(%rsp)
ffffffff81011542:	41 55                	push   %r13
ffffffff81011544:	4d 89 f1             	mov    %r14,%r9
ffffffff81011547:	ff 74 24 28          	pushq  0x28(%rsp)
ffffffff8101154b:	41 57                	push   %r15
ffffffff8101154d:	4d 89 e0             	mov    %r12,%r8
ffffffff81011550:	48 8b 4c 24 30       	mov    0x30(%rsp),%rcx
ffffffff81011555:	48 8b 94 24 e8 00 00 	mov    0xe8(%rsp),%rdx
ffffffff8101155c:	00 
ffffffff8101155d:	48 c7 c7 7f ff 01 81 	mov    $0xffffffff8101ff7f,%rdi
ffffffff81011564:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff81011568:	31 c0                	xor    %eax,%eax
ffffffff8101156a:	e8 1d 0b ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
            continue;
ffffffff8101156f:	48 83 c4 20          	add    $0x20,%rsp
ffffffff81011573:	eb 65                	jmp    ffffffff810115da <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x2b6>
        }

        s |= S::update (qg, node);
ffffffff81011575:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff81011579:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
ffffffff8101157e:	31 c9                	xor    %ecx,%ecx
ffffffff81011580:	48 89 da             	mov    %rbx,%rdx
ffffffff81011583:	e8 22 4b 00 00       	callq  ffffffff810160aa <_ZN9Space_mem6updateER11Quota_guardP3Mdbm>
ffffffff81011588:	08 44 24 27          	or     %al,0x27(%rsp)

        if (Cpu::hazard & HZD_OOM) {
ffffffff8101158c:	f6 05 6d da fe 3e 20 	testb  $0x20,0x3efeda6d(%rip)        # ffffffffbffff000 <_ZN3Cpu6hazardE>
ffffffff81011593:	74 45                	je     ffffffff810115da <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x2b6>
            S::update (qg, node, attr);
ffffffff81011595:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff81011599:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
ffffffff8101159e:	4c 89 e9             	mov    %r13,%rcx
ffffffff810115a1:	48 89 da             	mov    %rbx,%rdx
ffffffff810115a4:	e8 01 4b 00 00       	callq  ffffffff810160aa <_ZN9Space_mem6updateER11Quota_guardP3Mdbm>
            node->demote_node (attr);
ffffffff810115a9:	4c 89 ee             	mov    %r13,%rsi
ffffffff810115ac:	48 89 df             	mov    %rbx,%rdi
ffffffff810115af:	e8 f2 73 ff ff       	callq  ffffffff810089a6 <_ZN3Mdb11demote_nodeEm>
            if (node->remove_node() && S::tree_remove (node))
ffffffff810115b4:	48 89 df             	mov    %rbx,%rdi
ffffffff810115b7:	e8 8a 74 ff ff       	callq  ffffffff81008a46 <_ZN3Mdb11remove_nodeEv>
ffffffff810115bc:	84 c0                	test   %al,%al
ffffffff810115be:	0f 84 ba 00 00 00    	je     ffffffff8101167e <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x35a>
ffffffff810115c4:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff810115c9:	48 89 df             	mov    %rbx,%rdi
ffffffff810115cc:	e8 0e ea ff ff       	callq  ffffffff8100ffdf <_ZN5Space11tree_removeEP3MdbN3Avl5StateE>
ffffffff810115d1:	84 c0                	test   %al,%al
ffffffff810115d3:	75 33                	jne    ffffffff81011608 <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x2e4>
ffffffff810115d5:	e9 a4 00 00 00       	jmpq   ffffffff8101167e <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x35a>
    bool s = false;

    Quota_guard qg(this->quota);

    Mdb *mdb;
    for (mword addr = snd_base; (mdb = snd->S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {
ffffffff810115da:	48 8b 4d 68          	mov    0x68(%rbp),%rcx
ffffffff810115de:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff810115e3:	48 d3 e6             	shl    %cl,%rsi
ffffffff810115e6:	48 03 75 60          	add    0x60(%rbp),%rsi
ffffffff810115ea:	e9 92 fd ff ff       	jmpq   ffffffff81011381 <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x5d>
                Rcu::call (node);
            return s;
        }
    }

    if (!qg.check(0))
ffffffff810115ef:	48 8d 7c 24 50       	lea    0x50(%rsp),%rdi
ffffffff810115f4:	31 f6                	xor    %esi,%esi
ffffffff810115f6:	e8 1d e8 ff ff       	callq  ffffffff8100fe18 <_ZN11Quota_guard5checkEm>
ffffffff810115fb:	84 c0                	test   %al,%al
ffffffff810115fd:	75 7f                	jne    ffffffff8101167e <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x35a>
        Cpu::hazard |= HZD_OOM;
ffffffff810115ff:	83 0d fa d9 fe 3e 20 	orl    $0x20,0x3efed9fa(%rip)        # ffffffffbffff000 <_ZN3Cpu6hazardE>

    return s;
ffffffff81011606:	eb 76                	jmp    ffffffff8101167e <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x35a>

        if (Cpu::hazard & HZD_OOM) {
            S::update (qg, node, attr);
            node->demote_node (attr);
            if (node->remove_node() && S::tree_remove (node))
                Rcu::call (node);
ffffffff81011608:	48 85 db             	test   %rbx,%rbx
ffffffff8101160b:	74 67                	je     ffffffff81011674 <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x350>
ffffffff8101160d:	48 8b 43 28          	mov    0x28(%rbx),%rax
ffffffff81011611:	48 8d 6b 18          	lea    0x18(%rbx),%rbp
ffffffff81011615:	48 85 c0             	test   %rax,%rax
ffffffff81011618:	74 05                	je     ffffffff8101161f <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x2fb>
                e->pre_func(e);
ffffffff8101161a:	48 89 ef             	mov    %rbp,%rdi
ffffffff8101161d:	ff d0                	callq  *%rax
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
ffffffff8101161f:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
ffffffff81011624:	75 0c                	jne    ffffffff81011632 <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x30e>
ffffffff81011626:	48 8b 05 3b e2 fe 3e 	mov    0x3efee23b(%rip),%rax        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff8101162d:	48 39 e8             	cmp    %rbp,%rax
ffffffff81011630:	75 2f                	jne    ffffffff81011661 <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x33d>
                trace (0, "warning: rcu element already enqueued");
ffffffff81011632:	48 8d 44 24 47       	lea    0x47(%rsp),%rax
ffffffff81011637:	8b 15 c7 d9 fe 3e    	mov    0x3efed9c7(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8101163d:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81011641:	48 c7 c7 14 df 01 81 	mov    $0xffffffff8101df14,%rdi
ffffffff81011648:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8101164e:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff81011654:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff81011658:	31 c0                	xor    %eax,%eax
ffffffff8101165a:	e8 2d 0a ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff8101165f:	eb 1d                	jmp    ffffffff8101167e <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x35a>
                return;
            }

            count ++;
ffffffff81011661:	48 ff 05 08 e2 fe 3e 	incq   0x3efee208(%rip)        # ffffffffbffff870 <_ZN3Rcu4nextE+0x10>

           *tail = e;
ffffffff81011668:	48 89 28             	mov    %rbp,(%rax)
            tail = &e->next;
ffffffff8101166b:	48 89 2d f6 e1 fe 3e 	mov    %rbp,0x3efee1f6(%rip)        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
            return s;
ffffffff81011672:	eb 0a                	jmp    ffffffff8101167e <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc+0x35a>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
ffffffff81011674:	48 8b 04 25 10 00 00 	mov    0x10,%rax
ffffffff8101167b:	00 
ffffffff8101167c:	0f 0b                	ud2    
    }

    if (!qg.check(0))
        Cpu::hazard |= HZD_OOM;

    return s;
ffffffff8101167e:	48 8d 7c 24 50       	lea    0x50(%rsp),%rdi
ffffffff81011683:	e8 d4 e7 ff ff       	callq  ffffffff8100fe5c <_ZN11Quota_guardD1Ev>
}
ffffffff81011688:	8a 44 24 27          	mov    0x27(%rsp),%al
ffffffff8101168c:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
ffffffff81011693:	5b                   	pop    %rbx
ffffffff81011694:	5d                   	pop    %rbp
ffffffff81011695:	41 5c                	pop    %r12
ffffffff81011697:	41 5d                	pop    %r13
ffffffff81011699:	41 5e                	pop    %r14
ffffffff8101169b:	41 5f                	pop    %r15
ffffffff8101169d:	c3                   	retq   

ffffffff8101169e <_ZN2Pd14chunk_delegateEPS_mmmmm>:
    }

    crd = Crd (0);
}

bool Pd::chunk_delegate(Pd* pd, mword sb, mword rb, mword ord, mword a, mword sub) {
ffffffff8101169e:	41 57                	push   %r15
ffffffff810116a0:	41 56                	push   %r14
ffffffff810116a2:	49 89 f7             	mov    %rsi,%r15
ffffffff810116a5:	41 55                	push   %r13
ffffffff810116a7:	41 54                	push   %r12
ffffffff810116a9:	49 89 fe             	mov    %rdi,%r14
ffffffff810116ac:	55                   	push   %rbp
ffffffff810116ad:	53                   	push   %rbx
ffffffff810116ae:	49 89 d4             	mov    %rdx,%r12
ffffffff810116b1:	48 89 cd             	mov    %rcx,%rbp
ffffffff810116b4:	4c 89 cb             	mov    %r9,%rbx
ffffffff810116b7:	48 83 ec 18          	sub    $0x18,%rsp
ffffffff810116bb:	4c 8b 6c 24 50       	mov    0x50(%rsp),%r13
    if (ord < (sub & 2 ? 9 : 10)) {//if sub & 2 == 1: ept or npt mapping, else hpt mapping 
ffffffff810116c0:	4c 89 e8             	mov    %r13,%rax
ffffffff810116c3:	48 c1 e0 3e          	shl    $0x3e,%rax
ffffffff810116c7:	48 c1 f8 3f          	sar    $0x3f,%rax
ffffffff810116cb:	48 83 c0 0a          	add    $0xa,%rax
ffffffff810116cf:	49 39 c0             	cmp    %rax,%r8
ffffffff810116d2:	73 0e                	jae    ffffffff810116e2 <_ZN2Pd14chunk_delegateEPS_mmmmm+0x44>
        bool s = delegate<Space_mem>(pd, sb, rb, ord, a, sub, "MEM");
ffffffff810116d4:	68 da ff 01 81       	pushq  $0xffffffff8101ffda
ffffffff810116d9:	41 55                	push   %r13
ffffffff810116db:	e8 44 fc ff ff       	callq  ffffffff81011324 <_ZN2Pd8delegateI9Space_memEEbPS_mmmmmPKc>
ffffffff810116e0:	eb 49                	jmp    ffffffff8101172b <_ZN2Pd14chunk_delegateEPS_mmmmm+0x8d>
//        Console::print("s in chunk %d", s);
        return s;
    } else {
        ord--;
ffffffff810116e2:	49 8d 40 ff          	lea    -0x1(%r8),%rax
ffffffff810116e6:	48 89 04 24          	mov    %rax,(%rsp)
        uint32 trans = 1U << ord;
        bool chunk1 = chunk_delegate(pd, sb, rb, ord, a, sub);
ffffffff810116ea:	56                   	push   %rsi
ffffffff810116eb:	4c 89 fe             	mov    %r15,%rsi
ffffffff810116ee:	41 55                	push   %r13
ffffffff810116f0:	4c 8b 44 24 10       	mov    0x10(%rsp),%r8
ffffffff810116f5:	e8 a4 ff ff ff       	callq  ffffffff8101169e <_ZN2Pd14chunk_delegateEPS_mmmmm>
        bool chunk2 = chunk_delegate(pd, sb + trans, rb + trans, ord, a, sub);
ffffffff810116fa:	8a 4c 24 10          	mov    0x10(%rsp),%cl
ffffffff810116fe:	ba 01 00 00 00       	mov    $0x1,%edx
ffffffff81011703:	4c 8b 44 24 10       	mov    0x10(%rsp),%r8
ffffffff81011708:	49 89 d9             	mov    %rbx,%r9
ffffffff8101170b:	4c 89 fe             	mov    %r15,%rsi
ffffffff8101170e:	4c 89 f7             	mov    %r14,%rdi
//        Console::print("s in chunk %d", s);
        return s;
    } else {
        ord--;
        uint32 trans = 1U << ord;
        bool chunk1 = chunk_delegate(pd, sb, rb, ord, a, sub);
ffffffff81011711:	88 44 24 1f          	mov    %al,0x1f(%rsp)
        bool chunk2 = chunk_delegate(pd, sb + trans, rb + trans, ord, a, sub);
ffffffff81011715:	4c 89 2c 24          	mov    %r13,(%rsp)
ffffffff81011719:	d3 e2                	shl    %cl,%edx
ffffffff8101171b:	48 8d 0c 2a          	lea    (%rdx,%rbp,1),%rcx
ffffffff8101171f:	4c 01 e2             	add    %r12,%rdx
ffffffff81011722:	e8 77 ff ff ff       	callq  ffffffff8101169e <_ZN2Pd14chunk_delegateEPS_mmmmm>
//        Console::print("chunk1 %d chunk1 %d", chunk1, chunk2);
        /*TODO
         * We must later handle when some succeed and other fail */
        return ( chunk1 || chunk2); // because delegate return 0 if ok
ffffffff81011727:	0a 44 24 1f          	or     0x1f(%rsp),%al
ffffffff8101172b:	5a                   	pop    %rdx
ffffffff8101172c:	59                   	pop    %rcx
    }
}
ffffffff8101172d:	48 83 c4 18          	add    $0x18,%rsp
ffffffff81011731:	5b                   	pop    %rbx
ffffffff81011732:	5d                   	pop    %rbp
ffffffff81011733:	41 5c                	pop    %r12
ffffffff81011735:	41 5d                	pop    %r13
ffffffff81011737:	41 5e                	pop    %r14
ffffffff81011739:	41 5f                	pop    %r15
ffffffff8101173b:	c3                   	retq   

ffffffff8101173c <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc>:

    Mdb::destroy (mdb, pd->quota);
}

template <typename S>
bool Pd::delegate (Pd *snd, mword const snd_base, mword const rcv_base, mword const ord, mword const attr, mword const sub, char const * deltype)
ffffffff8101173c:	41 57                	push   %r15
ffffffff8101173e:	41 56                	push   %r14
ffffffff81011740:	49 89 cf             	mov    %rcx,%r15
ffffffff81011743:	41 55                	push   %r13
ffffffff81011745:	41 54                	push   %r12
ffffffff81011747:	49 89 fc             	mov    %rdi,%r12
ffffffff8101174a:	55                   	push   %rbp
ffffffff8101174b:	53                   	push   %rbx
ffffffff8101174c:	49 89 d6             	mov    %rdx,%r14
ffffffff8101174f:	4d 89 cd             	mov    %r9,%r13
ffffffff81011752:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
        Quota q;
        Quota &r;

    public:

        Quota_guard(Quota &ref) : q(), r(ref) { }
ffffffff81011759:	48 8d 5c 24 50       	lea    0x50(%rsp),%rbx
ffffffff8101175e:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
ffffffff81011763:	4c 89 44 24 20       	mov    %r8,0x20(%rsp)
ffffffff81011768:	48 89 df             	mov    %rbx,%rdi
ffffffff8101176b:	e8 82 e6 ff ff       	callq  ffffffff8100fdf2 <_ZN5QuotaC1Ev>
{
    bool s = false;

    Quota_guard qg(this->quota);
ffffffff81011770:	49 8d 84 24 08 03 00 	lea    0x308(%r12),%rax
ffffffff81011777:	00 

    Mdb *mdb;
    for (mword addr = snd_base; (mdb = snd->S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {
ffffffff81011778:	4c 89 f6             	mov    %r14,%rsi
}

template <typename S>
bool Pd::delegate (Pd *snd, mword const snd_base, mword const rcv_base, mword const ord, mword const attr, mword const sub, char const * deltype)
{
    bool s = false;
ffffffff8101177b:	c6 44 24 2f 00       	movb   $0x0,0x2f(%rsp)
        bool insert_node (Mdb *, mword);
        void demote_node (mword);
        bool remove_node();

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
ffffffff81011780:	48 89 5c 24 08       	mov    %rbx,0x8(%rsp)

    Quota_guard qg(this->quota);
ffffffff81011785:	48 89 44 24 78       	mov    %rax,0x78(%rsp)
        }

        if (!node->insert_node (mdb, attr)) {
            S::tree_remove (node);
            Mdb::destroy (node, qg);
            trace (0, "overmap attempt %s - node - PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx SUB:%lx", deltype, snd, this, snd_base, rcv_base, ord, attr, sub);
ffffffff8101178a:	48 8d 44 24 47       	lea    0x47(%rsp),%rax
ffffffff8101178f:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81011795:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    bool s = false;

    Quota_guard qg(this->quota);

    Mdb *mdb;
    for (mword addr = snd_base; (mdb = snd->S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {
ffffffff8101179a:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
ffffffff8101179f:	ba 01 00 00 00       	mov    $0x1,%edx
ffffffff810117a4:	48 8d b8 d8 02 00 00 	lea    0x2d8(%rax),%rdi
ffffffff810117ab:	e8 b6 e6 ff ff       	callq  ffffffff8100fe66 <_ZN5Space11tree_lookupEmb>
ffffffff810117b0:	48 85 c0             	test   %rax,%rax
ffffffff810117b3:	48 89 c5             	mov    %rax,%rbp
ffffffff810117b6:	0f 84 3d 02 00 00    	je     ffffffff810119f9 <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x2bd>

        mword o, b = snd_base;
        if ((o = clamp (mdb->node_base, b, mdb->node_order, ord)) == ~0UL)
ffffffff810117bc:	48 8b 4d 68          	mov    0x68(%rbp),%rcx
ffffffff810117c0:	48 8b 75 60          	mov    0x60(%rbp),%rsi
ffffffff810117c4:	48 8d 54 24 40       	lea    0x40(%rsp),%rdx
ffffffff810117c9:	4c 8b 44 24 20       	mov    0x20(%rsp),%r8
ffffffff810117ce:	4c 89 e7             	mov    %r12,%rdi
    Quota_guard qg(this->quota);

    Mdb *mdb;
    for (mword addr = snd_base; (mdb = snd->S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {

        mword o, b = snd_base;
ffffffff810117d1:	4c 89 74 24 40       	mov    %r14,0x40(%rsp)
        if ((o = clamp (mdb->node_base, b, mdb->node_order, ord)) == ~0UL)
ffffffff810117d6:	e8 a1 ea ff ff       	callq  ffffffff8101027c <_ZN2Pd5clampEmRmmm>
ffffffff810117db:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
ffffffff810117df:	0f 84 14 02 00 00    	je     ffffffff810119f9 <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x2bd>
            }
        }

        bool hit_limit(mword free_space = 0)
        {
             if (free_space > upli)
ffffffff810117e5:	49 8b 94 24 20 03 00 	mov    0x320(%r12),%rdx
ffffffff810117ec:	00 
ffffffff810117ed:	48 85 d2             	test   %rdx,%rdx
ffffffff810117f0:	0f 84 13 02 00 00    	je     ffffffff81011a09 <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x2cd>
                 return true;

             return usage() > upli - free_space;
ffffffff810117f6:	48 ff ca             	dec    %rdx
            break;

        if (quota.hit_limit(1)) {
ffffffff810117f9:	49 39 94 24 10 03 00 	cmp    %rdx,0x310(%r12)
ffffffff81011800:	00 
ffffffff81011801:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
ffffffff81011806:	0f 87 fd 01 00 00    	ja     ffffffff81011a09 <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x2cd>
ffffffff8101180c:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
ffffffff81011811:	48 c7 c7 80 38 16 81 	mov    $0xffffffff81163880,%rdi
ffffffff81011818:	e8 11 41 00 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
            Cpu::hazard |= HZD_OOM;
            return s;
        }

        Mdb *node = new (qg) Mdb (static_cast<S *>(this), free_mdb<S>, b - mdb->node_base + mdb->node_phys, b - snd_base + rcv_base, o, 0, mdb->node_type, S::sticky_sub(mdb->node_sub) | sub);
ffffffff8101181d:	48 8b 4c 24 40       	mov    0x40(%rsp),%rcx
ffffffff81011822:	48 89 c3             	mov    %rax,%rbx
ffffffff81011825:	49 8d 84 24 d8 02 00 	lea    0x2d8(%r12),%rax
ffffffff8101182c:	00 
ffffffff8101182d:	48 c7 c2 56 fd 00 81 	mov    $0xffffffff8100fd56,%rdx
ffffffff81011834:	48 89 df             	mov    %rbx,%rdi
ffffffff81011837:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
ffffffff8101183c:	50                   	push   %rax
ffffffff8101183d:	4d 8d 04 0f          	lea    (%r15,%rcx,1),%r8
ffffffff81011841:	48 03 4d 58          	add    0x58(%rbp),%rcx
ffffffff81011845:	48 2b 4d 60          	sub    0x60(%rbp),%rcx
ffffffff81011849:	ff b4 24 c8 00 00 00 	pushq  0xc8(%rsp)
ffffffff81011850:	ff 75 78             	pushq  0x78(%rbp)
ffffffff81011853:	6a 00                	pushq  $0x0
ffffffff81011855:	4d 29 f0             	sub    %r14,%r8
ffffffff81011858:	4c 8b 4c 24 58       	mov    0x58(%rsp),%r9
ffffffff8101185d:	48 8b 74 24 30       	mov    0x30(%rsp),%rsi
ffffffff81011862:	e8 75 15 ff ff       	callq  ffffffff81002ddc <_ZN3MdbC1EP5SpacePFvP8Rcu_elemEmmmmmm>

        if (!S::tree_insert (node)) {
ffffffff81011867:	48 83 c4 20          	add    $0x20,%rsp
ffffffff8101186b:	48 89 df             	mov    %rbx,%rdi
ffffffff8101186e:	e8 c9 e6 ff ff       	callq  ffffffff8100ff3c <_ZN5Space11tree_insertEP3Mdb>
ffffffff81011873:	84 c0                	test   %al,%al
ffffffff81011875:	0f 85 82 00 00 00    	jne    ffffffff810118fd <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x1c1>

        ALWAYS_INLINE
        static inline void destroy (Mdb *obj, Quota &quota) { obj->~Mdb(); cache.free (obj, quota); }
ffffffff8101187b:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
ffffffff81011880:	48 89 de             	mov    %rbx,%rsi
ffffffff81011883:	48 c7 c7 80 38 16 81 	mov    $0xffffffff81163880,%rdi
ffffffff8101188a:	e8 db 41 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
ffffffff8101188f:	4c 89 fe             	mov    %r15,%rsi
ffffffff81011892:	48 03 74 24 40       	add    0x40(%rsp),%rsi
            Mdb::destroy (node, qg);

            Mdb * x = S::tree_lookup(b - snd_base + rcv_base);
ffffffff81011897:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
ffffffff8101189c:	31 d2                	xor    %edx,%edx
ffffffff8101189e:	4c 29 f6             	sub    %r14,%rsi
ffffffff810118a1:	e8 c0 e5 ff ff       	callq  ffffffff8100fe66 <_ZN5Space11tree_lookupEmb>
            if (!x || x->prnt != mdb || x->node_attr != attr)
ffffffff810118a6:	48 85 c0             	test   %rax,%rax
ffffffff810118a9:	74 10                	je     ffffffff810118bb <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x17f>
ffffffff810118ab:	48 39 68 48          	cmp    %rbp,0x48(%rax)
ffffffff810118af:	75 0a                	jne    ffffffff810118bb <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x17f>
ffffffff810118b1:	4c 39 68 70          	cmp    %r13,0x70(%rax)
ffffffff810118b5:	0f 84 29 01 00 00    	je     ffffffff810119e4 <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x2a8>
                trace (0, "overmap attempt %s - tree - PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx SUB:%lx", deltype, snd, this, snd_base, rcv_base, ord, attr, sub);
ffffffff810118bb:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff810118bf:	8b 05 3f d7 fe 3e    	mov    0x3efed73f(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff810118c5:	48 81 7c 24 30 00 d0 	cmpq   $0xffffffffbfffd000,0x30(%rsp)
ffffffff810118cc:	ff bf 
ffffffff810118ce:	4d 89 f1             	mov    %r14,%r9
ffffffff810118d1:	ff b4 24 c0 00 00 00 	pushq  0xc0(%rsp)
ffffffff810118d8:	4d 89 e0             	mov    %r12,%r8
ffffffff810118db:	41 55                	push   %r13
ffffffff810118dd:	48 c7 c7 24 ff 01 81 	mov    $0xffffffff8101ff24,%rdi
ffffffff810118e4:	ff 74 24 30          	pushq  0x30(%rsp)
ffffffff810118e8:	41 57                	push   %r15
ffffffff810118ea:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
ffffffff810118ef:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff810118f3:	48 8b 94 24 e8 00 00 	mov    0xe8(%rsp),%rdx
ffffffff810118fa:	00 
ffffffff810118fb:	eb 73                	jmp    ffffffff81011970 <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x234>

            continue;
        }

        if (!node->insert_node (mdb, attr)) {
ffffffff810118fd:	4c 89 ea             	mov    %r13,%rdx
ffffffff81011900:	48 89 ee             	mov    %rbp,%rsi
ffffffff81011903:	48 89 df             	mov    %rbx,%rdi
ffffffff81011906:	e8 a3 6f ff ff       	callq  ffffffff810088ae <_ZN3Mdb11insert_nodeEPS_m>
ffffffff8101190b:	84 c0                	test   %al,%al
ffffffff8101190d:	75 6e                	jne    ffffffff8101197d <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x241>
            S::tree_remove (node);
ffffffff8101190f:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff81011914:	48 89 df             	mov    %rbx,%rdi
ffffffff81011917:	e8 c3 e6 ff ff       	callq  ffffffff8100ffdf <_ZN5Space11tree_removeEP3MdbN3Avl5StateE>
ffffffff8101191c:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
ffffffff81011921:	48 89 de             	mov    %rbx,%rsi
ffffffff81011924:	48 c7 c7 80 38 16 81 	mov    $0xffffffff81163880,%rdi
ffffffff8101192b:	e8 3a 41 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
            Mdb::destroy (node, qg);
            trace (0, "overmap attempt %s - node - PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx SUB:%lx", deltype, snd, this, snd_base, rcv_base, ord, attr, sub);
ffffffff81011930:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81011934:	8b 05 ca d6 fe 3e    	mov    0x3efed6ca(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8101193a:	48 81 7c 24 30 00 d0 	cmpq   $0xffffffffbfffd000,0x30(%rsp)
ffffffff81011941:	ff bf 
ffffffff81011943:	ff b4 24 c0 00 00 00 	pushq  0xc0(%rsp)
ffffffff8101194a:	41 55                	push   %r13
ffffffff8101194c:	4d 89 f1             	mov    %r14,%r9
ffffffff8101194f:	ff 74 24 30          	pushq  0x30(%rsp)
ffffffff81011953:	41 57                	push   %r15
ffffffff81011955:	4d 89 e0             	mov    %r12,%r8
ffffffff81011958:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
ffffffff8101195d:	48 8b 94 24 e8 00 00 	mov    0xe8(%rsp),%rdx
ffffffff81011964:	00 
ffffffff81011965:	48 c7 c7 7f ff 01 81 	mov    $0xffffffff8101ff7f,%rdi
ffffffff8101196c:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff81011970:	31 c0                	xor    %eax,%eax
ffffffff81011972:	e8 15 07 ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
            continue;
ffffffff81011977:	48 83 c4 20          	add    $0x20,%rsp
ffffffff8101197b:	eb 67                	jmp    ffffffff810119e4 <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x2a8>
        }

        s |= S::update (qg, node);
ffffffff8101197d:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
ffffffff81011982:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
ffffffff81011987:	31 c9                	xor    %ecx,%ecx
ffffffff81011989:	48 89 da             	mov    %rbx,%rdx
ffffffff8101198c:	e8 c3 52 00 00       	callq  ffffffff81016c54 <_ZN9Space_pio6updateER5QuotaP3Mdbm>
ffffffff81011991:	08 44 24 2f          	or     %al,0x2f(%rsp)

        if (Cpu::hazard & HZD_OOM) {
ffffffff81011995:	f6 05 64 d6 fe 3e 20 	testb  $0x20,0x3efed664(%rip)        # ffffffffbffff000 <_ZN3Cpu6hazardE>
ffffffff8101199c:	74 46                	je     ffffffff810119e4 <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x2a8>
            S::update (qg, node, attr);
ffffffff8101199e:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
ffffffff810119a3:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
ffffffff810119a8:	4c 89 e9             	mov    %r13,%rcx
ffffffff810119ab:	48 89 da             	mov    %rbx,%rdx
ffffffff810119ae:	e8 a1 52 00 00       	callq  ffffffff81016c54 <_ZN9Space_pio6updateER5QuotaP3Mdbm>
            node->demote_node (attr);
ffffffff810119b3:	4c 89 ee             	mov    %r13,%rsi
ffffffff810119b6:	48 89 df             	mov    %rbx,%rdi
ffffffff810119b9:	e8 e8 6f ff ff       	callq  ffffffff810089a6 <_ZN3Mdb11demote_nodeEm>
            if (node->remove_node() && S::tree_remove (node))
ffffffff810119be:	48 89 df             	mov    %rbx,%rdi
ffffffff810119c1:	e8 80 70 ff ff       	callq  ffffffff81008a46 <_ZN3Mdb11remove_nodeEv>
ffffffff810119c6:	84 c0                	test   %al,%al
ffffffff810119c8:	0f 84 ba 00 00 00    	je     ffffffff81011a88 <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x34c>
ffffffff810119ce:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff810119d3:	48 89 df             	mov    %rbx,%rdi
ffffffff810119d6:	e8 04 e6 ff ff       	callq  ffffffff8100ffdf <_ZN5Space11tree_removeEP3MdbN3Avl5StateE>
ffffffff810119db:	84 c0                	test   %al,%al
ffffffff810119dd:	75 33                	jne    ffffffff81011a12 <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x2d6>
ffffffff810119df:	e9 a4 00 00 00       	jmpq   ffffffff81011a88 <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x34c>
    bool s = false;

    Quota_guard qg(this->quota);

    Mdb *mdb;
    for (mword addr = snd_base; (mdb = snd->S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {
ffffffff810119e4:	48 8b 4d 68          	mov    0x68(%rbp),%rcx
ffffffff810119e8:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff810119ed:	48 d3 e6             	shl    %cl,%rsi
ffffffff810119f0:	48 03 75 60          	add    0x60(%rbp),%rsi
ffffffff810119f4:	e9 a1 fd ff ff       	jmpq   ffffffff8101179a <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x5e>
                Rcu::call (node);
            return s;
        }
    }

    if (!qg.check(0))
ffffffff810119f9:	48 8d 7c 24 50       	lea    0x50(%rsp),%rdi
ffffffff810119fe:	31 f6                	xor    %esi,%esi
ffffffff81011a00:	e8 13 e4 ff ff       	callq  ffffffff8100fe18 <_ZN11Quota_guard5checkEm>
ffffffff81011a05:	84 c0                	test   %al,%al
ffffffff81011a07:	75 7f                	jne    ffffffff81011a88 <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x34c>
        Cpu::hazard |= HZD_OOM;
ffffffff81011a09:	83 0d f0 d5 fe 3e 20 	orl    $0x20,0x3efed5f0(%rip)        # ffffffffbffff000 <_ZN3Cpu6hazardE>

    return s;
ffffffff81011a10:	eb 76                	jmp    ffffffff81011a88 <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x34c>

        if (Cpu::hazard & HZD_OOM) {
            S::update (qg, node, attr);
            node->demote_node (attr);
            if (node->remove_node() && S::tree_remove (node))
                Rcu::call (node);
ffffffff81011a12:	48 85 db             	test   %rbx,%rbx
ffffffff81011a15:	74 67                	je     ffffffff81011a7e <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x342>
ffffffff81011a17:	48 8b 43 28          	mov    0x28(%rbx),%rax
ffffffff81011a1b:	48 8d 6b 18          	lea    0x18(%rbx),%rbp
ffffffff81011a1f:	48 85 c0             	test   %rax,%rax
ffffffff81011a22:	74 05                	je     ffffffff81011a29 <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x2ed>
                e->pre_func(e);
ffffffff81011a24:	48 89 ef             	mov    %rbp,%rdi
ffffffff81011a27:	ff d0                	callq  *%rax
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
ffffffff81011a29:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
ffffffff81011a2e:	75 0c                	jne    ffffffff81011a3c <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x300>
ffffffff81011a30:	48 8b 05 31 de fe 3e 	mov    0x3efede31(%rip),%rax        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff81011a37:	48 39 e8             	cmp    %rbp,%rax
ffffffff81011a3a:	75 2f                	jne    ffffffff81011a6b <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x32f>
                trace (0, "warning: rcu element already enqueued");
ffffffff81011a3c:	48 8d 44 24 47       	lea    0x47(%rsp),%rax
ffffffff81011a41:	8b 15 bd d5 fe 3e    	mov    0x3efed5bd(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81011a47:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81011a4b:	48 c7 c7 14 df 01 81 	mov    $0xffffffff8101df14,%rdi
ffffffff81011a52:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81011a58:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff81011a5e:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff81011a62:	31 c0                	xor    %eax,%eax
ffffffff81011a64:	e8 23 06 ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff81011a69:	eb 1d                	jmp    ffffffff81011a88 <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x34c>
                return;
            }

            count ++;
ffffffff81011a6b:	48 ff 05 fe dd fe 3e 	incq   0x3efeddfe(%rip)        # ffffffffbffff870 <_ZN3Rcu4nextE+0x10>

           *tail = e;
ffffffff81011a72:	48 89 28             	mov    %rbp,(%rax)
            tail = &e->next;
ffffffff81011a75:	48 89 2d ec dd fe 3e 	mov    %rbp,0x3efeddec(%rip)        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
            return s;
ffffffff81011a7c:	eb 0a                	jmp    ffffffff81011a88 <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc+0x34c>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
ffffffff81011a7e:	48 8b 04 25 10 00 00 	mov    0x10,%rax
ffffffff81011a85:	00 
ffffffff81011a86:	0f 0b                	ud2    
    }

    if (!qg.check(0))
        Cpu::hazard |= HZD_OOM;

    return s;
ffffffff81011a88:	48 8d 7c 24 50       	lea    0x50(%rsp),%rdi
ffffffff81011a8d:	e8 ca e3 ff ff       	callq  ffffffff8100fe5c <_ZN11Quota_guardD1Ev>
}
ffffffff81011a92:	8a 44 24 2f          	mov    0x2f(%rsp),%al
ffffffff81011a96:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
ffffffff81011a9d:	5b                   	pop    %rbx
ffffffff81011a9e:	5d                   	pop    %rbp
ffffffff81011a9f:	41 5c                	pop    %r12
ffffffff81011aa1:	41 5d                	pop    %r13
ffffffff81011aa3:	41 5e                	pop    %r14
ffffffff81011aa5:	41 5f                	pop    %r15
ffffffff81011aa7:	c3                   	retq   

ffffffff81011aa8 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc>:

    Mdb::destroy (mdb, pd->quota);
}

template <typename S>
bool Pd::delegate (Pd *snd, mword const snd_base, mword const rcv_base, mword const ord, mword const attr, mword const sub, char const * deltype)
ffffffff81011aa8:	41 57                	push   %r15
ffffffff81011aaa:	41 56                	push   %r14
ffffffff81011aac:	49 89 cf             	mov    %rcx,%r15
ffffffff81011aaf:	41 55                	push   %r13
ffffffff81011ab1:	41 54                	push   %r12
ffffffff81011ab3:	49 89 fc             	mov    %rdi,%r12
ffffffff81011ab6:	55                   	push   %rbp
ffffffff81011ab7:	53                   	push   %rbx
ffffffff81011ab8:	49 89 d6             	mov    %rdx,%r14
ffffffff81011abb:	4d 89 cd             	mov    %r9,%r13
ffffffff81011abe:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
        Quota q;
        Quota &r;

    public:

        Quota_guard(Quota &ref) : q(), r(ref) { }
ffffffff81011ac5:	48 8d 5c 24 50       	lea    0x50(%rsp),%rbx
ffffffff81011aca:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
ffffffff81011acf:	4c 89 44 24 20       	mov    %r8,0x20(%rsp)
ffffffff81011ad4:	48 89 df             	mov    %rbx,%rdi
ffffffff81011ad7:	e8 16 e3 ff ff       	callq  ffffffff8100fdf2 <_ZN5QuotaC1Ev>
{
    bool s = false;

    Quota_guard qg(this->quota);
ffffffff81011adc:	49 8d 84 24 08 03 00 	lea    0x308(%r12),%rax
ffffffff81011ae3:	00 

    Mdb *mdb;
    for (mword addr = snd_base; (mdb = snd->S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {
ffffffff81011ae4:	4c 89 f6             	mov    %r14,%rsi
}

template <typename S>
bool Pd::delegate (Pd *snd, mword const snd_base, mword const rcv_base, mword const ord, mword const attr, mword const sub, char const * deltype)
{
    bool s = false;
ffffffff81011ae7:	c6 44 24 2f 00       	movb   $0x0,0x2f(%rsp)
        bool insert_node (Mdb *, mword);
        void demote_node (mword);
        bool remove_node();

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
ffffffff81011aec:	48 89 5c 24 08       	mov    %rbx,0x8(%rsp)

    Quota_guard qg(this->quota);
ffffffff81011af1:	48 89 44 24 78       	mov    %rax,0x78(%rsp)
        }

        if (!node->insert_node (mdb, attr)) {
            S::tree_remove (node);
            Mdb::destroy (node, qg);
            trace (0, "overmap attempt %s - node - PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx SUB:%lx", deltype, snd, this, snd_base, rcv_base, ord, attr, sub);
ffffffff81011af6:	48 8d 44 24 47       	lea    0x47(%rsp),%rax
ffffffff81011afb:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81011b01:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
    bool s = false;

    Quota_guard qg(this->quota);

    Mdb *mdb;
    for (mword addr = snd_base; (mdb = snd->S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {
ffffffff81011b06:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
ffffffff81011b0b:	ba 01 00 00 00       	mov    $0x1,%edx
ffffffff81011b10:	48 8d b8 f8 02 00 00 	lea    0x2f8(%rax),%rdi
ffffffff81011b17:	e8 4a e3 ff ff       	callq  ffffffff8100fe66 <_ZN5Space11tree_lookupEmb>
ffffffff81011b1c:	48 85 c0             	test   %rax,%rax
ffffffff81011b1f:	48 89 c5             	mov    %rax,%rbp
ffffffff81011b22:	0f 84 3d 02 00 00    	je     ffffffff81011d65 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x2bd>

        mword o, b = snd_base;
        if ((o = clamp (mdb->node_base, b, mdb->node_order, ord)) == ~0UL)
ffffffff81011b28:	48 8b 4d 68          	mov    0x68(%rbp),%rcx
ffffffff81011b2c:	48 8b 75 60          	mov    0x60(%rbp),%rsi
ffffffff81011b30:	48 8d 54 24 40       	lea    0x40(%rsp),%rdx
ffffffff81011b35:	4c 8b 44 24 20       	mov    0x20(%rsp),%r8
ffffffff81011b3a:	4c 89 e7             	mov    %r12,%rdi
    Quota_guard qg(this->quota);

    Mdb *mdb;
    for (mword addr = snd_base; (mdb = snd->S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {

        mword o, b = snd_base;
ffffffff81011b3d:	4c 89 74 24 40       	mov    %r14,0x40(%rsp)
        if ((o = clamp (mdb->node_base, b, mdb->node_order, ord)) == ~0UL)
ffffffff81011b42:	e8 35 e7 ff ff       	callq  ffffffff8101027c <_ZN2Pd5clampEmRmmm>
ffffffff81011b47:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
ffffffff81011b4b:	0f 84 14 02 00 00    	je     ffffffff81011d65 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x2bd>
            }
        }

        bool hit_limit(mword free_space = 0)
        {
             if (free_space > upli)
ffffffff81011b51:	49 8b 94 24 20 03 00 	mov    0x320(%r12),%rdx
ffffffff81011b58:	00 
ffffffff81011b59:	48 85 d2             	test   %rdx,%rdx
ffffffff81011b5c:	0f 84 13 02 00 00    	je     ffffffff81011d75 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x2cd>
                 return true;

             return usage() > upli - free_space;
ffffffff81011b62:	48 ff ca             	dec    %rdx
            break;

        if (quota.hit_limit(1)) {
ffffffff81011b65:	49 39 94 24 10 03 00 	cmp    %rdx,0x310(%r12)
ffffffff81011b6c:	00 
ffffffff81011b6d:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
ffffffff81011b72:	0f 87 fd 01 00 00    	ja     ffffffff81011d75 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x2cd>
ffffffff81011b78:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
ffffffff81011b7d:	48 c7 c7 80 38 16 81 	mov    $0xffffffff81163880,%rdi
ffffffff81011b84:	e8 a5 3d 00 00       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
            Cpu::hazard |= HZD_OOM;
            return s;
        }

        Mdb *node = new (qg) Mdb (static_cast<S *>(this), free_mdb<S>, b - mdb->node_base + mdb->node_phys, b - snd_base + rcv_base, o, 0, mdb->node_type, S::sticky_sub(mdb->node_sub) | sub);
ffffffff81011b89:	48 8b 4c 24 40       	mov    0x40(%rsp),%rcx
ffffffff81011b8e:	48 89 c3             	mov    %rax,%rbx
ffffffff81011b91:	49 8d 84 24 f8 02 00 	lea    0x2f8(%r12),%rax
ffffffff81011b98:	00 
ffffffff81011b99:	48 c7 c2 a4 fd 00 81 	mov    $0xffffffff8100fda4,%rdx
ffffffff81011ba0:	48 89 df             	mov    %rbx,%rdi
ffffffff81011ba3:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
ffffffff81011ba8:	50                   	push   %rax
ffffffff81011ba9:	4d 8d 04 0f          	lea    (%r15,%rcx,1),%r8
ffffffff81011bad:	48 03 4d 58          	add    0x58(%rbp),%rcx
ffffffff81011bb1:	48 2b 4d 60          	sub    0x60(%rbp),%rcx
ffffffff81011bb5:	ff b4 24 c8 00 00 00 	pushq  0xc8(%rsp)
ffffffff81011bbc:	ff 75 78             	pushq  0x78(%rbp)
ffffffff81011bbf:	6a 00                	pushq  $0x0
ffffffff81011bc1:	4d 29 f0             	sub    %r14,%r8
ffffffff81011bc4:	4c 8b 4c 24 58       	mov    0x58(%rsp),%r9
ffffffff81011bc9:	48 8b 74 24 30       	mov    0x30(%rsp),%rsi
ffffffff81011bce:	e8 09 12 ff ff       	callq  ffffffff81002ddc <_ZN3MdbC1EP5SpacePFvP8Rcu_elemEmmmmmm>

        if (!S::tree_insert (node)) {
ffffffff81011bd3:	48 83 c4 20          	add    $0x20,%rsp
ffffffff81011bd7:	48 89 df             	mov    %rbx,%rdi
ffffffff81011bda:	e8 5d e3 ff ff       	callq  ffffffff8100ff3c <_ZN5Space11tree_insertEP3Mdb>
ffffffff81011bdf:	84 c0                	test   %al,%al
ffffffff81011be1:	0f 85 82 00 00 00    	jne    ffffffff81011c69 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x1c1>

        ALWAYS_INLINE
        static inline void destroy (Mdb *obj, Quota &quota) { obj->~Mdb(); cache.free (obj, quota); }
ffffffff81011be7:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
ffffffff81011bec:	48 89 de             	mov    %rbx,%rsi
ffffffff81011bef:	48 c7 c7 80 38 16 81 	mov    $0xffffffff81163880,%rdi
ffffffff81011bf6:	e8 6f 3e 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
ffffffff81011bfb:	4c 89 fe             	mov    %r15,%rsi
ffffffff81011bfe:	48 03 74 24 40       	add    0x40(%rsp),%rsi
            Mdb::destroy (node, qg);

            Mdb * x = S::tree_lookup(b - snd_base + rcv_base);
ffffffff81011c03:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
ffffffff81011c08:	31 d2                	xor    %edx,%edx
ffffffff81011c0a:	4c 29 f6             	sub    %r14,%rsi
ffffffff81011c0d:	e8 54 e2 ff ff       	callq  ffffffff8100fe66 <_ZN5Space11tree_lookupEmb>
            if (!x || x->prnt != mdb || x->node_attr != attr)
ffffffff81011c12:	48 85 c0             	test   %rax,%rax
ffffffff81011c15:	74 10                	je     ffffffff81011c27 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x17f>
ffffffff81011c17:	48 39 68 48          	cmp    %rbp,0x48(%rax)
ffffffff81011c1b:	75 0a                	jne    ffffffff81011c27 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x17f>
ffffffff81011c1d:	4c 39 68 70          	cmp    %r13,0x70(%rax)
ffffffff81011c21:	0f 84 29 01 00 00    	je     ffffffff81011d50 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x2a8>
                trace (0, "overmap attempt %s - tree - PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx SUB:%lx", deltype, snd, this, snd_base, rcv_base, ord, attr, sub);
ffffffff81011c27:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81011c2b:	8b 05 d3 d3 fe 3e    	mov    0x3efed3d3(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81011c31:	48 81 7c 24 30 00 d0 	cmpq   $0xffffffffbfffd000,0x30(%rsp)
ffffffff81011c38:	ff bf 
ffffffff81011c3a:	4d 89 f1             	mov    %r14,%r9
ffffffff81011c3d:	ff b4 24 c0 00 00 00 	pushq  0xc0(%rsp)
ffffffff81011c44:	4d 89 e0             	mov    %r12,%r8
ffffffff81011c47:	41 55                	push   %r13
ffffffff81011c49:	48 c7 c7 24 ff 01 81 	mov    $0xffffffff8101ff24,%rdi
ffffffff81011c50:	ff 74 24 30          	pushq  0x30(%rsp)
ffffffff81011c54:	41 57                	push   %r15
ffffffff81011c56:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
ffffffff81011c5b:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff81011c5f:	48 8b 94 24 e8 00 00 	mov    0xe8(%rsp),%rdx
ffffffff81011c66:	00 
ffffffff81011c67:	eb 73                	jmp    ffffffff81011cdc <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x234>

            continue;
        }

        if (!node->insert_node (mdb, attr)) {
ffffffff81011c69:	4c 89 ea             	mov    %r13,%rdx
ffffffff81011c6c:	48 89 ee             	mov    %rbp,%rsi
ffffffff81011c6f:	48 89 df             	mov    %rbx,%rdi
ffffffff81011c72:	e8 37 6c ff ff       	callq  ffffffff810088ae <_ZN3Mdb11insert_nodeEPS_m>
ffffffff81011c77:	84 c0                	test   %al,%al
ffffffff81011c79:	75 6e                	jne    ffffffff81011ce9 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x241>
            S::tree_remove (node);
ffffffff81011c7b:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff81011c80:	48 89 df             	mov    %rbx,%rdi
ffffffff81011c83:	e8 57 e3 ff ff       	callq  ffffffff8100ffdf <_ZN5Space11tree_removeEP3MdbN3Avl5StateE>
ffffffff81011c88:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
ffffffff81011c8d:	48 89 de             	mov    %rbx,%rsi
ffffffff81011c90:	48 c7 c7 80 38 16 81 	mov    $0xffffffff81163880,%rdi
ffffffff81011c97:	e8 ce 3d 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
            Mdb::destroy (node, qg);
            trace (0, "overmap attempt %s - node - PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx SUB:%lx", deltype, snd, this, snd_base, rcv_base, ord, attr, sub);
ffffffff81011c9c:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81011ca0:	8b 05 5e d3 fe 3e    	mov    0x3efed35e(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81011ca6:	48 81 7c 24 30 00 d0 	cmpq   $0xffffffffbfffd000,0x30(%rsp)
ffffffff81011cad:	ff bf 
ffffffff81011caf:	ff b4 24 c0 00 00 00 	pushq  0xc0(%rsp)
ffffffff81011cb6:	41 55                	push   %r13
ffffffff81011cb8:	4d 89 f1             	mov    %r14,%r9
ffffffff81011cbb:	ff 74 24 30          	pushq  0x30(%rsp)
ffffffff81011cbf:	41 57                	push   %r15
ffffffff81011cc1:	4d 89 e0             	mov    %r12,%r8
ffffffff81011cc4:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
ffffffff81011cc9:	48 8b 94 24 e8 00 00 	mov    0xe8(%rsp),%rdx
ffffffff81011cd0:	00 
ffffffff81011cd1:	48 c7 c7 7f ff 01 81 	mov    $0xffffffff8101ff7f,%rdi
ffffffff81011cd8:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff81011cdc:	31 c0                	xor    %eax,%eax
ffffffff81011cde:	e8 a9 03 ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
            continue;
ffffffff81011ce3:	48 83 c4 20          	add    $0x20,%rsp
ffffffff81011ce7:	eb 67                	jmp    ffffffff81011d50 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x2a8>
        }

        s |= S::update (qg, node);
ffffffff81011ce9:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
ffffffff81011cee:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
ffffffff81011cf3:	31 c9                	xor    %ecx,%ecx
ffffffff81011cf5:	48 89 da             	mov    %rbx,%rdx
ffffffff81011cf8:	e8 69 4c 00 00       	callq  ffffffff81016966 <_ZN9Space_obj6updateER5QuotaP3Mdbm>
ffffffff81011cfd:	08 44 24 2f          	or     %al,0x2f(%rsp)

        if (Cpu::hazard & HZD_OOM) {
ffffffff81011d01:	f6 05 f8 d2 fe 3e 20 	testb  $0x20,0x3efed2f8(%rip)        # ffffffffbffff000 <_ZN3Cpu6hazardE>
ffffffff81011d08:	74 46                	je     ffffffff81011d50 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x2a8>
            S::update (qg, node, attr);
ffffffff81011d0a:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
ffffffff81011d0f:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
ffffffff81011d14:	4c 89 e9             	mov    %r13,%rcx
ffffffff81011d17:	48 89 da             	mov    %rbx,%rdx
ffffffff81011d1a:	e8 47 4c 00 00       	callq  ffffffff81016966 <_ZN9Space_obj6updateER5QuotaP3Mdbm>
            node->demote_node (attr);
ffffffff81011d1f:	4c 89 ee             	mov    %r13,%rsi
ffffffff81011d22:	48 89 df             	mov    %rbx,%rdi
ffffffff81011d25:	e8 7c 6c ff ff       	callq  ffffffff810089a6 <_ZN3Mdb11demote_nodeEm>
            if (node->remove_node() && S::tree_remove (node))
ffffffff81011d2a:	48 89 df             	mov    %rbx,%rdi
ffffffff81011d2d:	e8 14 6d ff ff       	callq  ffffffff81008a46 <_ZN3Mdb11remove_nodeEv>
ffffffff81011d32:	84 c0                	test   %al,%al
ffffffff81011d34:	0f 84 ba 00 00 00    	je     ffffffff81011df4 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x34c>
ffffffff81011d3a:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff81011d3f:	48 89 df             	mov    %rbx,%rdi
ffffffff81011d42:	e8 98 e2 ff ff       	callq  ffffffff8100ffdf <_ZN5Space11tree_removeEP3MdbN3Avl5StateE>
ffffffff81011d47:	84 c0                	test   %al,%al
ffffffff81011d49:	75 33                	jne    ffffffff81011d7e <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x2d6>
ffffffff81011d4b:	e9 a4 00 00 00       	jmpq   ffffffff81011df4 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x34c>
    bool s = false;

    Quota_guard qg(this->quota);

    Mdb *mdb;
    for (mword addr = snd_base; (mdb = snd->S::tree_lookup (addr, true)); addr = mdb->node_base + (1UL << mdb->node_order)) {
ffffffff81011d50:	48 8b 4d 68          	mov    0x68(%rbp),%rcx
ffffffff81011d54:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff81011d59:	48 d3 e6             	shl    %cl,%rsi
ffffffff81011d5c:	48 03 75 60          	add    0x60(%rbp),%rsi
ffffffff81011d60:	e9 a1 fd ff ff       	jmpq   ffffffff81011b06 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x5e>
                Rcu::call (node);
            return s;
        }
    }

    if (!qg.check(0))
ffffffff81011d65:	48 8d 7c 24 50       	lea    0x50(%rsp),%rdi
ffffffff81011d6a:	31 f6                	xor    %esi,%esi
ffffffff81011d6c:	e8 a7 e0 ff ff       	callq  ffffffff8100fe18 <_ZN11Quota_guard5checkEm>
ffffffff81011d71:	84 c0                	test   %al,%al
ffffffff81011d73:	75 7f                	jne    ffffffff81011df4 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x34c>
        Cpu::hazard |= HZD_OOM;
ffffffff81011d75:	83 0d 84 d2 fe 3e 20 	orl    $0x20,0x3efed284(%rip)        # ffffffffbffff000 <_ZN3Cpu6hazardE>

    return s;
ffffffff81011d7c:	eb 76                	jmp    ffffffff81011df4 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x34c>

        if (Cpu::hazard & HZD_OOM) {
            S::update (qg, node, attr);
            node->demote_node (attr);
            if (node->remove_node() && S::tree_remove (node))
                Rcu::call (node);
ffffffff81011d7e:	48 85 db             	test   %rbx,%rbx
ffffffff81011d81:	74 67                	je     ffffffff81011dea <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x342>
ffffffff81011d83:	48 8b 43 28          	mov    0x28(%rbx),%rax
ffffffff81011d87:	48 8d 6b 18          	lea    0x18(%rbx),%rbp
ffffffff81011d8b:	48 85 c0             	test   %rax,%rax
ffffffff81011d8e:	74 05                	je     ffffffff81011d95 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x2ed>
                e->pre_func(e);
ffffffff81011d90:	48 89 ef             	mov    %rbp,%rdi
ffffffff81011d93:	ff d0                	callq  *%rax
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
ffffffff81011d95:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
ffffffff81011d9a:	75 0c                	jne    ffffffff81011da8 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x300>
ffffffff81011d9c:	48 8b 05 c5 da fe 3e 	mov    0x3efedac5(%rip),%rax        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff81011da3:	48 39 e8             	cmp    %rbp,%rax
ffffffff81011da6:	75 2f                	jne    ffffffff81011dd7 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x32f>
                trace (0, "warning: rcu element already enqueued");
ffffffff81011da8:	48 8d 44 24 47       	lea    0x47(%rsp),%rax
ffffffff81011dad:	8b 15 51 d2 fe 3e    	mov    0x3efed251(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81011db3:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81011db7:	48 c7 c7 14 df 01 81 	mov    $0xffffffff8101df14,%rdi
ffffffff81011dbe:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81011dc4:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff81011dca:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff81011dce:	31 c0                	xor    %eax,%eax
ffffffff81011dd0:	e8 b7 02 ff ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff81011dd5:	eb 1d                	jmp    ffffffff81011df4 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x34c>
                return;
            }

            count ++;
ffffffff81011dd7:	48 ff 05 92 da fe 3e 	incq   0x3efeda92(%rip)        # ffffffffbffff870 <_ZN3Rcu4nextE+0x10>

           *tail = e;
ffffffff81011dde:	48 89 28             	mov    %rbp,(%rax)
            tail = &e->next;
ffffffff81011de1:	48 89 2d 80 da fe 3e 	mov    %rbp,0x3efeda80(%rip)        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
            return s;
ffffffff81011de8:	eb 0a                	jmp    ffffffff81011df4 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc+0x34c>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
ffffffff81011dea:	48 8b 04 25 10 00 00 	mov    0x10,%rax
ffffffff81011df1:	00 
ffffffff81011df2:	0f 0b                	ud2    
    }

    if (!qg.check(0))
        Cpu::hazard |= HZD_OOM;

    return s;
ffffffff81011df4:	48 8d 7c 24 50       	lea    0x50(%rsp),%rdi
ffffffff81011df9:	e8 5e e0 ff ff       	callq  ffffffff8100fe5c <_ZN11Quota_guardD1Ev>
}
ffffffff81011dfe:	8a 44 24 2f          	mov    0x2f(%rsp),%al
ffffffff81011e02:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
ffffffff81011e09:	5b                   	pop    %rbx
ffffffff81011e0a:	5d                   	pop    %rbp
ffffffff81011e0b:	41 5c                	pop    %r12
ffffffff81011e0d:	41 5d                	pop    %r13
ffffffff81011e0f:	41 5e                	pop    %r14
ffffffff81011e11:	41 5f                	pop    %r15
ffffffff81011e13:	c3                   	retq   

ffffffff81011e14 <_ZN2Pd7del_crdEPS_3CrdRS1_mm>:
        return ( chunk1 || chunk2); // because delegate return 0 if ok
    }
}

void Pd::del_crd (Pd *pd, Crd del, Crd &crd, mword sub, mword hot)
{
ffffffff81011e14:	41 57                	push   %r15
ffffffff81011e16:	41 56                	push   %r14
ffffffff81011e18:	41 55                	push   %r13
ffffffff81011e1a:	41 54                	push   %r12
ffffffff81011e1c:	49 89 cd             	mov    %rcx,%r13
ffffffff81011e1f:	55                   	push   %rbp
ffffffff81011e20:	53                   	push   %rbx

        ALWAYS_INLINE
        inline explicit Crd (Type t, mword b = 0, mword o = 0x1f, mword a = 0x1f) : val (b << 12 | o << 7 | a << 2 | t) {}

        ALWAYS_INLINE
        inline Type type() const { return static_cast<Type>(val & 0x3); }
ffffffff81011e21:	89 d5                	mov    %edx,%ebp
ffffffff81011e23:	49 89 fc             	mov    %rdi,%r12

        ALWAYS_INLINE
        inline unsigned order() const { return val >> 7 & 0x1f; }

        ALWAYS_INLINE
        inline mword base() const { return val >> 12; }
ffffffff81011e26:	48 89 d7             	mov    %rdx,%rdi

        ALWAYS_INLINE
        inline explicit Crd (Type t, mword b = 0, mword o = 0x1f, mword a = 0x1f) : val (b << 12 | o << 7 | a << 2 | t) {}

        ALWAYS_INLINE
        inline Type type() const { return static_cast<Type>(val & 0x3); }
ffffffff81011e29:	83 e5 03             	and    $0x3,%ebp
ffffffff81011e2c:	48 83 ec 28          	sub    $0x28,%rsp
ffffffff81011e30:	48 8b 01             	mov    (%rcx),%rax

        ALWAYS_INLINE
        inline unsigned attr() const { return val >> 2 & 0x1f; }
ffffffff81011e33:	48 89 d1             	mov    %rdx,%rcx
ffffffff81011e36:	48 c1 e9 02          	shr    $0x2,%rcx

        ALWAYS_INLINE
        inline unsigned order() const { return val >> 7 & 0x1f; }
ffffffff81011e3a:	48 c1 ea 07          	shr    $0x7,%rdx
ffffffff81011e3e:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)

        ALWAYS_INLINE
        inline mword base() const { return val >> 12; }
ffffffff81011e43:	48 c1 ef 0c          	shr    $0xc,%rdi
    Crd::Type st = crd.type(), rt = del.type();
    bool s = false;

    mword a = crd.attr() & del.attr(), sb = crd.base(), so = crd.order(), rb = del.base(), ro = del.order(), o = 0;
ffffffff81011e47:	83 e2 1f             	and    $0x1f,%edx

        ALWAYS_INLINE
        inline Type type() const { return static_cast<Type>(val & 0x3); }

        ALWAYS_INLINE
        inline unsigned attr() const { return val >> 2 & 0x1f; }
ffffffff81011e4a:	48 89 c3             	mov    %rax,%rbx

        ALWAYS_INLINE
        inline unsigned order() const { return val >> 7 & 0x1f; }

        ALWAYS_INLINE
        inline mword base() const { return val >> 12; }
ffffffff81011e4d:	48 89 c6             	mov    %rax,%rsi
ffffffff81011e50:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)

        ALWAYS_INLINE
        inline Type type() const { return static_cast<Type>(val & 0x3); }

        ALWAYS_INLINE
        inline unsigned attr() const { return val >> 2 & 0x1f; }
ffffffff81011e55:	48 c1 eb 02          	shr    $0x2,%rbx

        ALWAYS_INLINE
        inline unsigned order() const { return val >> 7 & 0x1f; }

        ALWAYS_INLINE
        inline mword base() const { return val >> 12; }
ffffffff81011e59:	48 c1 ee 0c          	shr    $0xc,%rsi
ffffffff81011e5d:	21 cb                	and    %ecx,%ebx

        ALWAYS_INLINE
        inline unsigned attr() const { return val >> 2 & 0x1f; }

        ALWAYS_INLINE
        inline unsigned order() const { return val >> 7 & 0x1f; }
ffffffff81011e5f:	48 89 c1             	mov    %rax,%rcx
ffffffff81011e62:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
ffffffff81011e67:	48 c1 e9 07          	shr    $0x7,%rcx
ffffffff81011e6b:	83 e1 1f             	and    $0x1f,%ecx

    if (EXPECT_FALSE (st != rt || !a)) {
ffffffff81011e6e:	83 e3 1f             	and    $0x1f,%ebx
ffffffff81011e71:	74 07                	je     ffffffff81011e7a <_ZN2Pd7del_crdEPS_3CrdRS1_mm+0x66>

        ALWAYS_INLINE
        inline explicit Crd (Type t, mword b = 0, mword o = 0x1f, mword a = 0x1f) : val (b << 12 | o << 7 | a << 2 | t) {}

        ALWAYS_INLINE
        inline Type type() const { return static_cast<Type>(val & 0x3); }
ffffffff81011e73:	83 e0 03             	and    $0x3,%eax
ffffffff81011e76:	39 e8                	cmp    %ebp,%eax
ffffffff81011e78:	74 0d                	je     ffffffff81011e87 <_ZN2Pd7del_crdEPS_3CrdRS1_mm+0x73>
        crd = Crd (0);
ffffffff81011e7a:	49 c7 45 00 00 00 00 	movq   $0x0,0x0(%r13)
ffffffff81011e81:	00 
ffffffff81011e82:	e9 f7 00 00 00       	jmpq   ffffffff81011f7e <_ZN2Pd7del_crdEPS_3CrdRS1_mm+0x16a>
        return;
    }

    switch (rt) {
ffffffff81011e87:	83 fd 02             	cmp    $0x2,%ebp
ffffffff81011e8a:	4d 89 c7             	mov    %r8,%r15
ffffffff81011e8d:	49 89 d0             	mov    %rdx,%r8
ffffffff81011e90:	74 4a                	je     ffffffff81011edc <_ZN2Pd7del_crdEPS_3CrdRS1_mm+0xc8>
ffffffff81011e92:	83 fd 03             	cmp    $0x3,%ebp
ffffffff81011e95:	74 79                	je     ffffffff81011f10 <_ZN2Pd7del_crdEPS_3CrdRS1_mm+0xfc>
void Pd::del_crd (Pd *pd, Crd del, Crd &crd, mword sub, mword hot)
{
    Crd::Type st = crd.type(), rt = del.type();
    bool s = false;

    mword a = crd.attr() & del.attr(), sb = crd.base(), so = crd.order(), rb = del.base(), ro = del.order(), o = 0;
ffffffff81011e97:	45 31 f6             	xor    %r14d,%r14d
    if (EXPECT_FALSE (st != rt || !a)) {
        crd = Crd (0);
        return;
    }

    switch (rt) {
ffffffff81011e9a:	83 fd 01             	cmp    $0x1,%ebp
ffffffff81011e9d:	0f 85 a8 00 00 00    	jne    ffffffff81011f4b <_ZN2Pd7del_crdEPS_3CrdRS1_mm+0x137>

        case Crd::MEM:
            o = clamp (sb, rb, so, ro, hot);
ffffffff81011ea3:	48 8d 54 24 18       	lea    0x18(%rsp),%rdx
ffffffff81011ea8:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
ffffffff81011ead:	4c 89 e7             	mov    %r12,%rdi
ffffffff81011eb0:	e8 fd e3 ff ff       	callq  ffffffff810102b2 <_ZN2Pd5clampERmS0_mmm>
            trace (TRACE_DEL, "DEL MEM PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx", pd, this, sb, rb, o, a);
            s = chunk_delegate(pd, sb, rb, o, a, sub);
ffffffff81011eb5:	51                   	push   %rcx
ffffffff81011eb6:	41 57                	push   %r15
ffffffff81011eb8:	4c 89 e7             	mov    %r12,%rdi
ffffffff81011ebb:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
ffffffff81011ec0:	48 8b 54 24 20       	mov    0x20(%rsp),%rdx
ffffffff81011ec5:	49 89 d9             	mov    %rbx,%r9
ffffffff81011ec8:	48 8b 74 24 18       	mov    0x18(%rsp),%rsi
ffffffff81011ecd:	49 89 c0             	mov    %rax,%r8
    }

    switch (rt) {

        case Crd::MEM:
            o = clamp (sb, rb, so, ro, hot);
ffffffff81011ed0:	49 89 c6             	mov    %rax,%r14
            trace (TRACE_DEL, "DEL MEM PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx", pd, this, sb, rb, o, a);
            s = chunk_delegate(pd, sb, rb, o, a, sub);
ffffffff81011ed3:	e8 c6 f7 ff ff       	callq  ffffffff8101169e <_ZN2Pd14chunk_delegateEPS_mmmmm>
            break;
ffffffff81011ed8:	5e                   	pop    %rsi
ffffffff81011ed9:	5f                   	pop    %rdi
ffffffff81011eda:	eb 71                	jmp    ffffffff81011f4d <_ZN2Pd7del_crdEPS_3CrdRS1_mm+0x139>

        case Crd::PIO:
            o = clamp (sb, rb, so, ro);
ffffffff81011edc:	48 8d 54 24 18       	lea    0x18(%rsp),%rdx
ffffffff81011ee1:	4c 89 e7             	mov    %r12,%rdi
ffffffff81011ee4:	e8 93 e3 ff ff       	callq  ffffffff8101027c <_ZN2Pd5clampEmRmmm>
            trace (TRACE_DEL, "DEL I/O PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx", pd, this, rb, rb, o, a);
            delegate<Space_pio>(pd, rb, rb, o, a, sub, "PIO");
ffffffff81011ee9:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
ffffffff81011eee:	68 de ff 01 81       	pushq  $0xffffffff8101ffde
ffffffff81011ef3:	49 89 d9             	mov    %rbx,%r9
ffffffff81011ef6:	41 57                	push   %r15
ffffffff81011ef8:	48 8b 74 24 18       	mov    0x18(%rsp),%rsi
ffffffff81011efd:	49 89 c0             	mov    %rax,%r8
ffffffff81011f00:	4c 89 e7             	mov    %r12,%rdi
            trace (TRACE_DEL, "DEL MEM PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx", pd, this, sb, rb, o, a);
            s = chunk_delegate(pd, sb, rb, o, a, sub);
            break;

        case Crd::PIO:
            o = clamp (sb, rb, so, ro);
ffffffff81011f03:	49 89 c6             	mov    %rax,%r14
            trace (TRACE_DEL, "DEL I/O PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx", pd, this, rb, rb, o, a);
            delegate<Space_pio>(pd, rb, rb, o, a, sub, "PIO");
ffffffff81011f06:	48 89 d1             	mov    %rdx,%rcx
ffffffff81011f09:	e8 2e f8 ff ff       	callq  ffffffff8101173c <_ZN2Pd8delegateI9Space_pioEEbPS_mmmmmPKc>
ffffffff81011f0e:	eb 39                	jmp    ffffffff81011f49 <_ZN2Pd7del_crdEPS_3CrdRS1_mm+0x135>
            break;

        case Crd::OBJ:
            o = clamp (sb, rb, so, ro, hot);
ffffffff81011f10:	48 8d 54 24 18       	lea    0x18(%rsp),%rdx
ffffffff81011f15:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
ffffffff81011f1a:	4c 89 e7             	mov    %r12,%rdi
ffffffff81011f1d:	e8 90 e3 ff ff       	callq  ffffffff810102b2 <_ZN2Pd5clampERmS0_mmm>
            trace (TRACE_DEL, "DEL OBJ PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx", pd, this, sb, rb, o, a);
            delegate<Space_obj>(pd, sb, rb, o, a, 0, "OBJ");
ffffffff81011f22:	68 e2 ff 01 81       	pushq  $0xffffffff8101ffe2
ffffffff81011f27:	6a 00                	pushq  $0x0
ffffffff81011f29:	49 89 d9             	mov    %rbx,%r9
ffffffff81011f2c:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
ffffffff81011f31:	48 8b 54 24 20       	mov    0x20(%rsp),%rdx
ffffffff81011f36:	49 89 c0             	mov    %rax,%r8
ffffffff81011f39:	48 8b 74 24 18       	mov    0x18(%rsp),%rsi
ffffffff81011f3e:	4c 89 e7             	mov    %r12,%rdi
            trace (TRACE_DEL, "DEL I/O PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx", pd, this, rb, rb, o, a);
            delegate<Space_pio>(pd, rb, rb, o, a, sub, "PIO");
            break;

        case Crd::OBJ:
            o = clamp (sb, rb, so, ro, hot);
ffffffff81011f41:	49 89 c6             	mov    %rax,%r14
            trace (TRACE_DEL, "DEL OBJ PD:%p->%p SB:%#010lx RB:%#010lx O:%#04lx A:%#lx", pd, this, sb, rb, o, a);
            delegate<Space_obj>(pd, sb, rb, o, a, 0, "OBJ");
ffffffff81011f44:	e8 5f fb ff ff       	callq  ffffffff81011aa8 <_ZN2Pd8delegateI9Space_objEEbPS_mmmmmPKc>
            break;
ffffffff81011f49:	58                   	pop    %rax
ffffffff81011f4a:	5a                   	pop    %rdx
}

void Pd::del_crd (Pd *pd, Crd del, Crd &crd, mword sub, mword hot)
{
    Crd::Type st = crd.type(), rt = del.type();
    bool s = false;
ffffffff81011f4b:	31 c0                	xor    %eax,%eax

        ALWAYS_INLINE
        inline explicit Crd (mword v) : val (v) {}

        ALWAYS_INLINE
        inline explicit Crd (Type t, mword b = 0, mword o = 0x1f, mword a = 0x1f) : val (b << 12 | o << 7 | a << 2 | t) {}
ffffffff81011f4d:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
ffffffff81011f52:	4d 89 f2             	mov    %r14,%r10
ffffffff81011f55:	49 c1 e2 07          	shl    $0x7,%r10
ffffffff81011f59:	48 c1 e2 0c          	shl    $0xc,%rdx
ffffffff81011f5d:	48 09 d5             	or     %rdx,%rbp
ffffffff81011f60:	48 8d 14 9d 00 00 00 	lea    0x0(,%rbx,4),%rdx
ffffffff81011f67:	00 
ffffffff81011f68:	48 89 eb             	mov    %rbp,%rbx
ffffffff81011f6b:	48 09 d3             	or     %rdx,%rbx
ffffffff81011f6e:	49 09 da             	or     %rbx,%r10
            break;
    }

    crd = Crd (rt, rb, o, a);

    if (s)
ffffffff81011f71:	84 c0                	test   %al,%al
ffffffff81011f73:	4d 89 55 00          	mov    %r10,0x0(%r13)
ffffffff81011f77:	74 05                	je     ffffffff81011f7e <_ZN2Pd7del_crdEPS_3CrdRS1_mm+0x16a>
        shootdown();
ffffffff81011f79:	e8 fc 46 00 00       	callq  ffffffff8101667a <_ZN9Space_mem9shootdownEv>
}
ffffffff81011f7e:	48 83 c4 28          	add    $0x28,%rsp
ffffffff81011f82:	5b                   	pop    %rbx
ffffffff81011f83:	5d                   	pop    %rbp
ffffffff81011f84:	41 5c                	pop    %r12
ffffffff81011f86:	41 5d                	pop    %r13
ffffffff81011f88:	41 5e                	pop    %r14
ffffffff81011f8a:	41 5f                	pop    %r15
ffffffff81011f8c:	c3                   	retq   
ffffffff81011f8d:	90                   	nop

ffffffff81011f8e <_ZN2Pd10xfer_itemsEPS_3CrdS1_P4XferS3_m>:
    if (crd.type() == Crd::MEM)
        shootdown();
}

void Pd::xfer_items (Pd *src, Crd xlt, Crd del, Xfer *s, Xfer *d, unsigned long ti)
{
ffffffff81011f8e:	41 57                	push   %r15
ffffffff81011f90:	41 56                	push   %r14
ffffffff81011f92:	4d 89 cf             	mov    %r9,%r15
ffffffff81011f95:	41 55                	push   %r13
ffffffff81011f97:	41 54                	push   %r12
ffffffff81011f99:	49 89 fd             	mov    %rdi,%r13
ffffffff81011f9c:	55                   	push   %rbp
ffffffff81011f9d:	53                   	push   %rbx
ffffffff81011f9e:	48 89 f5             	mov    %rsi,%rbp
ffffffff81011fa1:	49 89 d6             	mov    %rdx,%r14
ffffffff81011fa4:	4c 89 c3             	mov    %r8,%rbx
ffffffff81011fa7:	48 83 ec 28          	sub    $0x28,%rsp
            PIO = 2,
            OBJ = 3,
        };

        ALWAYS_INLINE
        inline explicit Crd() : val (0) {}
ffffffff81011fab:	4c 8b 64 24 60       	mov    0x60(%rsp),%r12
ffffffff81011fb0:	48 89 0c 24          	mov    %rcx,(%rsp)
    mword set_as_del;

    for (Crd crd; ti--; s--) {
ffffffff81011fb4:	4d 85 e4             	test   %r12,%r12
ffffffff81011fb7:	0f 84 15 01 00 00    	je     ffffffff810120d2 <_ZN2Pd10xfer_itemsEPS_3CrdS1_P4XferS3_m+0x144>

        crd = *s;
ffffffff81011fbd:	48 8b 13             	mov    (%rbx),%rdx
ffffffff81011fc0:	48 89 54 24 18       	mov    %rdx,0x18(%rsp)
        set_as_del = 0;

        switch (s->flags() & 3) {
ffffffff81011fc5:	48 8b 53 08          	mov    0x8(%rbx),%rdx
ffffffff81011fc9:	83 e2 03             	and    $0x3,%edx
ffffffff81011fcc:	48 83 fa 01          	cmp    $0x1,%rdx
ffffffff81011fd0:	74 53                	je     ffffffff81012025 <_ZN2Pd10xfer_itemsEPS_3CrdS1_P4XferS3_m+0x97>
ffffffff81011fd2:	72 0b                	jb     ffffffff81011fdf <_ZN2Pd10xfer_itemsEPS_3CrdS1_P4XferS3_m+0x51>
ffffffff81011fd4:	48 83 fa 02          	cmp    $0x2,%rdx
ffffffff81011fd8:	74 1d                	je     ffffffff81011ff7 <_ZN2Pd10xfer_itemsEPS_3CrdS1_P4XferS3_m+0x69>
ffffffff81011fda:	e9 b8 00 00 00       	jmpq   ffffffff81012097 <_ZN2Pd10xfer_itemsEPS_3CrdS1_P4XferS3_m+0x109>

            case 0:
                xlt_crd (src, xlt, crd);
ffffffff81011fdf:	48 8d 4c 24 18       	lea    0x18(%rsp),%rcx
ffffffff81011fe4:	4c 89 f2             	mov    %r14,%rdx
ffffffff81011fe7:	48 89 ee             	mov    %rbp,%rsi
ffffffff81011fea:	4c 89 ef             	mov    %r13,%rdi
ffffffff81011fed:	e8 64 e3 ff ff       	callq  ffffffff81010356 <_ZN2Pd7xlt_crdEPS_3CrdRS1_>
ffffffff81011ff2:	e9 a9 00 00 00       	jmpq   ffffffff810120a0 <_ZN2Pd10xfer_itemsEPS_3CrdS1_P4XferS3_m+0x112>
                break;

            case 2:
                xlt_crd (src, xlt, crd);
ffffffff81011ff7:	48 8d 4c 24 18       	lea    0x18(%rsp),%rcx
ffffffff81011ffc:	4c 89 f2             	mov    %r14,%rdx
ffffffff81011fff:	48 89 ee             	mov    %rbp,%rsi
ffffffff81012002:	4c 89 ef             	mov    %r13,%rdi
ffffffff81012005:	e8 4c e3 ff ff       	callq  ffffffff81010356 <_ZN2Pd7xlt_crdEPS_3CrdRS1_>
                if (crd.type()) break;
ffffffff8101200a:	f6 44 24 18 03       	testb  $0x3,0x18(%rsp)
ffffffff8101200f:	0f 85 8b 00 00 00    	jne    ffffffff810120a0 <_ZN2Pd10xfer_itemsEPS_3CrdS1_P4XferS3_m+0x112>

                crd = *s;
ffffffff81012015:	48 8b 13             	mov    (%rbx),%rdx
                set_as_del = 1;
ffffffff81012018:	41 ba 01 00 00 00    	mov    $0x1,%r10d

            case 2:
                xlt_crd (src, xlt, crd);
                if (crd.type()) break;

                crd = *s;
ffffffff8101201e:	48 89 54 24 18       	mov    %rdx,0x18(%rsp)
ffffffff81012023:	eb 03                	jmp    ffffffff81012028 <_ZN2Pd10xfer_itemsEPS_3CrdS1_P4XferS3_m+0x9a>
    mword set_as_del;

    for (Crd crd; ti--; s--) {

        crd = *s;
        set_as_del = 0;
ffffffff81012025:	45 31 d2             	xor    %r10d,%r10d

                crd = *s;
                set_as_del = 1;

            case 1: {
                bool r = src == &root && s->flags() & 0x800;
ffffffff81012028:	31 c9                	xor    %ecx,%ecx
ffffffff8101202a:	48 81 fd 60 39 16 81 	cmp    $0xffffffff81163960,%rbp
ffffffff81012031:	4c 8b 4b 08          	mov    0x8(%rbx),%r9
ffffffff81012035:	75 0a                	jne    ffffffff81012041 <_ZN2Pd10xfer_itemsEPS_3CrdS1_P4XferS3_m+0xb3>
ffffffff81012037:	4c 89 c9             	mov    %r9,%rcx
ffffffff8101203a:	48 c1 e9 0b          	shr    $0xb,%rcx
ffffffff8101203e:	83 e1 01             	and    $0x1,%ecx
    public:
        ALWAYS_INLINE
        inline explicit Xfer (Crd c, mword v) : Crd (c), val (v) {}

        ALWAYS_INLINE
        inline mword flags() const { return val & 0xfff; }
ffffffff81012041:	4d 89 c8             	mov    %r9,%r8
                del_crd (r? &kern : src, del, crd, (s->flags() >> 8) & (r ? 7 : 3), s->hotspot());
ffffffff81012044:	48 c7 c6 a0 3c 16 81 	mov    $0xffffffff81163ca0,%rsi
ffffffff8101204b:	4c 89 ef             	mov    %r13,%rdi
ffffffff8101204e:	41 81 e0 ff 0f 00 00 	and    $0xfff,%r8d
ffffffff81012055:	4c 89 54 24 08       	mov    %r10,0x8(%rsp)
ffffffff8101205a:	49 c1 e8 08          	shr    $0x8,%r8
ffffffff8101205e:	80 f9 01             	cmp    $0x1,%cl
ffffffff81012061:	48 19 d2             	sbb    %rdx,%rdx
ffffffff81012064:	48 83 e2 fc          	and    $0xfffffffffffffffc,%rdx
ffffffff81012068:	48 83 c2 07          	add    $0x7,%rdx
ffffffff8101206c:	84 c9                	test   %cl,%cl
ffffffff8101206e:	48 8d 4c 24 18       	lea    0x18(%rsp),%rcx
ffffffff81012073:	48 0f 44 f5          	cmove  %rbp,%rsi
ffffffff81012077:	49 21 d0             	and    %rdx,%r8
ffffffff8101207a:	48 8b 14 24          	mov    (%rsp),%rdx
ffffffff8101207e:	49 c1 e9 0c          	shr    $0xc,%r9
ffffffff81012082:	e8 8d fd ff ff       	callq  ffffffff81011e14 <_ZN2Pd7del_crdEPS_3CrdRS1_mm>
                if (Cpu::hazard & HZD_OOM)
ffffffff81012087:	f6 05 72 cf fe 3e 20 	testb  $0x20,0x3efecf72(%rip)        # ffffffffbffff000 <_ZN3Cpu6hazardE>
ffffffff8101208e:	4c 8b 54 24 08       	mov    0x8(%rsp),%r10
ffffffff81012093:	74 0e                	je     ffffffff810120a3 <_ZN2Pd10xfer_itemsEPS_3CrdS1_P4XferS3_m+0x115>
ffffffff81012095:	eb 3b                	jmp    ffffffff810120d2 <_ZN2Pd10xfer_itemsEPS_3CrdS1_P4XferS3_m+0x144>
                    return;
                break;
            }
            default:
                crd = Crd(0);
ffffffff81012097:	48 c7 44 24 18 00 00 	movq   $0x0,0x18(%rsp)
ffffffff8101209e:	00 00 
    mword set_as_del;

    for (Crd crd; ti--; s--) {

        crd = *s;
        set_as_del = 0;
ffffffff810120a0:	45 31 d2             	xor    %r10d,%r10d
            default:
                crd = Crd(0);

        };

        if (d)
ffffffff810120a3:	4d 85 ff             	test   %r15,%r15
ffffffff810120a6:	74 1e                	je     ffffffff810120c6 <_ZN2Pd10xfer_itemsEPS_3CrdS1_P4XferS3_m+0x138>
ffffffff810120a8:	48 8b 53 08          	mov    0x8(%rbx),%rdx
            *d-- = Xfer (crd, s->flags() | set_as_del);
ffffffff810120ac:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
ffffffff810120b1:	49 83 ef 10          	sub    $0x10,%r15
ffffffff810120b5:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
ffffffff810120bb:	49 89 4f 10          	mov    %rcx,0x10(%r15)
ffffffff810120bf:	4c 09 d2             	or     %r10,%rdx
ffffffff810120c2:	49 89 57 18          	mov    %rdx,0x18(%r15)

void Pd::xfer_items (Pd *src, Crd xlt, Crd del, Xfer *s, Xfer *d, unsigned long ti)
{
    mword set_as_del;

    for (Crd crd; ti--; s--) {
ffffffff810120c6:	48 83 eb 10          	sub    $0x10,%rbx
ffffffff810120ca:	49 ff cc             	dec    %r12
ffffffff810120cd:	e9 e2 fe ff ff       	jmpq   ffffffff81011fb4 <_ZN2Pd10xfer_itemsEPS_3CrdS1_P4XferS3_m+0x26>
        };

        if (d)
            *d-- = Xfer (crd, s->flags() | set_as_del);
    }
}
ffffffff810120d2:	48 83 c4 28          	add    $0x28,%rsp
ffffffff810120d6:	5b                   	pop    %rbx
ffffffff810120d7:	5d                   	pop    %rbp
ffffffff810120d8:	41 5c                	pop    %r12
ffffffff810120da:	41 5d                	pop    %r13
ffffffff810120dc:	41 5e                	pop    %r14
ffffffff810120de:	41 5f                	pop    %r15
ffffffff810120e0:	c3                   	retq   

ffffffff810120e1 <_GLOBAL__sub_I.00101__ZN2Pd5cacheE>:
Slab_cache Pd::cache (sizeof (Pd), 32);

Pd *Pd::current;

INIT_PRIORITY (PRIO_BUDDY)
ALIGNED(32) Pd Pd::kern (&Pd::kern);
ffffffff810120e1:	48 c7 c6 a0 3c 16 81 	mov    $0xffffffff81163ca0,%rsi
        if (Hip::cpu_online (cpu))
            Space_mem::loc[cpu].clear(quota, Space_mem::hpt.dest_loc, Space_mem::hpt.iter_loc_lev);
}

extern "C" int __cxa_atexit(void (*)(void *), void *, void *) { return 0; }
void * __dso_handle = nullptr;
ffffffff810120e8:	50                   	push   %rax
Slab_cache Pd::cache (sizeof (Pd), 32);

Pd *Pd::current;

INIT_PRIORITY (PRIO_BUDDY)
ALIGNED(32) Pd Pd::kern (&Pd::kern);
ffffffff810120e9:	48 89 f7             	mov    %rsi,%rdi
ffffffff810120ec:	e8 51 f8 1e 7f       	callq  201942 <_ZN2PdC1EPS_>
        if (Hip::cpu_online (cpu))
            Space_mem::loc[cpu].clear(quota, Space_mem::hpt.dest_loc, Space_mem::hpt.iter_loc_lev);
}

extern "C" int __cxa_atexit(void (*)(void *), void *, void *) { return 0; }
void * __dso_handle = nullptr;
ffffffff810120f1:	59                   	pop    %rcx
Slab_cache Pd::cache (sizeof (Pd), 32);

Pd *Pd::current;

INIT_PRIORITY (PRIO_BUDDY)
ALIGNED(32) Pd Pd::kern (&Pd::kern);
ffffffff810120f2:	48 c7 c2 40 39 16 81 	mov    $0xffffffff81163940,%rdx
ffffffff810120f9:	48 c7 c6 a0 3c 16 81 	mov    $0xffffffff81163ca0,%rsi
ffffffff81012100:	48 c7 c7 28 10 01 81 	mov    $0xffffffff81011028,%rdi
ffffffff81012107:	e9 4a e4 ff ff       	jmpq   ffffffff81010556 <__cxa_atexit>

ffffffff8101210c <_GLOBAL__sub_I.00102__ZN2Pd5cacheE>:
#include "stdio.hpp"
#include "hip.hpp"
#include "ec.hpp"

INIT_PRIORITY (PRIO_SLAB)
Slab_cache Pd::cache (sizeof (Pd), 32);
ffffffff8101210c:	ba 20 00 00 00       	mov    $0x20,%edx
ffffffff81012111:	be 30 03 00 00       	mov    $0x330,%esi
ffffffff81012116:	48 c7 c7 d0 3f 16 81 	mov    $0xffffffff81163fd0,%rdi
ffffffff8101211d:	e9 7e 37 00 00       	jmpq   ffffffff810158a0 <_ZN10Slab_cacheC1Emj>

ffffffff81012122 <_GLOBAL__sub_I__ZN2Pd5cacheE>:

Pd *Pd::current;

INIT_PRIORITY (PRIO_BUDDY)
ALIGNED(32) Pd Pd::kern (&Pd::kern);
ALIGNED(32) Pd Pd::root (&Pd::root, NUM_EXC, 0x1f);
ffffffff81012122:	48 c7 c6 60 39 16 81 	mov    $0xffffffff81163960,%rsi
        if (Hip::cpu_online (cpu))
            Space_mem::loc[cpu].clear(quota, Space_mem::hpt.dest_loc, Space_mem::hpt.iter_loc_lev);
}

extern "C" int __cxa_atexit(void (*)(void *), void *, void *) { return 0; }
void * __dso_handle = nullptr;
ffffffff81012129:	50                   	push   %rax

Pd *Pd::current;

INIT_PRIORITY (PRIO_BUDDY)
ALIGNED(32) Pd Pd::kern (&Pd::kern);
ALIGNED(32) Pd Pd::root (&Pd::root, NUM_EXC, 0x1f);
ffffffff8101212a:	b9 1f 00 00 00       	mov    $0x1f,%ecx
ffffffff8101212f:	48 89 f7             	mov    %rsi,%rdi
ffffffff81012132:	ba 20 00 00 00       	mov    $0x20,%edx
ffffffff81012137:	e8 52 df ff ff       	callq  ffffffff8101008e <_ZN2PdC1EPS_mm>
        if (Hip::cpu_online (cpu))
            Space_mem::loc[cpu].clear(quota, Space_mem::hpt.dest_loc, Space_mem::hpt.iter_loc_lev);
}

extern "C" int __cxa_atexit(void (*)(void *), void *, void *) { return 0; }
void * __dso_handle = nullptr;
ffffffff8101213c:	59                   	pop    %rcx

Pd *Pd::current;

INIT_PRIORITY (PRIO_BUDDY)
ALIGNED(32) Pd Pd::kern (&Pd::kern);
ALIGNED(32) Pd Pd::root (&Pd::root, NUM_EXC, 0x1f);
ffffffff8101213d:	48 c7 c2 40 39 16 81 	mov    $0xffffffff81163940,%rdx
ffffffff81012144:	48 c7 c6 60 39 16 81 	mov    $0xffffffff81163960,%rsi
ffffffff8101214b:	48 c7 c7 28 10 01 81 	mov    $0xffffffff81011028,%rdi
ffffffff81012152:	e9 ff e3 ff ff       	jmpq   ffffffff81010556 <__cxa_atexit>
ffffffff81012157:	90                   	nop

ffffffff81012158 <_ZN2Pt4freeEP8Rcu_elem>:
    trace (TRACE_SYSCALL, "PT:%p created (EC:%p IP:%#lx)", this, e, ip);
}

void Pt::free (Rcu_elem * p)
{
    Pt *pt = static_cast<Pt *>(p);
ffffffff81012158:	48 8d 47 e8          	lea    -0x18(%rdi),%rax
{
    trace (TRACE_SYSCALL, "PT:%p created (EC:%p IP:%#lx)", this, e, ip);
}

void Pt::free (Rcu_elem * p)
{
ffffffff8101215c:	55                   	push   %rbp
ffffffff8101215d:	53                   	push   %rbx
    Pt *pt = static_cast<Pt *>(p);
ffffffff8101215e:	31 db                	xor    %ebx,%ebx
{
    trace (TRACE_SYSCALL, "PT:%p created (EC:%p IP:%#lx)", this, e, ip);
}

void Pt::free (Rcu_elem * p)
{
ffffffff81012160:	56                   	push   %rsi
    Pt *pt = static_cast<Pt *>(p);
ffffffff81012161:	48 85 ff             	test   %rdi,%rdi
ffffffff81012164:	48 0f 45 d8          	cmovne %rax,%rbx
ffffffff81012168:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff8101216b:	f0 0f c1 83 8c 00 00 	lock xadd %eax,0x8c(%rbx)
ffffffff81012172:	00 

    if (!pt->del_ref())
ffffffff81012173:	ff c8                	dec    %eax
ffffffff81012175:	75 7d                	jne    ffffffff810121f4 <_ZN2Pt4freeEP8Rcu_elem+0x9c>
        return;

    Pd *pd = static_cast<Pd *>(static_cast<Space_obj *>(pt->space));
ffffffff81012177:	48 8b 43 50          	mov    0x50(%rbx),%rax
ffffffff8101217b:	31 d2                	xor    %edx,%edx
ffffffff8101217d:	48 8d 88 08 fd ff ff 	lea    -0x2f8(%rax),%rcx
ffffffff81012184:	48 85 c0             	test   %rax,%rax
        inline Refptr (T *p) : ptr (p->add_ref() ? p : nullptr) {}

        ALWAYS_INLINE
        inline ~Refptr()
        {
            if (ptr && ptr->del_ref())
ffffffff81012187:	48 8b 83 90 00 00 00 	mov    0x90(%rbx),%rax
ffffffff8101218e:	48 0f 45 d1          	cmovne %rcx,%rdx
ffffffff81012192:	48 85 c0             	test   %rax,%rax
    destroy(pt, pd->quota);
ffffffff81012195:	48 8d aa 08 03 00 00 	lea    0x308(%rdx),%rbp
ffffffff8101219c:	74 41                	je     ffffffff810121df <_ZN2Pt4freeEP8Rcu_elem+0x87>
ffffffff8101219e:	83 ca ff             	or     $0xffffffff,%edx
ffffffff810121a1:	f0 0f c1 90 8c 00 00 	lock xadd %edx,0x8c(%rax)
ffffffff810121a8:	00 
ffffffff810121a9:	ff ca                	dec    %edx
ffffffff810121ab:	75 32                	jne    ffffffff810121df <_ZN2Pt4freeEP8Rcu_elem+0x87>
                delete ptr;
ffffffff810121ad:	48 8b bb 90 00 00 00 	mov    0x90(%rbx),%rdi
ffffffff810121b4:	48 85 ff             	test   %rdi,%rdi
ffffffff810121b7:	74 26                	je     ffffffff810121df <_ZN2Pt4freeEP8Rcu_elem+0x87>
ffffffff810121b9:	e8 7e 22 ff ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
ffffffff810121be:	48 8b b3 90 00 00 00 	mov    0x90(%rbx),%rsi
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff810121c5:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff810121cc:	48 8b 86 98 02 00 00 	mov    0x298(%rsi),%rax
ffffffff810121d3:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff810121da:	e8 8b 38 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
}
ffffffff810121df:	59                   	pop    %rcx
ffffffff810121e0:	48 89 ea             	mov    %rbp,%rdx
ffffffff810121e3:	48 89 de             	mov    %rbx,%rsi
ffffffff810121e6:	48 c7 c7 00 40 16 81 	mov    $0xffffffff81164000,%rdi
ffffffff810121ed:	5b                   	pop    %rbx
ffffffff810121ee:	5d                   	pop    %rbp
ffffffff810121ef:	e9 76 38 00 00       	jmpq   ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
ffffffff810121f4:	58                   	pop    %rax
ffffffff810121f5:	5b                   	pop    %rbx
ffffffff810121f6:	5d                   	pop    %rbp
ffffffff810121f7:	c3                   	retq   

ffffffff810121f8 <_ZN2PtC1EP2PdmP2Ec3Mtdm>:
#include "stdio.hpp"

INIT_PRIORITY (PRIO_SLAB)
Slab_cache Pt::cache (sizeof (Pt), 32);

Pt::Pt (Pd *own, mword sel, Ec *e, Mtd m, mword addr) : Kobject (PT, static_cast<Space_obj *>(own), sel, 0x3, free), ec (e), mtd (m), ip (addr), id(0)
ffffffff810121f8:	41 55                	push   %r13
ffffffff810121fa:	41 54                	push   %r12
ffffffff810121fc:	48 8d 86 f8 02 00 00 	lea    0x2f8(%rsi),%rax
ffffffff81012203:	55                   	push   %rbp
ffffffff81012204:	53                   	push   %rbx
ffffffff81012205:	48 89 cd             	mov    %rcx,%rbp
ffffffff81012208:	4d 89 c5             	mov    %r8,%r13
ffffffff8101220b:	48 89 d1             	mov    %rdx,%rcx
ffffffff8101220e:	4d 89 cc             	mov    %r9,%r12
ffffffff81012211:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff81012215:	48 85 f6             	test   %rsi,%rsi
ffffffff81012218:	be 00 00 00 00       	mov    $0x0,%esi
ffffffff8101221d:	6a 00                	pushq  $0x0
ffffffff8101221f:	48 0f 45 f0          	cmovne %rax,%rsi
ffffffff81012223:	49 c7 c1 58 21 01 81 	mov    $0xffffffff81012158,%r9
ffffffff8101222a:	41 b8 03 00 00 00    	mov    $0x3,%r8d
ffffffff81012230:	48 89 fa             	mov    %rdi,%rdx
ffffffff81012233:	48 89 fb             	mov    %rdi,%rbx
ffffffff81012236:	e8 71 16 ff ff       	callq  ffffffff810038ac <_ZN3MdbC1EP5SpacemmmPFvP8Rcu_elemES5_>
    private:
        uint32 ref;

    public:
        ALWAYS_INLINE
        inline Refex() : ref (1) {}
ffffffff8101223b:	41 5b                	pop    %r11
ffffffff8101223d:	58                   	pop    %rax
ffffffff8101223e:	c6 83 88 00 00 00 03 	movb   $0x3,0x88(%rbx)
ffffffff81012245:	66 c7 83 8a 00 00 00 	movw   $0x0,0x8a(%rbx)
ffffffff8101224c:	00 00 
ffffffff8101224e:	c7 83 8c 00 00 00 01 	movl   $0x1,0x8c(%rbx)
ffffffff81012255:	00 00 00 

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff81012258:	8b 85 8c 00 00 00    	mov    0x8c(%rbp),%eax
ffffffff8101225e:	85 c0                	test   %eax,%eax
ffffffff81012260:	74 0f                	je     ffffffff81012271 <_ZN2PtC1EP2PdmP2Ec3Mtdm+0x79>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff81012262:	8d 50 01             	lea    0x1(%rax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff81012265:	f0 0f b1 95 8c 00 00 	lock cmpxchg %edx,0x8c(%rbp)
ffffffff8101226c:	00 
ffffffff8101226d:	75 e9                	jne    ffffffff81012258 <_ZN2PtC1EP2PdmP2Ec3Mtdm+0x60>
ffffffff8101226f:	eb 02                	jmp    ffffffff81012273 <_ZN2PtC1EP2PdmP2Ec3Mtdm+0x7b>
    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }

        ALWAYS_INLINE
        inline Refptr (T *p) : ptr (p->add_ref() ? p : nullptr) {}
ffffffff81012271:	31 ed                	xor    %ebp,%ebp
ffffffff81012273:	48 89 ab 90 00 00 00 	mov    %rbp,0x90(%rbx)
ffffffff8101227a:	4c 89 ab 98 00 00 00 	mov    %r13,0x98(%rbx)
ffffffff81012281:	4c 89 a3 a0 00 00 00 	mov    %r12,0xa0(%rbx)
ffffffff81012288:	48 c7 83 a8 00 00 00 	movq   $0x0,0xa8(%rbx)
ffffffff8101228f:	00 00 00 00 
{
    trace (TRACE_SYSCALL, "PT:%p created (EC:%p IP:%#lx)", this, e, ip);
}
ffffffff81012293:	58                   	pop    %rax
ffffffff81012294:	5b                   	pop    %rbx
ffffffff81012295:	5d                   	pop    %rbp
ffffffff81012296:	41 5c                	pop    %r12
ffffffff81012298:	41 5d                	pop    %r13
ffffffff8101229a:	c3                   	retq   

ffffffff8101229b <_GLOBAL__sub_I.00102__ZN2Pt5cacheE>:
#include "ec.hpp"
#include "pt.hpp"
#include "stdio.hpp"

INIT_PRIORITY (PRIO_SLAB)
Slab_cache Pt::cache (sizeof (Pt), 32);
ffffffff8101229b:	ba 20 00 00 00       	mov    $0x20,%edx
ffffffff810122a0:	be b0 00 00 00       	mov    $0xb0,%esi
ffffffff810122a5:	48 c7 c7 00 40 16 81 	mov    $0xffffffff81164000,%rdi
ffffffff810122ac:	e9 ef 35 00 00       	jmpq   ffffffff810158a0 <_ZN10Slab_cacheC1Emj>
ffffffff810122b1:	90                   	nop

ffffffff810122b2 <_ZN3PteI3DptyLj4ELj9ELb1EE4walkER5Quotaymb>:
    }
    return true;
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
P *Pte<P, E, L, B, F>::walk(Quota &quota, E v, unsigned long n, bool a) {
ffffffff810122b2:	41 57                	push   %r15
ffffffff810122b4:	41 56                	push   %r14
ffffffff810122b6:	45 88 c7             	mov    %r8b,%r15b
ffffffff810122b9:	41 55                	push   %r13
ffffffff810122bb:	41 54                	push   %r12
ffffffff810122bd:	49 89 d5             	mov    %rdx,%r13
ffffffff810122c0:	55                   	push   %rbp
ffffffff810122c1:	53                   	push   %rbx
ffffffff810122c2:	49 89 f4             	mov    %rsi,%r12
ffffffff810122c5:	41 51                	push   %r9
ffffffff810122c7:	49 89 ce             	mov    %rcx,%r14
    unsigned long l = L;

    for (P *p, *e = static_cast<P *> (this);; e = static_cast<P *> (Buddy::phys_to_ptr(e->addr())) + (v >> (--l * B + PAGE_BITS) & ((1UL << B) - 1))) {
ffffffff810122ca:	48 89 fb             	mov    %rdi,%rbx
    return true;
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
P *Pte<P, E, L, B, F>::walk(Quota &quota, E v, unsigned long n, bool a) {
    unsigned long l = L;
ffffffff810122cd:	bd 04 00 00 00       	mov    $0x4,%ebp

    for (P *p, *e = static_cast<P *> (this);; e = static_cast<P *> (Buddy::phys_to_ptr(e->addr())) + (v >> (--l * B + PAGE_BITS) & ((1UL << B) - 1))) {

        if (l == n)
ffffffff810122d2:	4c 39 f5             	cmp    %r14,%rbp
ffffffff810122d5:	0f 84 96 00 00 00    	je     ffffffff81012371 <_ZN3PteI3DptyLj4ELj9ELb1EE4walkER5Quotaymb+0xbf>
            return e;

        if (!e->val) {
ffffffff810122db:	48 83 3b 00          	cmpq   $0x0,(%rbx)
ffffffff810122df:	75 64                	jne    ffffffff81012345 <_ZN3PteI3DptyLj4ELj9ELb1EE4walkER5Quotaymb+0x93>

            if (!a)
ffffffff810122e1:	45 84 ff             	test   %r15b,%r15b
ffffffff810122e4:	0f 84 8c 00 00 00    	je     ffffffff81012376 <_ZN3PteI3DptyLj4ELj9ELb1EE4walkER5Quotaymb+0xc4>
        return b;
    }

    ALWAYS_INLINE
    static inline void *operator new (size_t, Quota &quota) {
        void *p = Buddy::allocator.alloc(0, quota, Buddy::FILL_0);
ffffffff810122ea:	4c 89 e2             	mov    %r12,%rdx
ffffffff810122ed:	31 f6                	xor    %esi,%esi
ffffffff810122ef:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff810122f4:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff810122fb:	e8 f2 f5 fe ff       	callq  ffffffff810018f2 <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
ffffffff81012300:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
ffffffff81012307:	48 89 c6             	mov    %rax,%rsi
}

ALWAYS_INLINE NONNULL
inline void *flush (void *d, size_t n)
{
    for (char *p = static_cast<char *>(d); p < static_cast<char *>(d) + n; p += 32)
ffffffff8101230a:	48 39 d0             	cmp    %rdx,%rax
ffffffff8101230d:	74 09                	je     ffffffff81012318 <_ZN3PteI3DptyLj4ELj9ELb1EE4walkER5Quotaymb+0x66>

template <typename T>
ALWAYS_INLINE
static inline void flush (T t)
{
    asm volatile ("clflush %0" : : "m" (*t) : "memory");
ffffffff8101230f:	0f ae 38             	clflush (%rax)
}

ALWAYS_INLINE NONNULL
inline void *flush (void *d, size_t n)
{
    for (char *p = static_cast<char *>(d); p < static_cast<char *>(d) + n; p += 32)
ffffffff81012312:	48 83 c0 20          	add    $0x20,%rax
ffffffff81012316:	eb f2                	jmp    ffffffff8101230a <_ZN3PteI3DptyLj4ELj9ELb1EE4walkER5Quotaymb+0x58>
ffffffff81012318:	48 89 f2             	mov    %rsi,%rdx
                return nullptr;

            if (!e->set(0, Buddy::ptr_to_phys(p = new (quota) P) | (l == L ? 0 : P::PTE_N)))
ffffffff8101231b:	31 c0                	xor    %eax,%eax

    void free_up(Quota &quota, unsigned l, P *, mword, bool (*) (Paddr, mword, unsigned), bool (*) (unsigned, mword));

public:

    Pte() : val(0) {
ffffffff8101231d:	48 c7 06 00 00 00 00 	movq   $0x0,(%rsi)
ffffffff81012324:	48 81 ea 00 00 c0 80 	sub    $0xffffffff80c00000,%rdx
ffffffff8101232b:	48 83 fd 04          	cmp    $0x4,%rbp
ffffffff8101232f:	0f 95 c0             	setne  %al
ffffffff81012332:	48 8d 04 40          	lea    (%rax,%rax,2),%rax
ffffffff81012336:	48 09 c2             	or     %rax,%rdx
ffffffff81012339:	31 c0                	xor    %eax,%eax
ffffffff8101233b:	f0 48 0f b1 13       	lock cmpxchg %rdx,(%rbx)

    ALWAYS_INLINE
    inline bool set(E o, E v) {
        bool b = Atomic::cmp_swap(val, o, v);

        if (F && b)
ffffffff81012340:	75 38                	jne    ffffffff8101237a <_ZN3PteI3DptyLj4ELj9ELb1EE4walkER5Quotaymb+0xc8>

template <typename T>
ALWAYS_INLINE
static inline void flush (T t)
{
    asm volatile ("clflush %0" : : "m" (*t) : "memory");
ffffffff81012342:	0f ae 3b             	clflush (%rbx)

template <typename P, typename E, unsigned L, unsigned B, bool F>
P *Pte<P, E, L, B, F>::walk(Quota &quota, E v, unsigned long n, bool a) {
    unsigned long l = L;

    for (P *p, *e = static_cast<P *> (this);; e = static_cast<P *> (Buddy::phys_to_ptr(e->addr())) + (v >> (--l * B + PAGE_BITS) & ((1UL << B) - 1))) {
ffffffff81012345:	48 ff cd             	dec    %rbp
        return static_cast<mword> (val) & PAGE_MASK;
    }

    ALWAYS_INLINE
    inline Paddr addr() const {
        return static_cast<Paddr> (val) & ~((1UL << order()) - 1);
ffffffff81012348:	48 8b 03             	mov    (%rbx),%rax
ffffffff8101234b:	4c 89 ea             	mov    %r13,%rdx
ffffffff8101234e:	8d 4c ed 00          	lea    0x0(%rbp,%rbp,8),%ecx
ffffffff81012352:	83 c1 0c             	add    $0xc,%ecx
ffffffff81012355:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8101235b:	48 d3 ea             	shr    %cl,%rdx
ffffffff8101235e:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
ffffffff81012364:	48 8d 9c d0 00 00 c0 	lea    -0x7f400000(%rax,%rdx,8),%rbx
ffffffff8101236b:	80 
ffffffff8101236c:	e9 61 ff ff ff       	jmpq   ffffffff810122d2 <_ZN3PteI3DptyLj4ELj9ELb1EE4walkER5Quotaymb+0x20>
ffffffff81012371:	48 89 d8             	mov    %rbx,%rax
ffffffff81012374:	eb 15                	jmp    ffffffff8101238b <_ZN3PteI3DptyLj4ELj9ELb1EE4walkER5Quotaymb+0xd9>
            return e;

        if (!e->val) {

            if (!a)
                return nullptr;
ffffffff81012376:	31 c0                	xor    %eax,%eax
ffffffff81012378:	eb 11                	jmp    ffffffff8101238b <_ZN3PteI3DptyLj4ELj9ELb1EE4walkER5Quotaymb+0xd9>
    }

    ALWAYS_INLINE
    static inline void destroy(Pte *obj, Quota &quota) {
        obj->~Pte();
        Buddy::allocator.free(reinterpret_cast<mword> (obj), quota);
ffffffff8101237a:	4c 89 e2             	mov    %r12,%rdx
ffffffff8101237d:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff81012384:	e8 25 f2 fe ff       	callq  ffffffff810015ae <_ZN5Buddy4freeEmR5Quota>
ffffffff81012389:	eb ba                	jmp    ffffffff81012345 <_ZN3PteI3DptyLj4ELj9ELb1EE4walkER5Quotaymb+0x93>

            if (!e->set(0, Buddy::ptr_to_phys(p = new (quota) P) | (l == L ? 0 : P::PTE_N)))
                Pte::destroy(p, quota);
        }
    }
}
ffffffff8101238b:	5a                   	pop    %rdx
ffffffff8101238c:	5b                   	pop    %rbx
ffffffff8101238d:	5d                   	pop    %rbp
ffffffff8101238e:	41 5c                	pop    %r12
ffffffff81012390:	41 5d                	pop    %r13
ffffffff81012392:	41 5e                	pop    %r14
ffffffff81012394:	41 5f                	pop    %r15
ffffffff81012396:	c3                   	retq   
ffffffff81012397:	90                   	nop

ffffffff81012398 <_ZN3PteI3DptyLj4ELj9ELb1EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE>:

    Pte::destroy(e, quota);
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
void Pte<P, E, L, B, F>::free_up(Quota &quota, unsigned l, P * e, mword v, bool (*d)(Paddr, mword, unsigned), bool (*il) (unsigned, mword)) {
ffffffff81012398:	41 57                	push   %r15
ffffffff8101239a:	41 56                	push   %r14
ffffffff8101239c:	41 55                	push   %r13
ffffffff8101239e:	41 54                	push   %r12
ffffffff810123a0:	55                   	push   %rbp
ffffffff810123a1:	53                   	push   %rbx
ffffffff810123a2:	48 83 ec 28          	sub    $0x28,%rsp
    if (!e)
ffffffff810123a6:	48 85 c9             	test   %rcx,%rcx

    Pte::destroy(e, quota);
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
void Pte<P, E, L, B, F>::free_up(Quota &quota, unsigned l, P * e, mword v, bool (*d)(Paddr, mword, unsigned), bool (*il) (unsigned, mword)) {
ffffffff810123a9:	4c 8b 7c 24 60       	mov    0x60(%rsp),%r15
    if (!e)
ffffffff810123ae:	0f 84 d0 00 00 00    	je     ffffffff81012484 <_ZN3PteI3DptyLj4ELj9ELb1EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0xec>
    for (unsigned long i = 0; i < (1 << B); i++) {
        if (!e[i].val || e[i].super())
            continue;

        P *p = static_cast<P *> (Buddy::phys_to_ptr(e[i].addr()));
        mword virt = v + (i << (l * B + PAGE_BITS));
ffffffff810123b4:	8d 04 d2             	lea    (%rdx,%rdx,8),%eax
ffffffff810123b7:	4d 89 cd             	mov    %r9,%r13
ffffffff810123ba:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
ffffffff810123bf:	49 89 cc             	mov    %rcx,%r12
ffffffff810123c2:	89 d3                	mov    %edx,%ebx
ffffffff810123c4:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
ffffffff810123c9:	83 c0 0c             	add    $0xc,%eax
ffffffff810123cc:	31 ed                	xor    %ebp,%ebp
ffffffff810123ce:	89 44 24 10          	mov    %eax,0x10(%rsp)

        if (il ? il(l, virt) : l > 1)
            p->free_up(quota, l - 1, p, virt, d, il);
ffffffff810123d2:	8d 42 ff             	lea    -0x1(%rdx),%eax
ffffffff810123d5:	89 44 24 14          	mov    %eax,0x14(%rsp)
void Pte<P, E, L, B, F>::free_up(Quota &quota, unsigned l, P * e, mword v, bool (*d)(Paddr, mword, unsigned), bool (*il) (unsigned, mword)) {
    if (!e)
        return;

    for (unsigned long i = 0; i < (1 << B); i++) {
        if (!e[i].val || e[i].super())
ffffffff810123d9:	49 8b 04 ec          	mov    (%r12,%rbp,8),%rax
ffffffff810123dd:	48 85 c0             	test   %rax,%rax
ffffffff810123e0:	74 71                	je     ffffffff81012453 <_ZN3PteI3DptyLj4ELj9ELb1EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0xbb>
ffffffff810123e2:	a8 80                	test   $0x80,%al
ffffffff810123e4:	75 6d                	jne    ffffffff81012453 <_ZN3PteI3DptyLj4ELj9ELb1EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0xbb>
            continue;

        P *p = static_cast<P *> (Buddy::phys_to_ptr(e[i].addr()));
        mword virt = v + (i << (l * B + PAGE_BITS));
ffffffff810123e6:	8a 4c 24 10          	mov    0x10(%rsp),%cl
        return static_cast<mword> (val) & PAGE_MASK;
    }

    ALWAYS_INLINE
    inline Paddr addr() const {
        return static_cast<Paddr> (val) & ~((1UL << order()) - 1);
ffffffff810123ea:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff810123f0:	49 89 ee             	mov    %rbp,%r14
        }

        ALWAYS_INLINE
        inline mword phys_to_virt (mword phys)
        {
            return phys + reinterpret_cast<mword>(&OFFSET);
ffffffff810123f3:	48 05 00 00 c0 80    	add    $0xffffffff80c00000,%rax
ffffffff810123f9:	48 89 04 24          	mov    %rax,(%rsp)
ffffffff810123fd:	49 d3 e6             	shl    %cl,%r14
ffffffff81012400:	4c 03 74 24 18       	add    0x18(%rsp),%r14

        if (il ? il(l, virt) : l > 1)
ffffffff81012405:	4d 85 ff             	test   %r15,%r15
ffffffff81012408:	74 5b                	je     ffffffff81012465 <_ZN3PteI3DptyLj4ELj9ELb1EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0xcd>
ffffffff8101240a:	4c 89 f6             	mov    %r14,%rsi
ffffffff8101240d:	89 df                	mov    %ebx,%edi
ffffffff8101240f:	41 ff d7             	callq  *%r15
ffffffff81012412:	84 c0                	test   %al,%al
ffffffff81012414:	74 21                	je     ffffffff81012437 <_ZN3PteI3DptyLj4ELj9ELb1EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0x9f>
            p->free_up(quota, l - 1, p, virt, d, il);
ffffffff81012416:	50                   	push   %rax
ffffffff81012417:	41 57                	push   %r15
ffffffff81012419:	4d 89 e9             	mov    %r13,%r9
ffffffff8101241c:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
ffffffff81012421:	8b 54 24 24          	mov    0x24(%rsp),%edx
ffffffff81012425:	4d 89 f0             	mov    %r14,%r8
ffffffff81012428:	48 8b 74 24 18       	mov    0x18(%rsp),%rsi
ffffffff8101242d:	48 89 cf             	mov    %rcx,%rdi
ffffffff81012430:	e8 63 ff ff ff       	callq  ffffffff81012398 <_ZN3PteI3DptyLj4ELj9ELb1EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE>
ffffffff81012435:	5a                   	pop    %rdx
ffffffff81012436:	59                   	pop    %rcx

        if (!d || d(e[i].addr(), virt, l))
ffffffff81012437:	4d 85 ed             	test   %r13,%r13
ffffffff8101243a:	74 31                	je     ffffffff8101246d <_ZN3PteI3DptyLj4ELj9ELb1EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0xd5>
ffffffff8101243c:	49 8b 3c ec          	mov    (%r12,%rbp,8),%rdi
ffffffff81012440:	89 da                	mov    %ebx,%edx
ffffffff81012442:	4c 89 f6             	mov    %r14,%rsi
ffffffff81012445:	48 81 e7 00 f0 ff ff 	and    $0xfffffffffffff000,%rdi
ffffffff8101244c:	41 ff d5             	callq  *%r13
ffffffff8101244f:	84 c0                	test   %al,%al
ffffffff81012451:	75 1a                	jne    ffffffff8101246d <_ZN3PteI3DptyLj4ELj9ELb1EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0xd5>
template <typename P, typename E, unsigned L, unsigned B, bool F>
void Pte<P, E, L, B, F>::free_up(Quota &quota, unsigned l, P * e, mword v, bool (*d)(Paddr, mword, unsigned), bool (*il) (unsigned, mword)) {
    if (!e)
        return;

    for (unsigned long i = 0; i < (1 << B); i++) {
ffffffff81012453:	48 ff c5             	inc    %rbp
ffffffff81012456:	48 81 fd 00 02 00 00 	cmp    $0x200,%rbp
ffffffff8101245d:	0f 85 76 ff ff ff    	jne    ffffffff810123d9 <_ZN3PteI3DptyLj4ELj9ELb1EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0x41>
ffffffff81012463:	eb 1f                	jmp    ffffffff81012484 <_ZN3PteI3DptyLj4ELj9ELb1EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0xec>
            continue;

        P *p = static_cast<P *> (Buddy::phys_to_ptr(e[i].addr()));
        mword virt = v + (i << (l * B + PAGE_BITS));

        if (il ? il(l, virt) : l > 1)
ffffffff81012465:	83 fb 01             	cmp    $0x1,%ebx
ffffffff81012468:	0f 97 c0             	seta   %al
ffffffff8101246b:	eb a5                	jmp    ffffffff81012412 <_ZN3PteI3DptyLj4ELj9ELb1EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0x7a>
    }

    ALWAYS_INLINE
    static inline void destroy(Pte *obj, Quota &quota) {
        obj->~Pte();
        Buddy::allocator.free(reinterpret_cast<mword> (obj), quota);
ffffffff8101246d:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
ffffffff81012472:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff81012476:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff8101247d:	e8 2c f1 fe ff       	callq  ffffffff810015ae <_ZN5Buddy4freeEmR5Quota>
ffffffff81012482:	eb cf                	jmp    ffffffff81012453 <_ZN3PteI3DptyLj4ELj9ELb1EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0xbb>
            p->free_up(quota, l - 1, p, virt, d, il);

        if (!d || d(e[i].addr(), virt, l))
            Pte::destroy(p, quota);
    }
}
ffffffff81012484:	48 83 c4 28          	add    $0x28,%rsp
ffffffff81012488:	5b                   	pop    %rbx
ffffffff81012489:	5d                   	pop    %rbp
ffffffff8101248a:	41 5c                	pop    %r12
ffffffff8101248c:	41 5d                	pop    %r13
ffffffff8101248e:	41 5e                	pop    %r14
ffffffff81012490:	41 5f                	pop    %r15
ffffffff81012492:	c3                   	retq   
ffffffff81012493:	90                   	nop

ffffffff81012494 <_ZN3PteI3DptyLj4ELj9ELb1EE5clearER5QuotaPFbmmjEPFbjmE>:

    return flush_tlb;
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
void Pte<P, E, L, B, F>::clear(Quota &quota, bool (*d) (Paddr, mword, unsigned), bool (*il) (unsigned, mword)) {
ffffffff81012494:	55                   	push   %rbp
ffffffff81012495:	53                   	push   %rbx
ffffffff81012496:	41 50                	push   %r8
    if (!val)
ffffffff81012498:	48 8b 1f             	mov    (%rdi),%rbx
ffffffff8101249b:	48 85 db             	test   %rbx,%rbx
ffffffff8101249e:	74 41                	je     ffffffff810124e1 <_ZN3PteI3DptyLj4ELj9ELb1EE5clearER5QuotaPFbmmjEPFbjmE+0x4d>
        return static_cast<mword> (val) & PAGE_MASK;
    }

    ALWAYS_INLINE
    inline Paddr addr() const {
        return static_cast<Paddr> (val) & ~((1UL << order()) - 1);
ffffffff810124a0:	48 81 e3 00 f0 ff ff 	and    $0xfffffffffffff000,%rbx
ffffffff810124a7:	49 89 d1             	mov    %rdx,%r9
        return;

    P * e = static_cast<P *> (Buddy::phys_to_ptr(this->addr()));

    e->free_up(quota, L - 1, e, 0, d, il);
ffffffff810124aa:	52                   	push   %rdx
ffffffff810124ab:	48 81 c3 00 00 c0 80 	add    $0xffffffff80c00000,%rbx
ffffffff810124b2:	51                   	push   %rcx
ffffffff810124b3:	ba 03 00 00 00       	mov    $0x3,%edx
ffffffff810124b8:	48 89 df             	mov    %rbx,%rdi
ffffffff810124bb:	48 89 d9             	mov    %rbx,%rcx
ffffffff810124be:	45 31 c0             	xor    %r8d,%r8d
ffffffff810124c1:	48 89 f5             	mov    %rsi,%rbp
ffffffff810124c4:	e8 cf fe ff ff       	callq  ffffffff81012398 <_ZN3PteI3DptyLj4ELj9ELb1EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE>

    Pte::destroy(e, quota);
}
ffffffff810124c9:	48 83 c4 18          	add    $0x18,%rsp
    }

    ALWAYS_INLINE
    static inline void destroy(Pte *obj, Quota &quota) {
        obj->~Pte();
        Buddy::allocator.free(reinterpret_cast<mword> (obj), quota);
ffffffff810124cd:	48 89 ea             	mov    %rbp,%rdx
ffffffff810124d0:	48 89 de             	mov    %rbx,%rsi
ffffffff810124d3:	5b                   	pop    %rbx
ffffffff810124d4:	5d                   	pop    %rbp
ffffffff810124d5:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff810124dc:	e9 cd f0 fe ff       	jmpq   ffffffff810015ae <_ZN5Buddy4freeEmR5Quota>
ffffffff810124e1:	58                   	pop    %rax
ffffffff810124e2:	5b                   	pop    %rbx
ffffffff810124e3:	5d                   	pop    %rbp
ffffffff810124e4:	c3                   	retq   

ffffffff810124e5 <_ZN3PteI3DptyLj4ELj9ELb1EE7is_mmioEy>:
mword Ept::ord = ~0UL;
mword Hpt::ord = ~0UL;

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P, E, L, B, F>::is_mmio(E p) {
    Cow::block *b = Cow::ram_mem_list;
ffffffff810124e5:	48 8b 05 0c f9 00 00 	mov    0xf90c(%rip),%rax        # ffffffff81021df8 <_ZN3Cow12ram_mem_listE>
    while (b != nullptr) {
ffffffff810124ec:	48 85 c0             	test   %rax,%rax
ffffffff810124ef:	74 11                	je     ffffffff81012502 <_ZN3PteI3DptyLj4ELj9ELb1EE7is_mmioEy+0x1d>
        //        Console::print("deb: %08lx  fin: %08lx  p: %08lx", b->start, b->end, p);
        if ((p >= b->start) && (p < b->end)) {
ffffffff810124f1:	48 3b 38             	cmp    (%rax),%rdi
ffffffff810124f4:	72 06                	jb     ffffffff810124fc <_ZN3PteI3DptyLj4ELj9ELb1EE7is_mmioEy+0x17>
ffffffff810124f6:	48 3b 78 08          	cmp    0x8(%rax),%rdi
ffffffff810124fa:	72 09                	jb     ffffffff81012505 <_ZN3PteI3DptyLj4ELj9ELb1EE7is_mmioEy+0x20>
            return false;
        }
        b = b->next;
ffffffff810124fc:	48 8b 40 18          	mov    0x18(%rax),%rax
ffffffff81012500:	eb ea                	jmp    ffffffff810124ec <_ZN3PteI3DptyLj4ELj9ELb1EE7is_mmioEy+0x7>
    }
    return true;
ffffffff81012502:	b0 01                	mov    $0x1,%al
ffffffff81012504:	c3                   	retq   
bool Pte<P, E, L, B, F>::is_mmio(E p) {
    Cow::block *b = Cow::ram_mem_list;
    while (b != nullptr) {
        //        Console::print("deb: %08lx  fin: %08lx  p: %08lx", b->start, b->end, p);
        if ((p >= b->start) && (p < b->end)) {
            return false;
ffffffff81012505:	31 c0                	xor    %eax,%eax
        }
        b = b->next;
    }
    return true;
}
ffffffff81012507:	c3                   	retq   

ffffffff81012508 <_ZN3PteI3DptyLj4ELj9ELb1EE12set_cow_pageEyRy>:
template <typename P, typename E, unsigned L, unsigned B, bool F>
/**
 * 
 *  */
void Pte<P, E, L, B, F>::set_cow_page(E virt, E &entry) {
    if ((virt < USER_ADDR) && (entry & P::PTE_P) && (entry & P::PTE_U)) {
ffffffff81012508:	48 b8 ff ef ff ff ff 	movabs $0x7fffffffefff,%rax
ffffffff8101250f:	7f 00 00 
ffffffff81012512:	48 39 c7             	cmp    %rax,%rdi
ffffffff81012515:	77 57                	ja     ffffffff8101256e <_ZN3PteI3DptyLj4ELj9ELb1EE12set_cow_pageEyRy+0x66>

template <typename P, typename E, unsigned L, unsigned B, bool F>
/**
 * 
 *  */
void Pte<P, E, L, B, F>::set_cow_page(E virt, E &entry) {
ffffffff81012517:	55                   	push   %rbp
ffffffff81012518:	53                   	push   %rbx
ffffffff81012519:	52                   	push   %rdx
    if ((virt < USER_ADDR) && (entry & P::PTE_P) && (entry & P::PTE_U)) {
ffffffff8101251a:	48 8b 1e             	mov    (%rsi),%rbx
ffffffff8101251d:	f6 c3 03             	test   $0x3,%bl
ffffffff81012520:	74 49                	je     ffffffff8101256b <_ZN3PteI3DptyLj4ELj9ELb1EE12set_cow_pageEyRy+0x63>
        if (is_mmio(entry & ~PAGE_MASK)) {
ffffffff81012522:	48 89 df             	mov    %rbx,%rdi
ffffffff81012525:	48 89 f5             	mov    %rsi,%rbp
ffffffff81012528:	48 81 e7 00 f0 ff ff 	and    $0xfffffffffffff000,%rdi
ffffffff8101252f:	e8 b1 ff ff ff       	callq  ffffffff810124e5 <_ZN3PteI3DptyLj4ELj9ELb1EE7is_mmioEy>
ffffffff81012534:	84 c0                	test   %al,%al
ffffffff81012536:	74 10                	je     ffffffff81012548 <_ZN3PteI3DptyLj4ELj9ELb1EE12set_cow_pageEyRy+0x40>
            entry |= P::PTE_COW | P::PTE_COW_IO;
            entry &= ~P::PTE_P;
ffffffff81012538:	48 83 e3 fc          	and    $0xfffffffffffffffc,%rbx
ffffffff8101253c:	48 b8 00 00 00 00 00 	movabs $0x1800000000000000,%rax
ffffffff81012543:	00 00 18 
ffffffff81012546:	eb 1c                	jmp    ffffffff81012564 <_ZN3PteI3DptyLj4ELj9ELb1EE12set_cow_pageEyRy+0x5c>
        } else if (entry & P::PTE_W) {
ffffffff81012548:	f6 c3 02             	test   $0x2,%bl
ffffffff8101254b:	74 1e                	je     ffffffff8101256b <_ZN3PteI3DptyLj4ELj9ELb1EE12set_cow_pageEyRy+0x63>
            entry |= P::PTE_COW;
            entry &= ~P::PTE_COW_IO;
            entry &= ~P::PTE_W;
ffffffff8101254d:	48 b8 fd ff ff ff ff 	movabs $0xf7fffffffffffffd,%rax
ffffffff81012554:	ff ff f7 
ffffffff81012557:	48 21 c3             	and    %rax,%rbx
ffffffff8101255a:	48 b8 00 00 00 00 00 	movabs $0x1000000000000000,%rax
ffffffff81012561:	00 00 10 
ffffffff81012564:	48 09 c3             	or     %rax,%rbx
ffffffff81012567:	48 89 5d 00          	mov    %rbx,0x0(%rbp)
        }
    }
}
ffffffff8101256b:	58                   	pop    %rax
ffffffff8101256c:	5b                   	pop    %rbx
ffffffff8101256d:	5d                   	pop    %rbp
ffffffff8101256e:	c3                   	retq   
ffffffff8101256f:	90                   	nop

ffffffff81012570 <_ZN3PteI3DptyLj4ELj9ELb1EE6updateER5QuotaymymNS1_4TypeEb>:
        return s;
    }
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P, E, L, B, F>::update(Quota &quota, E v, mword o, E p, mword a, Type t, bool set_cow) {
ffffffff81012570:	41 57                	push   %r15
    unsigned long l = o / B, n = 1UL << o % B, s;
ffffffff81012572:	48 89 c8             	mov    %rcx,%rax
        return s;
    }
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P, E, L, B, F>::update(Quota &quota, E v, mword o, E p, mword a, Type t, bool set_cow) {
ffffffff81012575:	41 56                	push   %r14
ffffffff81012577:	49 89 d6             	mov    %rdx,%r14
ffffffff8101257a:	41 55                	push   %r13
    unsigned long l = o / B, n = 1UL << o % B, s;
ffffffff8101257c:	31 d2                	xor    %edx,%edx
        return s;
    }
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P, E, L, B, F>::update(Quota &quota, E v, mword o, E p, mword a, Type t, bool set_cow) {
ffffffff8101257e:	41 54                	push   %r12
ffffffff81012580:	55                   	push   %rbp
    unsigned long l = o / B, n = 1UL << o % B, s;
ffffffff81012581:	bd 01 00 00 00       	mov    $0x1,%ebp
        return s;
    }
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P, E, L, B, F>::update(Quota &quota, E v, mword o, E p, mword a, Type t, bool set_cow) {
ffffffff81012586:	53                   	push   %rbx
    unsigned long l = o / B, n = 1UL << o % B, s;
ffffffff81012587:	bb 09 00 00 00       	mov    $0x9,%ebx
        return s;
    }
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P, E, L, B, F>::update(Quota &quota, E v, mword o, E p, mword a, Type t, bool set_cow) {
ffffffff8101258c:	49 89 f5             	mov    %rsi,%r13
    unsigned long l = o / B, n = 1UL << o % B, s;
ffffffff8101258f:	48 f7 f3             	div    %rbx
        return s;
    }
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P, E, L, B, F>::update(Quota &quota, E v, mword o, E p, mword a, Type t, bool set_cow) {
ffffffff81012592:	48 83 ec 28          	sub    $0x28,%rsp
ffffffff81012596:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
    unsigned long l = o / B, n = 1UL << o % B, s;

    P *e = walk(quota, v, l, t == TYPE_UP);
ffffffff8101259b:	45 31 c0             	xor    %r8d,%r8d
        return s;
    }
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P, E, L, B, F>::update(Quota &quota, E v, mword o, E p, mword a, Type t, bool set_cow) {
ffffffff8101259e:	4c 89 4c 24 10       	mov    %r9,0x10(%rsp)
ffffffff810125a3:	44 8b 7c 24 68       	mov    0x68(%rsp),%r15d
    unsigned long l = o / B, n = 1UL << o % B, s;
ffffffff810125a8:	48 89 d1             	mov    %rdx,%rcx
ffffffff810125ab:	49 89 c4             	mov    %rax,%r12
ffffffff810125ae:	48 89 e8             	mov    %rbp,%rax
ffffffff810125b1:	48 d3 e0             	shl    %cl,%rax

    P *e = walk(quota, v, l, t == TYPE_UP);
ffffffff810125b4:	83 7c 24 60 00       	cmpl   $0x0,0x60(%rsp)
ffffffff810125b9:	4c 89 e1             	mov    %r12,%rcx
ffffffff810125bc:	4c 89 f2             	mov    %r14,%rdx
    }
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P, E, L, B, F>::update(Quota &quota, E v, mword o, E p, mword a, Type t, bool set_cow) {
    unsigned long l = o / B, n = 1UL << o % B, s;
ffffffff810125bf:	48 89 44 24 08       	mov    %rax,0x8(%rsp)

    P *e = walk(quota, v, l, t == TYPE_UP);
ffffffff810125c4:	41 0f 94 c0          	sete   %r8b
ffffffff810125c8:	e8 e5 fc ff ff       	callq  ffffffff810122b2 <_ZN3PteI3DptyLj4ELj9ELb1EE4walkER5Quotaymb>
ffffffff810125cd:	48 89 c3             	mov    %rax,%rbx

    if (!e)
        return false;
ffffffff810125d0:	31 c0                	xor    %eax,%eax
bool Pte<P, E, L, B, F>::update(Quota &quota, E v, mword o, E p, mword a, Type t, bool set_cow) {
    unsigned long l = o / B, n = 1UL << o % B, s;

    P *e = walk(quota, v, l, t == TYPE_UP);

    if (!e)
ffffffff810125d2:	48 85 db             	test   %rbx,%rbx
ffffffff810125d5:	0f 84 ea 00 00 00    	je     ffffffff810126c5 <_ZN3PteI3DptyLj4ELj9ELb1EE6updateER5QuotaymymNS1_4TypeEb+0x155>
        return false;

    if (a) {
ffffffff810125db:	4c 8b 4c 24 10       	mov    0x10(%rsp),%r9
ffffffff810125e0:	4d 85 c9             	test   %r9,%r9
ffffffff810125e3:	74 3a                	je     ffffffff8101261f <_ZN3PteI3DptyLj4ELj9ELb1EE6updateER5QuotaymymNS1_4TypeEb+0xaf>
        p |= P::order(o % B) | (l ? P::PTE_S : 0) | a;
ffffffff810125e5:	49 83 fc 01          	cmp    $0x1,%r12
        s = 1UL << (l * B + PAGE_BITS);
ffffffff810125e9:	43 8d 0c e4          	lea    (%r12,%r12,8),%ecx

    if (!e)
        return false;

    if (a) {
        p |= P::order(o % B) | (l ? P::PTE_S : 0) | a;
ffffffff810125ed:	48 19 c0             	sbb    %rax,%rax
ffffffff810125f0:	4c 0b 4c 24 18       	or     0x18(%rsp),%r9
ffffffff810125f5:	48 f7 d0             	not    %rax
        s = 1UL << (l * B + PAGE_BITS);
ffffffff810125f8:	83 c1 0c             	add    $0xc,%ecx

    if (!e)
        return false;

    if (a) {
        p |= P::order(o % B) | (l ? P::PTE_S : 0) | a;
ffffffff810125fb:	25 80 00 00 00       	and    $0x80,%eax
        s = 1UL << (l * B + PAGE_BITS);
ffffffff81012600:	48 d3 e5             	shl    %cl,%rbp

    if (!e)
        return false;

    if (a) {
        p |= P::order(o % B) | (l ? P::PTE_S : 0) | a;
ffffffff81012603:	4c 09 c8             	or     %r9,%rax
        s = 1UL << (l * B + PAGE_BITS);
        if (set_cow) {
ffffffff81012606:	45 84 ff             	test   %r15b,%r15b

    if (!e)
        return false;

    if (a) {
        p |= P::order(o % B) | (l ? P::PTE_S : 0) | a;
ffffffff81012609:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
        s = 1UL << (l * B + PAGE_BITS);
        if (set_cow) {
ffffffff8101260e:	74 1a                	je     ffffffff8101262a <_ZN3PteI3DptyLj4ELj9ELb1EE6updateER5QuotaymymNS1_4TypeEb+0xba>
            set_cow_page(v, p);
ffffffff81012610:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi
ffffffff81012615:	4c 89 f7             	mov    %r14,%rdi
ffffffff81012618:	e8 eb fe ff ff       	callq  ffffffff81012508 <_ZN3PteI3DptyLj4ELj9ELb1EE12set_cow_pageEyRy>
ffffffff8101261d:	eb 0b                	jmp    ffffffff8101262a <_ZN3PteI3DptyLj4ELj9ELb1EE6updateER5QuotaymymNS1_4TypeEb+0xba>
        }
    } else
        p = s = 0;
ffffffff8101261f:	48 c7 44 24 18 00 00 	movq   $0x0,0x18(%rsp)
ffffffff81012626:	00 00 
ffffffff81012628:	31 ed                	xor    %ebp,%ebp
ffffffff8101262a:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
ffffffff8101262f:	49 89 de             	mov    %rbx,%r14

    bool flush_tlb = false;
ffffffff81012632:	31 ff                	xor    %edi,%edi

    for (unsigned long i = 0; i < n; e[i].val = p, i++, p += s) {

        if (l && e[i].val != p)
            flush_tlb = true;
ffffffff81012634:	b1 01                	mov    $0x1,%cl
ffffffff81012636:	4c 8d 3c c3          	lea    (%rbx,%rax,8),%r15

    bool flush_tlb = false;

    for (unsigned long i = 0; i < n; e[i].val = p, i++, p += s) {

        if (l && e[i].val != p)
ffffffff8101263a:	4d 85 e4             	test   %r12,%r12
ffffffff8101263d:	74 0b                	je     ffffffff8101264a <_ZN3PteI3DptyLj4ELj9ELb1EE6updateER5QuotaymymNS1_4TypeEb+0xda>
            flush_tlb = true;
ffffffff8101263f:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
ffffffff81012644:	49 39 06             	cmp    %rax,(%r14)
ffffffff81012647:	0f 45 f9             	cmovne %ecx,%edi

        if (!e[i].val)
ffffffff8101264a:	49 8b 36             	mov    (%r14),%rsi
ffffffff8101264d:	48 85 f6             	test   %rsi,%rsi
ffffffff81012650:	41 0f 94 c0          	sete   %r8b
            continue;

        if (t == TYPE_DF)
ffffffff81012654:	83 7c 24 60 02       	cmpl   $0x2,0x60(%rsp)
ffffffff81012659:	0f 94 c2             	sete   %dl
ffffffff8101265c:	44 09 c2             	or     %r8d,%edx
            continue;

        if (l && !e[i].super()) {
ffffffff8101265f:	4d 85 e4             	test   %r12,%r12
ffffffff81012662:	41 0f 95 c0          	setne  %r8b
ffffffff81012666:	44 38 c2             	cmp    %r8b,%dl
ffffffff81012669:	73 06                	jae    ffffffff81012671 <_ZN3PteI3DptyLj4ELj9ELb1EE6updateER5QuotaymymNS1_4TypeEb+0x101>
ffffffff8101266b:	40 f6 c6 80          	test   $0x80,%sil
ffffffff8101266f:	74 2a                	je     ffffffff8101269b <_ZN3PteI3DptyLj4ELj9ELb1EE6updateER5QuotaymymNS1_4TypeEb+0x12b>
    } else
        p = s = 0;

    bool flush_tlb = false;

    for (unsigned long i = 0; i < n; e[i].val = p, i++, p += s) {
ffffffff81012671:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
ffffffff81012676:	49 83 c6 08          	add    $0x8,%r14
ffffffff8101267a:	49 89 56 f8          	mov    %rdx,-0x8(%r14)
ffffffff8101267e:	48 01 6c 24 18       	add    %rbp,0x18(%rsp)
ffffffff81012683:	4d 39 fe             	cmp    %r15,%r14
ffffffff81012686:	75 b2                	jne    ffffffff8101263a <_ZN3PteI3DptyLj4ELj9ELb1EE6updateER5QuotaymymNS1_4TypeEb+0xca>
}

ALWAYS_INLINE NONNULL
inline void *flush (void *d, size_t n)
{
    for (char *p = static_cast<char *>(d); p < static_cast<char *>(d) + n; p += 32)
ffffffff81012688:	4c 39 fb             	cmp    %r15,%rbx
ffffffff8101268b:	73 09                	jae    ffffffff81012696 <_ZN3PteI3DptyLj4ELj9ELb1EE6updateER5QuotaymymNS1_4TypeEb+0x126>

template <typename T>
ALWAYS_INLINE
static inline void flush (T t)
{
    asm volatile ("clflush %0" : : "m" (*t) : "memory");
ffffffff8101268d:	0f ae 3b             	clflush (%rbx)
}

ALWAYS_INLINE NONNULL
inline void *flush (void *d, size_t n)
{
    for (char *p = static_cast<char *>(d); p < static_cast<char *>(d) + n; p += 32)
ffffffff81012690:	48 83 c3 20          	add    $0x20,%rbx
ffffffff81012694:	eb f2                	jmp    ffffffff81012688 <_ZN3PteI3DptyLj4ELj9ELb1EE6updateER5QuotaymymNS1_4TypeEb+0x118>
ffffffff81012696:	40 88 f8             	mov    %dil,%al
ffffffff81012699:	eb 2a                	jmp    ffffffff810126c5 <_ZN3PteI3DptyLj4ELj9ELb1EE6updateER5QuotaymymNS1_4TypeEb+0x155>
        return static_cast<mword> (val) & PAGE_MASK;
    }

    ALWAYS_INLINE
    inline Paddr addr() const {
        return static_cast<Paddr> (val) & ~((1UL << order()) - 1);
ffffffff8101269b:	48 81 e6 00 f0 ff ff 	and    $0xfffffffffffff000,%rsi
    }

    ALWAYS_INLINE
    static inline void destroy(Pte *obj, Quota &quota) {
        obj->~Pte();
        Buddy::allocator.free(reinterpret_cast<mword> (obj), quota);
ffffffff810126a2:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff810126a9:	4c 89 ea             	mov    %r13,%rdx
ffffffff810126ac:	48 81 c6 00 00 c0 80 	add    $0xffffffff80c00000,%rsi
ffffffff810126b3:	88 4c 24 08          	mov    %cl,0x8(%rsp)
ffffffff810126b7:	e8 f2 ee fe ff       	callq  ffffffff810015ae <_ZN5Buddy4freeEmR5Quota>
        if (t == TYPE_DF)
            continue;

        if (l && !e[i].super()) {
            Pte::destroy(static_cast<P *> (Buddy::phys_to_ptr(e[i].addr())), quota);
            flush_tlb = true;
ffffffff810126bc:	40 b7 01             	mov    $0x1,%dil
ffffffff810126bf:	8a 4c 24 08          	mov    0x8(%rsp),%cl
ffffffff810126c3:	eb ac                	jmp    ffffffff81012671 <_ZN3PteI3DptyLj4ELj9ELb1EE6updateER5QuotaymymNS1_4TypeEb+0x101>

    if (F)
        flush(e, n * sizeof (E));

    return flush_tlb;
}
ffffffff810126c5:	48 83 c4 28          	add    $0x28,%rsp
ffffffff810126c9:	5b                   	pop    %rbx
ffffffff810126ca:	5d                   	pop    %rbp
ffffffff810126cb:	41 5c                	pop    %r12
ffffffff810126cd:	41 5d                	pop    %r13
ffffffff810126cf:	41 5e                	pop    %r14
ffffffff810126d1:	41 5f                	pop    %r15
ffffffff810126d3:	c3                   	retq   

ffffffff810126d4 <_ZN3PteI3EptyLj4ELj9ELb0EE4walkER5Quotaymb>:
    }
    return true;
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
P *Pte<P, E, L, B, F>::walk(Quota &quota, E v, unsigned long n, bool a) {
ffffffff810126d4:	41 57                	push   %r15
ffffffff810126d6:	41 56                	push   %r14
ffffffff810126d8:	49 89 cf             	mov    %rcx,%r15
ffffffff810126db:	41 55                	push   %r13
ffffffff810126dd:	41 54                	push   %r12
ffffffff810126df:	49 89 d6             	mov    %rdx,%r14
ffffffff810126e2:	55                   	push   %rbp
ffffffff810126e3:	53                   	push   %rbx
ffffffff810126e4:	49 89 f4             	mov    %rsi,%r12
ffffffff810126e7:	41 51                	push   %r9
ffffffff810126e9:	45 88 c5             	mov    %r8b,%r13b
    unsigned long l = L;

    for (P *p, *e = static_cast<P *> (this);; e = static_cast<P *> (Buddy::phys_to_ptr(e->addr())) + (v >> (--l * B + PAGE_BITS) & ((1UL << B) - 1))) {
ffffffff810126ec:	48 89 fb             	mov    %rdi,%rbx
    return true;
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
P *Pte<P, E, L, B, F>::walk(Quota &quota, E v, unsigned long n, bool a) {
    unsigned long l = L;
ffffffff810126ef:	bd 04 00 00 00       	mov    $0x4,%ebp

    for (P *p, *e = static_cast<P *> (this);; e = static_cast<P *> (Buddy::phys_to_ptr(e->addr())) + (v >> (--l * B + PAGE_BITS) & ((1UL << B) - 1))) {

        if (l == n)
ffffffff810126f4:	4c 39 fd             	cmp    %r15,%rbp
ffffffff810126f7:	0f 84 8e 00 00 00    	je     ffffffff8101278b <_ZN3PteI3EptyLj4ELj9ELb0EE4walkER5Quotaymb+0xb7>
            return e;

        if (!e->val) {
ffffffff810126fd:	48 83 3b 00          	cmpq   $0x0,(%rbx)
ffffffff81012701:	75 5c                	jne    ffffffff8101275f <_ZN3PteI3EptyLj4ELj9ELb0EE4walkER5Quotaymb+0x8b>

            if (!a)
ffffffff81012703:	45 84 ed             	test   %r13b,%r13b
ffffffff81012706:	0f 84 84 00 00 00    	je     ffffffff81012790 <_ZN3PteI3EptyLj4ELj9ELb0EE4walkER5Quotaymb+0xbc>
        return b;
    }

    ALWAYS_INLINE
    static inline void *operator new (size_t, Quota &quota) {
        void *p = Buddy::allocator.alloc(0, quota, Buddy::FILL_0);
ffffffff8101270c:	4c 89 e2             	mov    %r12,%rdx
ffffffff8101270f:	31 f6                	xor    %esi,%esi
ffffffff81012711:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff81012716:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff8101271d:	e8 d0 f1 fe ff       	callq  ffffffff810018f2 <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
                return nullptr;

            if (!e->set(0, Buddy::ptr_to_phys(p = new (quota) P) | (l == L ? 0 : P::PTE_N)))
ffffffff81012722:	bf 00 00 00 00       	mov    $0x0,%edi
ffffffff81012727:	48 89 c6             	mov    %rax,%rsi

    void free_up(Quota &quota, unsigned l, P *, mword, bool (*) (Paddr, mword, unsigned), bool (*) (unsigned, mword));

public:

    Pte() : val(0) {
ffffffff8101272a:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
ffffffff81012731:	ba 07 00 00 00       	mov    $0x7,%edx
        }

        ALWAYS_INLINE
        inline mword virt_to_phys (mword virt)
        {
            return virt - reinterpret_cast<mword>(&OFFSET);
ffffffff81012736:	48 2d 00 00 c0 80    	sub    $0xffffffff80c00000,%rax
ffffffff8101273c:	48 83 fd 04          	cmp    $0x4,%rbp
ffffffff81012740:	48 0f 44 d7          	cmove  %rdi,%rdx
ffffffff81012744:	48 09 c2             	or     %rax,%rdx
ffffffff81012747:	31 c0                	xor    %eax,%eax
ffffffff81012749:	f0 48 0f b1 13       	lock cmpxchg %rdx,(%rbx)
ffffffff8101274e:	74 0f                	je     ffffffff8101275f <_ZN3PteI3EptyLj4ELj9ELb0EE4walkER5Quotaymb+0x8b>
    }

    ALWAYS_INLINE
    static inline void destroy(Pte *obj, Quota &quota) {
        obj->~Pte();
        Buddy::allocator.free(reinterpret_cast<mword> (obj), quota);
ffffffff81012750:	4c 89 e2             	mov    %r12,%rdx
ffffffff81012753:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff8101275a:	e8 4f ee fe ff       	callq  ffffffff810015ae <_ZN5Buddy4freeEmR5Quota>

template <typename P, typename E, unsigned L, unsigned B, bool F>
P *Pte<P, E, L, B, F>::walk(Quota &quota, E v, unsigned long n, bool a) {
    unsigned long l = L;

    for (P *p, *e = static_cast<P *> (this);; e = static_cast<P *> (Buddy::phys_to_ptr(e->addr())) + (v >> (--l * B + PAGE_BITS) & ((1UL << B) - 1))) {
ffffffff8101275f:	48 ff cd             	dec    %rbp
        return static_cast<mword> (val) & PAGE_MASK;
    }

    ALWAYS_INLINE
    inline Paddr addr() const {
        return static_cast<Paddr> (val) & ~((1UL << order()) - 1);
ffffffff81012762:	48 8b 03             	mov    (%rbx),%rax
ffffffff81012765:	4c 89 f2             	mov    %r14,%rdx
ffffffff81012768:	8d 4c ed 00          	lea    0x0(%rbp,%rbp,8),%ecx
ffffffff8101276c:	83 c1 0c             	add    $0xc,%ecx
ffffffff8101276f:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81012775:	48 d3 ea             	shr    %cl,%rdx
ffffffff81012778:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
ffffffff8101277e:	48 8d 9c d0 00 00 c0 	lea    -0x7f400000(%rax,%rdx,8),%rbx
ffffffff81012785:	80 
ffffffff81012786:	e9 69 ff ff ff       	jmpq   ffffffff810126f4 <_ZN3PteI3EptyLj4ELj9ELb0EE4walkER5Quotaymb+0x20>
ffffffff8101278b:	48 89 d8             	mov    %rbx,%rax
ffffffff8101278e:	eb 02                	jmp    ffffffff81012792 <_ZN3PteI3EptyLj4ELj9ELb0EE4walkER5Quotaymb+0xbe>
            return e;

        if (!e->val) {

            if (!a)
                return nullptr;
ffffffff81012790:	31 c0                	xor    %eax,%eax

            if (!e->set(0, Buddy::ptr_to_phys(p = new (quota) P) | (l == L ? 0 : P::PTE_N)))
                Pte::destroy(p, quota);
        }
    }
}
ffffffff81012792:	5a                   	pop    %rdx
ffffffff81012793:	5b                   	pop    %rbx
ffffffff81012794:	5d                   	pop    %rbp
ffffffff81012795:	41 5c                	pop    %r12
ffffffff81012797:	41 5d                	pop    %r13
ffffffff81012799:	41 5e                	pop    %r14
ffffffff8101279b:	41 5f                	pop    %r15
ffffffff8101279d:	c3                   	retq   

ffffffff8101279e <_ZN3PteI3EptyLj4ELj9ELb0EE6lookupEyRmS2_>:

template <typename P, typename E, unsigned L, unsigned B, bool F>
size_t Pte<P, E, L, B, F>::lookup(E v, Paddr &p, mword &a) {
ffffffff8101279e:	49 89 c9             	mov    %rcx,%r9
    unsigned long l = L;
ffffffff810127a1:	b8 04 00 00 00       	mov    $0x4,%eax

    for (P *e = static_cast<P *> (this);; e = static_cast<P *> (Buddy::phys_to_ptr(e->addr())) + (v >> (--l * B + PAGE_BITS) & ((1UL << B) - 1))) {

        if (EXPECT_FALSE(!e->val))
ffffffff810127a6:	4c 8b 07             	mov    (%rdi),%r8
ffffffff810127a9:	4d 85 c0             	test   %r8,%r8
ffffffff810127ac:	74 34                	je     ffffffff810127e2 <_ZN3PteI3EptyLj4ELj9ELb0EE6lookupEyRmS2_+0x44>
            return 0;

        if (EXPECT_FALSE(l && !e->super()))
ffffffff810127ae:	48 85 c0             	test   %rax,%rax
ffffffff810127b1:	74 32                	je     ffffffff810127e5 <_ZN3PteI3EptyLj4ELj9ELb0EE6lookupEyRmS2_+0x47>
ffffffff810127b3:	41 f6 c0 80          	test   $0x80,%r8b
ffffffff810127b7:	75 2c                	jne    ffffffff810127e5 <_ZN3PteI3EptyLj4ELj9ELb0EE6lookupEyRmS2_+0x47>

template <typename P, typename E, unsigned L, unsigned B, bool F>
size_t Pte<P, E, L, B, F>::lookup(E v, Paddr &p, mword &a) {
    unsigned long l = L;

    for (P *e = static_cast<P *> (this);; e = static_cast<P *> (Buddy::phys_to_ptr(e->addr())) + (v >> (--l * B + PAGE_BITS) & ((1UL << B) - 1))) {
ffffffff810127b9:	48 ff c8             	dec    %rax
ffffffff810127bc:	48 89 f7             	mov    %rsi,%rdi
ffffffff810127bf:	49 81 e0 00 f0 ff ff 	and    $0xfffffffffffff000,%r8
ffffffff810127c6:	8d 0c c0             	lea    (%rax,%rax,8),%ecx
ffffffff810127c9:	83 c1 0c             	add    $0xc,%ecx
ffffffff810127cc:	48 d3 ef             	shr    %cl,%rdi
ffffffff810127cf:	48 89 f9             	mov    %rdi,%rcx
ffffffff810127d2:	81 e1 ff 01 00 00    	and    $0x1ff,%ecx
ffffffff810127d8:	49 8d bc c8 00 00 c0 	lea    -0x7f400000(%r8,%rcx,8),%rdi
ffffffff810127df:	80 
ffffffff810127e0:	eb c4                	jmp    ffffffff810127a6 <_ZN3PteI3EptyLj4ELj9ELb0EE6lookupEyRmS2_+0x8>

        if (EXPECT_FALSE(!e->val))
            return 0;
ffffffff810127e2:	31 c0                	xor    %eax,%eax
ffffffff810127e4:	c3                   	retq   
        return a ? t << 3 | a | EPT_I | EPT_R : 0;
    }

    ALWAYS_INLINE
    inline mword order() const {
        return PAGE_BITS + (static_cast<mword> (val) >> 8 & 0xf);
ffffffff810127e5:	4c 89 c1             	mov    %r8,%rcx

        if (EXPECT_FALSE(l && !e->super()))
            continue;

        size_t s = 1UL << (l * B + e->order());
ffffffff810127e8:	8d 04 c0             	lea    (%rax,%rax,8),%eax
ffffffff810127eb:	49 81 e0 00 f0 ff ff 	and    $0xfffffffffffff000,%r8
ffffffff810127f2:	48 c1 e9 08          	shr    $0x8,%rcx
ffffffff810127f6:	83 e1 0f             	and    $0xf,%ecx
ffffffff810127f9:	8d 4c 08 0c          	lea    0xc(%rax,%rcx,1),%ecx
ffffffff810127fd:	b8 01 00 00 00       	mov    $0x1,%eax
ffffffff81012802:	48 d3 e0             	shl    %cl,%rax

        p = static_cast<Paddr> (e->addr() | (v & (s - 1)));
ffffffff81012805:	48 8d 48 ff          	lea    -0x1(%rax),%rcx
ffffffff81012809:	48 21 ce             	and    %rcx,%rsi
ffffffff8101280c:	49 09 f0             	or     %rsi,%r8
ffffffff8101280f:	4c 89 02             	mov    %r8,(%rdx)
        return val & P::PTE_S;
    }

    ALWAYS_INLINE
    inline mword attr() const {
        return static_cast<mword> (val) & PAGE_MASK;
ffffffff81012812:	48 8b 17             	mov    (%rdi),%rdx
ffffffff81012815:	81 e2 ff 0f 00 00    	and    $0xfff,%edx

        a = e->attr();
ffffffff8101281b:	49 89 11             	mov    %rdx,(%r9)

        return s;
    }
}
ffffffff8101281e:	c3                   	retq   

ffffffff8101281f <_ZN3PteI3EptyLj4ELj9ELb0EE7is_mmioEy>:
mword Ept::ord = ~0UL;
mword Hpt::ord = ~0UL;

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P, E, L, B, F>::is_mmio(E p) {
    Cow::block *b = Cow::ram_mem_list;
ffffffff8101281f:	48 8b 05 d2 f5 00 00 	mov    0xf5d2(%rip),%rax        # ffffffff81021df8 <_ZN3Cow12ram_mem_listE>
    while (b != nullptr) {
ffffffff81012826:	48 85 c0             	test   %rax,%rax
ffffffff81012829:	74 11                	je     ffffffff8101283c <_ZN3PteI3EptyLj4ELj9ELb0EE7is_mmioEy+0x1d>
        //        Console::print("deb: %08lx  fin: %08lx  p: %08lx", b->start, b->end, p);
        if ((p >= b->start) && (p < b->end)) {
ffffffff8101282b:	48 3b 38             	cmp    (%rax),%rdi
ffffffff8101282e:	72 06                	jb     ffffffff81012836 <_ZN3PteI3EptyLj4ELj9ELb0EE7is_mmioEy+0x17>
ffffffff81012830:	48 3b 78 08          	cmp    0x8(%rax),%rdi
ffffffff81012834:	72 09                	jb     ffffffff8101283f <_ZN3PteI3EptyLj4ELj9ELb0EE7is_mmioEy+0x20>
            return false;
        }
        b = b->next;
ffffffff81012836:	48 8b 40 18          	mov    0x18(%rax),%rax
ffffffff8101283a:	eb ea                	jmp    ffffffff81012826 <_ZN3PteI3EptyLj4ELj9ELb0EE7is_mmioEy+0x7>
    }
    return true;
ffffffff8101283c:	b0 01                	mov    $0x1,%al
ffffffff8101283e:	c3                   	retq   
bool Pte<P, E, L, B, F>::is_mmio(E p) {
    Cow::block *b = Cow::ram_mem_list;
    while (b != nullptr) {
        //        Console::print("deb: %08lx  fin: %08lx  p: %08lx", b->start, b->end, p);
        if ((p >= b->start) && (p < b->end)) {
            return false;
ffffffff8101283f:	31 c0                	xor    %eax,%eax
        }
        b = b->next;
    }
    return true;
}
ffffffff81012841:	c3                   	retq   

ffffffff81012842 <_ZN3PteI3EptyLj4ELj9ELb0EE12set_cow_pageEyRy>:
template <typename P, typename E, unsigned L, unsigned B, bool F>
/**
 * 
 *  */
void Pte<P, E, L, B, F>::set_cow_page(E virt, E &entry) {
    if ((virt < USER_ADDR) && (entry & P::PTE_P) && (entry & P::PTE_U)) {
ffffffff81012842:	48 b8 ff ef ff ff ff 	movabs $0x7fffffffefff,%rax
ffffffff81012849:	7f 00 00 
ffffffff8101284c:	48 39 c7             	cmp    %rax,%rdi
ffffffff8101284f:	77 57                	ja     ffffffff810128a8 <_ZN3PteI3EptyLj4ELj9ELb0EE12set_cow_pageEyRy+0x66>

template <typename P, typename E, unsigned L, unsigned B, bool F>
/**
 * 
 *  */
void Pte<P, E, L, B, F>::set_cow_page(E virt, E &entry) {
ffffffff81012851:	55                   	push   %rbp
ffffffff81012852:	53                   	push   %rbx
ffffffff81012853:	52                   	push   %rdx
    if ((virt < USER_ADDR) && (entry & P::PTE_P) && (entry & P::PTE_U)) {
ffffffff81012854:	48 8b 1e             	mov    (%rsi),%rbx
ffffffff81012857:	f6 c3 07             	test   $0x7,%bl
ffffffff8101285a:	74 49                	je     ffffffff810128a5 <_ZN3PteI3EptyLj4ELj9ELb0EE12set_cow_pageEyRy+0x63>
        if (is_mmio(entry & ~PAGE_MASK)) {
ffffffff8101285c:	48 89 df             	mov    %rbx,%rdi
ffffffff8101285f:	48 89 f5             	mov    %rsi,%rbp
ffffffff81012862:	48 81 e7 00 f0 ff ff 	and    $0xfffffffffffff000,%rdi
ffffffff81012869:	e8 b1 ff ff ff       	callq  ffffffff8101281f <_ZN3PteI3EptyLj4ELj9ELb0EE7is_mmioEy>
ffffffff8101286e:	84 c0                	test   %al,%al
ffffffff81012870:	74 10                	je     ffffffff81012882 <_ZN3PteI3EptyLj4ELj9ELb0EE12set_cow_pageEyRy+0x40>
            entry |= P::PTE_COW | P::PTE_COW_IO;
            entry &= ~P::PTE_P;
ffffffff81012872:	48 83 e3 f8          	and    $0xfffffffffffffff8,%rbx
ffffffff81012876:	48 b8 00 00 00 00 00 	movabs $0x1800000000000000,%rax
ffffffff8101287d:	00 00 18 
ffffffff81012880:	eb 1c                	jmp    ffffffff8101289e <_ZN3PteI3EptyLj4ELj9ELb0EE12set_cow_pageEyRy+0x5c>
        } else if (entry & P::PTE_W) {
ffffffff81012882:	f6 c3 02             	test   $0x2,%bl
ffffffff81012885:	74 1e                	je     ffffffff810128a5 <_ZN3PteI3EptyLj4ELj9ELb0EE12set_cow_pageEyRy+0x63>
            entry |= P::PTE_COW;
            entry &= ~P::PTE_COW_IO;
            entry &= ~P::PTE_W;
ffffffff81012887:	48 b8 fd ff ff ff ff 	movabs $0xf7fffffffffffffd,%rax
ffffffff8101288e:	ff ff f7 
ffffffff81012891:	48 21 c3             	and    %rax,%rbx
ffffffff81012894:	48 b8 00 00 00 00 00 	movabs $0x1000000000000000,%rax
ffffffff8101289b:	00 00 10 
ffffffff8101289e:	48 09 c3             	or     %rax,%rbx
ffffffff810128a1:	48 89 5d 00          	mov    %rbx,0x0(%rbp)
        }
    }
}
ffffffff810128a5:	58                   	pop    %rax
ffffffff810128a6:	5b                   	pop    %rbx
ffffffff810128a7:	5d                   	pop    %rbp
ffffffff810128a8:	c3                   	retq   
ffffffff810128a9:	90                   	nop

ffffffff810128aa <_ZN3PteI3EptyLj4ELj9ELb0EE6updateER5QuotaymymNS1_4TypeEb>:
        return s;
    }
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P, E, L, B, F>::update(Quota &quota, E v, mword o, E p, mword a, Type t, bool set_cow) {
ffffffff810128aa:	41 57                	push   %r15
    unsigned long l = o / B, n = 1UL << o % B, s;
ffffffff810128ac:	48 89 c8             	mov    %rcx,%rax
        return s;
    }
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P, E, L, B, F>::update(Quota &quota, E v, mword o, E p, mword a, Type t, bool set_cow) {
ffffffff810128af:	41 56                	push   %r14
ffffffff810128b1:	41 55                	push   %r13
ffffffff810128b3:	49 89 f5             	mov    %rsi,%r13
ffffffff810128b6:	41 54                	push   %r12
    unsigned long l = o / B, n = 1UL << o % B, s;
ffffffff810128b8:	be 09 00 00 00       	mov    $0x9,%esi
        return s;
    }
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P, E, L, B, F>::update(Quota &quota, E v, mword o, E p, mword a, Type t, bool set_cow) {
ffffffff810128bd:	55                   	push   %rbp
ffffffff810128be:	53                   	push   %rbx
ffffffff810128bf:	48 89 d3             	mov    %rdx,%rbx
    unsigned long l = o / B, n = 1UL << o % B, s;
ffffffff810128c2:	31 d2                	xor    %edx,%edx
ffffffff810128c4:	bd 01 00 00 00       	mov    $0x1,%ebp
ffffffff810128c9:	48 f7 f6             	div    %rsi
        return s;
    }
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P, E, L, B, F>::update(Quota &quota, E v, mword o, E p, mword a, Type t, bool set_cow) {
ffffffff810128cc:	48 83 ec 28          	sub    $0x28,%rsp
    unsigned long l = o / B, n = 1UL << o % B, s;

    P *e = walk(quota, v, l, t == TYPE_UP);
ffffffff810128d0:	4c 89 ee             	mov    %r13,%rsi
        return s;
    }
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P, E, L, B, F>::update(Quota &quota, E v, mword o, E p, mword a, Type t, bool set_cow) {
ffffffff810128d3:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
    unsigned long l = o / B, n = 1UL << o % B, s;

    P *e = walk(quota, v, l, t == TYPE_UP);
ffffffff810128d8:	45 31 c0             	xor    %r8d,%r8d
        return s;
    }
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P, E, L, B, F>::update(Quota &quota, E v, mword o, E p, mword a, Type t, bool set_cow) {
ffffffff810128db:	4c 89 4c 24 10       	mov    %r9,0x10(%rsp)
ffffffff810128e0:	44 8b 7c 24 68       	mov    0x68(%rsp),%r15d
    unsigned long l = o / B, n = 1UL << o % B, s;
ffffffff810128e5:	48 89 14 24          	mov    %rdx,(%rsp)
ffffffff810128e9:	8a 0c 24             	mov    (%rsp),%cl
ffffffff810128ec:	49 89 c4             	mov    %rax,%r12
ffffffff810128ef:	48 89 e8             	mov    %rbp,%rax

    P *e = walk(quota, v, l, t == TYPE_UP);
ffffffff810128f2:	48 89 da             	mov    %rbx,%rdx
    }
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P, E, L, B, F>::update(Quota &quota, E v, mword o, E p, mword a, Type t, bool set_cow) {
    unsigned long l = o / B, n = 1UL << o % B, s;
ffffffff810128f5:	48 d3 e0             	shl    %cl,%rax

    P *e = walk(quota, v, l, t == TYPE_UP);
ffffffff810128f8:	83 7c 24 60 00       	cmpl   $0x0,0x60(%rsp)
ffffffff810128fd:	4c 89 e1             	mov    %r12,%rcx
    }
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P, E, L, B, F>::update(Quota &quota, E v, mword o, E p, mword a, Type t, bool set_cow) {
    unsigned long l = o / B, n = 1UL << o % B, s;
ffffffff81012900:	48 89 44 24 08       	mov    %rax,0x8(%rsp)

    P *e = walk(quota, v, l, t == TYPE_UP);
ffffffff81012905:	41 0f 94 c0          	sete   %r8b
ffffffff81012909:	e8 c6 fd ff ff       	callq  ffffffff810126d4 <_ZN3PteI3EptyLj4ELj9ELb0EE4walkER5Quotaymb>

    if (!e)
        return false;
ffffffff8101290e:	31 ff                	xor    %edi,%edi
bool Pte<P, E, L, B, F>::update(Quota &quota, E v, mword o, E p, mword a, Type t, bool set_cow) {
    unsigned long l = o / B, n = 1UL << o % B, s;

    P *e = walk(quota, v, l, t == TYPE_UP);

    if (!e)
ffffffff81012910:	48 85 c0             	test   %rax,%rax

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P, E, L, B, F>::update(Quota &quota, E v, mword o, E p, mword a, Type t, bool set_cow) {
    unsigned long l = o / B, n = 1UL << o % B, s;

    P *e = walk(quota, v, l, t == TYPE_UP);
ffffffff81012913:	49 89 c6             	mov    %rax,%r14

    if (!e)
ffffffff81012916:	0f 84 d8 00 00 00    	je     ffffffff810129f4 <_ZN3PteI3EptyLj4ELj9ELb0EE6updateER5QuotaymymNS1_4TypeEb+0x14a>
        return false;

    if (a) {
ffffffff8101291c:	4c 8b 4c 24 10       	mov    0x10(%rsp),%r9
ffffffff81012921:	4d 85 c9             	test   %r9,%r9
ffffffff81012924:	74 46                	je     ffffffff8101296c <_ZN3PteI3EptyLj4ELj9ELb0EE6updateER5QuotaymymNS1_4TypeEb+0xc2>
    }

    ALWAYS_INLINE
    static inline mword order(mword o) {
        return o << 8;
ffffffff81012926:	48 8b 04 24          	mov    (%rsp),%rax
        p |= P::order(o % B) | (l ? P::PTE_S : 0) | a;
        s = 1UL << (l * B + PAGE_BITS);
ffffffff8101292a:	43 8d 0c e4          	lea    (%r12,%r12,8),%ecx
ffffffff8101292e:	48 c1 e0 08          	shl    $0x8,%rax

    if (!e)
        return false;

    if (a) {
        p |= P::order(o % B) | (l ? P::PTE_S : 0) | a;
ffffffff81012932:	49 83 fc 01          	cmp    $0x1,%r12
ffffffff81012936:	48 19 d2             	sbb    %rdx,%rdx
ffffffff81012939:	4c 0b 4c 24 18       	or     0x18(%rsp),%r9
        s = 1UL << (l * B + PAGE_BITS);
ffffffff8101293e:	83 c1 0c             	add    $0xc,%ecx

    if (!e)
        return false;

    if (a) {
        p |= P::order(o % B) | (l ? P::PTE_S : 0) | a;
ffffffff81012941:	48 f7 d2             	not    %rdx
        s = 1UL << (l * B + PAGE_BITS);
ffffffff81012944:	48 d3 e5             	shl    %cl,%rbp

    if (!e)
        return false;

    if (a) {
        p |= P::order(o % B) | (l ? P::PTE_S : 0) | a;
ffffffff81012947:	81 e2 80 00 00 00    	and    $0x80,%edx
ffffffff8101294d:	49 09 c1             	or     %rax,%r9
ffffffff81012950:	4c 09 ca             	or     %r9,%rdx
        s = 1UL << (l * B + PAGE_BITS);
        if (set_cow) {
ffffffff81012953:	45 84 ff             	test   %r15b,%r15b

    if (!e)
        return false;

    if (a) {
        p |= P::order(o % B) | (l ? P::PTE_S : 0) | a;
ffffffff81012956:	48 89 54 24 18       	mov    %rdx,0x18(%rsp)
        s = 1UL << (l * B + PAGE_BITS);
        if (set_cow) {
ffffffff8101295b:	74 1a                	je     ffffffff81012977 <_ZN3PteI3EptyLj4ELj9ELb0EE6updateER5QuotaymymNS1_4TypeEb+0xcd>
            set_cow_page(v, p);
ffffffff8101295d:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi
ffffffff81012962:	48 89 df             	mov    %rbx,%rdi
ffffffff81012965:	e8 d8 fe ff ff       	callq  ffffffff81012842 <_ZN3PteI3EptyLj4ELj9ELb0EE12set_cow_pageEyRy>
ffffffff8101296a:	eb 0b                	jmp    ffffffff81012977 <_ZN3PteI3EptyLj4ELj9ELb0EE6updateER5QuotaymymNS1_4TypeEb+0xcd>
        }
    } else
        p = s = 0;
ffffffff8101296c:	48 c7 44 24 18 00 00 	movq   $0x0,0x18(%rsp)
ffffffff81012973:	00 00 
ffffffff81012975:	31 ed                	xor    %ebp,%ebp
ffffffff81012977:	48 8b 44 24 08       	mov    0x8(%rsp),%rax

    bool flush_tlb = false;
ffffffff8101297c:	31 ff                	xor    %edi,%edi

    for (unsigned long i = 0; i < n; e[i].val = p, i++, p += s) {

        if (l && e[i].val != p)
            flush_tlb = true;
ffffffff8101297e:	41 b7 01             	mov    $0x1,%r15b
ffffffff81012981:	49 8d 1c c6          	lea    (%r14,%rax,8),%rbx

    bool flush_tlb = false;

    for (unsigned long i = 0; i < n; e[i].val = p, i++, p += s) {

        if (l && e[i].val != p)
ffffffff81012985:	4d 85 e4             	test   %r12,%r12
ffffffff81012988:	74 0c                	je     ffffffff81012996 <_ZN3PteI3EptyLj4ELj9ELb0EE6updateER5QuotaymymNS1_4TypeEb+0xec>
            flush_tlb = true;
ffffffff8101298a:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
ffffffff8101298f:	49 39 06             	cmp    %rax,(%r14)
ffffffff81012992:	41 0f 45 ff          	cmovne %r15d,%edi

        if (!e[i].val)
ffffffff81012996:	49 8b 36             	mov    (%r14),%rsi
ffffffff81012999:	48 85 f6             	test   %rsi,%rsi
ffffffff8101299c:	0f 94 c1             	sete   %cl
            continue;

        if (t == TYPE_DF)
ffffffff8101299f:	83 7c 24 60 02       	cmpl   $0x2,0x60(%rsp)
ffffffff810129a4:	0f 94 c2             	sete   %dl
ffffffff810129a7:	09 ca                	or     %ecx,%edx
            continue;

        if (l && !e[i].super()) {
ffffffff810129a9:	4d 85 e4             	test   %r12,%r12
ffffffff810129ac:	0f 95 c1             	setne  %cl
ffffffff810129af:	38 ca                	cmp    %cl,%dl
ffffffff810129b1:	73 06                	jae    ffffffff810129b9 <_ZN3PteI3EptyLj4ELj9ELb0EE6updateER5QuotaymymNS1_4TypeEb+0x10f>
ffffffff810129b3:	40 f6 c6 80          	test   $0x80,%sil
ffffffff810129b7:	74 19                	je     ffffffff810129d2 <_ZN3PteI3EptyLj4ELj9ELb0EE6updateER5QuotaymymNS1_4TypeEb+0x128>
    } else
        p = s = 0;

    bool flush_tlb = false;

    for (unsigned long i = 0; i < n; e[i].val = p, i++, p += s) {
ffffffff810129b9:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
ffffffff810129be:	49 83 c6 08          	add    $0x8,%r14
ffffffff810129c2:	49 89 56 f8          	mov    %rdx,-0x8(%r14)
ffffffff810129c6:	48 01 6c 24 18       	add    %rbp,0x18(%rsp)
ffffffff810129cb:	49 39 de             	cmp    %rbx,%r14
ffffffff810129ce:	75 b5                	jne    ffffffff81012985 <_ZN3PteI3EptyLj4ELj9ELb0EE6updateER5QuotaymymNS1_4TypeEb+0xdb>
ffffffff810129d0:	eb 22                	jmp    ffffffff810129f4 <_ZN3PteI3EptyLj4ELj9ELb0EE6updateER5QuotaymymNS1_4TypeEb+0x14a>
    }

    ALWAYS_INLINE
    inline Paddr addr() const {
        return static_cast<Paddr> (val) & ~((1UL << order()) - 1);
ffffffff810129d2:	48 81 e6 00 f0 ff ff 	and    $0xfffffffffffff000,%rsi
    }

    ALWAYS_INLINE
    static inline void destroy(Pte *obj, Quota &quota) {
        obj->~Pte();
        Buddy::allocator.free(reinterpret_cast<mword> (obj), quota);
ffffffff810129d9:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff810129e0:	4c 89 ea             	mov    %r13,%rdx
        }

        ALWAYS_INLINE
        inline mword phys_to_virt (mword phys)
        {
            return phys + reinterpret_cast<mword>(&OFFSET);
ffffffff810129e3:	48 81 c6 00 00 c0 80 	add    $0xffffffff80c00000,%rsi
ffffffff810129ea:	e8 bf eb fe ff       	callq  ffffffff810015ae <_ZN5Buddy4freeEmR5Quota>
        if (t == TYPE_DF)
            continue;

        if (l && !e[i].super()) {
            Pte::destroy(static_cast<P *> (Buddy::phys_to_ptr(e[i].addr())), quota);
            flush_tlb = true;
ffffffff810129ef:	40 b7 01             	mov    $0x1,%dil
ffffffff810129f2:	eb c5                	jmp    ffffffff810129b9 <_ZN3PteI3EptyLj4ELj9ELb0EE6updateER5QuotaymymNS1_4TypeEb+0x10f>

    if (F)
        flush(e, n * sizeof (E));

    return flush_tlb;
}
ffffffff810129f4:	48 83 c4 28          	add    $0x28,%rsp
ffffffff810129f8:	40 88 f8             	mov    %dil,%al
ffffffff810129fb:	5b                   	pop    %rbx
ffffffff810129fc:	5d                   	pop    %rbp
ffffffff810129fd:	41 5c                	pop    %r12
ffffffff810129ff:	41 5d                	pop    %r13
ffffffff81012a01:	41 5e                	pop    %r14
ffffffff81012a03:	41 5f                	pop    %r15
ffffffff81012a05:	c3                   	retq   

ffffffff81012a06 <_ZN3PteI3HptmLj4ELj9ELb0EE4walkER5Quotammb>:
    }
    return true;
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
P *Pte<P, E, L, B, F>::walk(Quota &quota, E v, unsigned long n, bool a) {
ffffffff81012a06:	41 57                	push   %r15
ffffffff81012a08:	41 56                	push   %r14
        if (!e->val) {

            if (!a)
                return nullptr;

            if (!e->set(0, Buddy::ptr_to_phys(p = new (quota) P) | (l == L ? 0 : P::PTE_N)))
ffffffff81012a0a:	41 bf 27 00 00 00    	mov    $0x27,%r15d
    }
    return true;
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
P *Pte<P, E, L, B, F>::walk(Quota &quota, E v, unsigned long n, bool a) {
ffffffff81012a10:	41 55                	push   %r13
ffffffff81012a12:	41 54                	push   %r12
ffffffff81012a14:	45 88 c5             	mov    %r8b,%r13b
ffffffff81012a17:	55                   	push   %rbp
ffffffff81012a18:	53                   	push   %rbx
ffffffff81012a19:	49 89 f4             	mov    %rsi,%r12
    unsigned long l = L;

    for (P *p, *e = static_cast<P *> (this);; e = static_cast<P *> (Buddy::phys_to_ptr(e->addr())) + (v >> (--l * B + PAGE_BITS) & ((1UL << B) - 1))) {
ffffffff81012a1c:	48 89 fb             	mov    %rdi,%rbx
    return true;
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
P *Pte<P, E, L, B, F>::walk(Quota &quota, E v, unsigned long n, bool a) {
    unsigned long l = L;
ffffffff81012a1f:	bd 04 00 00 00       	mov    $0x4,%ebp
    }
    return true;
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
P *Pte<P, E, L, B, F>::walk(Quota &quota, E v, unsigned long n, bool a) {
ffffffff81012a24:	48 83 ec 18          	sub    $0x18,%rsp
ffffffff81012a28:	48 89 14 24          	mov    %rdx,(%rsp)
ffffffff81012a2c:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
    unsigned long l = L;

    for (P *p, *e = static_cast<P *> (this);; e = static_cast<P *> (Buddy::phys_to_ptr(e->addr())) + (v >> (--l * B + PAGE_BITS) & ((1UL << B) - 1))) {

        if (l == n)
ffffffff81012a31:	48 3b 6c 24 08       	cmp    0x8(%rsp),%rbp
ffffffff81012a36:	0f 84 86 00 00 00    	je     ffffffff81012ac2 <_ZN3PteI3HptmLj4ELj9ELb0EE4walkER5Quotammb+0xbc>
            return e;

        if (!e->val) {
ffffffff81012a3c:	4c 8b 33             	mov    (%rbx),%r14
ffffffff81012a3f:	4d 85 f6             	test   %r14,%r14
ffffffff81012a42:	75 51                	jne    ffffffff81012a95 <_ZN3PteI3HptmLj4ELj9ELb0EE4walkER5Quotammb+0x8f>

            if (!a)
ffffffff81012a44:	45 84 ed             	test   %r13b,%r13b
ffffffff81012a47:	74 7e                	je     ffffffff81012ac7 <_ZN3PteI3HptmLj4ELj9ELb0EE4walkER5Quotammb+0xc1>
        return b;
    }

    ALWAYS_INLINE
    static inline void *operator new (size_t, Quota &quota) {
        void *p = Buddy::allocator.alloc(0, quota, Buddy::FILL_0);
ffffffff81012a49:	31 f6                	xor    %esi,%esi
ffffffff81012a4b:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff81012a50:	4c 89 e2             	mov    %r12,%rdx
ffffffff81012a53:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff81012a5a:	e8 93 ee fe ff       	callq  ffffffff810018f2 <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
ffffffff81012a5f:	48 89 c6             	mov    %rax,%rsi

    void free_up(Quota &quota, unsigned l, P *, mword, bool (*) (Paddr, mword, unsigned), bool (*) (unsigned, mword));

public:

    Pte() : val(0) {
ffffffff81012a62:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
        }

        ALWAYS_INLINE
        inline mword virt_to_phys (mword virt)
        {
            return virt - reinterpret_cast<mword>(&OFFSET);
ffffffff81012a69:	48 2d 00 00 c0 80    	sub    $0xffffffff80c00000,%rax
                return nullptr;

            if (!e->set(0, Buddy::ptr_to_phys(p = new (quota) P) | (l == L ? 0 : P::PTE_N)))
ffffffff81012a6f:	48 83 fd 04          	cmp    $0x4,%rbp
ffffffff81012a73:	4d 0f 45 f7          	cmovne %r15,%r14
ffffffff81012a77:	4d 89 f1             	mov    %r14,%r9
ffffffff81012a7a:	49 09 c1             	or     %rax,%r9
ffffffff81012a7d:	31 c0                	xor    %eax,%eax
ffffffff81012a7f:	f0 4c 0f b1 0b       	lock cmpxchg %r9,(%rbx)
ffffffff81012a84:	74 0f                	je     ffffffff81012a95 <_ZN3PteI3HptmLj4ELj9ELb0EE4walkER5Quotammb+0x8f>
    }

    ALWAYS_INLINE
    static inline void destroy(Pte *obj, Quota &quota) {
        obj->~Pte();
        Buddy::allocator.free(reinterpret_cast<mword> (obj), quota);
ffffffff81012a86:	4c 89 e2             	mov    %r12,%rdx
ffffffff81012a89:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff81012a90:	e8 19 eb fe ff       	callq  ffffffff810015ae <_ZN5Buddy4freeEmR5Quota>

template <typename P, typename E, unsigned L, unsigned B, bool F>
P *Pte<P, E, L, B, F>::walk(Quota &quota, E v, unsigned long n, bool a) {
    unsigned long l = L;

    for (P *p, *e = static_cast<P *> (this);; e = static_cast<P *> (Buddy::phys_to_ptr(e->addr())) + (v >> (--l * B + PAGE_BITS) & ((1UL << B) - 1))) {
ffffffff81012a95:	48 ff cd             	dec    %rbp
ffffffff81012a98:	48 8b 14 24          	mov    (%rsp),%rdx
        PTE_U = HPT_U,
    };

    ALWAYS_INLINE
    inline Paddr addr() const {
        return static_cast<Paddr> (val) & ~PAGE_MASK;
ffffffff81012a9c:	48 8b 03             	mov    (%rbx),%rax
ffffffff81012a9f:	8d 4c ed 00          	lea    0x0(%rbp,%rbp,8),%ecx
ffffffff81012aa3:	83 c1 0c             	add    $0xc,%ecx
ffffffff81012aa6:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81012aac:	48 d3 ea             	shr    %cl,%rdx
ffffffff81012aaf:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
ffffffff81012ab5:	48 8d 9c d0 00 00 c0 	lea    -0x7f400000(%rax,%rdx,8),%rbx
ffffffff81012abc:	80 
ffffffff81012abd:	e9 6f ff ff ff       	jmpq   ffffffff81012a31 <_ZN3PteI3HptmLj4ELj9ELb0EE4walkER5Quotammb+0x2b>
ffffffff81012ac2:	48 89 d8             	mov    %rbx,%rax
ffffffff81012ac5:	eb 02                	jmp    ffffffff81012ac9 <_ZN3PteI3HptmLj4ELj9ELb0EE4walkER5Quotammb+0xc3>
            return e;

        if (!e->val) {

            if (!a)
                return nullptr;
ffffffff81012ac7:	31 c0                	xor    %eax,%eax

            if (!e->set(0, Buddy::ptr_to_phys(p = new (quota) P) | (l == L ? 0 : P::PTE_N)))
                Pte::destroy(p, quota);
        }
    }
}
ffffffff81012ac9:	48 83 c4 18          	add    $0x18,%rsp
ffffffff81012acd:	5b                   	pop    %rbx
ffffffff81012ace:	5d                   	pop    %rbp
ffffffff81012acf:	41 5c                	pop    %r12
ffffffff81012ad1:	41 5d                	pop    %r13
ffffffff81012ad3:	41 5e                	pop    %r14
ffffffff81012ad5:	41 5f                	pop    %r15
ffffffff81012ad7:	c3                   	retq   

ffffffff81012ad8 <_ZN3PteI3HptmLj4ELj9ELb0EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE>:

    Pte::destroy(e, quota);
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
void Pte<P, E, L, B, F>::free_up(Quota &quota, unsigned l, P * e, mword v, bool (*d)(Paddr, mword, unsigned), bool (*il) (unsigned, mword)) {
ffffffff81012ad8:	41 57                	push   %r15
ffffffff81012ada:	41 56                	push   %r14
ffffffff81012adc:	41 55                	push   %r13
ffffffff81012ade:	41 54                	push   %r12
ffffffff81012ae0:	55                   	push   %rbp
ffffffff81012ae1:	53                   	push   %rbx
ffffffff81012ae2:	48 83 ec 28          	sub    $0x28,%rsp
    if (!e)
ffffffff81012ae6:	48 85 c9             	test   %rcx,%rcx

    Pte::destroy(e, quota);
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
void Pte<P, E, L, B, F>::free_up(Quota &quota, unsigned l, P * e, mword v, bool (*d)(Paddr, mword, unsigned), bool (*il) (unsigned, mword)) {
ffffffff81012ae9:	4c 8b 7c 24 60       	mov    0x60(%rsp),%r15
    if (!e)
ffffffff81012aee:	0f 84 d0 00 00 00    	je     ffffffff81012bc4 <_ZN3PteI3HptmLj4ELj9ELb0EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0xec>
    for (unsigned long i = 0; i < (1 << B); i++) {
        if (!e[i].val || e[i].super())
            continue;

        P *p = static_cast<P *> (Buddy::phys_to_ptr(e[i].addr()));
        mword virt = v + (i << (l * B + PAGE_BITS));
ffffffff81012af4:	8d 04 d2             	lea    (%rdx,%rdx,8),%eax
ffffffff81012af7:	4d 89 cd             	mov    %r9,%r13
ffffffff81012afa:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
ffffffff81012aff:	49 89 cc             	mov    %rcx,%r12
ffffffff81012b02:	89 d3                	mov    %edx,%ebx
ffffffff81012b04:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
ffffffff81012b09:	83 c0 0c             	add    $0xc,%eax
ffffffff81012b0c:	31 ed                	xor    %ebp,%ebp
ffffffff81012b0e:	89 44 24 10          	mov    %eax,0x10(%rsp)

        if (il ? il(l, virt) : l > 1)
            p->free_up(quota, l - 1, p, virt, d, il);
ffffffff81012b12:	8d 42 ff             	lea    -0x1(%rdx),%eax
ffffffff81012b15:	89 44 24 14          	mov    %eax,0x14(%rsp)
void Pte<P, E, L, B, F>::free_up(Quota &quota, unsigned l, P * e, mword v, bool (*d)(Paddr, mword, unsigned), bool (*il) (unsigned, mword)) {
    if (!e)
        return;

    for (unsigned long i = 0; i < (1 << B); i++) {
        if (!e[i].val || e[i].super())
ffffffff81012b19:	49 8b 04 ec          	mov    (%r12,%rbp,8),%rax
ffffffff81012b1d:	48 85 c0             	test   %rax,%rax
ffffffff81012b20:	74 71                	je     ffffffff81012b93 <_ZN3PteI3HptmLj4ELj9ELb0EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0xbb>
ffffffff81012b22:	a8 80                	test   $0x80,%al
ffffffff81012b24:	75 6d                	jne    ffffffff81012b93 <_ZN3PteI3HptmLj4ELj9ELb0EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0xbb>
            continue;

        P *p = static_cast<P *> (Buddy::phys_to_ptr(e[i].addr()));
        mword virt = v + (i << (l * B + PAGE_BITS));
ffffffff81012b26:	8a 4c 24 10          	mov    0x10(%rsp),%cl
ffffffff81012b2a:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81012b30:	49 89 ee             	mov    %rbp,%r14
        }

        ALWAYS_INLINE
        inline mword phys_to_virt (mword phys)
        {
            return phys + reinterpret_cast<mword>(&OFFSET);
ffffffff81012b33:	48 05 00 00 c0 80    	add    $0xffffffff80c00000,%rax
ffffffff81012b39:	48 89 04 24          	mov    %rax,(%rsp)
ffffffff81012b3d:	49 d3 e6             	shl    %cl,%r14
ffffffff81012b40:	4c 03 74 24 18       	add    0x18(%rsp),%r14

        if (il ? il(l, virt) : l > 1)
ffffffff81012b45:	4d 85 ff             	test   %r15,%r15
ffffffff81012b48:	74 5b                	je     ffffffff81012ba5 <_ZN3PteI3HptmLj4ELj9ELb0EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0xcd>
ffffffff81012b4a:	4c 89 f6             	mov    %r14,%rsi
ffffffff81012b4d:	89 df                	mov    %ebx,%edi
ffffffff81012b4f:	41 ff d7             	callq  *%r15
ffffffff81012b52:	84 c0                	test   %al,%al
ffffffff81012b54:	74 21                	je     ffffffff81012b77 <_ZN3PteI3HptmLj4ELj9ELb0EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0x9f>
            p->free_up(quota, l - 1, p, virt, d, il);
ffffffff81012b56:	50                   	push   %rax
ffffffff81012b57:	41 57                	push   %r15
ffffffff81012b59:	4d 89 e9             	mov    %r13,%r9
ffffffff81012b5c:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
ffffffff81012b61:	8b 54 24 24          	mov    0x24(%rsp),%edx
ffffffff81012b65:	4d 89 f0             	mov    %r14,%r8
ffffffff81012b68:	48 8b 74 24 18       	mov    0x18(%rsp),%rsi
ffffffff81012b6d:	48 89 cf             	mov    %rcx,%rdi
ffffffff81012b70:	e8 63 ff ff ff       	callq  ffffffff81012ad8 <_ZN3PteI3HptmLj4ELj9ELb0EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE>
ffffffff81012b75:	5a                   	pop    %rdx
ffffffff81012b76:	59                   	pop    %rcx

        if (!d || d(e[i].addr(), virt, l))
ffffffff81012b77:	4d 85 ed             	test   %r13,%r13
ffffffff81012b7a:	74 31                	je     ffffffff81012bad <_ZN3PteI3HptmLj4ELj9ELb0EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0xd5>
ffffffff81012b7c:	49 8b 3c ec          	mov    (%r12,%rbp,8),%rdi
ffffffff81012b80:	89 da                	mov    %ebx,%edx
ffffffff81012b82:	4c 89 f6             	mov    %r14,%rsi
ffffffff81012b85:	48 81 e7 00 f0 ff ff 	and    $0xfffffffffffff000,%rdi
ffffffff81012b8c:	41 ff d5             	callq  *%r13
ffffffff81012b8f:	84 c0                	test   %al,%al
ffffffff81012b91:	75 1a                	jne    ffffffff81012bad <_ZN3PteI3HptmLj4ELj9ELb0EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0xd5>
template <typename P, typename E, unsigned L, unsigned B, bool F>
void Pte<P, E, L, B, F>::free_up(Quota &quota, unsigned l, P * e, mword v, bool (*d)(Paddr, mword, unsigned), bool (*il) (unsigned, mword)) {
    if (!e)
        return;

    for (unsigned long i = 0; i < (1 << B); i++) {
ffffffff81012b93:	48 ff c5             	inc    %rbp
ffffffff81012b96:	48 81 fd 00 02 00 00 	cmp    $0x200,%rbp
ffffffff81012b9d:	0f 85 76 ff ff ff    	jne    ffffffff81012b19 <_ZN3PteI3HptmLj4ELj9ELb0EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0x41>
ffffffff81012ba3:	eb 1f                	jmp    ffffffff81012bc4 <_ZN3PteI3HptmLj4ELj9ELb0EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0xec>
            continue;

        P *p = static_cast<P *> (Buddy::phys_to_ptr(e[i].addr()));
        mword virt = v + (i << (l * B + PAGE_BITS));

        if (il ? il(l, virt) : l > 1)
ffffffff81012ba5:	83 fb 01             	cmp    $0x1,%ebx
ffffffff81012ba8:	0f 97 c0             	seta   %al
ffffffff81012bab:	eb a5                	jmp    ffffffff81012b52 <_ZN3PteI3HptmLj4ELj9ELb0EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0x7a>
ffffffff81012bad:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
ffffffff81012bb2:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff81012bb6:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff81012bbd:	e8 ec e9 fe ff       	callq  ffffffff810015ae <_ZN5Buddy4freeEmR5Quota>
ffffffff81012bc2:	eb cf                	jmp    ffffffff81012b93 <_ZN3PteI3HptmLj4ELj9ELb0EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE+0xbb>
            p->free_up(quota, l - 1, p, virt, d, il);

        if (!d || d(e[i].addr(), virt, l))
            Pte::destroy(p, quota);
    }
}
ffffffff81012bc4:	48 83 c4 28          	add    $0x28,%rsp
ffffffff81012bc8:	5b                   	pop    %rbx
ffffffff81012bc9:	5d                   	pop    %rbp
ffffffff81012bca:	41 5c                	pop    %r12
ffffffff81012bcc:	41 5d                	pop    %r13
ffffffff81012bce:	41 5e                	pop    %r14
ffffffff81012bd0:	41 5f                	pop    %r15
ffffffff81012bd2:	c3                   	retq   
ffffffff81012bd3:	90                   	nop

ffffffff81012bd4 <_ZN3PteI3HptmLj4ELj9ELb0EE6lookupEmRmS2_>:
        }
    }
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
size_t Pte<P, E, L, B, F>::lookup(E v, Paddr &p, mword &a) {
ffffffff81012bd4:	49 89 ca             	mov    %rcx,%r10
    unsigned long l = L;
ffffffff81012bd7:	41 b8 04 00 00 00    	mov    $0x4,%r8d

    for (P *e = static_cast<P *> (this);; e = static_cast<P *> (Buddy::phys_to_ptr(e->addr())) + (v >> (--l * B + PAGE_BITS) & ((1UL << B) - 1))) {

        if (EXPECT_FALSE(!e->val))
ffffffff81012bdd:	48 8b 07             	mov    (%rdi),%rax
ffffffff81012be0:	48 85 c0             	test   %rax,%rax
ffffffff81012be3:	74 64                	je     ffffffff81012c49 <_ZN3PteI3HptmLj4ELj9ELb0EE6lookupEmRmS2_+0x75>
            return 0;

        if (EXPECT_FALSE(l && !e->super()))
ffffffff81012be5:	4d 85 c0             	test   %r8,%r8
ffffffff81012be8:	74 2d                	je     ffffffff81012c17 <_ZN3PteI3HptmLj4ELj9ELb0EE6lookupEmRmS2_+0x43>
ffffffff81012bea:	a8 80                	test   $0x80,%al
ffffffff81012bec:	75 29                	jne    ffffffff81012c17 <_ZN3PteI3HptmLj4ELj9ELb0EE6lookupEmRmS2_+0x43>

template <typename P, typename E, unsigned L, unsigned B, bool F>
size_t Pte<P, E, L, B, F>::lookup(E v, Paddr &p, mword &a) {
    unsigned long l = L;

    for (P *e = static_cast<P *> (this);; e = static_cast<P *> (Buddy::phys_to_ptr(e->addr())) + (v >> (--l * B + PAGE_BITS) & ((1UL << B) - 1))) {
ffffffff81012bee:	49 ff c8             	dec    %r8
ffffffff81012bf1:	48 89 f7             	mov    %rsi,%rdi
ffffffff81012bf4:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81012bfa:	43 8d 0c c0          	lea    (%r8,%r8,8),%ecx
ffffffff81012bfe:	83 c1 0c             	add    $0xc,%ecx
ffffffff81012c01:	48 d3 ef             	shr    %cl,%rdi
ffffffff81012c04:	48 89 f9             	mov    %rdi,%rcx
ffffffff81012c07:	81 e1 ff 01 00 00    	and    $0x1ff,%ecx
ffffffff81012c0d:	48 8d bc c8 00 00 c0 	lea    -0x7f400000(%rax,%rcx,8),%rdi
ffffffff81012c14:	80 
ffffffff81012c15:	eb c6                	jmp    ffffffff81012bdd <_ZN3PteI3HptmLj4ELj9ELb0EE6lookupEmRmS2_+0x9>
            return 0;

        if (EXPECT_FALSE(l && !e->super()))
            continue;

        size_t s = 1UL << (l * B + e->order());
ffffffff81012c17:	47 8d 04 c0          	lea    (%r8,%r8,8),%r8d
ffffffff81012c1b:	41 b9 01 00 00 00    	mov    $0x1,%r9d
ffffffff81012c21:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81012c27:	41 8d 48 0c          	lea    0xc(%r8),%ecx
ffffffff81012c2b:	49 d3 e1             	shl    %cl,%r9

        p = static_cast<Paddr> (e->addr() | (v & (s - 1)));
ffffffff81012c2e:	49 8d 49 ff          	lea    -0x1(%r9),%rcx
ffffffff81012c32:	48 21 ce             	and    %rcx,%rsi
ffffffff81012c35:	48 09 f0             	or     %rsi,%rax
ffffffff81012c38:	48 89 02             	mov    %rax,(%rdx)
        return val & P::PTE_S;
    }

    ALWAYS_INLINE
    inline mword attr() const {
        return static_cast<mword> (val) & PAGE_MASK;
ffffffff81012c3b:	48 8b 07             	mov    (%rdi),%rax
ffffffff81012c3e:	25 ff 0f 00 00       	and    $0xfff,%eax

        a = e->attr();
ffffffff81012c43:	49 89 02             	mov    %rax,(%r10)

        return s;
ffffffff81012c46:	4c 89 c8             	mov    %r9,%rax
    }
}
ffffffff81012c49:	c3                   	retq   

ffffffff81012c4a <_ZN3PteI3HptmLj4ELj9ELb0EE5clearER5QuotaPFbmmjEPFbjmE>:

    return flush_tlb;
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
void Pte<P, E, L, B, F>::clear(Quota &quota, bool (*d) (Paddr, mword, unsigned), bool (*il) (unsigned, mword)) {
ffffffff81012c4a:	55                   	push   %rbp
ffffffff81012c4b:	53                   	push   %rbx
ffffffff81012c4c:	41 50                	push   %r8
    if (!val)
ffffffff81012c4e:	48 8b 1f             	mov    (%rdi),%rbx
ffffffff81012c51:	48 85 db             	test   %rbx,%rbx
ffffffff81012c54:	74 41                	je     ffffffff81012c97 <_ZN3PteI3HptmLj4ELj9ELb0EE5clearER5QuotaPFbmmjEPFbjmE+0x4d>
    }

    ALWAYS_INLINE
    inline Paddr addr() const {
        return static_cast<Paddr> (val) & ~((1UL << order()) - 1);
ffffffff81012c56:	48 81 e3 00 f0 ff ff 	and    $0xfffffffffffff000,%rbx
ffffffff81012c5d:	49 89 d1             	mov    %rdx,%r9
        return;

    P * e = static_cast<P *> (Buddy::phys_to_ptr(this->addr()));

    e->free_up(quota, L - 1, e, 0, d, il);
ffffffff81012c60:	52                   	push   %rdx
ffffffff81012c61:	48 81 c3 00 00 c0 80 	add    $0xffffffff80c00000,%rbx
ffffffff81012c68:	51                   	push   %rcx
ffffffff81012c69:	ba 03 00 00 00       	mov    $0x3,%edx
ffffffff81012c6e:	48 89 df             	mov    %rbx,%rdi
ffffffff81012c71:	48 89 d9             	mov    %rbx,%rcx
ffffffff81012c74:	45 31 c0             	xor    %r8d,%r8d
ffffffff81012c77:	48 89 f5             	mov    %rsi,%rbp
ffffffff81012c7a:	e8 59 fe ff ff       	callq  ffffffff81012ad8 <_ZN3PteI3HptmLj4ELj9ELb0EE7free_upER5QuotajPS0_mPFbmmjEPFbjmE>

    Pte::destroy(e, quota);
}
ffffffff81012c7f:	48 83 c4 18          	add    $0x18,%rsp
    }

    ALWAYS_INLINE
    static inline void destroy(Pte *obj, Quota &quota) {
        obj->~Pte();
        Buddy::allocator.free(reinterpret_cast<mword> (obj), quota);
ffffffff81012c83:	48 89 ea             	mov    %rbp,%rdx
ffffffff81012c86:	48 89 de             	mov    %rbx,%rsi
ffffffff81012c89:	5b                   	pop    %rbx
ffffffff81012c8a:	5d                   	pop    %rbp
ffffffff81012c8b:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff81012c92:	e9 17 e9 fe ff       	jmpq   ffffffff810015ae <_ZN5Buddy4freeEmR5Quota>
ffffffff81012c97:	58                   	pop    %rax
ffffffff81012c98:	5b                   	pop    %rbx
ffffffff81012c99:	5d                   	pop    %rbp
ffffffff81012c9a:	c3                   	retq   

ffffffff81012c9b <_ZN3PteI3HptmLj4ELj9ELb0EE7is_mmioEm>:
mword Ept::ord = ~0UL;
mword Hpt::ord = ~0UL;

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P, E, L, B, F>::is_mmio(E p) {
    Cow::block *b = Cow::ram_mem_list;
ffffffff81012c9b:	48 8b 05 56 f1 00 00 	mov    0xf156(%rip),%rax        # ffffffff81021df8 <_ZN3Cow12ram_mem_listE>
    while (b != nullptr) {
ffffffff81012ca2:	48 85 c0             	test   %rax,%rax
ffffffff81012ca5:	74 11                	je     ffffffff81012cb8 <_ZN3PteI3HptmLj4ELj9ELb0EE7is_mmioEm+0x1d>
        //        Console::print("deb: %08lx  fin: %08lx  p: %08lx", b->start, b->end, p);
        if ((p >= b->start) && (p < b->end)) {
ffffffff81012ca7:	48 3b 38             	cmp    (%rax),%rdi
ffffffff81012caa:	72 06                	jb     ffffffff81012cb2 <_ZN3PteI3HptmLj4ELj9ELb0EE7is_mmioEm+0x17>
ffffffff81012cac:	48 3b 78 08          	cmp    0x8(%rax),%rdi
ffffffff81012cb0:	72 09                	jb     ffffffff81012cbb <_ZN3PteI3HptmLj4ELj9ELb0EE7is_mmioEm+0x20>
            return false;
        }
        b = b->next;
ffffffff81012cb2:	48 8b 40 18          	mov    0x18(%rax),%rax
ffffffff81012cb6:	eb ea                	jmp    ffffffff81012ca2 <_ZN3PteI3HptmLj4ELj9ELb0EE7is_mmioEm+0x7>
    }
    return true;
ffffffff81012cb8:	b0 01                	mov    $0x1,%al
ffffffff81012cba:	c3                   	retq   
bool Pte<P, E, L, B, F>::is_mmio(E p) {
    Cow::block *b = Cow::ram_mem_list;
    while (b != nullptr) {
        //        Console::print("deb: %08lx  fin: %08lx  p: %08lx", b->start, b->end, p);
        if ((p >= b->start) && (p < b->end)) {
            return false;
ffffffff81012cbb:	31 c0                	xor    %eax,%eax
        }
        b = b->next;
    }
    return true;
}
ffffffff81012cbd:	c3                   	retq   

ffffffff81012cbe <_ZN3PteI3HptmLj4ELj9ELb0EE12set_cow_pageEmRm>:
template <typename P, typename E, unsigned L, unsigned B, bool F>
/**
 * 
 *  */
void Pte<P, E, L, B, F>::set_cow_page(E virt, E &entry) {
    if ((virt < USER_ADDR) && (entry & P::PTE_P) && (entry & P::PTE_U)) {
ffffffff81012cbe:	48 b8 ff ef ff ff ff 	movabs $0x7fffffffefff,%rax
ffffffff81012cc5:	7f 00 00 
ffffffff81012cc8:	48 39 c7             	cmp    %rax,%rdi
ffffffff81012ccb:	77 47                	ja     ffffffff81012d14 <_ZN3PteI3HptmLj4ELj9ELb0EE12set_cow_pageEmRm+0x56>

template <typename P, typename E, unsigned L, unsigned B, bool F>
/**
 * 
 *  */
void Pte<P, E, L, B, F>::set_cow_page(E virt, E &entry) {
ffffffff81012ccd:	55                   	push   %rbp
ffffffff81012cce:	53                   	push   %rbx
ffffffff81012ccf:	52                   	push   %rdx
    if ((virt < USER_ADDR) && (entry & P::PTE_P) && (entry & P::PTE_U)) {
ffffffff81012cd0:	48 8b 1e             	mov    (%rsi),%rbx
ffffffff81012cd3:	48 89 d8             	mov    %rbx,%rax
ffffffff81012cd6:	83 e0 05             	and    $0x5,%eax
ffffffff81012cd9:	48 83 f8 05          	cmp    $0x5,%rax
ffffffff81012cdd:	75 32                	jne    ffffffff81012d11 <_ZN3PteI3HptmLj4ELj9ELb0EE12set_cow_pageEmRm+0x53>
        if (is_mmio(entry & ~PAGE_MASK)) {
ffffffff81012cdf:	48 89 df             	mov    %rbx,%rdi
ffffffff81012ce2:	48 89 f5             	mov    %rsi,%rbp
ffffffff81012ce5:	48 81 e7 00 f0 ff ff 	and    $0xfffffffffffff000,%rdi
ffffffff81012cec:	e8 aa ff ff ff       	callq  ffffffff81012c9b <_ZN3PteI3HptmLj4ELj9ELb0EE7is_mmioEm>
ffffffff81012cf1:	84 c0                	test   %al,%al
ffffffff81012cf3:	74 09                	je     ffffffff81012cfe <_ZN3PteI3HptmLj4ELj9ELb0EE12set_cow_pageEmRm+0x40>
            entry |= P::PTE_COW | P::PTE_COW_IO;
            entry &= ~P::PTE_P;
ffffffff81012cf5:	48 83 e3 fe          	and    $0xfffffffffffffffe,%rbx
ffffffff81012cf9:	80 cf 0c             	or     $0xc,%bh
ffffffff81012cfc:	eb 0f                	jmp    ffffffff81012d0d <_ZN3PteI3HptmLj4ELj9ELb0EE12set_cow_pageEmRm+0x4f>
        } else if (entry & P::PTE_W) {
ffffffff81012cfe:	f6 c3 02             	test   $0x2,%bl
ffffffff81012d01:	74 0e                	je     ffffffff81012d11 <_ZN3PteI3HptmLj4ELj9ELb0EE12set_cow_pageEmRm+0x53>
            entry |= P::PTE_COW;
            entry &= ~P::PTE_COW_IO;
            entry &= ~P::PTE_W;
ffffffff81012d03:	48 81 e3 fd fb ff ff 	and    $0xfffffffffffffbfd,%rbx
ffffffff81012d0a:	80 cf 08             	or     $0x8,%bh
ffffffff81012d0d:	48 89 5d 00          	mov    %rbx,0x0(%rbp)
        }
    }
}
ffffffff81012d11:	58                   	pop    %rax
ffffffff81012d12:	5b                   	pop    %rbx
ffffffff81012d13:	5d                   	pop    %rbp
ffffffff81012d14:	c3                   	retq   
ffffffff81012d15:	90                   	nop

ffffffff81012d16 <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb>:
        return s;
    }
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P, E, L, B, F>::update(Quota &quota, E v, mword o, E p, mword a, Type t, bool set_cow) {
ffffffff81012d16:	41 57                	push   %r15
    unsigned long l = o / B, n = 1UL << o % B, s;
ffffffff81012d18:	48 89 c8             	mov    %rcx,%rax
        return s;
    }
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P, E, L, B, F>::update(Quota &quota, E v, mword o, E p, mword a, Type t, bool set_cow) {
ffffffff81012d1b:	41 56                	push   %r14
ffffffff81012d1d:	49 89 d7             	mov    %rdx,%r15
ffffffff81012d20:	41 55                	push   %r13
    unsigned long l = o / B, n = 1UL << o % B, s;
ffffffff81012d22:	31 d2                	xor    %edx,%edx
        return s;
    }
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P, E, L, B, F>::update(Quota &quota, E v, mword o, E p, mword a, Type t, bool set_cow) {
ffffffff81012d24:	41 54                	push   %r12
ffffffff81012d26:	55                   	push   %rbp
ffffffff81012d27:	49 89 f4             	mov    %rsi,%r12
ffffffff81012d2a:	53                   	push   %rbx
    unsigned long l = o / B, n = 1UL << o % B, s;
ffffffff81012d2b:	bb 09 00 00 00       	mov    $0x9,%ebx
ffffffff81012d30:	48 f7 f3             	div    %rbx
ffffffff81012d33:	b3 01                	mov    $0x1,%bl
        return s;
    }
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P, E, L, B, F>::update(Quota &quota, E v, mword o, E p, mword a, Type t, bool set_cow) {
ffffffff81012d35:	48 83 ec 28          	sub    $0x28,%rsp
ffffffff81012d39:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
    unsigned long l = o / B, n = 1UL << o % B, s;

    P *e = walk(quota, v, l, t == TYPE_UP);
ffffffff81012d3e:	45 31 c0             	xor    %r8d,%r8d
        return s;
    }
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P, E, L, B, F>::update(Quota &quota, E v, mword o, E p, mword a, Type t, bool set_cow) {
ffffffff81012d41:	4c 89 4c 24 10       	mov    %r9,0x10(%rsp)
ffffffff81012d46:	44 8b 74 24 68       	mov    0x68(%rsp),%r14d
    unsigned long l = o / B, n = 1UL << o % B, s;
ffffffff81012d4b:	48 89 d1             	mov    %rdx,%rcx
ffffffff81012d4e:	48 89 c5             	mov    %rax,%rbp
ffffffff81012d51:	48 89 d8             	mov    %rbx,%rax
ffffffff81012d54:	48 d3 e0             	shl    %cl,%rax

    P *e = walk(quota, v, l, t == TYPE_UP);
ffffffff81012d57:	83 7c 24 60 00       	cmpl   $0x0,0x60(%rsp)
ffffffff81012d5c:	48 89 e9             	mov    %rbp,%rcx
ffffffff81012d5f:	4c 89 fa             	mov    %r15,%rdx
    }
}

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P, E, L, B, F>::update(Quota &quota, E v, mword o, E p, mword a, Type t, bool set_cow) {
    unsigned long l = o / B, n = 1UL << o % B, s;
ffffffff81012d62:	48 89 44 24 08       	mov    %rax,0x8(%rsp)

    P *e = walk(quota, v, l, t == TYPE_UP);
ffffffff81012d67:	41 0f 94 c0          	sete   %r8b
ffffffff81012d6b:	e8 96 fc ff ff       	callq  ffffffff81012a06 <_ZN3PteI3HptmLj4ELj9ELb0EE4walkER5Quotammb>

    if (!e)
        return false;
ffffffff81012d70:	31 ff                	xor    %edi,%edi
bool Pte<P, E, L, B, F>::update(Quota &quota, E v, mword o, E p, mword a, Type t, bool set_cow) {
    unsigned long l = o / B, n = 1UL << o % B, s;

    P *e = walk(quota, v, l, t == TYPE_UP);

    if (!e)
ffffffff81012d72:	48 85 c0             	test   %rax,%rax

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P, E, L, B, F>::update(Quota &quota, E v, mword o, E p, mword a, Type t, bool set_cow) {
    unsigned long l = o / B, n = 1UL << o % B, s;

    P *e = walk(quota, v, l, t == TYPE_UP);
ffffffff81012d75:	49 89 c5             	mov    %rax,%r13

    if (!e)
ffffffff81012d78:	0f 84 d1 00 00 00    	je     ffffffff81012e4f <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb+0x139>
        return false;

    if (a) {
ffffffff81012d7e:	4c 8b 4c 24 10       	mov    0x10(%rsp),%r9
ffffffff81012d83:	4d 85 c9             	test   %r9,%r9
ffffffff81012d86:	74 3b                	je     ffffffff81012dc3 <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb+0xad>
        p |= P::order(o % B) | (l ? P::PTE_S : 0) | a;
ffffffff81012d88:	48 83 fd 01          	cmp    $0x1,%rbp
        s = 1UL << (l * B + PAGE_BITS);
ffffffff81012d8c:	8d 4c ed 00          	lea    0x0(%rbp,%rbp,8),%ecx

    if (!e)
        return false;

    if (a) {
        p |= P::order(o % B) | (l ? P::PTE_S : 0) | a;
ffffffff81012d90:	48 19 d2             	sbb    %rdx,%rdx
ffffffff81012d93:	4c 0b 4c 24 18       	or     0x18(%rsp),%r9
ffffffff81012d98:	48 f7 d2             	not    %rdx
        s = 1UL << (l * B + PAGE_BITS);
ffffffff81012d9b:	83 c1 0c             	add    $0xc,%ecx

    if (!e)
        return false;

    if (a) {
        p |= P::order(o % B) | (l ? P::PTE_S : 0) | a;
ffffffff81012d9e:	81 e2 80 00 00 00    	and    $0x80,%edx
        s = 1UL << (l * B + PAGE_BITS);
ffffffff81012da4:	48 d3 e3             	shl    %cl,%rbx

    if (!e)
        return false;

    if (a) {
        p |= P::order(o % B) | (l ? P::PTE_S : 0) | a;
ffffffff81012da7:	4c 09 ca             	or     %r9,%rdx
        s = 1UL << (l * B + PAGE_BITS);
        if (set_cow) {
ffffffff81012daa:	45 84 f6             	test   %r14b,%r14b

    if (!e)
        return false;

    if (a) {
        p |= P::order(o % B) | (l ? P::PTE_S : 0) | a;
ffffffff81012dad:	48 89 54 24 18       	mov    %rdx,0x18(%rsp)
        s = 1UL << (l * B + PAGE_BITS);
        if (set_cow) {
ffffffff81012db2:	74 1a                	je     ffffffff81012dce <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb+0xb8>
            set_cow_page(v, p);
ffffffff81012db4:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi
ffffffff81012db9:	4c 89 ff             	mov    %r15,%rdi
ffffffff81012dbc:	e8 fd fe ff ff       	callq  ffffffff81012cbe <_ZN3PteI3HptmLj4ELj9ELb0EE12set_cow_pageEmRm>
ffffffff81012dc1:	eb 0b                	jmp    ffffffff81012dce <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb+0xb8>
        }
    } else
        p = s = 0;
ffffffff81012dc3:	48 c7 44 24 18 00 00 	movq   $0x0,0x18(%rsp)
ffffffff81012dca:	00 00 
ffffffff81012dcc:	31 db                	xor    %ebx,%ebx
ffffffff81012dce:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
ffffffff81012dd3:	4d 89 ef             	mov    %r13,%r15

    bool flush_tlb = false;
ffffffff81012dd6:	31 ff                	xor    %edi,%edi
ffffffff81012dd8:	4d 8d 74 c5 00       	lea    0x0(%r13,%rax,8),%r14

    for (unsigned long i = 0; i < n; e[i].val = p, i++, p += s) {

        if (l && e[i].val != p)
            flush_tlb = true;
ffffffff81012ddd:	41 b5 01             	mov    $0x1,%r13b

    bool flush_tlb = false;

    for (unsigned long i = 0; i < n; e[i].val = p, i++, p += s) {

        if (l && e[i].val != p)
ffffffff81012de0:	48 85 ed             	test   %rbp,%rbp
ffffffff81012de3:	74 0c                	je     ffffffff81012df1 <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb+0xdb>
            flush_tlb = true;
ffffffff81012de5:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
ffffffff81012dea:	49 39 07             	cmp    %rax,(%r15)
ffffffff81012ded:	41 0f 45 fd          	cmovne %r13d,%edi

        if (!e[i].val)
ffffffff81012df1:	49 8b 37             	mov    (%r15),%rsi
ffffffff81012df4:	48 85 f6             	test   %rsi,%rsi
ffffffff81012df7:	0f 94 c2             	sete   %dl
            continue;

        if (t == TYPE_DF)
ffffffff81012dfa:	83 7c 24 60 02       	cmpl   $0x2,0x60(%rsp)
ffffffff81012dff:	0f 94 c0             	sete   %al
ffffffff81012e02:	09 d0                	or     %edx,%eax
            continue;

        if (l && !e[i].super()) {
ffffffff81012e04:	48 85 ed             	test   %rbp,%rbp
ffffffff81012e07:	0f 95 c2             	setne  %dl
ffffffff81012e0a:	38 d0                	cmp    %dl,%al
ffffffff81012e0c:	73 06                	jae    ffffffff81012e14 <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb+0xfe>
ffffffff81012e0e:	40 f6 c6 80          	test   $0x80,%sil
ffffffff81012e12:	74 19                	je     ffffffff81012e2d <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb+0x117>
    } else
        p = s = 0;

    bool flush_tlb = false;

    for (unsigned long i = 0; i < n; e[i].val = p, i++, p += s) {
ffffffff81012e14:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
ffffffff81012e19:	49 83 c7 08          	add    $0x8,%r15
ffffffff81012e1d:	49 89 47 f8          	mov    %rax,-0x8(%r15)
ffffffff81012e21:	48 01 5c 24 18       	add    %rbx,0x18(%rsp)
ffffffff81012e26:	4d 39 f7             	cmp    %r14,%r15
ffffffff81012e29:	75 b5                	jne    ffffffff81012de0 <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb+0xca>
ffffffff81012e2b:	eb 22                	jmp    ffffffff81012e4f <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb+0x139>
ffffffff81012e2d:	48 81 e6 00 f0 ff ff 	and    $0xfffffffffffff000,%rsi
ffffffff81012e34:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff81012e3b:	4c 89 e2             	mov    %r12,%rdx
ffffffff81012e3e:	48 81 c6 00 00 c0 80 	add    $0xffffffff80c00000,%rsi
ffffffff81012e45:	e8 64 e7 fe ff       	callq  ffffffff810015ae <_ZN5Buddy4freeEmR5Quota>
        if (t == TYPE_DF)
            continue;

        if (l && !e[i].super()) {
            Pte::destroy(static_cast<P *> (Buddy::phys_to_ptr(e[i].addr())), quota);
            flush_tlb = true;
ffffffff81012e4a:	40 b7 01             	mov    $0x1,%dil
ffffffff81012e4d:	eb c5                	jmp    ffffffff81012e14 <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb+0xfe>

    if (F)
        flush(e, n * sizeof (E));

    return flush_tlb;
}
ffffffff81012e4f:	48 83 c4 28          	add    $0x28,%rsp
ffffffff81012e53:	40 88 f8             	mov    %dil,%al
ffffffff81012e56:	5b                   	pop    %rbx
ffffffff81012e57:	5d                   	pop    %rbp
ffffffff81012e58:	41 5c                	pop    %r12
ffffffff81012e5a:	41 5d                	pop    %r13
ffffffff81012e5c:	41 5e                	pop    %r14
ffffffff81012e5e:	41 5f                	pop    %r15
ffffffff81012e60:	c3                   	retq   

ffffffff81012e61 <_ZN3PteI4VtlbyLj3ELj9ELb0EE7is_mmioEy>:
mword Ept::ord = ~0UL;
mword Hpt::ord = ~0UL;

template <typename P, typename E, unsigned L, unsigned B, bool F>
bool Pte<P, E, L, B, F>::is_mmio(E p) {
    Cow::block *b = Cow::ram_mem_list;
ffffffff81012e61:	48 8b 05 90 ef 00 00 	mov    0xef90(%rip),%rax        # ffffffff81021df8 <_ZN3Cow12ram_mem_listE>
    while (b != nullptr) {
ffffffff81012e68:	48 85 c0             	test   %rax,%rax
ffffffff81012e6b:	74 11                	je     ffffffff81012e7e <_ZN3PteI4VtlbyLj3ELj9ELb0EE7is_mmioEy+0x1d>
        //        Console::print("deb: %08lx  fin: %08lx  p: %08lx", b->start, b->end, p);
        if ((p >= b->start) && (p < b->end)) {
ffffffff81012e6d:	48 3b 38             	cmp    (%rax),%rdi
ffffffff81012e70:	72 06                	jb     ffffffff81012e78 <_ZN3PteI4VtlbyLj3ELj9ELb0EE7is_mmioEy+0x17>
ffffffff81012e72:	48 3b 78 08          	cmp    0x8(%rax),%rdi
ffffffff81012e76:	72 09                	jb     ffffffff81012e81 <_ZN3PteI4VtlbyLj3ELj9ELb0EE7is_mmioEy+0x20>
            return false;
        }
        b = b->next;
ffffffff81012e78:	48 8b 40 18          	mov    0x18(%rax),%rax
ffffffff81012e7c:	eb ea                	jmp    ffffffff81012e68 <_ZN3PteI4VtlbyLj3ELj9ELb0EE7is_mmioEy+0x7>
    }
    return true;
ffffffff81012e7e:	b0 01                	mov    $0x1,%al
ffffffff81012e80:	c3                   	retq   
bool Pte<P, E, L, B, F>::is_mmio(E p) {
    Cow::block *b = Cow::ram_mem_list;
    while (b != nullptr) {
        //        Console::print("deb: %08lx  fin: %08lx  p: %08lx", b->start, b->end, p);
        if ((p >= b->start) && (p < b->end)) {
            return false;
ffffffff81012e81:	31 c0                	xor    %eax,%eax
        }
        b = b->next;
    }
    return true;
}
ffffffff81012e83:	c3                   	retq   

ffffffff81012e84 <_ZN3PteI4VtlbyLj3ELj9ELb0EE12set_cow_pageEyRy>:
template <typename P, typename E, unsigned L, unsigned B, bool F>
/**
 * 
 *  */
void Pte<P, E, L, B, F>::set_cow_page(E virt, E &entry) {
    if ((virt < USER_ADDR) && (entry & P::PTE_P) && (entry & P::PTE_U)) {
ffffffff81012e84:	48 b8 ff ef ff ff ff 	movabs $0x7fffffffefff,%rax
ffffffff81012e8b:	7f 00 00 
ffffffff81012e8e:	48 39 c7             	cmp    %rax,%rdi
ffffffff81012e91:	77 41                	ja     ffffffff81012ed4 <_ZN3PteI4VtlbyLj3ELj9ELb0EE12set_cow_pageEyRy+0x50>

template <typename P, typename E, unsigned L, unsigned B, bool F>
/**
 * 
 *  */
void Pte<P, E, L, B, F>::set_cow_page(E virt, E &entry) {
ffffffff81012e93:	55                   	push   %rbp
ffffffff81012e94:	53                   	push   %rbx
ffffffff81012e95:	52                   	push   %rdx
    if ((virt < USER_ADDR) && (entry & P::PTE_P) && (entry & P::PTE_U)) {
ffffffff81012e96:	48 8b 1e             	mov    (%rsi),%rbx
ffffffff81012e99:	f6 c3 01             	test   $0x1,%bl
ffffffff81012e9c:	74 33                	je     ffffffff81012ed1 <_ZN3PteI4VtlbyLj3ELj9ELb0EE12set_cow_pageEyRy+0x4d>
        if (is_mmio(entry & ~PAGE_MASK)) {
ffffffff81012e9e:	48 89 df             	mov    %rbx,%rdi
ffffffff81012ea1:	48 89 f5             	mov    %rsi,%rbp
ffffffff81012ea4:	48 81 e7 00 f0 ff ff 	and    $0xfffffffffffff000,%rdi
ffffffff81012eab:	e8 b1 ff ff ff       	callq  ffffffff81012e61 <_ZN3PteI4VtlbyLj3ELj9ELb0EE7is_mmioEy>
ffffffff81012eb0:	84 c0                	test   %al,%al
ffffffff81012eb2:	74 0d                	je     ffffffff81012ec1 <_ZN3PteI4VtlbyLj3ELj9ELb0EE12set_cow_pageEyRy+0x3d>
            entry |= P::PTE_COW | P::PTE_COW_IO;
            entry &= ~P::PTE_P;
ffffffff81012eb4:	48 83 e3 fe          	and    $0xfffffffffffffffe,%rbx
ffffffff81012eb8:	48 81 cb 08 08 00 00 	or     $0x808,%rbx
ffffffff81012ebf:	eb 0c                	jmp    ffffffff81012ecd <_ZN3PteI4VtlbyLj3ELj9ELb0EE12set_cow_pageEyRy+0x49>
        } else if (entry & P::PTE_W) {
ffffffff81012ec1:	f6 c3 02             	test   $0x2,%bl
ffffffff81012ec4:	74 0b                	je     ffffffff81012ed1 <_ZN3PteI4VtlbyLj3ELj9ELb0EE12set_cow_pageEyRy+0x4d>
            entry |= P::PTE_COW;
            entry &= ~P::PTE_COW_IO;
            entry &= ~P::PTE_W;
ffffffff81012ec6:	48 83 e3 f5          	and    $0xfffffffffffffff5,%rbx
ffffffff81012eca:	80 cf 08             	or     $0x8,%bh
ffffffff81012ecd:	48 89 5d 00          	mov    %rbx,0x0(%rbp)
        }
    }
}
ffffffff81012ed1:	58                   	pop    %rax
ffffffff81012ed2:	5b                   	pop    %rbx
ffffffff81012ed3:	5d                   	pop    %rbp
ffffffff81012ed4:	c3                   	retq   
ffffffff81012ed5:	90                   	nop

ffffffff81012ed6 <_ZN3Rcu12invoke_batchEv>:
INIT_PRIORITY (PRIO_LOCAL) Rcu_list Rcu::curr;
INIT_PRIORITY (PRIO_LOCAL) Rcu_list Rcu::done;

void Rcu::invoke_batch()
{
    for (Rcu_elem *e = done.head, *n = nullptr; n != done.head; e = n) {
ffffffff81012ed6:	48 8b 05 43 c9 fe 3e 	mov    0x3efec943(%rip),%rax        # ffffffffbffff820 <_ZN3Rcu4doneE>
INIT_PRIORITY (PRIO_LOCAL) Rcu_list Rcu::next;
INIT_PRIORITY (PRIO_LOCAL) Rcu_list Rcu::curr;
INIT_PRIORITY (PRIO_LOCAL) Rcu_list Rcu::done;

void Rcu::invoke_batch()
{
ffffffff81012edd:	53                   	push   %rbx
    for (Rcu_elem *e = done.head, *n = nullptr; n != done.head; e = n) {
ffffffff81012ede:	31 db                	xor    %ebx,%ebx
ffffffff81012ee0:	48 3b 1d 39 c9 fe 3e 	cmp    0x3efec939(%rip),%rbx        # ffffffffbffff820 <_ZN3Rcu4doneE>
ffffffff81012ee7:	74 15                	je     ffffffff81012efe <_ZN3Rcu12invoke_batchEv+0x28>
        n = e->next;
ffffffff81012ee9:	48 8b 18             	mov    (%rax),%rbx
        e->next = nullptr;
        (e->func)(e);
ffffffff81012eec:	48 89 c7             	mov    %rax,%rdi

void Rcu::invoke_batch()
{
    for (Rcu_elem *e = done.head, *n = nullptr; n != done.head; e = n) {
        n = e->next;
        e->next = nullptr;
ffffffff81012eef:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
        (e->func)(e);
ffffffff81012ef6:	ff 50 08             	callq  *0x8(%rax)
INIT_PRIORITY (PRIO_LOCAL) Rcu_list Rcu::curr;
INIT_PRIORITY (PRIO_LOCAL) Rcu_list Rcu::done;

void Rcu::invoke_batch()
{
    for (Rcu_elem *e = done.head, *n = nullptr; n != done.head; e = n) {
ffffffff81012ef9:	48 89 d8             	mov    %rbx,%rax
ffffffff81012efc:	eb e2                	jmp    ffffffff81012ee0 <_ZN3Rcu12invoke_batchEv+0xa>

        ALWAYS_INLINE
        explicit Rcu_list() { clear(); }

        ALWAYS_INLINE
        inline void clear() { head = nullptr; tail = &head; count = 0;}
ffffffff81012efe:	48 c7 05 17 c9 fe 3e 	movq   $0x0,0x3efec917(%rip)        # ffffffffbffff820 <_ZN3Rcu4doneE>
ffffffff81012f05:	00 00 00 00 
ffffffff81012f09:	48 c7 05 14 c9 fe 3e 	movq   $0xffffffffbffff820,0x3efec914(%rip)        # ffffffffbffff828 <_ZN3Rcu4doneE+0x8>
ffffffff81012f10:	20 f8 ff bf 
ffffffff81012f14:	48 c7 05 11 c9 fe 3e 	movq   $0x0,0x3efec911(%rip)        # ffffffffbffff830 <_ZN3Rcu4doneE+0x10>
ffffffff81012f1b:	00 00 00 00 
        e->next = nullptr;
        (e->func)(e);
    }

    done.clear();
}
ffffffff81012f1f:	5b                   	pop    %rbx
ffffffff81012f20:	c3                   	retq   
ffffffff81012f21:	90                   	nop

ffffffff81012f22 <_ZN3Rcu11start_batchENS_5StateE>:

void Rcu::start_batch (State s)
{
    mword v, m = RCU_CMP | RCU_PND;

    do if ((v = state) >> 2 != l_batch) return; while (!(v & s) && !Atomic::cmp_swap (state, v, v | s));
ffffffff81012f22:	48 63 cf             	movslq %edi,%rcx
ffffffff81012f25:	48 8b 15 c4 ec 00 00 	mov    0xecc4(%rip),%rdx        # ffffffff81021bf0 <_ZN3Rcu5stateE>
ffffffff81012f2c:	48 89 d0             	mov    %rdx,%rax
ffffffff81012f2f:	48 c1 e8 02          	shr    $0x2,%rax
ffffffff81012f33:	48 3b 05 46 c9 fe 3e 	cmp    0x3efec946(%rip),%rax        # ffffffffbffff880 <_ZN3Rcu7l_batchE>
ffffffff81012f3a:	75 39                	jne    ffffffff81012f75 <_ZN3Rcu11start_batchENS_5StateE+0x53>
ffffffff81012f3c:	48 85 d1             	test   %rdx,%rcx
ffffffff81012f3f:	75 14                	jne    ffffffff81012f55 <_ZN3Rcu11start_batchENS_5StateE+0x33>
ffffffff81012f41:	48 89 ce             	mov    %rcx,%rsi
ffffffff81012f44:	48 89 d0             	mov    %rdx,%rax
ffffffff81012f47:	48 09 d6             	or     %rdx,%rsi
ffffffff81012f4a:	f0 48 0f b1 35 9d ec 	lock cmpxchg %rsi,0xec9d(%rip)        # ffffffff81021bf0 <_ZN3Rcu5stateE>
ffffffff81012f51:	00 00 
ffffffff81012f53:	75 d0                	jne    ffffffff81012f25 <_ZN3Rcu11start_batchENS_5StateE+0x3>

    if ((v ^ ~s) & m)
ffffffff81012f55:	f7 d7                	not    %edi
ffffffff81012f57:	48 31 d7             	xor    %rdx,%rdi
ffffffff81012f5a:	40 80 e7 03          	and    $0x3,%dil
ffffffff81012f5e:	75 15                	jne    ffffffff81012f75 <_ZN3Rcu11start_batchENS_5StateE+0x53>
        return;

    count = Cpu::online;
ffffffff81012f60:	8b 05 da f0 14 00    	mov    0x14f0da(%rip),%eax        # ffffffff81162040 <_ZN3Cpu6onlineE>
ffffffff81012f66:	48 89 05 c3 10 15 00 	mov    %rax,0x1510c3(%rip)        # ffffffff81164030 <_ZN3Rcu5countE>

    barrier();

    state++;
ffffffff81012f6d:	48 ff 05 7c ec 00 00 	incq   0xec7c(%rip)        # ffffffff81021bf0 <_ZN3Rcu5stateE>
ffffffff81012f74:	c3                   	retq   
ffffffff81012f75:	c3                   	retq   

ffffffff81012f76 <_ZN3Rcu5quietEv>:
}

void Rcu::quiet()
{
    Cpu::hazard &= ~HZD_RCU;
ffffffff81012f76:	83 25 83 c0 fe 3e ef 	andl   $0xffffffef,0x3efec083(%rip)        # ffffffffbffff000 <_ZN3Cpu6hazardE>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff81012f7d:	48 83 c8 ff          	or     $0xffffffffffffffff,%rax
ffffffff81012f81:	f0 48 0f c1 05 a6 10 	lock xadd %rax,0x1510a6(%rip)        # ffffffff81164030 <_ZN3Rcu5countE>
ffffffff81012f88:	15 00 

    if (Atomic::sub (count, 1UL) == 0)
ffffffff81012f8a:	48 ff c8             	dec    %rax
ffffffff81012f8d:	75 0a                	jne    ffffffff81012f99 <_ZN3Rcu5quietEv+0x23>
        start_batch (RCU_CMP);
ffffffff81012f8f:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff81012f94:	e9 89 ff ff ff       	jmpq   ffffffff81012f22 <_ZN3Rcu11start_batchENS_5StateE>
ffffffff81012f99:	c3                   	retq   

ffffffff81012f9a <_ZN3Rcu6updateEv>:
            RCU_CMP = 1UL << 0,
            RCU_PND = 1UL << 1,
        };

        ALWAYS_INLINE
        static inline mword batch() { return state >> 2; }
ffffffff81012f9a:	48 8b 15 4f ec 00 00 	mov    0xec4f(%rip),%rdx        # ffffffff81021bf0 <_ZN3Rcu5stateE>
}

void Rcu::update()
{
ffffffff81012fa1:	53                   	push   %rbx
ffffffff81012fa2:	48 c1 ea 02          	shr    $0x2,%rdx
    if (l_batch != batch()) {
ffffffff81012fa6:	48 39 15 d3 c8 fe 3e 	cmp    %rdx,0x3efec8d3(%rip)        # ffffffffbffff880 <_ZN3Rcu7l_batchE>
ffffffff81012fad:	74 1c                	je     ffffffff81012fcb <_ZN3Rcu6updateEv+0x31>
        }

        template <unsigned D, unsigned B>
        static void print (mword val, Console_vga::Color c, unsigned col)
        {
            if (EXPECT_FALSE (Cpu::row))
ffffffff81012faf:	8b 05 db c7 fe 3e    	mov    0x3efec7db(%rip),%eax        # ffffffffbffff790 <_ZN3Cpu3rowE>
        l_batch = batch();
        Cpu::hazard |= HZD_RCU;
ffffffff81012fb5:	83 0d 44 c0 fe 3e 10 	orl    $0x10,0x3efec044(%rip)        # ffffffffbffff000 <_ZN3Cpu6hazardE>
}

void Rcu::update()
{
    if (l_batch != batch()) {
        l_batch = batch();
ffffffff81012fbc:	48 89 15 bd c8 fe 3e 	mov    %rdx,0x3efec8bd(%rip)        # ffffffffbffff880 <_ZN3Rcu7l_batchE>
ffffffff81012fc3:	85 c0                	test   %eax,%eax
ffffffff81012fc5:	0f 85 da 01 00 00    	jne    ffffffff810131a5 <_ZN3Rcu6updateEv+0x20b>

        ALWAYS_INLINE
        inline void clear() { head = nullptr; tail = &head; count = 0;}

        ALWAYS_INLINE
        inline bool empty() { return &head == tail || head == nullptr; }
ffffffff81012fcb:	48 81 3d 72 c8 fe 3e 	cmpq   $0xffffffffbffff840,0x3efec872(%rip)        # ffffffffbffff848 <_ZN3Rcu4currE+0x8>
ffffffff81012fd2:	40 f8 ff bf 
ffffffff81012fd6:	74 7f                	je     ffffffff81013057 <_ZN3Rcu6updateEv+0xbd>
ffffffff81012fd8:	48 8b 0d 61 c8 fe 3e 	mov    0x3efec861(%rip),%rcx        # ffffffffbffff840 <_ZN3Rcu4currE>
ffffffff81012fdf:	48 85 c9             	test   %rcx,%rcx
ffffffff81012fe2:	74 73                	je     ffffffff81013057 <_ZN3Rcu6updateEv+0xbd>

        ALWAYS_INLINE
        static inline mword batch() { return state >> 2; }

        ALWAYS_INLINE
        static inline bool complete (mword b) { return static_cast<signed long>((state & ~RCU_PND) - (b << 2)) > 0; }
ffffffff81012fe4:	48 8b 35 8d c8 fe 3e 	mov    0x3efec88d(%rip),%rsi        # ffffffffbffff878 <_ZN3Rcu7c_batchE>
ffffffff81012feb:	48 8b 05 fe eb 00 00 	mov    0xebfe(%rip),%rax        # ffffffff81021bf0 <_ZN3Rcu5stateE>
ffffffff81012ff2:	48 8d 14 b5 00 00 00 	lea    0x0(,%rsi,4),%rdx
ffffffff81012ff9:	00 
ffffffff81012ffa:	48 83 e0 fd          	and    $0xfffffffffffffffd,%rax
ffffffff81012ffe:	48 29 d0             	sub    %rdx,%rax
        Cpu::hazard |= HZD_RCU;
        Counter::print<1,16> (l_batch, Console_vga::COLOR_LIGHT_GREEN, SPN_RCU);
    }

    if (!curr.empty() && complete (c_batch))
ffffffff81013001:	48 85 c0             	test   %rax,%rax
ffffffff81013004:	7e 51                	jle    ffffffff81013057 <_ZN3Rcu6updateEv+0xbd>
        inline bool empty() { return &head == tail || head == nullptr; }

        ALWAYS_INLINE
        inline void append (Rcu_list *l)
        {
           *tail   = l->head;
ffffffff81013006:	48 8b 05 1b c8 fe 3e 	mov    0x3efec81b(%rip),%rax        # ffffffffbffff828 <_ZN3Rcu4doneE+0x8>
ffffffff8101300d:	48 89 08             	mov    %rcx,(%rax)
            tail   = l->tail;
ffffffff81013010:	48 8b 05 31 c8 fe 3e 	mov    0x3efec831(%rip),%rax        # ffffffffbffff848 <_ZN3Rcu4currE+0x8>
           *tail   = head;
ffffffff81013017:	48 8b 15 02 c8 fe 3e 	mov    0x3efec802(%rip),%rdx        # ffffffffbffff820 <_ZN3Rcu4doneE>

        ALWAYS_INLINE
        inline void append (Rcu_list *l)
        {
           *tail   = l->head;
            tail   = l->tail;
ffffffff8101301e:	48 89 05 03 c8 fe 3e 	mov    %rax,0x3efec803(%rip)        # ffffffffbffff828 <_ZN3Rcu4doneE+0x8>
           *tail   = head;
ffffffff81013025:	48 89 10             	mov    %rdx,(%rax)

            count += l->count;
ffffffff81013028:	48 8b 05 21 c8 fe 3e 	mov    0x3efec821(%rip),%rax        # ffffffffbffff850 <_ZN3Rcu4currE+0x10>
ffffffff8101302f:	48 01 05 fa c7 fe 3e 	add    %rax,0x3efec7fa(%rip)        # ffffffffbffff830 <_ZN3Rcu4doneE+0x10>

        ALWAYS_INLINE
        explicit Rcu_list() { clear(); }

        ALWAYS_INLINE
        inline void clear() { head = nullptr; tail = &head; count = 0;}
ffffffff81013036:	48 c7 05 ff c7 fe 3e 	movq   $0x0,0x3efec7ff(%rip)        # ffffffffbffff840 <_ZN3Rcu4currE>
ffffffff8101303d:	00 00 00 00 
ffffffff81013041:	48 c7 05 fc c7 fe 3e 	movq   $0xffffffffbffff840,0x3efec7fc(%rip)        # ffffffffbffff848 <_ZN3Rcu4currE+0x8>
ffffffff81013048:	40 f8 ff bf 
ffffffff8101304c:	48 c7 05 f9 c7 fe 3e 	movq   $0x0,0x3efec7f9(%rip)        # ffffffffbffff850 <_ZN3Rcu4currE+0x10>
ffffffff81013053:	00 00 00 00 

        ALWAYS_INLINE
        inline bool empty() { return &head == tail || head == nullptr; }
ffffffff81013057:	48 8b 05 ea c7 fe 3e 	mov    0x3efec7ea(%rip),%rax        # ffffffffbffff848 <_ZN3Rcu4currE+0x8>
ffffffff8101305e:	48 3d 40 f8 ff bf    	cmp    $0xffffffffbffff840,%rax
ffffffff81013064:	74 0a                	je     ffffffff81013070 <_ZN3Rcu6updateEv+0xd6>
ffffffff81013066:	48 83 3d d2 c7 fe 3e 	cmpq   $0x0,0x3efec7d2(%rip)        # ffffffffbffff840 <_ZN3Rcu4currE>
ffffffff8101306d:	00 
ffffffff8101306e:	75 0d                	jne    ffffffff8101307d <_ZN3Rcu6updateEv+0xe3>
ffffffff81013070:	48 81 3d ed c7 fe 3e 	cmpq   $0xffffffffbffff860,0x3efec7ed(%rip)        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff81013077:	60 f8 ff bf 
ffffffff8101307b:	75 43                	jne    ffffffff810130c0 <_ZN3Rcu6updateEv+0x126>
ffffffff8101307d:	48 81 3d c0 c7 fe 3e 	cmpq   $0xffffffffbffff840,0x3efec7c0(%rip)        # ffffffffbffff848 <_ZN3Rcu4currE+0x8>
ffffffff81013084:	40 f8 ff bf 
ffffffff81013088:	75 12                	jne    ffffffff8101309c <_ZN3Rcu6updateEv+0x102>
ffffffff8101308a:	48 81 3d 93 c7 fe 3e 	cmpq   $0xffffffffbffff820,0x3efec793(%rip)        # ffffffffbffff828 <_ZN3Rcu4doneE+0x8>
ffffffff81013091:	20 f8 ff bf 
ffffffff81013095:	75 15                	jne    ffffffff810130ac <_ZN3Rcu6updateEv+0x112>
ffffffff81013097:	e9 2c 01 00 00       	jmpq   ffffffff810131c8 <_ZN3Rcu6updateEv+0x22e>
ffffffff8101309c:	48 83 3d 9c c7 fe 3e 	cmpq   $0x0,0x3efec79c(%rip)        # ffffffffbffff840 <_ZN3Rcu4currE>
ffffffff810130a3:	00 
ffffffff810130a4:	0f 85 8c 00 00 00    	jne    ffffffff81013136 <_ZN3Rcu6updateEv+0x19c>
ffffffff810130aa:	eb de                	jmp    ffffffff8101308a <_ZN3Rcu6updateEv+0xf0>
ffffffff810130ac:	48 83 3d 6c c7 fe 3e 	cmpq   $0x0,0x3efec76c(%rip)        # ffffffffbffff820 <_ZN3Rcu4doneE>
ffffffff810130b3:	00 
ffffffff810130b4:	0f 84 0e 01 00 00    	je     ffffffff810131c8 <_ZN3Rcu6updateEv+0x22e>
            Lapic::send_ipi (cpu, VEC_IPI_IDL);
        }

    if (!done.empty())
        invoke_batch();
}
ffffffff810130ba:	5b                   	pop    %rbx

            Lapic::send_ipi (cpu, VEC_IPI_IDL);
        }

    if (!done.empty())
        invoke_batch();
ffffffff810130bb:	e9 16 fe ff ff       	jmpq   ffffffff81012ed6 <_ZN3Rcu12invoke_batchEv>
ffffffff810130c0:	48 8b 15 99 c7 fe 3e 	mov    0x3efec799(%rip),%rdx        # ffffffffbffff860 <_ZN3Rcu4nextE>
ffffffff810130c7:	48 85 d2             	test   %rdx,%rdx
ffffffff810130ca:	74 b1                	je     ffffffff8101307d <_ZN3Rcu6updateEv+0xe3>

        ALWAYS_INLINE
        inline void append (Rcu_list *l)
        {
           *tail   = l->head;
ffffffff810130cc:	48 89 10             	mov    %rdx,(%rax)
            tail   = l->tail;
ffffffff810130cf:	48 8b 05 92 c7 fe 3e 	mov    0x3efec792(%rip),%rax        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
    if (curr.empty() && !next.empty()) {
        curr.append (&next);

        c_batch = l_batch + 1;

        start_batch (RCU_PND);
ffffffff810130d6:	bf 02 00 00 00       	mov    $0x2,%edi
           *tail   = head;
ffffffff810130db:	48 8b 15 5e c7 fe 3e 	mov    0x3efec75e(%rip),%rdx        # ffffffffbffff840 <_ZN3Rcu4currE>

        ALWAYS_INLINE
        inline void append (Rcu_list *l)
        {
           *tail   = l->head;
            tail   = l->tail;
ffffffff810130e2:	48 89 05 5f c7 fe 3e 	mov    %rax,0x3efec75f(%rip)        # ffffffffbffff848 <_ZN3Rcu4currE+0x8>
           *tail   = head;
ffffffff810130e9:	48 89 10             	mov    %rdx,(%rax)

            count += l->count;
ffffffff810130ec:	48 8b 05 7d c7 fe 3e 	mov    0x3efec77d(%rip),%rax        # ffffffffbffff870 <_ZN3Rcu4nextE+0x10>
ffffffff810130f3:	48 01 05 56 c7 fe 3e 	add    %rax,0x3efec756(%rip)        # ffffffffbffff850 <_ZN3Rcu4currE+0x10>
        done.append (&curr);

    if (curr.empty() && !next.empty()) {
        curr.append (&next);

        c_batch = l_batch + 1;
ffffffff810130fa:	48 8b 05 7f c7 fe 3e 	mov    0x3efec77f(%rip),%rax        # ffffffffbffff880 <_ZN3Rcu7l_batchE>

        ALWAYS_INLINE
        explicit Rcu_list() { clear(); }

        ALWAYS_INLINE
        inline void clear() { head = nullptr; tail = &head; count = 0;}
ffffffff81013101:	48 c7 05 54 c7 fe 3e 	movq   $0x0,0x3efec754(%rip)        # ffffffffbffff860 <_ZN3Rcu4nextE>
ffffffff81013108:	00 00 00 00 
ffffffff8101310c:	48 c7 05 51 c7 fe 3e 	movq   $0xffffffffbffff860,0x3efec751(%rip)        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff81013113:	60 f8 ff bf 
ffffffff81013117:	48 c7 05 4e c7 fe 3e 	movq   $0x0,0x3efec74e(%rip)        # ffffffffbffff870 <_ZN3Rcu4nextE+0x10>
ffffffff8101311e:	00 00 00 00 
ffffffff81013122:	48 ff c0             	inc    %rax
ffffffff81013125:	48 89 05 4c c7 fe 3e 	mov    %rax,0x3efec74c(%rip)        # ffffffffbffff878 <_ZN3Rcu7c_batchE>

        start_batch (RCU_PND);
ffffffff8101312c:	e8 f1 fd ff ff       	callq  ffffffff81012f22 <_ZN3Rcu11start_batchENS_5StateE>
ffffffff81013131:	e9 47 ff ff ff       	jmpq   ffffffff8101307d <_ZN3Rcu6updateEv+0xe3>

        ALWAYS_INLINE
        inline bool empty() { return &head == tail || head == nullptr; }
ffffffff81013136:	48 81 3d 27 c7 fe 3e 	cmpq   $0xffffffffbffff860,0x3efec727(%rip)        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff8101313d:	60 f8 ff bf 
ffffffff81013141:	0f 84 43 ff ff ff    	je     ffffffff8101308a <_ZN3Rcu6updateEv+0xf0>
ffffffff81013147:	48 83 3d 11 c7 fe 3e 	cmpq   $0x0,0x3efec711(%rip)        # ffffffffbffff860 <_ZN3Rcu4nextE>
ffffffff8101314e:	00 
ffffffff8101314f:	0f 84 35 ff ff ff    	je     ffffffff8101308a <_ZN3Rcu6updateEv+0xf0>
    }

    if (!curr.empty() && !next.empty() && (next.count > 2000 || curr.count > 2000))
ffffffff81013155:	48 81 3d 10 c7 fe 3e 	cmpq   $0x7d0,0x3efec710(%rip)        # ffffffffbffff870 <_ZN3Rcu4nextE+0x10>
ffffffff8101315c:	d0 07 00 00 
ffffffff81013160:	77 11                	ja     ffffffff81013173 <_ZN3Rcu6updateEv+0x1d9>
ffffffff81013162:	48 81 3d e3 c6 fe 3e 	cmpq   $0x7d0,0x3efec6e3(%rip)        # ffffffffbffff850 <_ZN3Rcu4currE+0x10>
ffffffff81013169:	d0 07 00 00 
ffffffff8101316d:	0f 86 17 ff ff ff    	jbe    ffffffff8101308a <_ZN3Rcu6updateEv+0xf0>
ffffffff81013173:	31 db                	xor    %ebx,%ebx
ffffffff81013175:	f6 04 dd 38 70 16 81 	testb  $0x1,-0x7ee98fc8(,%rbx,8)
ffffffff8101317c:	01 
ffffffff8101317d:	74 18                	je     ffffffff81013197 <_ZN3Rcu6updateEv+0x1fd>
        for (unsigned cpu = 0; cpu < NUM_CPU; cpu++) {

            if (!Hip::cpu_online (cpu) || Cpu::id == cpu)
ffffffff8101317f:	39 1d 7f be fe 3e    	cmp    %ebx,0x3efebe7f(%rip)        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81013185:	74 10                	je     ffffffff81013197 <_ZN3Rcu6updateEv+0x1fd>
                continue;

            Lapic::send_ipi (cpu, VEC_IPI_IDL);
ffffffff81013187:	31 c9                	xor    %ecx,%ecx
ffffffff81013189:	31 d2                	xor    %edx,%edx
ffffffff8101318b:	be a9 00 00 00       	mov    $0xa9,%esi
ffffffff81013190:	89 df                	mov    %ebx,%edi
ffffffff81013192:	e8 97 52 ff ff       	callq  ffffffff8100842e <_ZN5Lapic8send_ipiEjjNS_13Delivery_modeENS_9ShorthandE>
ffffffff81013197:	48 ff c3             	inc    %rbx

        start_batch (RCU_PND);
    }

    if (!curr.empty() && !next.empty() && (next.count > 2000 || curr.count > 2000))
        for (unsigned cpu = 0; cpu < NUM_CPU; cpu++) {
ffffffff8101319a:	48 83 fb 40          	cmp    $0x40,%rbx
ffffffff8101319e:	75 d5                	jne    ffffffff81013175 <_ZN3Rcu6updateEv+0x1db>
ffffffff810131a0:	e9 e5 fe ff ff       	jmpq   ffffffff8101308a <_ZN3Rcu6updateEv+0xf0>
                for (unsigned i = 0; i < D; i++, val /= B)
                    Console_vga::con.put (Cpu::row, col - i, c, !i || val ? (val % B)["0123456789ABCDEF"] : ' ');
ffffffff810131a5:	83 e2 0f             	and    $0xf,%edx
ffffffff810131a8:	48 6b c0 50          	imul   $0x50,%rax,%rax
ffffffff810131ac:	66 0f be 92 d8 d7 01 	movsbw -0x7efe2828(%rdx),%dx
ffffffff810131b3:	81 
ffffffff810131b4:	48 83 c0 02          	add    $0x2,%rax
ffffffff810131b8:	80 ce 0a             	or     $0xa,%dh
ffffffff810131bb:	66 89 94 00 00 f0 df 	mov    %dx,-0x40201000(%rax,%rax,1)
ffffffff810131c2:	bf 
ffffffff810131c3:	e9 03 fe ff ff       	jmpq   ffffffff81012fcb <_ZN3Rcu6updateEv+0x31>
            Lapic::send_ipi (cpu, VEC_IPI_IDL);
        }

    if (!done.empty())
        invoke_batch();
}
ffffffff810131c8:	5b                   	pop    %rbx
ffffffff810131c9:	c3                   	retq   

ffffffff810131ca <_GLOBAL__sub_I.65534__ZN3Rcu5stateE>:

        ALWAYS_INLINE
        explicit Rcu_list() { clear(); }

        ALWAYS_INLINE
        inline void clear() { head = nullptr; tail = &head; count = 0;}
ffffffff810131ca:	48 c7 05 8b c6 fe 3e 	movq   $0x0,0x3efec68b(%rip)        # ffffffffbffff860 <_ZN3Rcu4nextE>
ffffffff810131d1:	00 00 00 00 
ffffffff810131d5:	48 c7 05 88 c6 fe 3e 	movq   $0xffffffffbffff860,0x3efec688(%rip)        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff810131dc:	60 f8 ff bf 
ffffffff810131e0:	48 c7 05 85 c6 fe 3e 	movq   $0x0,0x3efec685(%rip)        # ffffffffbffff870 <_ZN3Rcu4nextE+0x10>
ffffffff810131e7:	00 00 00 00 
ffffffff810131eb:	48 c7 05 4a c6 fe 3e 	movq   $0x0,0x3efec64a(%rip)        # ffffffffbffff840 <_ZN3Rcu4currE>
ffffffff810131f2:	00 00 00 00 
ffffffff810131f6:	48 c7 05 47 c6 fe 3e 	movq   $0xffffffffbffff840,0x3efec647(%rip)        # ffffffffbffff848 <_ZN3Rcu4currE+0x8>
ffffffff810131fd:	40 f8 ff bf 
ffffffff81013201:	48 c7 05 44 c6 fe 3e 	movq   $0x0,0x3efec644(%rip)        # ffffffffbffff850 <_ZN3Rcu4currE+0x10>
ffffffff81013208:	00 00 00 00 
ffffffff8101320c:	48 c7 05 09 c6 fe 3e 	movq   $0x0,0x3efec609(%rip)        # ffffffffbffff820 <_ZN3Rcu4doneE>
ffffffff81013213:	00 00 00 00 
ffffffff81013217:	48 c7 05 06 c6 fe 3e 	movq   $0xffffffffbffff820,0x3efec606(%rip)        # ffffffffbffff828 <_ZN3Rcu4doneE+0x8>
ffffffff8101321e:	20 f8 ff bf 
ffffffff81013222:	48 c7 05 03 c6 fe 3e 	movq   $0x0,0x3efec603(%rip)        # ffffffffbffff830 <_ZN3Rcu4doneE+0x10>
ffffffff81013229:	00 00 00 00 
ffffffff8101322d:	c3                   	retq   

ffffffff8101322e <_ZNK8Exc_regs11get_g_cs_dlI4VmcbEEmv>:
#include "vmx.hpp"
#include "vpid.hpp"
#include "vtlb.hpp"

template <> mword Exc_regs::get_g_cs_dl<Vmcb>() const {
    return static_cast<mword> (vmcb->cs.ar) >> 9 & 0x3;
ffffffff8101322e:	48 8b 87 80 00 00 00 	mov    0x80(%rdi),%rax
ffffffff81013235:	0f b7 80 12 04 00 00 	movzwl 0x412(%rax),%eax
ffffffff8101323c:	48 c1 e8 09          	shr    $0x9,%rax
ffffffff81013240:	83 e0 03             	and    $0x3,%eax
}
ffffffff81013243:	c3                   	retq   

ffffffff81013244 <_ZNK8Exc_regs9tlb_flushI4VmcbEEvb>:

template <> void Exc_regs::set_s_cr4<Vmcs> (mword v) {
    Vmcs::write(Vmcs::CR4_READ_SHADOW, cr4_shadow = v);
}

template <> void Exc_regs::tlb_flush<Vmcb>(bool full) const {
ffffffff81013244:	53                   	push   %rbx
ffffffff81013245:	48 89 fb             	mov    %rdi,%rbx
    vtlb->flush(full);
ffffffff81013248:	48 8b bf 88 00 00 00 	mov    0x88(%rdi),%rdi
ffffffff8101324f:	40 0f b6 f6          	movzbl %sil,%esi
ffffffff81013253:	e8 00 9b 00 00       	callq  ffffffff8101cd58 <_ZN4Vtlb5flushEb>

    if (vmcb->asid)
ffffffff81013258:	48 8b 83 80 00 00 00 	mov    0x80(%rbx),%rax
ffffffff8101325f:	83 78 58 00          	cmpl   $0x0,0x58(%rax)
ffffffff81013263:	74 07                	je     ffffffff8101326c <_ZNK8Exc_regs9tlb_flushI4VmcbEEvb+0x28>
        vmcb->tlb_control = 1;
ffffffff81013265:	c7 40 5c 01 00 00 00 	movl   $0x1,0x5c(%rax)
}
ffffffff8101326c:	5b                   	pop    %rbx
ffffffff8101326d:	c3                   	retq   

ffffffff8101326e <_ZNK8Exc_regs9tlb_flushI4VmcsEEvb>:

template <> void Exc_regs::tlb_flush<Vmcs>(bool full) const {
ffffffff8101326e:	53                   	push   %rbx
ffffffff8101326f:	89 f3                	mov    %esi,%ebx
    vtlb->flush(full);
ffffffff81013271:	40 0f b6 f6          	movzbl %sil,%esi

    if (vmcb->asid)
        vmcb->tlb_control = 1;
}

template <> void Exc_regs::tlb_flush<Vmcs>(bool full) const {
ffffffff81013275:	48 83 ec 10          	sub    $0x10,%rsp
    vtlb->flush(full);
ffffffff81013279:	48 8b bf 88 00 00 00 	mov    0x88(%rdi),%rdi
ffffffff81013280:	e8 d3 9a 00 00       	callq  ffffffff8101cd58 <_ZN4Vtlb5flushEb>
        }

        ALWAYS_INLINE
        static inline unsigned long vpid()
        {
            return has_vpid() ? read (VPID) : 0;
ffffffff81013285:	f6 05 e0 cb fe 3e 20 	testb  $0x20,0x3efecbe0(%rip)        # ffffffffbffffe6c <_ZN4Vmcs8ctrl_cpuE+0xc>
ffffffff8101328c:	74 27                	je     ffffffff810132b5 <_ZNK8Exc_regs9tlb_flushI4VmcsEEvb+0x47>

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
ffffffff8101328e:	31 d2                	xor    %edx,%edx
ffffffff81013290:	0f 78 d2             	vmread %rdx,%rdx

    mword vpid = Vmcs::vpid();

    if (vpid)
ffffffff81013293:	48 85 d2             	test   %rdx,%rdx
ffffffff81013296:	74 1d                	je     ffffffff810132b5 <_ZNK8Exc_regs9tlb_flushI4VmcsEEvb+0x47>
        Vpid::flush(full ? Vpid::CONTEXT_GLOBAL : Vpid::CONTEXT_NOGLOBAL, vpid);
ffffffff81013298:	80 fb 01             	cmp    $0x1,%bl
        uint64  vpid;
        uint64  addr;

    public:
        ALWAYS_INLINE
        inline Invvpid (unsigned long v, mword a) : vpid (v), addr (a) {}
ffffffff8101329b:	48 89 14 24          	mov    %rdx,(%rsp)
ffffffff8101329f:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
ffffffff810132a6:	00 00 
ffffffff810132a8:	19 c0                	sbb    %eax,%eax
ffffffff810132aa:	83 e0 02             	and    $0x2,%eax
        };

        ALWAYS_INLINE
        static inline void flush (Type t, unsigned long vpid, mword addr = 0)
        {
            asm volatile ("invvpid %0, %1" : : "m" (Invvpid (vpid, addr)), "r" (static_cast<mword>(t)) : "cc");
ffffffff810132ad:	ff c0                	inc    %eax
ffffffff810132af:	66 0f 38 81 04 24    	invvpid (%rsp),%rax
}
ffffffff810132b5:	48 83 c4 10          	add    $0x10,%rsp
ffffffff810132b9:	5b                   	pop    %rbx
ffffffff810132ba:	c3                   	retq   
ffffffff810132bb:	90                   	nop

ffffffff810132bc <_ZNK8Exc_regs9tlb_flushI4VmcsEEvm>:

template <> void Exc_regs::tlb_flush<Vmcs>(mword addr) const {
ffffffff810132bc:	53                   	push   %rbx
ffffffff810132bd:	48 89 f3             	mov    %rsi,%rbx
ffffffff810132c0:	48 83 ec 10          	sub    $0x10,%rsp
    vtlb->flush(addr);
ffffffff810132c4:	48 8b bf 88 00 00 00 	mov    0x88(%rdi),%rdi
ffffffff810132cb:	e8 b2 9a 00 00       	callq  ffffffff8101cd82 <_ZN4Vtlb5flushEm>
        }

        ALWAYS_INLINE
        static inline unsigned long vpid()
        {
            return has_vpid() ? read (VPID) : 0;
ffffffff810132d0:	f6 05 95 cb fe 3e 20 	testb  $0x20,0x3efecb95(%rip)        # ffffffffbffffe6c <_ZN4Vmcs8ctrl_cpuE+0xc>
ffffffff810132d7:	74 1b                	je     ffffffff810132f4 <_ZNK8Exc_regs9tlb_flushI4VmcsEEvm+0x38>

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
ffffffff810132d9:	31 c0                	xor    %eax,%eax
ffffffff810132db:	0f 78 c0             	vmread %rax,%rax

    mword vpid = Vmcs::vpid();

    if (vpid)
ffffffff810132de:	48 85 c0             	test   %rax,%rax
ffffffff810132e1:	74 11                	je     ffffffff810132f4 <_ZNK8Exc_regs9tlb_flushI4VmcsEEvm+0x38>
        uint64  vpid;
        uint64  addr;

    public:
        ALWAYS_INLINE
        inline Invvpid (unsigned long v, mword a) : vpid (v), addr (a) {}
ffffffff810132e3:	48 89 04 24          	mov    %rax,(%rsp)
ffffffff810132e7:	48 89 5c 24 08       	mov    %rbx,0x8(%rsp)
        };

        ALWAYS_INLINE
        static inline void flush (Type t, unsigned long vpid, mword addr = 0)
        {
            asm volatile ("invvpid %0, %1" : : "m" (Invvpid (vpid, addr)), "r" (static_cast<mword>(t)) : "cc");
ffffffff810132ec:	31 c0                	xor    %eax,%eax
ffffffff810132ee:	66 0f 38 81 04 24    	invvpid (%rsp),%rax
        Vpid::flush(Vpid::ADDRESS, vpid, addr);
}
ffffffff810132f4:	48 83 c4 10          	add    $0x10,%rsp
ffffffff810132f8:	5b                   	pop    %rbx
ffffffff810132f9:	c3                   	retq   

ffffffff810132fa <_ZN8Exc_regs17svm_set_cpu_ctrl0Em>:
        msk |= 1UL << Cpu::EXC_NM;

    set_e_bmp<T> (msk);
}

void Exc_regs::svm_set_cpu_ctrl0(mword val) {
ffffffff810132fa:	0f b6 97 c0 00 00 00 	movzbl 0xc0(%rdi),%edx
template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
ffffffff81013301:	b9 01 00 01 80       	mov    $0x80010001,%ecx
ffffffff81013306:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff8101330b:	84 d2                	test   %dl,%dl
ffffffff8101330d:	48 0f 44 c1          	cmove  %rcx,%rax
    if (!fpu_on)
        set |= Cpu::CR0_TS;
ffffffff81013311:	48 89 c1             	mov    %rax,%rcx
ffffffff81013314:	48 83 c9 08          	or     $0x8,%rcx
ffffffff81013318:	80 bf c1 00 00 00 00 	cmpb   $0x0,0xc1(%rdi)
ffffffff8101331f:	48 0f 44 c1          	cmove  %rcx,%rax

    set_e_bmp<T> (msk);
}

void Exc_regs::svm_set_cpu_ctrl0(mword val) {
    unsigned const msk = !!cr0_msk<Vmcb>() << 0 | !nst_on << 3 | !!cr4_msk<Vmcb>() << 4;
ffffffff81013323:	48 85 c0             	test   %rax,%rax
ffffffff81013326:	0f 95 c0             	setne  %al
ffffffff81013329:	80 fa 01             	cmp    $0x1,%dl
ffffffff8101332c:	45 19 c0             	sbb    %r8d,%r8d
ffffffff8101332f:	0f b6 c0             	movzbl %al,%eax
ffffffff81013332:	41 83 e0 08          	and    $0x8,%r8d
ffffffff81013336:	41 09 c0             	or     %eax,%r8d
mword Exc_regs::cr4_msk() const {
    mword clr = nst_on ? 0 :
#ifdef __i386__
            Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
            Cpu::CR4_PGE;
ffffffff81013339:	80 fa 01             	cmp    $0x1,%dl
ffffffff8101333c:	48 19 c0             	sbb    %rax,%rax
ffffffff8101333f:	25 80 00 00 00       	and    $0x80,%eax
ffffffff81013344:	80 fa 01             	cmp    $0x1,%dl
ffffffff81013347:	48 19 c9             	sbb    %rcx,%rcx
ffffffff8101334a:	83 e1 30             	and    $0x30,%ecx
#endif

    return T::fix_cr4_clr | clr | cr4_set<T>();
ffffffff8101334d:	48 09 c1             	or     %rax,%rcx

    set_e_bmp<T> (msk);
}

void Exc_regs::svm_set_cpu_ctrl0(mword val) {
    unsigned const msk = !!cr0_msk<Vmcb>() << 0 | !nst_on << 3 | !!cr4_msk<Vmcb>() << 4;
ffffffff81013350:	48 83 f9 01          	cmp    $0x1,%rcx

    vmcb->npt_control = nst_on;
ffffffff81013354:	48 8b 8f 80 00 00 00 	mov    0x80(%rdi),%rcx

    set_e_bmp<T> (msk);
}

void Exc_regs::svm_set_cpu_ctrl0(mword val) {
    unsigned const msk = !!cr0_msk<Vmcb>() << 0 | !nst_on << 3 | !!cr4_msk<Vmcb>() << 4;
ffffffff8101335b:	19 c0                	sbb    %eax,%eax
ffffffff8101335d:	f7 d0                	not    %eax
ffffffff8101335f:	83 e0 10             	and    $0x10,%eax

    vmcb->npt_control = nst_on;
ffffffff81013362:	48 89 91 90 00 00 00 	mov    %rdx,0x90(%rcx)
    vmcb->intercept_cr = (msk << 16) | msk;
ffffffff81013369:	48 8b 97 80 00 00 00 	mov    0x80(%rdi),%rdx

    set_e_bmp<T> (msk);
}

void Exc_regs::svm_set_cpu_ctrl0(mword val) {
    unsigned const msk = !!cr0_msk<Vmcb>() << 0 | !nst_on << 3 | !!cr4_msk<Vmcb>() << 4;
ffffffff81013370:	44 09 c0             	or     %r8d,%eax

    vmcb->npt_control = nst_on;
    vmcb->intercept_cr = (msk << 16) | msk;
ffffffff81013373:	89 c1                	mov    %eax,%ecx
ffffffff81013375:	c1 e1 10             	shl    $0x10,%ecx
ffffffff81013378:	09 c8                	or     %ecx,%eax
ffffffff8101337a:	89 02                	mov    %eax,(%rdx)

    if (nst_on)
ffffffff8101337c:	80 bf c0 00 00 00 00 	cmpb   $0x0,0xc0(%rdi)
ffffffff81013383:	48 8b 87 80 00 00 00 	mov    0x80(%rdi),%rax
ffffffff8101338a:	74 0e                	je     ffffffff8101339a <_ZN8Exc_regs17svm_set_cpu_ctrl0Em+0xa0>
        vmcb->intercept_cpu[0] = static_cast<uint32> ((val & ~Vmcb::CPU_INVLPG) | Vmcb::force_ctrl0);
ffffffff8101338c:	81 e6 f4 ff bf 64    	and    $0x64bffff4,%esi
ffffffff81013392:	81 ce 0b 00 40 99    	or     $0x9940000b,%esi
ffffffff81013398:	eb 06                	jmp    ffffffff810133a0 <_ZN8Exc_regs17svm_set_cpu_ctrl0Em+0xa6>
    else
        vmcb->intercept_cpu[0] = static_cast<uint32> ((val | Vmcb::CPU_INVLPG) | Vmcb::force_ctrl0);
ffffffff8101339a:	81 ce 0b 00 40 9b    	or     $0x9b40000b,%esi
ffffffff810133a0:	89 70 0c             	mov    %esi,0xc(%rax)
ffffffff810133a3:	c3                   	retq   

ffffffff810133a4 <_ZN8Exc_regs17svm_set_cpu_ctrl1Em>:
}

void Exc_regs::svm_set_cpu_ctrl1(mword val) {
    vmcb->intercept_cpu[1] = static_cast<uint32> (val | Vmcb::force_ctrl1);
ffffffff810133a4:	48 8b 87 80 00 00 00 	mov    0x80(%rdi),%rax
ffffffff810133ab:	83 ce 6c             	or     $0x6c,%esi
ffffffff810133ae:	89 70 10             	mov    %esi,0x10(%rax)
ffffffff810133b1:	c3                   	retq   

ffffffff810133b2 <_ZN8Exc_regs17vmx_set_cpu_ctrl0Em>:
    unsigned const msk = Vmcs::CPU_INVLPG | Vmcs::CPU_CR3_LOAD | Vmcs::CPU_CR3_STORE;

    if (nst_on)
        val &= ~msk;
    else
        val |= msk;
ffffffff810133b2:	48 89 f2             	mov    %rsi,%rdx

void Exc_regs::vmx_set_cpu_ctrl0(mword val) {
    unsigned const msk = Vmcs::CPU_INVLPG | Vmcs::CPU_CR3_LOAD | Vmcs::CPU_CR3_STORE;

    if (nst_on)
        val &= ~msk;
ffffffff810133b5:	81 e6 ff 7d fe ff    	and    $0xfffe7dff,%esi
    else
        val |= msk;

    val |= Vmcs::ctrl_cpu[0].set;
ffffffff810133bb:	8b 05 9f ca fe 3e    	mov    0x3efeca9f(%rip),%eax        # ffffffffbffffe60 <_ZN4Vmcs8ctrl_cpuE>
    unsigned const msk = Vmcs::CPU_INVLPG | Vmcs::CPU_CR3_LOAD | Vmcs::CPU_CR3_STORE;

    if (nst_on)
        val &= ~msk;
    else
        val |= msk;
ffffffff810133c1:	48 81 ca 00 82 01 00 	or     $0x18200,%rdx

void Exc_regs::vmx_set_cpu_ctrl0(mword val) {
    unsigned const msk = Vmcs::CPU_INVLPG | Vmcs::CPU_CR3_LOAD | Vmcs::CPU_CR3_STORE;

    if (nst_on)
        val &= ~msk;
ffffffff810133c8:	80 bf c0 00 00 00 00 	cmpb   $0x0,0xc0(%rdi)
ffffffff810133cf:	48 0f 45 d6          	cmovne %rsi,%rdx
    else
        val |= msk;

    val |= Vmcs::ctrl_cpu[0].set;
ffffffff810133d3:	48 09 d0             	or     %rdx,%rax
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
ffffffff810133d6:	ba 02 40 00 00       	mov    $0x4002,%edx
    val &= Vmcs::ctrl_cpu[0].clr;
ffffffff810133db:	23 05 83 ca fe 3e    	and    0x3efeca83(%rip),%eax        # ffffffffbffffe64 <_ZN4Vmcs8ctrl_cpuE+0x4>
ffffffff810133e1:	0f 79 d0             	vmwrite %rax,%rdx
ffffffff810133e4:	c3                   	retq   
ffffffff810133e5:	90                   	nop

ffffffff810133e6 <_ZN8Exc_regs17vmx_set_cpu_ctrl1Em>:
    unsigned const msk = Vmcs::CPU_EPT;

    if (nst_on)
        val |= msk;
    else
        val &= ~msk;
ffffffff810133e6:	48 89 f2             	mov    %rsi,%rdx

void Exc_regs::vmx_set_cpu_ctrl1(mword val) {
    unsigned const msk = Vmcs::CPU_EPT;

    if (nst_on)
        val |= msk;
ffffffff810133e9:	48 83 ce 02          	or     $0x2,%rsi
    else
        val &= ~msk;

    val |= Vmcs::ctrl_cpu[1].set;
ffffffff810133ed:	8b 05 75 ca fe 3e    	mov    0x3efeca75(%rip),%eax        # ffffffffbffffe68 <_ZN4Vmcs8ctrl_cpuE+0x8>
    unsigned const msk = Vmcs::CPU_EPT;

    if (nst_on)
        val |= msk;
    else
        val &= ~msk;
ffffffff810133f3:	83 e2 fd             	and    $0xfffffffd,%edx

void Exc_regs::vmx_set_cpu_ctrl1(mword val) {
    unsigned const msk = Vmcs::CPU_EPT;

    if (nst_on)
        val |= msk;
ffffffff810133f6:	80 bf c0 00 00 00 00 	cmpb   $0x0,0xc0(%rdi)
ffffffff810133fd:	48 0f 45 d6          	cmovne %rsi,%rdx
    else
        val &= ~msk;

    val |= Vmcs::ctrl_cpu[1].set;
ffffffff81013401:	48 09 d0             	or     %rdx,%rax
ffffffff81013404:	ba 1e 40 00 00       	mov    $0x401e,%edx
    val &= Vmcs::ctrl_cpu[1].clr;
ffffffff81013409:	23 05 5d ca fe 3e    	and    0x3efeca5d(%rip),%eax        # ffffffffbffffe6c <_ZN4Vmcs8ctrl_cpuE+0xc>
ffffffff8101340f:	0f 79 d0             	vmwrite %rax,%rdx
ffffffff81013412:	c3                   	retq   
ffffffff81013413:	90                   	nop

ffffffff81013414 <_ZN8Exc_regs8nst_ctrlI4VmcbEEvb>:

    Vmcs::write(Vmcs::CPU_EXEC_CTRL1, val);
}

template <> void Exc_regs::nst_ctrl<Vmcb>(bool on) {
ffffffff81013414:	53                   	push   %rbx
ffffffff81013415:	8a 8f c0 00 00 00    	mov    0xc0(%rdi),%cl
ffffffff8101341b:	48 89 fb             	mov    %rdi,%rbx
ffffffff8101341e:	44 8a 8f c1 00 00 00 	mov    0xc1(%rdi),%r9b
ffffffff81013425:	48 8b bf 80 00 00 00 	mov    0x80(%rdi),%rdi

template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
ffffffff8101342c:	84 c9                	test   %cl,%cl
ffffffff8101342e:	74 0d                	je     ffffffff8101343d <_ZN8Exc_regs8nst_ctrlI4VmcbEEvb+0x29>
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
ffffffff81013430:	45 84 c9             	test   %r9b,%r9b
ffffffff81013433:	0f 85 bd 01 00 00    	jne    ffffffff810135f6 <_ZN8Exc_regs8nst_ctrlI4VmcbEEvb+0x1e2>
    return mode<T>() == MODE_PROT_64 ? val : val & 0xffffffff;
}

template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;
ffffffff81013439:	31 d2                	xor    %edx,%edx
ffffffff8101343b:	eb 0a                	jmp    ffffffff81013447 <_ZN8Exc_regs8nst_ctrlI4VmcbEEvb+0x33>

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
ffffffff8101343d:	45 84 c9             	test   %r9b,%r9b
ffffffff81013440:	75 31                	jne    ffffffff81013473 <_ZN8Exc_regs8nst_ctrlI4VmcbEEvb+0x5f>
template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
ffffffff81013442:	ba 01 00 01 80       	mov    $0x80010001,%edx
    if (!fpu_on)
        set |= Cpu::CR0_TS;
ffffffff81013447:	48 83 ca 08          	or     $0x8,%rdx

template <typename T>
mword Exc_regs::get_cr0() const {
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
ffffffff8101344b:	48 89 d0             	mov    %rdx,%rax
ffffffff8101344e:	48 23 93 90 00 00 00 	and    0x90(%rbx),%rdx
ffffffff81013455:	48 f7 d0             	not    %rax
ffffffff81013458:	48 23 87 58 05 00 00 	and    0x558(%rdi),%rax
ffffffff8101345f:	48 09 d0             	or     %rdx,%rax
}

template <typename T>
mword Exc_regs::get_cr3() const {
    return nst_on ? get_g_cr3<T>() : cr3_shadow;
ffffffff81013462:	84 c9                	test   %cl,%cl
ffffffff81013464:	74 2d                	je     ffffffff81013493 <_ZN8Exc_regs8nst_ctrlI4VmcbEEvb+0x7f>
template <> mword Exc_regs::get_g_cr2<Vmcb>() const {
    return static_cast<mword> (vmcb->cr2);
}

template <> mword Exc_regs::get_g_cr3<Vmcb>() const {
    return static_cast<mword> (vmcb->cr3);
ffffffff81013466:	4c 8b 87 50 05 00 00 	mov    0x550(%rdi),%r8
mword Exc_regs::cr4_msk() const {
    mword clr = nst_on ? 0 :
#ifdef __i386__
            Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
            Cpu::CR4_PGE;
ffffffff8101346d:	31 c9                	xor    %ecx,%ecx
mword Exc_regs::cr4_set() const {
    mword set = nst_on ? 0 :
#ifdef __i386__
            Cpu::CR4_PSE;
#else
            Cpu::CR4_PSE | Cpu::CR4_PAE;
ffffffff8101346f:	31 d2                	xor    %edx,%edx
ffffffff81013471:	eb 31                	jmp    ffffffff810134a4 <_ZN8Exc_regs8nst_ctrlI4VmcbEEvb+0x90>

template <typename T>
mword Exc_regs::get_cr0() const {
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
ffffffff81013473:	48 8b 83 90 00 00 00 	mov    0x90(%rbx),%rax
ffffffff8101347a:	48 ba fe ff fe 7f ff 	movabs $0xffffffff7ffefffe,%rdx
ffffffff81013481:	ff ff ff 
ffffffff81013484:	48 23 97 58 05 00 00 	and    0x558(%rdi),%rdx
ffffffff8101348b:	25 01 00 01 80       	and    $0x80010001,%eax
ffffffff81013490:	48 09 d0             	or     %rdx,%rax
}

template <typename T>
mword Exc_regs::get_cr3() const {
    return nst_on ? get_g_cr3<T>() : cr3_shadow;
ffffffff81013493:	4c 8b 83 98 00 00 00 	mov    0x98(%rbx),%r8
mword Exc_regs::cr4_msk() const {
    mword clr = nst_on ? 0 :
#ifdef __i386__
            Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
            Cpu::CR4_PGE;
ffffffff8101349a:	b9 80 00 00 00       	mov    $0x80,%ecx
mword Exc_regs::cr4_set() const {
    mword set = nst_on ? 0 :
#ifdef __i386__
            Cpu::CR4_PSE;
#else
            Cpu::CR4_PSE | Cpu::CR4_PAE;
ffffffff8101349f:	ba 30 00 00 00       	mov    $0x30,%edx
            Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
            Cpu::CR4_PGE;
#endif

    return T::fix_cr4_clr | clr | cr4_set<T>();
ffffffff810134a4:	48 09 ca             	or     %rcx,%rdx

template <> void Exc_regs::nst_ctrl<Vmcb>(bool on) {
    mword cr0 = get_cr0<Vmcb>();
    mword cr3 = get_cr3<Vmcb>();
    mword cr4 = get_cr4<Vmcb>();
    nst_on = Vmcb::has_npt() && on;
ffffffff810134a7:	23 35 73 c8 fe 3e    	and    0x3efec873(%rip),%esi        # ffffffffbffffd20 <_ZN4Vmcb11svm_featureE>

template <typename T>
mword Exc_regs::get_cr4() const {
    mword msk = cr4_msk<T>();

    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
ffffffff810134ad:	48 89 d1             	mov    %rdx,%rcx
ffffffff810134b0:	48 23 93 a0 00 00 00 	and    0xa0(%rbx),%rdx
ffffffff810134b7:	48 f7 d1             	not    %rcx
ffffffff810134ba:	48 23 8f 48 05 00 00 	and    0x548(%rdi),%rcx

template <> void Exc_regs::nst_ctrl<Vmcb>(bool on) {
    mword cr0 = get_cr0<Vmcb>();
    mword cr3 = get_cr3<Vmcb>();
    mword cr4 = get_cr4<Vmcb>();
    nst_on = Vmcb::has_npt() && on;
ffffffff810134c1:	83 e6 01             	and    $0x1,%esi
ffffffff810134c4:	40 88 b3 c0 00 00 00 	mov    %sil,0xc0(%rbx)

template <typename T>
mword Exc_regs::get_cr4() const {
    mword msk = cr4_msk<T>();

    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
ffffffff810134cb:	48 09 d1             	or     %rdx,%rcx

template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
ffffffff810134ce:	40 84 f6             	test   %sil,%sil
ffffffff810134d1:	75 0c                	jne    ffffffff810134df <_ZN8Exc_regs8nst_ctrlI4VmcbEEvb+0xcb>
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
ffffffff810134d3:	45 84 c9             	test   %r9b,%r9b
template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
ffffffff810134d6:	ba 01 00 01 80       	mov    $0x80010001,%edx
    if (!fpu_on)
ffffffff810134db:	75 11                	jne    ffffffff810134ee <_ZN8Exc_regs8nst_ctrlI4VmcbEEvb+0xda>
ffffffff810134dd:	eb 0b                	jmp    ffffffff810134ea <_ZN8Exc_regs8nst_ctrlI4VmcbEEvb+0xd6>
ffffffff810134df:	45 84 c9             	test   %r9b,%r9b
ffffffff810134e2:	0f 85 1a 01 00 00    	jne    ffffffff81013602 <_ZN8Exc_regs8nst_ctrlI4VmcbEEvb+0x1ee>
    return mode<T>() == MODE_PROT_64 ? val : val & 0xffffffff;
}

template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;
ffffffff810134e8:	31 d2                	xor    %edx,%edx

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
        set |= Cpu::CR0_TS;
ffffffff810134ea:	48 83 ca 08          	or     $0x8,%rdx
    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
}

template <typename T>
void Exc_regs::set_cr0(mword v) {
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
ffffffff810134ee:	48 f7 d2             	not    %rdx
template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
ffffffff810134f1:	41 ba 01 00 01 80    	mov    $0x80010001,%r10d
    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
}

template <typename T>
void Exc_regs::set_cr0(mword v) {
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
ffffffff810134f7:	48 83 ca 01          	or     $0x1,%rdx
ffffffff810134fb:	48 21 c2             	and    %rax,%rdx
template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
ffffffff810134fe:	40 84 f6             	test   %sil,%sil
ffffffff81013501:	be 00 00 00 00       	mov    $0x0,%esi
ffffffff81013506:	49 0f 44 f2          	cmove  %r10,%rsi
    if (!fpu_on)
        set |= Cpu::CR0_TS;
ffffffff8101350a:	49 89 f2             	mov    %rsi,%r10
ffffffff8101350d:	49 83 ca 08          	or     $0x8,%r10
ffffffff81013511:	45 84 c9             	test   %r9b,%r9b
ffffffff81013514:	49 0f 44 f2          	cmove  %r10,%rsi
    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
}

template <typename T>
void Exc_regs::set_cr0(mword v) {
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
ffffffff81013518:	83 e6 fe             	and    $0xfffffffe,%esi
ffffffff8101351b:	48 09 f2             	or     %rsi,%rdx
ffffffff8101351e:	48 89 97 58 05 00 00 	mov    %rdx,0x558(%rdi)
    set_s_cr0<T> (v);
}

template <typename T>
void Exc_regs::set_cr3(mword v) {
    if (nst_on)
ffffffff81013525:	80 bb c0 00 00 00 00 	cmpb   $0x0,0xc0(%rbx)
template <> void Exc_regs::set_e_bmp<Vmcb> (uint32 v) const {
    vmcb->intercept_exc = v;
}

template <> void Exc_regs::set_s_cr0<Vmcb> (mword v) {
    cr0_shadow = v;
ffffffff8101352c:	48 89 83 90 00 00 00 	mov    %rax,0x90(%rbx)
    set_s_cr0<T> (v);
}

template <typename T>
void Exc_regs::set_cr3(mword v) {
    if (nst_on)
ffffffff81013533:	74 10                	je     ffffffff81013545 <_ZN8Exc_regs8nst_ctrlI4VmcbEEvb+0x131>
template <> void Exc_regs::set_g_cr2<Vmcb> (mword v) {
    vmcb->cr2 = v;
}

template <> void Exc_regs::set_g_cr3<Vmcb> (mword v) const {
    vmcb->cr3 = v;
ffffffff81013535:	48 8b 83 80 00 00 00 	mov    0x80(%rbx),%rax
ffffffff8101353c:	4c 89 80 50 05 00 00 	mov    %r8,0x550(%rax)
ffffffff81013543:	eb 07                	jmp    ffffffff8101354c <_ZN8Exc_regs8nst_ctrlI4VmcbEEvb+0x138>
template <typename T>
void Exc_regs::set_cr3(mword v) {
    if (nst_on)
        set_g_cr3<T> (v);
    else
        cr3_shadow = v;
ffffffff81013545:	4c 89 83 98 00 00 00 	mov    %r8,0x98(%rbx)
ffffffff8101354c:	8a 93 c0 00 00 00    	mov    0xc0(%rbx),%dl
    nst_on = Vmcb::has_npt() && on;
    set_cr0<Vmcb> (cr0);
    set_cr3<Vmcb> (cr3);
    set_cr4<Vmcb> (cr4);

    svm_set_cpu_ctrl0(vmcb->intercept_cpu[0]);
ffffffff81013552:	48 89 df             	mov    %rbx,%rdi
mword Exc_regs::cr4_msk() const {
    mword clr = nst_on ? 0 :
#ifdef __i386__
            Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
            Cpu::CR4_PGE;
ffffffff81013555:	80 fa 01             	cmp    $0x1,%dl
ffffffff81013558:	48 19 c0             	sbb    %rax,%rax
ffffffff8101355b:	25 80 00 00 00       	and    $0x80,%eax
ffffffff81013560:	80 fa 01             	cmp    $0x1,%dl
template <> void Exc_regs::set_g_cr3<Vmcb> (mword v) const {
    vmcb->cr3 = v;
}

template <> void Exc_regs::set_g_cr4<Vmcb> (mword v) const {
    vmcb->cr4 = v;
ffffffff81013563:	48 8b 93 80 00 00 00 	mov    0x80(%rbx),%rdx
mword Exc_regs::cr4_msk() const {
    mword clr = nst_on ? 0 :
#ifdef __i386__
            Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
            Cpu::CR4_PGE;
ffffffff8101356a:	48 19 f6             	sbb    %rsi,%rsi
ffffffff8101356d:	83 e6 30             	and    $0x30,%esi
#endif

    return T::fix_cr4_clr | clr | cr4_set<T>();
ffffffff81013570:	48 09 f0             	or     %rsi,%rax
        cr3_shadow = v;
}

template <typename T>
void Exc_regs::set_cr4(mword v) {
    set_g_cr4<T> ((v & ~cr4_msk<T>()) | cr4_set<T>());
ffffffff81013573:	48 f7 d0             	not    %rax
ffffffff81013576:	48 21 c8             	and    %rcx,%rax
ffffffff81013579:	48 09 f0             	or     %rsi,%rax
ffffffff8101357c:	48 89 82 48 05 00 00 	mov    %rax,0x548(%rdx)
    nst_on = Vmcb::has_npt() && on;
    set_cr0<Vmcb> (cr0);
    set_cr3<Vmcb> (cr3);
    set_cr4<Vmcb> (cr4);

    svm_set_cpu_ctrl0(vmcb->intercept_cpu[0]);
ffffffff81013583:	48 8b 83 80 00 00 00 	mov    0x80(%rbx),%rax
template <> void Exc_regs::set_s_cr0<Vmcb> (mword v) {
    cr0_shadow = v;
}

template <> void Exc_regs::set_s_cr4<Vmcb> (mword v) {
    cr4_shadow = v;
ffffffff8101358a:	48 89 8b a0 00 00 00 	mov    %rcx,0xa0(%rbx)
    nst_on = Vmcb::has_npt() && on;
    set_cr0<Vmcb> (cr0);
    set_cr3<Vmcb> (cr3);
    set_cr4<Vmcb> (cr4);

    svm_set_cpu_ctrl0(vmcb->intercept_cpu[0]);
ffffffff81013591:	8b 70 0c             	mov    0xc(%rax),%esi
ffffffff81013594:	e8 61 fd ff ff       	callq  ffffffff810132fa <_ZN8Exc_regs17svm_set_cpu_ctrl0Em>
    svm_set_cpu_ctrl1(vmcb->intercept_cpu[1]);
ffffffff81013599:	48 8b 83 80 00 00 00 	mov    0x80(%rbx),%rax
    else
        vmcb->intercept_cpu[0] = static_cast<uint32> ((val | Vmcb::CPU_INVLPG) | Vmcb::force_ctrl0);
}

void Exc_regs::svm_set_cpu_ctrl1(mword val) {
    vmcb->intercept_cpu[1] = static_cast<uint32> (val | Vmcb::force_ctrl1);
ffffffff810135a0:	83 48 10 6c          	orl    $0x6c,0x10(%rax)
template <typename T>
void Exc_regs::set_exc() const {
    unsigned msk = 1UL << Cpu::EXC_AC;

    if (!nst_on)
        msk |= 1UL << Cpu::EXC_PF;
ffffffff810135a4:	80 bb c0 00 00 00 01 	cmpb   $0x1,0xc0(%rbx)
ffffffff810135ab:	19 c0                	sbb    %eax,%eax
ffffffff810135ad:	25 00 40 00 00       	and    $0x4000,%eax
ffffffff810135b2:	05 00 00 02 00       	add    $0x20000,%eax
    if (!fpu_on)
        msk |= 1UL << Cpu::EXC_NM;
ffffffff810135b7:	89 c2                	mov    %eax,%edx
ffffffff810135b9:	80 ca 80             	or     $0x80,%dl
ffffffff810135bc:	80 bb c1 00 00 00 00 	cmpb   $0x0,0xc1(%rbx)
ffffffff810135c3:	0f 44 c2             	cmove  %edx,%eax
template <> void Exc_regs::set_g_cr4<Vmcs> (mword v) const {
    Vmcs::write(Vmcs::GUEST_CR4, v);
}

template <> void Exc_regs::set_e_bmp<Vmcb> (uint32 v) const {
    vmcb->intercept_exc = v;
ffffffff810135c6:	48 8b 93 80 00 00 00 	mov    0x80(%rbx),%rdx
ffffffff810135cd:	89 42 08             	mov    %eax,0x8(%rdx)

    svm_set_cpu_ctrl0(vmcb->intercept_cpu[0]);
    svm_set_cpu_ctrl1(vmcb->intercept_cpu[1]);
    set_exc<Vmcb>();

    if (!nst_on)
ffffffff810135d0:	80 bb c0 00 00 00 00 	cmpb   $0x0,0xc0(%rbx)
ffffffff810135d7:	75 33                	jne    ffffffff8101360c <_ZN8Exc_regs8nst_ctrlI4VmcbEEvb+0x1f8>
        }

        ALWAYS_INLINE
        inline mword virt_to_phys (mword virt)
        {
            return virt - reinterpret_cast<mword>(&OFFSET);
ffffffff810135d9:	48 8b 83 88 00 00 00 	mov    0x88(%rbx),%rax
template <> void Exc_regs::set_g_cr2<Vmcb> (mword v) {
    vmcb->cr2 = v;
}

template <> void Exc_regs::set_g_cr3<Vmcb> (mword v) const {
    vmcb->cr3 = v;
ffffffff810135e0:	48 8b 93 80 00 00 00 	mov    0x80(%rbx),%rdx
ffffffff810135e7:	48 2d 00 00 c0 80    	sub    $0xffffffff80c00000,%rax
ffffffff810135ed:	48 89 82 50 05 00 00 	mov    %rax,0x550(%rdx)
ffffffff810135f4:	eb 16                	jmp    ffffffff8101360c <_ZN8Exc_regs8nst_ctrlI4VmcbEEvb+0x1f8>
template <> mword Exc_regs::get_g_efer<Vmcb>() const {
    return static_cast<mword> (vmcb->efer);
}

template <> mword Exc_regs::get_g_cr0<Vmcb>() const {
    return static_cast<mword> (vmcb->cr0);
ffffffff810135f6:	48 8b 87 58 05 00 00 	mov    0x558(%rdi),%rax
ffffffff810135fd:	e9 64 fe ff ff       	jmpq   ffffffff81013466 <_ZN8Exc_regs8nst_ctrlI4VmcbEEvb+0x52>
    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
}

template <typename T>
void Exc_regs::set_cr0(mword v) {
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
ffffffff81013602:	48 89 c2             	mov    %rax,%rdx
    return mode<T>() == MODE_PROT_64 ? val : val & 0xffffffff;
}

template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;
ffffffff81013605:	31 f6                	xor    %esi,%esi
ffffffff81013607:	e9 0c ff ff ff       	jmpq   ffffffff81013518 <_ZN8Exc_regs8nst_ctrlI4VmcbEEvb+0x104>
    svm_set_cpu_ctrl1(vmcb->intercept_cpu[1]);
    set_exc<Vmcb>();

    if (!nst_on)
        set_g_cr3<Vmcb> (Buddy::ptr_to_phys(vtlb));
}
ffffffff8101360c:	5b                   	pop    %rbx
ffffffff8101360d:	c3                   	retq   

ffffffff8101360e <_ZN8Exc_regs8nst_ctrlI4VmcsEEvb>:

template <> void Exc_regs::nst_ctrl<Vmcs>(bool on) {
ffffffff8101360e:	41 54                	push   %r12
ffffffff81013610:	55                   	push   %rbp
ffffffff81013611:	53                   	push   %rbx
    assert(Vmcs::current == vmcs);
ffffffff81013612:	48 8b 87 80 00 00 00 	mov    0x80(%rdi),%rax

    if (!nst_on)
        set_g_cr3<Vmcb> (Buddy::ptr_to_phys(vtlb));
}

template <> void Exc_regs::nst_ctrl<Vmcs>(bool on) {
ffffffff81013619:	48 89 fb             	mov    %rdi,%rbx
    assert(Vmcs::current == vmcs);
ffffffff8101361c:	48 39 05 fd b9 fe 3e 	cmp    %rax,0x3efeb9fd(%rip)        # ffffffffbffff020 <_ZN4Vmcs7currentE>
ffffffff81013623:	74 28                	je     ffffffff8101364d <_ZN8Exc_regs8nst_ctrlI4VmcsEEvb+0x3f>
ffffffff81013625:	49 c7 c0 20 03 02 81 	mov    $0xffffffff81020320,%r8
ffffffff8101362c:	b9 52 01 00 00       	mov    $0x152,%ecx
ffffffff81013631:	48 c7 c2 73 02 02 81 	mov    $0xffffffff81020273,%rdx
ffffffff81013638:	48 c7 c6 df 02 02 81 	mov    $0xffffffff810202df,%rsi
ffffffff8101363f:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81013646:	31 c0                	xor    %eax,%eax
ffffffff81013648:	e8 03 e9 fe ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
ffffffff8101364d:	8a 97 c0 00 00 00    	mov    0xc0(%rdi),%dl
ffffffff81013653:	40 8a af c1 00 00 00 	mov    0xc1(%rdi),%bpl
template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
ffffffff8101365a:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff8101365f:	41 b8 01 00 01 80    	mov    $0x80010001,%r8d
    if (!fpu_on)
        set |= Cpu::CR0_TS;

    return T::fix_cr0_set | set;
ffffffff81013665:	4c 8b 25 dc c7 fe 3e 	mov    0x3efec7dc(%rip),%r12        # ffffffffbffffe48 <_ZN4Vmcs11fix_cr0_setE>
template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
ffffffff8101366c:	84 d2                	test   %dl,%dl
ffffffff8101366e:	4c 0f 45 c0          	cmovne %rax,%r8
ffffffff81013672:	4c 89 e1             	mov    %r12,%rcx
    if (!fpu_on)
        set |= Cpu::CR0_TS;
ffffffff81013675:	4c 89 c0             	mov    %r8,%rax
ffffffff81013678:	48 83 c8 08          	or     $0x8,%rax
ffffffff8101367c:	40 84 ed             	test   %bpl,%bpl
ffffffff8101367f:	4c 0f 44 c0          	cmove  %rax,%r8
ffffffff81013683:	48 0b 0d b6 c7 fe 3e 	or     0x3efec7b6(%rip),%rcx        # ffffffffbffffe40 <_ZN4Vmcs11fix_cr0_clrE>

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
ffffffff8101368a:	b8 00 68 00 00       	mov    $0x6800,%eax
    return T::fix_cr0_set | set;
}

template <typename T>
mword Exc_regs::cr0_msk() const {
    return T::fix_cr0_clr | cr0_set<T>();
ffffffff8101368f:	49 09 c8             	or     %rcx,%r8
ffffffff81013692:	0f 78 c0             	vmread %rax,%rax

template <typename T>
mword Exc_regs::get_cr0() const {
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
ffffffff81013695:	4c 89 c7             	mov    %r8,%rdi
ffffffff81013698:	4c 23 83 90 00 00 00 	and    0x90(%rbx),%r8
ffffffff8101369f:	48 f7 d7             	not    %rdi
ffffffff810136a2:	48 21 f8             	and    %rdi,%rax
ffffffff810136a5:	49 09 c0             	or     %rax,%r8
}

template <typename T>
mword Exc_regs::get_cr3() const {
    return nst_on ? get_g_cr3<T>() : cr3_shadow;
ffffffff810136a8:	84 d2                	test   %dl,%dl
ffffffff810136aa:	74 0e                	je     ffffffff810136ba <_ZN8Exc_regs8nst_ctrlI4VmcsEEvb+0xac>
ffffffff810136ac:	41 b9 02 68 00 00    	mov    $0x6802,%r9d
ffffffff810136b2:	45 0f 78 c9          	vmread %r9,%r9
mword Exc_regs::cr4_msk() const {
    mword clr = nst_on ? 0 :
#ifdef __i386__
            Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
            Cpu::CR4_PGE;
ffffffff810136b6:	31 ff                	xor    %edi,%edi
ffffffff810136b8:	eb 0c                	jmp    ffffffff810136c6 <_ZN8Exc_regs8nst_ctrlI4VmcsEEvb+0xb8>
    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
}

template <typename T>
mword Exc_regs::get_cr3() const {
    return nst_on ? get_g_cr3<T>() : cr3_shadow;
ffffffff810136ba:	4c 8b 8b 98 00 00 00 	mov    0x98(%rbx),%r9
mword Exc_regs::cr4_msk() const {
    mword clr = nst_on ? 0 :
#ifdef __i386__
            Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
            Cpu::CR4_PGE;
ffffffff810136c1:	bf 80 00 00 00       	mov    $0x80,%edi
            Cpu::CR4_PSE;
#else
            Cpu::CR4_PSE | Cpu::CR4_PAE;
#endif

    return T::fix_cr4_set | set;
ffffffff810136c6:	4c 8b 15 6b c7 fe 3e 	mov    0x3efec76b(%rip),%r10        # ffffffffbffffe38 <_ZN4Vmcs11fix_cr4_setE>
mword Exc_regs::cr4_set() const {
    mword set = nst_on ? 0 :
#ifdef __i386__
            Cpu::CR4_PSE;
#else
            Cpu::CR4_PSE | Cpu::CR4_PAE;
ffffffff810136cd:	80 fa 01             	cmp    $0x1,%dl
ffffffff810136d0:	48 19 c0             	sbb    %rax,%rax
ffffffff810136d3:	83 e0 30             	and    $0x30,%eax
ffffffff810136d6:	4d 89 d3             	mov    %r10,%r11
ffffffff810136d9:	4c 0b 1d 50 c7 fe 3e 	or     0x3efec750(%rip),%r11        # ffffffffbffffe30 <_ZN4Vmcs11fix_cr4_clrE>
ffffffff810136e0:	4c 09 df             	or     %r11,%rdi
            Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
            Cpu::CR4_PGE;
#endif

    return T::fix_cr4_clr | clr | cr4_set<T>();
ffffffff810136e3:	48 09 f8             	or     %rdi,%rax
ffffffff810136e6:	bf 04 68 00 00       	mov    $0x6804,%edi
ffffffff810136eb:	0f 78 ff             	vmread %rdi,%rdi

template <typename T>
mword Exc_regs::get_cr4() const {
    mword msk = cr4_msk<T>();

    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
ffffffff810136ee:	48 89 c2             	mov    %rax,%rdx
ffffffff810136f1:	48 23 83 a0 00 00 00 	and    0xa0(%rbx),%rax
ffffffff810136f8:	48 f7 d2             	not    %rdx
ffffffff810136fb:	48 21 d7             	and    %rdx,%rdi
ffffffff810136fe:	48 09 c7             	or     %rax,%rdi
    assert(Vmcs::current == vmcs);

    mword cr0 = get_cr0<Vmcs>();
    mword cr3 = get_cr3<Vmcs>();
    mword cr4 = get_cr4<Vmcs>();
    nst_on = Vmcs::has_ept() && on;
ffffffff81013701:	8b 05 65 c7 fe 3e    	mov    0x3efec765(%rip),%eax        # ffffffffbffffe6c <_ZN4Vmcs8ctrl_cpuE+0xc>
ffffffff81013707:	d1 e8                	shr    %eax
ffffffff81013709:	83 e0 01             	and    $0x1,%eax
ffffffff8101370c:	21 c6                	and    %eax,%esi

template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
ffffffff8101370e:	40 84 f6             	test   %sil,%sil
    assert(Vmcs::current == vmcs);

    mword cr0 = get_cr0<Vmcs>();
    mword cr3 = get_cr3<Vmcs>();
    mword cr4 = get_cr4<Vmcs>();
    nst_on = Vmcs::has_ept() && on;
ffffffff81013711:	40 88 b3 c0 00 00 00 	mov    %sil,0xc0(%rbx)

template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
ffffffff81013718:	75 0c                	jne    ffffffff81013726 <_ZN8Exc_regs8nst_ctrlI4VmcsEEvb+0x118>
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
ffffffff8101371a:	40 84 ed             	test   %bpl,%bpl
template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
ffffffff8101371d:	ba 01 00 01 80       	mov    $0x80010001,%edx
    if (!fpu_on)
ffffffff81013722:	75 11                	jne    ffffffff81013735 <_ZN8Exc_regs8nst_ctrlI4VmcsEEvb+0x127>
ffffffff81013724:	eb 0b                	jmp    ffffffff81013731 <_ZN8Exc_regs8nst_ctrlI4VmcsEEvb+0x123>
ffffffff81013726:	40 84 ed             	test   %bpl,%bpl
ffffffff81013729:	0f 85 7e 01 00 00    	jne    ffffffff810138ad <_ZN8Exc_regs8nst_ctrlI4VmcsEEvb+0x29f>
    return mode<T>() == MODE_PROT_64 ? val : val & 0xffffffff;
}

template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;
ffffffff8101372f:	31 d2                	xor    %edx,%edx

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
        set |= Cpu::CR0_TS;
ffffffff81013731:	48 83 ca 08          	or     $0x8,%rdx
    return T::fix_cr0_set | set;
}

template <typename T>
mword Exc_regs::cr0_msk() const {
    return T::fix_cr0_clr | cr0_set<T>();
ffffffff81013735:	48 09 d1             	or     %rdx,%rcx
template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
ffffffff81013738:	b8 01 00 01 80       	mov    $0x80010001,%eax
ffffffff8101373d:	ba 00 00 00 00       	mov    $0x0,%edx
    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
}

template <typename T>
void Exc_regs::set_cr0(mword v) {
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
ffffffff81013742:	48 f7 d1             	not    %rcx
ffffffff81013745:	48 83 c9 01          	or     $0x1,%rcx
ffffffff81013749:	4c 21 c1             	and    %r8,%rcx
template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
ffffffff8101374c:	40 84 f6             	test   %sil,%sil
ffffffff8101374f:	48 0f 45 c2          	cmovne %rdx,%rax
    if (!fpu_on)
        set |= Cpu::CR0_TS;
ffffffff81013753:	48 89 c2             	mov    %rax,%rdx
ffffffff81013756:	48 83 ca 08          	or     $0x8,%rdx
ffffffff8101375a:	40 84 ed             	test   %bpl,%bpl
ffffffff8101375d:	48 0f 44 c2          	cmove  %rdx,%rax

    return T::fix_cr0_set | set;
ffffffff81013761:	4c 09 e0             	or     %r12,%rax
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
ffffffff81013764:	ba 00 68 00 00       	mov    $0x6800,%edx
    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
}

template <typename T>
void Exc_regs::set_cr0(mword v) {
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
ffffffff81013769:	83 e0 fe             	and    $0xfffffffe,%eax
ffffffff8101376c:	48 09 c8             	or     %rcx,%rax
ffffffff8101376f:	0f 79 d0             	vmwrite %rax,%rdx
ffffffff81013772:	b8 04 60 00 00       	mov    $0x6004,%eax
template <> void Exc_regs::set_e_bmp<Vmcs> (uint32 v) const {
    Vmcs::write(Vmcs::EXC_BITMAP, v);
}

template <> void Exc_regs::set_s_cr0<Vmcs> (mword v) {
    Vmcs::write(Vmcs::CR0_READ_SHADOW, cr0_shadow = v);
ffffffff81013777:	4c 89 83 90 00 00 00 	mov    %r8,0x90(%rbx)
ffffffff8101377e:	41 0f 79 c0          	vmwrite %r8,%rax
    set_s_cr0<T> (v);
}

template <typename T>
void Exc_regs::set_cr3(mword v) {
    if (nst_on)
ffffffff81013782:	40 84 f6             	test   %sil,%sil
ffffffff81013785:	74 10                	je     ffffffff81013797 <_ZN8Exc_regs8nst_ctrlI4VmcsEEvb+0x189>
ffffffff81013787:	66 b8 02 68          	mov    $0x6802,%ax
ffffffff8101378b:	41 0f 79 c1          	vmwrite %r9,%rax
mword Exc_regs::cr4_msk() const {
    mword clr = nst_on ? 0 :
#ifdef __i386__
            Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
            Cpu::CR4_PGE;
ffffffff8101378f:	66 31 d2             	xor    %dx,%dx
mword Exc_regs::cr4_set() const {
    mword set = nst_on ? 0 :
#ifdef __i386__
            Cpu::CR4_PSE;
#else
            Cpu::CR4_PSE | Cpu::CR4_PAE;
ffffffff81013792:	66 31 c0             	xor    %ax,%ax
ffffffff81013795:	eb 11                	jmp    ffffffff810137a8 <_ZN8Exc_regs8nst_ctrlI4VmcsEEvb+0x19a>
template <typename T>
void Exc_regs::set_cr3(mword v) {
    if (nst_on)
        set_g_cr3<T> (v);
    else
        cr3_shadow = v;
ffffffff81013797:	4c 89 8b 98 00 00 00 	mov    %r9,0x98(%rbx)
mword Exc_regs::cr4_msk() const {
    mword clr = nst_on ? 0 :
#ifdef __i386__
            Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
            Cpu::CR4_PGE;
ffffffff8101379e:	ba 80 00 00 00       	mov    $0x80,%edx
mword Exc_regs::cr4_set() const {
    mword set = nst_on ? 0 :
#ifdef __i386__
            Cpu::CR4_PSE;
#else
            Cpu::CR4_PSE | Cpu::CR4_PAE;
ffffffff810137a3:	b8 30 00 00 00       	mov    $0x30,%eax
ffffffff810137a8:	49 09 d3             	or     %rdx,%r11
            Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
            Cpu::CR4_PGE;
#endif

    return T::fix_cr4_clr | clr | cr4_set<T>();
ffffffff810137ab:	4c 09 d8             	or     %r11,%rax
        cr3_shadow = v;
}

template <typename T>
void Exc_regs::set_cr4(mword v) {
    set_g_cr4<T> ((v & ~cr4_msk<T>()) | cr4_set<T>());
ffffffff810137ae:	48 f7 d0             	not    %rax
ffffffff810137b1:	48 21 f8             	and    %rdi,%rax
mword Exc_regs::cr4_set() const {
    mword set = nst_on ? 0 :
#ifdef __i386__
            Cpu::CR4_PSE;
#else
            Cpu::CR4_PSE | Cpu::CR4_PAE;
ffffffff810137b4:	40 80 fe 01          	cmp    $0x1,%sil
ffffffff810137b8:	4d 19 db             	sbb    %r11,%r11
ffffffff810137bb:	49 09 c2             	or     %rax,%r10
ffffffff810137be:	b8 04 68 00 00       	mov    $0x6804,%eax
ffffffff810137c3:	41 83 e3 30          	and    $0x30,%r11d
        cr3_shadow = v;
}

template <typename T>
void Exc_regs::set_cr4(mword v) {
    set_g_cr4<T> ((v & ~cr4_msk<T>()) | cr4_set<T>());
ffffffff810137c7:	4d 09 da             	or     %r11,%r10
ffffffff810137ca:	41 0f 79 c2          	vmwrite %r10,%rax
template <> void Exc_regs::set_s_cr0<Vmcs> (mword v) {
    Vmcs::write(Vmcs::CR0_READ_SHADOW, cr0_shadow = v);
}

template <> void Exc_regs::set_s_cr4<Vmcs> (mword v) {
    Vmcs::write(Vmcs::CR4_READ_SHADOW, cr4_shadow = v);
ffffffff810137ce:	48 89 bb a0 00 00 00 	mov    %rdi,0xa0(%rbx)
ffffffff810137d5:	66 b8 06 60          	mov    $0x6006,%ax
ffffffff810137d9:	0f 79 c7             	vmwrite %rdi,%rax

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
ffffffff810137dc:	be 02 40 00 00       	mov    $0x4002,%esi
ffffffff810137e1:	0f 78 f6             	vmread %rsi,%rsi
    nst_on = Vmcs::has_ept() && on;
    set_cr0<Vmcs> (cr0);
    set_cr3<Vmcs> (cr3);
    set_cr4<Vmcs> (cr4);

    vmx_set_cpu_ctrl0(Vmcs::read(Vmcs::CPU_EXEC_CTRL0));
ffffffff810137e4:	48 89 df             	mov    %rbx,%rdi
ffffffff810137e7:	e8 c6 fb ff ff       	callq  ffffffff810133b2 <_ZN8Exc_regs17vmx_set_cpu_ctrl0Em>
ffffffff810137ec:	be 1e 40 00 00       	mov    $0x401e,%esi
ffffffff810137f1:	0f 78 f6             	vmread %rsi,%rsi
    vmx_set_cpu_ctrl1(Vmcs::read(Vmcs::CPU_EXEC_CTRL1));
ffffffff810137f4:	48 89 df             	mov    %rbx,%rdi
ffffffff810137f7:	e8 ea fb ff ff       	callq  ffffffff810133e6 <_ZN8Exc_regs17vmx_set_cpu_ctrl1Em>

template <typename T>
void Exc_regs::set_exc() const {
    unsigned msk = 1UL << Cpu::EXC_AC;

    if (!nst_on)
ffffffff810137fc:	8a 8b c0 00 00 00    	mov    0xc0(%rbx),%cl
        msk |= 1UL << Cpu::EXC_PF;
    if (!fpu_on)
ffffffff81013802:	8a 93 c1 00 00 00    	mov    0xc1(%rbx),%dl
template <typename T>
void Exc_regs::set_exc() const {
    unsigned msk = 1UL << Cpu::EXC_AC;

    if (!nst_on)
        msk |= 1UL << Cpu::EXC_PF;
ffffffff81013808:	80 f9 01             	cmp    $0x1,%cl
ffffffff8101380b:	19 c0                	sbb    %eax,%eax
ffffffff8101380d:	25 00 40 00 00       	and    $0x4000,%eax
ffffffff81013812:	05 00 00 02 00       	add    $0x20000,%eax
    if (!fpu_on)
        msk |= 1UL << Cpu::EXC_NM;
ffffffff81013817:	89 c6                	mov    %eax,%esi
ffffffff81013819:	40 80 ce 80          	or     $0x80,%sil
ffffffff8101381d:	84 d2                	test   %dl,%dl
ffffffff8101381f:	0f 44 c6             	cmove  %esi,%eax
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
ffffffff81013822:	be 04 40 00 00       	mov    $0x4004,%esi
template <> void Exc_regs::set_s_cr4<Vmcb> (mword v) {
    cr4_shadow = v;
}

template <> void Exc_regs::set_e_bmp<Vmcs> (uint32 v) const {
    Vmcs::write(Vmcs::EXC_BITMAP, v);
ffffffff81013827:	89 c0                	mov    %eax,%eax
ffffffff81013829:	0f 79 f0             	vmwrite %rax,%rsi
template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
ffffffff8101382c:	be 01 00 01 80       	mov    $0x80010001,%esi
ffffffff81013831:	84 c9                	test   %cl,%cl
ffffffff81013833:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff81013838:	48 0f 44 c6          	cmove  %rsi,%rax
    if (!fpu_on)
        set |= Cpu::CR0_TS;
ffffffff8101383c:	48 89 c6             	mov    %rax,%rsi
ffffffff8101383f:	48 83 ce 08          	or     $0x8,%rsi
ffffffff81013843:	84 d2                	test   %dl,%dl
ffffffff81013845:	48 8b 15 f4 c5 fe 3e 	mov    0x3efec5f4(%rip),%rdx        # ffffffffbffffe40 <_ZN4Vmcs11fix_cr0_clrE>
ffffffff8101384c:	48 0f 44 c6          	cmove  %rsi,%rax
ffffffff81013850:	48 0b 15 f1 c5 fe 3e 	or     0x3efec5f1(%rip),%rdx        # ffffffffbffffe48 <_ZN4Vmcs11fix_cr0_setE>
    return T::fix_cr0_set | set;
}

template <typename T>
mword Exc_regs::cr0_msk() const {
    return T::fix_cr0_clr | cr0_set<T>();
ffffffff81013857:	48 09 d0             	or     %rdx,%rax
ffffffff8101385a:	ba 00 60 00 00       	mov    $0x6000,%edx
ffffffff8101385f:	0f 79 d0             	vmwrite %rax,%rdx
mword Exc_regs::cr4_msk() const {
    mword clr = nst_on ? 0 :
#ifdef __i386__
            Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
            Cpu::CR4_PGE;
ffffffff81013862:	80 f9 01             	cmp    $0x1,%cl
ffffffff81013865:	48 8b 35 c4 c5 fe 3e 	mov    0x3efec5c4(%rip),%rsi        # ffffffffbffffe30 <_ZN4Vmcs11fix_cr4_clrE>
ffffffff8101386c:	48 19 d2             	sbb    %rdx,%rdx
ffffffff8101386f:	81 e2 80 00 00 00    	and    $0x80,%edx
mword Exc_regs::cr4_set() const {
    mword set = nst_on ? 0 :
#ifdef __i386__
            Cpu::CR4_PSE;
#else
            Cpu::CR4_PSE | Cpu::CR4_PAE;
ffffffff81013875:	80 f9 01             	cmp    $0x1,%cl
ffffffff81013878:	48 19 c0             	sbb    %rax,%rax
ffffffff8101387b:	48 0b 35 b6 c5 fe 3e 	or     0x3efec5b6(%rip),%rsi        # ffffffffbffffe38 <_ZN4Vmcs11fix_cr4_setE>
ffffffff81013882:	83 e0 30             	and    $0x30,%eax
ffffffff81013885:	48 09 f2             	or     %rsi,%rdx
            Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
            Cpu::CR4_PGE;
#endif

    return T::fix_cr4_clr | clr | cr4_set<T>();
ffffffff81013888:	48 09 d0             	or     %rdx,%rax
ffffffff8101388b:	ba 02 60 00 00       	mov    $0x6002,%edx
ffffffff81013890:	0f 79 d0             	vmwrite %rax,%rdx
    set_exc<Vmcs>();

    Vmcs::write(Vmcs::CR0_MASK, cr0_msk<Vmcs>());
    Vmcs::write(Vmcs::CR4_MASK, cr4_msk<Vmcs>());

    if (!nst_on)
ffffffff81013893:	84 c9                	test   %cl,%cl
ffffffff81013895:	75 27                	jne    ffffffff810138be <_ZN8Exc_regs8nst_ctrlI4VmcsEEvb+0x2b0>
ffffffff81013897:	48 8b 83 88 00 00 00 	mov    0x88(%rbx),%rax
ffffffff8101389e:	66 ba 02 68          	mov    $0x6802,%dx
ffffffff810138a2:	48 2d 00 00 c0 80    	sub    $0xffffffff80c00000,%rax
ffffffff810138a8:	0f 79 d0             	vmwrite %rax,%rdx
ffffffff810138ab:	eb 11                	jmp    ffffffff810138be <_ZN8Exc_regs8nst_ctrlI4VmcsEEvb+0x2b0>
    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
}

template <typename T>
void Exc_regs::set_cr0(mword v) {
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
ffffffff810138ad:	48 f7 d1             	not    %rcx
    return mode<T>() == MODE_PROT_64 ? val : val & 0xffffffff;
}

template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;
ffffffff810138b0:	31 c0                	xor    %eax,%eax
    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
}

template <typename T>
void Exc_regs::set_cr0(mword v) {
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
ffffffff810138b2:	48 83 c9 01          	or     $0x1,%rcx
ffffffff810138b6:	4c 21 c1             	and    %r8,%rcx
ffffffff810138b9:	e9 a3 fe ff ff       	jmpq   ffffffff81013761 <_ZN8Exc_regs8nst_ctrlI4VmcsEEvb+0x153>
    Vmcs::write(Vmcs::CR0_MASK, cr0_msk<Vmcs>());
    Vmcs::write(Vmcs::CR4_MASK, cr4_msk<Vmcs>());

    if (!nst_on)
        set_g_cr3<Vmcs> (Buddy::ptr_to_phys(vtlb));
}
ffffffff810138be:	5b                   	pop    %rbx
ffffffff810138bf:	5d                   	pop    %rbp
ffffffff810138c0:	41 5c                	pop    %r12
ffffffff810138c2:	c3                   	retq   
ffffffff810138c3:	90                   	nop

ffffffff810138c4 <_ZN8Exc_regs13disable_rdtscI4VmcbEEvv>:

template <> void Exc_regs::disable_rdtsc<Vmcb>() {
    vmcb->intercept_cpu[0] |= (1U << 14); // RDTSC
ffffffff810138c4:	48 8b 87 80 00 00 00 	mov    0x80(%rdi),%rax
ffffffff810138cb:	81 48 0c 00 40 00 00 	orl    $0x4000,0xc(%rax)
    vmcb->intercept_cpu[1] |= (1U << 7); // RDTSCP
ffffffff810138d2:	48 8b 87 80 00 00 00 	mov    0x80(%rdi),%rax
ffffffff810138d9:	81 48 10 80 00 00 00 	orl    $0x80,0x10(%rax)
ffffffff810138e0:	c3                   	retq   
ffffffff810138e1:	90                   	nop

ffffffff810138e2 <_ZN8Exc_regs13disable_rdtscI4VmcsEEvv>:

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
ffffffff810138e2:	be 02 40 00 00       	mov    $0x4002,%esi
ffffffff810138e7:	0f 78 f6             	vmread %rsi,%rsi
}

template <> void Exc_regs::disable_rdtsc<Vmcs>() {
    // TODO
    mword val = Vmcs::read(Vmcs::CPU_EXEC_CTRL0);
    val |= Vmcs::CPU_RDTSC;
ffffffff810138ea:	48 81 ce 00 10 00 00 	or     $0x1000,%rsi
    vmx_set_cpu_ctrl0(val);
ffffffff810138f1:	e9 bc fa ff ff       	jmpq   ffffffff810133b2 <_ZN8Exc_regs17vmx_set_cpu_ctrl0Em>

ffffffff810138f6 <_ZN8Exc_regs13resolve_rdtscI4VmcbEEvy>:
    val &= ~Vmcs::CPU_RDTSC;
    vmx_set_cpu_ctrl0(val);
}

template <> void Exc_regs::resolve_rdtsc<Vmcb>(uint64 t) {
    t += vmcb->tsc_offset;
ffffffff810138f6:	48 8b 87 80 00 00 00 	mov    0x80(%rdi),%rax
ffffffff810138fd:	48 03 70 50          	add    0x50(%rax),%rsi
    vmcb->rax = t;
ffffffff81013901:	48 89 b0 f8 05 00 00 	mov    %rsi,0x5f8(%rax)
    REG(dx) = static_cast<mword> (t >> 32);
    vmcb->adjust_rip(2);
ffffffff81013908:	48 8b 87 80 00 00 00 	mov    0x80(%rdi),%rax
}

template <> void Exc_regs::resolve_rdtsc<Vmcb>(uint64 t) {
    t += vmcb->tsc_offset;
    vmcb->rax = t;
    REG(dx) = static_cast<mword> (t >> 32);
ffffffff8101390f:	48 c1 ee 20          	shr    $0x20,%rsi
ffffffff81013913:	48 89 77 68          	mov    %rsi,0x68(%rdi)
        asm volatile ("vmsave" : : "a" (Buddy::ptr_to_phys(this)) : "memory");
    }

    ALWAYS_INLINE
    inline void adjust_rip(mword len) {
        rip += len;
ffffffff81013917:	48 83 80 78 05 00 00 	addq   $0x2,0x578(%rax)
ffffffff8101391e:	02 

        if (int_shadow)
ffffffff8101391f:	48 83 78 68 00       	cmpq   $0x0,0x68(%rax)
ffffffff81013924:	74 08                	je     ffffffff8101392e <_ZN8Exc_regs13resolve_rdtscI4VmcbEEvy+0x38>
            int_shadow = 0;
ffffffff81013926:	48 c7 40 68 00 00 00 	movq   $0x0,0x68(%rax)
ffffffff8101392d:	00 
ffffffff8101392e:	c3                   	retq   
ffffffff8101392f:	90                   	nop

ffffffff81013930 <_ZN8Exc_regs13resolve_rdtscI4VmcsEEvy>:
ffffffff81013930:	b8 10 20 00 00       	mov    $0x2010,%eax
ffffffff81013935:	0f 78 c0             	vmread %rax,%rax
    vmcb->adjust_rip(2);
}

template <> void Exc_regs::resolve_rdtsc<Vmcs>(uint64 t) {
    //TODO
    t += Vmcs::read(Vmcs::TSC_OFFSET);
ffffffff81013938:	48 01 c6             	add    %rax,%rsi
ffffffff8101393b:	b9 1e 68 00 00       	mov    $0x681e,%ecx
    REG(ax) = static_cast<mword> (t);
ffffffff81013940:	48 89 77 78          	mov    %rsi,0x78(%rdi)
    REG(dx) = static_cast<mword> (t >> 32);
ffffffff81013944:	48 c1 ee 20          	shr    $0x20,%rsi
ffffffff81013948:	48 89 77 68          	mov    %rsi,0x68(%rdi)
ffffffff8101394c:	0f 78 ca             	vmread %rcx,%rdx
ffffffff8101394f:	b8 0c 44 00 00       	mov    $0x440c,%eax
ffffffff81013954:	0f 78 c0             	vmread %rax,%rax
        }

        ALWAYS_INLINE
        static inline void adjust_rip()
        {
            write (GUEST_RIP, read (GUEST_RIP) + read (EXI_INST_LEN));
ffffffff81013957:	48 01 d0             	add    %rdx,%rax
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
ffffffff8101395a:	0f 79 c8             	vmwrite %rax,%rcx

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
ffffffff8101395d:	b8 24 48 00 00       	mov    $0x4824,%eax
ffffffff81013962:	0f 78 c0             	vmread %rax,%rax
        static inline void adjust_rip()
        {
            write (GUEST_RIP, read (GUEST_RIP) + read (EXI_INST_LEN));

            uint32 intr = static_cast<uint32>(read (GUEST_INTR_STATE));
            if (EXPECT_FALSE (intr & 3))
ffffffff81013965:	a8 03                	test   $0x3,%al
ffffffff81013967:	74 0b                	je     ffffffff81013974 <_ZN8Exc_regs13resolve_rdtscI4VmcsEEvy+0x44>
                write (GUEST_INTR_STATE, intr & ~3);
ffffffff81013969:	83 e0 fc             	and    $0xfffffffc,%eax
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
ffffffff8101396c:	ba 24 48 00 00       	mov    $0x4824,%edx
ffffffff81013971:	0f 79 d0             	vmwrite %rax,%rdx
ffffffff81013974:	c3                   	retq   
ffffffff81013975:	90                   	nop

ffffffff81013976 <_ZN8Exc_regs8fpu_ctrlEb>:
    vmcs->adjust_rip();
}

void Exc_regs::fpu_ctrl(bool on) {
ffffffff81013976:	48 83 ec 18          	sub    $0x18,%rsp
    if (Hip::feature() & Hip::FEAT_VMX) {
ffffffff8101397a:	f6 05 8f 36 15 00 02 	testb  $0x2,0x15368f(%rip)        # ffffffff81167010 <PAGE_H+0x10>
ffffffff81013981:	0f 84 79 01 00 00    	je     ffffffff81013b00 <_ZN8Exc_regs8fpu_ctrlEb+0x18a>

        vmcs->make_current();
ffffffff81013987:	48 8b 87 80 00 00 00 	mov    0x80(%rdi),%rax
        Vmcs* clone();

        ALWAYS_INLINE
        inline void make_current()
        {
            if (EXPECT_TRUE (current == this))
ffffffff8101398e:	48 39 05 8b b6 fe 3e 	cmp    %rax,0x3efeb68b(%rip)        # ffffffffbffff020 <_ZN4Vmcs7currentE>
ffffffff81013995:	74 44                	je     ffffffff810139db <_ZN8Exc_regs8fpu_ctrlEb+0x65>
                return;

            uint64 phys = Buddy::ptr_to_phys (current = this);
ffffffff81013997:	48 89 05 82 b6 fe 3e 	mov    %rax,0x3efeb682(%rip)        # ffffffffbffff020 <_ZN4Vmcs7currentE>
ffffffff8101399e:	48 2d 00 00 c0 80    	sub    $0xffffffff80c00000,%rax
ffffffff810139a4:	48 89 44 24 08       	mov    %rax,0x8(%rsp)

            bool ret;
            asm volatile ("vmptrld %1; seta %0" : "=q" (ret) : "m" (phys) : "cc");
ffffffff810139a9:	0f c7 74 24 08       	vmptrld 0x8(%rsp)
ffffffff810139ae:	0f 97 c0             	seta   %al
            assert (ret);
ffffffff810139b1:	84 c0                	test   %al,%al
ffffffff810139b3:	75 26                	jne    ffffffff810139db <_ZN8Exc_regs8fpu_ctrlEb+0x65>
ffffffff810139b5:	49 c7 c0 00 03 02 81 	mov    $0xffffffff81020300,%r8
ffffffff810139bc:	b9 9a 01 00 00       	mov    $0x19a,%ecx
ffffffff810139c1:	48 c7 c2 72 db 01 81 	mov    $0xffffffff8101db72,%rdx
ffffffff810139c8:	48 c7 c6 e1 db 01 81 	mov    $0xffffffff8101dbe1,%rsi
ffffffff810139cf:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff810139d6:	e8 75 e5 fe ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
ffffffff810139db:	44 8a 87 c0 00 00 00 	mov    0xc0(%rdi),%r8b
template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
ffffffff810139e2:	b8 01 00 01 80       	mov    $0x80010001,%eax
ffffffff810139e7:	b9 00 00 00 00       	mov    $0x0,%ecx
    if (!fpu_on)
        set |= Cpu::CR0_TS;

    return T::fix_cr0_set | set;
ffffffff810139ec:	4c 8b 15 55 c4 fe 3e 	mov    0x3efec455(%rip),%r10        # ffffffffbffffe48 <_ZN4Vmcs11fix_cr0_setE>

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
ffffffff810139f3:	41 bb 00 68 00 00    	mov    $0x6800,%r11d
template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
ffffffff810139f9:	45 84 c0             	test   %r8b,%r8b
ffffffff810139fc:	48 0f 44 c8          	cmove  %rax,%rcx
ffffffff81013a00:	4d 89 d1             	mov    %r10,%r9
    if (!fpu_on)
        set |= Cpu::CR0_TS;
ffffffff81013a03:	48 89 ca             	mov    %rcx,%rdx
ffffffff81013a06:	48 83 ca 08          	or     $0x8,%rdx
ffffffff81013a0a:	80 bf c1 00 00 00 00 	cmpb   $0x0,0xc1(%rdi)
ffffffff81013a11:	48 0f 44 ca          	cmove  %rdx,%rcx
ffffffff81013a15:	4c 0b 0d 24 c4 fe 3e 	or     0x3efec424(%rip),%r9        # ffffffffbffffe40 <_ZN4Vmcs11fix_cr0_clrE>
    return T::fix_cr0_set | set;
}

template <typename T>
mword Exc_regs::cr0_msk() const {
    return T::fix_cr0_clr | cr0_set<T>();
ffffffff81013a1c:	4c 09 c9             	or     %r9,%rcx
ffffffff81013a1f:	45 0f 78 db          	vmread %r11,%r11

template <typename T>
mword Exc_regs::get_cr0() const {
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
ffffffff81013a23:	48 89 ca             	mov    %rcx,%rdx
ffffffff81013a26:	48 23 8f 90 00 00 00 	and    0x90(%rdi),%rcx
    if (Hip::feature() & Hip::FEAT_VMX) {

        vmcs->make_current();

        mword cr0 = get_cr0<Vmcs>();
        fpu_on = on;
ffffffff81013a2d:	40 88 b7 c1 00 00 00 	mov    %sil,0xc1(%rdi)

template <typename T>
mword Exc_regs::get_cr0() const {
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
ffffffff81013a34:	48 f7 d2             	not    %rdx
ffffffff81013a37:	49 21 d3             	and    %rdx,%r11
ffffffff81013a3a:	4c 09 d9             	or     %r11,%rcx

template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
ffffffff81013a3d:	45 84 c0             	test   %r8b,%r8b
ffffffff81013a40:	75 0a                	jne    ffffffff81013a4c <_ZN8Exc_regs8fpu_ctrlEb+0xd6>
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
ffffffff81013a42:	40 84 f6             	test   %sil,%sil
template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
ffffffff81013a45:	48 89 c2             	mov    %rax,%rdx
    if (!fpu_on)
ffffffff81013a48:	75 11                	jne    ffffffff81013a5b <_ZN8Exc_regs8fpu_ctrlEb+0xe5>
ffffffff81013a4a:	eb 0b                	jmp    ffffffff81013a57 <_ZN8Exc_regs8fpu_ctrlEb+0xe1>
ffffffff81013a4c:	40 84 f6             	test   %sil,%sil
ffffffff81013a4f:	0f 85 c6 00 00 00    	jne    ffffffff81013b1b <_ZN8Exc_regs8fpu_ctrlEb+0x1a5>
    return mode<T>() == MODE_PROT_64 ? val : val & 0xffffffff;
}

template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;
ffffffff81013a55:	31 d2                	xor    %edx,%edx

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
        set |= Cpu::CR0_TS;
ffffffff81013a57:	48 83 ca 08          	or     $0x8,%rdx
    return T::fix_cr0_set | set;
}

template <typename T>
mword Exc_regs::cr0_msk() const {
    return T::fix_cr0_clr | cr0_set<T>();
ffffffff81013a5b:	4c 09 ca             	or     %r9,%rdx
template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
ffffffff81013a5e:	41 bb 01 00 01 80    	mov    $0x80010001,%r11d
    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
}

template <typename T>
void Exc_regs::set_cr0(mword v) {
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
ffffffff81013a64:	48 f7 d2             	not    %rdx
ffffffff81013a67:	48 83 ca 01          	or     $0x1,%rdx
ffffffff81013a6b:	48 89 d0             	mov    %rdx,%rax
template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
ffffffff81013a6e:	ba 00 00 00 00       	mov    $0x0,%edx
    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
}

template <typename T>
void Exc_regs::set_cr0(mword v) {
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
ffffffff81013a73:	48 21 c8             	and    %rcx,%rax
template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
ffffffff81013a76:	45 84 c0             	test   %r8b,%r8b
ffffffff81013a79:	49 0f 44 d3          	cmove  %r11,%rdx
    if (!fpu_on)
        set |= Cpu::CR0_TS;
ffffffff81013a7d:	49 89 d3             	mov    %rdx,%r11
ffffffff81013a80:	49 83 cb 08          	or     $0x8,%r11
ffffffff81013a84:	40 84 f6             	test   %sil,%sil
ffffffff81013a87:	49 0f 44 d3          	cmove  %r11,%rdx

    return T::fix_cr0_set | set;
ffffffff81013a8b:	4c 09 d2             	or     %r10,%rdx
    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
}

template <typename T>
void Exc_regs::set_cr0(mword v) {
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
ffffffff81013a8e:	83 e2 fe             	and    $0xfffffffe,%edx
ffffffff81013a91:	48 09 d0             	or     %rdx,%rax
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
ffffffff81013a94:	ba 00 68 00 00       	mov    $0x6800,%edx
ffffffff81013a99:	0f 79 d0             	vmwrite %rax,%rdx
ffffffff81013a9c:	b8 04 60 00 00       	mov    $0x6004,%eax
template <> void Exc_regs::set_e_bmp<Vmcs> (uint32 v) const {
    Vmcs::write(Vmcs::EXC_BITMAP, v);
}

template <> void Exc_regs::set_s_cr0<Vmcs> (mword v) {
    Vmcs::write(Vmcs::CR0_READ_SHADOW, cr0_shadow = v);
ffffffff81013aa1:	48 89 8f 90 00 00 00 	mov    %rcx,0x90(%rdi)
ffffffff81013aa8:	0f 79 c1             	vmwrite %rcx,%rax
template <typename T>
void Exc_regs::set_exc() const {
    unsigned msk = 1UL << Cpu::EXC_AC;

    if (!nst_on)
        msk |= 1UL << Cpu::EXC_PF;
ffffffff81013aab:	41 80 f8 01          	cmp    $0x1,%r8b
ffffffff81013aaf:	19 c0                	sbb    %eax,%eax
ffffffff81013ab1:	25 00 40 00 00       	and    $0x4000,%eax
ffffffff81013ab6:	05 00 00 02 00       	add    $0x20000,%eax
    if (!fpu_on)
        msk |= 1UL << Cpu::EXC_NM;
ffffffff81013abb:	89 c2                	mov    %eax,%edx
ffffffff81013abd:	80 ca 80             	or     $0x80,%dl
ffffffff81013ac0:	40 84 f6             	test   %sil,%sil
ffffffff81013ac3:	0f 44 c2             	cmove  %edx,%eax
ffffffff81013ac6:	ba 04 40 00 00       	mov    $0x4004,%edx
template <> void Exc_regs::set_s_cr4<Vmcb> (mword v) {
    cr4_shadow = v;
}

template <> void Exc_regs::set_e_bmp<Vmcs> (uint32 v) const {
    Vmcs::write(Vmcs::EXC_BITMAP, v);
ffffffff81013acb:	89 c0                	mov    %eax,%eax
ffffffff81013acd:	0f 79 d0             	vmwrite %rax,%rdx
template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
ffffffff81013ad0:	ba 01 00 01 80       	mov    $0x80010001,%edx
ffffffff81013ad5:	45 84 c0             	test   %r8b,%r8b
ffffffff81013ad8:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff81013add:	48 0f 44 c2          	cmove  %rdx,%rax
    if (!fpu_on)
        set |= Cpu::CR0_TS;
ffffffff81013ae1:	48 89 c2             	mov    %rax,%rdx
ffffffff81013ae4:	48 83 ca 08          	or     $0x8,%rdx
ffffffff81013ae8:	40 84 f6             	test   %sil,%sil
ffffffff81013aeb:	48 0f 44 c2          	cmove  %rdx,%rax
    return T::fix_cr0_set | set;
}

template <typename T>
mword Exc_regs::cr0_msk() const {
    return T::fix_cr0_clr | cr0_set<T>();
ffffffff81013aef:	49 09 c1             	or     %rax,%r9
ffffffff81013af2:	b8 00 60 00 00       	mov    $0x6000,%eax
ffffffff81013af7:	41 0f 79 c1          	vmwrite %r9,%rax
ffffffff81013afb:	e9 67 01 00 00       	jmpq   ffffffff81013c67 <_ZN8Exc_regs8fpu_ctrlEb+0x2f1>
ffffffff81013b00:	44 8a 8f c0 00 00 00 	mov    0xc0(%rdi),%r9b
ffffffff81013b07:	8a 87 c1 00 00 00    	mov    0xc1(%rdi),%al
ffffffff81013b0d:	48 8b 8f 80 00 00 00 	mov    0x80(%rdi),%rcx

template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
ffffffff81013b14:	45 84 c9             	test   %r9b,%r9b
ffffffff81013b17:	74 22                	je     ffffffff81013b3b <_ZN8Exc_regs8fpu_ctrlEb+0x1c5>
ffffffff81013b19:	eb 14                	jmp    ffffffff81013b2f <_ZN8Exc_regs8fpu_ctrlEb+0x1b9>
    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
}

template <typename T>
void Exc_regs::set_cr0(mword v) {
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
ffffffff81013b1b:	4c 89 c8             	mov    %r9,%rax
    return mode<T>() == MODE_PROT_64 ? val : val & 0xffffffff;
}

template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;
ffffffff81013b1e:	31 d2                	xor    %edx,%edx
    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
}

template <typename T>
void Exc_regs::set_cr0(mword v) {
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
ffffffff81013b20:	48 f7 d0             	not    %rax
ffffffff81013b23:	48 83 c8 01          	or     $0x1,%rax
ffffffff81013b27:	48 21 c8             	and    %rcx,%rax
ffffffff81013b2a:	e9 5c ff ff ff       	jmpq   ffffffff81013a8b <_ZN8Exc_regs8fpu_ctrlEb+0x115>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
ffffffff81013b2f:	84 c0                	test   %al,%al
ffffffff81013b31:	0f 85 df 00 00 00    	jne    ffffffff81013c16 <_ZN8Exc_regs8fpu_ctrlEb+0x2a0>
    return mode<T>() == MODE_PROT_64 ? val : val & 0xffffffff;
}

template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;
ffffffff81013b37:	31 d2                	xor    %edx,%edx
ffffffff81013b39:	eb 0d                	jmp    ffffffff81013b48 <_ZN8Exc_regs8fpu_ctrlEb+0x1d2>

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
ffffffff81013b3b:	84 c0                	test   %al,%al
ffffffff81013b3d:	0f 85 eb 00 00 00    	jne    ffffffff81013c2e <_ZN8Exc_regs8fpu_ctrlEb+0x2b8>
template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
ffffffff81013b43:	ba 01 00 01 80       	mov    $0x80010001,%edx
    if (!fpu_on)
        set |= Cpu::CR0_TS;
ffffffff81013b48:	48 83 ca 08          	or     $0x8,%rdx
        Vmcs::write(Vmcs::CR0_MASK, cr0_msk<Vmcs>());

    } else {

        mword cr0 = get_cr0<Vmcb>();
        fpu_on = on;
ffffffff81013b4c:	41 88 f0             	mov    %sil,%r8b

template <typename T>
mword Exc_regs::get_cr0() const {
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
ffffffff81013b4f:	48 89 d0             	mov    %rdx,%rax
ffffffff81013b52:	48 23 97 90 00 00 00 	and    0x90(%rdi),%rdx
ffffffff81013b59:	48 f7 d0             	not    %rax
ffffffff81013b5c:	48 23 81 58 05 00 00 	and    0x558(%rcx),%rax
        Vmcs::write(Vmcs::CR0_MASK, cr0_msk<Vmcs>());

    } else {

        mword cr0 = get_cr0<Vmcb>();
        fpu_on = on;
ffffffff81013b63:	40 88 b7 c1 00 00 00 	mov    %sil,0xc1(%rdi)

template <typename T>
mword Exc_regs::get_cr0() const {
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
ffffffff81013b6a:	48 09 d0             	or     %rdx,%rax

template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
ffffffff81013b6d:	45 84 c9             	test   %r9b,%r9b
ffffffff81013b70:	75 0c                	jne    ffffffff81013b7e <_ZN8Exc_regs8fpu_ctrlEb+0x208>
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
ffffffff81013b72:	ba 01 00 01 80       	mov    $0x80010001,%edx
    if (!fpu_on)
ffffffff81013b77:	45 84 c0             	test   %r8b,%r8b
ffffffff81013b7a:	75 19                	jne    ffffffff81013b95 <_ZN8Exc_regs8fpu_ctrlEb+0x21f>
ffffffff81013b7c:	eb 0b                	jmp    ffffffff81013b89 <_ZN8Exc_regs8fpu_ctrlEb+0x213>
ffffffff81013b7e:	40 84 f6             	test   %sil,%sil
ffffffff81013b81:	0f 85 d6 00 00 00    	jne    ffffffff81013c5d <_ZN8Exc_regs8fpu_ctrlEb+0x2e7>
    return mode<T>() == MODE_PROT_64 ? val : val & 0xffffffff;
}

template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;
ffffffff81013b87:	31 d2                	xor    %edx,%edx

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
        set |= Cpu::CR0_TS;
ffffffff81013b89:	48 83 ca 08          	or     $0x8,%rdx
ffffffff81013b8d:	48 89 c6             	mov    %rax,%rsi
ffffffff81013b90:	45 31 c0             	xor    %r8d,%r8d
ffffffff81013b93:	eb 06                	jmp    ffffffff81013b9b <_ZN8Exc_regs8fpu_ctrlEb+0x225>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
ffffffff81013b95:	48 89 c6             	mov    %rax,%rsi
ffffffff81013b98:	41 b0 01             	mov    $0x1,%r8b
    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
}

template <typename T>
void Exc_regs::set_cr0(mword v) {
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
ffffffff81013b9b:	48 f7 d2             	not    %rdx
ffffffff81013b9e:	48 83 ca 01          	or     $0x1,%rdx
ffffffff81013ba2:	48 21 d0             	and    %rdx,%rax
template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
ffffffff81013ba5:	45 84 c9             	test   %r9b,%r9b
ffffffff81013ba8:	ba 00 00 00 00       	mov    $0x0,%edx
ffffffff81013bad:	41 b9 01 00 01 80    	mov    $0x80010001,%r9d
ffffffff81013bb3:	49 0f 44 d1          	cmove  %r9,%rdx
    if (!fpu_on)
        set |= Cpu::CR0_TS;
ffffffff81013bb7:	49 89 d1             	mov    %rdx,%r9
ffffffff81013bba:	49 83 c9 08          	or     $0x8,%r9
ffffffff81013bbe:	45 84 c0             	test   %r8b,%r8b
ffffffff81013bc1:	49 0f 44 d1          	cmove  %r9,%rdx
    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
}

template <typename T>
void Exc_regs::set_cr0(mword v) {
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
ffffffff81013bc5:	83 e2 fe             	and    $0xfffffffe,%edx
ffffffff81013bc8:	48 09 d0             	or     %rdx,%rax
ffffffff81013bcb:	48 89 81 58 05 00 00 	mov    %rax,0x558(%rcx)
template <typename T>
void Exc_regs::set_exc() const {
    unsigned msk = 1UL << Cpu::EXC_AC;

    if (!nst_on)
        msk |= 1UL << Cpu::EXC_PF;
ffffffff81013bd2:	80 bf c0 00 00 00 01 	cmpb   $0x1,0xc0(%rdi)
template <> void Exc_regs::set_e_bmp<Vmcb> (uint32 v) const {
    vmcb->intercept_exc = v;
}

template <> void Exc_regs::set_s_cr0<Vmcb> (mword v) {
    cr0_shadow = v;
ffffffff81013bd9:	48 89 b7 90 00 00 00 	mov    %rsi,0x90(%rdi)
template <typename T>
void Exc_regs::set_exc() const {
    unsigned msk = 1UL << Cpu::EXC_AC;

    if (!nst_on)
        msk |= 1UL << Cpu::EXC_PF;
ffffffff81013be0:	19 c0                	sbb    %eax,%eax
ffffffff81013be2:	25 00 40 00 00       	and    $0x4000,%eax
ffffffff81013be7:	05 00 00 02 00       	add    $0x20000,%eax
    if (!fpu_on)
        msk |= 1UL << Cpu::EXC_NM;
ffffffff81013bec:	89 c2                	mov    %eax,%edx
ffffffff81013bee:	80 ca 80             	or     $0x80,%dl
ffffffff81013bf1:	80 bf c1 00 00 00 00 	cmpb   $0x0,0xc1(%rdi)
ffffffff81013bf8:	0f 44 c2             	cmove  %edx,%eax
template <> void Exc_regs::set_g_cr4<Vmcs> (mword v) const {
    Vmcs::write(Vmcs::GUEST_CR4, v);
}

template <> void Exc_regs::set_e_bmp<Vmcb> (uint32 v) const {
    vmcb->intercept_exc = v;
ffffffff81013bfb:	48 8b 97 80 00 00 00 	mov    0x80(%rdi),%rdx
ffffffff81013c02:	89 42 08             	mov    %eax,0x8(%rdx)
        fpu_on = on;
        set_cr0<Vmcb> (cr0);

        set_exc<Vmcb>();

        svm_set_cpu_ctrl0(vmcb->intercept_cpu[0]);
ffffffff81013c05:	48 8b 87 80 00 00 00 	mov    0x80(%rdi),%rax
ffffffff81013c0c:	8b 70 0c             	mov    0xc(%rax),%esi
ffffffff81013c0f:	e8 e6 f6 ff ff       	callq  ffffffff810132fa <_ZN8Exc_regs17svm_set_cpu_ctrl0Em>
ffffffff81013c14:	eb 51                	jmp    ffffffff81013c67 <_ZN8Exc_regs8fpu_ctrlEb+0x2f1>
template <> mword Exc_regs::get_g_efer<Vmcb>() const {
    return static_cast<mword> (vmcb->efer);
}

template <> mword Exc_regs::get_g_cr0<Vmcb>() const {
    return static_cast<mword> (vmcb->cr0);
ffffffff81013c16:	48 8b 81 58 05 00 00 	mov    0x558(%rcx),%rax
        Vmcs::write(Vmcs::CR0_MASK, cr0_msk<Vmcs>());

    } else {

        mword cr0 = get_cr0<Vmcb>();
        fpu_on = on;
ffffffff81013c1d:	41 88 f0             	mov    %sil,%r8b
ffffffff81013c20:	40 88 b7 c1 00 00 00 	mov    %sil,0xc1(%rdi)
    return mode<T>() == MODE_PROT_64 ? val : val & 0xffffffff;
}

template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;
ffffffff81013c27:	31 d2                	xor    %edx,%edx
ffffffff81013c29:	e9 49 ff ff ff       	jmpq   ffffffff81013b77 <_ZN8Exc_regs8fpu_ctrlEb+0x201>

template <typename T>
mword Exc_regs::get_cr0() const {
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
ffffffff81013c2e:	48 8b 87 90 00 00 00 	mov    0x90(%rdi),%rax
ffffffff81013c35:	48 ba fe ff fe 7f ff 	movabs $0xffffffff7ffefffe,%rdx
ffffffff81013c3c:	ff ff ff 
ffffffff81013c3f:	48 23 91 58 05 00 00 	and    0x558(%rcx),%rdx
        Vmcs::write(Vmcs::CR0_MASK, cr0_msk<Vmcs>());

    } else {

        mword cr0 = get_cr0<Vmcb>();
        fpu_on = on;
ffffffff81013c46:	41 88 f0             	mov    %sil,%r8b
ffffffff81013c49:	40 88 b7 c1 00 00 00 	mov    %sil,0xc1(%rdi)

template <typename T>
mword Exc_regs::get_cr0() const {
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
ffffffff81013c50:	25 01 00 01 80       	and    $0x80010001,%eax
ffffffff81013c55:	48 09 d0             	or     %rdx,%rax
ffffffff81013c58:	e9 15 ff ff ff       	jmpq   ffffffff81013b72 <_ZN8Exc_regs8fpu_ctrlEb+0x1fc>
ffffffff81013c5d:	48 89 c6             	mov    %rax,%rsi
    return mode<T>() == MODE_PROT_64 ? val : val & 0xffffffff;
}

template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;
ffffffff81013c60:	31 d2                	xor    %edx,%edx
ffffffff81013c62:	e9 5e ff ff ff       	jmpq   ffffffff81013bc5 <_ZN8Exc_regs8fpu_ctrlEb+0x24f>

        set_exc<Vmcb>();

        svm_set_cpu_ctrl0(vmcb->intercept_cpu[0]);
    }
}
ffffffff81013c67:	48 83 c4 18          	add    $0x18,%rsp
ffffffff81013c6b:	c3                   	retq   

ffffffff81013c6c <_ZN8Exc_regs18svm_update_shadowsEv>:

void Exc_regs::svm_update_shadows() {
ffffffff81013c6c:	40 8a b7 c0 00 00 00 	mov    0xc0(%rdi),%sil
ffffffff81013c73:	8a 87 c1 00 00 00    	mov    0xc1(%rdi),%al
ffffffff81013c79:	48 8b 97 80 00 00 00 	mov    0x80(%rdi),%rdx

template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
ffffffff81013c80:	40 84 f6             	test   %sil,%sil
ffffffff81013c83:	74 0c                	je     ffffffff81013c91 <_ZN8Exc_regs18svm_update_shadowsEv+0x25>
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
ffffffff81013c85:	84 c0                	test   %al,%al
ffffffff81013c87:	0f 85 ab 00 00 00    	jne    ffffffff81013d38 <_ZN8Exc_regs18svm_update_shadowsEv+0xcc>
    return mode<T>() == MODE_PROT_64 ? val : val & 0xffffffff;
}

template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;
ffffffff81013c8d:	31 c0                	xor    %eax,%eax
ffffffff81013c8f:	eb 09                	jmp    ffffffff81013c9a <_ZN8Exc_regs18svm_update_shadowsEv+0x2e>

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
ffffffff81013c91:	84 c0                	test   %al,%al
ffffffff81013c93:	75 35                	jne    ffffffff81013cca <_ZN8Exc_regs18svm_update_shadowsEv+0x5e>
template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
ffffffff81013c95:	b8 01 00 01 80       	mov    $0x80010001,%eax
    if (!fpu_on)
        set |= Cpu::CR0_TS;
ffffffff81013c9a:	48 83 c8 08          	or     $0x8,%rax

template <typename T>
mword Exc_regs::get_cr0() const {
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
ffffffff81013c9e:	48 89 c1             	mov    %rax,%rcx
ffffffff81013ca1:	48 23 87 90 00 00 00 	and    0x90(%rdi),%rax
ffffffff81013ca8:	48 f7 d1             	not    %rcx
ffffffff81013cab:	48 23 8a 58 05 00 00 	and    0x558(%rdx),%rcx
ffffffff81013cb2:	48 09 c8             	or     %rcx,%rax
}

template <typename T>
mword Exc_regs::get_cr3() const {
    return nst_on ? get_g_cr3<T>() : cr3_shadow;
ffffffff81013cb5:	40 84 f6             	test   %sil,%sil

template <typename T>
mword Exc_regs::get_cr0() const {
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
ffffffff81013cb8:	48 89 87 90 00 00 00 	mov    %rax,0x90(%rdi)
}

template <typename T>
mword Exc_regs::get_cr3() const {
    return nst_on ? get_g_cr3<T>() : cr3_shadow;
ffffffff81013cbf:	74 30                	je     ffffffff81013cf1 <_ZN8Exc_regs18svm_update_shadowsEv+0x85>
template <> mword Exc_regs::get_g_cr2<Vmcb>() const {
    return static_cast<mword> (vmcb->cr2);
}

template <> mword Exc_regs::get_g_cr3<Vmcb>() const {
    return static_cast<mword> (vmcb->cr3);
ffffffff81013cc1:	48 8b 82 50 05 00 00 	mov    0x550(%rdx),%rax
ffffffff81013cc8:	eb 2e                	jmp    ffffffff81013cf8 <_ZN8Exc_regs18svm_update_shadowsEv+0x8c>

template <typename T>
mword Exc_regs::get_cr0() const {
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
ffffffff81013cca:	48 8b 87 90 00 00 00 	mov    0x90(%rdi),%rax
ffffffff81013cd1:	48 b9 fe ff fe 7f ff 	movabs $0xffffffff7ffefffe,%rcx
ffffffff81013cd8:	ff ff ff 
ffffffff81013cdb:	48 23 8a 58 05 00 00 	and    0x558(%rdx),%rcx
ffffffff81013ce2:	25 01 00 01 80       	and    $0x80010001,%eax
ffffffff81013ce7:	48 09 c8             	or     %rcx,%rax
ffffffff81013cea:	48 89 87 90 00 00 00 	mov    %rax,0x90(%rdi)
}

template <typename T>
mword Exc_regs::get_cr3() const {
    return nst_on ? get_g_cr3<T>() : cr3_shadow;
ffffffff81013cf1:	48 8b 87 98 00 00 00 	mov    0x98(%rdi),%rax
mword Exc_regs::cr4_msk() const {
    mword clr = nst_on ? 0 :
#ifdef __i386__
            Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
            Cpu::CR4_PGE;
ffffffff81013cf8:	40 80 fe 01          	cmp    $0x1,%sil
    }
}

void Exc_regs::svm_update_shadows() {
    cr0_shadow = get_cr0<Vmcb>();
    cr3_shadow = get_cr3<Vmcb>();
ffffffff81013cfc:	48 89 87 98 00 00 00 	mov    %rax,0x98(%rdi)
mword Exc_regs::cr4_msk() const {
    mword clr = nst_on ? 0 :
#ifdef __i386__
            Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
            Cpu::CR4_PGE;
ffffffff81013d03:	48 19 c9             	sbb    %rcx,%rcx
ffffffff81013d06:	81 e1 80 00 00 00    	and    $0x80,%ecx
ffffffff81013d0c:	40 80 fe 01          	cmp    $0x1,%sil
ffffffff81013d10:	48 19 c0             	sbb    %rax,%rax
ffffffff81013d13:	83 e0 30             	and    $0x30,%eax
#endif

    return T::fix_cr4_clr | clr | cr4_set<T>();
ffffffff81013d16:	48 09 c8             	or     %rcx,%rax

template <typename T>
mword Exc_regs::get_cr4() const {
    mword msk = cr4_msk<T>();

    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
ffffffff81013d19:	48 89 c1             	mov    %rax,%rcx
ffffffff81013d1c:	48 23 87 a0 00 00 00 	and    0xa0(%rdi),%rax
ffffffff81013d23:	48 f7 d1             	not    %rcx
ffffffff81013d26:	48 23 8a 48 05 00 00 	and    0x548(%rdx),%rcx
ffffffff81013d2d:	48 09 c8             	or     %rcx,%rax
ffffffff81013d30:	48 89 87 a0 00 00 00 	mov    %rax,0xa0(%rdi)
ffffffff81013d37:	c3                   	retq   
template <> mword Exc_regs::get_g_efer<Vmcb>() const {
    return static_cast<mword> (vmcb->efer);
}

template <> mword Exc_regs::get_g_cr0<Vmcb>() const {
    return static_cast<mword> (vmcb->cr0);
ffffffff81013d38:	48 8b 82 58 05 00 00 	mov    0x558(%rdx),%rax
        svm_set_cpu_ctrl0(vmcb->intercept_cpu[0]);
    }
}

void Exc_regs::svm_update_shadows() {
    cr0_shadow = get_cr0<Vmcb>();
ffffffff81013d3f:	48 89 87 90 00 00 00 	mov    %rax,0x90(%rdi)
ffffffff81013d46:	e9 76 ff ff ff       	jmpq   ffffffff81013cc1 <_ZN8Exc_regs18svm_update_shadowsEv+0x55>
ffffffff81013d4b:	90                   	nop

ffffffff81013d4c <_ZN8Exc_regs12svm_read_gprEj>:
    cr3_shadow = get_cr3<Vmcb>();
    cr4_shadow = get_cr4<Vmcb>();
}

mword Exc_regs::svm_read_gpr(unsigned reg) {
    switch (reg) {
ffffffff81013d4c:	85 f6                	test   %esi,%esi
ffffffff81013d4e:	74 14                	je     ffffffff81013d64 <_ZN8Exc_regs12svm_read_gprEj+0x18>
ffffffff81013d50:	83 fe 04             	cmp    $0x4,%esi
ffffffff81013d53:	75 1e                	jne    ffffffff81013d73 <_ZN8Exc_regs12svm_read_gprEj+0x27>
        case 0: return static_cast<mword> (vmcb->rax);
        case 4: return static_cast<mword> (vmcb->rsp);
ffffffff81013d55:	48 8b 87 80 00 00 00 	mov    0x80(%rdi),%rax
ffffffff81013d5c:	48 8b 80 d8 05 00 00 	mov    0x5d8(%rax),%rax
ffffffff81013d63:	c3                   	retq   
    cr4_shadow = get_cr4<Vmcb>();
}

mword Exc_regs::svm_read_gpr(unsigned reg) {
    switch (reg) {
        case 0: return static_cast<mword> (vmcb->rax);
ffffffff81013d64:	48 8b 87 80 00 00 00 	mov    0x80(%rdi),%rax
ffffffff81013d6b:	48 8b 80 f8 05 00 00 	mov    0x5f8(%rax),%rax
ffffffff81013d72:	c3                   	retq   
        case 4: return static_cast<mword> (vmcb->rsp);
        default: return gpr[sizeof (Sys_regs) / sizeof (mword) - 1 - reg];
ffffffff81013d73:	89 f6                	mov    %esi,%esi
ffffffff81013d75:	b8 0f 00 00 00       	mov    $0xf,%eax
ffffffff81013d7a:	48 29 f0             	sub    %rsi,%rax
ffffffff81013d7d:	48 8b 04 c7          	mov    (%rdi,%rax,8),%rax
    }
}
ffffffff81013d81:	c3                   	retq   

ffffffff81013d82 <_ZN8Exc_regs13svm_write_gprEjm>:

void Exc_regs::svm_write_gpr(unsigned reg, mword val) {
    switch (reg) {
ffffffff81013d82:	85 f6                	test   %esi,%esi
ffffffff81013d84:	74 14                	je     ffffffff81013d9a <_ZN8Exc_regs13svm_write_gprEjm+0x18>
ffffffff81013d86:	83 fe 04             	cmp    $0x4,%esi
ffffffff81013d89:	75 1e                	jne    ffffffff81013da9 <_ZN8Exc_regs13svm_write_gprEjm+0x27>
        case 0: vmcb->rax = val;
            return;
        case 4: vmcb->rsp = val;
ffffffff81013d8b:	48 8b 87 80 00 00 00 	mov    0x80(%rdi),%rax
ffffffff81013d92:	48 89 90 d8 05 00 00 	mov    %rdx,0x5d8(%rax)
            return;
ffffffff81013d99:	c3                   	retq   
    }
}

void Exc_regs::svm_write_gpr(unsigned reg, mword val) {
    switch (reg) {
        case 0: vmcb->rax = val;
ffffffff81013d9a:	48 8b 87 80 00 00 00 	mov    0x80(%rdi),%rax
ffffffff81013da1:	48 89 90 f8 05 00 00 	mov    %rdx,0x5f8(%rax)
            return;
ffffffff81013da8:	c3                   	retq   
        case 4: vmcb->rsp = val;
            return;
        default: gpr[sizeof (Sys_regs) / sizeof (mword) - 1 - reg] = val;
ffffffff81013da9:	89 f6                	mov    %esi,%esi
ffffffff81013dab:	b8 0f 00 00 00       	mov    $0xf,%eax
ffffffff81013db0:	48 29 f0             	sub    %rsi,%rax
ffffffff81013db3:	48 89 14 c7          	mov    %rdx,(%rdi,%rax,8)
ffffffff81013db7:	c3                   	retq   

ffffffff81013db8 <_ZN8Exc_regs12vmx_read_gprEj>:
            return;
    }
}

mword Exc_regs::vmx_read_gpr(unsigned reg) {
    if (EXPECT_FALSE(reg == 4))
ffffffff81013db8:	83 fe 04             	cmp    $0x4,%esi
ffffffff81013dbb:	75 09                	jne    ffffffff81013dc6 <_ZN8Exc_regs12vmx_read_gprEj+0xe>
        return Vmcs::read(Vmcs::GUEST_RSP);
ffffffff81013dbd:	b8 1c 68 00 00       	mov    $0x681c,%eax
ffffffff81013dc2:	0f 78 c0             	vmread %rax,%rax
ffffffff81013dc5:	c3                   	retq   
    else
        return gpr[sizeof (Sys_regs) / sizeof (mword) - 1 - reg];
ffffffff81013dc6:	89 f6                	mov    %esi,%esi
ffffffff81013dc8:	b8 0f 00 00 00       	mov    $0xf,%eax
ffffffff81013dcd:	48 29 f0             	sub    %rsi,%rax
ffffffff81013dd0:	48 8b 04 c7          	mov    (%rdi,%rax,8),%rax
}
ffffffff81013dd4:	c3                   	retq   
ffffffff81013dd5:	90                   	nop

ffffffff81013dd6 <_ZN8Exc_regs13vmx_write_gprEjm>:

void Exc_regs::vmx_write_gpr(unsigned reg, mword val) {
    if (EXPECT_FALSE(reg == 4))
ffffffff81013dd6:	83 fe 04             	cmp    $0x4,%esi
ffffffff81013dd9:	75 09                	jne    ffffffff81013de4 <_ZN8Exc_regs13vmx_write_gprEjm+0xe>
ffffffff81013ddb:	b8 1c 68 00 00       	mov    $0x681c,%eax
ffffffff81013de0:	0f 79 c2             	vmwrite %rdx,%rax
ffffffff81013de3:	c3                   	retq   
        Vmcs::write(Vmcs::GUEST_RSP, val);
    else
        gpr[sizeof (Sys_regs) / sizeof (mword) - 1 - reg] = val;
ffffffff81013de4:	89 f6                	mov    %esi,%esi
ffffffff81013de6:	b8 0f 00 00 00       	mov    $0xf,%eax
ffffffff81013deb:	48 29 f0             	sub    %rsi,%rax
ffffffff81013dee:	48 89 14 c7          	mov    %rdx,(%rdi,%rax,8)
ffffffff81013df2:	c3                   	retq   
ffffffff81013df3:	90                   	nop

ffffffff81013df4 <_ZN8Exc_regs10write_eferI4VmcbEEvm>:
            UNREACHED;
    }
}

template <> void Exc_regs::write_efer<Vmcb> (mword val) {
    vmcb->efer = val;
ffffffff81013df4:	48 8b 87 80 00 00 00 	mov    0x80(%rdi),%rax
ffffffff81013dfb:	48 89 b0 d0 04 00 00 	mov    %rsi,0x4d0(%rax)
ffffffff81013e02:	c3                   	retq   
ffffffff81013e03:	90                   	nop

ffffffff81013e04 <_ZN8Exc_regs10write_eferI4VmcsEEvm>:
ffffffff81013e04:	b8 06 28 00 00       	mov    $0x2806,%eax
ffffffff81013e09:	0f 79 c6             	vmwrite %rsi,%rax
}

template <> void Exc_regs::write_efer<Vmcs> (mword val) {
    Vmcs::write(Vmcs::GUEST_EFER, val);

    if (val & Cpu::EFER_LMA)
ffffffff81013e0c:	f7 c6 00 04 00 00    	test   $0x400,%esi

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
ffffffff81013e12:	ba 12 40 00 00       	mov    $0x4012,%edx
ffffffff81013e17:	74 08                	je     ffffffff81013e21 <_ZN8Exc_regs10write_eferI4VmcsEEvm+0x1d>
ffffffff81013e19:	0f 78 d0             	vmread %rdx,%rax
        Vmcs::write(Vmcs::ENT_CONTROLS, Vmcs::read(Vmcs::ENT_CONTROLS) | Vmcs::ENT_GUEST_64);
ffffffff81013e1c:	80 cc 02             	or     $0x2,%ah
ffffffff81013e1f:	eb 06                	jmp    ffffffff81013e27 <_ZN8Exc_regs10write_eferI4VmcsEEvm+0x23>
ffffffff81013e21:	0f 78 d0             	vmread %rdx,%rax
    else
        Vmcs::write(Vmcs::ENT_CONTROLS, Vmcs::read(Vmcs::ENT_CONTROLS) & ~Vmcs::ENT_GUEST_64);
ffffffff81013e24:	80 e4 fd             	and    $0xfd,%ah
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
ffffffff81013e27:	0f 79 d0             	vmwrite %rax,%rdx
ffffffff81013e2a:	c3                   	retq   
ffffffff81013e2b:	90                   	nop

ffffffff81013e2c <_ZNK8Exc_regs14linear_addressI4VmcbEEmm>:
template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
ffffffff81013e2c:	80 bf c0 00 00 00 00 	cmpb   $0x0,0xc0(%rdi)
ffffffff81013e33:	b8 01 00 01 80       	mov    $0x80010001,%eax
ffffffff81013e38:	ba 00 00 00 00       	mov    $0x0,%edx

    return (get_g_efer<T>() & Cpu::EFER_LMA) && (dl & 1) ? MODE_PROT_64 : dl & 2 ? MODE_PROT_32 : MODE_PROT_16;
}

template <typename T>
mword Exc_regs::linear_address(mword val) const {
ffffffff81013e3d:	55                   	push   %rbp
template <> mword Exc_regs::get_g_efer<Vmcb>() const {
    return static_cast<mword> (vmcb->efer);
}

template <> mword Exc_regs::get_g_cr0<Vmcb>() const {
    return static_cast<mword> (vmcb->cr0);
ffffffff81013e3e:	48 8b af 80 00 00 00 	mov    0x80(%rdi),%rbp

    return (get_g_efer<T>() & Cpu::EFER_LMA) && (dl & 1) ? MODE_PROT_64 : dl & 2 ? MODE_PROT_32 : MODE_PROT_16;
}

template <typename T>
mword Exc_regs::linear_address(mword val) const {
ffffffff81013e45:	53                   	push   %rbx
ffffffff81013e46:	48 89 f3             	mov    %rsi,%rbx
template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
ffffffff81013e49:	48 0f 44 d0          	cmove  %rax,%rdx
    if (!fpu_on)
        set |= Cpu::CR0_TS;
ffffffff81013e4d:	48 89 d0             	mov    %rdx,%rax
ffffffff81013e50:	48 83 c8 08          	or     $0x8,%rax
ffffffff81013e54:	80 bf c1 00 00 00 00 	cmpb   $0x0,0xc1(%rdi)
ffffffff81013e5b:	48 0f 44 d0          	cmove  %rax,%rdx

template <typename T>
mword Exc_regs::get_cr0() const {
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
ffffffff81013e5f:	48 89 d0             	mov    %rdx,%rax
ffffffff81013e62:	48 23 97 90 00 00 00 	and    0x90(%rdi),%rdx
ffffffff81013e69:	48 f7 d0             	not    %rax
ffffffff81013e6c:	48 23 85 58 05 00 00 	and    0x558(%rbp),%rax
ffffffff81013e73:	48 09 c2             	or     %rax,%rdx
        Vpid::flush(Vpid::ADDRESS, vpid, addr);
}

template <typename T>
Exc_regs::Mode Exc_regs::mode() const {
    if (!(get_cr0<T>() & Cpu::CR0_PE))
ffffffff81013e76:	80 e2 01             	and    $0x1,%dl
ffffffff81013e79:	74 20                	je     ffffffff81013e9b <_ZNK8Exc_regs14linear_addressI4VmcbEEmm+0x6f>
        return MODE_REAL;

    if (get_g_flags<T>() & Cpu::EFL_VM)
ffffffff81013e7b:	f6 85 72 05 00 00 02 	testb  $0x2,0x572(%rbp)
ffffffff81013e82:	75 17                	jne    ffffffff81013e9b <_ZNK8Exc_regs14linear_addressI4VmcbEEmm+0x6f>
        return MODE_VM86;

    mword dl = get_g_cs_dl<T>();
ffffffff81013e84:	e8 a5 f3 ff ff       	callq  ffffffff8101322e <_ZNK8Exc_regs11get_g_cs_dlI4VmcbEEmv>

    return (get_g_efer<T>() & Cpu::EFER_LMA) && (dl & 1) ? MODE_PROT_64 : dl & 2 ? MODE_PROT_32 : MODE_PROT_16;
ffffffff81013e89:	f6 85 d1 04 00 00 04 	testb  $0x4,0x4d1(%rbp)
ffffffff81013e90:	74 09                	je     ffffffff81013e9b <_ZNK8Exc_regs14linear_addressI4VmcbEEmm+0x6f>
ffffffff81013e92:	a8 01                	test   $0x1,%al
ffffffff81013e94:	74 05                	je     ffffffff81013e9b <_ZNK8Exc_regs14linear_addressI4VmcbEEmm+0x6f>
}

template <typename T>
mword Exc_regs::linear_address(mword val) const {
    return mode<T>() == MODE_PROT_64 ? val : val & 0xffffffff;
ffffffff81013e96:	48 89 d8             	mov    %rbx,%rax
ffffffff81013e99:	eb 02                	jmp    ffffffff81013e9d <_ZNK8Exc_regs14linear_addressI4VmcbEEmm+0x71>
ffffffff81013e9b:	89 d8                	mov    %ebx,%eax
}
ffffffff81013e9d:	5b                   	pop    %rbx
ffffffff81013e9e:	5d                   	pop    %rbp
ffffffff81013e9f:	c3                   	retq   

ffffffff81013ea0 <_ZNK8Exc_regs7read_crI4VmcbEEmj>:
        gpr[sizeof (Sys_regs) / sizeof (mword) - 1 - reg] = val;
}

template <typename T>
mword Exc_regs::read_cr(unsigned cr) const {
    switch (cr) {
ffffffff81013ea0:	83 fe 02             	cmp    $0x2,%esi
ffffffff81013ea3:	0f 84 9f 00 00 00    	je     ffffffff81013f48 <_ZNK8Exc_regs7read_crI4VmcbEEmj+0xa8>
ffffffff81013ea9:	77 4e                	ja     ffffffff81013ef9 <_ZNK8Exc_regs7read_crI4VmcbEEmj+0x59>
ffffffff81013eab:	85 f6                	test   %esi,%esi
ffffffff81013ead:	0f 85 c4 00 00 00    	jne    ffffffff81013f77 <_ZNK8Exc_regs7read_crI4VmcbEEmj+0xd7>
template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
ffffffff81013eb3:	80 bf c0 00 00 00 00 	cmpb   $0x0,0xc0(%rdi)
ffffffff81013eba:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff81013ebf:	ba 01 00 01 80       	mov    $0x80010001,%edx
template <> mword Exc_regs::get_g_efer<Vmcb>() const {
    return static_cast<mword> (vmcb->efer);
}

template <> mword Exc_regs::get_g_cr0<Vmcb>() const {
    return static_cast<mword> (vmcb->cr0);
ffffffff81013ec4:	48 8b 8f 80 00 00 00 	mov    0x80(%rdi),%rcx
template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
ffffffff81013ecb:	48 0f 45 d0          	cmovne %rax,%rdx
    if (!fpu_on)
        set |= Cpu::CR0_TS;
ffffffff81013ecf:	48 89 d0             	mov    %rdx,%rax
ffffffff81013ed2:	48 83 c8 08          	or     $0x8,%rax
ffffffff81013ed6:	80 bf c1 00 00 00 00 	cmpb   $0x0,0xc1(%rdi)
ffffffff81013edd:	48 0f 44 d0          	cmove  %rax,%rdx

template <typename T>
mword Exc_regs::get_cr0() const {
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
ffffffff81013ee1:	48 89 d0             	mov    %rdx,%rax
ffffffff81013ee4:	48 23 97 90 00 00 00 	and    0x90(%rdi),%rdx
ffffffff81013eeb:	48 f7 d0             	not    %rax
ffffffff81013eee:	48 23 81 58 05 00 00 	and    0x558(%rcx),%rax
ffffffff81013ef5:	48 09 d0             	or     %rdx,%rax
}

template <typename T>
mword Exc_regs::read_cr(unsigned cr) const {
    switch (cr) {
        case 0: return get_cr0<T>();
ffffffff81013ef8:	c3                   	retq   
        gpr[sizeof (Sys_regs) / sizeof (mword) - 1 - reg] = val;
}

template <typename T>
mword Exc_regs::read_cr(unsigned cr) const {
    switch (cr) {
ffffffff81013ef9:	83 fe 03             	cmp    $0x3,%esi
ffffffff81013efc:	74 59                	je     ffffffff81013f57 <_ZNK8Exc_regs7read_crI4VmcbEEmj+0xb7>
ffffffff81013efe:	83 fe 04             	cmp    $0x4,%esi
ffffffff81013f01:	75 74                	jne    ffffffff81013f77 <_ZNK8Exc_regs7read_crI4VmcbEEmj+0xd7>
mword Exc_regs::cr4_msk() const {
    mword clr = nst_on ? 0 :
#ifdef __i386__
            Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
            Cpu::CR4_PGE;
ffffffff81013f03:	80 bf c0 00 00 00 01 	cmpb   $0x1,0xc0(%rdi)
template <> mword Exc_regs::get_g_cr3<Vmcb>() const {
    return static_cast<mword> (vmcb->cr3);
}

template <> mword Exc_regs::get_g_cr4<Vmcb>() const {
    return static_cast<mword> (vmcb->cr4);
ffffffff81013f0a:	48 8b 8f 80 00 00 00 	mov    0x80(%rdi),%rcx
mword Exc_regs::cr4_msk() const {
    mword clr = nst_on ? 0 :
#ifdef __i386__
            Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
            Cpu::CR4_PGE;
ffffffff81013f11:	48 19 d2             	sbb    %rdx,%rdx
ffffffff81013f14:	81 e2 80 00 00 00    	and    $0x80,%edx
ffffffff81013f1a:	80 bf c0 00 00 00 01 	cmpb   $0x1,0xc0(%rdi)
ffffffff81013f21:	48 19 c0             	sbb    %rax,%rax
ffffffff81013f24:	83 e0 30             	and    $0x30,%eax
#endif

    return T::fix_cr4_clr | clr | cr4_set<T>();
ffffffff81013f27:	48 09 c2             	or     %rax,%rdx

template <typename T>
mword Exc_regs::get_cr4() const {
    mword msk = cr4_msk<T>();

    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
ffffffff81013f2a:	48 89 d0             	mov    %rdx,%rax
ffffffff81013f2d:	48 f7 d0             	not    %rax
ffffffff81013f30:	48 23 81 48 05 00 00 	and    0x548(%rcx),%rax
ffffffff81013f37:	48 89 c1             	mov    %rax,%rcx
ffffffff81013f3a:	48 89 d0             	mov    %rdx,%rax
ffffffff81013f3d:	48 23 87 a0 00 00 00 	and    0xa0(%rdi),%rax
ffffffff81013f44:	48 09 c8             	or     %rcx,%rax
mword Exc_regs::read_cr(unsigned cr) const {
    switch (cr) {
        case 0: return get_cr0<T>();
        case 2: return get_g_cr2<T>();
        case 3: return get_cr3<T>();
        case 4: return get_cr4<T>();
ffffffff81013f47:	c3                   	retq   
template <> mword Exc_regs::get_g_cr0<Vmcb>() const {
    return static_cast<mword> (vmcb->cr0);
}

template <> mword Exc_regs::get_g_cr2<Vmcb>() const {
    return static_cast<mword> (vmcb->cr2);
ffffffff81013f48:	48 8b 87 80 00 00 00 	mov    0x80(%rdi),%rax
ffffffff81013f4f:	48 8b 80 40 06 00 00 	mov    0x640(%rax),%rax

template <typename T>
mword Exc_regs::read_cr(unsigned cr) const {
    switch (cr) {
        case 0: return get_cr0<T>();
        case 2: return get_g_cr2<T>();
ffffffff81013f56:	c3                   	retq   
    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
}

template <typename T>
mword Exc_regs::get_cr3() const {
    return nst_on ? get_g_cr3<T>() : cr3_shadow;
ffffffff81013f57:	80 bf c0 00 00 00 00 	cmpb   $0x0,0xc0(%rdi)
ffffffff81013f5e:	74 0f                	je     ffffffff81013f6f <_ZNK8Exc_regs7read_crI4VmcbEEmj+0xcf>
template <> mword Exc_regs::get_g_cr2<Vmcb>() const {
    return static_cast<mword> (vmcb->cr2);
}

template <> mword Exc_regs::get_g_cr3<Vmcb>() const {
    return static_cast<mword> (vmcb->cr3);
ffffffff81013f60:	48 8b 87 80 00 00 00 	mov    0x80(%rdi),%rax
ffffffff81013f67:	48 8b 80 50 05 00 00 	mov    0x550(%rax),%rax
ffffffff81013f6e:	c3                   	retq   
    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
}

template <typename T>
mword Exc_regs::get_cr3() const {
    return nst_on ? get_g_cr3<T>() : cr3_shadow;
ffffffff81013f6f:	48 8b 87 98 00 00 00 	mov    0x98(%rdi),%rax
ffffffff81013f76:	c3                   	retq   
ffffffff81013f77:	90                   	nop

ffffffff81013f78 <_ZNK8Exc_regs7read_crI4VmcsEEmj>:
        gpr[sizeof (Sys_regs) / sizeof (mword) - 1 - reg] = val;
}

template <typename T>
mword Exc_regs::read_cr(unsigned cr) const {
    switch (cr) {
ffffffff81013f78:	83 fe 02             	cmp    $0x2,%esi
ffffffff81013f7b:	0f 84 ad 00 00 00    	je     ffffffff8101402e <_ZNK8Exc_regs7read_crI4VmcsEEmj+0xb6>
ffffffff81013f81:	77 5a                	ja     ffffffff81013fdd <_ZNK8Exc_regs7read_crI4VmcsEEmj+0x65>
ffffffff81013f83:	85 f6                	test   %esi,%esi
ffffffff81013f85:	0f 85 c6 00 00 00    	jne    ffffffff81014051 <_ZNK8Exc_regs7read_crI4VmcsEEmj+0xd9>
template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
ffffffff81013f8b:	80 bf c0 00 00 00 00 	cmpb   $0x0,0xc0(%rdi)
ffffffff81013f92:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff81013f97:	ba 01 00 01 80       	mov    $0x80010001,%edx
ffffffff81013f9c:	48 0f 45 d0          	cmovne %rax,%rdx
    if (!fpu_on)
        set |= Cpu::CR0_TS;
ffffffff81013fa0:	48 89 d0             	mov    %rdx,%rax
ffffffff81013fa3:	48 83 c8 08          	or     $0x8,%rax
ffffffff81013fa7:	80 bf c1 00 00 00 00 	cmpb   $0x0,0xc1(%rdi)
ffffffff81013fae:	48 0f 44 d0          	cmove  %rax,%rdx
ffffffff81013fb2:	48 8b 05 87 be fe 3e 	mov    0x3efebe87(%rip),%rax        # ffffffffbffffe40 <_ZN4Vmcs11fix_cr0_clrE>
ffffffff81013fb9:	48 0b 05 88 be fe 3e 	or     0x3efebe88(%rip),%rax        # ffffffffbffffe48 <_ZN4Vmcs11fix_cr0_setE>
    return T::fix_cr0_set | set;
}

template <typename T>
mword Exc_regs::cr0_msk() const {
    return T::fix_cr0_clr | cr0_set<T>();
ffffffff81013fc0:	48 09 c2             	or     %rax,%rdx

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
ffffffff81013fc3:	b8 00 68 00 00       	mov    $0x6800,%eax
ffffffff81013fc8:	0f 78 c0             	vmread %rax,%rax

template <typename T>
mword Exc_regs::get_cr0() const {
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
ffffffff81013fcb:	48 89 d1             	mov    %rdx,%rcx
ffffffff81013fce:	48 23 97 90 00 00 00 	and    0x90(%rdi),%rdx
ffffffff81013fd5:	48 f7 d1             	not    %rcx
ffffffff81013fd8:	48 21 c8             	and    %rcx,%rax
ffffffff81013fdb:	eb 70                	jmp    ffffffff8101404d <_ZNK8Exc_regs7read_crI4VmcsEEmj+0xd5>
        gpr[sizeof (Sys_regs) / sizeof (mword) - 1 - reg] = val;
}

template <typename T>
mword Exc_regs::read_cr(unsigned cr) const {
    switch (cr) {
ffffffff81013fdd:	83 fe 03             	cmp    $0x3,%esi
ffffffff81013fe0:	74 51                	je     ffffffff81014033 <_ZNK8Exc_regs7read_crI4VmcsEEmj+0xbb>
ffffffff81013fe2:	83 fe 04             	cmp    $0x4,%esi
ffffffff81013fe5:	75 6a                	jne    ffffffff81014051 <_ZNK8Exc_regs7read_crI4VmcsEEmj+0xd9>
ffffffff81013fe7:	8a 87 c0 00 00 00    	mov    0xc0(%rdi),%al
mword Exc_regs::cr4_msk() const {
    mword clr = nst_on ? 0 :
#ifdef __i386__
            Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
            Cpu::CR4_PGE;
ffffffff81013fed:	3c 01                	cmp    $0x1,%al
ffffffff81013fef:	48 19 c9             	sbb    %rcx,%rcx
ffffffff81013ff2:	81 e1 80 00 00 00    	and    $0x80,%ecx
mword Exc_regs::cr4_set() const {
    mword set = nst_on ? 0 :
#ifdef __i386__
            Cpu::CR4_PSE;
#else
            Cpu::CR4_PSE | Cpu::CR4_PAE;
ffffffff81013ff8:	3c 01                	cmp    $0x1,%al
ffffffff81013ffa:	48 8b 05 2f be fe 3e 	mov    0x3efebe2f(%rip),%rax        # ffffffffbffffe30 <_ZN4Vmcs11fix_cr4_clrE>
ffffffff81014001:	48 19 d2             	sbb    %rdx,%rdx
ffffffff81014004:	48 0b 05 2d be fe 3e 	or     0x3efebe2d(%rip),%rax        # ffffffffbffffe38 <_ZN4Vmcs11fix_cr4_setE>
ffffffff8101400b:	83 e2 30             	and    $0x30,%edx
ffffffff8101400e:	48 09 c1             	or     %rax,%rcx
ffffffff81014011:	b8 04 68 00 00       	mov    $0x6804,%eax
            Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
            Cpu::CR4_PGE;
#endif

    return T::fix_cr4_clr | clr | cr4_set<T>();
ffffffff81014016:	48 09 ca             	or     %rcx,%rdx
ffffffff81014019:	0f 78 c0             	vmread %rax,%rax

template <typename T>
mword Exc_regs::get_cr4() const {
    mword msk = cr4_msk<T>();

    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
ffffffff8101401c:	48 89 d1             	mov    %rdx,%rcx
ffffffff8101401f:	48 23 97 a0 00 00 00 	and    0xa0(%rdi),%rdx
ffffffff81014026:	48 f7 d1             	not    %rcx
ffffffff81014029:	48 21 c8             	and    %rcx,%rax
ffffffff8101402c:	eb 1f                	jmp    ffffffff8101404d <_ZNK8Exc_regs7read_crI4VmcsEEmj+0xd5>
template <> mword Exc_regs::get_g_cr0<Vmcs>() const {
    return Vmcs::read(Vmcs::GUEST_CR0);
}

template <> mword Exc_regs::get_g_cr2<Vmcs>() const {
    return cr2;
ffffffff8101402e:	48 8b 47 58          	mov    0x58(%rdi),%rax

template <typename T>
mword Exc_regs::read_cr(unsigned cr) const {
    switch (cr) {
        case 0: return get_cr0<T>();
        case 2: return get_g_cr2<T>();
ffffffff81014032:	c3                   	retq   
    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
}

template <typename T>
mword Exc_regs::get_cr3() const {
    return nst_on ? get_g_cr3<T>() : cr3_shadow;
ffffffff81014033:	80 bf c0 00 00 00 00 	cmpb   $0x0,0xc0(%rdi)
ffffffff8101403a:	74 09                	je     ffffffff81014045 <_ZNK8Exc_regs7read_crI4VmcsEEmj+0xcd>
ffffffff8101403c:	b8 02 68 00 00       	mov    $0x6802,%eax
ffffffff81014041:	0f 78 c0             	vmread %rax,%rax
ffffffff81014044:	c3                   	retq   
ffffffff81014045:	48 8b 87 98 00 00 00 	mov    0x98(%rdi),%rax
ffffffff8101404c:	c3                   	retq   

template <typename T>
mword Exc_regs::get_cr4() const {
    mword msk = cr4_msk<T>();

    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
ffffffff8101404d:	48 09 d0             	or     %rdx,%rax
mword Exc_regs::read_cr(unsigned cr) const {
    switch (cr) {
        case 0: return get_cr0<T>();
        case 2: return get_g_cr2<T>();
        case 3: return get_cr3<T>();
        case 4: return get_cr4<T>();
ffffffff81014050:	c3                   	retq   
ffffffff81014051:	90                   	nop

ffffffff81014052 <_ZN8Exc_regs8write_crI4VmcbEEvjm>:

template <typename T>
void Exc_regs::write_cr(unsigned cr, mword val) {
    mword toggled;

    switch (cr) {
ffffffff81014052:	83 fe 02             	cmp    $0x2,%esi
ffffffff81014055:	74 28                	je     ffffffff8101407f <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x2d>
        default: UNREACHED;
    }
}

template <typename T>
void Exc_regs::write_cr(unsigned cr, mword val) {
ffffffff81014057:	41 54                	push   %r12
ffffffff81014059:	49 89 d4             	mov    %rdx,%r12
ffffffff8101405c:	55                   	push   %rbp
ffffffff8101405d:	53                   	push   %rbx
ffffffff8101405e:	48 89 fb             	mov    %rdi,%rbx
    mword toggled;

    switch (cr) {
ffffffff81014061:	77 09                	ja     ffffffff8101406c <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x1a>
ffffffff81014063:	85 f6                	test   %esi,%esi
ffffffff81014065:	74 5f                	je     ffffffff810140c6 <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x74>
ffffffff81014067:	e9 04 02 00 00       	jmpq   ffffffff81014270 <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x21e>
ffffffff8101406c:	83 fe 03             	cmp    $0x3,%esi
ffffffff8101406f:	74 1d                	je     ffffffff8101408e <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x3c>
ffffffff81014071:	83 fe 04             	cmp    $0x4,%esi
ffffffff81014074:	0f 84 59 01 00 00    	je     ffffffff810141d3 <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x181>
ffffffff8101407a:	e9 f1 01 00 00       	jmpq   ffffffff81014270 <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x21e>
template <> void Exc_regs::set_g_cr0<Vmcb> (mword v) const {
    vmcb->cr0 = v;
}

template <> void Exc_regs::set_g_cr2<Vmcb> (mword v) {
    vmcb->cr2 = v;
ffffffff8101407f:	48 8b 87 80 00 00 00 	mov    0x80(%rdi),%rax
ffffffff81014086:	48 89 90 40 06 00 00 	mov    %rdx,0x640(%rax)
ffffffff8101408d:	c3                   	retq   
        case 2:
            set_g_cr2<T> (val);
            break;

        case 3:
            if (!nst_on)
ffffffff8101408e:	80 bf c0 00 00 00 00 	cmpb   $0x0,0xc0(%rdi)
ffffffff81014095:	75 07                	jne    ffffffff8101409e <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x4c>
                tlb_flush<T> (false);
ffffffff81014097:	31 f6                	xor    %esi,%esi
ffffffff81014099:	e8 a6 f1 ff ff       	callq  ffffffff81013244 <_ZNK8Exc_regs9tlb_flushI4VmcbEEvb>
    set_s_cr0<T> (v);
}

template <typename T>
void Exc_regs::set_cr3(mword v) {
    if (nst_on)
ffffffff8101409e:	80 bb c0 00 00 00 00 	cmpb   $0x0,0xc0(%rbx)
ffffffff810140a5:	74 13                	je     ffffffff810140ba <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x68>
template <> void Exc_regs::set_g_cr2<Vmcb> (mword v) {
    vmcb->cr2 = v;
}

template <> void Exc_regs::set_g_cr3<Vmcb> (mword v) const {
    vmcb->cr3 = v;
ffffffff810140a7:	48 8b 83 80 00 00 00 	mov    0x80(%rbx),%rax
ffffffff810140ae:	4c 89 a0 50 05 00 00 	mov    %r12,0x550(%rax)
ffffffff810140b5:	e9 e9 01 00 00       	jmpq   ffffffff810142a3 <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x251>
template <typename T>
void Exc_regs::set_cr3(mword v) {
    if (nst_on)
        set_g_cr3<T> (v);
    else
        cr3_shadow = v;
ffffffff810140ba:	4c 89 a3 98 00 00 00 	mov    %r12,0x98(%rbx)
ffffffff810140c1:	e9 dd 01 00 00       	jmpq   ffffffff810142a3 <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x251>
ffffffff810140c6:	40 8a b7 c0 00 00 00 	mov    0xc0(%rdi),%sil
ffffffff810140cd:	8a 8f c1 00 00 00    	mov    0xc1(%rdi),%cl
ffffffff810140d3:	48 8b 97 80 00 00 00 	mov    0x80(%rdi),%rdx

template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
ffffffff810140da:	40 84 f6             	test   %sil,%sil
ffffffff810140dd:	74 08                	je     ffffffff810140e7 <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x95>
    return mode<T>() == MODE_PROT_64 ? val : val & 0xffffffff;
}

template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;
ffffffff810140df:	31 c0                	xor    %eax,%eax

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
ffffffff810140e1:	84 c9                	test   %cl,%cl
ffffffff810140e3:	75 13                	jne    ffffffff810140f8 <_ZN8Exc_regs8write_crI4VmcbEEvjm+0xa6>
ffffffff810140e5:	eb 0d                	jmp    ffffffff810140f4 <_ZN8Exc_regs8write_crI4VmcbEEvjm+0xa2>
ffffffff810140e7:	84 c9                	test   %cl,%cl
ffffffff810140e9:	0f 85 81 01 00 00    	jne    ffffffff81014270 <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x21e>
template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
ffffffff810140ef:	b8 01 00 01 80       	mov    $0x80010001,%eax
    if (!fpu_on)
        set |= Cpu::CR0_TS;
ffffffff810140f4:	48 83 c8 08          	or     $0x8,%rax

template <typename T>
mword Exc_regs::get_cr0() const {
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
ffffffff810140f8:	48 89 c5             	mov    %rax,%rbp
ffffffff810140fb:	48 23 83 90 00 00 00 	and    0x90(%rbx),%rax
ffffffff81014102:	48 f7 d5             	not    %rbp
ffffffff81014105:	48 23 aa 58 05 00 00 	and    0x558(%rdx),%rbp
ffffffff8101410c:	48 09 c5             	or     %rax,%rbp
            set_cr3<T> (val);

            break;

        case 0:
            toggled = get_cr0<T>() ^ val;
ffffffff8101410f:	4c 31 e5             	xor    %r12,%rbp

            if (!nst_on)
ffffffff81014112:	40 84 f6             	test   %sil,%sil
ffffffff81014115:	75 15                	jne    ffffffff8101412c <_ZN8Exc_regs8write_crI4VmcbEEvjm+0xda>
                if (toggled & (Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE))
ffffffff81014117:	f7 c5 01 00 01 80    	test   $0x80010001,%ebp
ffffffff8101411d:	74 0d                	je     ffffffff8101412c <_ZN8Exc_regs8write_crI4VmcbEEvjm+0xda>
                    tlb_flush<T> (true);
ffffffff8101411f:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff81014124:	48 89 df             	mov    %rbx,%rdi
ffffffff81014127:	e8 18 f1 ff ff       	callq  ffffffff81013244 <_ZNK8Exc_regs9tlb_flushI4VmcbEEvb>
ffffffff8101412c:	8a 93 c0 00 00 00    	mov    0xc0(%rbx),%dl
ffffffff81014132:	8a 8b c1 00 00 00    	mov    0xc1(%rbx),%cl

template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
ffffffff81014138:	84 d2                	test   %dl,%dl
ffffffff8101413a:	75 0b                	jne    ffffffff81014147 <_ZN8Exc_regs8write_crI4VmcbEEvjm+0xf5>
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
ffffffff8101413c:	84 c9                	test   %cl,%cl
template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
ffffffff8101413e:	b8 01 00 01 80       	mov    $0x80010001,%eax
    if (!fpu_on)
ffffffff81014143:	75 10                	jne    ffffffff81014155 <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x103>
ffffffff81014145:	eb 0a                	jmp    ffffffff81014151 <_ZN8Exc_regs8write_crI4VmcbEEvjm+0xff>
ffffffff81014147:	84 c9                	test   %cl,%cl
ffffffff81014149:	0f 85 4a 01 00 00    	jne    ffffffff81014299 <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x247>
    return mode<T>() == MODE_PROT_64 ? val : val & 0xffffffff;
}

template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;
ffffffff8101414f:	31 c0                	xor    %eax,%eax

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
        set |= Cpu::CR0_TS;
ffffffff81014151:	48 83 c8 08          	or     $0x8,%rax
    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
}

template <typename T>
void Exc_regs::set_cr0(mword v) {
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
ffffffff81014155:	48 f7 d0             	not    %rax
template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
ffffffff81014158:	be 01 00 01 80       	mov    $0x80010001,%esi
    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
}

template <typename T>
void Exc_regs::set_cr0(mword v) {
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
ffffffff8101415d:	48 83 c8 01          	or     $0x1,%rax
ffffffff81014161:	4c 21 e0             	and    %r12,%rax
template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
ffffffff81014164:	84 d2                	test   %dl,%dl
ffffffff81014166:	ba 00 00 00 00       	mov    $0x0,%edx
ffffffff8101416b:	48 0f 44 d6          	cmove  %rsi,%rdx
    if (!fpu_on)
        set |= Cpu::CR0_TS;
ffffffff8101416f:	48 89 d6             	mov    %rdx,%rsi
ffffffff81014172:	48 83 ce 08          	or     $0x8,%rsi
ffffffff81014176:	84 c9                	test   %cl,%cl
ffffffff81014178:	48 0f 44 d6          	cmove  %rsi,%rdx
template <> mword Exc_regs::get_g_cr4<Vmcs>() const {
    return Vmcs::read(Vmcs::GUEST_CR4);
}

template <> void Exc_regs::set_g_cr0<Vmcb> (mword v) const {
    vmcb->cr0 = v;
ffffffff8101417c:	48 8b 8b 80 00 00 00 	mov    0x80(%rbx),%rcx
    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
}

template <typename T>
void Exc_regs::set_cr0(mword v) {
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
ffffffff81014183:	83 e2 fe             	and    $0xfffffffe,%edx
ffffffff81014186:	48 09 d0             	or     %rdx,%rax
                if (toggled & (Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE))
                    tlb_flush<T> (true);

            set_cr0<T> (val);

            if (toggled & Cpu::CR0_PG) {
ffffffff81014189:	f7 c5 00 00 00 80    	test   $0x80000000,%ebp
    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
}

template <typename T>
void Exc_regs::set_cr0(mword v) {
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
ffffffff8101418f:	48 89 81 58 05 00 00 	mov    %rax,0x558(%rcx)
template <> void Exc_regs::set_e_bmp<Vmcb> (uint32 v) const {
    vmcb->intercept_exc = v;
}

template <> void Exc_regs::set_s_cr0<Vmcb> (mword v) {
    cr0_shadow = v;
ffffffff81014196:	4c 89 a3 90 00 00 00 	mov    %r12,0x90(%rbx)
                if (toggled & (Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE))
                    tlb_flush<T> (true);

            set_cr0<T> (val);

            if (toggled & Cpu::CR0_PG) {
ffffffff8101419d:	0f 84 00 01 00 00    	je     ffffffff810142a3 <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x251>
template <> mword Exc_regs::get_g_flags<Vmcb>() const {
    return static_cast<mword> (vmcb->rflags);
}

template <> mword Exc_regs::get_g_efer<Vmcb>() const {
    return static_cast<mword> (vmcb->efer);
ffffffff810141a3:	48 8b 93 80 00 00 00 	mov    0x80(%rbx),%rdx
                if (!T::has_urg())
                    nst_ctrl<T> (val & Cpu::CR0_PG);

#ifdef __x86_64__
                mword efer = get_g_efer<T>();
                if ((val & Cpu::CR0_PG) && (efer & Cpu::EFER_LME))
ffffffff810141aa:	41 f7 c4 00 00 00 80 	test   $0x80000000,%r12d
template <> mword Exc_regs::get_g_flags<Vmcb>() const {
    return static_cast<mword> (vmcb->rflags);
}

template <> mword Exc_regs::get_g_efer<Vmcb>() const {
    return static_cast<mword> (vmcb->efer);
ffffffff810141b1:	48 8b 82 d0 04 00 00 	mov    0x4d0(%rdx),%rax
                if (!T::has_urg())
                    nst_ctrl<T> (val & Cpu::CR0_PG);

#ifdef __x86_64__
                mword efer = get_g_efer<T>();
                if ((val & Cpu::CR0_PG) && (efer & Cpu::EFER_LME))
ffffffff810141b8:	74 0a                	je     ffffffff810141c4 <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x172>
ffffffff810141ba:	f6 c4 01             	test   $0x1,%ah
ffffffff810141bd:	74 05                	je     ffffffff810141c4 <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x172>
                    write_efer<T> (efer | Cpu::EFER_LMA);
ffffffff810141bf:	80 cc 04             	or     $0x4,%ah
ffffffff810141c2:	eb 03                	jmp    ffffffff810141c7 <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x175>
                else
                    write_efer<T> (efer & ~Cpu::EFER_LMA);
ffffffff810141c4:	80 e4 fb             	and    $0xfb,%ah
ffffffff810141c7:	48 89 82 d0 04 00 00 	mov    %rax,0x4d0(%rdx)
ffffffff810141ce:	e9 d0 00 00 00       	jmpq   ffffffff810142a3 <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x251>
ffffffff810141d3:	40 8a bf c0 00 00 00 	mov    0xc0(%rdi),%dil
template <> mword Exc_regs::get_g_cr3<Vmcb>() const {
    return static_cast<mword> (vmcb->cr3);
}

template <> mword Exc_regs::get_g_cr4<Vmcb>() const {
    return static_cast<mword> (vmcb->cr4);
ffffffff810141da:	48 8b 93 80 00 00 00 	mov    0x80(%rbx),%rdx
mword Exc_regs::cr4_msk() const {
    mword clr = nst_on ? 0 :
#ifdef __i386__
            Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
            Cpu::CR4_PGE;
ffffffff810141e1:	40 80 ff 01          	cmp    $0x1,%dil
template <> mword Exc_regs::get_g_cr3<Vmcb>() const {
    return static_cast<mword> (vmcb->cr3);
}

template <> mword Exc_regs::get_g_cr4<Vmcb>() const {
    return static_cast<mword> (vmcb->cr4);
ffffffff810141e5:	48 8b b2 48 05 00 00 	mov    0x548(%rdx),%rsi

template <typename T>
mword Exc_regs::get_cr4() const {
    mword msk = cr4_msk<T>();

    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
ffffffff810141ec:	48 8b 93 a0 00 00 00 	mov    0xa0(%rbx),%rdx
mword Exc_regs::cr4_msk() const {
    mword clr = nst_on ? 0 :
#ifdef __i386__
            Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
            Cpu::CR4_PGE;
ffffffff810141f3:	48 19 c0             	sbb    %rax,%rax
ffffffff810141f6:	25 80 00 00 00       	and    $0x80,%eax
ffffffff810141fb:	40 80 ff 01          	cmp    $0x1,%dil
ffffffff810141ff:	48 19 c9             	sbb    %rcx,%rcx
ffffffff81014202:	83 e1 30             	and    $0x30,%ecx
            break;

        case 4:
            toggled = get_cr4<T>() ^ val;

            if (!nst_on)
ffffffff81014205:	40 84 ff             	test   %dil,%dil
ffffffff81014208:	75 29                	jne    ffffffff81014233 <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x1e1>
            Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
            Cpu::CR4_PGE;
#endif

    return T::fix_cr4_clr | clr | cr4_set<T>();
ffffffff8101420a:	48 09 c1             	or     %rax,%rcx

template <typename T>
mword Exc_regs::get_cr4() const {
    mword msk = cr4_msk<T>();

    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
ffffffff8101420d:	48 89 c8             	mov    %rcx,%rax
ffffffff81014210:	48 f7 d0             	not    %rax
ffffffff81014213:	48 21 c6             	and    %rax,%rsi
ffffffff81014216:	48 89 c8             	mov    %rcx,%rax
ffffffff81014219:	48 21 d0             	and    %rdx,%rax
ffffffff8101421c:	48 09 f0             	or     %rsi,%rax
            }

            break;

        case 4:
            toggled = get_cr4<T>() ^ val;
ffffffff8101421f:	4c 31 e0             	xor    %r12,%rax

            if (!nst_on)
                if (toggled & (Cpu::CR4_PGE | Cpu::CR4_PAE | Cpu::CR4_PSE))
ffffffff81014222:	a8 b0                	test   $0xb0,%al
ffffffff81014224:	74 0d                	je     ffffffff81014233 <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x1e1>
                    tlb_flush<T> (true);
ffffffff81014226:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff8101422b:	48 89 df             	mov    %rbx,%rdi
ffffffff8101422e:	e8 11 f0 ff ff       	callq  ffffffff81013244 <_ZNK8Exc_regs9tlb_flushI4VmcbEEvb>
ffffffff81014233:	8a 93 c0 00 00 00    	mov    0xc0(%rbx),%dl
mword Exc_regs::cr4_msk() const {
    mword clr = nst_on ? 0 :
#ifdef __i386__
            Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
            Cpu::CR4_PGE;
ffffffff81014239:	80 fa 01             	cmp    $0x1,%dl
ffffffff8101423c:	48 19 c0             	sbb    %rax,%rax
ffffffff8101423f:	25 80 00 00 00       	and    $0x80,%eax
ffffffff81014244:	80 fa 01             	cmp    $0x1,%dl
template <> void Exc_regs::set_g_cr3<Vmcb> (mword v) const {
    vmcb->cr3 = v;
}

template <> void Exc_regs::set_g_cr4<Vmcb> (mword v) const {
    vmcb->cr4 = v;
ffffffff81014247:	48 8b 93 80 00 00 00 	mov    0x80(%rbx),%rdx
mword Exc_regs::cr4_msk() const {
    mword clr = nst_on ? 0 :
#ifdef __i386__
            Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
            Cpu::CR4_PGE;
ffffffff8101424e:	48 19 c9             	sbb    %rcx,%rcx
ffffffff81014251:	83 e1 30             	and    $0x30,%ecx
#endif

    return T::fix_cr4_clr | clr | cr4_set<T>();
ffffffff81014254:	48 09 c8             	or     %rcx,%rax
        cr3_shadow = v;
}

template <typename T>
void Exc_regs::set_cr4(mword v) {
    set_g_cr4<T> ((v & ~cr4_msk<T>()) | cr4_set<T>());
ffffffff81014257:	48 f7 d0             	not    %rax
ffffffff8101425a:	4c 21 e0             	and    %r12,%rax
ffffffff8101425d:	48 09 c8             	or     %rcx,%rax
ffffffff81014260:	48 89 82 48 05 00 00 	mov    %rax,0x548(%rdx)
template <> void Exc_regs::set_s_cr0<Vmcb> (mword v) {
    cr0_shadow = v;
}

template <> void Exc_regs::set_s_cr4<Vmcb> (mword v) {
    cr4_shadow = v;
ffffffff81014267:	4c 89 a3 a0 00 00 00 	mov    %r12,0xa0(%rbx)
ffffffff8101426e:	eb 33                	jmp    ffffffff810142a3 <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x251>

template <typename T>
mword Exc_regs::get_cr0() const {
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
ffffffff81014270:	48 8b ab 90 00 00 00 	mov    0x90(%rbx),%rbp
ffffffff81014277:	48 b8 fe ff fe 7f ff 	movabs $0xffffffff7ffefffe,%rax
ffffffff8101427e:	ff ff ff 
ffffffff81014281:	48 23 82 58 05 00 00 	and    0x558(%rdx),%rax
ffffffff81014288:	81 e5 01 00 01 80    	and    $0x80010001,%ebp
ffffffff8101428e:	48 09 c5             	or     %rax,%rbp
            set_cr3<T> (val);

            break;

        case 0:
            toggled = get_cr0<T>() ^ val;
ffffffff81014291:	4c 31 e5             	xor    %r12,%rbp
ffffffff81014294:	e9 7e fe ff ff       	jmpq   ffffffff81014117 <_ZN8Exc_regs8write_crI4VmcbEEvjm+0xc5>
    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
}

template <typename T>
void Exc_regs::set_cr0(mword v) {
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
ffffffff81014299:	4c 89 e0             	mov    %r12,%rax
    return mode<T>() == MODE_PROT_64 ? val : val & 0xffffffff;
}

template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;
ffffffff8101429c:	31 d2                	xor    %edx,%edx
ffffffff8101429e:	e9 d9 fe ff ff       	jmpq   ffffffff8101417c <_ZN8Exc_regs8write_crI4VmcbEEvjm+0x12a>
            break;

        default:
            UNREACHED;
    }
}
ffffffff810142a3:	5b                   	pop    %rbx
ffffffff810142a4:	5d                   	pop    %rbp
ffffffff810142a5:	41 5c                	pop    %r12
ffffffff810142a7:	c3                   	retq   

ffffffff810142a8 <_ZN8Exc_regs8write_crI4VmcsEEvjm>:

template <typename T>
void Exc_regs::write_cr(unsigned cr, mword val) {
    mword toggled;

    switch (cr) {
ffffffff810142a8:	83 fe 02             	cmp    $0x2,%esi
ffffffff810142ab:	74 28                	je     ffffffff810142d5 <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x2d>
        default: UNREACHED;
    }
}

template <typename T>
void Exc_regs::write_cr(unsigned cr, mword val) {
ffffffff810142ad:	41 54                	push   %r12
ffffffff810142af:	49 89 d4             	mov    %rdx,%r12
ffffffff810142b2:	55                   	push   %rbp
ffffffff810142b3:	53                   	push   %rbx
ffffffff810142b4:	48 89 fb             	mov    %rdi,%rbx
    mword toggled;

    switch (cr) {
ffffffff810142b7:	77 09                	ja     ffffffff810142c2 <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x1a>
ffffffff810142b9:	85 f6                	test   %esi,%esi
ffffffff810142bb:	74 4b                	je     ffffffff81014308 <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x60>
ffffffff810142bd:	e9 60 02 00 00       	jmpq   ffffffff81014522 <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x27a>
ffffffff810142c2:	83 fe 03             	cmp    $0x3,%esi
ffffffff810142c5:	74 13                	je     ffffffff810142da <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x32>
ffffffff810142c7:	83 fe 04             	cmp    $0x4,%esi
ffffffff810142ca:	0f 84 8d 01 00 00    	je     ffffffff8101445d <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x1b5>
ffffffff810142d0:	e9 4d 02 00 00       	jmpq   ffffffff81014522 <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x27a>
template <> void Exc_regs::set_g_cr0<Vmcs> (mword v) const {
    Vmcs::write(Vmcs::GUEST_CR0, v);
}

template <> void Exc_regs::set_g_cr2<Vmcs> (mword v) {
    cr2 = v;
ffffffff810142d5:	48 89 57 58          	mov    %rdx,0x58(%rdi)
ffffffff810142d9:	c3                   	retq   
        case 2:
            set_g_cr2<T> (val);
            break;

        case 3:
            if (!nst_on)
ffffffff810142da:	80 bf c0 00 00 00 00 	cmpb   $0x0,0xc0(%rdi)
ffffffff810142e1:	75 07                	jne    ffffffff810142ea <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x42>
                tlb_flush<T> (false);
ffffffff810142e3:	31 f6                	xor    %esi,%esi
ffffffff810142e5:	e8 84 ef ff ff       	callq  ffffffff8101326e <_ZNK8Exc_regs9tlb_flushI4VmcsEEvb>
    set_s_cr0<T> (v);
}

template <typename T>
void Exc_regs::set_cr3(mword v) {
    if (nst_on)
ffffffff810142ea:	80 bb c0 00 00 00 00 	cmpb   $0x0,0xc0(%rbx)
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
ffffffff810142f1:	b8 02 68 00 00       	mov    $0x6802,%eax
ffffffff810142f6:	0f 85 20 02 00 00    	jne    ffffffff8101451c <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x274>
        set_g_cr3<T> (v);
    else
        cr3_shadow = v;
ffffffff810142fc:	4c 89 a3 98 00 00 00 	mov    %r12,0x98(%rbx)
ffffffff81014303:	e9 2e 02 00 00       	jmpq   ffffffff81014536 <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x28e>
ffffffff81014308:	8a 97 c0 00 00 00    	mov    0xc0(%rdi),%dl
template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
ffffffff8101430e:	b9 01 00 01 80       	mov    $0x80010001,%ecx
ffffffff81014313:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff81014318:	48 8b 2d 21 bb fe 3e 	mov    0x3efebb21(%rip),%rbp        # ffffffffbffffe40 <_ZN4Vmcs11fix_cr0_clrE>
ffffffff8101431f:	84 d2                	test   %dl,%dl
ffffffff81014321:	48 0f 44 c1          	cmove  %rcx,%rax
    if (!fpu_on)
        set |= Cpu::CR0_TS;
ffffffff81014325:	48 89 c1             	mov    %rax,%rcx
ffffffff81014328:	48 83 c9 08          	or     $0x8,%rcx
ffffffff8101432c:	80 bf c1 00 00 00 00 	cmpb   $0x0,0xc1(%rdi)
ffffffff81014333:	48 0f 44 c1          	cmove  %rcx,%rax
ffffffff81014337:	48 0b 2d 0a bb fe 3e 	or     0x3efebb0a(%rip),%rbp        # ffffffffbffffe48 <_ZN4Vmcs11fix_cr0_setE>
    return T::fix_cr0_set | set;
}

template <typename T>
mword Exc_regs::cr0_msk() const {
    return T::fix_cr0_clr | cr0_set<T>();
ffffffff8101433e:	48 09 e8             	or     %rbp,%rax

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
ffffffff81014341:	bd 00 68 00 00       	mov    $0x6800,%ebp
ffffffff81014346:	0f 78 ed             	vmread %rbp,%rbp

template <typename T>
mword Exc_regs::get_cr0() const {
    mword msk = cr0_msk<T>();

    return (get_g_cr0<T>() & ~msk) | (cr0_shadow & msk);
ffffffff81014349:	48 89 c1             	mov    %rax,%rcx
ffffffff8101434c:	48 23 87 90 00 00 00 	and    0x90(%rdi),%rax
ffffffff81014353:	48 f7 d1             	not    %rcx
ffffffff81014356:	48 21 cd             	and    %rcx,%rbp
ffffffff81014359:	48 09 c5             	or     %rax,%rbp
            set_cr3<T> (val);

            break;

        case 0:
            toggled = get_cr0<T>() ^ val;
ffffffff8101435c:	4c 31 e5             	xor    %r12,%rbp

            if (!nst_on)
ffffffff8101435f:	84 d2                	test   %dl,%dl
ffffffff81014361:	75 12                	jne    ffffffff81014375 <_ZN8Exc_regs8write_crI4VmcsEEvjm+0xcd>
                if (toggled & (Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE))
ffffffff81014363:	f7 c5 01 00 01 80    	test   $0x80010001,%ebp
ffffffff81014369:	74 0a                	je     ffffffff81014375 <_ZN8Exc_regs8write_crI4VmcsEEvjm+0xcd>
                    tlb_flush<T> (true);
ffffffff8101436b:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff81014370:	e8 f9 ee ff ff       	callq  ffffffff8101326e <_ZNK8Exc_regs9tlb_flushI4VmcsEEvb>
ffffffff81014375:	40 8a bb c0 00 00 00 	mov    0xc0(%rbx),%dil
    return T::fix_cr0_set | set;
}

template <typename T>
mword Exc_regs::cr0_msk() const {
    return T::fix_cr0_clr | cr0_set<T>();
ffffffff8101437c:	48 8b 05 bd ba fe 3e 	mov    0x3efebabd(%rip),%rax        # ffffffffbffffe40 <_ZN4Vmcs11fix_cr0_clrE>
ffffffff81014383:	40 8a b3 c1 00 00 00 	mov    0xc1(%rbx),%sil
ffffffff8101438a:	48 8b 0d b7 ba fe 3e 	mov    0x3efebab7(%rip),%rcx        # ffffffffbffffe48 <_ZN4Vmcs11fix_cr0_setE>

template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
ffffffff81014391:	40 84 ff             	test   %dil,%dil
ffffffff81014394:	75 0c                	jne    ffffffff810143a2 <_ZN8Exc_regs8write_crI4VmcsEEvjm+0xfa>
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
ffffffff81014396:	40 84 f6             	test   %sil,%sil
template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
ffffffff81014399:	ba 01 00 01 80       	mov    $0x80010001,%edx
    if (!fpu_on)
ffffffff8101439e:	75 11                	jne    ffffffff810143b1 <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x109>
ffffffff810143a0:	eb 0b                	jmp    ffffffff810143ad <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x105>
ffffffff810143a2:	40 84 f6             	test   %sil,%sil
ffffffff810143a5:	0f 85 77 01 00 00    	jne    ffffffff81014522 <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x27a>
    return mode<T>() == MODE_PROT_64 ? val : val & 0xffffffff;
}

template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;
ffffffff810143ab:	31 d2                	xor    %edx,%edx

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
    if (!fpu_on)
        set |= Cpu::CR0_TS;
ffffffff810143ad:	48 83 ca 08          	or     $0x8,%rdx
ffffffff810143b1:	48 09 c8             	or     %rcx,%rax
    return T::fix_cr0_set | set;
}

template <typename T>
mword Exc_regs::cr0_msk() const {
    return T::fix_cr0_clr | cr0_set<T>();
ffffffff810143b4:	48 09 d0             	or     %rdx,%rax
template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
ffffffff810143b7:	ba 00 00 00 00       	mov    $0x0,%edx
    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
}

template <typename T>
void Exc_regs::set_cr0(mword v) {
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
ffffffff810143bc:	48 f7 d0             	not    %rax
ffffffff810143bf:	48 83 c8 01          	or     $0x1,%rax
ffffffff810143c3:	4c 21 e0             	and    %r12,%rax
template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;

    if (!nst_on)
        set |= Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE;
ffffffff810143c6:	40 84 ff             	test   %dil,%dil
ffffffff810143c9:	bf 01 00 01 80       	mov    $0x80010001,%edi
ffffffff810143ce:	48 0f 44 d7          	cmove  %rdi,%rdx
    if (!fpu_on)
        set |= Cpu::CR0_TS;
ffffffff810143d2:	48 89 d7             	mov    %rdx,%rdi
ffffffff810143d5:	48 83 cf 08          	or     $0x8,%rdi
ffffffff810143d9:	40 84 f6             	test   %sil,%sil
ffffffff810143dc:	48 0f 44 d7          	cmove  %rdi,%rdx

    return T::fix_cr0_set | set;
ffffffff810143e0:	48 09 d1             	or     %rdx,%rcx
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
ffffffff810143e3:	ba 00 68 00 00       	mov    $0x6800,%edx
    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
}

template <typename T>
void Exc_regs::set_cr0(mword v) {
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
ffffffff810143e8:	83 e1 fe             	and    $0xfffffffe,%ecx
ffffffff810143eb:	48 09 c8             	or     %rcx,%rax
ffffffff810143ee:	0f 79 d0             	vmwrite %rax,%rdx
ffffffff810143f1:	b8 04 60 00 00       	mov    $0x6004,%eax
template <> void Exc_regs::set_e_bmp<Vmcs> (uint32 v) const {
    Vmcs::write(Vmcs::EXC_BITMAP, v);
}

template <> void Exc_regs::set_s_cr0<Vmcs> (mword v) {
    Vmcs::write(Vmcs::CR0_READ_SHADOW, cr0_shadow = v);
ffffffff810143f6:	4c 89 a3 90 00 00 00 	mov    %r12,0x90(%rbx)
ffffffff810143fd:	41 0f 79 c4          	vmwrite %r12,%rax
                if (toggled & (Cpu::CR0_PG | Cpu::CR0_WP | Cpu::CR0_PE))
                    tlb_flush<T> (true);

            set_cr0<T> (val);

            if (toggled & Cpu::CR0_PG) {
ffffffff81014401:	f7 c5 00 00 00 80    	test   $0x80000000,%ebp
ffffffff81014407:	0f 84 29 01 00 00    	je     ffffffff81014536 <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x28e>

                if (!T::has_urg())
ffffffff8101440d:	f6 05 58 ba fe 3e 80 	testb  $0x80,0x3efeba58(%rip)        # ffffffffbffffe6c <_ZN4Vmcs8ctrl_cpuE+0xc>
ffffffff81014414:	75 12                	jne    ffffffff81014428 <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x180>
                    nst_ctrl<T> (val & Cpu::CR0_PG);
ffffffff81014416:	4c 89 e6             	mov    %r12,%rsi
ffffffff81014419:	48 89 df             	mov    %rbx,%rdi
ffffffff8101441c:	48 c1 ee 1f          	shr    $0x1f,%rsi
ffffffff81014420:	83 e6 01             	and    $0x1,%esi
ffffffff81014423:	e8 e6 f1 ff ff       	callq  ffffffff8101360e <_ZN8Exc_regs8nst_ctrlI4VmcsEEvb>

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
ffffffff81014428:	be 06 28 00 00       	mov    $0x2806,%esi
ffffffff8101442d:	0f 78 f6             	vmread %rsi,%rsi

#ifdef __x86_64__
                mword efer = get_g_efer<T>();
                if ((val & Cpu::CR0_PG) && (efer & Cpu::EFER_LME))
ffffffff81014430:	41 f7 c4 00 00 00 80 	test   $0x80000000,%r12d
ffffffff81014437:	74 11                	je     ffffffff8101444a <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x1a2>
ffffffff81014439:	f7 c6 00 01 00 00    	test   $0x100,%esi
ffffffff8101443f:	74 09                	je     ffffffff8101444a <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x1a2>
                    write_efer<T> (efer | Cpu::EFER_LMA);
ffffffff81014441:	48 81 ce 00 04 00 00 	or     $0x400,%rsi
ffffffff81014448:	eb 07                	jmp    ffffffff81014451 <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x1a9>
                else
                    write_efer<T> (efer & ~Cpu::EFER_LMA);
ffffffff8101444a:	48 81 e6 ff fb ff ff 	and    $0xfffffffffffffbff,%rsi
ffffffff81014451:	48 89 df             	mov    %rbx,%rdi
            break;

        default:
            UNREACHED;
    }
}
ffffffff81014454:	5b                   	pop    %rbx
ffffffff81014455:	5d                   	pop    %rbp
ffffffff81014456:	41 5c                	pop    %r12
#ifdef __x86_64__
                mword efer = get_g_efer<T>();
                if ((val & Cpu::CR0_PG) && (efer & Cpu::EFER_LME))
                    write_efer<T> (efer | Cpu::EFER_LMA);
                else
                    write_efer<T> (efer & ~Cpu::EFER_LMA);
ffffffff81014458:	e9 a7 f9 ff ff       	jmpq   ffffffff81013e04 <_ZN8Exc_regs10write_eferI4VmcsEEvm>
ffffffff8101445d:	44 8a 87 c0 00 00 00 	mov    0xc0(%rdi),%r8b
            Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
            Cpu::CR4_PGE;
#endif

    return T::fix_cr4_clr | clr | cr4_set<T>();
ffffffff81014464:	48 8b 05 c5 b9 fe 3e 	mov    0x3efeb9c5(%rip),%rax        # ffffffffbffffe30 <_ZN4Vmcs11fix_cr4_clrE>
ffffffff8101446b:	be 04 68 00 00       	mov    $0x6804,%esi
            Cpu::CR4_PSE;
#else
            Cpu::CR4_PSE | Cpu::CR4_PAE;
#endif

    return T::fix_cr4_set | set;
ffffffff81014470:	4c 8b 0d c1 b9 fe 3e 	mov    0x3efeb9c1(%rip),%r9        # ffffffffbffffe38 <_ZN4Vmcs11fix_cr4_setE>
mword Exc_regs::cr4_msk() const {
    mword clr = nst_on ? 0 :
#ifdef __i386__
            Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
            Cpu::CR4_PGE;
ffffffff81014477:	41 80 f8 01          	cmp    $0x1,%r8b
ffffffff8101447b:	48 19 ff             	sbb    %rdi,%rdi
ffffffff8101447e:	81 e7 80 00 00 00    	and    $0x80,%edi
mword Exc_regs::cr4_set() const {
    mword set = nst_on ? 0 :
#ifdef __i386__
            Cpu::CR4_PSE;
#else
            Cpu::CR4_PSE | Cpu::CR4_PAE;
ffffffff81014484:	41 80 f8 01          	cmp    $0x1,%r8b
ffffffff81014488:	48 19 c9             	sbb    %rcx,%rcx
ffffffff8101448b:	83 e1 30             	and    $0x30,%ecx
ffffffff8101448e:	0f 78 f6             	vmread %rsi,%rsi
            break;

        case 4:
            toggled = get_cr4<T>() ^ val;

            if (!nst_on)
ffffffff81014491:	45 84 c0             	test   %r8b,%r8b

template <typename T>
mword Exc_regs::get_cr4() const {
    mword msk = cr4_msk<T>();

    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
ffffffff81014494:	48 8b 93 a0 00 00 00 	mov    0xa0(%rbx),%rdx
            break;

        case 4:
            toggled = get_cr4<T>() ^ val;

            if (!nst_on)
ffffffff8101449b:	75 2f                	jne    ffffffff810144cc <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x224>
ffffffff8101449d:	4c 09 c8             	or     %r9,%rax
ffffffff810144a0:	48 09 f8             	or     %rdi,%rax
            Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
            Cpu::CR4_PGE;
#endif

    return T::fix_cr4_clr | clr | cr4_set<T>();
ffffffff810144a3:	48 09 c1             	or     %rax,%rcx

template <typename T>
mword Exc_regs::get_cr4() const {
    mword msk = cr4_msk<T>();

    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
ffffffff810144a6:	48 89 c8             	mov    %rcx,%rax
ffffffff810144a9:	48 f7 d0             	not    %rax
ffffffff810144ac:	48 21 c6             	and    %rax,%rsi
ffffffff810144af:	48 89 c8             	mov    %rcx,%rax
ffffffff810144b2:	48 21 d0             	and    %rdx,%rax
ffffffff810144b5:	48 09 f0             	or     %rsi,%rax
            }

            break;

        case 4:
            toggled = get_cr4<T>() ^ val;
ffffffff810144b8:	4c 31 e0             	xor    %r12,%rax

            if (!nst_on)
                if (toggled & (Cpu::CR4_PGE | Cpu::CR4_PAE | Cpu::CR4_PSE))
ffffffff810144bb:	a8 b0                	test   $0xb0,%al
ffffffff810144bd:	74 0d                	je     ffffffff810144cc <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x224>
                    tlb_flush<T> (true);
ffffffff810144bf:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff810144c4:	48 89 df             	mov    %rbx,%rdi
ffffffff810144c7:	e8 a2 ed ff ff       	callq  ffffffff8101326e <_ZNK8Exc_regs9tlb_flushI4VmcsEEvb>
ffffffff810144cc:	8a 93 c0 00 00 00    	mov    0xc0(%rbx),%dl
            Cpu::CR4_PSE;
#else
            Cpu::CR4_PSE | Cpu::CR4_PAE;
#endif

    return T::fix_cr4_set | set;
ffffffff810144d2:	48 8b 35 5f b9 fe 3e 	mov    0x3efeb95f(%rip),%rsi        # ffffffffbffffe38 <_ZN4Vmcs11fix_cr4_setE>
mword Exc_regs::cr4_msk() const {
    mword clr = nst_on ? 0 :
#ifdef __i386__
            Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
            Cpu::CR4_PGE;
ffffffff810144d9:	80 fa 01             	cmp    $0x1,%dl
ffffffff810144dc:	48 19 c0             	sbb    %rax,%rax
ffffffff810144df:	25 80 00 00 00       	and    $0x80,%eax
mword Exc_regs::cr4_set() const {
    mword set = nst_on ? 0 :
#ifdef __i386__
            Cpu::CR4_PSE;
#else
            Cpu::CR4_PSE | Cpu::CR4_PAE;
ffffffff810144e4:	80 fa 01             	cmp    $0x1,%dl
ffffffff810144e7:	48 89 f2             	mov    %rsi,%rdx
ffffffff810144ea:	48 19 c9             	sbb    %rcx,%rcx
ffffffff810144ed:	48 0b 15 3c b9 fe 3e 	or     0x3efeb93c(%rip),%rdx        # ffffffffbffffe30 <_ZN4Vmcs11fix_cr4_clrE>
ffffffff810144f4:	83 e1 30             	and    $0x30,%ecx
ffffffff810144f7:	48 09 d0             	or     %rdx,%rax
            Cpu::CR4_PGE | Cpu::CR4_PAE;
#else
            Cpu::CR4_PGE;
#endif

    return T::fix_cr4_clr | clr | cr4_set<T>();
ffffffff810144fa:	48 09 c8             	or     %rcx,%rax
        cr3_shadow = v;
}

template <typename T>
void Exc_regs::set_cr4(mword v) {
    set_g_cr4<T> ((v & ~cr4_msk<T>()) | cr4_set<T>());
ffffffff810144fd:	48 f7 d0             	not    %rax
ffffffff81014500:	4c 21 e0             	and    %r12,%rax
ffffffff81014503:	48 09 f0             	or     %rsi,%rax
ffffffff81014506:	48 09 c1             	or     %rax,%rcx
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
ffffffff81014509:	b8 04 68 00 00       	mov    $0x6804,%eax
ffffffff8101450e:	0f 79 c1             	vmwrite %rcx,%rax
template <> void Exc_regs::set_s_cr0<Vmcs> (mword v) {
    Vmcs::write(Vmcs::CR0_READ_SHADOW, cr0_shadow = v);
}

template <> void Exc_regs::set_s_cr4<Vmcs> (mword v) {
    Vmcs::write(Vmcs::CR4_READ_SHADOW, cr4_shadow = v);
ffffffff81014511:	4c 89 a3 a0 00 00 00 	mov    %r12,0xa0(%rbx)
ffffffff81014518:	66 b8 06 60          	mov    $0x6006,%ax
ffffffff8101451c:	41 0f 79 c4          	vmwrite %r12,%rax
ffffffff81014520:	eb 14                	jmp    ffffffff81014536 <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x28e>
    return T::fix_cr0_set | set;
}

template <typename T>
mword Exc_regs::cr0_msk() const {
    return T::fix_cr0_clr | cr0_set<T>();
ffffffff81014522:	48 09 c8             	or     %rcx,%rax
    return mode<T>() == MODE_PROT_64 ? val : val & 0xffffffff;
}

template <typename T>
mword Exc_regs::cr0_set() const {
    mword set = 0;
ffffffff81014525:	31 d2                	xor    %edx,%edx
    return (get_g_cr4<T>() & ~msk) | (cr4_shadow & msk);
}

template <typename T>
void Exc_regs::set_cr0(mword v) {
    set_g_cr0<T> ((v & (~cr0_msk<T>() | Cpu::CR0_PE)) | (cr0_set<T>() & ~Cpu::CR0_PE));
ffffffff81014527:	48 f7 d0             	not    %rax
ffffffff8101452a:	48 83 c8 01          	or     $0x1,%rax
ffffffff8101452e:	4c 21 e0             	and    %r12,%rax
ffffffff81014531:	e9 aa fe ff ff       	jmpq   ffffffff810143e0 <_ZN8Exc_regs8write_crI4VmcsEEvjm+0x138>
            break;

        default:
            UNREACHED;
    }
}
ffffffff81014536:	5b                   	pop    %rbx
ffffffff81014537:	5d                   	pop    %rbp
ffffffff81014538:	41 5c                	pop    %r12
ffffffff8101453a:	c3                   	retq   
ffffffff8101453b:	90                   	nop

ffffffff8101453c <_ZN2ScC1EP2PdmP2Ec>:

Sc *Sc::list[Sc::priorities];

unsigned Sc::prio_top;

Sc::Sc (Pd *own, mword sel, Ec *e) : Kobject (SC, static_cast<Space_obj *>(own), sel, 0x1, free), ec (e), cpu (static_cast<unsigned>(sel)), prio (0), budget (Lapic::freq_tsc * 1000), left (0), prev (nullptr), next (nullptr)
ffffffff8101453c:	48 8d 86 f8 02 00 00 	lea    0x2f8(%rsi),%rax
ffffffff81014543:	48 85 f6             	test   %rsi,%rsi
ffffffff81014546:	be 00 00 00 00       	mov    $0x0,%esi
ffffffff8101454b:	41 54                	push   %r12
ffffffff8101454d:	55                   	push   %rbp
ffffffff8101454e:	49 89 d4             	mov    %rdx,%r12
ffffffff81014551:	53                   	push   %rbx
ffffffff81014552:	48 0f 45 f0          	cmovne %rax,%rsi
ffffffff81014556:	50                   	push   %rax
ffffffff81014557:	6a 00                	pushq  $0x0
ffffffff81014559:	48 89 cd             	mov    %rcx,%rbp
ffffffff8101455c:	49 c7 c1 4e 4d 01 81 	mov    $0xffffffff81014d4e,%r9
ffffffff81014563:	48 89 d1             	mov    %rdx,%rcx
ffffffff81014566:	41 b8 01 00 00 00    	mov    $0x1,%r8d
ffffffff8101456c:	48 89 fa             	mov    %rdi,%rdx
ffffffff8101456f:	48 89 fb             	mov    %rdi,%rbx
ffffffff81014572:	e8 35 f3 fe ff       	callq  ffffffff810038ac <_ZN3MdbC1EP5SpacemmmPFvP8Rcu_elemES5_>
    private:
        uint32 ref;

    public:
        ALWAYS_INLINE
        inline Refex() : ref (1) {}
ffffffff81014577:	5a                   	pop    %rdx
ffffffff81014578:	59                   	pop    %rcx
ffffffff81014579:	c6 83 88 00 00 00 02 	movb   $0x2,0x88(%rbx)
ffffffff81014580:	66 c7 83 8a 00 00 00 	movw   $0x0,0x8a(%rbx)
ffffffff81014587:	00 00 
ffffffff81014589:	c7 83 8c 00 00 00 01 	movl   $0x1,0x8c(%rbx)
ffffffff81014590:	00 00 00 

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff81014593:	8b 85 8c 00 00 00    	mov    0x8c(%rbp),%eax
ffffffff81014599:	85 c0                	test   %eax,%eax
ffffffff8101459b:	74 0f                	je     ffffffff810145ac <_ZN2ScC1EP2PdmP2Ec+0x70>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8101459d:	8d 50 01             	lea    0x1(%rax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff810145a0:	f0 0f b1 95 8c 00 00 	lock cmpxchg %edx,0x8c(%rbp)
ffffffff810145a7:	00 
ffffffff810145a8:	75 e9                	jne    ffffffff81014593 <_ZN2ScC1EP2PdmP2Ec+0x57>
ffffffff810145aa:	eb 02                	jmp    ffffffff810145ae <_ZN2ScC1EP2PdmP2Ec+0x72>
    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }

        ALWAYS_INLINE
        inline Refptr (T *p) : ptr (p->add_ref() ? p : nullptr) {}
ffffffff810145ac:	31 ed                	xor    %ebp,%ebp
ffffffff810145ae:	69 05 bc f2 14 00 e8 	imul   $0x3e8,0x14f2bc(%rip),%eax        # ffffffff81163874 <_ZN5Lapic8freq_tscE>
ffffffff810145b5:	03 00 00 
ffffffff810145b8:	48 89 ab 90 00 00 00 	mov    %rbp,0x90(%rbx)
ffffffff810145bf:	44 89 a3 98 00 00 00 	mov    %r12d,0x98(%rbx)
ffffffff810145c6:	c7 83 9c 00 00 00 00 	movl   $0x0,0x9c(%rbx)
ffffffff810145cd:	00 00 00 
ffffffff810145d0:	48 c7 83 b0 00 00 00 	movq   $0x0,0xb0(%rbx)
ffffffff810145d7:	00 00 00 00 
ffffffff810145db:	48 c7 83 b8 00 00 00 	movq   $0x0,0xb8(%rbx)
ffffffff810145e2:	00 00 00 00 
ffffffff810145e6:	48 c7 83 c0 00 00 00 	movq   $0x0,0xc0(%rbx)
ffffffff810145ed:	00 00 00 00 
ffffffff810145f1:	48 89 83 a0 00 00 00 	mov    %rax,0xa0(%rbx)
{
    trace (TRACE_SYSCALL, "SC:%p created (PD:%p Kernel)", this, own);
}
ffffffff810145f8:	5b                   	pop    %rbx
ffffffff810145f9:	5d                   	pop    %rbp
ffffffff810145fa:	41 5c                	pop    %r12
ffffffff810145fc:	c3                   	retq   
ffffffff810145fd:	90                   	nop

ffffffff810145fe <_ZN2ScC1EP2PdmP2Ecjjj>:

Sc::Sc (Pd *own, mword sel, Ec *e, unsigned c, unsigned p, unsigned q) : Kobject (SC, static_cast<Space_obj *>(own), sel, 0x1, free), ec (e), cpu (c), prio (p), budget (Lapic::freq_tsc / 1000 * q), left (0), prev (nullptr), next (nullptr)
ffffffff810145fe:	41 55                	push   %r13
ffffffff81014600:	41 54                	push   %r12
ffffffff81014602:	48 8d 86 f8 02 00 00 	lea    0x2f8(%rsi),%rax
ffffffff81014609:	55                   	push   %rbp
ffffffff8101460a:	53                   	push   %rbx
ffffffff8101460b:	48 89 cd             	mov    %rcx,%rbp
ffffffff8101460e:	45 89 c5             	mov    %r8d,%r13d
ffffffff81014611:	48 89 d1             	mov    %rdx,%rcx
ffffffff81014614:	45 89 cc             	mov    %r9d,%r12d
ffffffff81014617:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff8101461b:	48 85 f6             	test   %rsi,%rsi
ffffffff8101461e:	be 00 00 00 00       	mov    $0x0,%esi
ffffffff81014623:	6a 00                	pushq  $0x0
ffffffff81014625:	48 0f 45 f0          	cmovne %rax,%rsi
ffffffff81014629:	49 c7 c1 4e 4d 01 81 	mov    $0xffffffff81014d4e,%r9
ffffffff81014630:	41 b8 01 00 00 00    	mov    $0x1,%r8d
ffffffff81014636:	48 89 fa             	mov    %rdi,%rdx
ffffffff81014639:	48 89 fb             	mov    %rdi,%rbx
ffffffff8101463c:	e8 6b f2 fe ff       	callq  ffffffff810038ac <_ZN3MdbC1EP5SpacemmmPFvP8Rcu_elemES5_>
    private:
        uint32 ref;

    public:
        ALWAYS_INLINE
        inline Refex() : ref (1) {}
ffffffff81014641:	41 5b                	pop    %r11
ffffffff81014643:	58                   	pop    %rax
ffffffff81014644:	c6 83 88 00 00 00 02 	movb   $0x2,0x88(%rbx)
ffffffff8101464b:	66 c7 83 8a 00 00 00 	movw   $0x0,0x8a(%rbx)
ffffffff81014652:	00 00 
ffffffff81014654:	c7 83 8c 00 00 00 01 	movl   $0x1,0x8c(%rbx)
ffffffff8101465b:	00 00 00 

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8101465e:	8b 85 8c 00 00 00    	mov    0x8c(%rbp),%eax
ffffffff81014664:	85 c0                	test   %eax,%eax
ffffffff81014666:	74 0f                	je     ffffffff81014677 <_ZN2ScC1EP2PdmP2Ecjjj+0x79>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff81014668:	8d 50 01             	lea    0x1(%rax),%edx
ffffffff8101466b:	f0 0f b1 95 8c 00 00 	lock cmpxchg %edx,0x8c(%rbp)
ffffffff81014672:	00 
ffffffff81014673:	75 e9                	jne    ffffffff8101465e <_ZN2ScC1EP2PdmP2Ecjjj+0x60>
ffffffff81014675:	eb 02                	jmp    ffffffff81014679 <_ZN2ScC1EP2PdmP2Ecjjj+0x7b>
    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }

        ALWAYS_INLINE
        inline Refptr (T *p) : ptr (p->add_ref() ? p : nullptr) {}
ffffffff81014677:	31 ed                	xor    %ebp,%ebp
ffffffff81014679:	8b 05 f5 f1 14 00    	mov    0x14f1f5(%rip),%eax        # ffffffff81163874 <_ZN5Lapic8freq_tscE>
ffffffff8101467f:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
ffffffff81014684:	31 d2                	xor    %edx,%edx
ffffffff81014686:	48 89 ab 90 00 00 00 	mov    %rbp,0x90(%rbx)
ffffffff8101468d:	44 89 ab 98 00 00 00 	mov    %r13d,0x98(%rbx)
ffffffff81014694:	44 89 a3 9c 00 00 00 	mov    %r12d,0x9c(%rbx)
ffffffff8101469b:	48 c7 83 b0 00 00 00 	movq   $0x0,0xb0(%rbx)
ffffffff810146a2:	00 00 00 00 
ffffffff810146a6:	f7 f1                	div    %ecx
ffffffff810146a8:	48 c7 83 b8 00 00 00 	movq   $0x0,0xb8(%rbx)
ffffffff810146af:	00 00 00 00 
ffffffff810146b3:	48 c7 83 c0 00 00 00 	movq   $0x0,0xc0(%rbx)
ffffffff810146ba:	00 00 00 00 
ffffffff810146be:	0f af 44 24 30       	imul   0x30(%rsp),%eax
ffffffff810146c3:	48 89 83 a0 00 00 00 	mov    %rax,0xa0(%rbx)
{
    trace (TRACE_SYSCALL, "SC:%p created (EC:%p CPU:%#x P:%#x Q:%#x)", this, e, c, p, q);
}
ffffffff810146ca:	58                   	pop    %rax
ffffffff810146cb:	5b                   	pop    %rbx
ffffffff810146cc:	5d                   	pop    %rbp
ffffffff810146cd:	41 5c                	pop    %r12
ffffffff810146cf:	41 5d                	pop    %r13
ffffffff810146d1:	c3                   	retq   

ffffffff810146d2 <_ZN2ScC1EP2PdP2EcjPS_>:

Sc::Sc (Pd *own, Ec *e, unsigned c, Sc *x) : Kobject (SC, static_cast<Space_obj *>(own), 0, 0x1, free), ec (e), cpu (c), prio (x->prio), budget (x->budget), left (x->left)
ffffffff810146d2:	41 55                	push   %r13
ffffffff810146d4:	41 54                	push   %r12
ffffffff810146d6:	48 8d 86 f8 02 00 00 	lea    0x2f8(%rsi),%rax
ffffffff810146dd:	55                   	push   %rbp
ffffffff810146de:	53                   	push   %rbx
ffffffff810146df:	48 89 d5             	mov    %rdx,%rbp
ffffffff810146e2:	41 89 cd             	mov    %ecx,%r13d
ffffffff810146e5:	4d 89 c4             	mov    %r8,%r12
ffffffff810146e8:	49 c7 c1 4e 4d 01 81 	mov    $0xffffffff81014d4e,%r9
ffffffff810146ef:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff810146f3:	48 85 f6             	test   %rsi,%rsi
ffffffff810146f6:	be 00 00 00 00       	mov    $0x0,%esi
ffffffff810146fb:	6a 00                	pushq  $0x0
ffffffff810146fd:	48 0f 45 f0          	cmovne %rax,%rsi
ffffffff81014701:	41 b8 01 00 00 00    	mov    $0x1,%r8d
ffffffff81014707:	31 c9                	xor    %ecx,%ecx
ffffffff81014709:	48 89 fa             	mov    %rdi,%rdx
ffffffff8101470c:	48 89 fb             	mov    %rdi,%rbx
ffffffff8101470f:	e8 98 f1 fe ff       	callq  ffffffff810038ac <_ZN3MdbC1EP5SpacemmmPFvP8Rcu_elemES5_>
    private:
        uint32 ref;

    public:
        ALWAYS_INLINE
        inline Refex() : ref (1) {}
ffffffff81014714:	41 5a                	pop    %r10
ffffffff81014716:	41 5b                	pop    %r11
ffffffff81014718:	c6 83 88 00 00 00 02 	movb   $0x2,0x88(%rbx)
ffffffff8101471f:	66 c7 83 8a 00 00 00 	movw   $0x0,0x8a(%rbx)
ffffffff81014726:	00 00 
ffffffff81014728:	c7 83 8c 00 00 00 01 	movl   $0x1,0x8c(%rbx)
ffffffff8101472f:	00 00 00 

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff81014732:	8b 85 8c 00 00 00    	mov    0x8c(%rbp),%eax
ffffffff81014738:	85 c0                	test   %eax,%eax
ffffffff8101473a:	74 0f                	je     ffffffff8101474b <_ZN2ScC1EP2PdP2EcjPS_+0x79>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8101473c:	8d 50 01             	lea    0x1(%rax),%edx
ffffffff8101473f:	f0 0f b1 95 8c 00 00 	lock cmpxchg %edx,0x8c(%rbp)
ffffffff81014746:	00 
ffffffff81014747:	75 e9                	jne    ffffffff81014732 <_ZN2ScC1EP2PdP2EcjPS_+0x60>
ffffffff81014749:	eb 02                	jmp    ffffffff8101474d <_ZN2ScC1EP2PdP2EcjPS_+0x7b>
    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }

        ALWAYS_INLINE
        inline Refptr (T *p) : ptr (p->add_ref() ? p : nullptr) {}
ffffffff8101474b:	31 ed                	xor    %ebp,%ebp
ffffffff8101474d:	48 89 ab 90 00 00 00 	mov    %rbp,0x90(%rbx)
ffffffff81014754:	44 89 ab 98 00 00 00 	mov    %r13d,0x98(%rbx)
ffffffff8101475b:	41 8b 84 24 9c 00 00 	mov    0x9c(%r12),%eax
ffffffff81014762:	00 
ffffffff81014763:	89 83 9c 00 00 00    	mov    %eax,0x9c(%rbx)
ffffffff81014769:	49 8b 84 24 a0 00 00 	mov    0xa0(%r12),%rax
ffffffff81014770:	00 
ffffffff81014771:	48 89 83 a0 00 00 00 	mov    %rax,0xa0(%rbx)
ffffffff81014778:	49 8b 84 24 b0 00 00 	mov    0xb0(%r12),%rax
ffffffff8101477f:	00 
ffffffff81014780:	48 89 83 b0 00 00 00 	mov    %rax,0xb0(%rbx)
{
    trace (TRACE_SYSCALL, "SC:%p created (EC:%p CPU:%#x P:%#x Q:%#llx) - xCPU", this, e, c, prio, budget / (Lapic::freq_bus / 1000));
}
ffffffff81014787:	58                   	pop    %rax
ffffffff81014788:	5b                   	pop    %rbx
ffffffff81014789:	5d                   	pop    %rbp
ffffffff8101478a:	41 5c                	pop    %r12
ffffffff8101478c:	41 5d                	pop    %r13
ffffffff8101478e:	c3                   	retq   
ffffffff8101478f:	90                   	nop

ffffffff81014790 <_ZN2Sc13ready_enqueueEyb>:

void Sc::ready_enqueue (uint64 t, bool use_left)
{
ffffffff81014790:	48 83 ec 18          	sub    $0x18,%rsp
    assert (prio < priorities);
ffffffff81014794:	83 bf 9c 00 00 00 7f 	cmpl   $0x7f,0x9c(%rdi)
ffffffff8101479b:	76 1c                	jbe    ffffffff810147b9 <_ZN2Sc13ready_enqueueEyb+0x29>
ffffffff8101479d:	49 c7 c0 80 05 02 81 	mov    $0xffffffff81020580,%r8
ffffffff810147a4:	b9 3b 00 00 00       	mov    $0x3b,%ecx
ffffffff810147a9:	48 c7 c2 4e 03 02 81 	mov    $0xffffffff8102034e,%rdx
ffffffff810147b0:	48 c7 c6 b8 03 02 81 	mov    $0xffffffff810203b8,%rsi
ffffffff810147b7:	eb 28                	jmp    ffffffff810147e1 <_ZN2Sc13ready_enqueueEyb+0x51>
    assert (cpu == Cpu::id);
ffffffff810147b9:	8b 05 45 a8 fe 3e    	mov    0x3efea845(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff810147bf:	39 87 98 00 00 00    	cmp    %eax,0x98(%rdi)
ffffffff810147c5:	74 35                	je     ffffffff810147fc <_ZN2Sc13ready_enqueueEyb+0x6c>
ffffffff810147c7:	49 c7 c0 80 05 02 81 	mov    $0xffffffff81020580,%r8
ffffffff810147ce:	b9 3c 00 00 00       	mov    $0x3c,%ecx
ffffffff810147d3:	48 c7 c2 4e 03 02 81 	mov    $0xffffffff8102034e,%rdx
ffffffff810147da:	48 c7 c6 ca 03 02 81 	mov    $0xffffffff810203ca,%rsi
ffffffff810147e1:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff810147e8:	31 c0                	xor    %eax,%eax
ffffffff810147ea:	e8 61 d7 fe ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff810147ef:	8d 48 01             	lea    0x1(%rax),%ecx
ffffffff810147f2:	f0 0f b1 8f 8c 00 00 	lock cmpxchg %ecx,0x8c(%rdi)
ffffffff810147f9:	00 
ffffffff810147fa:	74 49                	je     ffffffff81014845 <_ZN2Sc13ready_enqueueEyb+0xb5>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff810147fc:	8b 87 8c 00 00 00    	mov    0x8c(%rdi),%eax
ffffffff81014802:	83 f8 ff             	cmp    $0xffffffff,%eax
ffffffff81014805:	75 e8                	jne    ffffffff810147ef <_ZN2Sc13ready_enqueueEyb+0x5f>

    if (!add_ref()) {
        trace (TRACE_ERROR, "SC:%p add_ref failed - %s", this, __func__);
ffffffff81014807:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff8101480c:	8b 35 f2 a7 fe 3e    	mov    0x3efea7f2(%rip),%esi        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81014812:	48 89 fa             	mov    %rdi,%rdx
ffffffff81014815:	48 c7 c1 70 05 02 81 	mov    $0xffffffff81020570,%rcx
ffffffff8101481c:	48 c7 c7 d9 03 02 81 	mov    $0xffffffff810203d9,%rdi
ffffffff81014823:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81014829:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff8101482f:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
ffffffff81014836:	48 0f 45 f0          	cmovne %rax,%rsi
ffffffff8101483a:	31 c0                	xor    %eax,%eax

    if (!left)
        left = budget;

    tsc = t;
}
ffffffff8101483c:	48 83 c4 18          	add    $0x18,%rsp
{
    assert (prio < priorities);
    assert (cpu == Cpu::id);

    if (!add_ref()) {
        trace (TRACE_ERROR, "SC:%p add_ref failed - %s", this, __func__);
ffffffff81014840:	e9 47 d8 fe ff       	jmpq   ffffffff8100208c <_ZN7Console5printEPKcz>
        return;
    }

    if (prio > prio_top)
ffffffff81014845:	8b 87 9c 00 00 00    	mov    0x9c(%rdi),%eax
ffffffff8101484b:	3b 05 6f b0 fe 3e    	cmp    0x3efeb06f(%rip),%eax        # ffffffffbffff8c0 <_ZN2Sc8prio_topE>
ffffffff81014851:	76 06                	jbe    ffffffff81014859 <_ZN2Sc13ready_enqueueEyb+0xc9>
        prio_top = prio;
ffffffff81014853:	89 05 67 b0 fe 3e    	mov    %eax,0x3efeb067(%rip)        # ffffffffbffff8c0 <_ZN2Sc8prio_topE>

    if (!list[prio])
ffffffff81014859:	48 8b 0c c5 00 f9 ff 	mov    -0x40000700(,%rax,8),%rcx
ffffffff81014860:	bf 
ffffffff81014861:	48 85 c9             	test   %rcx,%rcx
ffffffff81014864:	75 10                	jne    ffffffff81014876 <_ZN2Sc13ready_enqueueEyb+0xe6>
        list[prio] = prev = next = this;
ffffffff81014866:	48 89 bf c0 00 00 00 	mov    %rdi,0xc0(%rdi)
ffffffff8101486d:	48 89 bf b8 00 00 00 	mov    %rdi,0xb8(%rdi)
ffffffff81014874:	eb 3f                	jmp    ffffffff810148b5 <_ZN2Sc13ready_enqueueEyb+0x125>
    else {
        next = list[prio];
ffffffff81014876:	48 89 8f c0 00 00 00 	mov    %rcx,0xc0(%rdi)
        prev = list[prio]->prev;
ffffffff8101487d:	48 8b 04 c5 00 f9 ff 	mov    -0x40000700(,%rax,8),%rax
ffffffff81014884:	bf 
        next->prev = prev->next = this;
        if (use_left && left)
ffffffff81014885:	84 d2                	test   %dl,%dl

    if (!list[prio])
        list[prio] = prev = next = this;
    else {
        next = list[prio];
        prev = list[prio]->prev;
ffffffff81014887:	48 8b 80 b8 00 00 00 	mov    0xb8(%rax),%rax
ffffffff8101488e:	48 89 87 b8 00 00 00 	mov    %rax,0xb8(%rdi)
        next->prev = prev->next = this;
ffffffff81014895:	48 89 b8 c0 00 00 00 	mov    %rdi,0xc0(%rax)
ffffffff8101489c:	48 89 b9 b8 00 00 00 	mov    %rdi,0xb8(%rcx)
        if (use_left && left)
ffffffff810148a3:	74 18                	je     ffffffff810148bd <_ZN2Sc13ready_enqueueEyb+0x12d>
ffffffff810148a5:	48 83 bf b0 00 00 00 	cmpq   $0x0,0xb0(%rdi)
ffffffff810148ac:	00 
ffffffff810148ad:	74 0e                	je     ffffffff810148bd <_ZN2Sc13ready_enqueueEyb+0x12d>
            list[prio] = this;
ffffffff810148af:	8b 87 9c 00 00 00    	mov    0x9c(%rdi),%eax
ffffffff810148b5:	48 89 3c c5 00 f9 ff 	mov    %rdi,-0x40000700(,%rax,8)
ffffffff810148bc:	bf 
    }

    trace (TRACE_SCHEDULE, "ENQ:%p (%llu) PRIO:%#x TOP:%#x %s", this, left, prio, prio_top, prio > current->prio ? "reschedule" : "");

    if (prio > current->prio || (this != current && prio == current->prio && (use_left && left)))
ffffffff810148bd:	48 8b 05 54 a7 fe 3e 	mov    0x3efea754(%rip),%rax        # ffffffffbffff018 <_ZN2Sc7currentE>
ffffffff810148c4:	8b 88 9c 00 00 00    	mov    0x9c(%rax),%ecx
ffffffff810148ca:	39 8f 9c 00 00 00    	cmp    %ecx,0x9c(%rdi)
ffffffff810148d0:	77 16                	ja     ffffffff810148e8 <_ZN2Sc13ready_enqueueEyb+0x158>
ffffffff810148d2:	0f 94 c1             	sete   %cl
ffffffff810148d5:	84 d1                	test   %dl,%cl
ffffffff810148d7:	74 16                	je     ffffffff810148ef <_ZN2Sc13ready_enqueueEyb+0x15f>
ffffffff810148d9:	48 39 c7             	cmp    %rax,%rdi
ffffffff810148dc:	74 11                	je     ffffffff810148ef <_ZN2Sc13ready_enqueueEyb+0x15f>
ffffffff810148de:	48 83 bf b0 00 00 00 	cmpq   $0x0,0xb0(%rdi)
ffffffff810148e5:	00 
ffffffff810148e6:	74 07                	je     ffffffff810148ef <_ZN2Sc13ready_enqueueEyb+0x15f>
        Cpu::hazard |= HZD_SCHED;
ffffffff810148e8:	83 0d 11 a7 fe 3e 01 	orl    $0x1,0x3efea711(%rip)        # ffffffffbffff000 <_ZN3Cpu6hazardE>

    if (!left)
ffffffff810148ef:	48 83 bf b0 00 00 00 	cmpq   $0x0,0xb0(%rdi)
ffffffff810148f6:	00 
ffffffff810148f7:	75 0e                	jne    ffffffff81014907 <_ZN2Sc13ready_enqueueEyb+0x177>
        left = budget;
ffffffff810148f9:	48 8b 87 a0 00 00 00 	mov    0xa0(%rdi),%rax
ffffffff81014900:	48 89 87 b0 00 00 00 	mov    %rax,0xb0(%rdi)

    tsc = t;
ffffffff81014907:	48 89 b7 c8 00 00 00 	mov    %rsi,0xc8(%rdi)
}
ffffffff8101490e:	48 83 c4 18          	add    $0x18,%rsp
ffffffff81014912:	c3                   	retq   
ffffffff81014913:	90                   	nop

ffffffff81014914 <_ZN2Sc13ready_dequeueEy>:

void Sc::ready_dequeue (uint64 t)
{
ffffffff81014914:	52                   	push   %rdx
    assert (prio < priorities);
ffffffff81014915:	8b 87 9c 00 00 00    	mov    0x9c(%rdi),%eax
ffffffff8101491b:	83 f8 7f             	cmp    $0x7f,%eax
ffffffff8101491e:	76 1c                	jbe    ffffffff8101493c <_ZN2Sc13ready_dequeueEy+0x28>
ffffffff81014920:	49 c7 c0 50 05 02 81 	mov    $0xffffffff81020550,%r8
ffffffff81014927:	b9 5d 00 00 00       	mov    $0x5d,%ecx
ffffffff8101492c:	48 c7 c2 4e 03 02 81 	mov    $0xffffffff8102034e,%rdx
ffffffff81014933:	48 c7 c6 b8 03 02 81 	mov    $0xffffffff810203b8,%rsi
ffffffff8101493a:	eb 28                	jmp    ffffffff81014964 <_ZN2Sc13ready_dequeueEy+0x50>
    assert (cpu == Cpu::id);
ffffffff8101493c:	8b 0d c2 a6 fe 3e    	mov    0x3efea6c2(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81014942:	39 8f 98 00 00 00    	cmp    %ecx,0x98(%rdi)
ffffffff81014948:	74 28                	je     ffffffff81014972 <_ZN2Sc13ready_dequeueEy+0x5e>
ffffffff8101494a:	49 c7 c0 50 05 02 81 	mov    $0xffffffff81020550,%r8
ffffffff81014951:	b9 5e 00 00 00       	mov    $0x5e,%ecx
ffffffff81014956:	48 c7 c2 4e 03 02 81 	mov    $0xffffffff8102034e,%rdx
ffffffff8101495d:	48 c7 c6 ca 03 02 81 	mov    $0xffffffff810203ca,%rsi
ffffffff81014964:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8101496b:	31 c0                	xor    %eax,%eax
ffffffff8101496d:	e8 de d5 fe ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
    assert (prev && next);
ffffffff81014972:	48 83 bf b8 00 00 00 	cmpq   $0x0,0xb8(%rdi)
ffffffff81014979:	00 
ffffffff8101497a:	74 0a                	je     ffffffff81014986 <_ZN2Sc13ready_dequeueEy+0x72>
ffffffff8101497c:	48 83 bf c0 00 00 00 	cmpq   $0x0,0xc0(%rdi)
ffffffff81014983:	00 
ffffffff81014984:	75 1c                	jne    ffffffff810149a2 <_ZN2Sc13ready_dequeueEy+0x8e>
ffffffff81014986:	49 c7 c0 50 05 02 81 	mov    $0xffffffff81020550,%r8
ffffffff8101498d:	b9 5f 00 00 00       	mov    $0x5f,%ecx
ffffffff81014992:	48 c7 c2 4e 03 02 81 	mov    $0xffffffff8102034e,%rdx
ffffffff81014999:	48 c7 c6 fa 03 02 81 	mov    $0xffffffff810203fa,%rsi
ffffffff810149a0:	eb c2                	jmp    ffffffff81014964 <_ZN2Sc13ready_dequeueEy+0x50>

    if (list[prio] == this)
ffffffff810149a2:	48 39 3c c5 00 f9 ff 	cmp    %rdi,-0x40000700(,%rax,8)
ffffffff810149a9:	bf 
ffffffff810149aa:	75 1b                	jne    ffffffff810149c7 <_ZN2Sc13ready_dequeueEy+0xb3>
        list[prio] = next == this ? nullptr : next;
ffffffff810149ac:	48 8b 97 c0 00 00 00 	mov    0xc0(%rdi),%rdx
ffffffff810149b3:	b9 00 00 00 00       	mov    $0x0,%ecx
ffffffff810149b8:	48 39 fa             	cmp    %rdi,%rdx
ffffffff810149bb:	48 0f 44 d1          	cmove  %rcx,%rdx
ffffffff810149bf:	48 89 14 c5 00 f9 ff 	mov    %rdx,-0x40000700(,%rax,8)
ffffffff810149c6:	bf 

    next->prev = prev;
ffffffff810149c7:	48 8b 87 c0 00 00 00 	mov    0xc0(%rdi),%rax
ffffffff810149ce:	48 8b 97 b8 00 00 00 	mov    0xb8(%rdi),%rdx
ffffffff810149d5:	48 89 90 b8 00 00 00 	mov    %rdx,0xb8(%rax)
    prev->next = next;
ffffffff810149dc:	48 8b 87 b8 00 00 00 	mov    0xb8(%rdi),%rax
ffffffff810149e3:	48 8b 97 c0 00 00 00 	mov    0xc0(%rdi),%rdx
ffffffff810149ea:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
ffffffff810149f1:	8b 05 c9 ae fe 3e    	mov    0x3efeaec9(%rip),%eax        # ffffffffbffff8c0 <_ZN2Sc8prio_topE>
    prev = next = nullptr;
ffffffff810149f7:	48 c7 87 c0 00 00 00 	movq   $0x0,0xc0(%rdi)
ffffffff810149fe:	00 00 00 00 
ffffffff81014a02:	48 c7 87 b8 00 00 00 	movq   $0x0,0xb8(%rdi)
ffffffff81014a09:	00 00 00 00 

    while (!list[prio_top] && prio_top)
ffffffff81014a0d:	89 c1                	mov    %eax,%ecx
ffffffff81014a0f:	8d 50 ff             	lea    -0x1(%rax),%edx
ffffffff81014a12:	48 83 3c cd 00 f9 ff 	cmpq   $0x0,-0x40000700(,%rcx,8)
ffffffff81014a19:	bf 00 
ffffffff81014a1b:	75 08                	jne    ffffffff81014a25 <_ZN2Sc13ready_dequeueEy+0x111>
ffffffff81014a1d:	85 c0                	test   %eax,%eax
ffffffff81014a1f:	74 04                	je     ffffffff81014a25 <_ZN2Sc13ready_dequeueEy+0x111>
ffffffff81014a21:	89 d0                	mov    %edx,%eax
ffffffff81014a23:	eb e8                	jmp    ffffffff81014a0d <_ZN2Sc13ready_dequeueEy+0xf9>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
ffffffff81014a25:	48 8b 97 90 00 00 00 	mov    0x90(%rdi),%rdx
ffffffff81014a2c:	89 05 8e ae fe 3e    	mov    %eax,0x3efeae8e(%rip)        # ffffffffbffff8c0 <_ZN2Sc8prio_topE>
ffffffff81014a32:	48 8b 87 c8 00 00 00 	mov    0xc8(%rdi),%rax
ffffffff81014a39:	48 03 82 88 01 00 00 	add    0x188(%rdx),%rax
        inline void clr_hazard (mword h) { Atomic::clr_mask (hzd, h); }

        ALWAYS_INLINE
        inline void add_tsc_offset (uint64 tsc)
        {
            tsc_offset += tsc;
ffffffff81014a40:	48 29 f0             	sub    %rsi,%rax
ffffffff81014a43:	48 89 82 88 01 00 00 	mov    %rax,0x188(%rdx)
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }
ffffffff81014a4a:	f0 48 81 8a 80 01 00 	lock orq $0x20000000,0x180(%rdx)
ffffffff81014a51:	00 00 00 00 20 

    trace (TRACE_SCHEDULE, "DEQ:%p (%llu) PRIO:%#x TOP:%#x", this, left, prio, prio_top);

    ec->add_tsc_offset (tsc - t);

    tsc = t;
ffffffff81014a56:	48 89 b7 c8 00 00 00 	mov    %rsi,0xc8(%rdi)
}
ffffffff81014a5d:	58                   	pop    %rax
ffffffff81014a5e:	c3                   	retq   
ffffffff81014a5f:	90                   	nop

ffffffff81014a60 <_ZN2Sc14remote_enqueueEv>:
    sc->ready_dequeue (t);
    sc->ec->activate();
}

void Sc::remote_enqueue()
{
ffffffff81014a60:	41 54                	push   %r12
ffffffff81014a62:	55                   	push   %rbp
ffffffff81014a63:	53                   	push   %rbx
ffffffff81014a64:	48 83 ec 10          	sub    $0x10,%rsp
    if (Cpu::id == cpu)
ffffffff81014a68:	8b 87 98 00 00 00    	mov    0x98(%rdi),%eax
ffffffff81014a6e:	39 05 90 a5 fe 3e    	cmp    %eax,0x3efea590(%rip)        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81014a74:	75 2b                	jne    ffffffff81014aa1 <_ZN2Sc14remote_enqueueEv+0x41>

ALWAYS_INLINE
static inline uint64 rdtsc()
{
    mword h, l;
    asm volatile ("rdtsc" : "=a" (l), "=d" (h));
ffffffff81014a76:	0f 31                	rdtsc  
        } else {
            r->queue = prev = next = this;
            Lapic::send_ipi (cpu, VEC_IPI_RRQ);
        }
    }
}
ffffffff81014a78:	48 83 c4 10          	add    $0x10,%rsp
    return static_cast<uint64>(h) << 32 | l;
ffffffff81014a7c:	48 89 d6             	mov    %rdx,%rsi
}

void Sc::remote_enqueue()
{
    if (Cpu::id == cpu)
        ready_enqueue (rdtsc());
ffffffff81014a7f:	ba 01 00 00 00       	mov    $0x1,%edx
        } else {
            r->queue = prev = next = this;
            Lapic::send_ipi (cpu, VEC_IPI_RRQ);
        }
    }
}
ffffffff81014a84:	5b                   	pop    %rbx
ffffffff81014a85:	5d                   	pop    %rbp
ffffffff81014a86:	41 5c                	pop    %r12
ffffffff81014a88:	48 c1 e6 20          	shl    $0x20,%rsi
ffffffff81014a8c:	48 09 c6             	or     %rax,%rsi
}

void Sc::remote_enqueue()
{
    if (Cpu::id == cpu)
        ready_enqueue (rdtsc());
ffffffff81014a8f:	e9 fc fc ff ff       	jmpq   ffffffff81014790 <_ZN2Sc13ready_enqueueEyb>

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff81014a94:	8d 50 01             	lea    0x1(%rax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff81014a97:	f0 0f b1 97 8c 00 00 	lock cmpxchg %edx,0x8c(%rdi)
ffffffff81014a9e:	00 
ffffffff81014a9f:	74 4d                	je     ffffffff81014aee <_ZN2Sc14remote_enqueueEv+0x8e>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff81014aa1:	8b 87 8c 00 00 00    	mov    0x8c(%rdi),%eax
ffffffff81014aa7:	83 f8 ff             	cmp    $0xffffffff,%eax
ffffffff81014aaa:	75 e8                	jne    ffffffff81014a94 <_ZN2Sc14remote_enqueueEv+0x34>

    else {
        if (!add_ref()) {
            trace (TRACE_ERROR, "SC:%p add_ref failed - %s", this, __func__);
ffffffff81014aac:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff81014ab1:	8b 35 4d a5 fe 3e    	mov    0x3efea54d(%rip),%esi        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81014ab7:	48 89 fa             	mov    %rdi,%rdx
ffffffff81014aba:	48 c7 c1 08 05 02 81 	mov    $0xffffffff81020508,%rcx
ffffffff81014ac1:	48 c7 c7 d9 03 02 81 	mov    $0xffffffff810203d9,%rdi
ffffffff81014ac8:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81014ace:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff81014ad4:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
ffffffff81014adb:	48 0f 45 f0          	cmovne %rax,%rsi
        } else {
            r->queue = prev = next = this;
            Lapic::send_ipi (cpu, VEC_IPI_RRQ);
        }
    }
}
ffffffff81014adf:	48 83 c4 10          	add    $0x10,%rsp
    if (Cpu::id == cpu)
        ready_enqueue (rdtsc());

    else {
        if (!add_ref()) {
            trace (TRACE_ERROR, "SC:%p add_ref failed - %s", this, __func__);
ffffffff81014ae3:	31 c0                	xor    %eax,%eax
        } else {
            r->queue = prev = next = this;
            Lapic::send_ipi (cpu, VEC_IPI_RRQ);
        }
    }
}
ffffffff81014ae5:	5b                   	pop    %rbx
ffffffff81014ae6:	5d                   	pop    %rbp
ffffffff81014ae7:	41 5c                	pop    %r12
    if (Cpu::id == cpu)
        ready_enqueue (rdtsc());

    else {
        if (!add_ref()) {
            trace (TRACE_ERROR, "SC:%p add_ref failed - %s", this, __func__);
ffffffff81014ae9:	e9 9e d5 fe ff       	jmpq   ffffffff8100208c <_ZN7Console5printEPKcz>
            return;
        }

        Sc::Rq *r = remote (cpu);
ffffffff81014aee:	8b af 98 00 00 00    	mov    0x98(%rdi),%ebp
        Sc (Pd *, Ec *, unsigned, Sc *);

        ALWAYS_INLINE
        static inline Rq *remote (unsigned long c)
        {
            return reinterpret_cast<typeof rq *>(reinterpret_cast<mword>(&rq) - CPU_LOCAL_DATA + HV_GLOBAL_CPUS + c * PAGE_SIZE);
ffffffff81014af4:	48 b8 10 0d e0 be ff 	movabs $0xffffffffbee00d10,%rax
ffffffff81014afb:	ff ff ff 
ffffffff81014afe:	48 89 fb             	mov    %rdi,%rbx
ffffffff81014b01:	48 c1 e5 0c          	shl    $0xc,%rbp
ffffffff81014b05:	48 01 c5             	add    %rax,%rbp

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81014b08:	9c                   	pushfq 
ffffffff81014b09:	58                   	pop    %rax
            return flags & 0x200;
ffffffff81014b0a:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff81014b0e:	41 88 c4             	mov    %al,%r12b
ffffffff81014b11:	41 80 e4 01          	and    $0x1,%r12b
ffffffff81014b15:	74 30                	je     ffffffff81014b47 <_ZN2Sc14remote_enqueueEv+0xe7>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81014b17:	80 3d 12 ac fe 3e 00 	cmpb   $0x0,0x3efeac12(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81014b1e:	75 1f                	jne    ffffffff81014b3f <_ZN2Sc14remote_enqueueEv+0xdf>
ffffffff81014b20:	49 c7 c0 e0 04 02 81 	mov    $0xffffffff810204e0,%r8
ffffffff81014b27:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff81014b2c:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81014b33:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff81014b3a:	e9 93 00 00 00       	jmpq   ffffffff81014bd2 <_ZN2Sc14remote_enqueueEv+0x172>

            asm volatile ("cli" : : : "memory");
ffffffff81014b3f:	fa                   	cli    
            preemption = false;
ffffffff81014b40:	c6 05 e9 ab fe 3e 00 	movb   $0x0,0x3efeabe9(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff81014b47:	48 89 ef             	mov    %rbp,%rdi
ffffffff81014b4a:	e8 3f c3 fe ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>

        Lock_guard <Spinlock> guard (r->lock);

        if (r->queue) {
ffffffff81014b4f:	48 8b 45 08          	mov    0x8(%rbp),%rax
ffffffff81014b53:	48 85 c0             	test   %rax,%rax
ffffffff81014b56:	74 29                	je     ffffffff81014b81 <_ZN2Sc14remote_enqueueEv+0x121>
            next = r->queue;
ffffffff81014b58:	48 89 83 c0 00 00 00 	mov    %rax,0xc0(%rbx)
            prev = r->queue->prev;
ffffffff81014b5f:	48 8b 55 08          	mov    0x8(%rbp),%rdx
ffffffff81014b63:	48 8b 92 b8 00 00 00 	mov    0xb8(%rdx),%rdx
ffffffff81014b6a:	48 89 93 b8 00 00 00 	mov    %rdx,0xb8(%rbx)
            next->prev = prev->next = this;
ffffffff81014b71:	48 89 9a c0 00 00 00 	mov    %rbx,0xc0(%rdx)
ffffffff81014b78:	48 89 98 b8 00 00 00 	mov    %rbx,0xb8(%rax)
ffffffff81014b7f:	eb 26                	jmp    ffffffff81014ba7 <_ZN2Sc14remote_enqueueEv+0x147>
        } else {
            r->queue = prev = next = this;
ffffffff81014b81:	48 89 9b c0 00 00 00 	mov    %rbx,0xc0(%rbx)
ffffffff81014b88:	48 89 9b b8 00 00 00 	mov    %rbx,0xb8(%rbx)
            Lapic::send_ipi (cpu, VEC_IPI_RRQ);
ffffffff81014b8f:	31 c9                	xor    %ecx,%ecx
        if (r->queue) {
            next = r->queue;
            prev = r->queue->prev;
            next->prev = prev->next = this;
        } else {
            r->queue = prev = next = this;
ffffffff81014b91:	48 89 5d 08          	mov    %rbx,0x8(%rbp)
            Lapic::send_ipi (cpu, VEC_IPI_RRQ);
ffffffff81014b95:	8b bb 98 00 00 00    	mov    0x98(%rbx),%edi
ffffffff81014b9b:	31 d2                	xor    %edx,%edx
ffffffff81014b9d:	be a7 00 00 00       	mov    $0xa7,%esi
ffffffff81014ba2:	e8 87 38 ff ff       	callq  ffffffff8100842e <_ZN5Lapic8send_ipiEjjNS_13Delivery_modeENS_9ShorthandE>
        }

        ALWAYS_INLINE
        inline void unlock()
        {
            asm volatile ("incb %0" : "=m" (val) : : "memory");
ffffffff81014ba7:	fe 45 00             	incb   0x0(%rbp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81014baa:	45 84 e4             	test   %r12b,%r12b
ffffffff81014bad:	74 39                	je     ffffffff81014be8 <_ZN2Sc14remote_enqueueEv+0x188>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81014baf:	80 3d 7a ab fe 3e 00 	cmpb   $0x0,0x3efeab7a(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81014bb6:	74 28                	je     ffffffff81014be0 <_ZN2Sc14remote_enqueueEv+0x180>
ffffffff81014bb8:	49 c7 c0 b0 04 02 81 	mov    $0xffffffff810204b0,%r8
ffffffff81014bbf:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff81014bc4:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81014bcb:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff81014bd2:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81014bd9:	31 c0                	xor    %eax,%eax
ffffffff81014bdb:	e8 70 d3 fe ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            preemption = true;
ffffffff81014be0:	c6 05 49 ab fe 3e 01 	movb   $0x1,0x3efeab49(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81014be7:	fb                   	sti    
        }
    }
}
ffffffff81014be8:	48 83 c4 10          	add    $0x10,%rsp
ffffffff81014bec:	5b                   	pop    %rbx
ffffffff81014bed:	5d                   	pop    %rbp
ffffffff81014bee:	41 5c                	pop    %r12
ffffffff81014bf0:	c3                   	retq   
ffffffff81014bf1:	90                   	nop

ffffffff81014bf2 <_ZN2Sc11rrq_handlerEv>:

void Sc::rrq_handler()
{
ffffffff81014bf2:	41 55                	push   %r13
ffffffff81014bf4:	41 54                	push   %r12
ffffffff81014bf6:	55                   	push   %rbp
ffffffff81014bf7:	53                   	push   %rbx
ffffffff81014bf8:	52                   	push   %rdx

ALWAYS_INLINE
static inline uint64 rdtsc()
{
    mword h, l;
    asm volatile ("rdtsc" : "=a" (l), "=d" (h));
ffffffff81014bf9:	0f 31                	rdtsc  
    return static_cast<uint64>(h) << 32 | l;
ffffffff81014bfb:	48 c1 e2 20          	shl    $0x20,%rdx
ffffffff81014bff:	48 09 c2             	or     %rax,%rdx
ffffffff81014c02:	49 89 d4             	mov    %rdx,%r12

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81014c05:	9c                   	pushfq 
ffffffff81014c06:	59                   	pop    %rcx
            return flags & 0x200;
ffffffff81014c07:	48 c1 e9 09          	shr    $0x9,%rcx

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff81014c0b:	40 88 cd             	mov    %cl,%bpl
ffffffff81014c0e:	40 80 e5 01          	and    $0x1,%bpl
ffffffff81014c12:	74 30                	je     ffffffff81014c44 <_ZN2Sc11rrq_handlerEv+0x52>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81014c14:	80 3d 15 ab fe 3e 00 	cmpb   $0x0,0x3efeab15(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81014c1b:	75 1f                	jne    ffffffff81014c3c <_ZN2Sc11rrq_handlerEv+0x4a>
ffffffff81014c1d:	49 c7 c0 e0 04 02 81 	mov    $0xffffffff810204e0,%r8
ffffffff81014c24:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff81014c29:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81014c30:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff81014c37:	e9 ad 00 00 00       	jmpq   ffffffff81014ce9 <_ZN2Sc11rrq_handlerEv+0xf7>

            asm volatile ("cli" : : : "memory");
ffffffff81014c3c:	fa                   	cli    
            preemption = false;
ffffffff81014c3d:	c6 05 ec aa fe 3e 00 	movb   $0x0,0x3efeaaec(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff81014c44:	48 c7 c7 10 fd ff bf 	mov    $0xffffffffbffffd10,%rdi
        ptr->next->prev = ptr->prev;
        ptr->prev->next = ptr->next;

        Sc *sc = ptr;

        ptr = ptr->next == ptr ? nullptr : ptr->next;
ffffffff81014c4b:	45 31 ed             	xor    %r13d,%r13d
ffffffff81014c4e:	e8 3b c2 fe ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
{
    uint64 t = rdtsc();

    Lock_guard <Spinlock> guard (rq.lock);

    for (Sc *ptr = rq.queue; ptr; ) {
ffffffff81014c53:	48 8b 3d be b0 fe 3e 	mov    0x3efeb0be(%rip),%rdi        # ffffffffbffffd18 <_ZN2Sc2rqE+0x8>
ffffffff81014c5a:	48 85 ff             	test   %rdi,%rdi
ffffffff81014c5d:	74 51                	je     ffffffff81014cb0 <_ZN2Sc11rrq_handlerEv+0xbe>

        ptr->next->prev = ptr->prev;
ffffffff81014c5f:	48 8b 87 c0 00 00 00 	mov    0xc0(%rdi),%rax
ffffffff81014c66:	48 8b 97 b8 00 00 00 	mov    0xb8(%rdi),%rdx
ffffffff81014c6d:	48 89 90 b8 00 00 00 	mov    %rdx,0xb8(%rax)
        ptr->prev->next = ptr->next;
ffffffff81014c74:	48 8b 87 b8 00 00 00 	mov    0xb8(%rdi),%rax
ffffffff81014c7b:	48 8b 97 c0 00 00 00 	mov    0xc0(%rdi),%rdx
ffffffff81014c82:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)

        Sc *sc = ptr;

        ptr = ptr->next == ptr ? nullptr : ptr->next;
ffffffff81014c89:	48 8b 9f c0 00 00 00 	mov    0xc0(%rdi),%rbx
ffffffff81014c90:	48 39 fb             	cmp    %rdi,%rbx
ffffffff81014c93:	49 0f 44 dd          	cmove  %r13,%rbx
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff81014c97:	f0 ff 8f 8c 00 00 00 	lock decl 0x8c(%rdi)

        sc->del_ref();
        sc->ready_enqueue (t);
ffffffff81014c9e:	ba 01 00 00 00       	mov    $0x1,%edx
ffffffff81014ca3:	4c 89 e6             	mov    %r12,%rsi
ffffffff81014ca6:	e8 e5 fa ff ff       	callq  ffffffff81014790 <_ZN2Sc13ready_enqueueEyb>
        ptr->next->prev = ptr->prev;
        ptr->prev->next = ptr->next;

        Sc *sc = ptr;

        ptr = ptr->next == ptr ? nullptr : ptr->next;
ffffffff81014cab:	48 89 df             	mov    %rbx,%rdi
ffffffff81014cae:	eb aa                	jmp    ffffffff81014c5a <_ZN2Sc11rrq_handlerEv+0x68>

        sc->del_ref();
        sc->ready_enqueue (t);
    }

    rq.queue = nullptr;
ffffffff81014cb0:	48 c7 05 5d b0 fe 3e 	movq   $0x0,0x3efeb05d(%rip)        # ffffffffbffffd18 <_ZN2Sc2rqE+0x8>
ffffffff81014cb7:	00 00 00 00 
ffffffff81014cbb:	fe 05 4f b0 fe 3e    	incb   0x3efeb04f(%rip)        # ffffffffbffffd10 <_ZN2Sc2rqE>
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81014cc1:	40 84 ed             	test   %bpl,%bpl
ffffffff81014cc4:	74 39                	je     ffffffff81014cff <_ZN2Sc11rrq_handlerEv+0x10d>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81014cc6:	80 3d 63 aa fe 3e 00 	cmpb   $0x0,0x3efeaa63(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81014ccd:	74 28                	je     ffffffff81014cf7 <_ZN2Sc11rrq_handlerEv+0x105>
ffffffff81014ccf:	49 c7 c0 b0 04 02 81 	mov    $0xffffffff810204b0,%r8
ffffffff81014cd6:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff81014cdb:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81014ce2:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff81014ce9:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81014cf0:	31 c0                	xor    %eax,%eax
ffffffff81014cf2:	e8 59 d2 fe ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            preemption = true;
ffffffff81014cf7:	c6 05 32 aa fe 3e 01 	movb   $0x1,0x3efeaa32(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81014cfe:	fb                   	sti    
}
ffffffff81014cff:	58                   	pop    %rax
ffffffff81014d00:	5b                   	pop    %rbx
ffffffff81014d01:	5d                   	pop    %rbp
ffffffff81014d02:	41 5c                	pop    %r12
ffffffff81014d04:	41 5d                	pop    %r13
ffffffff81014d06:	c3                   	retq   
ffffffff81014d07:	90                   	nop

ffffffff81014d08 <_ZN2Sc11rke_handlerEv>:

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
ffffffff81014d08:	48 8b 15 01 a3 fe 3e 	mov    0x3efea301(%rip),%rdx        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81014d0f:	8b 05 ef a2 fe 3e    	mov    0x3efea2ef(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81014d15:	48 8b 92 c8 02 00 00 	mov    0x2c8(%rdx),%rdx

void Sc::rke_handler()
{
    if (Pd::current->Space_mem::htlb.chk (Cpu::id))
ffffffff81014d1c:	48 0f a3 c2          	bt     %rax,%rdx
ffffffff81014d20:	73 07                	jae    ffffffff81014d29 <_ZN2Sc11rke_handlerEv+0x21>
        Cpu::hazard |= HZD_SCHED;
ffffffff81014d22:	83 0d d7 a2 fe 3e 01 	orl    $0x1,0x3efea2d7(%rip)        # ffffffffbffff000 <_ZN3Cpu6hazardE>
ffffffff81014d29:	c3                   	retq   

ffffffff81014d2a <_ZN2ScdlEPv>:
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
ffffffff81014d2a:	48 8b 87 90 00 00 00 	mov    0x90(%rdi),%rax
}

void Sc::operator delete (void *ptr) { cache.free (ptr, static_cast<Sc *>(ptr)->ec->pd->quota); }
ffffffff81014d31:	48 89 fe             	mov    %rdi,%rsi
ffffffff81014d34:	48 c7 c7 40 40 16 81 	mov    $0xffffffff81164040,%rdi
ffffffff81014d3b:	48 8b 90 98 02 00 00 	mov    0x298(%rax),%rdx
ffffffff81014d42:	48 81 c2 08 03 00 00 	add    $0x308,%rdx
ffffffff81014d49:	e9 1c 0d 00 00       	jmpq   ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>

ffffffff81014d4e <_ZN2Sc4freeEP8Rcu_elem>:

        void ready_enqueue (uint64, bool use_left = true);
        void ready_dequeue (uint64);

        static void free (Rcu_elem * a) {
            Sc * s = static_cast<Sc *>(a);
ffffffff81014d4e:	48 8d 47 e8          	lea    -0x18(%rdi),%rax
        static unsigned prio_top CPULOCAL;

        void ready_enqueue (uint64, bool use_left = true);
        void ready_dequeue (uint64);

        static void free (Rcu_elem * a) {
ffffffff81014d52:	53                   	push   %rbx
            Sc * s = static_cast<Sc *>(a);
ffffffff81014d53:	31 db                	xor    %ebx,%ebx
ffffffff81014d55:	48 85 ff             	test   %rdi,%rdi
ffffffff81014d58:	48 0f 45 d8          	cmovne %rax,%rbx
ffffffff81014d5c:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff81014d5f:	f0 0f c1 83 8c 00 00 	lock xadd %eax,0x8c(%rbx)
ffffffff81014d66:	00 
              
            if (s->del_ref()) {
ffffffff81014d67:	ff c8                	dec    %eax
ffffffff81014d69:	75 47                	jne    ffffffff81014db2 <_ZN2Sc4freeEP8Rcu_elem+0x64>
                assert(Sc::current != s);
ffffffff81014d6b:	48 39 1d a6 a2 fe 3e 	cmp    %rbx,0x3efea2a6(%rip)        # ffffffffbffff018 <_ZN2Sc7currentE>
ffffffff81014d72:	75 28                	jne    ffffffff81014d9c <_ZN2Sc4freeEP8Rcu_elem+0x4e>
ffffffff81014d74:	49 c7 c0 b0 05 02 81 	mov    $0xffffffff810205b0,%r8
ffffffff81014d7b:	b9 41 00 00 00       	mov    $0x41,%ecx
ffffffff81014d80:	48 c7 c2 07 04 02 81 	mov    $0xffffffff81020407,%rdx
ffffffff81014d87:	48 c7 c6 75 04 02 81 	mov    $0xffffffff81020475,%rsi
ffffffff81014d8e:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81014d95:	31 c0                	xor    %eax,%eax
ffffffff81014d97:	e8 b4 d1 fe ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
                delete s;
ffffffff81014d9c:	48 85 db             	test   %rbx,%rbx
ffffffff81014d9f:	74 11                	je     ffffffff81014db2 <_ZN2Sc4freeEP8Rcu_elem+0x64>
ffffffff81014da1:	48 89 df             	mov    %rbx,%rdi
ffffffff81014da4:	e8 b7 3d ff ff       	callq  ffffffff81008b60 <_ZN2ScD1Ev>
ffffffff81014da9:	48 89 df             	mov    %rbx,%rdi
            }
        }
ffffffff81014dac:	5b                   	pop    %rbx
        static void free (Rcu_elem * a) {
            Sc * s = static_cast<Sc *>(a);
              
            if (s->del_ref()) {
                assert(Sc::current != s);
                delete s;
ffffffff81014dad:	e9 78 ff ff ff       	jmpq   ffffffff81014d2a <_ZN2ScdlEPv>
            }
        }
ffffffff81014db2:	5b                   	pop    %rbx
ffffffff81014db3:	c3                   	retq   

ffffffff81014db4 <_ZN2Sc8scheduleEbb>:

    tsc = t;
}

void Sc::schedule (bool suspend, bool use_left)
{
ffffffff81014db4:	41 55                	push   %r13
ffffffff81014db6:	41 54                	push   %r12
ffffffff81014db8:	41 89 fc             	mov    %edi,%r12d
ffffffff81014dbb:	55                   	push   %rbp
ffffffff81014dbc:	53                   	push   %rbx
ffffffff81014dbd:	89 f5                	mov    %esi,%ebp
ffffffff81014dbf:	50                   	push   %rax
    Counter::print<1,16> (++Counter::schedule, Console_vga::COLOR_LIGHT_CYAN, SPN_SCH);
ffffffff81014dc0:	8b 05 86 a2 fe 3e    	mov    0x3efea286(%rip),%eax        # ffffffffbffff04c <_ZN7Counter8scheduleE>
ffffffff81014dc6:	8d 48 01             	lea    0x1(%rax),%ecx
        }

        template <unsigned D, unsigned B>
        static void print (mword val, Console_vga::Color c, unsigned col)
        {
            if (EXPECT_FALSE (Cpu::row))
ffffffff81014dc9:	8b 05 c1 a9 fe 3e    	mov    0x3efea9c1(%rip),%eax        # ffffffffbffff790 <_ZN3Cpu3rowE>
ffffffff81014dcf:	89 0d 77 a2 fe 3e    	mov    %ecx,0x3efea277(%rip)        # ffffffffbffff04c <_ZN7Counter8scheduleE>
ffffffff81014dd5:	85 c0                	test   %eax,%eax
ffffffff81014dd7:	0f 85 7d 01 00 00    	jne    ffffffff81014f5a <_ZN2Sc8scheduleEbb+0x1a6>

    assert (current);
ffffffff81014ddd:	48 8b 05 34 a2 fe 3e 	mov    0x3efea234(%rip),%rax        # ffffffffbffff018 <_ZN2Sc7currentE>
ffffffff81014de4:	48 85 c0             	test   %rax,%rax
ffffffff81014de7:	75 23                	jne    ffffffff81014e0c <_ZN2Sc8scheduleEbb+0x58>
ffffffff81014de9:	49 c7 c0 20 05 02 81 	mov    $0xffffffff81020520,%r8
ffffffff81014df0:	b9 76 00 00 00       	mov    $0x76,%ecx
ffffffff81014df5:	48 c7 c2 4e 03 02 81 	mov    $0xffffffff8102034e,%rdx
ffffffff81014dfc:	48 c7 c6 0c df 01 81 	mov    $0xffffffff8101df0c,%rsi
ffffffff81014e03:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81014e0a:	eb 32                	jmp    ffffffff81014e3e <_ZN2Sc8scheduleEbb+0x8a>
    assert (suspend || !current->prev);
ffffffff81014e0c:	45 84 e4             	test   %r12b,%r12b
ffffffff81014e0f:	75 32                	jne    ffffffff81014e43 <_ZN2Sc8scheduleEbb+0x8f>
ffffffff81014e11:	48 83 b8 b8 00 00 00 	cmpq   $0x0,0xb8(%rax)
ffffffff81014e18:	00 
ffffffff81014e19:	74 28                	je     ffffffff81014e43 <_ZN2Sc8scheduleEbb+0x8f>
ffffffff81014e1b:	49 c7 c0 20 05 02 81 	mov    $0xffffffff81020520,%r8
ffffffff81014e22:	b9 77 00 00 00       	mov    $0x77,%ecx
ffffffff81014e27:	48 c7 c2 4e 03 02 81 	mov    $0xffffffff8102034e,%rdx
ffffffff81014e2e:	48 c7 c6 89 04 02 81 	mov    $0xffffffff81020489,%rsi
    else
    if (EXPECT_TRUE (!suspend))
        current->ready_enqueue (t, use_left);

    Sc *sc = list[prio_top];
    assert (sc);
ffffffff81014e35:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81014e3c:	31 c0                	xor    %eax,%eax
ffffffff81014e3e:	e8 0d d1 fe ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

ALWAYS_INLINE
static inline uint64 rdtsc()
{
    mword h, l;
    asm volatile ("rdtsc" : "=a" (l), "=d" (h));
ffffffff81014e43:	0f 31                	rdtsc  
    return static_cast<uint64>(h) << 32 | l;
ffffffff81014e45:	48 c1 e2 20          	shl    $0x20,%rdx

    assert (current);
    assert (suspend || !current->prev);

    uint64 t = rdtsc();
    uint64 d = Timeout_budget::budget.dequeue();
ffffffff81014e49:	48 c7 c7 40 fd ff bf 	mov    $0xffffffffbffffd40,%rdi
ffffffff81014e50:	48 89 d3             	mov    %rdx,%rbx
ffffffff81014e53:	48 09 c3             	or     %rax,%rbx
ffffffff81014e56:	e8 a5 5b 00 00       	callq  ffffffff8101aa00 <_ZN7Timeout7dequeueEv>

    current->time += t - current->tsc;
ffffffff81014e5b:	48 8b 0d b6 a1 fe 3e 	mov    0x3efea1b6(%rip),%rcx        # ffffffffbffff018 <_ZN2Sc7currentE>
ffffffff81014e62:	48 89 da             	mov    %rbx,%rdx
ffffffff81014e65:	48 03 91 a8 00 00 00 	add    0xa8(%rcx),%rdx
ffffffff81014e6c:	48 2b 91 c8 00 00 00 	sub    0xc8(%rcx),%rdx
ffffffff81014e73:	48 89 91 a8 00 00 00 	mov    %rdx,0xa8(%rcx)
    current->left = d > t ? d - t : 0;
ffffffff81014e7a:	48 89 c2             	mov    %rax,%rdx
ffffffff81014e7d:	48 29 da             	sub    %rbx,%rdx
ffffffff81014e80:	48 39 d8             	cmp    %rbx,%rax
ffffffff81014e83:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff81014e88:	48 0f 47 c2          	cmova  %rdx,%rax

    Cpu::hazard &= ~HZD_SCHED;
ffffffff81014e8c:	83 25 6d a1 fe 3e fe 	andl   $0xfffffffe,0x3efea16d(%rip)        # ffffffffbffff000 <_ZN3Cpu6hazardE>

    uint64 t = rdtsc();
    uint64 d = Timeout_budget::budget.dequeue();

    current->time += t - current->tsc;
    current->left = d > t ? d - t : 0;
ffffffff81014e93:	48 89 81 b0 00 00 00 	mov    %rax,0xb0(%rcx)
ffffffff81014e9a:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff81014e9d:	f0 0f c1 81 8c 00 00 	lock xadd %eax,0x8c(%rcx)
ffffffff81014ea4:	00 

    Cpu::hazard &= ~HZD_SCHED;

    if (EXPECT_FALSE(current->del_ref()) && (Ec::current == current->ec))
ffffffff81014ea5:	ff c8                	dec    %eax
ffffffff81014ea7:	75 29                	jne    ffffffff81014ed2 <_ZN2Sc8scheduleEbb+0x11e>
ffffffff81014ea9:	4c 8b 2d 68 a1 fe 3e 	mov    0x3efea168(%rip),%r13        # ffffffffbffff018 <_ZN2Sc7currentE>
ffffffff81014eb0:	49 8b 85 90 00 00 00 	mov    0x90(%r13),%rax
ffffffff81014eb7:	48 39 05 4a a1 fe 3e 	cmp    %rax,0x3efea14a(%rip)        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81014ebe:	75 12                	jne    ffffffff81014ed2 <_ZN2Sc8scheduleEbb+0x11e>
        delete current;
ffffffff81014ec0:	4c 89 ef             	mov    %r13,%rdi
ffffffff81014ec3:	e8 98 3c ff ff       	callq  ffffffff81008b60 <_ZN2ScD1Ev>
ffffffff81014ec8:	4c 89 ef             	mov    %r13,%rdi
ffffffff81014ecb:	e8 5a fe ff ff       	callq  ffffffff81014d2a <_ZN2ScdlEPv>
ffffffff81014ed0:	eb 18                	jmp    ffffffff81014eea <_ZN2Sc8scheduleEbb+0x136>
    else
    if (EXPECT_TRUE (!suspend))
ffffffff81014ed2:	45 84 e4             	test   %r12b,%r12b
ffffffff81014ed5:	75 13                	jne    ffffffff81014eea <_ZN2Sc8scheduleEbb+0x136>
        current->ready_enqueue (t, use_left);
ffffffff81014ed7:	48 8b 3d 3a a1 fe 3e 	mov    0x3efea13a(%rip),%rdi        # ffffffffbffff018 <_ZN2Sc7currentE>
ffffffff81014ede:	40 0f b6 d5          	movzbl %bpl,%edx
ffffffff81014ee2:	48 89 de             	mov    %rbx,%rsi
ffffffff81014ee5:	e8 a6 f8 ff ff       	callq  ffffffff81014790 <_ZN2Sc13ready_enqueueEyb>

    Sc *sc = list[prio_top];
ffffffff81014eea:	8b 05 d0 a9 fe 3e    	mov    0x3efea9d0(%rip),%eax        # ffffffffbffff8c0 <_ZN2Sc8prio_topE>
ffffffff81014ef0:	48 8b 2c c5 00 f9 ff 	mov    -0x40000700(,%rax,8),%rbp
ffffffff81014ef7:	bf 
    assert (sc);
ffffffff81014ef8:	48 85 ed             	test   %rbp,%rbp
ffffffff81014efb:	75 1f                	jne    ffffffff81014f1c <_ZN2Sc8scheduleEbb+0x168>
ffffffff81014efd:	49 c7 c0 20 05 02 81 	mov    $0xffffffff81020520,%r8
ffffffff81014f04:	b9 88 00 00 00       	mov    $0x88,%ecx
ffffffff81014f09:	48 c7 c2 4e 03 02 81 	mov    $0xffffffff8102034e,%rdx
ffffffff81014f10:	48 c7 c6 86 04 02 81 	mov    $0xffffffff81020486,%rsi
ffffffff81014f17:	e9 19 ff ff ff       	jmpq   ffffffff81014e35 <_ZN2Sc8scheduleEbb+0x81>

    Timeout_budget::budget.enqueue (t + sc->left);
ffffffff81014f1c:	48 89 de             	mov    %rbx,%rsi
ffffffff81014f1f:	48 03 b5 b0 00 00 00 	add    0xb0(%rbp),%rsi
ffffffff81014f26:	48 c7 c7 40 fd ff bf 	mov    $0xffffffffbffffd40,%rdi
ffffffff81014f2d:	e8 24 5a 00 00       	callq  ffffffff8101a956 <_ZN7Timeout7enqueueEy>

    ctr_loop = 0;

    current = sc;
    sc->ready_dequeue (t);
ffffffff81014f32:	48 89 ef             	mov    %rbp,%rdi
ffffffff81014f35:	48 89 de             	mov    %rbx,%rsi
    Sc *sc = list[prio_top];
    assert (sc);

    Timeout_budget::budget.enqueue (t + sc->left);

    ctr_loop = 0;
ffffffff81014f38:	c7 05 be ad fe 3e 00 	movl   $0x0,0x3efeadbe(%rip)        # ffffffffbffffd00 <_ZN2Sc8ctr_loopE>
ffffffff81014f3f:	00 00 00 

    current = sc;
ffffffff81014f42:	48 89 2d cf a0 fe 3e 	mov    %rbp,0x3efea0cf(%rip)        # ffffffffbffff018 <_ZN2Sc7currentE>
    sc->ready_dequeue (t);
ffffffff81014f49:	e8 c6 f9 ff ff       	callq  ffffffff81014914 <_ZN2Sc13ready_dequeueEy>
    sc->ec->activate();
ffffffff81014f4e:	48 8b bd 90 00 00 00 	mov    0x90(%rbp),%rdi
ffffffff81014f55:	e8 1c 25 00 00       	callq  ffffffff81017476 <_ZN2Ec8activateEv>
                for (unsigned i = 0; i < D; i++, val /= B)
                    Console_vga::con.put (Cpu::row, col - i, c, !i || val ? (val % B)["0123456789ABCDEF"] : ' ');
ffffffff81014f5a:	83 e1 0f             	and    $0xf,%ecx
ffffffff81014f5d:	66 0f be 91 d8 d7 01 	movsbw -0x7efe2828(%rcx),%dx
ffffffff81014f64:	81 
ffffffff81014f65:	48 69 c0 a0 00 00 00 	imul   $0xa0,%rax,%rax
ffffffff81014f6c:	80 ce 0b             	or     $0xb,%dh
ffffffff81014f6f:	66 89 90 00 f0 df bf 	mov    %dx,-0x40201000(%rax)
ffffffff81014f76:	e9 62 fe ff ff       	jmpq   ffffffff81014ddd <_ZN2Sc8scheduleEbb+0x29>

ffffffff81014f7b <_GLOBAL__sub_I.00102__ZN2Sc5cacheE>:
#include "stdio.hpp"
#include "timeout_budget.hpp"
#include "vectors.hpp"

INIT_PRIORITY (PRIO_SLAB)
Slab_cache Sc::cache (sizeof (Sc), 32);
ffffffff81014f7b:	ba 20 00 00 00       	mov    $0x20,%edx
ffffffff81014f80:	be d0 00 00 00       	mov    $0xd0,%esi
ffffffff81014f85:	48 c7 c7 40 40 16 81 	mov    $0xffffffff81164040,%rdi
ffffffff81014f8c:	e9 0f 09 00 00       	jmpq   ffffffff810158a0 <_ZN10Slab_cacheC1Emj>

ffffffff81014f91 <_GLOBAL__sub_I.65534__ZN2Sc5cacheE>:
    private:
        uint16 val;

    public:
        ALWAYS_INLINE
        inline Spinlock() : val (0) {}
ffffffff81014f91:	66 c7 05 76 ad fe 3e 	movw   $0x0,0x3efead76(%rip)        # ffffffffbffffd10 <_ZN2Sc2rqE>
ffffffff81014f98:	00 00 
ffffffff81014f9a:	c3                   	retq   
ffffffff81014f9b:	90                   	nop

ffffffff81014f9c <_ZN2SiC1EP2Smm>:

Si::Si (Sm * s, mword v) : sm(s), prev(nullptr), next(nullptr), value(v)
{
    trace (TRACE_SYSCALL, "SI:%p created (SM:%p signal:%#lx)", this, s, v);

    if (sm)
ffffffff81014f9c:	48 85 f6             	test   %rsi,%rsi

#include "stdio.hpp"

static Spinlock lock;

Si::Si (Sm * s, mword v) : sm(s), prev(nullptr), next(nullptr), value(v)
ffffffff81014f9f:	48 89 37             	mov    %rsi,(%rdi)
ffffffff81014fa2:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
ffffffff81014fa9:	00 
ffffffff81014faa:	48 c7 47 10 00 00 00 	movq   $0x0,0x10(%rdi)
ffffffff81014fb1:	00 
ffffffff81014fb2:	48 89 57 18          	mov    %rdx,0x18(%rdi)
{
    trace (TRACE_SYSCALL, "SI:%p created (SM:%p signal:%#lx)", this, s, v);

    if (sm)
ffffffff81014fb6:	75 0e                	jne    ffffffff81014fc6 <_ZN2SiC1EP2Smm+0x2a>
ffffffff81014fb8:	c3                   	retq   

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff81014fb9:	8d 50 01             	lea    0x1(%rax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff81014fbc:	f0 0f b1 96 8c 00 00 	lock cmpxchg %edx,0x8c(%rsi)
ffffffff81014fc3:	00 
ffffffff81014fc4:	74 0a                	je     ffffffff81014fd0 <_ZN2SiC1EP2Smm+0x34>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff81014fc6:	8b 86 8c 00 00 00    	mov    0x8c(%rsi),%eax
ffffffff81014fcc:	85 c0                	test   %eax,%eax
ffffffff81014fce:	75 e9                	jne    ffffffff81014fb9 <_ZN2SiC1EP2Smm+0x1d>
ffffffff81014fd0:	c3                   	retq   
ffffffff81014fd1:	90                   	nop

ffffffff81014fd2 <_ZN2SiD1Ev>:
        sm->add_ref();
}

Si::~Si()
ffffffff81014fd2:	55                   	push   %rbp
ffffffff81014fd3:	53                   	push   %rbx
ffffffff81014fd4:	56                   	push   %rsi
{
    if (!sm)
ffffffff81014fd5:	48 8b 07             	mov    (%rdi),%rax
ffffffff81014fd8:	48 85 c0             	test   %rax,%rax
ffffffff81014fdb:	0f 84 ce 00 00 00    	je     ffffffff810150af <_ZN2SiD1Ev+0xdd>
ffffffff81014fe1:	48 8b 57 10          	mov    0x10(%rdi),%rdx
        return;

    if (queued()) {
ffffffff81014fe5:	48 85 d2             	test   %rdx,%rdx
ffffffff81014fe8:	74 53                	je     ffffffff8101503d <_ZN2SiD1Ev+0x6b>
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff81014fea:	48 8b 4f 08          	mov    0x8(%rdi),%rcx
ffffffff81014fee:	48 85 c9             	test   %rcx,%rcx
ffffffff81014ff1:	0f 84 90 00 00 00    	je     ffffffff81015087 <_ZN2SiD1Ev+0xb5>
                return false;

            if (t == t->next)
ffffffff81014ff7:	48 39 d7             	cmp    %rdx,%rdi
ffffffff81014ffa:	75 0d                	jne    ffffffff81015009 <_ZN2SiD1Ev+0x37>
                headptr = nullptr;
ffffffff81014ffc:	48 c7 80 98 00 00 00 	movq   $0x0,0x98(%rax)
ffffffff81015003:	00 00 00 00 
ffffffff81015007:	eb 24                	jmp    ffffffff8101502d <_ZN2SiD1Ev+0x5b>

            else {
                t->next->prev = t->prev;
ffffffff81015009:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
                t->prev->next = t->next;
ffffffff8101500d:	48 8b 57 08          	mov    0x8(%rdi),%rdx
ffffffff81015011:	48 8b 4f 10          	mov    0x10(%rdi),%rcx
ffffffff81015015:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
                if (t == headptr)
ffffffff81015019:	48 3b b8 98 00 00 00 	cmp    0x98(%rax),%rdi
ffffffff81015020:	75 0b                	jne    ffffffff8101502d <_ZN2SiD1Ev+0x5b>
                    headptr = t->next;
ffffffff81015022:	48 8b 57 10          	mov    0x10(%rdi),%rdx
ffffffff81015026:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
            }

            t->next = t->prev = nullptr;
ffffffff8101502d:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
ffffffff81015034:	00 
ffffffff81015035:	48 c7 47 10 00 00 00 	movq   $0x0,0x10(%rdi)
ffffffff8101503c:	00 
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff8101503d:	48 8b 07             	mov    (%rdi),%rax
ffffffff81015040:	83 ca ff             	or     $0xffffffff,%edx
ffffffff81015043:	f0 0f c1 90 8c 00 00 	lock xadd %edx,0x8c(%rax)
ffffffff8101504a:	00 
        bool r = sm->Queue<Si>::dequeue(this);
        assert(r);
    }

    if (sm->del_ref()) {
ffffffff8101504b:	ff ca                	dec    %edx
ffffffff8101504d:	75 60                	jne    ffffffff810150af <_ZN2SiD1Ev+0xdd>
        Pd *pd = static_cast<Pd *>(static_cast<Space_obj *>(sm->space));
ffffffff8101504f:	48 8b 2f             	mov    (%rdi),%rbp
ffffffff81015052:	31 db                	xor    %ebx,%ebx
ffffffff81015054:	48 8b 45 50          	mov    0x50(%rbp),%rax

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void destroy(Sm *obj, Quota &quota) { obj->~Sm(); cache.free (obj, quota); }
ffffffff81015058:	48 89 ef             	mov    %rbp,%rdi
ffffffff8101505b:	48 8d 90 08 fd ff ff 	lea    -0x2f8(%rax),%rdx
ffffffff81015062:	48 85 c0             	test   %rax,%rax
ffffffff81015065:	48 0f 45 da          	cmovne %rdx,%rbx
ffffffff81015069:	e8 52 68 ff ff       	callq  ffffffff8100b8c0 <_ZN2SmD1Ev>
        Sm::destroy(sm, pd->quota);
    }
}
ffffffff8101506e:	59                   	pop    %rcx
        assert(r);
    }

    if (sm->del_ref()) {
        Pd *pd = static_cast<Pd *>(static_cast<Space_obj *>(sm->space));
        Sm::destroy(sm, pd->quota);
ffffffff8101506f:	48 8d 93 08 03 00 00 	lea    0x308(%rbx),%rdx
ffffffff81015076:	48 89 ee             	mov    %rbp,%rsi
ffffffff81015079:	48 c7 c7 80 40 16 81 	mov    $0xffffffff81164080,%rdi
    }
}
ffffffff81015080:	5b                   	pop    %rbx
ffffffff81015081:	5d                   	pop    %rbp
ffffffff81015082:	e9 e3 09 00 00       	jmpq   ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
    if (!sm)
        return;

    if (queued()) {
        bool r = sm->Queue<Si>::dequeue(this);
        assert(r);
ffffffff81015087:	49 c7 c0 18 07 02 81 	mov    $0xffffffff81020718,%r8
ffffffff8101508e:	b9 29 00 00 00       	mov    $0x29,%ecx
ffffffff81015093:	48 c7 c2 d0 05 02 81 	mov    $0xffffffff810205d0,%rdx
ffffffff8101509a:	48 c7 c6 86 d1 01 81 	mov    $0xffffffff8101d186,%rsi
ffffffff810150a1:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff810150a8:	31 c0                	xor    %eax,%eax
ffffffff810150aa:	e8 a1 ce fe ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

    if (sm->del_ref()) {
        Pd *pd = static_cast<Pd *>(static_cast<Space_obj *>(sm->space));
        Sm::destroy(sm, pd->quota);
    }
}
ffffffff810150af:	58                   	pop    %rax
ffffffff810150b0:	5b                   	pop    %rbx
ffffffff810150b1:	5d                   	pop    %rbp
ffffffff810150b2:	c3                   	retq   
ffffffff810150b3:	90                   	nop

ffffffff810150b4 <_ZN2Si6submitEv>:
    for (unsigned i = 0; i < c; i++)
        kern_sm->submit();
}

void Si::submit()
{
ffffffff810150b4:	41 55                	push   %r13
ffffffff810150b6:	41 54                	push   %r12
ffffffff810150b8:	55                   	push   %rbp
ffffffff810150b9:	53                   	push   %rbx
ffffffff810150ba:	48 89 fb             	mov    %rdi,%rbx
ffffffff810150bd:	52                   	push   %rdx
    Sm * i = static_cast<Sm *>(this);
    assert(i);
ffffffff810150be:	49 89 dd             	mov    %rbx,%r13
ffffffff810150c1:	49 81 ed a0 00 00 00 	sub    $0xa0,%r13
ffffffff810150c8:	75 1c                	jne    ffffffff810150e6 <_ZN2Si6submitEv+0x32>
ffffffff810150ca:	49 c7 c0 80 06 02 81 	mov    $0xffffffff81020680,%r8
ffffffff810150d1:	b9 4d 00 00 00       	mov    $0x4d,%ecx
ffffffff810150d6:	48 c7 c2 d0 05 02 81 	mov    $0xffffffff810205d0,%rdx
ffffffff810150dd:	48 c7 c6 3a 06 02 81 	mov    $0xffffffff8102063a,%rsi
ffffffff810150e4:	eb 52                	jmp    ffffffff81015138 <_ZN2Si6submitEv+0x84>

    if (i->space == static_cast<Space_obj *>(&Pd::kern)) {
ffffffff810150e6:	48 81 7b b0 98 3f 16 	cmpq   $0xffffffff81163f98,-0x50(%rbx)
ffffffff810150ed:	81 
ffffffff810150ee:	75 11                	jne    ffffffff81015101 <_ZN2Si6submitEv+0x4d>
        Sm * si = ACCESS_ONCE(i->sm);
ffffffff810150f0:	48 8b 03             	mov    (%rbx),%rax
        if (si) {
ffffffff810150f3:	48 85 c0             	test   %rax,%rax
ffffffff810150f6:	74 09                	je     ffffffff81015101 <_ZN2Si6submitEv+0x4d>
            si->submit();
ffffffff810150f8:	48 8d 98 a0 00 00 00 	lea    0xa0(%rax),%rbx
            return;
ffffffff810150ff:	eb bd                	jmp    ffffffff810150be <_ZN2Si6submitEv+0xa>
        ALWAYS_INLINE
        inline void up (void (*c)() = nullptr, Sm * si = nullptr)
        {
            Ec *ec;

            {   Lock_guard <Spinlock> guard (lock);
ffffffff81015101:	49 8d bd 8a 00 00 00 	lea    0x8a(%r13),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81015108:	9c                   	pushfq 
ffffffff81015109:	41 5c                	pop    %r12
            return flags & 0x200;
ffffffff8101510b:	49 c1 ec 09          	shr    $0x9,%r12

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8101510f:	41 80 e4 01          	and    $0x1,%r12b
ffffffff81015113:	74 39                	je     ffffffff8101514e <_ZN2Si6submitEv+0x9a>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81015115:	80 3d 14 a6 fe 3e 00 	cmpb   $0x0,0x3efea614(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8101511c:	75 28                	jne    ffffffff81015146 <_ZN2Si6submitEv+0x92>
ffffffff8101511e:	49 c7 c0 f0 06 02 81 	mov    $0xffffffff810206f0,%r8
ffffffff81015125:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff8101512a:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81015131:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff81015138:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8101513f:	31 c0                	xor    %eax,%eax
ffffffff81015141:	e8 0a ce fe ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            asm volatile ("cli" : : : "memory");
ffffffff81015146:	fa                   	cli    
            preemption = false;
ffffffff81015147:	c6 05 e2 a5 fe 3e 00 	movb   $0x0,0x3efea5e2(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff8101514e:	e8 3b bd fe ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff81015153:	48 8b 6b f0          	mov    -0x10(%rbx),%rbp
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff81015157:	48 85 ed             	test   %rbp,%rbp
ffffffff8101515a:	0f 84 d9 01 00 00    	je     ffffffff81015339 <_ZN2Si6submitEv+0x285>
ffffffff81015160:	48 8b 85 b0 02 00 00 	mov    0x2b0(%rbp),%rax
ffffffff81015167:	48 85 c0             	test   %rax,%rax
ffffffff8101516a:	0f 84 c9 01 00 00    	je     ffffffff81015339 <_ZN2Si6submitEv+0x285>
ffffffff81015170:	48 8b 95 a8 02 00 00 	mov    0x2a8(%rbp),%rdx
ffffffff81015177:	48 85 d2             	test   %rdx,%rdx
ffffffff8101517a:	0f 84 b9 01 00 00    	je     ffffffff81015339 <_ZN2Si6submitEv+0x285>
                return false;

            if (t == t->next)
ffffffff81015180:	48 39 c5             	cmp    %rax,%rbp
ffffffff81015183:	75 0a                	jne    ffffffff8101518f <_ZN2Si6submitEv+0xdb>
                headptr = nullptr;
ffffffff81015185:	48 c7 43 f0 00 00 00 	movq   $0x0,-0x10(%rbx)
ffffffff8101518c:	00 
ffffffff8101518d:	eb 2d                	jmp    ffffffff810151bc <_ZN2Si6submitEv+0x108>

            else {
                t->next->prev = t->prev;
ffffffff8101518f:	48 89 90 a8 02 00 00 	mov    %rdx,0x2a8(%rax)
                t->prev->next = t->next;
ffffffff81015196:	48 8b 85 a8 02 00 00 	mov    0x2a8(%rbp),%rax
ffffffff8101519d:	48 8b 95 b0 02 00 00 	mov    0x2b0(%rbp),%rdx
ffffffff810151a4:	48 89 90 b0 02 00 00 	mov    %rdx,0x2b0(%rax)
                if (t == headptr)
ffffffff810151ab:	48 3b 6b f0          	cmp    -0x10(%rbx),%rbp
ffffffff810151af:	75 0b                	jne    ffffffff810151bc <_ZN2Si6submitEv+0x108>
                    headptr = t->next;
ffffffff810151b1:	48 8b 85 b0 02 00 00 	mov    0x2b0(%rbp),%rax
ffffffff810151b8:	48 89 43 f0          	mov    %rax,-0x10(%rbx)
            }

            t->next = t->prev = nullptr;
ffffffff810151bc:	48 c7 85 a8 02 00 00 	movq   $0x0,0x2a8(%rbp)
ffffffff810151c3:	00 00 00 00 
ffffffff810151c7:	48 c7 85 b0 02 00 00 	movq   $0x0,0x2b0(%rbp)
ffffffff810151ce:	00 00 00 00 
ffffffff810151d2:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff810151d5:	f0 0f c1 85 8c 00 00 	lock xadd %eax,0x8c(%rbp)
ffffffff810151dc:	00 

                    counter++;
                    return;
                }

                if (EXPECT_FALSE(ec->del_ref())) {
ffffffff810151dd:	ff c8                	dec    %eax
ffffffff810151df:	75 2a                	jne    ffffffff8101520b <_ZN2Si6submitEv+0x157>
                    delete ec;
ffffffff810151e1:	48 89 ef             	mov    %rbp,%rdi
ffffffff810151e4:	e8 53 f2 fe ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
ffffffff810151e9:	48 8b 85 98 02 00 00 	mov    0x298(%rbp),%rax
ffffffff810151f0:	48 89 ee             	mov    %rbp,%rsi
ffffffff810151f3:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff810151fa:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff81015201:	e8 64 08 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
ffffffff81015206:	e9 48 ff ff ff       	jmpq   ffffffff81015153 <_ZN2Si6submitEv+0x9f>
        }

        ALWAYS_INLINE
        inline void unlock()
        {
            asm volatile ("incb %0" : "=m" (val) : : "memory");
ffffffff8101520b:	41 fe 85 8a 00 00 00 	incb   0x8a(%r13)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81015212:	45 84 e4             	test   %r12b,%r12b
ffffffff81015215:	74 30                	je     ffffffff81015247 <_ZN2Si6submitEv+0x193>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81015217:	80 3d 12 a5 fe 3e 00 	cmpb   $0x0,0x3efea512(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8101521e:	74 1f                	je     ffffffff8101523f <_ZN2Si6submitEv+0x18b>
ffffffff81015220:	49 c7 c0 c0 06 02 81 	mov    $0xffffffff810206c0,%r8
ffffffff81015227:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff8101522c:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81015233:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff8101523a:	e9 f9 fe ff ff       	jmpq   ffffffff81015138 <_ZN2Si6submitEv+0x84>

            preemption = true;
ffffffff8101523f:	c6 05 ea a4 fe 3e 01 	movb   $0x1,0x3efea4ea(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81015246:	fb                   	sti    
    ALWAYS_INLINE
    inline void release(void (*c)()) {
        if (c)
            cont = c;

        Lock_guard <Spinlock> guard(lock);
ffffffff81015247:	48 8d bd 8a 00 00 00 	lea    0x8a(%rbp),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff8101524e:	9c                   	pushfq 
ffffffff8101524f:	58                   	pop    %rax
            return flags & 0x200;
ffffffff81015250:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff81015254:	41 88 c5             	mov    %al,%r13b
ffffffff81015257:	41 80 e5 01          	and    $0x1,%r13b
ffffffff8101525b:	74 15                	je     ffffffff81015272 <_ZN2Si6submitEv+0x1be>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff8101525d:	80 3d cc a4 fe 3e 00 	cmpb   $0x0,0x3efea4cc(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81015264:	0f 84 b4 fe ff ff    	je     ffffffff8101511e <_ZN2Si6submitEv+0x6a>

            asm volatile ("cli" : : : "memory");
ffffffff8101526a:	fa                   	cli    
            preemption = false;
ffffffff8101526b:	c6 05 be a4 fe 3e 00 	movb   $0x0,0x3efea4be(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff81015272:	e8 17 bc fe ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff81015277:	4c 8b a5 90 00 00 00 	mov    0x90(%rbp),%r12
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff8101527e:	4d 85 e4             	test   %r12,%r12
ffffffff81015281:	0f 84 cf 00 00 00    	je     ffffffff81015356 <_ZN2Si6submitEv+0x2a2>
ffffffff81015287:	49 8b 84 24 c0 00 00 	mov    0xc0(%r12),%rax
ffffffff8101528e:	00 
ffffffff8101528f:	48 85 c0             	test   %rax,%rax
ffffffff81015292:	0f 84 be 00 00 00    	je     ffffffff81015356 <_ZN2Si6submitEv+0x2a2>
ffffffff81015298:	49 8b 94 24 b8 00 00 	mov    0xb8(%r12),%rdx
ffffffff8101529f:	00 
ffffffff810152a0:	48 85 d2             	test   %rdx,%rdx
ffffffff810152a3:	0f 84 ad 00 00 00    	je     ffffffff81015356 <_ZN2Si6submitEv+0x2a2>
                return false;

            if (t == t->next)
ffffffff810152a9:	49 39 c4             	cmp    %rax,%r12
ffffffff810152ac:	75 0d                	jne    ffffffff810152bb <_ZN2Si6submitEv+0x207>
                headptr = nullptr;
ffffffff810152ae:	48 c7 85 90 00 00 00 	movq   $0x0,0x90(%rbp)
ffffffff810152b5:	00 00 00 00 
ffffffff810152b9:	eb 36                	jmp    ffffffff810152f1 <_ZN2Si6submitEv+0x23d>

            else {
                t->next->prev = t->prev;
ffffffff810152bb:	48 89 90 b8 00 00 00 	mov    %rdx,0xb8(%rax)
                t->prev->next = t->next;
ffffffff810152c2:	49 8b 84 24 b8 00 00 	mov    0xb8(%r12),%rax
ffffffff810152c9:	00 
ffffffff810152ca:	49 8b 94 24 c0 00 00 	mov    0xc0(%r12),%rdx
ffffffff810152d1:	00 
ffffffff810152d2:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
                if (t == headptr)
ffffffff810152d9:	4c 3b a5 90 00 00 00 	cmp    0x90(%rbp),%r12
ffffffff810152e0:	75 0f                	jne    ffffffff810152f1 <_ZN2Si6submitEv+0x23d>
                    headptr = t->next;
ffffffff810152e2:	49 8b 84 24 c0 00 00 	mov    0xc0(%r12),%rax
ffffffff810152e9:	00 
ffffffff810152ea:	48 89 85 90 00 00 00 	mov    %rax,0x90(%rbp)
            }

            t->next = t->prev = nullptr;
ffffffff810152f1:	49 c7 84 24 b8 00 00 	movq   $0x0,0xb8(%r12)
ffffffff810152f8:	00 00 00 00 00 
ffffffff810152fd:	49 c7 84 24 c0 00 00 	movq   $0x0,0xc0(%r12)
ffffffff81015304:	00 00 00 00 00 
ffffffff81015309:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff8101530c:	f0 41 0f c1 84 24 8c 	lock xadd %eax,0x8c(%r12)
ffffffff81015313:	00 00 00 

        for (Sc *s; dequeue(s = head());) {
            if (EXPECT_FALSE(s->del_ref()) && (this == s->ec)) {
ffffffff81015316:	ff c8                	dec    %eax
ffffffff81015318:	75 2f                	jne    ffffffff81015349 <_ZN2Si6submitEv+0x295>
ffffffff8101531a:	49 3b ac 24 90 00 00 	cmp    0x90(%r12),%rbp
ffffffff81015321:	00 
ffffffff81015322:	75 25                	jne    ffffffff81015349 <_ZN2Si6submitEv+0x295>
                delete s;
ffffffff81015324:	4c 89 e7             	mov    %r12,%rdi
ffffffff81015327:	e8 34 38 ff ff       	callq  ffffffff81008b60 <_ZN2ScD1Ev>
ffffffff8101532c:	4c 89 e7             	mov    %r12,%rdi
ffffffff8101532f:	e8 f6 f9 ff ff       	callq  ffffffff81014d2a <_ZN2ScdlEPv>
ffffffff81015334:	e9 3e ff ff ff       	jmpq   ffffffff81015277 <_ZN2Si6submitEv+0x1c3>
                    if (si) {
                       if (si->queued()) return;
                       Queue<Si>::enqueue(si);
                    }

                    counter++;
ffffffff81015339:	48 ff 43 20          	incq   0x20(%rbx)
ffffffff8101533d:	41 fe 85 8a 00 00 00 	incb   0x8a(%r13)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81015344:	45 84 e4             	test   %r12b,%r12b
ffffffff81015347:	eb 16                	jmp    ffffffff8101535f <_ZN2Si6submitEv+0x2ab>
                continue;
            }
            s->remote_enqueue();
ffffffff81015349:	4c 89 e7             	mov    %r12,%rdi
ffffffff8101534c:	e8 0f f7 ff ff       	callq  ffffffff81014a60 <_ZN2Sc14remote_enqueueEv>
ffffffff81015351:	e9 21 ff ff ff       	jmpq   ffffffff81015277 <_ZN2Si6submitEv+0x1c3>
ffffffff81015356:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
ffffffff8101535c:	45 84 ed             	test   %r13b,%r13b
ffffffff8101535f:	74 15                	je     ffffffff81015376 <_ZN2Si6submitEv+0x2c2>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81015361:	80 3d c8 a3 fe 3e 00 	cmpb   $0x0,0x3efea3c8(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81015368:	0f 85 b2 fe ff ff    	jne    ffffffff81015220 <_ZN2Si6submitEv+0x16c>

            preemption = true;
ffffffff8101536e:	c6 05 bb a3 fe 3e 01 	movb   $0x1,0x3efea3bb(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81015375:	fb                   	sti    
        }
    }

    i->up();

    Sm * sm_chained = ACCESS_ONCE(sm);
ffffffff81015376:	4c 8b 23             	mov    (%rbx),%r12
    /* if !sm than it is just a semaphore */
    if (!sm_chained) return;
ffffffff81015379:	4d 85 e4             	test   %r12,%r12
ffffffff8101537c:	0f 84 a5 02 00 00    	je     ffffffff81015627 <_ZN2Si6submitEv+0x573>
        ALWAYS_INLINE
        inline void up (void (*c)() = nullptr, Sm * si = nullptr)
        {
            Ec *ec;

            {   Lock_guard <Spinlock> guard (lock);
ffffffff81015382:	49 8d bc 24 8a 00 00 	lea    0x8a(%r12),%rdi
ffffffff81015389:	00 

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff8101538a:	9c                   	pushfq 
ffffffff8101538b:	41 5d                	pop    %r13
            return flags & 0x200;
ffffffff8101538d:	49 c1 ed 09          	shr    $0x9,%r13

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff81015391:	41 80 e5 01          	and    $0x1,%r13b
ffffffff81015395:	74 15                	je     ffffffff810153ac <_ZN2Si6submitEv+0x2f8>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81015397:	80 3d 92 a3 fe 3e 00 	cmpb   $0x0,0x3efea392(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8101539e:	0f 84 7a fd ff ff    	je     ffffffff8101511e <_ZN2Si6submitEv+0x6a>

            asm volatile ("cli" : : : "memory");
ffffffff810153a4:	fa                   	cli    
            preemption = false;
ffffffff810153a5:	c6 05 84 a3 fe 3e 00 	movb   $0x0,0x3efea384(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff810153ac:	e8 dd ba fe ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff810153b1:	49 8b ac 24 90 00 00 	mov    0x90(%r12),%rbp
ffffffff810153b8:	00 
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff810153b9:	48 85 ed             	test   %rbp,%rbp
ffffffff810153bc:	0f 84 0e 02 00 00    	je     ffffffff810155d0 <_ZN2Si6submitEv+0x51c>
ffffffff810153c2:	48 8b 85 b0 02 00 00 	mov    0x2b0(%rbp),%rax
ffffffff810153c9:	48 85 c0             	test   %rax,%rax
ffffffff810153cc:	0f 84 fe 01 00 00    	je     ffffffff810155d0 <_ZN2Si6submitEv+0x51c>
ffffffff810153d2:	48 8b 95 a8 02 00 00 	mov    0x2a8(%rbp),%rdx
ffffffff810153d9:	48 85 d2             	test   %rdx,%rdx
ffffffff810153dc:	0f 84 ee 01 00 00    	je     ffffffff810155d0 <_ZN2Si6submitEv+0x51c>
                return false;

            if (t == t->next)
ffffffff810153e2:	48 39 c5             	cmp    %rax,%rbp
ffffffff810153e5:	75 0e                	jne    ffffffff810153f5 <_ZN2Si6submitEv+0x341>
                headptr = nullptr;
ffffffff810153e7:	49 c7 84 24 90 00 00 	movq   $0x0,0x90(%r12)
ffffffff810153ee:	00 00 00 00 00 
ffffffff810153f3:	eb 35                	jmp    ffffffff8101542a <_ZN2Si6submitEv+0x376>

            else {
                t->next->prev = t->prev;
ffffffff810153f5:	48 89 90 a8 02 00 00 	mov    %rdx,0x2a8(%rax)
                t->prev->next = t->next;
ffffffff810153fc:	48 8b 85 a8 02 00 00 	mov    0x2a8(%rbp),%rax
ffffffff81015403:	48 8b 95 b0 02 00 00 	mov    0x2b0(%rbp),%rdx
ffffffff8101540a:	48 89 90 b0 02 00 00 	mov    %rdx,0x2b0(%rax)
                if (t == headptr)
ffffffff81015411:	49 3b ac 24 90 00 00 	cmp    0x90(%r12),%rbp
ffffffff81015418:	00 
ffffffff81015419:	75 0f                	jne    ffffffff8101542a <_ZN2Si6submitEv+0x376>
                    headptr = t->next;
ffffffff8101541b:	48 8b 85 b0 02 00 00 	mov    0x2b0(%rbp),%rax
ffffffff81015422:	49 89 84 24 90 00 00 	mov    %rax,0x90(%r12)
ffffffff81015429:	00 
            }

            t->next = t->prev = nullptr;
ffffffff8101542a:	48 c7 85 a8 02 00 00 	movq   $0x0,0x2a8(%rbp)
ffffffff81015431:	00 00 00 00 
ffffffff81015435:	48 c7 85 b0 02 00 00 	movq   $0x0,0x2b0(%rbp)
ffffffff8101543c:	00 00 00 00 
ffffffff81015440:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff81015443:	f0 0f c1 85 8c 00 00 	lock xadd %eax,0x8c(%rbp)
ffffffff8101544a:	00 

                    counter++;
                    return;
                }

                if (EXPECT_FALSE(ec->del_ref())) {
ffffffff8101544b:	ff c8                	dec    %eax
ffffffff8101544d:	75 2a                	jne    ffffffff81015479 <_ZN2Si6submitEv+0x3c5>
                    delete ec;
ffffffff8101544f:	48 89 ef             	mov    %rbp,%rdi
ffffffff81015452:	e8 e5 ef fe ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff81015457:	48 8b 85 98 02 00 00 	mov    0x298(%rbp),%rax
ffffffff8101545e:	48 89 ee             	mov    %rbp,%rsi
ffffffff81015461:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff81015468:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff8101546f:	e8 f6 05 00 00       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
ffffffff81015474:	e9 38 ff ff ff       	jmpq   ffffffff810153b1 <_ZN2Si6submitEv+0x2fd>

    public:

        mword reset(bool l = false) {
            if (l) lock.lock();
            mword c = counter;
ffffffff81015479:	48 8b 43 20          	mov    0x20(%rbx),%rax
                if (EXPECT_FALSE(ec->del_ref())) {
                    delete ec;
                    goto loop;
                }

                if (si) ec->set_si_regs(si->value, si->reset());
ffffffff8101547d:	48 8b 53 18          	mov    0x18(%rbx),%rdx
    public:

        mword reset(bool l = false) {
            if (l) lock.lock();
            mword c = counter;
            counter = 0;
ffffffff81015481:	48 c7 43 20 00 00 00 	movq   $0x0,0x20(%rbx)
ffffffff81015488:	00 
            timeout.dequeue();
    }

    ALWAYS_INLINE
    inline void set_si_regs(mword sig, mword cnt) {
        regs.ARG_2 = sig;
ffffffff81015489:	48 89 95 f0 00 00 00 	mov    %rdx,0xf0(%rbp)
        regs.ARG_3 = cnt;
ffffffff81015490:	48 89 85 10 01 00 00 	mov    %rax,0x110(%rbp)
ffffffff81015497:	41 fe 84 24 8a 00 00 	incb   0x8a(%r12)
ffffffff8101549e:	00 
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff8101549f:	45 84 ed             	test   %r13b,%r13b
ffffffff810154a2:	74 15                	je     ffffffff810154b9 <_ZN2Si6submitEv+0x405>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff810154a4:	80 3d 85 a2 fe 3e 00 	cmpb   $0x0,0x3efea285(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff810154ab:	0f 85 6f fd ff ff    	jne    ffffffff81015220 <_ZN2Si6submitEv+0x16c>

            preemption = true;
ffffffff810154b1:	c6 05 78 a2 fe 3e 01 	movb   $0x1,0x3efea278(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff810154b8:	fb                   	sti    
    ALWAYS_INLINE
    inline void release(void (*c)()) {
        if (c)
            cont = c;

        Lock_guard <Spinlock> guard(lock);
ffffffff810154b9:	48 8d bd 8a 00 00 00 	lea    0x8a(%rbp),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff810154c0:	9c                   	pushfq 
ffffffff810154c1:	58                   	pop    %rax
            return flags & 0x200;
ffffffff810154c2:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff810154c6:	41 88 c4             	mov    %al,%r12b
ffffffff810154c9:	41 80 e4 01          	and    $0x1,%r12b
ffffffff810154cd:	74 15                	je     ffffffff810154e4 <_ZN2Si6submitEv+0x430>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff810154cf:	80 3d 5a a2 fe 3e 00 	cmpb   $0x0,0x3efea25a(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff810154d6:	0f 84 42 fc ff ff    	je     ffffffff8101511e <_ZN2Si6submitEv+0x6a>

            asm volatile ("cli" : : : "memory");
ffffffff810154dc:	fa                   	cli    
            preemption = false;
ffffffff810154dd:	c6 05 4c a2 fe 3e 00 	movb   $0x0,0x3efea24c(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff810154e4:	e8 a5 b9 fe ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff810154e9:	48 8b 9d 90 00 00 00 	mov    0x90(%rbp),%rbx
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff810154f0:	48 85 db             	test   %rbx,%rbx
ffffffff810154f3:	0f 84 b5 00 00 00    	je     ffffffff810155ae <_ZN2Si6submitEv+0x4fa>
ffffffff810154f9:	48 8b 83 c0 00 00 00 	mov    0xc0(%rbx),%rax
ffffffff81015500:	48 85 c0             	test   %rax,%rax
ffffffff81015503:	0f 84 a5 00 00 00    	je     ffffffff810155ae <_ZN2Si6submitEv+0x4fa>
ffffffff81015509:	48 8b 93 b8 00 00 00 	mov    0xb8(%rbx),%rdx
ffffffff81015510:	48 85 d2             	test   %rdx,%rdx
ffffffff81015513:	0f 84 95 00 00 00    	je     ffffffff810155ae <_ZN2Si6submitEv+0x4fa>
                return false;

            if (t == t->next)
ffffffff81015519:	48 39 c3             	cmp    %rax,%rbx
ffffffff8101551c:	75 0d                	jne    ffffffff8101552b <_ZN2Si6submitEv+0x477>
                headptr = nullptr;
ffffffff8101551e:	48 c7 85 90 00 00 00 	movq   $0x0,0x90(%rbp)
ffffffff81015525:	00 00 00 00 
ffffffff81015529:	eb 33                	jmp    ffffffff8101555e <_ZN2Si6submitEv+0x4aa>

            else {
                t->next->prev = t->prev;
ffffffff8101552b:	48 89 90 b8 00 00 00 	mov    %rdx,0xb8(%rax)
                t->prev->next = t->next;
ffffffff81015532:	48 8b 83 b8 00 00 00 	mov    0xb8(%rbx),%rax
ffffffff81015539:	48 8b 93 c0 00 00 00 	mov    0xc0(%rbx),%rdx
ffffffff81015540:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
                if (t == headptr)
ffffffff81015547:	48 3b 9d 90 00 00 00 	cmp    0x90(%rbp),%rbx
ffffffff8101554e:	75 0e                	jne    ffffffff8101555e <_ZN2Si6submitEv+0x4aa>
                    headptr = t->next;
ffffffff81015550:	48 8b 83 c0 00 00 00 	mov    0xc0(%rbx),%rax
ffffffff81015557:	48 89 85 90 00 00 00 	mov    %rax,0x90(%rbp)
            }

            t->next = t->prev = nullptr;
ffffffff8101555e:	48 c7 83 b8 00 00 00 	movq   $0x0,0xb8(%rbx)
ffffffff81015565:	00 00 00 00 
ffffffff81015569:	48 c7 83 c0 00 00 00 	movq   $0x0,0xc0(%rbx)
ffffffff81015570:	00 00 00 00 
ffffffff81015574:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff81015577:	f0 0f c1 83 8c 00 00 	lock xadd %eax,0x8c(%rbx)
ffffffff8101557e:	00 

        for (Sc *s; dequeue(s = head());) {
            if (EXPECT_FALSE(s->del_ref()) && (this == s->ec)) {
ffffffff8101557f:	ff c8                	dec    %eax
ffffffff81015581:	75 1e                	jne    ffffffff810155a1 <_ZN2Si6submitEv+0x4ed>
ffffffff81015583:	48 3b ab 90 00 00 00 	cmp    0x90(%rbx),%rbp
ffffffff8101558a:	75 15                	jne    ffffffff810155a1 <_ZN2Si6submitEv+0x4ed>
                delete s;
ffffffff8101558c:	48 89 df             	mov    %rbx,%rdi
ffffffff8101558f:	e8 cc 35 ff ff       	callq  ffffffff81008b60 <_ZN2ScD1Ev>
ffffffff81015594:	48 89 df             	mov    %rbx,%rdi
ffffffff81015597:	e8 8e f7 ff ff       	callq  ffffffff81014d2a <_ZN2ScdlEPv>
ffffffff8101559c:	e9 48 ff ff ff       	jmpq   ffffffff810154e9 <_ZN2Si6submitEv+0x435>
                continue;
            }
            s->remote_enqueue();
ffffffff810155a1:	48 89 df             	mov    %rbx,%rdi
ffffffff810155a4:	e8 b7 f4 ff ff       	callq  ffffffff81014a60 <_ZN2Sc14remote_enqueueEv>
ffffffff810155a9:	e9 3b ff ff ff       	jmpq   ffffffff810154e9 <_ZN2Si6submitEv+0x435>
ffffffff810155ae:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff810155b4:	45 84 e4             	test   %r12b,%r12b
ffffffff810155b7:	74 6e                	je     ffffffff81015627 <_ZN2Si6submitEv+0x573>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff810155b9:	80 3d 70 a1 fe 3e 00 	cmpb   $0x0,0x3efea170(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff810155c0:	0f 85 5a fc ff ff    	jne    ffffffff81015220 <_ZN2Si6submitEv+0x16c>

            preemption = true;
ffffffff810155c6:	c6 05 63 a1 fe 3e 01 	movb   $0x1,0x3efea163(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff810155cd:	fb                   	sti    
ffffffff810155ce:	eb 57                	jmp    ffffffff81015627 <_ZN2Si6submitEv+0x573>
                loop:

                if (!Queue<Ec>::dequeue (ec = Queue<Ec>::head())) {

                    if (si) {
                       if (si->queued()) return;
ffffffff810155d0:	48 83 7b 10 00       	cmpq   $0x0,0x10(%rbx)
ffffffff810155d5:	75 43                	jne    ffffffff8101561a <_ZN2Si6submitEv+0x566>
        inline T *head() const { return headptr; }

        ALWAYS_INLINE
        inline void enqueue (T *t)
        {
            if (!headptr)
ffffffff810155d7:	49 8b 84 24 98 00 00 	mov    0x98(%r12),%rax
ffffffff810155de:	00 
ffffffff810155df:	48 85 c0             	test   %rax,%rax
ffffffff810155e2:	75 12                	jne    ffffffff810155f6 <_ZN2Si6submitEv+0x542>
                headptr = t->prev = t->next = t;
ffffffff810155e4:	48 89 5b 10          	mov    %rbx,0x10(%rbx)
ffffffff810155e8:	48 89 5b 08          	mov    %rbx,0x8(%rbx)
ffffffff810155ec:	49 89 9c 24 98 00 00 	mov    %rbx,0x98(%r12)
ffffffff810155f3:	00 
ffffffff810155f4:	eb 1c                	jmp    ffffffff81015612 <_ZN2Si6submitEv+0x55e>
            else {
                t->next = headptr;
ffffffff810155f6:	48 89 43 10          	mov    %rax,0x10(%rbx)
                t->prev = headptr->prev;
ffffffff810155fa:	49 8b 94 24 98 00 00 	mov    0x98(%r12),%rdx
ffffffff81015601:	00 
ffffffff81015602:	48 8b 52 08          	mov    0x8(%rdx),%rdx
ffffffff81015606:	48 89 53 08          	mov    %rdx,0x8(%rbx)
                t->next->prev = t->prev->next = t;
ffffffff8101560a:	48 89 5a 10          	mov    %rbx,0x10(%rdx)
ffffffff8101560e:	48 89 58 08          	mov    %rbx,0x8(%rax)
                       Queue<Si>::enqueue(si);
                    }

                    counter++;
ffffffff81015612:	49 ff 84 24 c0 00 00 	incq   0xc0(%r12)
ffffffff81015619:	00 
ffffffff8101561a:	41 fe 84 24 8a 00 00 	incb   0x8a(%r12)
ffffffff81015621:	00 
ffffffff81015622:	45 84 ed             	test   %r13b,%r13b
ffffffff81015625:	eb 90                	jmp    ffffffff810155b7 <_ZN2Si6submitEv+0x503>

    /* signal mode - send up() to chained sm */
    sm_chained->up(nullptr, i);
}
ffffffff81015627:	58                   	pop    %rax
ffffffff81015628:	5b                   	pop    %rbx
ffffffff81015629:	5d                   	pop    %rbp
ffffffff8101562a:	41 5c                	pop    %r12
ffffffff8101562c:	41 5d                	pop    %r13
ffffffff8101562e:	c3                   	retq   
ffffffff8101562f:	90                   	nop

ffffffff81015630 <_ZN2Si5chainEP2Sm>:
        Sm::destroy(sm, pd->quota);
    }
}

void Si::chain(Sm *si)
{
ffffffff81015630:	41 57                	push   %r15
ffffffff81015632:	41 56                	push   %r14
    Sm * kern_sm = static_cast<Sm *>(this);
    assert (kern_sm);
ffffffff81015634:	49 89 fe             	mov    %rdi,%r14
        Sm::destroy(sm, pd->quota);
    }
}

void Si::chain(Sm *si)
{
ffffffff81015637:	41 55                	push   %r13
ffffffff81015639:	41 54                	push   %r12
ffffffff8101563b:	55                   	push   %rbp
ffffffff8101563c:	53                   	push   %rbx
ffffffff8101563d:	48 89 fb             	mov    %rdi,%rbx
ffffffff81015640:	48 83 ec 18          	sub    $0x18,%rsp
    Sm * kern_sm = static_cast<Sm *>(this);
    assert (kern_sm);
ffffffff81015644:	49 81 ee a0 00 00 00 	sub    $0xa0,%r14
ffffffff8101564b:	75 1c                	jne    ffffffff81015669 <_ZN2Si5chainEP2Sm+0x39>
ffffffff8101564d:	49 c7 c0 a0 06 02 81 	mov    $0xffffffff810206a0,%r8
ffffffff81015654:	b9 35 00 00 00       	mov    $0x35,%ecx
ffffffff81015659:	48 c7 c2 d0 05 02 81 	mov    $0xffffffff810205d0,%rdx
ffffffff81015660:	48 c7 c6 3c 06 02 81 	mov    $0xffffffff8102063c,%rsi
ffffffff81015667:	eb 24                	jmp    ffffffff8101568d <_ZN2Si5chainEP2Sm+0x5d>
    assert (kern_sm->space == static_cast<Space_obj *>(&Pd::kern));
ffffffff81015669:	48 81 7f b0 98 3f 16 	cmpq   $0xffffffff81163f98,-0x50(%rdi)
ffffffff81015670:	81 
ffffffff81015671:	74 28                	je     ffffffff8101569b <_ZN2Si5chainEP2Sm+0x6b>
ffffffff81015673:	49 c7 c0 a0 06 02 81 	mov    $0xffffffff810206a0,%r8
ffffffff8101567a:	b9 36 00 00 00       	mov    $0x36,%ecx
ffffffff8101567f:	48 c7 c2 d0 05 02 81 	mov    $0xffffffff810205d0,%rdx
ffffffff81015686:	48 c7 c6 44 06 02 81 	mov    $0xffffffff81020644,%rsi
ffffffff8101568d:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81015694:	31 c0                	xor    %eax,%eax
ffffffff81015696:	e8 b5 c8 fe ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
ffffffff8101569b:	49 89 f4             	mov    %rsi,%r12

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff8101569e:	9c                   	pushfq 
ffffffff8101569f:	5d                   	pop    %rbp
            return flags & 0x200;
ffffffff810156a0:	48 c1 ed 09          	shr    $0x9,%rbp

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff810156a4:	40 80 e5 01          	and    $0x1,%bpl
ffffffff810156a8:	74 2d                	je     ffffffff810156d7 <_ZN2Si5chainEP2Sm+0xa7>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff810156aa:	80 3d 7f a0 fe 3e 00 	cmpb   $0x0,0x3efea07f(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff810156b1:	75 1c                	jne    ffffffff810156cf <_ZN2Si5chainEP2Sm+0x9f>
ffffffff810156b3:	49 c7 c0 f0 06 02 81 	mov    $0xffffffff810206f0,%r8
ffffffff810156ba:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff810156bf:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff810156c6:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff810156cd:	eb be                	jmp    ffffffff8101568d <_ZN2Si5chainEP2Sm+0x5d>

            asm volatile ("cli" : : : "memory");
ffffffff810156cf:	fa                   	cli    
            preemption = false;
ffffffff810156d0:	c6 05 59 a0 fe 3e 00 	movb   $0x0,0x3efea059(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff810156d7:	48 c7 c7 70 40 16 81 	mov    $0xffffffff81164070,%rdi
ffffffff810156de:	e8 ab b7 fe ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>

    Lock_guard <Spinlock> guard (lock);

    if (sm && sm->del_ref()) {
ffffffff810156e3:	48 8b 03             	mov    (%rbx),%rax
ffffffff810156e6:	48 85 c0             	test   %rax,%rax
ffffffff810156e9:	74 3b                	je     ffffffff81015726 <_ZN2Si5chainEP2Sm+0xf6>
ffffffff810156eb:	83 ca ff             	or     $0xffffffff,%edx
ffffffff810156ee:	f0 0f c1 90 8c 00 00 	lock xadd %edx,0x8c(%rax)
ffffffff810156f5:	00 
ffffffff810156f6:	ff ca                	dec    %edx
ffffffff810156f8:	75 2c                	jne    ffffffff81015726 <_ZN2Si5chainEP2Sm+0xf6>
        sm->add_ref();
ffffffff810156fa:	48 8b 13             	mov    (%rbx),%rdx
ffffffff810156fd:	8b 82 8c 00 00 00    	mov    0x8c(%rdx),%eax
ffffffff81015703:	85 c0                	test   %eax,%eax
ffffffff81015705:	74 0d                	je     ffffffff81015714 <_ZN2Si5chainEP2Sm+0xe4>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff81015707:	8d 48 01             	lea    0x1(%rax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff8101570a:	f0 0f b1 8a 8c 00 00 	lock cmpxchg %ecx,0x8c(%rdx)
ffffffff81015711:	00 
ffffffff81015712:	75 e9                	jne    ffffffff810156fd <_ZN2Si5chainEP2Sm+0xcd>
        sm->call_rcu();
ffffffff81015714:	4c 8b 2b             	mov    (%rbx),%r13
        }

        ALWAYS_INLINE
        inline void call_rcu(bool r = false)
        {
            if (ACCESS_ONCE(rcu))
ffffffff81015717:	41 8a 85 c8 00 00 00 	mov    0xc8(%r13),%al
ffffffff8101571e:	84 c0                	test   %al,%al
ffffffff81015720:	0f 84 99 00 00 00    	je     ffffffff810157bf <_ZN2Si5chainEP2Sm+0x18f>
    }

    sm = si;
ffffffff81015726:	4c 89 23             	mov    %r12,(%rbx)

    if (sm)
ffffffff81015729:	4d 85 e4             	test   %r12,%r12
ffffffff8101572c:	75 20                	jne    ffffffff8101574e <_ZN2Si5chainEP2Sm+0x11e>
        }

    public:

        mword reset(bool l = false) {
            if (l) lock.lock();
ffffffff8101572e:	49 8d be 8a 00 00 00 	lea    0x8a(%r14),%rdi
ffffffff81015735:	e8 54 b7 fe ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
            mword c = counter;
ffffffff8101573a:	4c 8b 6b 20          	mov    0x20(%rbx),%r13
            counter = 0;
ffffffff8101573e:	48 c7 43 20 00 00 00 	movq   $0x0,0x20(%rbx)
ffffffff81015745:	00 
ffffffff81015746:	fe 43 ea             	incb   -0x16(%rbx)
        sm->add_ref();

    mword c = kern_sm->reset(true);

    for (unsigned i = 0; i < c; i++)
ffffffff81015749:	45 31 e4             	xor    %r12d,%r12d
ffffffff8101574c:	eb 1b                	jmp    ffffffff81015769 <_ZN2Si5chainEP2Sm+0x139>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8101574e:	41 8b 84 24 8c 00 00 	mov    0x8c(%r12),%eax
ffffffff81015755:	00 
ffffffff81015756:	85 c0                	test   %eax,%eax
ffffffff81015758:	74 d4                	je     ffffffff8101572e <_ZN2Si5chainEP2Sm+0xfe>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8101575a:	8d 50 01             	lea    0x1(%rax),%edx
ffffffff8101575d:	f0 41 0f b1 94 24 8c 	lock cmpxchg %edx,0x8c(%r12)
ffffffff81015764:	00 00 00 
ffffffff81015767:	eb c3                	jmp    ffffffff8101572c <_ZN2Si5chainEP2Sm+0xfc>
ffffffff81015769:	44 89 e0             	mov    %r12d,%eax
ffffffff8101576c:	4c 39 e8             	cmp    %r13,%rax
ffffffff8101576f:	73 0d                	jae    ffffffff8101577e <_ZN2Si5chainEP2Sm+0x14e>
        kern_sm->submit();
ffffffff81015771:	48 89 df             	mov    %rbx,%rdi
    if (sm)
        sm->add_ref();

    mword c = kern_sm->reset(true);

    for (unsigned i = 0; i < c; i++)
ffffffff81015774:	41 ff c4             	inc    %r12d
        kern_sm->submit();
ffffffff81015777:	e8 38 f9 ff ff       	callq  ffffffff810150b4 <_ZN2Si6submitEv>
ffffffff8101577c:	eb eb                	jmp    ffffffff81015769 <_ZN2Si5chainEP2Sm+0x139>
ffffffff8101577e:	fe 05 ec e8 14 00    	incb   0x14e8ec(%rip)        # ffffffff81164070 <_ZL4lock>
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81015784:	40 84 ed             	test   %bpl,%bpl
ffffffff81015787:	0f 84 a7 00 00 00    	je     ffffffff81015834 <_ZN2Si5chainEP2Sm+0x204>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8101578d:	80 3d 9c 9f fe 3e 00 	cmpb   $0x0,0x3efe9f9c(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81015794:	74 1f                	je     ffffffff810157b5 <_ZN2Si5chainEP2Sm+0x185>
ffffffff81015796:	49 c7 c0 c0 06 02 81 	mov    $0xffffffff810206c0,%r8
ffffffff8101579d:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff810157a2:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff810157a9:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff810157b0:	e9 d8 fe ff ff       	jmpq   ffffffff8101568d <_ZN2Si5chainEP2Sm+0x5d>

            preemption = true;
ffffffff810157b5:	c6 05 74 9f fe 3e 01 	movb   $0x1,0x3efe9f74(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff810157bc:	fb                   	sti    
ffffffff810157bd:	eb 75                	jmp    ffffffff81015834 <_ZN2Si5chainEP2Sm+0x204>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
ffffffff810157bf:	49 8b 45 28          	mov    0x28(%r13),%rax
        inline void call_rcu(bool r = false)
        {
            if (ACCESS_ONCE(rcu))
                return;

            rcu = true;
ffffffff810157c3:	41 c6 85 c8 00 00 00 	movb   $0x1,0xc8(%r13)
ffffffff810157ca:	01 

            if (r)
                add_ref();

            Rcu::call (this);
ffffffff810157cb:	4d 8d 7d 18          	lea    0x18(%r13),%r15
ffffffff810157cf:	48 85 c0             	test   %rax,%rax
ffffffff810157d2:	74 05                	je     ffffffff810157d9 <_ZN2Si5chainEP2Sm+0x1a9>
                e->pre_func(e);
ffffffff810157d4:	4c 89 ff             	mov    %r15,%rdi
ffffffff810157d7:	ff d0                	callq  *%rax
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
ffffffff810157d9:	49 83 7d 18 00       	cmpq   $0x0,0x18(%r13)
ffffffff810157de:	75 0c                	jne    ffffffff810157ec <_ZN2Si5chainEP2Sm+0x1bc>
ffffffff810157e0:	48 8b 05 81 a0 fe 3e 	mov    0x3efea081(%rip),%rax        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff810157e7:	4c 39 f8             	cmp    %r15,%rax
ffffffff810157ea:	75 32                	jne    ffffffff8101581e <_ZN2Si5chainEP2Sm+0x1ee>
                trace (0, "warning: rcu element already enqueued");
ffffffff810157ec:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff810157f1:	8b 15 0d 98 fe 3e    	mov    0x3efe980d(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff810157f7:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff810157fb:	48 c7 c7 14 df 01 81 	mov    $0xffffffff8101df14,%rdi
ffffffff81015802:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81015808:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff8101580e:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff81015812:	31 c0                	xor    %eax,%eax
ffffffff81015814:	e8 73 c8 fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff81015819:	e9 08 ff ff ff       	jmpq   ffffffff81015726 <_ZN2Si5chainEP2Sm+0xf6>
                return;
            }

            count ++;
ffffffff8101581e:	48 ff 05 4b a0 fe 3e 	incq   0x3efea04b(%rip)        # ffffffffbffff870 <_ZN3Rcu4nextE+0x10>

           *tail = e;
ffffffff81015825:	4c 89 38             	mov    %r15,(%rax)
            tail = &e->next;
ffffffff81015828:	4c 89 3d 39 a0 fe 3e 	mov    %r15,0x3efea039(%rip)        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff8101582f:	e9 f2 fe ff ff       	jmpq   ffffffff81015726 <_ZN2Si5chainEP2Sm+0xf6>
}
ffffffff81015834:	48 83 c4 18          	add    $0x18,%rsp
ffffffff81015838:	5b                   	pop    %rbx
ffffffff81015839:	5d                   	pop    %rbp
ffffffff8101583a:	41 5c                	pop    %r12
ffffffff8101583c:	41 5d                	pop    %r13
ffffffff8101583e:	41 5e                	pop    %r14
ffffffff81015840:	41 5f                	pop    %r15
ffffffff81015842:	c3                   	retq   

ffffffff81015843 <_GLOBAL__sub_I__ZN2SiC2EP2Smm>:
    private:
        uint16 val;

    public:
        ALWAYS_INLINE
        inline Spinlock() : val (0) {}
ffffffff81015843:	66 c7 05 24 e8 14 00 	movw   $0x0,0x14e824(%rip)        # ffffffff81164070 <_ZL4lock>
ffffffff8101584a:	00 00 
ffffffff8101584c:	c3                   	retq   
ffffffff8101584d:	90                   	nop

ffffffff8101584e <_ZN4SlabC1EP10Slab_cache>:
Slab::Slab (Slab_cache *slab_cache)
    : avail (slab_cache->elem),
      cache (slab_cache),
      prev  (nullptr),
      next  (nullptr),
      head  (nullptr)
ffffffff8101584e:	48 8b 56 28          	mov    0x28(%rsi),%rdx
ffffffff81015852:	48 89 77 08          	mov    %rsi,0x8(%rdi)
ffffffff81015856:	48 c7 47 10 00 00 00 	movq   $0x0,0x10(%rdi)
ffffffff8101585d:	00 
ffffffff8101585e:	48 c7 47 18 00 00 00 	movq   $0x0,0x18(%rdi)
ffffffff81015865:	00 
ffffffff81015866:	48 c7 47 20 00 00 00 	movq   $0x0,0x20(%rdi)
ffffffff8101586d:	00 
ffffffff8101586e:	48 89 17             	mov    %rdx,(%rdi)
ffffffff81015871:	48 8b 46 18          	mov    0x18(%rsi),%rax
ffffffff81015875:	48 05 00 10 00 00    	add    $0x1000,%rax
{
    char *link = reinterpret_cast<char *>(this) + PAGE_SIZE - cache->buff + cache->size;
ffffffff8101587b:	48 2b 46 20          	sub    0x20(%rsi),%rax
ffffffff8101587f:	48 01 f8             	add    %rdi,%rax

    for (unsigned long i = avail; i; i--, link -= cache->buff) {
ffffffff81015882:	48 85 d2             	test   %rdx,%rdx
ffffffff81015885:	74 18                	je     ffffffff8101589f <_ZN4SlabC1EP10Slab_cache+0x51>
        *reinterpret_cast<char **>(link) = head;
ffffffff81015887:	48 8b 4f 20          	mov    0x20(%rdi),%rcx
      next  (nullptr),
      head  (nullptr)
{
    char *link = reinterpret_cast<char *>(this) + PAGE_SIZE - cache->buff + cache->size;

    for (unsigned long i = avail; i; i--, link -= cache->buff) {
ffffffff8101588b:	48 ff ca             	dec    %rdx
        *reinterpret_cast<char **>(link) = head;
ffffffff8101588e:	48 89 08             	mov    %rcx,(%rax)
      next  (nullptr),
      head  (nullptr)
{
    char *link = reinterpret_cast<char *>(this) + PAGE_SIZE - cache->buff + cache->size;

    for (unsigned long i = avail; i; i--, link -= cache->buff) {
ffffffff81015891:	48 8b 4f 08          	mov    0x8(%rdi),%rcx
        *reinterpret_cast<char **>(link) = head;
        head = link;
ffffffff81015895:	48 89 47 20          	mov    %rax,0x20(%rdi)
      next  (nullptr),
      head  (nullptr)
{
    char *link = reinterpret_cast<char *>(this) + PAGE_SIZE - cache->buff + cache->size;

    for (unsigned long i = avail; i; i--, link -= cache->buff) {
ffffffff81015899:	48 2b 41 20          	sub    0x20(%rcx),%rax
ffffffff8101589d:	eb e3                	jmp    ffffffff81015882 <_ZN4SlabC1EP10Slab_cache+0x34>
        *reinterpret_cast<char **>(link) = head;
        head = link;
    }
}
ffffffff8101589f:	c3                   	retq   

ffffffff810158a0 <_ZN10Slab_cacheC1Emj>:
}

ALWAYS_INLINE
static inline mword align_up (mword val, mword align)
{
    val += (align - 1);                 // Expect power-of-2
ffffffff810158a0:	48 83 c6 07          	add    $0x7,%rsi

Slab_cache::Slab_cache (unsigned long elem_size, unsigned elem_align)
          : curr (nullptr),
            head (nullptr),
            size (align_up (elem_size, sizeof (mword))),
            buff (align_up (size + sizeof (mword), elem_align)),
ffffffff810158a4:	89 d1                	mov    %edx,%ecx
            elem ((PAGE_SIZE - sizeof (Slab)) / buff)
ffffffff810158a6:	b8 d8 0f 00 00       	mov    $0xfd8,%eax
}

ALWAYS_INLINE
static inline mword align_dn (mword val, mword align)
{
    val &= ~(align - 1);                // Expect power-of-2
ffffffff810158ab:	48 83 e6 f8          	and    $0xfffffffffffffff8,%rsi
ffffffff810158af:	66 c7 07 00 00       	movw   $0x0,(%rdi)
ffffffff810158b4:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
ffffffff810158bb:	00 
}

ALWAYS_INLINE
static inline mword align_up (mword val, mword align)
{
    val += (align - 1);                 // Expect power-of-2
ffffffff810158bc:	48 8d 54 31 07       	lea    0x7(%rcx,%rsi,1),%rdx
}

ALWAYS_INLINE
static inline mword align_dn (mword val, mword align)
{
    val &= ~(align - 1);                // Expect power-of-2
ffffffff810158c1:	48 f7 d9             	neg    %rcx
ffffffff810158c4:	48 c7 47 10 00 00 00 	movq   $0x0,0x10(%rdi)
ffffffff810158cb:	00 
ffffffff810158cc:	48 89 77 18          	mov    %rsi,0x18(%rdi)
ffffffff810158d0:	48 21 d1             	and    %rdx,%rcx
ffffffff810158d3:	31 d2                	xor    %edx,%edx
ffffffff810158d5:	48 f7 f1             	div    %rcx
ffffffff810158d8:	48 89 4f 20          	mov    %rcx,0x20(%rdi)
ffffffff810158dc:	48 89 47 28          	mov    %rax,0x28(%rdi)
ffffffff810158e0:	c3                   	retq   
ffffffff810158e1:	90                   	nop

ffffffff810158e2 <_ZN10Slab_cache4growER5Quota>:
           elem_size,
           elem_align);
}

void Slab_cache::grow(Quota &quota)
{
ffffffff810158e2:	55                   	push   %rbp
ffffffff810158e3:	53                   	push   %rbx
        char *          head;

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota)
        {
            return Buddy::allocator.alloc (0, quota, Buddy::FILL_0);
ffffffff810158e4:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff810158e9:	52                   	push   %rdx
ffffffff810158ea:	48 89 fb             	mov    %rdi,%rbx
ffffffff810158ed:	48 89 f2             	mov    %rsi,%rdx
ffffffff810158f0:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff810158f7:	31 f6                	xor    %esi,%esi
ffffffff810158f9:	e8 f4 bf fe ff       	callq  ffffffff810018f2 <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
    Slab *slab = new (quota) Slab (this);
ffffffff810158fe:	48 89 de             	mov    %rbx,%rsi
ffffffff81015901:	48 89 c7             	mov    %rax,%rdi
ffffffff81015904:	48 89 c5             	mov    %rax,%rbp
ffffffff81015907:	e8 42 ff ff ff       	callq  ffffffff8101584e <_ZN4SlabC1EP10Slab_cache>

    if (head)
ffffffff8101590c:	48 8b 43 10          	mov    0x10(%rbx),%rax
ffffffff81015910:	48 85 c0             	test   %rax,%rax
ffffffff81015913:	74 04                	je     ffffffff81015919 <_ZN10Slab_cache4growER5Quota+0x37>
        head->prev = slab;
ffffffff81015915:	48 89 68 10          	mov    %rbp,0x10(%rax)

    slab->next = head;
ffffffff81015919:	48 8b 43 10          	mov    0x10(%rbx),%rax
ffffffff8101591d:	48 89 45 18          	mov    %rax,0x18(%rbp)
    head = curr = slab;
ffffffff81015921:	48 89 6b 08          	mov    %rbp,0x8(%rbx)
ffffffff81015925:	48 89 6b 10          	mov    %rbp,0x10(%rbx)
}
ffffffff81015929:	58                   	pop    %rax
ffffffff8101592a:	5b                   	pop    %rbx
ffffffff8101592b:	5d                   	pop    %rbp
ffffffff8101592c:	c3                   	retq   
ffffffff8101592d:	90                   	nop

ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>:

void *Slab_cache::alloc(Quota &quota)
{
ffffffff8101592e:	55                   	push   %rbp
ffffffff8101592f:	53                   	push   %rbx
ffffffff81015930:	48 89 fb             	mov    %rdi,%rbx
ffffffff81015933:	48 83 ec 18          	sub    $0x18,%rsp

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81015937:	9c                   	pushfq 
ffffffff81015938:	58                   	pop    %rax
            return flags & 0x200;
ffffffff81015939:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8101593d:	40 88 c5             	mov    %al,%bpl
ffffffff81015940:	40 80 e5 01          	and    $0x1,%bpl
ffffffff81015944:	74 30                	je     ffffffff81015976 <_ZN10Slab_cache5allocER5Quota+0x48>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81015946:	80 3d e3 9d fe 3e 00 	cmpb   $0x0,0x3efe9de3(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8101594d:	75 1f                	jne    ffffffff8101596e <_ZN10Slab_cache5allocER5Quota+0x40>
ffffffff8101594f:	49 c7 c0 30 08 02 81 	mov    $0xffffffff81020830,%r8
ffffffff81015956:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff8101595b:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81015962:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff81015969:	e9 84 00 00 00       	jmpq   ffffffff810159f2 <_ZN10Slab_cache5allocER5Quota+0xc4>

            asm volatile ("cli" : : : "memory");
ffffffff8101596e:	fa                   	cli    
            preemption = false;
ffffffff8101596f:	c6 05 ba 9d fe 3e 00 	movb   $0x0,0x3efe9dba(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff81015976:	48 89 df             	mov    %rbx,%rdi
ffffffff81015979:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
ffffffff8101597e:	e8 0b b5 fe ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    Lock_guard <Spinlock> guard (lock);

    if (EXPECT_FALSE (!curr))
ffffffff81015983:	48 83 7b 08 00       	cmpq   $0x0,0x8(%rbx)
ffffffff81015988:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
ffffffff8101598d:	75 08                	jne    ffffffff81015997 <_ZN10Slab_cache5allocER5Quota+0x69>
        grow(quota);
ffffffff8101598f:	48 89 df             	mov    %rbx,%rdi
ffffffff81015992:	e8 4b ff ff ff       	callq  ffffffff810158e2 <_ZN10Slab_cache4growER5Quota>

    assert (!curr->full());
ffffffff81015997:	48 8b 53 08          	mov    0x8(%rbx),%rdx
ffffffff8101599b:	48 8b 02             	mov    (%rdx),%rax
ffffffff8101599e:	48 85 c0             	test   %rax,%rax
ffffffff810159a1:	75 26                	jne    ffffffff810159c9 <_ZN10Slab_cache5allocER5Quota+0x9b>
ffffffff810159a3:	49 c7 c0 60 08 02 81 	mov    $0xffffffff81020860,%r8
ffffffff810159aa:	b9 5b 00 00 00       	mov    $0x5b,%ecx
ffffffff810159af:	48 c7 c2 22 07 02 81 	mov    $0xffffffff81020722,%rdx
ffffffff810159b6:	48 c7 c6 8e 07 02 81 	mov    $0xffffffff8102078e,%rsi
ffffffff810159bd:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff810159c4:	e8 87 c5 fe ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
    assert (!curr->next || curr->next->full());
ffffffff810159c9:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
ffffffff810159cd:	48 85 c9             	test   %rcx,%rcx
ffffffff810159d0:	74 2b                	je     ffffffff810159fd <_ZN10Slab_cache5allocER5Quota+0xcf>
ffffffff810159d2:	48 83 39 00          	cmpq   $0x0,(%rcx)
ffffffff810159d6:	74 25                	je     ffffffff810159fd <_ZN10Slab_cache5allocER5Quota+0xcf>
ffffffff810159d8:	49 c7 c0 60 08 02 81 	mov    $0xffffffff81020860,%r8
ffffffff810159df:	b9 5c 00 00 00       	mov    $0x5c,%ecx
ffffffff810159e4:	48 c7 c2 22 07 02 81 	mov    $0xffffffff81020722,%rdx
ffffffff810159eb:	48 c7 c6 9c 07 02 81 	mov    $0xffffffff8102079c,%rsi
ffffffff810159f2:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff810159f9:	31 c0                	xor    %eax,%eax
ffffffff810159fb:	eb c7                	jmp    ffffffff810159c4 <_ZN10Slab_cache5allocER5Quota+0x96>

void *Slab::alloc()
{
    avail--;

    void *link = reinterpret_cast<void *>(head - cache->size);
ffffffff810159fd:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
    }
}

void *Slab::alloc()
{
    avail--;
ffffffff81015a01:	48 ff c8             	dec    %rax
ffffffff81015a04:	48 89 02             	mov    %rax,(%rdx)

    void *link = reinterpret_cast<void *>(head - cache->size);
ffffffff81015a07:	48 8b 42 08          	mov    0x8(%rdx),%rax
ffffffff81015a0b:	48 89 cf             	mov    %rcx,%rdi
    head = *reinterpret_cast<char **>(head);
ffffffff81015a0e:	48 8b 09             	mov    (%rcx),%rcx

void *Slab::alloc()
{
    avail--;

    void *link = reinterpret_cast<void *>(head - cache->size);
ffffffff81015a11:	48 2b 78 18          	sub    0x18(%rax),%rdi
    head = *reinterpret_cast<char **>(head);
ffffffff81015a15:	48 89 4a 20          	mov    %rcx,0x20(%rdx)
    assert (!curr->next || curr->next->full());

    // Allocate from slab
    void *ret = curr->alloc();

    if (EXPECT_FALSE (curr->full()))
ffffffff81015a19:	48 8b 53 08          	mov    0x8(%rbx),%rdx

void *Slab::alloc()
{
    avail--;

    void *link = reinterpret_cast<void *>(head - cache->size);
ffffffff81015a1d:	48 89 f8             	mov    %rdi,%rax
    assert (!curr->next || curr->next->full());

    // Allocate from slab
    void *ret = curr->alloc();

    if (EXPECT_FALSE (curr->full()))
ffffffff81015a20:	48 83 3a 00          	cmpq   $0x0,(%rdx)
ffffffff81015a24:	75 08                	jne    ffffffff81015a2e <_ZN10Slab_cache5allocER5Quota+0x100>
        curr = curr->prev;
ffffffff81015a26:	48 8b 52 10          	mov    0x10(%rdx),%rdx
ffffffff81015a2a:	48 89 53 08          	mov    %rdx,0x8(%rbx)
        }

        ALWAYS_INLINE
        inline void unlock()
        {
            asm volatile ("incb %0" : "=m" (val) : : "memory");
ffffffff81015a2e:	fe 03                	incb   (%rbx)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81015a30:	40 84 ed             	test   %bpl,%bpl
ffffffff81015a33:	74 2d                	je     ffffffff81015a62 <_ZN10Slab_cache5allocER5Quota+0x134>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81015a35:	80 3d f4 9c fe 3e 00 	cmpb   $0x0,0x3efe9cf4(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81015a3c:	74 1c                	je     ffffffff81015a5a <_ZN10Slab_cache5allocER5Quota+0x12c>
ffffffff81015a3e:	49 c7 c0 00 08 02 81 	mov    $0xffffffff81020800,%r8
ffffffff81015a45:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff81015a4a:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81015a51:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff81015a58:	eb 98                	jmp    ffffffff810159f2 <_ZN10Slab_cache5allocER5Quota+0xc4>

            preemption = true;
ffffffff81015a5a:	c6 05 cf 9c fe 3e 01 	movb   $0x1,0x3efe9ccf(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81015a61:	fb                   	sti    

    return ret;
}
ffffffff81015a62:	48 83 c4 18          	add    $0x18,%rsp
ffffffff81015a66:	5b                   	pop    %rbx
ffffffff81015a67:	5d                   	pop    %rbp
ffffffff81015a68:	c3                   	retq   
ffffffff81015a69:	90                   	nop

ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>:

void Slab_cache::free (void *ptr, Quota &quota)
{
ffffffff81015a6a:	41 54                	push   %r12
ffffffff81015a6c:	55                   	push   %rbp
ffffffff81015a6d:	48 89 f5             	mov    %rsi,%rbp
ffffffff81015a70:	53                   	push   %rbx
ffffffff81015a71:	48 89 fb             	mov    %rdi,%rbx
ffffffff81015a74:	48 83 ec 10          	sub    $0x10,%rsp

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81015a78:	9c                   	pushfq 
ffffffff81015a79:	58                   	pop    %rax
            return flags & 0x200;
ffffffff81015a7a:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff81015a7e:	41 88 c4             	mov    %al,%r12b
ffffffff81015a81:	41 80 e4 01          	and    $0x1,%r12b
ffffffff81015a85:	74 30                	je     ffffffff81015ab7 <_ZN10Slab_cache4freeEPvR5Quota+0x4d>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81015a87:	80 3d a2 9c fe 3e 00 	cmpb   $0x0,0x3efe9ca2(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81015a8e:	75 1f                	jne    ffffffff81015aaf <_ZN10Slab_cache4freeEPvR5Quota+0x45>
ffffffff81015a90:	49 c7 c0 30 08 02 81 	mov    $0xffffffff81020830,%r8
ffffffff81015a97:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff81015a9c:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81015aa3:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff81015aaa:	e9 38 01 00 00       	jmpq   ffffffff81015be7 <_ZN10Slab_cache4freeEPvR5Quota+0x17d>

            asm volatile ("cli" : : : "memory");
ffffffff81015aaf:	fa                   	cli    
            preemption = false;
ffffffff81015ab0:	c6 05 79 9c fe 3e 00 	movb   $0x0,0x3efe9c79(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff81015ab7:	48 89 df             	mov    %rbx,%rdi
ffffffff81015aba:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
ffffffff81015abf:	e8 ca b3 fe ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    Lock_guard <Spinlock> guard (lock);

    Slab *slab = reinterpret_cast<Slab *>(reinterpret_cast<mword>(ptr) & ~PAGE_MASK);
ffffffff81015ac4:	48 89 e8             	mov    %rbp,%rax

    bool was_full = slab->full();

    slab->free (ptr);       // Deallocate from slab

    if (EXPECT_FALSE (was_full)) {
ffffffff81015ac7:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx

void Slab_cache::free (void *ptr, Quota &quota)
{
    Lock_guard <Spinlock> guard (lock);

    Slab *slab = reinterpret_cast<Slab *>(reinterpret_cast<mword>(ptr) & ~PAGE_MASK);
ffffffff81015acc:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81015ad2:	48 8b 08             	mov    (%rax),%rcx
    return link;
}

void Slab::free (void *ptr)
{
    avail++;
ffffffff81015ad5:	48 8d 71 01          	lea    0x1(%rcx),%rsi
ffffffff81015ad9:	48 89 30             	mov    %rsi,(%rax)

    char *link = reinterpret_cast<char *>(ptr) + cache->size;
ffffffff81015adc:	48 8b 70 08          	mov    0x8(%rax),%rsi
ffffffff81015ae0:	48 03 6e 18          	add    0x18(%rsi),%rbp
    *reinterpret_cast<char **>(link) = head;
ffffffff81015ae4:	48 8b 70 20          	mov    0x20(%rax),%rsi

    bool was_full = slab->full();

    slab->free (ptr);       // Deallocate from slab

    if (EXPECT_FALSE (was_full)) {
ffffffff81015ae8:	48 85 c9             	test   %rcx,%rcx
void Slab::free (void *ptr)
{
    avail++;

    char *link = reinterpret_cast<char *>(ptr) + cache->size;
    *reinterpret_cast<char **>(link) = head;
ffffffff81015aeb:	48 89 75 00          	mov    %rsi,0x0(%rbp)
    head = link;
ffffffff81015aef:	48 89 68 20          	mov    %rbp,0x20(%rax)

    bool was_full = slab->full();

    slab->free (ptr);       // Deallocate from slab

    if (EXPECT_FALSE (was_full)) {
ffffffff81015af3:	75 5e                	jne    ffffffff81015b53 <_ZN10Slab_cache4freeEPvR5Quota+0xe9>

        // There are full slabs in front of us and we're partial; requeue
        if (slab->prev && slab->prev->full()) {
ffffffff81015af5:	48 8b 50 10          	mov    0x10(%rax),%rdx
ffffffff81015af9:	48 85 d2             	test   %rdx,%rdx
ffffffff81015afc:	74 4c                	je     ffffffff81015b4a <_ZN10Slab_cache4freeEPvR5Quota+0xe0>
ffffffff81015afe:	48 83 3a 00          	cmpq   $0x0,(%rdx)
ffffffff81015b02:	75 46                	jne    ffffffff81015b4a <_ZN10Slab_cache4freeEPvR5Quota+0xe0>

            // Dequeue
            slab->prev->next = slab->next;
ffffffff81015b04:	48 8b 48 18          	mov    0x18(%rax),%rcx
ffffffff81015b08:	48 89 4a 18          	mov    %rcx,0x18(%rdx)
            if (slab->next)
ffffffff81015b0c:	48 8b 50 18          	mov    0x18(%rax),%rdx
ffffffff81015b10:	48 85 d2             	test   %rdx,%rdx
ffffffff81015b13:	74 08                	je     ffffffff81015b1d <_ZN10Slab_cache4freeEPvR5Quota+0xb3>
                slab->next->prev = slab->prev;
ffffffff81015b15:	48 8b 48 10          	mov    0x10(%rax),%rcx
ffffffff81015b19:	48 89 4a 10          	mov    %rcx,0x10(%rdx)

            // Enqueue after curr
            if (curr) {
ffffffff81015b1d:	48 8b 53 08          	mov    0x8(%rbx),%rdx
ffffffff81015b21:	48 85 d2             	test   %rdx,%rdx
ffffffff81015b24:	0f 84 10 01 00 00    	je     ffffffff81015c3a <_ZN10Slab_cache4freeEPvR5Quota+0x1d0>
                slab->prev = curr;
ffffffff81015b2a:	48 89 50 10          	mov    %rdx,0x10(%rax)
                slab->next = curr->next;
ffffffff81015b2e:	48 8b 53 08          	mov    0x8(%rbx),%rdx
ffffffff81015b32:	48 8b 52 18          	mov    0x18(%rdx),%rdx
ffffffff81015b36:	48 89 50 18          	mov    %rdx,0x18(%rax)
                curr->next = curr->next->prev = slab;
ffffffff81015b3a:	48 8b 53 08          	mov    0x8(%rbx),%rdx
ffffffff81015b3e:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
ffffffff81015b42:	48 89 41 10          	mov    %rax,0x10(%rcx)
ffffffff81015b46:	48 89 42 18          	mov    %rax,0x18(%rdx)
                slab->next = head;
                head = head->prev = slab;
            }
        }

        curr = slab;
ffffffff81015b4a:	48 89 43 08          	mov    %rax,0x8(%rbx)
ffffffff81015b4e:	e9 b1 00 00 00       	jmpq   ffffffff81015c04 <_ZN10Slab_cache4freeEPvR5Quota+0x19a>
        }

        ALWAYS_INLINE
        inline bool empty() const
        {
            return avail == cache->elem;
ffffffff81015b53:	48 8b 48 08          	mov    0x8(%rax),%rcx

    } else if (EXPECT_FALSE (slab->empty())) {
ffffffff81015b57:	48 8b 79 28          	mov    0x28(%rcx),%rdi
ffffffff81015b5b:	48 39 38             	cmp    %rdi,(%rax)
ffffffff81015b5e:	0f 85 a0 00 00 00    	jne    ffffffff81015c04 <_ZN10Slab_cache4freeEPvR5Quota+0x19a>

        // There are slabs in front of us and we're empty; requeue
        if (slab->prev) {
ffffffff81015b64:	48 8b 48 10          	mov    0x10(%rax),%rcx
ffffffff81015b68:	48 85 c9             	test   %rcx,%rcx
ffffffff81015b6b:	0f 84 93 00 00 00    	je     ffffffff81015c04 <_ZN10Slab_cache4freeEPvR5Quota+0x19a>

            // Make slab in front of us current if we were current
            if (slab == curr)
ffffffff81015b71:	48 3b 43 08          	cmp    0x8(%rbx),%rax
ffffffff81015b75:	75 04                	jne    ffffffff81015b7b <_ZN10Slab_cache4freeEPvR5Quota+0x111>
                curr = slab->prev;
ffffffff81015b77:	48 89 4b 08          	mov    %rcx,0x8(%rbx)

            // Dequeue
            slab->prev->next = slab->next;
ffffffff81015b7b:	48 8b 48 10          	mov    0x10(%rax),%rcx
ffffffff81015b7f:	48 8b 70 18          	mov    0x18(%rax),%rsi
ffffffff81015b83:	48 89 71 18          	mov    %rsi,0x18(%rcx)
            if (slab->next)
ffffffff81015b87:	48 8b 48 18          	mov    0x18(%rax),%rcx
ffffffff81015b8b:	48 85 c9             	test   %rcx,%rcx
ffffffff81015b8e:	74 08                	je     ffffffff81015b98 <_ZN10Slab_cache4freeEPvR5Quota+0x12e>
                slab->next->prev = slab->prev;
ffffffff81015b90:	48 8b 70 10          	mov    0x10(%rax),%rsi
ffffffff81015b94:	48 89 71 10          	mov    %rsi,0x10(%rcx)

            if (slab->prev->empty() || (head && head->empty())) {
ffffffff81015b98:	48 8b 48 10          	mov    0x10(%rax),%rcx
ffffffff81015b9c:	48 8b 71 08          	mov    0x8(%rcx),%rsi
ffffffff81015ba0:	48 8b 7e 28          	mov    0x28(%rsi),%rdi
ffffffff81015ba4:	48 39 39             	cmp    %rdi,(%rcx)
ffffffff81015ba7:	74 1e                	je     ffffffff81015bc7 <_ZN10Slab_cache4freeEPvR5Quota+0x15d>
ffffffff81015ba9:	48 8b 4b 10          	mov    0x10(%rbx),%rcx
ffffffff81015bad:	48 85 c9             	test   %rcx,%rcx
ffffffff81015bb0:	0f 84 a5 00 00 00    	je     ffffffff81015c5b <_ZN10Slab_cache4freeEPvR5Quota+0x1f1>
ffffffff81015bb6:	48 8b 71 08          	mov    0x8(%rcx),%rsi
ffffffff81015bba:	48 8b 7e 28          	mov    0x28(%rsi),%rdi
ffffffff81015bbe:	48 39 39             	cmp    %rdi,(%rcx)
ffffffff81015bc1:	0f 85 94 00 00 00    	jne    ffffffff81015c5b <_ZN10Slab_cache4freeEPvR5Quota+0x1f1>
                // There are already empty slabs - delete current slab
                assert(head != slab);
ffffffff81015bc7:	48 39 43 10          	cmp    %rax,0x10(%rbx)
ffffffff81015bcb:	75 28                	jne    ffffffff81015bf5 <_ZN10Slab_cache4freeEPvR5Quota+0x18b>
ffffffff81015bcd:	49 c7 c0 d0 07 02 81 	mov    $0xffffffff810207d0,%r8
ffffffff81015bd4:	b9 9c 00 00 00       	mov    $0x9c,%ecx
ffffffff81015bd9:	48 c7 c2 22 07 02 81 	mov    $0xffffffff81020722,%rdx
ffffffff81015be0:	48 c7 c6 be 07 02 81 	mov    $0xffffffff810207be,%rsi
ffffffff81015be7:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81015bee:	31 c0                	xor    %eax,%eax
ffffffff81015bf0:	e8 5b c3 fe ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

        ALWAYS_INLINE
        static inline void destroy(Slab *slab, Quota &quota)
        {
            slab->~Slab();
            Buddy::allocator.free (reinterpret_cast<mword>(slab), quota);
ffffffff81015bf5:	48 89 c6             	mov    %rax,%rsi
ffffffff81015bf8:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff81015bff:	e8 aa b9 fe ff       	callq  ffffffff810015ae <_ZN5Buddy4freeEmR5Quota>
ffffffff81015c04:	fe 03                	incb   (%rbx)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81015c06:	45 84 e4             	test   %r12b,%r12b
ffffffff81015c09:	74 6e                	je     ffffffff81015c79 <_ZN10Slab_cache4freeEPvR5Quota+0x20f>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81015c0b:	80 3d 1e 9b fe 3e 00 	cmpb   $0x0,0x3efe9b1e(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81015c12:	74 1c                	je     ffffffff81015c30 <_ZN10Slab_cache4freeEPvR5Quota+0x1c6>
ffffffff81015c14:	49 c7 c0 00 08 02 81 	mov    $0xffffffff81020800,%r8
ffffffff81015c1b:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff81015c20:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81015c27:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff81015c2e:	eb b7                	jmp    ffffffff81015be7 <_ZN10Slab_cache4freeEPvR5Quota+0x17d>

            preemption = true;
ffffffff81015c30:	c6 05 f9 9a fe 3e 01 	movb   $0x1,0x3efe9af9(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81015c37:	fb                   	sti    
ffffffff81015c38:	eb 3f                	jmp    ffffffff81015c79 <_ZN10Slab_cache4freeEPvR5Quota+0x20f>
                curr->next = curr->next->prev = slab;
            }

            // Enqueue as head
            else {
                slab->prev = nullptr;
ffffffff81015c3a:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
ffffffff81015c41:	00 
                slab->next = head;
ffffffff81015c42:	48 8b 53 10          	mov    0x10(%rbx),%rdx
ffffffff81015c46:	48 89 50 18          	mov    %rdx,0x18(%rax)
                head = head->prev = slab;
ffffffff81015c4a:	48 8b 53 10          	mov    0x10(%rbx),%rdx
ffffffff81015c4e:	48 89 42 10          	mov    %rax,0x10(%rdx)
ffffffff81015c52:	48 89 43 10          	mov    %rax,0x10(%rbx)
ffffffff81015c56:	e9 ef fe ff ff       	jmpq   ffffffff81015b4a <_ZN10Slab_cache4freeEPvR5Quota+0xe0>
                assert(head != slab);
                Slab::destroy (slab, quota);
            } else {
                // There are partial slabs in front of us - requeue empty one
                // Enqueue as head
                slab->prev = nullptr;
ffffffff81015c5b:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
ffffffff81015c62:	00 
                slab->next = head;
ffffffff81015c63:	48 8b 53 10          	mov    0x10(%rbx),%rdx
ffffffff81015c67:	48 89 50 18          	mov    %rdx,0x18(%rax)
                head = head->prev = slab;
ffffffff81015c6b:	48 8b 53 10          	mov    0x10(%rbx),%rdx
ffffffff81015c6f:	48 89 42 10          	mov    %rax,0x10(%rdx)
ffffffff81015c73:	48 89 43 10          	mov    %rax,0x10(%rbx)
ffffffff81015c77:	eb 8b                	jmp    ffffffff81015c04 <_ZN10Slab_cache4freeEPvR5Quota+0x19a>
            }
        }
    }
}
ffffffff81015c79:	48 83 c4 10          	add    $0x10,%rsp
ffffffff81015c7d:	5b                   	pop    %rbx
ffffffff81015c7e:	5d                   	pop    %rbp
ffffffff81015c7f:	41 5c                	pop    %r12
ffffffff81015c81:	c3                   	retq   

ffffffff81015c82 <_ZN2Sm4freeEP8Rcu_elem>:
        bool  rcu;

        static Slab_cache cache;

        static void free (Rcu_elem * a) {
            Sm * sm = static_cast <Sm *>(a);
ffffffff81015c82:	48 8d 47 e8          	lea    -0x18(%rdi),%rax
        mword counter;
        bool  rcu;

        static Slab_cache cache;

        static void free (Rcu_elem * a) {
ffffffff81015c86:	41 55                	push   %r13
ffffffff81015c88:	41 54                	push   %r12
ffffffff81015c8a:	55                   	push   %rbp
            Sm * sm = static_cast <Sm *>(a);
ffffffff81015c8b:	31 ed                	xor    %ebp,%ebp
        mword counter;
        bool  rcu;

        static Slab_cache cache;

        static void free (Rcu_elem * a) {
ffffffff81015c8d:	53                   	push   %rbx
            Sm * sm = static_cast <Sm *>(a);
ffffffff81015c8e:	48 85 ff             	test   %rdi,%rdi
        mword counter;
        bool  rcu;

        static Slab_cache cache;

        static void free (Rcu_elem * a) {
ffffffff81015c91:	56                   	push   %rsi
            Sm * sm = static_cast <Sm *>(a);
ffffffff81015c92:	48 0f 45 e8          	cmovne %rax,%rbp
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff81015c96:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff81015c99:	f0 0f c1 85 8c 00 00 	lock xadd %eax,0x8c(%rbp)
ffffffff81015ca0:	00 

            if (sm->del_ref()) {
ffffffff81015ca1:	ff c8                	dec    %eax
ffffffff81015ca3:	75 39                	jne    ffffffff81015cde <_ZN2Sm4freeEP8Rcu_elem+0x5c>
                Pd *pd = static_cast<Pd *>(static_cast<Space_obj *>(sm->space));
ffffffff81015ca5:	48 8b 45 50          	mov    0x50(%rbp),%rax
ffffffff81015ca9:	31 db                	xor    %ebx,%ebx

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void destroy(Sm *obj, Quota &quota) { obj->~Sm(); cache.free (obj, quota); }
ffffffff81015cab:	48 89 ef             	mov    %rbp,%rdi

        static void free (Rcu_elem * a) {
            Sm * sm = static_cast <Sm *>(a);

            if (sm->del_ref()) {
                Pd *pd = static_cast<Pd *>(static_cast<Space_obj *>(sm->space));
ffffffff81015cae:	48 8d 90 08 fd ff ff 	lea    -0x2f8(%rax),%rdx
ffffffff81015cb5:	48 85 c0             	test   %rax,%rax
ffffffff81015cb8:	48 0f 45 da          	cmovne %rdx,%rbx

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void destroy(Sm *obj, Quota &quota) { obj->~Sm(); cache.free (obj, quota); }
ffffffff81015cbc:	e8 ff 5b ff ff       	callq  ffffffff8100b8c0 <_ZN2SmD1Ev>
                destroy(sm, pd->quota);
            } else {
                sm->rcu = false;
                sm->up();
            }
        }
ffffffff81015cc1:	59                   	pop    %rcx
        static void free (Rcu_elem * a) {
            Sm * sm = static_cast <Sm *>(a);

            if (sm->del_ref()) {
                Pd *pd = static_cast<Pd *>(static_cast<Space_obj *>(sm->space));
                destroy(sm, pd->quota);
ffffffff81015cc2:	48 8d 93 08 03 00 00 	lea    0x308(%rbx),%rdx

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void destroy(Sm *obj, Quota &quota) { obj->~Sm(); cache.free (obj, quota); }
ffffffff81015cc9:	48 89 ee             	mov    %rbp,%rsi
ffffffff81015ccc:	48 c7 c7 80 40 16 81 	mov    $0xffffffff81164080,%rdi
                destroy(sm, pd->quota);
            } else {
                sm->rcu = false;
                sm->up();
            }
        }
ffffffff81015cd3:	5b                   	pop    %rbx
ffffffff81015cd4:	5d                   	pop    %rbp
ffffffff81015cd5:	41 5c                	pop    %r12
ffffffff81015cd7:	41 5d                	pop    %r13

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void destroy(Sm *obj, Quota &quota) { obj->~Sm(); cache.free (obj, quota); }
ffffffff81015cd9:	e9 8c fd ff ff       	jmpq   ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>

            if (sm->del_ref()) {
                Pd *pd = static_cast<Pd *>(static_cast<Space_obj *>(sm->space));
                destroy(sm, pd->quota);
            } else {
                sm->rcu = false;
ffffffff81015cde:	c6 85 c8 00 00 00 00 	movb   $0x0,0xc8(%rbp)
        ALWAYS_INLINE
        inline void up (void (*c)() = nullptr, Sm * si = nullptr)
        {
            Ec *ec;

            {   Lock_guard <Spinlock> guard (lock);
ffffffff81015ce5:	4c 8d ad 8a 00 00 00 	lea    0x8a(%rbp),%r13

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81015cec:	9c                   	pushfq 
ffffffff81015ced:	41 5c                	pop    %r12
            return flags & 0x200;
ffffffff81015cef:	49 c1 ec 09          	shr    $0x9,%r12

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff81015cf3:	41 80 e4 01          	and    $0x1,%r12b
ffffffff81015cf7:	74 30                	je     ffffffff81015d29 <_ZN2Sm4freeEP8Rcu_elem+0xa7>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81015cf9:	80 3d 30 9a fe 3e 00 	cmpb   $0x0,0x3efe9a30(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81015d00:	75 1f                	jne    ffffffff81015d21 <_ZN2Sm4freeEP8Rcu_elem+0x9f>
ffffffff81015d02:	49 c7 c0 b0 08 02 81 	mov    $0xffffffff810208b0,%r8
ffffffff81015d09:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff81015d0e:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81015d15:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff81015d1c:	e9 00 01 00 00       	jmpq   ffffffff81015e21 <_ZN2Sm4freeEP8Rcu_elem+0x19f>

            asm volatile ("cli" : : : "memory");
ffffffff81015d21:	fa                   	cli    
            preemption = false;
ffffffff81015d22:	c6 05 07 9a fe 3e 00 	movb   $0x0,0x3efe9a07(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff81015d29:	4c 89 ef             	mov    %r13,%rdi
ffffffff81015d2c:	e8 5d b1 fe ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff81015d31:	48 8b 9d 90 00 00 00 	mov    0x90(%rbp),%rbx
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff81015d38:	48 85 db             	test   %rbx,%rbx
ffffffff81015d3b:	0f 84 de 01 00 00    	je     ffffffff81015f1f <_ZN2Sm4freeEP8Rcu_elem+0x29d>
ffffffff81015d41:	48 8b 83 b0 02 00 00 	mov    0x2b0(%rbx),%rax
ffffffff81015d48:	48 85 c0             	test   %rax,%rax
ffffffff81015d4b:	0f 84 ce 01 00 00    	je     ffffffff81015f1f <_ZN2Sm4freeEP8Rcu_elem+0x29d>
ffffffff81015d51:	48 8b 93 a8 02 00 00 	mov    0x2a8(%rbx),%rdx
ffffffff81015d58:	48 85 d2             	test   %rdx,%rdx
ffffffff81015d5b:	0f 84 be 01 00 00    	je     ffffffff81015f1f <_ZN2Sm4freeEP8Rcu_elem+0x29d>
                return false;

            if (t == t->next)
ffffffff81015d61:	48 39 c3             	cmp    %rax,%rbx
ffffffff81015d64:	75 0d                	jne    ffffffff81015d73 <_ZN2Sm4freeEP8Rcu_elem+0xf1>
                headptr = nullptr;
ffffffff81015d66:	48 c7 85 90 00 00 00 	movq   $0x0,0x90(%rbp)
ffffffff81015d6d:	00 00 00 00 
ffffffff81015d71:	eb 33                	jmp    ffffffff81015da6 <_ZN2Sm4freeEP8Rcu_elem+0x124>

            else {
                t->next->prev = t->prev;
ffffffff81015d73:	48 89 90 a8 02 00 00 	mov    %rdx,0x2a8(%rax)
                t->prev->next = t->next;
ffffffff81015d7a:	48 8b 83 a8 02 00 00 	mov    0x2a8(%rbx),%rax
ffffffff81015d81:	48 8b 93 b0 02 00 00 	mov    0x2b0(%rbx),%rdx
ffffffff81015d88:	48 89 90 b0 02 00 00 	mov    %rdx,0x2b0(%rax)
                if (t == headptr)
ffffffff81015d8f:	48 3b 9d 90 00 00 00 	cmp    0x90(%rbp),%rbx
ffffffff81015d96:	75 0e                	jne    ffffffff81015da6 <_ZN2Sm4freeEP8Rcu_elem+0x124>
                    headptr = t->next;
ffffffff81015d98:	48 8b 83 b0 02 00 00 	mov    0x2b0(%rbx),%rax
ffffffff81015d9f:	48 89 85 90 00 00 00 	mov    %rax,0x90(%rbp)
            }

            t->next = t->prev = nullptr;
ffffffff81015da6:	48 c7 83 a8 02 00 00 	movq   $0x0,0x2a8(%rbx)
ffffffff81015dad:	00 00 00 00 
ffffffff81015db1:	48 c7 83 b0 02 00 00 	movq   $0x0,0x2b0(%rbx)
ffffffff81015db8:	00 00 00 00 
ffffffff81015dbc:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff81015dbf:	f0 0f c1 83 8c 00 00 	lock xadd %eax,0x8c(%rbx)
ffffffff81015dc6:	00 

                    counter++;
                    return;
                }

                if (EXPECT_FALSE(ec->del_ref())) {
ffffffff81015dc7:	ff c8                	dec    %eax
ffffffff81015dc9:	75 2a                	jne    ffffffff81015df5 <_ZN2Sm4freeEP8Rcu_elem+0x173>
                    delete ec;
ffffffff81015dcb:	48 89 df             	mov    %rbx,%rdi
ffffffff81015dce:	e8 69 e6 fe ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff81015dd3:	48 8b 83 98 02 00 00 	mov    0x298(%rbx),%rax
ffffffff81015dda:	48 89 de             	mov    %rbx,%rsi
ffffffff81015ddd:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff81015de4:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff81015deb:	e8 7a fc ff ff       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
ffffffff81015df0:	e9 3c ff ff ff       	jmpq   ffffffff81015d31 <_ZN2Sm4freeEP8Rcu_elem+0xaf>
ffffffff81015df5:	41 fe 45 00          	incb   0x0(%r13)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81015df9:	45 84 e4             	test   %r12b,%r12b
ffffffff81015dfc:	74 39                	je     ffffffff81015e37 <_ZN2Sm4freeEP8Rcu_elem+0x1b5>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81015dfe:	80 3d 2b 99 fe 3e 00 	cmpb   $0x0,0x3efe992b(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81015e05:	74 28                	je     ffffffff81015e2f <_ZN2Sm4freeEP8Rcu_elem+0x1ad>
ffffffff81015e07:	49 c7 c0 80 08 02 81 	mov    $0xffffffff81020880,%r8
ffffffff81015e0e:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff81015e13:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81015e1a:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff81015e21:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81015e28:	31 c0                	xor    %eax,%eax
ffffffff81015e2a:	e8 21 c1 fe ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            preemption = true;
ffffffff81015e2f:	c6 05 fa 98 fe 3e 01 	movb   $0x1,0x3efe98fa(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81015e36:	fb                   	sti    
    ALWAYS_INLINE
    inline void release(void (*c)()) {
        if (c)
            cont = c;

        Lock_guard <Spinlock> guard(lock);
ffffffff81015e37:	48 8d bb 8a 00 00 00 	lea    0x8a(%rbx),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81015e3e:	9c                   	pushfq 
ffffffff81015e3f:	58                   	pop    %rax
            return flags & 0x200;
ffffffff81015e40:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff81015e44:	41 88 c4             	mov    %al,%r12b
ffffffff81015e47:	41 80 e4 01          	and    $0x1,%r12b
ffffffff81015e4b:	74 15                	je     ffffffff81015e62 <_ZN2Sm4freeEP8Rcu_elem+0x1e0>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81015e4d:	80 3d dc 98 fe 3e 00 	cmpb   $0x0,0x3efe98dc(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81015e54:	0f 84 a8 fe ff ff    	je     ffffffff81015d02 <_ZN2Sm4freeEP8Rcu_elem+0x80>

            asm volatile ("cli" : : : "memory");
ffffffff81015e5a:	fa                   	cli    
            preemption = false;
ffffffff81015e5b:	c6 05 ce 98 fe 3e 00 	movb   $0x0,0x3efe98ce(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff81015e62:	e8 27 b0 fe ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff81015e67:	48 8b ab 90 00 00 00 	mov    0x90(%rbx),%rbp
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff81015e6e:	48 85 ed             	test   %rbp,%rbp
ffffffff81015e71:	0f 84 c2 00 00 00    	je     ffffffff81015f39 <_ZN2Sm4freeEP8Rcu_elem+0x2b7>
ffffffff81015e77:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff81015e7e:	48 85 c0             	test   %rax,%rax
ffffffff81015e81:	0f 84 b2 00 00 00    	je     ffffffff81015f39 <_ZN2Sm4freeEP8Rcu_elem+0x2b7>
ffffffff81015e87:	48 8b 95 b8 00 00 00 	mov    0xb8(%rbp),%rdx
ffffffff81015e8e:	48 85 d2             	test   %rdx,%rdx
ffffffff81015e91:	0f 84 a2 00 00 00    	je     ffffffff81015f39 <_ZN2Sm4freeEP8Rcu_elem+0x2b7>
                return false;

            if (t == t->next)
ffffffff81015e97:	48 39 c5             	cmp    %rax,%rbp
ffffffff81015e9a:	75 0d                	jne    ffffffff81015ea9 <_ZN2Sm4freeEP8Rcu_elem+0x227>
                headptr = nullptr;
ffffffff81015e9c:	48 c7 83 90 00 00 00 	movq   $0x0,0x90(%rbx)
ffffffff81015ea3:	00 00 00 00 
ffffffff81015ea7:	eb 33                	jmp    ffffffff81015edc <_ZN2Sm4freeEP8Rcu_elem+0x25a>

            else {
                t->next->prev = t->prev;
ffffffff81015ea9:	48 89 90 b8 00 00 00 	mov    %rdx,0xb8(%rax)
                t->prev->next = t->next;
ffffffff81015eb0:	48 8b 85 b8 00 00 00 	mov    0xb8(%rbp),%rax
ffffffff81015eb7:	48 8b 95 c0 00 00 00 	mov    0xc0(%rbp),%rdx
ffffffff81015ebe:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
                if (t == headptr)
ffffffff81015ec5:	48 3b ab 90 00 00 00 	cmp    0x90(%rbx),%rbp
ffffffff81015ecc:	75 0e                	jne    ffffffff81015edc <_ZN2Sm4freeEP8Rcu_elem+0x25a>
                    headptr = t->next;
ffffffff81015ece:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff81015ed5:	48 89 83 90 00 00 00 	mov    %rax,0x90(%rbx)
            }

            t->next = t->prev = nullptr;
ffffffff81015edc:	48 c7 85 b8 00 00 00 	movq   $0x0,0xb8(%rbp)
ffffffff81015ee3:	00 00 00 00 
ffffffff81015ee7:	48 c7 85 c0 00 00 00 	movq   $0x0,0xc0(%rbp)
ffffffff81015eee:	00 00 00 00 
ffffffff81015ef2:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff81015ef5:	f0 0f c1 85 8c 00 00 	lock xadd %eax,0x8c(%rbp)
ffffffff81015efc:	00 

        for (Sc *s; dequeue(s = head());) {
            if (EXPECT_FALSE(s->del_ref()) && (this == s->ec)) {
ffffffff81015efd:	ff c8                	dec    %eax
ffffffff81015eff:	75 2b                	jne    ffffffff81015f2c <_ZN2Sm4freeEP8Rcu_elem+0x2aa>
ffffffff81015f01:	48 3b 9d 90 00 00 00 	cmp    0x90(%rbp),%rbx
ffffffff81015f08:	75 22                	jne    ffffffff81015f2c <_ZN2Sm4freeEP8Rcu_elem+0x2aa>
                delete s;
ffffffff81015f0a:	48 89 ef             	mov    %rbp,%rdi
ffffffff81015f0d:	e8 4e 2c ff ff       	callq  ffffffff81008b60 <_ZN2ScD1Ev>
ffffffff81015f12:	48 89 ef             	mov    %rbp,%rdi
ffffffff81015f15:	e8 10 ee ff ff       	callq  ffffffff81014d2a <_ZN2ScdlEPv>
ffffffff81015f1a:	e9 48 ff ff ff       	jmpq   ffffffff81015e67 <_ZN2Sm4freeEP8Rcu_elem+0x1e5>
                    if (si) {
                       if (si->queued()) return;
                       Queue<Si>::enqueue(si);
                    }

                    counter++;
ffffffff81015f1f:	48 ff 85 c0 00 00 00 	incq   0xc0(%rbp)
ffffffff81015f26:	41 fe 45 00          	incb   0x0(%r13)
ffffffff81015f2a:	eb 13                	jmp    ffffffff81015f3f <_ZN2Sm4freeEP8Rcu_elem+0x2bd>
                continue;
            }
            s->remote_enqueue();
ffffffff81015f2c:	48 89 ef             	mov    %rbp,%rdi
ffffffff81015f2f:	e8 2c eb ff ff       	callq  ffffffff81014a60 <_ZN2Sc14remote_enqueueEv>
ffffffff81015f34:	e9 2e ff ff ff       	jmpq   ffffffff81015e67 <_ZN2Sm4freeEP8Rcu_elem+0x1e5>
ffffffff81015f39:	fe 83 8a 00 00 00    	incb   0x8a(%rbx)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81015f3f:	45 84 e4             	test   %r12b,%r12b
ffffffff81015f42:	74 15                	je     ffffffff81015f59 <_ZN2Sm4freeEP8Rcu_elem+0x2d7>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81015f44:	80 3d e5 97 fe 3e 00 	cmpb   $0x0,0x3efe97e5(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81015f4b:	0f 85 b6 fe ff ff    	jne    ffffffff81015e07 <_ZN2Sm4freeEP8Rcu_elem+0x185>

            preemption = true;
ffffffff81015f51:	c6 05 d8 97 fe 3e 01 	movb   $0x1,0x3efe97d8(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81015f58:	fb                   	sti    
                destroy(sm, pd->quota);
            } else {
                sm->rcu = false;
                sm->up();
            }
        }
ffffffff81015f59:	58                   	pop    %rax
ffffffff81015f5a:	5b                   	pop    %rbx
ffffffff81015f5b:	5d                   	pop    %rbp
ffffffff81015f5c:	41 5c                	pop    %r12
ffffffff81015f5e:	41 5d                	pop    %r13
ffffffff81015f60:	c3                   	retq   
ffffffff81015f61:	90                   	nop

ffffffff81015f62 <_ZN2SmC1EP2PdmmPS_m>:
#include "stdio.hpp"

INIT_PRIORITY (PRIO_SLAB)
Slab_cache Sm::cache (sizeof (Sm), 32);

Sm::Sm (Pd *own, mword sel, mword cnt, Sm * s, mword v) : Kobject (SM, static_cast<Space_obj *>(own), sel, 0x3, free), Si (s, v), counter (cnt), rcu (false)
ffffffff81015f62:	41 55                	push   %r13
ffffffff81015f64:	41 54                	push   %r12
ffffffff81015f66:	48 8d 86 f8 02 00 00 	lea    0x2f8(%rsi),%rax
ffffffff81015f6d:	55                   	push   %rbp
ffffffff81015f6e:	53                   	push   %rbx
ffffffff81015f6f:	49 89 cd             	mov    %rcx,%r13
ffffffff81015f72:	48 89 fb             	mov    %rdi,%rbx
ffffffff81015f75:	4c 89 c5             	mov    %r8,%rbp
ffffffff81015f78:	4d 89 cc             	mov    %r9,%r12
ffffffff81015f7b:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff81015f7f:	48 85 f6             	test   %rsi,%rsi
ffffffff81015f82:	be 00 00 00 00       	mov    $0x0,%esi
ffffffff81015f87:	6a 00                	pushq  $0x0
ffffffff81015f89:	48 0f 45 f0          	cmovne %rax,%rsi
ffffffff81015f8d:	48 89 d1             	mov    %rdx,%rcx
ffffffff81015f90:	49 c7 c1 82 5c 01 81 	mov    $0xffffffff81015c82,%r9
ffffffff81015f97:	48 89 fa             	mov    %rdi,%rdx
ffffffff81015f9a:	41 b8 03 00 00 00    	mov    $0x3,%r8d
ffffffff81015fa0:	e8 07 d9 fe ff       	callq  ffffffff810038ac <_ZN3MdbC1EP5SpacemmmPFvP8Rcu_elemES5_>
ffffffff81015fa5:	48 8d bb a0 00 00 00 	lea    0xa0(%rbx),%rdi
ffffffff81015fac:	c6 83 88 00 00 00 04 	movb   $0x4,0x88(%rbx)
    private:
        uint16 val;

    public:
        ALWAYS_INLINE
        inline Spinlock() : val (0) {}
ffffffff81015fb3:	66 c7 83 8a 00 00 00 	movw   $0x0,0x8a(%rbx)
ffffffff81015fba:	00 00 
    private:
        uint32 ref;

    public:
        ALWAYS_INLINE
        inline Refex() : ref (1) {}
ffffffff81015fbc:	c7 83 8c 00 00 00 01 	movl   $0x1,0x8c(%rbx)
ffffffff81015fc3:	00 00 00 
    private:
        T *headptr;

    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}
ffffffff81015fc6:	48 c7 83 90 00 00 00 	movq   $0x0,0x90(%rbx)
ffffffff81015fcd:	00 00 00 00 
ffffffff81015fd1:	4c 89 e2             	mov    %r12,%rdx
ffffffff81015fd4:	48 c7 83 98 00 00 00 	movq   $0x0,0x98(%rbx)
ffffffff81015fdb:	00 00 00 00 
ffffffff81015fdf:	48 89 ee             	mov    %rbp,%rsi
ffffffff81015fe2:	e8 b5 ef ff ff       	callq  ffffffff81014f9c <_ZN2SiC1EP2Smm>
ffffffff81015fe7:	4c 89 ab c0 00 00 00 	mov    %r13,0xc0(%rbx)
ffffffff81015fee:	c6 83 c8 00 00 00 00 	movb   $0x0,0xc8(%rbx)
{
    trace (TRACE_SYSCALL, "SM:%p created (CNT:%lu)", this, cnt);
}
ffffffff81015ff5:	48 83 c4 18          	add    $0x18,%rsp
ffffffff81015ff9:	5b                   	pop    %rbx
ffffffff81015ffa:	5d                   	pop    %rbp
ffffffff81015ffb:	41 5c                	pop    %r12
ffffffff81015ffd:	41 5d                	pop    %r13
ffffffff81015fff:	c3                   	retq   

ffffffff81016000 <_GLOBAL__sub_I.00102__ZN2Sm5cacheE>:

#include "sm.hpp"
#include "stdio.hpp"

INIT_PRIORITY (PRIO_SLAB)
Slab_cache Sm::cache (sizeof (Sm), 32);
ffffffff81016000:	ba 20 00 00 00       	mov    $0x20,%edx
ffffffff81016005:	be d0 00 00 00       	mov    $0xd0,%esi
ffffffff8101600a:	48 c7 c7 80 40 16 81 	mov    $0xffffffff81164080,%rdi
ffffffff81016011:	e9 8a f8 ff ff       	jmpq   ffffffff810158a0 <_ZN10Slab_cacheC1Emj>

ffffffff81016016 <_ZL8free_mdbP8Rcu_elem>:

static void free_mdb(Rcu_elem * e)
{
    Mdb       *mdb   = static_cast<Mdb *>(e);
ffffffff81016016:	48 85 ff             	test   %rdi,%rdi
ffffffff81016019:	74 2b                	je     ffffffff81016046 <_ZL8free_mdbP8Rcu_elem+0x30>
    Space_mem *space = static_cast<Space_mem *>(mdb->space);
ffffffff8101601b:	48 8b 47 38          	mov    0x38(%rdi),%rax
    Pd        *pd    = static_cast<Pd *>(space);
ffffffff8101601f:	31 d2                	xor    %edx,%edx
    }
}

static void free_mdb(Rcu_elem * e)
{
    Mdb       *mdb   = static_cast<Mdb *>(e);
ffffffff81016021:	48 8d 77 e8          	lea    -0x18(%rdi),%rsi
ffffffff81016025:	48 c7 c7 80 38 16 81 	mov    $0xffffffff81163880,%rdi
    Space_mem *space = static_cast<Space_mem *>(mdb->space);
    Pd        *pd    = static_cast<Pd *>(space);
ffffffff8101602c:	48 8d 88 70 ff ff ff 	lea    -0x90(%rax),%rcx
ffffffff81016033:	48 85 c0             	test   %rax,%rax
ffffffff81016036:	48 0f 45 d1          	cmovne %rcx,%rdx

    Mdb::destroy (mdb, pd->quota);
ffffffff8101603a:	48 81 c2 08 03 00 00 	add    $0x308,%rdx
ffffffff81016041:	e9 24 fa ff ff       	jmpq   ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
}

static void free_mdb(Rcu_elem * e)
{
    Mdb       *mdb   = static_cast<Mdb *>(e);
    Space_mem *space = static_cast<Space_mem *>(mdb->space);
ffffffff81016046:	48 8b 04 25 50 00 00 	mov    0x50,%rax
ffffffff8101604d:	00 
ffffffff8101604e:	0f 0b                	ud2    

ffffffff81016050 <_ZN9Space_mem4initER5Quotaj>:

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }
ffffffff81016050:	89 d2                	mov    %edx,%edx
        template <typename T>
        ALWAYS_INLINE
        static inline bool test_set_bit (T &val, unsigned long bit)
        {
            bool ret;
            asm volatile ("lock; bts%z1 %2, %1; setc %0" : "=q" (ret), "+m" (val) : "ir" (bit) : "cc");
ffffffff81016052:	f0 48 0f ab 97 30 02 	lock bts %rdx,0x230(%rdi)
ffffffff81016059:	00 00 
ffffffff8101605b:	0f 92 c0             	setb   %al
mword Space_mem::did_c [4096 / 8 / sizeof(mword)];
mword Space_mem::did_f = 0;

void Space_mem::init (Quota &quota, unsigned cpu)
{
    if (cpus.set (cpu)) {
ffffffff8101605e:	84 c0                	test   %al,%al
ffffffff81016060:	75 46                	jne    ffffffff810160a8 <_ZN9Space_mem4initER5Quotaj+0x58>

mword Space_mem::did_c [4096 / 8 / sizeof(mword)];
mword Space_mem::did_f = 0;

void Space_mem::init (Quota &quota, unsigned cpu)
{
ffffffff81016062:	55                   	push   %rbp
ffffffff81016063:	53                   	push   %rbx
    if (cpus.set (cpu)) {
        loc[cpu].sync_from (quota, Pd::kern.loc[cpu], CPU_LOCAL, SPC_LOCAL);
ffffffff81016064:	48 8d 6c d7 10       	lea    0x10(%rdi,%rdx,8),%rbp

mword Space_mem::did_c [4096 / 8 / sizeof(mword)];
mword Space_mem::did_f = 0;

void Space_mem::init (Quota &quota, unsigned cpu)
{
ffffffff81016069:	50                   	push   %rax
    if (cpus.set (cpu)) {
        loc[cpu].sync_from (quota, Pd::kern.loc[cpu], CPU_LOCAL, SPC_LOCAL);
ffffffff8101606a:	48 8b 14 d5 40 3d 16 	mov    -0x7ee9c2c0(,%rdx,8),%rdx
ffffffff81016071:	81 
ffffffff81016072:	48 89 f3             	mov    %rsi,%rbx
ffffffff81016075:	48 89 ef             	mov    %rbp,%rdi
ffffffff81016078:	49 c7 c0 00 00 00 c0 	mov    $0xffffffffc0000000,%r8
ffffffff8101607f:	48 c7 c1 00 00 e0 bf 	mov    $0xffffffffbfe00000,%rcx
ffffffff81016086:	e8 f7 1e ff ff       	callq  ffffffff81007f82 <_ZN3Hpt9sync_fromER5QuotaS_mm>
        loc[cpu].sync_master_range (quota, LINK_ADDR, CPU_LOCAL);
    }
}
ffffffff8101608b:	41 58                	pop    %r8

void Space_mem::init (Quota &quota, unsigned cpu)
{
    if (cpus.set (cpu)) {
        loc[cpu].sync_from (quota, Pd::kern.loc[cpu], CPU_LOCAL, SPC_LOCAL);
        loc[cpu].sync_master_range (quota, LINK_ADDR, CPU_LOCAL);
ffffffff8101608d:	48 89 de             	mov    %rbx,%rsi
ffffffff81016090:	48 89 ef             	mov    %rbp,%rdi
ffffffff81016093:	48 c7 c1 00 00 e0 bf 	mov    $0xffffffffbfe00000,%rcx
    }
}
ffffffff8101609a:	5b                   	pop    %rbx
ffffffff8101609b:	5d                   	pop    %rbp

void Space_mem::init (Quota &quota, unsigned cpu)
{
    if (cpus.set (cpu)) {
        loc[cpu].sync_from (quota, Pd::kern.loc[cpu], CPU_LOCAL, SPC_LOCAL);
        loc[cpu].sync_master_range (quota, LINK_ADDR, CPU_LOCAL);
ffffffff8101609c:	48 c7 c2 00 00 00 81 	mov    $0xffffffff81000000,%rdx
ffffffff810160a3:	e9 96 1f ff ff       	jmpq   ffffffff8100803e <_ZN3Hpt17sync_master_rangeER5Quotamm>
ffffffff810160a8:	c3                   	retq   
ffffffff810160a9:	90                   	nop

ffffffff810160aa <_ZN9Space_mem6updateER11Quota_guardP3Mdbm>:
    }
}

bool Space_mem::update (Quota_guard &quota, Mdb *mdb, mword r)
{
ffffffff810160aa:	41 57                	push   %r15
ffffffff810160ac:	41 56                	push   %r14
ffffffff810160ae:	41 55                	push   %r13
ffffffff810160b0:	41 54                	push   %r12
ffffffff810160b2:	49 89 d5             	mov    %rdx,%r13
ffffffff810160b5:	55                   	push   %rbp
ffffffff810160b6:	53                   	push   %rbx
ffffffff810160b7:	48 89 fb             	mov    %rdi,%rbx
ffffffff810160ba:	48 83 ec 58          	sub    $0x58,%rsp
    assert (this == mdb->space && this != &Pd::kern);
ffffffff810160be:	48 81 ff 30 3d 16 81 	cmp    $0xffffffff81163d30,%rdi
ffffffff810160c5:	0f 94 c2             	sete   %dl
ffffffff810160c8:	49 3b 7d 50          	cmp    0x50(%r13),%rdi
        loc[cpu].sync_master_range (quota, LINK_ADDR, CPU_LOCAL);
    }
}

bool Space_mem::update (Quota_guard &quota, Mdb *mdb, mword r)
{
ffffffff810160cc:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
    assert (this == mdb->space && this != &Pd::kern);
ffffffff810160d1:	0f 95 c0             	setne  %al
ffffffff810160d4:	08 c2                	or     %al,%dl
ffffffff810160d6:	0f 85 d5 03 00 00    	jne    ffffffff810164b1 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x407>
ffffffff810160dc:	49 89 cc             	mov    %rcx,%r12

    Lock_guard <Spinlock> guard (mdb->node_lock);
ffffffff810160df:	49 8d 7d 30          	lea    0x30(%r13),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff810160e3:	9c                   	pushfq 
ffffffff810160e4:	58                   	pop    %rax
            return flags & 0x200;
ffffffff810160e5:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff810160e9:	24 01                	and    $0x1,%al
ffffffff810160eb:	88 44 24 4e          	mov    %al,0x4e(%rsp)
ffffffff810160ef:	74 30                	je     ffffffff81016121 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x77>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff810160f1:	80 3d 38 96 fe 3e 00 	cmpb   $0x0,0x3efe9638(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff810160f8:	75 1f                	jne    ffffffff81016119 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x6f>
ffffffff810160fa:	49 c7 c0 a0 09 02 81 	mov    $0xffffffff810209a0,%r8
ffffffff81016101:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff81016106:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8101610d:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff81016114:	e9 7d 03 00 00       	jmpq   ffffffff81016496 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x3ec>

            asm volatile ("cli" : : : "memory");
ffffffff81016119:	fa                   	cli    
            preemption = false;
ffffffff8101611a:	c6 05 0f 96 fe 3e 00 	movb   $0x0,0x3efe960f(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff81016121:	e8 68 ad fe ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>

    Paddr p = mdb->node_phys << PAGE_BITS;
ffffffff81016126:	49 8b 45 58          	mov    0x58(%r13),%rax
    mword b = mdb->node_base << PAGE_BITS;
    mword o = mdb->node_order;
    mword a = mdb->node_attr & ~r;
ffffffff8101612a:	4c 89 e5             	mov    %r12,%rbp
ffffffff8101612d:	48 f7 d5             	not    %rbp
ffffffff81016130:	49 23 6d 70          	and    0x70(%r13),%rbp
{
    assert (this == mdb->space && this != &Pd::kern);

    Lock_guard <Spinlock> guard (mdb->node_lock);

    Paddr p = mdb->node_phys << PAGE_BITS;
ffffffff81016134:	48 c1 e0 0c          	shl    $0xc,%rax
ffffffff81016138:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    mword b = mdb->node_base << PAGE_BITS;
ffffffff8101613d:	49 8b 45 60          	mov    0x60(%r13),%rax
ffffffff81016141:	48 c1 e0 0c          	shl    $0xc,%rax
ffffffff81016145:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
    mword o = mdb->node_order;
ffffffff8101614a:	49 8b 45 68          	mov    0x68(%r13),%rax
ffffffff8101614e:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    mword a = mdb->node_attr & ~r;
    mword s = mdb->node_sub;
ffffffff81016153:	49 8b 85 80 00 00 00 	mov    0x80(%r13),%rax

    if (s & 1 && Dpt::ord != ~0UL) {
ffffffff8101615a:	a8 01                	test   $0x1,%al

    Paddr p = mdb->node_phys << PAGE_BITS;
    mword b = mdb->node_base << PAGE_BITS;
    mword o = mdb->node_order;
    mword a = mdb->node_attr & ~r;
    mword s = mdb->node_sub;
ffffffff8101615c:	48 89 44 24 28       	mov    %rax,0x28(%rsp)

    if (s & 1 && Dpt::ord != ~0UL) {
ffffffff81016161:	75 0c                	jne    ffffffff8101616f <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0xc5>

            dpt.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (Dpt::ord + PAGE_BITS)), a, r ? Dpt::TYPE_DN : Dpt::TYPE_UP);
        }
    }

    if (s & 2) {
ffffffff81016163:	f6 44 24 28 02       	testb  $0x2,0x28(%rsp)
ffffffff81016168:	75 72                	jne    ffffffff810161dc <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x132>
ffffffff8101616a:	e9 81 01 00 00       	jmpq   ffffffff810162f0 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x246>
    mword b = mdb->node_base << PAGE_BITS;
    mword o = mdb->node_order;
    mword a = mdb->node_attr & ~r;
    mword s = mdb->node_sub;

    if (s & 1 && Dpt::ord != ~0UL) {
ffffffff8101616f:	4c 8b 35 72 ba 00 00 	mov    0xba72(%rip),%r14        # ffffffff81021be8 <_ZN3Dpt3ordE>
ffffffff81016176:	49 83 fe ff          	cmp    $0xffffffffffffffff,%r14
ffffffff8101617a:	74 e7                	je     ffffffff81016163 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0xb9>
ffffffff8101617c:	4c 3b 74 24 08       	cmp    0x8(%rsp),%r14
ffffffff81016181:	4c 0f 47 74 24 08    	cmova  0x8(%rsp),%r14
        mword ord = min (o, Dpt::ord);
        for (unsigned long i = 0; i < 1UL << (o - ord); i++) {
ffffffff81016187:	45 31 ff             	xor    %r15d,%r15d
    bool update(Quota &quota, E, mword, E, mword, Type = TYPE_UP, bool set_cow = false);

    void clear(Quota &quota, bool (*) (Paddr, mword, unsigned) = nullptr, bool (*) (unsigned, mword) = nullptr);

    bool check(Quota_guard &qg, mword o) {
        return qg.check(o / (4096 / sizeof (E)) + L);
ffffffff8101618a:	4c 89 f0             	mov    %r14,%rax
ffffffff8101618d:	48 c1 e8 09          	shr    $0x9,%rax
ffffffff81016191:	48 83 c0 04          	add    $0x4,%rax
ffffffff81016195:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
ffffffff8101619a:	8b 44 24 08          	mov    0x8(%rsp),%eax
ffffffff8101619e:	44 29 f0             	sub    %r14d,%eax
ffffffff810161a1:	89 44 24 38          	mov    %eax,0x38(%rsp)
ffffffff810161a5:	8a 4c 24 38          	mov    0x38(%rsp),%cl
ffffffff810161a9:	4c 89 f8             	mov    %r15,%rax
ffffffff810161ac:	48 d3 e8             	shr    %cl,%rax
ffffffff810161af:	48 85 c0             	test   %rax,%rax
ffffffff810161b2:	75 af                	jne    ffffffff81016163 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0xb9>
            if (!r && !dpt.check(quota, ord)) {
ffffffff810161b4:	4d 85 e4             	test   %r12,%r12
ffffffff810161b7:	0f 85 10 03 00 00    	jne    ffffffff810164cd <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x423>
ffffffff810161bd:	48 8b 74 24 30       	mov    0x30(%rsp),%rsi
ffffffff810161c2:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
ffffffff810161c7:	e8 4c 9c ff ff       	callq  ffffffff8100fe18 <_ZN11Quota_guard5checkEm>
ffffffff810161cc:	84 c0                	test   %al,%al
ffffffff810161ce:	41 88 c2             	mov    %al,%r10b
ffffffff810161d1:	0f 85 f6 02 00 00    	jne    ffffffff810164cd <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x423>
ffffffff810161d7:	e9 81 02 00 00       	jmpq   ffffffff8101645d <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x3b3>
            dpt.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (Dpt::ord + PAGE_BITS)), a, r ? Dpt::TYPE_DN : Dpt::TYPE_UP);
        }
    }

    if (s & 2) {
        if (Vmcb::has_npt()) {
ffffffff810161dc:	f6 05 3d 9b fe 3e 01 	testb  $0x1,0x3efe9b3d(%rip)        # ffffffffbffffd20 <_ZN4Vmcb11svm_featureE>
ffffffff810161e3:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
ffffffff810161e8:	74 7f                	je     ffffffff81016269 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x1bf>
ffffffff810161ea:	48 39 05 e7 b9 00 00 	cmp    %rax,0xb9e7(%rip)        # ffffffff81021bd8 <_ZN3Hpt3ordE>
ffffffff810161f1:	49 89 c7             	mov    %rax,%r15
    }

    ALWAYS_INLINE
    static inline mword hw_attr(mword a) {
        return a ? a | HPT_D | HPT_A | HPT_U | HPT_P : 0;
ffffffff810161f4:	48 89 ea             	mov    %rbp,%rdx
ffffffff810161f7:	4c 0f 46 3d d9 b9 00 	cmovbe 0xb9d9(%rip),%r15        # ffffffff81021bd8 <_ZN3Hpt3ordE>
ffffffff810161fe:	00 
ffffffff810161ff:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff81016204:	48 83 ca 65          	or     $0x65,%rdx
ffffffff81016208:	48 85 ed             	test   %rbp,%rbp
ffffffff8101620b:	48 0f 45 c2          	cmovne %rdx,%rax
            mword ord = min (o, Hpt::ord);
            for (unsigned long i = 0; i < 1UL << (o - ord); i++) {
ffffffff8101620f:	45 31 f6             	xor    %r14d,%r14d
ffffffff81016212:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
ffffffff81016217:	4c 89 f8             	mov    %r15,%rax
ffffffff8101621a:	48 c1 e8 09          	shr    $0x9,%rax
ffffffff8101621e:	48 83 c0 04          	add    $0x4,%rax
ffffffff81016222:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
ffffffff81016227:	8b 44 24 08          	mov    0x8(%rsp),%eax
ffffffff8101622b:	44 29 f8             	sub    %r15d,%eax
ffffffff8101622e:	89 44 24 40          	mov    %eax,0x40(%rsp)
ffffffff81016232:	8a 4c 24 40          	mov    0x40(%rsp),%cl
ffffffff81016236:	4c 89 f0             	mov    %r14,%rax
ffffffff81016239:	48 d3 e8             	shr    %cl,%rax
ffffffff8101623c:	48 85 c0             	test   %rax,%rax
ffffffff8101623f:	75 67                	jne    ffffffff810162a8 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x1fe>
                if (!r && !npt.check(quota, ord)) {
ffffffff81016241:	4d 85 e4             	test   %r12,%r12
ffffffff81016244:	0f 85 d9 02 00 00    	jne    ffffffff81016523 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x479>
ffffffff8101624a:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
ffffffff8101624f:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
ffffffff81016254:	e8 bf 9b ff ff       	callq  ffffffff8100fe18 <_ZN11Quota_guard5checkEm>
ffffffff81016259:	84 c0                	test   %al,%al
ffffffff8101625b:	41 88 c2             	mov    %al,%r10b
ffffffff8101625e:	0f 85 bf 02 00 00    	jne    ffffffff81016523 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x479>
ffffffff81016264:	e9 f4 01 00 00       	jmpq   ffffffff8101645d <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x3b3>
ffffffff81016269:	48 39 05 70 b9 00 00 	cmp    %rax,0xb970(%rip)        # ffffffff81021be0 <_ZN3Ept3ordE>
ffffffff81016270:	49 89 c6             	mov    %rax,%r14
ffffffff81016273:	4c 0f 46 35 65 b9 00 	cmovbe 0xb965(%rip),%r14        # ffffffff81021be0 <_ZN3Ept3ordE>
ffffffff8101627a:	00 

                npt.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (ord + PAGE_BITS)), Hpt::hw_attr (a), r ? Hpt::TYPE_DN : Hpt::TYPE_UP);
            }
        } else {
            mword ord = min (o, Ept::ord);
            for (unsigned long i = 0; i < 1UL << (o - ord); i++) {
ffffffff8101627b:	45 31 ff             	xor    %r15d,%r15d
ffffffff8101627e:	4c 89 f0             	mov    %r14,%rax
ffffffff81016281:	48 c1 e8 09          	shr    $0x9,%rax
ffffffff81016285:	48 83 c0 04          	add    $0x4,%rax
ffffffff81016289:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
ffffffff8101628e:	8b 44 24 08          	mov    0x8(%rsp),%eax
ffffffff81016292:	44 29 f0             	sub    %r14d,%eax
ffffffff81016295:	89 44 24 38          	mov    %eax,0x38(%rsp)
ffffffff81016299:	8a 4c 24 38          	mov    0x38(%rsp),%cl
ffffffff8101629d:	4d 89 f9             	mov    %r15,%r9
ffffffff810162a0:	49 d3 e9             	shr    %cl,%r9
ffffffff810162a3:	4d 85 c9             	test   %r9,%r9
ffffffff810162a6:	74 16                	je     ffffffff810162be <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x214>
                }

                ept.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (ord + PAGE_BITS)), Ept::hw_attr (a, mdb->node_type), r ? Ept::TYPE_DN : Ept::TYPE_UP);
            }
        }
        if (r)
ffffffff810162a8:	4d 85 e4             	test   %r12,%r12
ffffffff810162ab:	74 43                	je     ffffffff810162f0 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x246>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }
ffffffff810162ad:	48 8b 83 30 02 00 00 	mov    0x230(%rbx),%rax
ffffffff810162b4:	f0 48 09 83 40 02 00 	lock or %rax,0x240(%rbx)
ffffffff810162bb:	00 
ffffffff810162bc:	eb 32                	jmp    ffffffff810162f0 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x246>
                npt.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (ord + PAGE_BITS)), Hpt::hw_attr (a), r ? Hpt::TYPE_DN : Hpt::TYPE_UP);
            }
        } else {
            mword ord = min (o, Ept::ord);
            for (unsigned long i = 0; i < 1UL << (o - ord); i++) {
                if (!r && !ept.check(quota, ord)) {
ffffffff810162be:	4d 85 e4             	test   %r12,%r12
ffffffff810162c1:	0f 85 a8 02 00 00    	jne    ffffffff8101656f <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x4c5>
ffffffff810162c7:	48 8b 74 24 30       	mov    0x30(%rsp),%rsi
ffffffff810162cc:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
ffffffff810162d1:	4c 89 4c 24 40       	mov    %r9,0x40(%rsp)
ffffffff810162d6:	e8 3d 9b ff ff       	callq  ffffffff8100fe18 <_ZN11Quota_guard5checkEm>
ffffffff810162db:	84 c0                	test   %al,%al
ffffffff810162dd:	41 88 c2             	mov    %al,%r10b
ffffffff810162e0:	4c 8b 4c 24 40       	mov    0x40(%rsp),%r9
ffffffff810162e5:	0f 85 84 02 00 00    	jne    ffffffff8101656f <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x4c5>
ffffffff810162eb:	e9 6d 01 00 00       	jmpq   ffffffff8101645d <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x3b3>
        }
        if (r)
            gtlb.merge (cpus);
    }

    if (s & 4) {
ffffffff810162f0:	f6 44 24 28 04       	testb  $0x4,0x28(%rsp)
ffffffff810162f5:	74 0e                	je     ffffffff81016305 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x25b>
        if (a)
            a |= Hpt::HPT_PWT;
ffffffff810162f7:	48 89 e8             	mov    %rbp,%rax
ffffffff810162fa:	48 83 c8 08          	or     $0x8,%rax
ffffffff810162fe:	48 85 ed             	test   %rbp,%rbp
ffffffff81016301:	48 0f 45 e8          	cmovne %rax,%rbp
    }


    if ((mdb->node_base >= USER_ADDR >> PAGE_BITS) ||
ffffffff81016305:	49 8b 55 60          	mov    0x60(%r13),%rdx
ffffffff81016309:	48 b8 fe ff ff ff 07 	movabs $0x7fffffffe,%rax
ffffffff81016310:	00 00 00 
ffffffff81016313:	48 39 c2             	cmp    %rax,%rdx
ffffffff81016316:	76 08                	jbe    ffffffff81016320 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x276>
        (mdb->node_base + (1UL << o) > USER_ADDR >> PAGE_BITS) ||
        (mdb->node_base + (1UL << o) <= mdb->node_base))
        return false;
ffffffff81016318:	45 31 d2             	xor    %r10d,%r10d
ffffffff8101631b:	e9 44 01 00 00       	jmpq   ffffffff81016464 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x3ba>
            a |= Hpt::HPT_PWT;
    }


    if ((mdb->node_base >= USER_ADDR >> PAGE_BITS) ||
        (mdb->node_base + (1UL << o) > USER_ADDR >> PAGE_BITS) ||
ffffffff81016320:	8a 4c 24 08          	mov    0x8(%rsp),%cl
ffffffff81016324:	b8 01 00 00 00       	mov    $0x1,%eax
ffffffff81016329:	48 d3 e0             	shl    %cl,%rax
ffffffff8101632c:	48 01 d0             	add    %rdx,%rax
ffffffff8101632f:	48 39 d0             	cmp    %rdx,%rax
ffffffff81016332:	76 e4                	jbe    ffffffff81016318 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x26e>
ffffffff81016334:	48 ba ff ff ff ff 07 	movabs $0x7ffffffff,%rdx
ffffffff8101633b:	00 00 00 
ffffffff8101633e:	48 39 d0             	cmp    %rdx,%rax
ffffffff81016341:	77 d5                	ja     ffffffff81016318 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x26e>
ffffffff81016343:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
ffffffff81016348:	48 39 05 89 b8 00 00 	cmp    %rax,0xb889(%rip)        # ffffffff81021bd8 <_ZN3Hpt3ordE>
ffffffff8101634f:	48 89 ea             	mov    %rbp,%rdx
ffffffff81016352:	49 89 c7             	mov    %rax,%r15
ffffffff81016355:	4c 0f 46 3d 7b b8 00 	cmovbe 0xb87b(%rip),%r15        # ffffffff81021bd8 <_ZN3Hpt3ordE>
ffffffff8101635c:	00 
ffffffff8101635d:	48 83 ca 65          	or     $0x65,%rdx
ffffffff81016361:	4c 89 f8             	mov    %r15,%rax
ffffffff81016364:	48 c1 e8 09          	shr    $0x9,%rax
ffffffff81016368:	48 83 c0 04          	add    $0x4,%rax
ffffffff8101636c:	48 85 ed             	test   %rbp,%rbp
ffffffff8101636f:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
ffffffff81016374:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff81016379:	48 0f 45 c2          	cmovne %rdx,%rax
        return false;

    mword ord = min (o, Hpt::ord);
    bool f = false;

    for (unsigned long i = 0; i < 1UL << (o - ord); i++) {
ffffffff8101637d:	45 31 f6             	xor    %r14d,%r14d
        (mdb->node_base + (1UL << o) > USER_ADDR >> PAGE_BITS) ||
        (mdb->node_base + (1UL << o) <= mdb->node_base))
        return false;

    mword ord = min (o, Hpt::ord);
    bool f = false;
ffffffff81016380:	31 ed                	xor    %ebp,%ebp
ffffffff81016382:	48 89 44 24 28       	mov    %rax,0x28(%rsp)

    for (unsigned long i = 0; i < 1UL << (o - ord); i++) {
ffffffff81016387:	8b 44 24 08          	mov    0x8(%rsp),%eax
ffffffff8101638b:	44 29 f8             	sub    %r15d,%eax
ffffffff8101638e:	89 44 24 38          	mov    %eax,0x38(%rsp)
ffffffff81016392:	8a 4c 24 38          	mov    0x38(%rsp),%cl
ffffffff81016396:	4c 89 f2             	mov    %r14,%rdx
ffffffff81016399:	44 89 f8             	mov    %r15d,%eax
ffffffff8101639c:	48 d3 ea             	shr    %cl,%rdx
ffffffff8101639f:	48 85 d2             	test   %rdx,%rdx
ffffffff810163a2:	75 2f                	jne    ffffffff810163d3 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x329>
        if (!r && !hpt.check(quota, ord)) {
ffffffff810163a4:	4d 85 e4             	test   %r12,%r12
ffffffff810163a7:	0f 85 21 02 00 00    	jne    ffffffff810165ce <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x524>
ffffffff810163ad:	48 8b 74 24 30       	mov    0x30(%rsp),%rsi
ffffffff810163b2:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
ffffffff810163b7:	e8 5c 9a ff ff       	callq  ffffffff8100fe18 <_ZN11Quota_guard5checkEm>
ffffffff810163bc:	84 c0                	test   %al,%al
ffffffff810163be:	0f 85 0a 02 00 00    	jne    ffffffff810165ce <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x524>
            Cpu::hazard |= HZD_OOM;
ffffffff810163c4:	83 0d 35 8c fe 3e 20 	orl    $0x20,0x3efe8c35(%rip)        # ffffffffbffff000 <_ZN3Cpu6hazardE>
            return f;
ffffffff810163cb:	41 88 ea             	mov    %bpl,%r10b
ffffffff810163ce:	e9 91 00 00 00       	jmpq   ffffffff81016464 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x3ba>
        }

        f |= hpt.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (ord + PAGE_BITS)), Hpt::hw_attr (a), r ? Hpt::TYPE_DN : Hpt::TYPE_UP);
    }

    if (r || f) {
ffffffff810163d3:	4d 85 e4             	test   %r12,%r12
ffffffff810163d6:	41 0f 95 c2          	setne  %r10b
ffffffff810163da:	41 08 ea             	or     %bpl,%r10b
ffffffff810163dd:	0f 84 35 ff ff ff    	je     ffffffff81016318 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x26e>
                if (!r && !loc[j].check(quota, ord)) {
                    Cpu::hazard |= HZD_OOM;
                    return (r || f);
                }

                loc[j].update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (ord + PAGE_BITS)), Hpt::hw_attr (a), Hpt::TYPE_DF);
ffffffff810163e3:	83 c0 0c             	add    $0xc,%eax
ffffffff810163e6:	48 8d 6b 10          	lea    0x10(%rbx),%rbp
ffffffff810163ea:	4c 8d b3 10 02 00 00 	lea    0x210(%rbx),%r14
ffffffff810163f1:	89 44 24 40          	mov    %eax,0x40(%rsp)
    }

    if (r || f) {

        for (unsigned j = 0; j < sizeof (loc) / sizeof (*loc); j++) {
            if (!loc[j].addr())
ffffffff810163f5:	48 f7 45 00 00 f0 ff 	testq  $0xfffffffffffff000,0x0(%rbp)
ffffffff810163fc:	ff 
ffffffff810163fd:	75 1a                	jne    ffffffff81016419 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x36f>
ffffffff810163ff:	48 83 c5 08          	add    $0x8,%rbp
        f |= hpt.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (ord + PAGE_BITS)), Hpt::hw_attr (a), r ? Hpt::TYPE_DN : Hpt::TYPE_UP);
    }

    if (r || f) {

        for (unsigned j = 0; j < sizeof (loc) / sizeof (*loc); j++) {
ffffffff81016403:	4c 39 f5             	cmp    %r14,%rbp
ffffffff81016406:	75 ed                	jne    ffffffff810163f5 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x34b>
ffffffff81016408:	48 8b 83 30 02 00 00 	mov    0x230(%rbx),%rax
ffffffff8101640f:	f0 48 09 83 38 02 00 	lock or %rax,0x238(%rbx)
ffffffff81016416:	00 
ffffffff81016417:	eb 4b                	jmp    ffffffff81016464 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x3ba>
ffffffff81016419:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
ffffffff81016420:	00 00 
            if (!loc[j].addr())
                continue;

            for (unsigned long i = 0; i < 1UL << (o - ord); i++) {
ffffffff81016422:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
ffffffff81016427:	8a 4c 24 38          	mov    0x38(%rsp),%cl
ffffffff8101642b:	48 d3 e8             	shr    %cl,%rax
ffffffff8101642e:	48 85 c0             	test   %rax,%rax
ffffffff81016431:	75 cc                	jne    ffffffff810163ff <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x355>
                if (!r && !loc[j].check(quota, ord)) {
ffffffff81016433:	4d 85 e4             	test   %r12,%r12
ffffffff81016436:	0f 85 df 01 00 00    	jne    ffffffff8101661b <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x571>
ffffffff8101643c:	48 8b 74 24 30       	mov    0x30(%rsp),%rsi
ffffffff81016441:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
ffffffff81016446:	44 88 54 24 4f       	mov    %r10b,0x4f(%rsp)
ffffffff8101644b:	e8 c8 99 ff ff       	callq  ffffffff8100fe18 <_ZN11Quota_guard5checkEm>
ffffffff81016450:	84 c0                	test   %al,%al
ffffffff81016452:	44 8a 54 24 4f       	mov    0x4f(%rsp),%r10b
ffffffff81016457:	0f 85 be 01 00 00    	jne    ffffffff8101661b <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x571>
                    Cpu::hazard |= HZD_OOM;
ffffffff8101645d:	83 0d 9c 8b fe 3e 20 	orl    $0x20,0x3efe8b9c(%rip)        # ffffffffbffff000 <_ZN3Cpu6hazardE>
        }

        ALWAYS_INLINE
        inline void unlock()
        {
            asm volatile ("incb %0" : "=m" (val) : : "memory");
ffffffff81016464:	41 fe 45 30          	incb   0x30(%r13)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81016468:	80 7c 24 4e 00       	cmpb   $0x0,0x4e(%rsp)
ffffffff8101646d:	0f 84 f5 01 00 00    	je     ffffffff81016668 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x5be>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81016473:	80 3d b6 92 fe 3e 00 	cmpb   $0x0,0x3efe92b6(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8101647a:	74 28                	je     ffffffff810164a4 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x3fa>
ffffffff8101647c:	49 c7 c0 70 09 02 81 	mov    $0xffffffff81020970,%r8
ffffffff81016483:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff81016488:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8101648f:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff81016496:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8101649d:	31 c0                	xor    %eax,%eax
ffffffff8101649f:	e8 ac ba fe ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            preemption = true;
ffffffff810164a4:	c6 05 85 92 fe 3e 01 	movb   $0x1,0x3efe9285(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff810164ab:	fb                   	sti    
ffffffff810164ac:	e9 b7 01 00 00       	jmpq   ffffffff81016668 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x5be>
    }
}

bool Space_mem::update (Quota_guard &quota, Mdb *mdb, mword r)
{
    assert (this == mdb->space && this != &Pd::kern);
ffffffff810164b1:	49 c7 c0 d0 09 02 81 	mov    $0xffffffff810209d0,%r8
ffffffff810164b8:	b9 2d 00 00 00       	mov    $0x2d,%ecx
ffffffff810164bd:	48 c7 c2 d3 08 02 81 	mov    $0xffffffff810208d3,%rdx
ffffffff810164c4:	48 c7 c6 44 09 02 81 	mov    $0xffffffff81020944,%rsi
ffffffff810164cb:	eb c9                	jmp    ffffffff81016496 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x3ec>
            if (!r && !dpt.check(quota, ord)) {
                Cpu::hazard |= HZD_OOM;
                return false;
            }

            dpt.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (Dpt::ord + PAGE_BITS)), a, r ? Dpt::TYPE_DN : Dpt::TYPE_UP);
ffffffff810164cd:	8b 05 15 b7 00 00    	mov    0xb715(%rip),%eax        # ffffffff81021be8 <_ZN3Dpt3ordE>
ffffffff810164d3:	31 f6                	xor    %esi,%esi
ffffffff810164d5:	4d 85 e4             	test   %r12,%r12
ffffffff810164d8:	40 0f 95 c6          	setne  %sil
ffffffff810164dc:	4c 89 fa             	mov    %r15,%rdx
ffffffff810164df:	48 8d bb 18 02 00 00 	lea    0x218(%rbx),%rdi
ffffffff810164e6:	49 89 e9             	mov    %rbp,%r9
ffffffff810164e9:	8d 48 0c             	lea    0xc(%rax),%ecx
ffffffff810164ec:	4c 89 f8             	mov    %r15,%rax
    mword a = mdb->node_attr & ~r;
    mword s = mdb->node_sub;

    if (s & 1 && Dpt::ord != ~0UL) {
        mword ord = min (o, Dpt::ord);
        for (unsigned long i = 0; i < 1UL << (o - ord); i++) {
ffffffff810164ef:	49 ff c7             	inc    %r15
            if (!r && !dpt.check(quota, ord)) {
                Cpu::hazard |= HZD_OOM;
                return false;
            }

            dpt.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (Dpt::ord + PAGE_BITS)), a, r ? Dpt::TYPE_DN : Dpt::TYPE_UP);
ffffffff810164f2:	48 d3 e0             	shl    %cl,%rax
ffffffff810164f5:	41 8d 4e 0c          	lea    0xc(%r14),%ecx
ffffffff810164f9:	48 d3 e2             	shl    %cl,%rdx
ffffffff810164fc:	48 03 54 24 20       	add    0x20(%rsp),%rdx
ffffffff81016501:	6a 00                	pushq  $0x0
ffffffff81016503:	56                   	push   %rsi
ffffffff81016504:	48 8b 74 24 28       	mov    0x28(%rsp),%rsi
ffffffff81016509:	4c 89 f1             	mov    %r14,%rcx
ffffffff8101650c:	4c 8d 04 30          	lea    (%rax,%rsi,1),%r8
ffffffff81016510:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
ffffffff81016515:	e8 56 c0 ff ff       	callq  ffffffff81012570 <_ZN3PteI3DptyLj4ELj9ELb1EE6updateER5QuotaymymNS1_4TypeEb>
    mword a = mdb->node_attr & ~r;
    mword s = mdb->node_sub;

    if (s & 1 && Dpt::ord != ~0UL) {
        mword ord = min (o, Dpt::ord);
        for (unsigned long i = 0; i < 1UL << (o - ord); i++) {
ffffffff8101651a:	41 59                	pop    %r9
ffffffff8101651c:	41 5a                	pop    %r10
ffffffff8101651e:	e9 82 fc ff ff       	jmpq   ffffffff810161a5 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0xfb>
                if (!r && !npt.check(quota, ord)) {
                    Cpu::hazard |= HZD_OOM;
                    return false;
                }

                npt.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (ord + PAGE_BITS)), Hpt::hw_attr (a), r ? Hpt::TYPE_DN : Hpt::TYPE_UP);
ffffffff81016523:	31 f6                	xor    %esi,%esi
ffffffff81016525:	4d 85 e4             	test   %r12,%r12
ffffffff81016528:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
ffffffff8101652d:	40 0f 95 c6          	setne  %sil
ffffffff81016531:	6a 00                	pushq  $0x0
ffffffff81016533:	41 8d 4f 0c          	lea    0xc(%r15),%ecx
ffffffff81016537:	56                   	push   %rsi
ffffffff81016538:	48 8b 74 24 28       	mov    0x28(%rsp),%rsi
ffffffff8101653d:	4c 89 f0             	mov    %r14,%rax
ffffffff81016540:	48 d3 e0             	shl    %cl,%rax
ffffffff81016543:	4c 8b 4c 24 40       	mov    0x40(%rsp),%r9
ffffffff81016548:	4c 89 f9             	mov    %r15,%rcx
ffffffff8101654b:	48 8d 14 38          	lea    (%rax,%rdi,1),%rdx
ffffffff8101654f:	48 8d bb 20 02 00 00 	lea    0x220(%rbx),%rdi
    }

    if (s & 2) {
        if (Vmcb::has_npt()) {
            mword ord = min (o, Hpt::ord);
            for (unsigned long i = 0; i < 1UL << (o - ord); i++) {
ffffffff81016556:	49 ff c6             	inc    %r14
                if (!r && !npt.check(quota, ord)) {
                    Cpu::hazard |= HZD_OOM;
                    return false;
                }

                npt.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (ord + PAGE_BITS)), Hpt::hw_attr (a), r ? Hpt::TYPE_DN : Hpt::TYPE_UP);
ffffffff81016559:	4c 8d 04 30          	lea    (%rax,%rsi,1),%r8
ffffffff8101655d:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
ffffffff81016562:	e8 af c7 ff ff       	callq  ffffffff81012d16 <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb>
    }

    if (s & 2) {
        if (Vmcb::has_npt()) {
            mword ord = min (o, Hpt::ord);
            for (unsigned long i = 0; i < 1UL << (o - ord); i++) {
ffffffff81016567:	5f                   	pop    %rdi
ffffffff81016568:	41 58                	pop    %r8
ffffffff8101656a:	e9 c3 fc ff ff       	jmpq   ffffffff81016232 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x188>
                if (!r && !ept.check(quota, ord)) {
                    Cpu::hazard |= HZD_OOM;
                    return false;
                }

                ept.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (ord + PAGE_BITS)), Ept::hw_attr (a, mdb->node_type), r ? Ept::TYPE_DN : Ept::TYPE_UP);
ffffffff8101656f:	31 f6                	xor    %esi,%esi
ffffffff81016571:	4d 85 e4             	test   %r12,%r12
ffffffff81016574:	49 8b 45 78          	mov    0x78(%r13),%rax
ffffffff81016578:	40 0f 95 c6          	setne  %sil
        PTE_U = ~0ULL,
    };

    ALWAYS_INLINE
    static inline mword hw_attr(mword a, mword t) {
        return a ? t << 3 | a | EPT_I | EPT_R : 0;
ffffffff8101657c:	48 85 ed             	test   %rbp,%rbp
ffffffff8101657f:	74 0f                	je     ffffffff81016590 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x4e6>
ffffffff81016581:	4c 8d 0c c5 00 00 00 	lea    0x0(,%rax,8),%r9
ffffffff81016588:	00 
ffffffff81016589:	49 83 c9 41          	or     $0x41,%r9
ffffffff8101658d:	49 09 e9             	or     %rbp,%r9
ffffffff81016590:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
ffffffff81016595:	41 8d 4e 0c          	lea    0xc(%r14),%ecx
ffffffff81016599:	6a 00                	pushq  $0x0
ffffffff8101659b:	56                   	push   %rsi
ffffffff8101659c:	48 8b 74 24 28       	mov    0x28(%rsp),%rsi
ffffffff810165a1:	4c 89 f8             	mov    %r15,%rax
ffffffff810165a4:	48 d3 e0             	shl    %cl,%rax
ffffffff810165a7:	4c 89 f1             	mov    %r14,%rcx

                npt.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (ord + PAGE_BITS)), Hpt::hw_attr (a), r ? Hpt::TYPE_DN : Hpt::TYPE_UP);
            }
        } else {
            mword ord = min (o, Ept::ord);
            for (unsigned long i = 0; i < 1UL << (o - ord); i++) {
ffffffff810165aa:	49 ff c7             	inc    %r15
                if (!r && !ept.check(quota, ord)) {
                    Cpu::hazard |= HZD_OOM;
                    return false;
                }

                ept.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (ord + PAGE_BITS)), Ept::hw_attr (a, mdb->node_type), r ? Ept::TYPE_DN : Ept::TYPE_UP);
ffffffff810165ad:	48 8d 14 38          	lea    (%rax,%rdi,1),%rdx
ffffffff810165b1:	48 8d bb 20 02 00 00 	lea    0x220(%rbx),%rdi
ffffffff810165b8:	4c 8d 04 30          	lea    (%rax,%rsi,1),%r8
ffffffff810165bc:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
ffffffff810165c1:	e8 e4 c2 ff ff       	callq  ffffffff810128aa <_ZN3PteI3EptyLj4ELj9ELb0EE6updateER5QuotaymymNS1_4TypeEb>

                npt.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (ord + PAGE_BITS)), Hpt::hw_attr (a), r ? Hpt::TYPE_DN : Hpt::TYPE_UP);
            }
        } else {
            mword ord = min (o, Ept::ord);
            for (unsigned long i = 0; i < 1UL << (o - ord); i++) {
ffffffff810165c6:	41 5b                	pop    %r11
ffffffff810165c8:	58                   	pop    %rax
ffffffff810165c9:	e9 cb fc ff ff       	jmpq   ffffffff81016299 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x1ef>
        if (!r && !hpt.check(quota, ord)) {
            Cpu::hazard |= HZD_OOM;
            return f;
        }

        f |= hpt.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (ord + PAGE_BITS)), Hpt::hw_attr (a), r ? Hpt::TYPE_DN : Hpt::TYPE_UP);
ffffffff810165ce:	31 f6                	xor    %esi,%esi
ffffffff810165d0:	4d 85 e4             	test   %r12,%r12
ffffffff810165d3:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
ffffffff810165d8:	40 0f 95 c6          	setne  %sil
ffffffff810165dc:	6a 00                	pushq  $0x0
ffffffff810165de:	41 8d 4f 0c          	lea    0xc(%r15),%ecx
ffffffff810165e2:	56                   	push   %rsi
ffffffff810165e3:	48 8b 74 24 28       	mov    0x28(%rsp),%rsi
ffffffff810165e8:	4c 89 f0             	mov    %r14,%rax
ffffffff810165eb:	48 d3 e0             	shl    %cl,%rax
ffffffff810165ee:	4c 8b 4c 24 38       	mov    0x38(%rsp),%r9
ffffffff810165f3:	4c 89 f9             	mov    %r15,%rcx
ffffffff810165f6:	48 8d 14 38          	lea    (%rax,%rdi,1),%rdx
ffffffff810165fa:	48 8d bb 10 02 00 00 	lea    0x210(%rbx),%rdi
        return false;

    mword ord = min (o, Hpt::ord);
    bool f = false;

    for (unsigned long i = 0; i < 1UL << (o - ord); i++) {
ffffffff81016601:	49 ff c6             	inc    %r14
        if (!r && !hpt.check(quota, ord)) {
            Cpu::hazard |= HZD_OOM;
            return f;
        }

        f |= hpt.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (ord + PAGE_BITS)), Hpt::hw_attr (a), r ? Hpt::TYPE_DN : Hpt::TYPE_UP);
ffffffff81016604:	4c 8d 04 30          	lea    (%rax,%rsi,1),%r8
ffffffff81016608:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
ffffffff8101660d:	e8 04 c7 ff ff       	callq  ffffffff81012d16 <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb>
        return false;

    mword ord = min (o, Hpt::ord);
    bool f = false;

    for (unsigned long i = 0; i < 1UL << (o - ord); i++) {
ffffffff81016612:	59                   	pop    %rcx
        if (!r && !hpt.check(quota, ord)) {
            Cpu::hazard |= HZD_OOM;
            return f;
        }

        f |= hpt.update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (ord + PAGE_BITS)), Hpt::hw_attr (a), r ? Hpt::TYPE_DN : Hpt::TYPE_UP);
ffffffff81016613:	09 c5                	or     %eax,%ebp
        return false;

    mword ord = min (o, Hpt::ord);
    bool f = false;

    for (unsigned long i = 0; i < 1UL << (o - ord); i++) {
ffffffff81016615:	5e                   	pop    %rsi
ffffffff81016616:	e9 77 fd ff ff       	jmpq   ffffffff81016392 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x2e8>
                if (!r && !loc[j].check(quota, ord)) {
                    Cpu::hazard |= HZD_OOM;
                    return (r || f);
                }

                loc[j].update (quota, b + i * (1UL << (ord + PAGE_BITS)), ord, p + i * (1UL << (ord + PAGE_BITS)), Hpt::hw_attr (a), Hpt::TYPE_DF);
ffffffff8101661b:	8a 4c 24 40          	mov    0x40(%rsp),%cl
ffffffff8101661f:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
ffffffff81016624:	48 89 ef             	mov    %rbp,%rdi
ffffffff81016627:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
ffffffff8101662c:	44 88 54 24 4f       	mov    %r10b,0x4f(%rsp)
ffffffff81016631:	6a 00                	pushq  $0x0
ffffffff81016633:	6a 02                	pushq  $0x2
ffffffff81016635:	48 d3 e0             	shl    %cl,%rax
ffffffff81016638:	4c 8b 4c 24 38       	mov    0x38(%rsp),%r9
ffffffff8101663d:	4c 89 f9             	mov    %r15,%rcx
ffffffff81016640:	48 8d 14 30          	lea    (%rax,%rsi,1),%rdx
ffffffff81016644:	48 8b 74 24 28       	mov    0x28(%rsp),%rsi
ffffffff81016649:	4c 8d 04 30          	lea    (%rax,%rsi,1),%r8
ffffffff8101664d:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
ffffffff81016652:	e8 bf c6 ff ff       	callq  ffffffff81012d16 <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb>

        for (unsigned j = 0; j < sizeof (loc) / sizeof (*loc); j++) {
            if (!loc[j].addr())
                continue;

            for (unsigned long i = 0; i < 1UL << (o - ord); i++) {
ffffffff81016657:	48 ff 44 24 18       	incq   0x18(%rsp)
ffffffff8101665c:	58                   	pop    %rax
ffffffff8101665d:	5a                   	pop    %rdx
ffffffff8101665e:	44 8a 54 24 4f       	mov    0x4f(%rsp),%r10b
ffffffff81016663:	e9 ba fd ff ff       	jmpq   ffffffff81016422 <_ZN9Space_mem6updateER11Quota_guardP3Mdbm+0x378>

        htlb.merge (cpus);
    }

    return (r || f);
}
ffffffff81016668:	48 83 c4 58          	add    $0x58,%rsp
ffffffff8101666c:	44 88 d0             	mov    %r10b,%al
ffffffff8101666f:	5b                   	pop    %rbx
ffffffff81016670:	5d                   	pop    %rbp
ffffffff81016671:	41 5c                	pop    %r12
ffffffff81016673:	41 5d                	pop    %r13
ffffffff81016675:	41 5e                	pop    %r14
ffffffff81016677:	41 5f                	pop    %r15
ffffffff81016679:	c3                   	retq   

ffffffff8101667a <_ZN9Space_mem9shootdownEv>:

void Space_mem::shootdown()
{
ffffffff8101667a:	41 56                	push   %r14
ffffffff8101667c:	41 55                	push   %r13
ffffffff8101667e:	41 54                	push   %r12
ffffffff81016680:	41 bc 04 00 00 00    	mov    $0x4,%r12d
ffffffff81016686:	55                   	push   %rbp
ffffffff81016687:	49 81 ec 10 f0 ff bf 	sub    $0xffffffffbffff010,%r12
ffffffff8101668e:	53                   	push   %rbx
ffffffff8101668f:	48 bd 10 00 e0 be ff 	movabs $0xffffffffbee00010,%rbp
ffffffff81016696:	ff ff ff 
ffffffff81016699:	31 db                	xor    %ebx,%ebx
ffffffff8101669b:	f6 04 dd 38 70 16 81 	testb  $0x1,-0x7ee98fc8(,%rbx,8)
ffffffff810166a2:	01 
ffffffff810166a3:	89 df                	mov    %ebx,%edi
ffffffff810166a5:	74 1e                	je     ffffffff810166c5 <_ZN9Space_mem9shootdownEv+0x4b>
        }

        ALWAYS_INLINE
        static inline Pd *remote (unsigned c)
        {
            return *reinterpret_cast<volatile typeof current *>(reinterpret_cast<mword>(&current) - CPU_LOCAL_DATA + HV_GLOBAL_CPUS + c * PAGE_SIZE);
ffffffff810166a7:	48 8b 45 00          	mov    0x0(%rbp),%rax
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
ffffffff810166ab:	48 8b 90 c8 02 00 00 	mov    0x2c8(%rax),%rdx
        if (!Hip::cpu_online (cpu))
            continue;

        Pd *pd = Pd::remote (cpu);

        if (!pd->htlb.chk (cpu) && !pd->gtlb.chk (cpu))
ffffffff810166b2:	48 0f a3 da          	bt     %rbx,%rdx
ffffffff810166b6:	72 26                	jb     ffffffff810166de <_ZN9Space_mem9shootdownEv+0x64>
ffffffff810166b8:	48 8b 80 d0 02 00 00 	mov    0x2d0(%rax),%rax
ffffffff810166bf:	48 0f a3 f8          	bt     %rdi,%rax
ffffffff810166c3:	72 19                	jb     ffffffff810166de <_ZN9Space_mem9shootdownEv+0x64>
ffffffff810166c5:	48 ff c3             	inc    %rbx
ffffffff810166c8:	48 81 c5 00 10 00 00 	add    $0x1000,%rbp
    return (r || f);
}

void Space_mem::shootdown()
{
    for (unsigned cpu = 0; cpu < NUM_CPU; cpu++) {
ffffffff810166cf:	48 83 fb 40          	cmp    $0x40,%rbx
ffffffff810166d3:	75 c6                	jne    ffffffff8101669b <_ZN9Space_mem9shootdownEv+0x21>
            pause();

        if (!Cpu::preemption)
            asm volatile ("cli" : : : "memory");
    }
}
ffffffff810166d5:	5b                   	pop    %rbx
ffffffff810166d6:	5d                   	pop    %rbp
ffffffff810166d7:	41 5c                	pop    %r12
ffffffff810166d9:	41 5d                	pop    %r13
ffffffff810166db:	41 5e                	pop    %r14
ffffffff810166dd:	c3                   	retq   
        Pd *pd = Pd::remote (cpu);

        if (!pd->htlb.chk (cpu) && !pd->gtlb.chk (cpu))
            continue;

        if (Cpu::id == cpu) {
ffffffff810166de:	39 3d 20 89 fe 3e    	cmp    %edi,0x3efe8920(%rip)        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff810166e4:	75 09                	jne    ffffffff810166ef <_ZN9Space_mem9shootdownEv+0x75>
            Cpu::hazard |= HZD_SCHED;
ffffffff810166e6:	83 0d 13 89 fe 3e 01 	orl    $0x1,0x3efe8913(%rip)        # ffffffffbffff000 <_ZN3Cpu6hazardE>
            continue;
ffffffff810166ed:	eb d6                	jmp    ffffffff810166c5 <_ZN9Space_mem9shootdownEv+0x4b>
ffffffff810166ef:	49 8d 04 2c          	lea    (%r12,%rbp,1),%rax
        }

        unsigned ctr = Counter::remote (cpu, 1);

        Lapic::send_ipi (cpu, VEC_IPI_RKE);
ffffffff810166f3:	31 c9                	xor    %ecx,%ecx
ffffffff810166f5:	31 d2                	xor    %edx,%edx
ffffffff810166f7:	be a8 00 00 00       	mov    $0xa8,%esi
ffffffff810166fc:	4c 8d b0 18 f7 ff bf 	lea    -0x400008e8(%rax),%r14
        static void dump();

        ALWAYS_INLINE
        static inline unsigned remote (unsigned c, unsigned i)
        {
            return *reinterpret_cast<volatile unsigned *>(reinterpret_cast<mword>(ipi + i) - CPU_LOCAL_DATA + HV_GLOBAL_CPUS + c * PAGE_SIZE);
ffffffff81016703:	44 8b a8 18 f7 ff bf 	mov    -0x400008e8(%rax),%r13d
ffffffff8101670a:	e8 1f 1d ff ff       	callq  ffffffff8100842e <_ZN5Lapic8send_ipiEjjNS_13Delivery_modeENS_9ShorthandE>

        if (!Cpu::preemption)
ffffffff8101670f:	80 3d 1a 90 fe 3e 00 	cmpb   $0x0,0x3efe901a(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81016716:	75 01                	jne    ffffffff81016719 <_ZN9Space_mem9shootdownEv+0x9f>
            asm volatile ("sti" : : : "memory");
ffffffff81016718:	fb                   	sti    
ffffffff81016719:	41 8b 06             	mov    (%r14),%eax

        while (Counter::remote (cpu, 1) == ctr)
ffffffff8101671c:	44 39 e8             	cmp    %r13d,%eax
ffffffff8101671f:	75 04                	jne    ffffffff81016725 <_ZN9Space_mem9shootdownEv+0xab>
}

ALWAYS_INLINE
static inline void pause()
{
    asm volatile ("pause" : : : "memory");
ffffffff81016721:	f3 90                	pause  
ffffffff81016723:	eb f4                	jmp    ffffffff81016719 <_ZN9Space_mem9shootdownEv+0x9f>
            pause();

        if (!Cpu::preemption)
ffffffff81016725:	80 3d 04 90 fe 3e 00 	cmpb   $0x0,0x3efe9004(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8101672c:	75 97                	jne    ffffffff810166c5 <_ZN9Space_mem9shootdownEv+0x4b>
            asm volatile ("cli" : : : "memory");
ffffffff8101672e:	fa                   	cli    
ffffffff8101672f:	eb 94                	jmp    ffffffff810166c5 <_ZN9Space_mem9shootdownEv+0x4b>
ffffffff81016731:	90                   	nop

ffffffff81016732 <_ZN9Space_mem11insert_utcbER5Quotamm>:
bool Space_mem::insert_utcb (Quota &quota, mword b, mword phys)
{
    if (!phys)
       return true;

    if (!b)
ffffffff81016732:	48 85 c9             	test   %rcx,%rcx
ffffffff81016735:	0f 84 92 00 00 00    	je     ffffffff810167cd <_ZN9Space_mem11insert_utcbER5Quotamm+0x9b>
ffffffff8101673b:	48 85 d2             	test   %rdx,%rdx
ffffffff8101673e:	0f 84 89 00 00 00    	je     ffffffff810167cd <_ZN9Space_mem11insert_utcbER5Quotamm+0x9b>

    Mdb::destroy (mdb, pd->quota);
}

bool Space_mem::insert_utcb (Quota &quota, mword b, mword phys)
{
ffffffff81016744:	41 56                	push   %r14
ffffffff81016746:	41 55                	push   %r13
ffffffff81016748:	49 89 fe             	mov    %rdi,%r14
ffffffff8101674b:	41 54                	push   %r12
ffffffff8101674d:	55                   	push   %rbp
ffffffff8101674e:	49 89 d4             	mov    %rdx,%r12
ffffffff81016751:	53                   	push   %rbx
        bool insert_node (Mdb *, mword);
        void demote_node (mword);
        bool remove_node();

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
ffffffff81016752:	48 c7 c7 80 38 16 81 	mov    $0xffffffff81163880,%rdi
ffffffff81016759:	48 89 cd             	mov    %rcx,%rbp
ffffffff8101675c:	48 89 f3             	mov    %rsi,%rbx
ffffffff8101675f:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff81016763:	e8 c6 f1 ff ff       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
       return true;

    if (!b)
        return true;

    Mdb *mdb = new (quota) Mdb (this, free_mdb, phys, b >> PAGE_BITS, 0, 0x3);
ffffffff81016768:	4d 89 e0             	mov    %r12,%r8
ffffffff8101676b:	41 51                	push   %r9
ffffffff8101676d:	6a 00                	pushq  $0x0
ffffffff8101676f:	6a 00                	pushq  $0x0
ffffffff81016771:	6a 03                	pushq  $0x3
ffffffff81016773:	49 89 c5             	mov    %rax,%r13
ffffffff81016776:	45 31 c9             	xor    %r9d,%r9d
ffffffff81016779:	49 c1 e8 0c          	shr    $0xc,%r8
ffffffff8101677d:	48 89 c7             	mov    %rax,%rdi
ffffffff81016780:	48 89 e9             	mov    %rbp,%rcx
ffffffff81016783:	48 c7 c2 16 60 01 81 	mov    $0xffffffff81016016,%rdx
ffffffff8101678a:	4c 89 f6             	mov    %r14,%rsi
ffffffff8101678d:	e8 4a c6 fe ff       	callq  ffffffff81002ddc <_ZN3MdbC1EP5SpacePFvP8Rcu_elemEmmmmmm>

    if (tree_insert (mdb))
ffffffff81016792:	48 83 c4 20          	add    $0x20,%rsp
ffffffff81016796:	4c 89 ef             	mov    %r13,%rdi
ffffffff81016799:	e8 9e 97 ff ff       	callq  ffffffff8100ff3c <_ZN5Space11tree_insertEP3Mdb>
ffffffff8101679e:	84 c0                	test   %al,%al
ffffffff810167a0:	74 04                	je     ffffffff810167a6 <_ZN9Space_mem11insert_utcbER5Quotamm+0x74>
{
    if (!phys)
       return true;

    if (!b)
        return true;
ffffffff810167a2:	b0 01                	mov    $0x1,%al
ffffffff810167a4:	eb 1a                	jmp    ffffffff810167c0 <_ZN9Space_mem11insert_utcbER5Quotamm+0x8e>

        ALWAYS_INLINE
        static inline void destroy (Mdb *obj, Quota &quota) { obj->~Mdb(); cache.free (obj, quota); }
ffffffff810167a6:	48 89 da             	mov    %rbx,%rdx
ffffffff810167a9:	4c 89 ee             	mov    %r13,%rsi
ffffffff810167ac:	48 c7 c7 80 38 16 81 	mov    $0xffffffff81163880,%rdi
ffffffff810167b3:	88 44 24 0f          	mov    %al,0xf(%rsp)
ffffffff810167b7:	e8 ae f2 ff ff       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
ffffffff810167bc:	8a 44 24 0f          	mov    0xf(%rsp),%al
        return true;

    Mdb::destroy (mdb, quota);

    return false;
}
ffffffff810167c0:	48 83 c4 10          	add    $0x10,%rsp
ffffffff810167c4:	5b                   	pop    %rbx
ffffffff810167c5:	5d                   	pop    %rbp
ffffffff810167c6:	41 5c                	pop    %r12
ffffffff810167c8:	41 5d                	pop    %r13
ffffffff810167ca:	41 5e                	pop    %r14
ffffffff810167cc:	c3                   	retq   
{
    if (!phys)
       return true;

    if (!b)
        return true;
ffffffff810167cd:	b0 01                	mov    $0x1,%al
        return true;

    Mdb::destroy (mdb, quota);

    return false;
}
ffffffff810167cf:	c3                   	retq   

ffffffff810167d0 <_ZN9Space_mem11remove_utcbEm>:

bool Space_mem::remove_utcb (mword b)
{
ffffffff810167d0:	41 54                	push   %r12
ffffffff810167d2:	55                   	push   %rbp
ffffffff810167d3:	53                   	push   %rbx
ffffffff810167d4:	48 83 ec 10          	sub    $0x10,%rsp
    if (!b)
ffffffff810167d8:	48 85 f6             	test   %rsi,%rsi
ffffffff810167db:	0f 84 ab 00 00 00    	je     ffffffff8101688c <_ZN9Space_mem11remove_utcbEm+0xbc>
        return false;

    Mdb *mdb = tree_lookup(b >> PAGE_BITS, false);
ffffffff810167e1:	48 c1 ee 0c          	shr    $0xc,%rsi
ffffffff810167e5:	31 d2                	xor    %edx,%edx
ffffffff810167e7:	e8 7a 96 ff ff       	callq  ffffffff8100fe66 <_ZN5Space11tree_lookupEmb>
    if (!mdb)
ffffffff810167ec:	48 85 c0             	test   %rax,%rax
bool Space_mem::remove_utcb (mword b)
{
    if (!b)
        return false;

    Mdb *mdb = tree_lookup(b >> PAGE_BITS, false);
ffffffff810167ef:	48 89 c3             	mov    %rax,%rbx
    if (!mdb)
ffffffff810167f2:	0f 84 94 00 00 00    	je     ffffffff8101688c <_ZN9Space_mem11remove_utcbEm+0xbc>
        return false;

    mdb->demote_node(0x3);
ffffffff810167f8:	48 89 c7             	mov    %rax,%rdi
ffffffff810167fb:	be 03 00 00 00       	mov    $0x3,%esi
ffffffff81016800:	e8 a1 21 ff ff       	callq  ffffffff810089a6 <_ZN3Mdb11demote_nodeEm>

    if (mdb->remove_node() && tree_remove(mdb)) {
ffffffff81016805:	48 89 df             	mov    %rbx,%rdi
ffffffff81016808:	e8 39 22 ff ff       	callq  ffffffff81008a46 <_ZN3Mdb11remove_nodeEv>
ffffffff8101680d:	84 c0                	test   %al,%al
ffffffff8101680f:	74 7b                	je     ffffffff8101688c <_ZN9Space_mem11remove_utcbEm+0xbc>
ffffffff81016811:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff81016816:	48 89 df             	mov    %rbx,%rdi
ffffffff81016819:	e8 c1 97 ff ff       	callq  ffffffff8100ffdf <_ZN5Space11tree_removeEP3MdbN3Avl5StateE>
ffffffff8101681e:	84 c0                	test   %al,%al
ffffffff81016820:	40 88 c5             	mov    %al,%bpl
ffffffff81016823:	74 67                	je     ffffffff8101688c <_ZN9Space_mem11remove_utcbEm+0xbc>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
ffffffff81016825:	48 8b 43 28          	mov    0x28(%rbx),%rax
        Rcu::call (mdb);
ffffffff81016829:	4c 8d 63 18          	lea    0x18(%rbx),%r12
ffffffff8101682d:	48 85 c0             	test   %rax,%rax
ffffffff81016830:	74 05                	je     ffffffff81016837 <_ZN9Space_mem11remove_utcbEm+0x67>
                e->pre_func(e);
ffffffff81016832:	4c 89 e7             	mov    %r12,%rdi
ffffffff81016835:	ff d0                	callq  *%rax
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
ffffffff81016837:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
ffffffff8101683c:	75 0c                	jne    ffffffff8101684a <_ZN9Space_mem11remove_utcbEm+0x7a>
ffffffff8101683e:	48 8b 05 23 90 fe 3e 	mov    0x3efe9023(%rip),%rax        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff81016845:	4c 39 e0             	cmp    %r12,%rax
ffffffff81016848:	75 2f                	jne    ffffffff81016879 <_ZN9Space_mem11remove_utcbEm+0xa9>
                trace (0, "warning: rcu element already enqueued");
ffffffff8101684a:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff8101684f:	8b 15 af 87 fe 3e    	mov    0x3efe87af(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81016855:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81016859:	48 c7 c7 14 df 01 81 	mov    $0xffffffff8101df14,%rdi
ffffffff81016860:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81016866:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff8101686c:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff81016870:	31 c0                	xor    %eax,%eax
ffffffff81016872:	e8 15 b8 fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff81016877:	eb 15                	jmp    ffffffff8101688e <_ZN9Space_mem11remove_utcbEm+0xbe>
                return;
            }

            count ++;
ffffffff81016879:	48 ff 05 f0 8f fe 3e 	incq   0x3efe8ff0(%rip)        # ffffffffbffff870 <_ZN3Rcu4nextE+0x10>

           *tail = e;
ffffffff81016880:	4c 89 20             	mov    %r12,(%rax)
            tail = &e->next;
ffffffff81016883:	4c 89 25 de 8f fe 3e 	mov    %r12,0x3efe8fde(%rip)        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff8101688a:	eb 02                	jmp    ffffffff8101688e <_ZN9Space_mem11remove_utcbEm+0xbe>
        return true;
    }

    return false;
ffffffff8101688c:	31 ed                	xor    %ebp,%ebp
}
ffffffff8101688e:	48 83 c4 10          	add    $0x10,%rsp
ffffffff81016892:	40 88 e8             	mov    %bpl,%al
ffffffff81016895:	5b                   	pop    %rbx
ffffffff81016896:	5d                   	pop    %rbp
ffffffff81016897:	41 5c                	pop    %r12
ffffffff81016899:	c3                   	retq   

ffffffff8101689a <_ZN9Space_obj4walkER5Quotam>:
{
    return static_cast<Pd *>(this);
}

Paddr Space_obj::walk (Quota &quota, mword idx)
{
ffffffff8101689a:	41 56                	push   %r14
ffffffff8101689c:	41 55                	push   %r13
ffffffff8101689e:	81 e2 ff ff ff 03    	and    $0x3ffffff,%edx
ffffffff810168a4:	41 54                	push   %r12
ffffffff810168a6:	55                   	push   %rbp

        ALWAYS_INLINE
        inline size_t lookup (mword virt, Paddr &phys)
        {
            mword attr;
            return hpt.lookup (virt, phys, attr);
ffffffff810168a7:	48 8d 6f a8          	lea    -0x58(%rdi),%rbp
ffffffff810168ab:	53                   	push   %rbx
ffffffff810168ac:	48 8d 1c d5 00 00 00 	lea    -0x20000000(,%rdx,8),%rbx
ffffffff810168b3:	e0 
ffffffff810168b4:	49 89 f4             	mov    %rsi,%r12
ffffffff810168b7:	48 89 ef             	mov    %rbp,%rdi
ffffffff810168ba:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff810168be:	48 89 de             	mov    %rbx,%rsi
ffffffff810168c1:	48 8d 4c 24 08       	lea    0x8(%rsp),%rcx
ffffffff810168c6:	48 89 e2             	mov    %rsp,%rdx
ffffffff810168c9:	e8 06 c3 ff ff       	callq  ffffffff81012bd4 <_ZN3PteI3HptmLj4ELj9ELb0EE6lookupEmRmS2_>
    mword virt = idx_to_virt (idx); Paddr phys; void *ptr;

    if (!space_mem()->lookup (virt, phys) || (phys & ~PAGE_MASK) == reinterpret_cast<Paddr>(&FRAME_0)) {
ffffffff810168ce:	48 85 c0             	test   %rax,%rax
ffffffff810168d1:	74 12                	je     ffffffff810168e5 <_ZN9Space_obj4walkER5Quotam+0x4b>
ffffffff810168d3:	48 8b 04 24          	mov    (%rsp),%rax
ffffffff810168d7:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff810168dd:	48 3d 00 50 56 00    	cmp    $0x565000,%rax
ffffffff810168e3:	75 5d                	jne    ffffffff81016942 <_ZN9Space_obj4walkER5Quotam+0xa8>

        Paddr p = Buddy::ptr_to_phys (ptr = Buddy::allocator.alloc (0, quota, Buddy::FILL_0));
ffffffff810168e5:	31 f6                	xor    %esi,%esi
ffffffff810168e7:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff810168ec:	4c 89 e2             	mov    %r12,%rdx
ffffffff810168ef:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff810168f6:	e8 f7 af fe ff       	callq  ffffffff810018f2 <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
ffffffff810168fb:	49 89 c5             	mov    %rax,%r13
        }

        ALWAYS_INLINE
        inline Paddr replace (Quota &quota, mword v, Paddr p)
        {
            return hpt.replace (quota, v, p);
ffffffff810168fe:	48 89 da             	mov    %rbx,%rdx
ffffffff81016901:	4c 89 e6             	mov    %r12,%rsi
ffffffff81016904:	49 81 ed 00 00 c0 80 	sub    $0xffffffff80c00000,%r13
ffffffff8101690b:	48 89 ef             	mov    %rbp,%rdi
ffffffff8101690e:	49 89 c6             	mov    %rax,%r14

        if ((phys = space_mem()->replace (quota, virt, p | Hpt::HPT_NX | Hpt::HPT_D | Hpt::HPT_A | Hpt::HPT_W | Hpt::HPT_P)) != p)
ffffffff81016911:	4c 89 e9             	mov    %r13,%rcx
ffffffff81016914:	48 83 c9 63          	or     $0x63,%rcx
ffffffff81016918:	e8 8b 17 ff ff       	callq  ffffffff810080a8 <_ZN3Hpt7replaceER5Quotamm>
ffffffff8101691d:	4c 39 e8             	cmp    %r13,%rax
ffffffff81016920:	48 89 04 24          	mov    %rax,(%rsp)
ffffffff81016924:	74 12                	je     ffffffff81016938 <_ZN9Space_obj4walkER5Quotam+0x9e>
            Buddy::allocator.free (reinterpret_cast<mword>(ptr), quota);
ffffffff81016926:	4c 89 e2             	mov    %r12,%rdx
ffffffff81016929:	4c 89 f6             	mov    %r14,%rsi
ffffffff8101692c:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff81016933:	e8 76 ac fe ff       	callq  ffffffff810015ae <_ZN5Buddy4freeEmR5Quota>

        phys |= virt & PAGE_MASK;
ffffffff81016938:	81 e3 ff 0f 00 00    	and    $0xfff,%ebx
ffffffff8101693e:	48 09 1c 24          	or     %rbx,(%rsp)
    }

    return phys;
ffffffff81016942:	48 8b 04 24          	mov    (%rsp),%rax
}
ffffffff81016946:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8101694a:	5b                   	pop    %rbx
ffffffff8101694b:	5d                   	pop    %rbp
ffffffff8101694c:	41 5c                	pop    %r12
ffffffff8101694e:	41 5d                	pop    %r13
ffffffff81016950:	41 5e                	pop    %r14
ffffffff81016952:	c3                   	retq   
ffffffff81016953:	90                   	nop

ffffffff81016954 <_ZN9Space_obj6updateER5Quotam10Capability>:

void Space_obj::update (Quota &quota, mword idx, Capability cap)
{
ffffffff81016954:	53                   	push   %rbx
ffffffff81016955:	48 89 cb             	mov    %rcx,%rbx
    *static_cast<Capability *>(Buddy::phys_to_ptr (walk (quota, idx))) = cap;
ffffffff81016958:	e8 3d ff ff ff       	callq  ffffffff8101689a <_ZN9Space_obj4walkER5Quotam>
ffffffff8101695d:	48 89 98 00 00 c0 80 	mov    %rbx,-0x7f400000(%rax)
}
ffffffff81016964:	5b                   	pop    %rbx
ffffffff81016965:	c3                   	retq   

ffffffff81016966 <_ZN9Space_obj6updateER5QuotaP3Mdbm>:

    return 1;
}

bool Space_obj::update (Quota &quota, Mdb *mdb, mword r)
{
ffffffff81016966:	41 55                	push   %r13
ffffffff81016968:	41 54                	push   %r12
ffffffff8101696a:	49 89 fc             	mov    %rdi,%r12
ffffffff8101696d:	55                   	push   %rbp
ffffffff8101696e:	53                   	push   %rbx
ffffffff8101696f:	48 83 ec 18          	sub    $0x18,%rsp
    assert (this == mdb->space && this != &Pd::kern);
ffffffff81016973:	48 81 ff 98 3f 16 81 	cmp    $0xffffffff81163f98,%rdi
ffffffff8101697a:	0f 84 c1 00 00 00    	je     ffffffff81016a41 <_ZN9Space_obj6updateER5QuotaP3Mdbm+0xdb>
ffffffff81016980:	48 3b 7a 50          	cmp    0x50(%rdx),%rdi
ffffffff81016984:	48 89 d3             	mov    %rdx,%rbx
ffffffff81016987:	0f 85 b4 00 00 00    	jne    ffffffff81016a41 <_ZN9Space_obj6updateER5QuotaP3Mdbm+0xdb>
ffffffff8101698d:	49 89 cd             	mov    %rcx,%r13
    Lock_guard <Spinlock> guard (mdb->node_lock);
ffffffff81016990:	48 8d 7a 30          	lea    0x30(%rdx),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81016994:	9c                   	pushfq 
ffffffff81016995:	5d                   	pop    %rbp
            return flags & 0x200;
ffffffff81016996:	48 c1 ed 09          	shr    $0x9,%rbp

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8101699a:	40 80 e5 01          	and    $0x1,%bpl
ffffffff8101699e:	74 2d                	je     ffffffff810169cd <_ZN9Space_obj6updateER5QuotaP3Mdbm+0x67>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff810169a0:	80 3d 89 8d fe 3e 00 	cmpb   $0x0,0x3efe8d89(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff810169a7:	75 1c                	jne    ffffffff810169c5 <_ZN9Space_obj6updateER5QuotaP3Mdbm+0x5f>
ffffffff810169a9:	49 c7 c0 f0 0a 02 81 	mov    $0xffffffff81020af0,%r8
ffffffff810169b0:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff810169b5:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff810169bc:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff810169c3:	eb 64                	jmp    ffffffff81016a29 <_ZN9Space_obj6updateER5QuotaP3Mdbm+0xc3>

            asm volatile ("cli" : : : "memory");
ffffffff810169c5:	fa                   	cli    
            preemption = false;
ffffffff810169c6:	c6 05 63 8d fe 3e 00 	movb   $0x0,0x3efe8d63(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff810169cd:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
                Cpu::preempt_disable();

            _lock.lock();
ffffffff810169d2:	e8 b7 a4 fe ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    update (quota, mdb->node_base, Capability (reinterpret_cast<Kobject *>(mdb->node_phys), mdb->node_attr & ~r));
ffffffff810169d7:	4c 89 e9             	mov    %r13,%rcx
ffffffff810169da:	48 8b 43 58          	mov    0x58(%rbx),%rax
        static mword const perm = 0x1f;

    public:
        Capability() : val (0) {}

        Capability (Kobject *o, mword a) : val (a ? reinterpret_cast<mword>(o) | (a & perm) : 0) {}
ffffffff810169de:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
ffffffff810169e3:	48 f7 d1             	not    %rcx
ffffffff810169e6:	48 23 4b 70          	and    0x70(%rbx),%rcx
ffffffff810169ea:	74 06                	je     ffffffff810169f2 <_ZN9Space_obj6updateER5QuotaP3Mdbm+0x8c>
ffffffff810169ec:	83 e1 1f             	and    $0x1f,%ecx
ffffffff810169ef:	48 09 c1             	or     %rax,%rcx
ffffffff810169f2:	48 8b 53 60          	mov    0x60(%rbx),%rdx
ffffffff810169f6:	4c 89 e7             	mov    %r12,%rdi
ffffffff810169f9:	e8 56 ff ff ff       	callq  ffffffff81016954 <_ZN9Space_obj6updateER5Quotam10Capability>
ffffffff810169fe:	fe 43 30             	incb   0x30(%rbx)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81016a01:	40 84 ed             	test   %bpl,%bpl
ffffffff81016a04:	74 57                	je     ffffffff81016a5d <_ZN9Space_obj6updateER5QuotaP3Mdbm+0xf7>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81016a06:	80 3d 23 8d fe 3e 00 	cmpb   $0x0,0x3efe8d23(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81016a0d:	74 28                	je     ffffffff81016a37 <_ZN9Space_obj6updateER5QuotaP3Mdbm+0xd1>
ffffffff81016a0f:	49 c7 c0 c0 0a 02 81 	mov    $0xffffffff81020ac0,%r8
ffffffff81016a16:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff81016a1b:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81016a22:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff81016a29:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81016a30:	31 c0                	xor    %eax,%eax
ffffffff81016a32:	e8 19 b5 fe ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            preemption = true;
ffffffff81016a37:	c6 05 f2 8c fe 3e 01 	movb   $0x1,0x3efe8cf2(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81016a3e:	fb                   	sti    
ffffffff81016a3f:	eb 1c                	jmp    ffffffff81016a5d <_ZN9Space_obj6updateER5QuotaP3Mdbm+0xf7>
    return 1;
}

bool Space_obj::update (Quota &quota, Mdb *mdb, mword r)
{
    assert (this == mdb->space && this != &Pd::kern);
ffffffff81016a41:	49 c7 c0 20 0b 02 81 	mov    $0xffffffff81020b20,%r8
ffffffff81016a48:	b9 3f 00 00 00       	mov    $0x3f,%ecx
ffffffff81016a4d:	48 c7 c2 02 0a 02 81 	mov    $0xffffffff81020a02,%rdx
ffffffff81016a54:	48 c7 c6 44 09 02 81 	mov    $0xffffffff81020944,%rsi
ffffffff81016a5b:	eb cc                	jmp    ffffffff81016a29 <_ZN9Space_obj6updateER5QuotaP3Mdbm+0xc3>
    Lock_guard <Spinlock> guard (mdb->node_lock);
    update (quota, mdb->node_base, Capability (reinterpret_cast<Kobject *>(mdb->node_phys), mdb->node_attr & ~r));

    return false;
}
ffffffff81016a5d:	48 83 c4 18          	add    $0x18,%rsp
ffffffff81016a61:	31 c0                	xor    %eax,%eax
ffffffff81016a63:	5b                   	pop    %rbx
ffffffff81016a64:	5d                   	pop    %rbp
ffffffff81016a65:	41 5c                	pop    %r12
ffffffff81016a67:	41 5d                	pop    %r13
ffffffff81016a69:	c3                   	retq   

ffffffff81016a6a <_ZN9Space_obj11insert_rootER5QuotaP7Kobject>:

bool Space_obj::insert_root (Quota &quota, Kobject *obj)
{
ffffffff81016a6a:	55                   	push   %rbp
ffffffff81016a6b:	53                   	push   %rbx
ffffffff81016a6c:	48 89 fd             	mov    %rdi,%rbp
    if (!obj->space->tree_insert (obj))
ffffffff81016a6f:	48 89 f7             	mov    %rsi,%rdi

    return false;
}

bool Space_obj::insert_root (Quota &quota, Kobject *obj)
{
ffffffff81016a72:	48 89 f3             	mov    %rsi,%rbx
ffffffff81016a75:	48 83 ec 18          	sub    $0x18,%rsp
    if (!obj->space->tree_insert (obj))
ffffffff81016a79:	e8 be 94 ff ff       	callq  ffffffff8100ff3c <_ZN5Space11tree_insertEP3Mdb>
ffffffff81016a7e:	84 c0                	test   %al,%al
ffffffff81016a80:	74 30                	je     ffffffff81016ab2 <_ZN9Space_obj11insert_rootER5QuotaP7Kobject+0x48>
        return false;

    if (obj->space != static_cast<Space_obj *>(&Pd::kern))
ffffffff81016a82:	48 8b 7b 50          	mov    0x50(%rbx),%rdi
ffffffff81016a86:	48 81 ff 98 3f 16 81 	cmp    $0xffffffff81163f98,%rdi
ffffffff81016a8d:	74 23                	je     ffffffff81016ab2 <_ZN9Space_obj11insert_rootER5QuotaP7Kobject+0x48>
        static_cast<Space_obj *>(obj->space)->update (quota, obj->node_base, Capability (obj, obj->node_attr));
ffffffff81016a8f:	48 8b 4b 70          	mov    0x70(%rbx),%rcx
ffffffff81016a93:	48 85 c9             	test   %rcx,%rcx
ffffffff81016a96:	74 06                	je     ffffffff81016a9e <_ZN9Space_obj11insert_rootER5QuotaP7Kobject+0x34>
ffffffff81016a98:	83 e1 1f             	and    $0x1f,%ecx
ffffffff81016a9b:	48 09 d9             	or     %rbx,%rcx
ffffffff81016a9e:	48 8b 53 60          	mov    0x60(%rbx),%rdx
ffffffff81016aa2:	48 89 ee             	mov    %rbp,%rsi
ffffffff81016aa5:	88 44 24 0f          	mov    %al,0xf(%rsp)
ffffffff81016aa9:	e8 a6 fe ff ff       	callq  ffffffff81016954 <_ZN9Space_obj6updateER5Quotam10Capability>
ffffffff81016aae:	8a 44 24 0f          	mov    0xf(%rsp),%al

    return true;
}
ffffffff81016ab2:	48 83 c4 18          	add    $0x18,%rsp
ffffffff81016ab6:	5b                   	pop    %rbx
ffffffff81016ab7:	5d                   	pop    %rbp
ffffffff81016ab8:	c3                   	retq   
ffffffff81016ab9:	90                   	nop

ffffffff81016aba <_ZN9Space_obj10page_faultEmm>:

void Space_obj::page_fault (mword addr, mword error)
{
    assert (!(error & Hpt::ERR_W));
ffffffff81016aba:	40 80 e6 02          	and    $0x2,%sil

    return true;
}

void Space_obj::page_fault (mword addr, mword error)
{
ffffffff81016abe:	53                   	push   %rbx
    assert (!(error & Hpt::ERR_W));
ffffffff81016abf:	74 28                	je     ffffffff81016ae9 <_ZN9Space_obj10page_faultEmm+0x2f>
ffffffff81016ac1:	49 c7 c0 90 0a 02 81 	mov    $0xffffffff81020a90,%r8
ffffffff81016ac8:	b9 53 00 00 00       	mov    $0x53,%ecx
ffffffff81016acd:	48 c7 c2 02 0a 02 81 	mov    $0xffffffff81020a02,%rdx
ffffffff81016ad4:	48 c7 c6 73 0a 02 81 	mov    $0xffffffff81020a73,%rsi
ffffffff81016adb:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81016ae2:	31 c0                	xor    %eax,%eax
ffffffff81016ae4:	e8 67 b4 fe ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

    if (!Pd::current->Space_mem::loc[Cpu::id].sync_from (Pd::current->quota, Pd::current->Space_mem::hpt, addr, CPU_LOCAL))
ffffffff81016ae9:	48 8b 05 20 85 fe 3e 	mov    0x3efe8520(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81016af0:	8b 0d 0e 85 fe 3e    	mov    0x3efe850e(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81016af6:	48 89 fb             	mov    %rdi,%rbx
ffffffff81016af9:	49 c7 c0 00 00 e0 bf 	mov    $0xffffffffbfe00000,%r8
ffffffff81016b00:	48 8b 90 a0 02 00 00 	mov    0x2a0(%rax),%rdx
ffffffff81016b07:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff81016b0e:	48 8d bc c8 a0 00 00 	lea    0xa0(%rax,%rcx,8),%rdi
ffffffff81016b15:	00 
ffffffff81016b16:	48 89 d9             	mov    %rbx,%rcx
ffffffff81016b19:	e8 64 14 ff ff       	callq  ffffffff81007f82 <_ZN3Hpt9sync_fromER5QuotaS_mm>
ffffffff81016b1e:	84 c0                	test   %al,%al
ffffffff81016b20:	75 29                	jne    ffffffff81016b4b <_ZN9Space_obj10page_faultEmm+0x91>
        Pd::current->Space_mem::replace (Pd::current->quota, addr, reinterpret_cast<Paddr>(&FRAME_0) | Hpt::HPT_NX | Hpt::HPT_A | Hpt::HPT_P);
ffffffff81016b22:	48 8b 05 e7 84 fe 3e 	mov    0x3efe84e7(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81016b29:	48 89 da             	mov    %rbx,%rdx
ffffffff81016b2c:	48 c7 c1 00 50 56 00 	mov    $0x565000,%rcx
}
ffffffff81016b33:	5b                   	pop    %rbx
void Space_obj::page_fault (mword addr, mword error)
{
    assert (!(error & Hpt::ERR_W));

    if (!Pd::current->Space_mem::loc[Cpu::id].sync_from (Pd::current->quota, Pd::current->Space_mem::hpt, addr, CPU_LOCAL))
        Pd::current->Space_mem::replace (Pd::current->quota, addr, reinterpret_cast<Paddr>(&FRAME_0) | Hpt::HPT_NX | Hpt::HPT_A | Hpt::HPT_P);
ffffffff81016b34:	48 83 c9 21          	or     $0x21,%rcx
ffffffff81016b38:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff81016b3f:	48 8d b8 a0 02 00 00 	lea    0x2a0(%rax),%rdi
ffffffff81016b46:	e9 5d 15 ff ff       	jmpq   ffffffff810080a8 <_ZN3Hpt7replaceER5Quotamm>
}
ffffffff81016b4b:	5b                   	pop    %rbx
ffffffff81016b4c:	c3                   	retq   
ffffffff81016b4d:	90                   	nop

ffffffff81016b4e <_ZN9Space_pio4walkER5Quotabm>:
    return static_cast<Pd *>(this);
}

Paddr Space_pio::walk (Quota &quota, bool host, mword idx)
{
    Paddr &bmp = host ? hbmp : gbmp;
ffffffff81016b4e:	84 d2                	test   %dl,%dl
{
    return static_cast<Pd *>(this);
}

Paddr Space_pio::walk (Quota &quota, bool host, mword idx)
{
ffffffff81016b50:	41 55                	push   %r13
ffffffff81016b52:	41 54                	push   %r12
ffffffff81016b54:	49 89 f5             	mov    %rsi,%r13
ffffffff81016b57:	55                   	push   %rbp
ffffffff81016b58:	48 89 cd             	mov    %rcx,%rbp
ffffffff81016b5b:	53                   	push   %rbx
ffffffff81016b5c:	48 89 fb             	mov    %rdi,%rbx
ffffffff81016b5f:	41 50                	push   %r8
    Paddr &bmp = host ? hbmp : gbmp;
ffffffff81016b61:	74 57                	je     ffffffff81016bba <_ZN9Space_pio4walkER5Quotabm+0x6c>

    if (!bmp) {
ffffffff81016b63:	48 83 7f 10 00       	cmpq   $0x0,0x10(%rdi)
    return static_cast<Pd *>(this);
}

Paddr Space_pio::walk (Quota &quota, bool host, mword idx)
{
    Paddr &bmp = host ? hbmp : gbmp;
ffffffff81016b68:	4c 8d 67 10          	lea    0x10(%rdi),%r12

    if (!bmp) {
ffffffff81016b6c:	75 7a                	jne    ffffffff81016be8 <_ZN9Space_pio4walkER5Quotabm+0x9a>
        bmp = Buddy::ptr_to_phys (Buddy::allocator.alloc (1, quota, Buddy::FILL_1));
ffffffff81016b6e:	48 89 f2             	mov    %rsi,%rdx
ffffffff81016b71:	b9 02 00 00 00       	mov    $0x2,%ecx
ffffffff81016b76:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff81016b7b:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff81016b82:	e8 6b ad fe ff       	callq  ffffffff810018f2 <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
        }

        ALWAYS_INLINE
        inline void insert (Quota &quota, mword virt, unsigned o, mword attr, Paddr phys)
        {
            hpt.update (quota, virt, o, phys, attr);
ffffffff81016b87:	6a 00                	pushq  $0x0
ffffffff81016b89:	48 2d 00 00 c0 80    	sub    $0xffffffff80c00000,%rax
ffffffff81016b8f:	6a 00                	pushq  $0x0
ffffffff81016b91:	48 8d 7b c8          	lea    -0x38(%rbx),%rdi
ffffffff81016b95:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff81016b9a:	4c 89 ee             	mov    %r13,%rsi
ffffffff81016b9d:	49 89 c0             	mov    %rax,%r8
ffffffff81016ba0:	48 89 43 10          	mov    %rax,0x10(%rbx)
ffffffff81016ba4:	41 b9 63 00 00 00    	mov    $0x63,%r9d
ffffffff81016baa:	48 c7 c2 00 00 00 c0 	mov    $0xffffffffc0000000,%rdx
ffffffff81016bb1:	e8 60 c1 ff ff       	callq  ffffffff81012d16 <_ZN3PteI3HptmLj4ELj9ELb0EE6updateER5QuotammmmNS1_4TypeEb>
ffffffff81016bb6:	59                   	pop    %rcx
ffffffff81016bb7:	5e                   	pop    %rsi
ffffffff81016bb8:	eb 2e                	jmp    ffffffff81016be8 <_ZN9Space_pio4walkER5Quotabm+0x9a>

Paddr Space_pio::walk (Quota &quota, bool host, mword idx)
{
    Paddr &bmp = host ? hbmp : gbmp;

    if (!bmp) {
ffffffff81016bba:	48 83 7f 18 00       	cmpq   $0x0,0x18(%rdi)
    return static_cast<Pd *>(this);
}

Paddr Space_pio::walk (Quota &quota, bool host, mword idx)
{
    Paddr &bmp = host ? hbmp : gbmp;
ffffffff81016bbf:	4c 8d 67 18          	lea    0x18(%rdi),%r12

    if (!bmp) {
ffffffff81016bc3:	75 23                	jne    ffffffff81016be8 <_ZN9Space_pio4walkER5Quotabm+0x9a>
        bmp = Buddy::ptr_to_phys (Buddy::allocator.alloc (1, quota, Buddy::FILL_1));
ffffffff81016bc5:	48 89 f2             	mov    %rsi,%rdx
ffffffff81016bc8:	b9 02 00 00 00       	mov    $0x2,%ecx
ffffffff81016bcd:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff81016bd2:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff81016bd9:	e8 14 ad fe ff       	callq  ffffffff810018f2 <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
ffffffff81016bde:	48 2d 00 00 c0 80    	sub    $0xffffffff80c00000,%rax
ffffffff81016be4:	48 89 43 18          	mov    %rax,0x18(%rbx)
        Paddr hbmp, gbmp;

        ALWAYS_INLINE
        static inline mword idx_to_virt (mword idx)
        {
            return SPC_LOCAL_IOP + (idx / 8 / sizeof (mword)) * sizeof (mword);
ffffffff81016be8:	48 89 e8             	mov    %rbp,%rax
ffffffff81016beb:	48 c1 e8 03          	shr    $0x3,%rax

        if (host)
            space_mem()->insert (quota, SPC_LOCAL_IOP, 1, Hpt::HPT_NX | Hpt::HPT_D | Hpt::HPT_A | Hpt::HPT_W | Hpt::HPT_P, bmp);
    }

    return bmp | (idx_to_virt (idx) & (2 * PAGE_SIZE - 1));
ffffffff81016bef:	25 f8 1f 00 00       	and    $0x1ff8,%eax
ffffffff81016bf4:	49 0b 04 24          	or     (%r12),%rax
}
ffffffff81016bf8:	5a                   	pop    %rdx
ffffffff81016bf9:	5b                   	pop    %rbx
ffffffff81016bfa:	5d                   	pop    %rbp
ffffffff81016bfb:	41 5c                	pop    %r12
ffffffff81016bfd:	41 5d                	pop    %r13
ffffffff81016bff:	c3                   	retq   

ffffffff81016c00 <_ZN9Space_pio6updateER5Quotabmm>:

void Space_pio::update (Quota &quota, bool host, mword idx, mword attr)
{
ffffffff81016c00:	53                   	push   %rbx
    mword *m = static_cast<mword *>(Buddy::phys_to_ptr (walk (quota, host, idx)));
ffffffff81016c01:	0f b6 d2             	movzbl %dl,%edx

    return bmp | (idx_to_virt (idx) & (2 * PAGE_SIZE - 1));
}

void Space_pio::update (Quota &quota, bool host, mword idx, mword attr)
{
ffffffff81016c04:	48 89 cb             	mov    %rcx,%rbx
ffffffff81016c07:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff81016c0b:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
    mword *m = static_cast<mword *>(Buddy::phys_to_ptr (walk (quota, host, idx)));
ffffffff81016c10:	e8 39 ff ff ff       	callq  ffffffff81016b4e <_ZN9Space_pio4walkER5Quotabm>

    if (attr)
ffffffff81016c15:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
        }

        ALWAYS_INLINE
        inline mword phys_to_virt (mword phys)
        {
            return phys + reinterpret_cast<mword>(&OFFSET);
ffffffff81016c1a:	48 05 00 00 c0 80    	add    $0xffffffff80c00000,%rax
ffffffff81016c20:	4d 85 c0             	test   %r8,%r8
ffffffff81016c23:	74 16                	je     ffffffff81016c3b <_ZN9Space_pio6updateER5Quotabmm+0x3b>
        }

        ALWAYS_INLINE
        static inline mword idx_to_mask (mword idx)
        {
            return 1UL << (idx % (8 * sizeof (mword)));
ffffffff81016c25:	83 e3 3f             	and    $0x3f,%ebx
ffffffff81016c28:	48 c7 c2 fe ff ff ff 	mov    $0xfffffffffffffffe,%rdx
ffffffff81016c2f:	48 89 d9             	mov    %rbx,%rcx

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
ffffffff81016c32:	48 d3 c2             	rol    %cl,%rdx
ffffffff81016c35:	f0 48 21 10          	lock and %rdx,(%rax)
ffffffff81016c39:	eb 12                	jmp    ffffffff81016c4d <_ZN9Space_pio6updateER5Quotabmm+0x4d>
ffffffff81016c3b:	48 89 d9             	mov    %rbx,%rcx
ffffffff81016c3e:	ba 01 00 00 00       	mov    $0x1,%edx
ffffffff81016c43:	83 e1 3f             	and    $0x3f,%ecx
ffffffff81016c46:	48 d3 e2             	shl    %cl,%rdx
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }
ffffffff81016c49:	f0 48 09 10          	lock or %rdx,(%rax)
        Atomic::clr_mask (*m, idx_to_mask (idx));
    else
        Atomic::set_mask (*m, idx_to_mask (idx));
}
ffffffff81016c4d:	48 83 c4 10          	add    $0x10,%rsp
ffffffff81016c51:	5b                   	pop    %rbx
ffffffff81016c52:	c3                   	retq   
ffffffff81016c53:	90                   	nop

ffffffff81016c54 <_ZN9Space_pio6updateER5QuotaP3Mdbm>:

bool Space_pio::update (Quota &quota, Mdb *mdb, mword r)
{
ffffffff81016c54:	41 57                	push   %r15
ffffffff81016c56:	41 56                	push   %r14
ffffffff81016c58:	41 55                	push   %r13
ffffffff81016c5a:	41 54                	push   %r12
ffffffff81016c5c:	49 89 fc             	mov    %rdi,%r12
ffffffff81016c5f:	55                   	push   %rbp
ffffffff81016c60:	53                   	push   %rbx
ffffffff81016c61:	48 83 ec 18          	sub    $0x18,%rsp
    assert (this == mdb->space && this != &Pd::kern);
ffffffff81016c65:	48 81 ff 78 3f 16 81 	cmp    $0xffffffff81163f78,%rdi
ffffffff81016c6c:	0f 84 20 01 00 00    	je     ffffffff81016d92 <_ZN9Space_pio6updateER5QuotaP3Mdbm+0x13e>
ffffffff81016c72:	48 3b 7a 50          	cmp    0x50(%rdx),%rdi
ffffffff81016c76:	48 89 d3             	mov    %rdx,%rbx
ffffffff81016c79:	0f 85 13 01 00 00    	jne    ffffffff81016d92 <_ZN9Space_pio6updateER5QuotaP3Mdbm+0x13e>
ffffffff81016c7f:	49 89 f6             	mov    %rsi,%r14
ffffffff81016c82:	49 89 cd             	mov    %rcx,%r13

    Lock_guard <Spinlock> guard (mdb->node_lock);
ffffffff81016c85:	48 8d 7a 30          	lea    0x30(%rdx),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81016c89:	9c                   	pushfq 
ffffffff81016c8a:	58                   	pop    %rax
            return flags & 0x200;
ffffffff81016c8b:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff81016c8f:	40 88 c5             	mov    %al,%bpl
ffffffff81016c92:	40 80 e5 01          	and    $0x1,%bpl
ffffffff81016c96:	74 30                	je     ffffffff81016cc8 <_ZN9Space_pio6updateER5QuotaP3Mdbm+0x74>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81016c98:	80 3d 91 8a fe 3e 00 	cmpb   $0x0,0x3efe8a91(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81016c9f:	75 1f                	jne    ffffffff81016cc0 <_ZN9Space_pio6updateER5QuotaP3Mdbm+0x6c>
ffffffff81016ca1:	49 c7 c0 20 0c 02 81 	mov    $0xffffffff81020c20,%r8
ffffffff81016ca8:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff81016cad:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81016cb4:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff81016cbb:	e9 ba 00 00 00       	jmpq   ffffffff81016d7a <_ZN9Space_pio6updateER5QuotaP3Mdbm+0x126>

            asm volatile ("cli" : : : "memory");
ffffffff81016cc0:	fa                   	cli    
            preemption = false;
ffffffff81016cc1:	c6 05 68 8a fe 3e 00 	movb   $0x0,0x3efe8a68(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff81016cc8:	e8 c1 a1 fe ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>

    if (mdb->node_sub & 2)
ffffffff81016ccd:	f6 83 80 00 00 00 02 	testb  $0x2,0x80(%rbx)
ffffffff81016cd4:	75 08                	jne    ffffffff81016cde <_ZN9Space_pio6updateER5QuotaP3Mdbm+0x8a>
ffffffff81016cd6:	45 31 ff             	xor    %r15d,%r15d
        for (unsigned long i = 0; i < (1UL << mdb->node_order); i++)
            update (quota, false, mdb->node_base + i, mdb->node_attr & ~r);

    for (unsigned long i = 0; i < (1UL << mdb->node_order); i++)
        update (quota, true, mdb->node_base + i, mdb->node_attr & ~r);
ffffffff81016cd9:	49 f7 d5             	not    %r13
ffffffff81016cdc:	eb 3f                	jmp    ffffffff81016d1d <_ZN9Space_pio6updateER5QuotaP3Mdbm+0xc9>

    Lock_guard <Spinlock> guard (mdb->node_lock);

    if (mdb->node_sub & 2)
        for (unsigned long i = 0; i < (1UL << mdb->node_order); i++)
            update (quota, false, mdb->node_base + i, mdb->node_attr & ~r);
ffffffff81016cde:	4c 89 e8             	mov    %r13,%rax
ffffffff81016ce1:	45 31 ff             	xor    %r15d,%r15d
ffffffff81016ce4:	48 f7 d0             	not    %rax
ffffffff81016ce7:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    assert (this == mdb->space && this != &Pd::kern);

    Lock_guard <Spinlock> guard (mdb->node_lock);

    if (mdb->node_sub & 2)
        for (unsigned long i = 0; i < (1UL << mdb->node_order); i++)
ffffffff81016cec:	48 8b 4b 68          	mov    0x68(%rbx),%rcx
ffffffff81016cf0:	4c 89 fa             	mov    %r15,%rdx
ffffffff81016cf3:	48 d3 ea             	shr    %cl,%rdx
ffffffff81016cf6:	48 85 d2             	test   %rdx,%rdx
ffffffff81016cf9:	75 db                	jne    ffffffff81016cd6 <_ZN9Space_pio6updateER5QuotaP3Mdbm+0x82>
            update (quota, false, mdb->node_base + i, mdb->node_attr & ~r);
ffffffff81016cfb:	4c 89 f9             	mov    %r15,%rcx
ffffffff81016cfe:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
ffffffff81016d03:	48 03 4b 60          	add    0x60(%rbx),%rcx
ffffffff81016d07:	4c 23 43 70          	and    0x70(%rbx),%r8
ffffffff81016d0b:	31 d2                	xor    %edx,%edx
ffffffff81016d0d:	4c 89 f6             	mov    %r14,%rsi
ffffffff81016d10:	4c 89 e7             	mov    %r12,%rdi
    assert (this == mdb->space && this != &Pd::kern);

    Lock_guard <Spinlock> guard (mdb->node_lock);

    if (mdb->node_sub & 2)
        for (unsigned long i = 0; i < (1UL << mdb->node_order); i++)
ffffffff81016d13:	49 ff c7             	inc    %r15
            update (quota, false, mdb->node_base + i, mdb->node_attr & ~r);
ffffffff81016d16:	e8 e5 fe ff ff       	callq  ffffffff81016c00 <_ZN9Space_pio6updateER5Quotabmm>
ffffffff81016d1b:	eb cf                	jmp    ffffffff81016cec <_ZN9Space_pio6updateER5QuotaP3Mdbm+0x98>

    for (unsigned long i = 0; i < (1UL << mdb->node_order); i++)
ffffffff81016d1d:	48 8b 4b 68          	mov    0x68(%rbx),%rcx
ffffffff81016d21:	4c 89 f8             	mov    %r15,%rax
ffffffff81016d24:	48 d3 e8             	shr    %cl,%rax
ffffffff81016d27:	48 85 c0             	test   %rax,%rax
ffffffff81016d2a:	75 23                	jne    ffffffff81016d4f <_ZN9Space_pio6updateER5QuotaP3Mdbm+0xfb>
        update (quota, true, mdb->node_base + i, mdb->node_attr & ~r);
ffffffff81016d2c:	4c 89 f9             	mov    %r15,%rcx
ffffffff81016d2f:	4d 89 e8             	mov    %r13,%r8
ffffffff81016d32:	48 03 4b 60          	add    0x60(%rbx),%rcx
ffffffff81016d36:	4c 23 43 70          	and    0x70(%rbx),%r8
ffffffff81016d3a:	ba 01 00 00 00       	mov    $0x1,%edx
ffffffff81016d3f:	4c 89 f6             	mov    %r14,%rsi
ffffffff81016d42:	4c 89 e7             	mov    %r12,%rdi

    if (mdb->node_sub & 2)
        for (unsigned long i = 0; i < (1UL << mdb->node_order); i++)
            update (quota, false, mdb->node_base + i, mdb->node_attr & ~r);

    for (unsigned long i = 0; i < (1UL << mdb->node_order); i++)
ffffffff81016d45:	49 ff c7             	inc    %r15
        update (quota, true, mdb->node_base + i, mdb->node_attr & ~r);
ffffffff81016d48:	e8 b3 fe ff ff       	callq  ffffffff81016c00 <_ZN9Space_pio6updateER5Quotabmm>
ffffffff81016d4d:	eb ce                	jmp    ffffffff81016d1d <_ZN9Space_pio6updateER5QuotaP3Mdbm+0xc9>
ffffffff81016d4f:	fe 43 30             	incb   0x30(%rbx)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81016d52:	40 84 ed             	test   %bpl,%bpl
ffffffff81016d55:	74 57                	je     ffffffff81016dae <_ZN9Space_pio6updateER5QuotaP3Mdbm+0x15a>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81016d57:	80 3d d2 89 fe 3e 00 	cmpb   $0x0,0x3efe89d2(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81016d5e:	74 28                	je     ffffffff81016d88 <_ZN9Space_pio6updateER5QuotaP3Mdbm+0x134>
ffffffff81016d60:	49 c7 c0 f0 0b 02 81 	mov    $0xffffffff81020bf0,%r8
ffffffff81016d67:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff81016d6c:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81016d73:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff81016d7a:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81016d81:	31 c0                	xor    %eax,%eax
ffffffff81016d83:	e8 c8 b1 fe ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            preemption = true;
ffffffff81016d88:	c6 05 a1 89 fe 3e 01 	movb   $0x1,0x3efe89a1(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81016d8f:	fb                   	sti    
ffffffff81016d90:	eb 1c                	jmp    ffffffff81016dae <_ZN9Space_pio6updateER5QuotaP3Mdbm+0x15a>
        Atomic::set_mask (*m, idx_to_mask (idx));
}

bool Space_pio::update (Quota &quota, Mdb *mdb, mword r)
{
    assert (this == mdb->space && this != &Pd::kern);
ffffffff81016d92:	49 c7 c0 50 0c 02 81 	mov    $0xffffffff81020c50,%r8
ffffffff81016d99:	b9 36 00 00 00       	mov    $0x36,%ecx
ffffffff81016d9e:	48 c7 c2 4c 0b 02 81 	mov    $0xffffffff81020b4c,%rdx
ffffffff81016da5:	48 c7 c6 44 09 02 81 	mov    $0xffffffff81020944,%rsi
ffffffff81016dac:	eb cc                	jmp    ffffffff81016d7a <_ZN9Space_pio6updateER5QuotaP3Mdbm+0x126>

    for (unsigned long i = 0; i < (1UL << mdb->node_order); i++)
        update (quota, true, mdb->node_base + i, mdb->node_attr & ~r);

    return false;
}
ffffffff81016dae:	48 83 c4 18          	add    $0x18,%rsp
ffffffff81016db2:	31 c0                	xor    %eax,%eax
ffffffff81016db4:	5b                   	pop    %rbx
ffffffff81016db5:	5d                   	pop    %rbp
ffffffff81016db6:	41 5c                	pop    %r12
ffffffff81016db8:	41 5d                	pop    %r13
ffffffff81016dba:	41 5e                	pop    %r14
ffffffff81016dbc:	41 5f                	pop    %r15
ffffffff81016dbe:	c3                   	retq   
ffffffff81016dbf:	90                   	nop

ffffffff81016dc0 <_ZN9Space_pio10page_faultEmm>:

void Space_pio::page_fault (mword addr, mword error)
{
    assert (!(error & Hpt::ERR_W));
ffffffff81016dc0:	40 80 e6 02          	and    $0x2,%sil

    return false;
}

void Space_pio::page_fault (mword addr, mword error)
{
ffffffff81016dc4:	53                   	push   %rbx
    assert (!(error & Hpt::ERR_W));
ffffffff81016dc5:	74 28                	je     ffffffff81016def <_ZN9Space_pio10page_faultEmm+0x2f>
ffffffff81016dc7:	49 c7 c0 c0 0b 02 81 	mov    $0xffffffff81020bc0,%r8
ffffffff81016dce:	b9 46 00 00 00       	mov    $0x46,%ecx
ffffffff81016dd3:	48 c7 c2 4c 0b 02 81 	mov    $0xffffffff81020b4c,%rdx
ffffffff81016dda:	48 c7 c6 73 0a 02 81 	mov    $0xffffffff81020a73,%rsi
ffffffff81016de1:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81016de8:	31 c0                	xor    %eax,%eax
ffffffff81016dea:	e8 61 b1 fe ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

    if (!Pd::current->Space_mem::loc[Cpu::id].sync_from (Pd::current->quota, Pd::current->Space_mem::hpt, addr, CPU_LOCAL))
ffffffff81016def:	48 8b 05 1a 82 fe 3e 	mov    0x3efe821a(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81016df6:	8b 0d 08 82 fe 3e    	mov    0x3efe8208(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81016dfc:	48 89 fb             	mov    %rdi,%rbx
ffffffff81016dff:	49 c7 c0 00 00 e0 bf 	mov    $0xffffffffbfe00000,%r8
ffffffff81016e06:	48 8b 90 a0 02 00 00 	mov    0x2a0(%rax),%rdx
ffffffff81016e0d:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff81016e14:	48 8d bc c8 a0 00 00 	lea    0xa0(%rax,%rcx,8),%rdi
ffffffff81016e1b:	00 
ffffffff81016e1c:	48 89 d9             	mov    %rbx,%rcx
ffffffff81016e1f:	e8 5e 11 ff ff       	callq  ffffffff81007f82 <_ZN3Hpt9sync_fromER5QuotaS_mm>
ffffffff81016e24:	84 c0                	test   %al,%al
ffffffff81016e26:	75 29                	jne    ffffffff81016e51 <_ZN9Space_pio10page_faultEmm+0x91>
        Pd::current->Space_mem::replace (Pd::current->quota, addr, reinterpret_cast<Paddr>(&FRAME_1) | Hpt::HPT_NX | Hpt::HPT_A | Hpt::HPT_P);
ffffffff81016e28:	48 8b 05 e1 81 fe 3e 	mov    0x3efe81e1(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
        }

        ALWAYS_INLINE
        inline Paddr replace (Quota &quota, mword v, Paddr p)
        {
            return hpt.replace (quota, v, p);
ffffffff81016e2f:	48 89 da             	mov    %rbx,%rdx
ffffffff81016e32:	48 c7 c1 00 60 56 00 	mov    $0x566000,%rcx
}
ffffffff81016e39:	5b                   	pop    %rbx
void Space_pio::page_fault (mword addr, mword error)
{
    assert (!(error & Hpt::ERR_W));

    if (!Pd::current->Space_mem::loc[Cpu::id].sync_from (Pd::current->quota, Pd::current->Space_mem::hpt, addr, CPU_LOCAL))
        Pd::current->Space_mem::replace (Pd::current->quota, addr, reinterpret_cast<Paddr>(&FRAME_1) | Hpt::HPT_NX | Hpt::HPT_A | Hpt::HPT_P);
ffffffff81016e3a:	48 83 c9 21          	or     $0x21,%rcx
ffffffff81016e3e:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff81016e45:	48 8d b8 a0 02 00 00 	lea    0x2a0(%rax),%rdi
ffffffff81016e4c:	e9 57 12 ff ff       	jmpq   ffffffff810080a8 <_ZN3Hpt7replaceER5Quotamm>
}
ffffffff81016e51:	5b                   	pop    %rbx
ffffffff81016e52:	c3                   	retq   

.text

1:                      mov     %REG(ax), %cr3
ffffffff81016e53:	0f 22 d8             	mov    %rax,%cr3
                        mov     $(CPU_LOCAL_STCK + PAGE_SIZE), %REG(sp)
ffffffff81016e56:	48 c7 c4 00 e0 ff bf 	mov    $0xffffffffbfffe000,%rsp
                        jmp     bootstrap
ffffffff81016e5d:	e9 39 a4 fe ff       	jmpq   ffffffff8100129b <bootstrap>

ffffffff81016e62 <memcpy>:
    const char *s;
    char *d;

    s = reinterpret_cast<const char*> (src);
    d = reinterpret_cast<char*> (dst);
    if (s < d && s + n > d) {
ffffffff81016e62:	48 39 fe             	cmp    %rdi,%rsi

#include "compiler.hpp"
#include "types.hpp"

extern "C" NONNULL
inline void *memcpy(void *dst, const void *src, size_t n) {
ffffffff81016e65:	48 89 f8             	mov    %rdi,%rax
ffffffff81016e68:	48 89 d1             	mov    %rdx,%rcx
    const char *s;
    char *d;

    s = reinterpret_cast<const char*> (src);
    d = reinterpret_cast<char*> (dst);
    if (s < d && s + n > d) {
ffffffff81016e6b:	73 3b                	jae    ffffffff81016ea8 <memcpy+0x46>
ffffffff81016e6d:	48 8d 14 16          	lea    (%rsi,%rdx,1),%rdx
ffffffff81016e71:	48 39 fa             	cmp    %rdi,%rdx
ffffffff81016e74:	76 32                	jbe    ffffffff81016ea8 <memcpy+0x46>
        s += n;
        d += n;
ffffffff81016e76:	48 8d 3c 0f          	lea    (%rdi,%rcx,1),%rdi
ffffffff81016e7a:	48 89 d6             	mov    %rdx,%rsi
ffffffff81016e7d:	48 09 fe             	or     %rdi,%rsi
        if ((mword) s % 4 == 0 && (mword) d % 4 == 0 && n % 4 == 0)
ffffffff81016e80:	40 80 e6 03          	and    $0x3,%sil
ffffffff81016e84:	75 16                	jne    ffffffff81016e9c <memcpy+0x3a>
ffffffff81016e86:	f6 c1 03             	test   $0x3,%cl
ffffffff81016e89:	75 11                	jne    ffffffff81016e9c <memcpy+0x3a>
            asm volatile("std; rep movsl\n"
                        ::"D" (d - 4), "S" (s - 4), "c" (n / 4) : "cc", "memory");
ffffffff81016e8b:	48 83 ef 04          	sub    $0x4,%rdi
ffffffff81016e8f:	48 8d 72 fc          	lea    -0x4(%rdx),%rsi
ffffffff81016e93:	48 c1 e9 02          	shr    $0x2,%rcx
ffffffff81016e97:	fd                   	std    
ffffffff81016e98:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
ffffffff81016e9a:	eb 0a                	jmp    ffffffff81016ea6 <memcpy+0x44>
        else
            asm volatile("std; rep movsb\n"
                        ::"D" (d - 1), "S" (s - 1), "c" (n) : "cc", "memory");
ffffffff81016e9c:	48 ff cf             	dec    %rdi
ffffffff81016e9f:	48 8d 72 ff          	lea    -0x1(%rdx),%rsi
ffffffff81016ea3:	fd                   	std    
ffffffff81016ea4:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
        // Some versions of GCC rely on DF being clear
        asm volatile("cld" :: : "cc");
ffffffff81016ea6:	fc                   	cld    
ffffffff81016ea7:	c3                   	retq   
ffffffff81016ea8:	48 89 f2             	mov    %rsi,%rdx
ffffffff81016eab:	48 09 c2             	or     %rax,%rdx
    } else {
        if ((mword) s % 4 == 0 && (mword) d % 4 == 0 && n % 4 == 0)
ffffffff81016eae:	80 e2 03             	and    $0x3,%dl
ffffffff81016eb1:	75 10                	jne    ffffffff81016ec3 <memcpy+0x61>
ffffffff81016eb3:	f6 c1 03             	test   $0x3,%cl
ffffffff81016eb6:	75 0b                	jne    ffffffff81016ec3 <memcpy+0x61>
            asm volatile("cld; rep movsl\n"
                        ::"D" (d), "S" (s), "c" (n / 4) : "cc", "memory");
ffffffff81016eb8:	48 c1 e9 02          	shr    $0x2,%rcx
ffffffff81016ebc:	48 89 c7             	mov    %rax,%rdi
ffffffff81016ebf:	fc                   	cld    
ffffffff81016ec0:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
ffffffff81016ec2:	c3                   	retq   
        else
            asm volatile("cld; rep movsb\n"
                        ::"D" (d), "S" (s), "c" (n) : "cc", "memory");
ffffffff81016ec3:	48 89 c7             	mov    %rax,%rdi
ffffffff81016ec6:	fc                   	cld    
ffffffff81016ec7:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
    }
    return dst;
}
ffffffff81016ec9:	c3                   	retq   

ffffffff81016eca <_ZN4VmcbC1ER5Quotamm>:
Paddr Vmcb::root;
unsigned Vmcb::asid_ctr;
uint32 Vmcb::svm_version;
uint32 Vmcb::svm_feature;

Vmcb::Vmcb(Quota &quota, mword bmp, mword nptp) : base_io(bmp), asid(++asid_ctr), int_control(1ul << 24), npt_cr3(nptp), efer(Cpu::EFER_SVME), g_pat(0x7040600070406ull) {
ffffffff81016eca:	8b 05 58 8e fe 3e    	mov    0x3efe8e58(%rip),%eax        # ffffffffbffffd28 <_ZN4Vmcb8asid_ctrE>
ffffffff81016ed0:	53                   	push   %rbx
ffffffff81016ed1:	48 89 fb             	mov    %rdi,%rbx
ffffffff81016ed4:	48 89 57 40          	mov    %rdx,0x40(%rdi)
ffffffff81016ed8:	48 89 8f b0 00 00 00 	mov    %rcx,0xb0(%rdi)
    base_msr = Buddy::ptr_to_phys(Buddy::allocator.alloc(1, quota, Buddy::FILL_1));
ffffffff81016edf:	48 89 f2             	mov    %rsi,%rdx
Paddr Vmcb::root;
unsigned Vmcb::asid_ctr;
uint32 Vmcb::svm_version;
uint32 Vmcb::svm_feature;

Vmcb::Vmcb(Quota &quota, mword bmp, mword nptp) : base_io(bmp), asid(++asid_ctr), int_control(1ul << 24), npt_cr3(nptp), efer(Cpu::EFER_SVME), g_pat(0x7040600070406ull) {
ffffffff81016ee2:	48 c7 47 60 00 00 00 	movq   $0x1000000,0x60(%rdi)
ffffffff81016ee9:	01 
ffffffff81016eea:	48 c7 87 d0 04 00 00 	movq   $0x1000,0x4d0(%rdi)
ffffffff81016ef1:	00 10 00 00 
    base_msr = Buddy::ptr_to_phys(Buddy::allocator.alloc(1, quota, Buddy::FILL_1));
ffffffff81016ef5:	b9 02 00 00 00       	mov    $0x2,%ecx
Paddr Vmcb::root;
unsigned Vmcb::asid_ctr;
uint32 Vmcb::svm_version;
uint32 Vmcb::svm_feature;

Vmcb::Vmcb(Quota &quota, mword bmp, mword nptp) : base_io(bmp), asid(++asid_ctr), int_control(1ul << 24), npt_cr3(nptp), efer(Cpu::EFER_SVME), g_pat(0x7040600070406ull) {
ffffffff81016efa:	ff c0                	inc    %eax
    base_msr = Buddy::ptr_to_phys(Buddy::allocator.alloc(1, quota, Buddy::FILL_1));
ffffffff81016efc:	be 01 00 00 00       	mov    $0x1,%esi
Paddr Vmcb::root;
unsigned Vmcb::asid_ctr;
uint32 Vmcb::svm_version;
uint32 Vmcb::svm_feature;

Vmcb::Vmcb(Quota &quota, mword bmp, mword nptp) : base_io(bmp), asid(++asid_ctr), int_control(1ul << 24), npt_cr3(nptp), efer(Cpu::EFER_SVME), g_pat(0x7040600070406ull) {
ffffffff81016f01:	89 47 58             	mov    %eax,0x58(%rdi)
ffffffff81016f04:	89 05 1e 8e fe 3e    	mov    %eax,0x3efe8e1e(%rip)        # ffffffffbffffd28 <_ZN4Vmcb8asid_ctrE>
ffffffff81016f0a:	48 b8 06 04 07 00 06 	movabs $0x7040600070406,%rax
ffffffff81016f11:	04 07 00 
ffffffff81016f14:	48 89 87 68 06 00 00 	mov    %rax,0x668(%rdi)
    base_msr = Buddy::ptr_to_phys(Buddy::allocator.alloc(1, quota, Buddy::FILL_1));
ffffffff81016f1b:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff81016f22:	e8 cb a9 fe ff       	callq  ffffffff810018f2 <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
        }

        ALWAYS_INLINE
        inline mword virt_to_phys (mword virt)
        {
            return virt - reinterpret_cast<mword>(&OFFSET);
ffffffff81016f27:	48 2d 00 00 c0 80    	sub    $0xffffffff80c00000,%rax
ffffffff81016f2d:	48 89 43 48          	mov    %rax,0x48(%rbx)
}
ffffffff81016f31:	5b                   	pop    %rbx
ffffffff81016f32:	c3                   	retq   
ffffffff81016f33:	90                   	nop

ffffffff81016f34 <_ZN4Vmcb5cloneEv>:

Vmcb* Vmcb::clone() {
ffffffff81016f34:	53                   	push   %rbx
            CPU_CLGI |
            CPU_SKINIT;

    ALWAYS_INLINE
    static inline void *operator new (size_t, Quota &quota) {
        return Buddy::allocator.alloc(0, quota, Buddy::FILL_0);
ffffffff81016f35:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff81016f3a:	48 89 fb             	mov    %rdi,%rbx
ffffffff81016f3d:	48 c7 c2 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rdx
ffffffff81016f44:	31 f6                	xor    %esi,%esi
ffffffff81016f46:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff81016f4d:	e8 a0 a9 fe ff       	callq  ffffffff810018f2 <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
ffffffff81016f52:	48 89 c2             	mov    %rax,%rdx
ffffffff81016f55:	48 2d 00 00 c0 80    	sub    $0xffffffff80c00000,%rax
    Vmcb(Quota &quota, mword, mword);
    Vmcb* clone();

    ALWAYS_INLINE
    inline Vmcb() {
        asm volatile ("vmsave" : : "a" (Buddy::ptr_to_phys(this)) : "memory");
ffffffff81016f5b:	0f 01 db             	vmsave 
    const char *s;
    char *d;

    s = reinterpret_cast<const char*> (src);
    d = reinterpret_cast<char*> (dst);
    if (s < d && s + n > d) {
ffffffff81016f5e:	48 39 d3             	cmp    %rdx,%rbx
ffffffff81016f61:	73 44                	jae    ffffffff81016fa7 <_ZN4Vmcb5cloneEv+0x73>
ffffffff81016f63:	48 8d 83 00 10 00 00 	lea    0x1000(%rbx),%rax
ffffffff81016f6a:	48 39 d0             	cmp    %rdx,%rax
ffffffff81016f6d:	76 38                	jbe    ffffffff81016fa7 <_ZN4Vmcb5cloneEv+0x73>
ffffffff81016f6f:	48 09 d0             	or     %rdx,%rax
        s += n;
        d += n;
        if ((mword) s % 4 == 0 && (mword) d % 4 == 0 && n % 4 == 0)
ffffffff81016f72:	a8 03                	test   $0x3,%al
ffffffff81016f74:	75 18                	jne    ffffffff81016f8e <_ZN4Vmcb5cloneEv+0x5a>
            asm volatile("std; rep movsl\n"
                        ::"D" (d - 4), "S" (s - 4), "c" (n / 4) : "cc", "memory");
ffffffff81016f76:	48 8d ba fc 0f 00 00 	lea    0xffc(%rdx),%rdi
ffffffff81016f7d:	48 8d b3 fc 0f 00 00 	lea    0xffc(%rbx),%rsi
ffffffff81016f84:	b9 00 04 00 00       	mov    $0x400,%ecx
ffffffff81016f89:	fd                   	std    
ffffffff81016f8a:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
ffffffff81016f8c:	eb 16                	jmp    ffffffff81016fa4 <_ZN4Vmcb5cloneEv+0x70>
        else
            asm volatile("std; rep movsb\n"
                        ::"D" (d - 1), "S" (s - 1), "c" (n) : "cc", "memory");
ffffffff81016f8e:	48 8d ba ff 0f 00 00 	lea    0xfff(%rdx),%rdi
ffffffff81016f95:	48 8d b3 ff 0f 00 00 	lea    0xfff(%rbx),%rsi
ffffffff81016f9c:	b9 00 10 00 00       	mov    $0x1000,%ecx
ffffffff81016fa1:	fd                   	std    
ffffffff81016fa2:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
        // Some versions of GCC rely on DF being clear
        asm volatile("cld" :: : "cc");
ffffffff81016fa4:	fc                   	cld    
ffffffff81016fa5:	eb 28                	jmp    ffffffff81016fcf <_ZN4Vmcb5cloneEv+0x9b>
ffffffff81016fa7:	48 89 d8             	mov    %rbx,%rax
ffffffff81016faa:	48 09 d0             	or     %rdx,%rax
    } else {
        if ((mword) s % 4 == 0 && (mword) d % 4 == 0 && n % 4 == 0)
ffffffff81016fad:	a8 03                	test   $0x3,%al
ffffffff81016faf:	75 10                	jne    ffffffff81016fc1 <_ZN4Vmcb5cloneEv+0x8d>
            asm volatile("cld; rep movsl\n"
                        ::"D" (d), "S" (s), "c" (n / 4) : "cc", "memory");
ffffffff81016fb1:	b9 00 04 00 00       	mov    $0x400,%ecx
ffffffff81016fb6:	48 89 d7             	mov    %rdx,%rdi
ffffffff81016fb9:	48 89 de             	mov    %rbx,%rsi
ffffffff81016fbc:	fc                   	cld    
ffffffff81016fbd:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
ffffffff81016fbf:	eb 0e                	jmp    ffffffff81016fcf <_ZN4Vmcb5cloneEv+0x9b>
        else
            asm volatile("cld; rep movsb\n"
                        ::"D" (d), "S" (s), "c" (n) : "cc", "memory");
ffffffff81016fc1:	b9 00 10 00 00       	mov    $0x1000,%ecx
ffffffff81016fc6:	48 89 d7             	mov    %rdx,%rdi
ffffffff81016fc9:	48 89 de             	mov    %rbx,%rsi
ffffffff81016fcc:	fc                   	cld    
ffffffff81016fcd:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
    Vmcb *vmcb = new (Pd::kern.quota) Vmcb;
    memcpy(vmcb, this, PAGE_SIZE);
    return vmcb;
}
ffffffff81016fcf:	48 89 d0             	mov    %rdx,%rax
ffffffff81016fd2:	5b                   	pop    %rbx
ffffffff81016fd3:	c3                   	retq   

ffffffff81016fd4 <_ZN4Vmcb4initEv>:

void Vmcb::init() {
    if (!Cpu::feature(Cpu::FEAT_SVM)) {
ffffffff81016fd4:	f6 05 79 87 fe 3e 04 	testb  $0x4,0x3efe8779(%rip)        # ffffffffbffff754 <_ZN3Cpu8featuresE+0x14>
ffffffff81016fdb:	75 09                	jne    ffffffff81016fe6 <_ZN4Vmcb4initEv+0x12>

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
ffffffff81016fdd:	f0 83 25 2b 00 15 00 	lock andl $0xfffffffb,0x15002b(%rip)        # ffffffff81167010 <PAGE_H+0x10>
ffffffff81016fe4:	fb 
ffffffff81016fe5:	c3                   	retq   
    Vmcb *vmcb = new (Pd::kern.quota) Vmcb;
    memcpy(vmcb, this, PAGE_SIZE);
    return vmcb;
}

void Vmcb::init() {
ffffffff81016fe6:	52                   	push   %rdx
    if (!Cpu::feature(Cpu::FEAT_SVM)) {
        Hip::clr_feature(Hip::FEAT_SVM);
        return;
    }

    if (Cmdline::vtlb)
ffffffff81016fe7:	80 3d ae ad 00 00 00 	cmpb   $0x0,0xadae(%rip)        # ffffffff81021d9c <_ZN7Cmdline4vtlbE>
ffffffff81016fee:	74 07                	je     ffffffff81016ff7 <_ZN4Vmcb4initEv+0x23>
        svm_feature &= ~1;
ffffffff81016ff0:	83 25 29 8d fe 3e fe 	andl   $0xfffffffe,0x3efe8d29(%rip)        # ffffffffbffffd20 <_ZN4Vmcb11svm_featureE>
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
ffffffff81016ff7:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
ffffffff81016ffc:	0f 32                	rdmsr  

        template <typename T>
        ALWAYS_INLINE
        static inline void write (Register msr, T val)
        {
            asm volatile ("wrmsr" : : "a" (static_cast<mword>(val)), "d" (static_cast<mword>(static_cast<uint64>(val) >> 32)), "c" (msr));
ffffffff81016ffe:	31 d2                	xor    %edx,%edx
ffffffff81017000:	0d 00 10 00 00       	or     $0x1000,%eax
ffffffff81017005:	0f 30                	wrmsr  
            CPU_CLGI |
            CPU_SKINIT;

    ALWAYS_INLINE
    static inline void *operator new (size_t, Quota &quota) {
        return Buddy::allocator.alloc(0, quota, Buddy::FILL_0);
ffffffff81017007:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff8101700c:	48 c7 c2 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rdx
ffffffff81017013:	31 f6                	xor    %esi,%esi
ffffffff81017015:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff8101701c:	e8 d1 a8 fe ff       	callq  ffffffff810018f2 <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
ffffffff81017021:	48 2d 00 00 c0 80    	sub    $0xffffffff80c00000,%rax
    Vmcb(Quota &quota, mword, mword);
    Vmcb* clone();

    ALWAYS_INLINE
    inline Vmcb() {
        asm volatile ("vmsave" : : "a" (Buddy::ptr_to_phys(this)) : "memory");
ffffffff81017027:	0f 01 db             	vmsave 
ffffffff8101702a:	48 89 c2             	mov    %rax,%rdx

    Msr::write(Msr::IA32_EFER, Msr::read<uint32>(Msr::IA32_EFER) | Cpu::EFER_SVME);
    Msr::write(Msr::AMD_SVM_HSAVE_PA, root = Buddy::ptr_to_phys(new (Pd::kern.quota) Vmcb));
ffffffff8101702d:	48 89 05 fc 8c fe 3e 	mov    %rax,0x3efe8cfc(%rip)        # ffffffffbffffd30 <_ZN4Vmcb4rootE>
ffffffff81017034:	b9 17 01 01 c0       	mov    $0xc0010117,%ecx
ffffffff81017039:	48 c1 ea 20          	shr    $0x20,%rdx
ffffffff8101703d:	0f 30                	wrmsr  

    trace(TRACE_SVM, "VMCB:%#010lx REV:%#x NPT:%d", root, svm_version, has_npt());
}
ffffffff8101703f:	58                   	pop    %rax
ffffffff81017040:	c3                   	retq   
ffffffff81017041:	90                   	nop

ffffffff81017042 <_ZN5Quota9hit_limitEm>:
            }
        }

        bool hit_limit(mword free_space = 0)
        {
             if (free_space > upli)
ffffffff81017042:	48 8b 57 18          	mov    0x18(%rdi),%rdx
                 return true;
ffffffff81017046:	b0 01                	mov    $0x1,%al
            }
        }

        bool hit_limit(mword free_space = 0)
        {
             if (free_space > upli)
ffffffff81017048:	48 39 d6             	cmp    %rdx,%rsi
ffffffff8101704b:	77 0a                	ja     ffffffff81017057 <_ZN5Quota9hit_limitEm+0x15>
                 return true;

             return usage() > upli - free_space;
ffffffff8101704d:	48 29 f2             	sub    %rsi,%rdx
ffffffff81017050:	48 39 57 08          	cmp    %rdx,0x8(%rdi)
ffffffff81017054:	0f 97 c0             	seta   %al
        }
ffffffff81017057:	c3                   	retq   

ffffffff81017058 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb0EEEvv>:
#include "syscall.hpp"
#include "utcb.hpp"
#include "vectors.hpp"

template <Sys_regs::Status S, bool T>
void Ec::sys_finish()
ffffffff81017058:	53                   	push   %rbx
ffffffff81017059:	48 83 ec 10          	sub    $0x10,%rsp
{
    if (T)
        current->clr_timeout();

    current->regs.set_status (S);
ffffffff8101705d:	48 8b 05 a4 7f fe 3e 	mov    0x3efe7fa4(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>

    if (current->xcpu_sm)
ffffffff81017064:	48 83 b8 30 03 00 00 	cmpq   $0x0,0x330(%rax)
ffffffff8101706b:	00 

        ALWAYS_INLINE
        inline void set_status (Status s, bool c = true)
        {
            if (c)
                ARG_1 = s;
ffffffff8101706c:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
ffffffff81017073:	00 00 00 00 
ffffffff81017077:	74 05                	je     ffffffff8101707e <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb0EEEvv+0x26>
        xcpu_return();
ffffffff81017079:	e8 f8 e2 fe ff       	callq  ffffffff81005376 <_ZN2Ec11xcpu_returnEv>

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
ffffffff8101707e:	48 8b 1d 8b 7f fe 3e 	mov    0x3efe7f8b(%rip),%rbx        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81017085:	31 f6                	xor    %esi,%esi
ffffffff81017087:	48 8d bb 08 03 00 00 	lea    0x308(%rbx),%rdi
ffffffff8101708e:	e8 af ff ff ff       	callq  ffffffff81017042 <_ZN5Quota9hit_limitEm>
ffffffff81017093:	84 c0                	test   %al,%al
ffffffff81017095:	75 05                	jne    ffffffff8101709c <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb0EEEvv+0x44>
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());

    ret_user_sysexit();
ffffffff81017097:	e8 64 8f fe ff       	callq  ffffffff81000000 <_ZN2Ec16ret_user_sysexitEv>

    if (current->xcpu_sm)
        xcpu_return();

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());
ffffffff8101709c:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff810170a1:	8b 35 5d 7f fe 3e    	mov    0x3efe7f5d(%rip),%esi        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff810170a7:	48 8b 8b 20 03 00 00 	mov    0x320(%rbx),%rcx
ffffffff810170ae:	48 8b 93 10 03 00 00 	mov    0x310(%rbx),%rdx
ffffffff810170b5:	48 c7 c7 7c 0c 02 81 	mov    $0xffffffff81020c7c,%rdi
ffffffff810170bc:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff810170c2:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff810170c8:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
ffffffff810170cf:	48 0f 45 f0          	cmovne %rax,%rsi
ffffffff810170d3:	31 c0                	xor    %eax,%eax
ffffffff810170d5:	e8 b2 af fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff810170da:	eb bb                	jmp    ffffffff81017097 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb0EEEvv+0x3f>

ffffffff810170dc <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb1EEEvv>:
#include "syscall.hpp"
#include "utcb.hpp"
#include "vectors.hpp"

template <Sys_regs::Status S, bool T>
void Ec::sys_finish()
ffffffff810170dc:	53                   	push   %rbx
ffffffff810170dd:	48 83 ec 10          	sub    $0x10,%rsp
{
    if (T)
        current->clr_timeout();
ffffffff810170e1:	48 8b 05 20 7f fe 3e 	mov    0x3efe7f20(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>

        ALWAYS_INLINE
        inline bool active() const { return prev || list == this; }
ffffffff810170e8:	48 83 b8 00 03 00 00 	cmpq   $0x0,0x300(%rax)
ffffffff810170ef:	00 
            timeout.enqueue(t, s);
    }

    ALWAYS_INLINE
    inline void clr_timeout() {
        if (EXPECT_FALSE(timeout.active()))
ffffffff810170f0:	48 8d b8 f8 02 00 00 	lea    0x2f8(%rax),%rdi
ffffffff810170f7:	75 48                	jne    ffffffff81017141 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb1EEEvv+0x65>
ffffffff810170f9:	48 39 3d 38 8c fe 3e 	cmp    %rdi,0x3efe8c38(%rip)        # ffffffffbffffd38 <_ZN7Timeout4listE>
ffffffff81017100:	74 3f                	je     ffffffff81017141 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb1EEEvv+0x65>

    current->regs.set_status (S);
ffffffff81017102:	48 8b 05 ff 7e fe 3e 	mov    0x3efe7eff(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>

    if (current->xcpu_sm)
ffffffff81017109:	48 83 b8 30 03 00 00 	cmpq   $0x0,0x330(%rax)
ffffffff81017110:	00 
ffffffff81017111:	48 c7 80 e8 00 00 00 	movq   $0x4,0xe8(%rax)
ffffffff81017118:	04 00 00 00 
ffffffff8101711c:	74 05                	je     ffffffff81017123 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb1EEEvv+0x47>
        xcpu_return();
ffffffff8101711e:	e8 53 e2 fe ff       	callq  ffffffff81005376 <_ZN2Ec11xcpu_returnEv>

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
ffffffff81017123:	48 8b 1d e6 7e fe 3e 	mov    0x3efe7ee6(%rip),%rbx        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8101712a:	31 f6                	xor    %esi,%esi
ffffffff8101712c:	48 8d bb 08 03 00 00 	lea    0x308(%rbx),%rdi
ffffffff81017133:	e8 0a ff ff ff       	callq  ffffffff81017042 <_ZN5Quota9hit_limitEm>
ffffffff81017138:	84 c0                	test   %al,%al
ffffffff8101713a:	75 0c                	jne    ffffffff81017148 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb1EEEvv+0x6c>
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());

    ret_user_sysexit();
ffffffff8101713c:	e8 bf 8e fe ff       	callq  ffffffff81000000 <_ZN2Ec16ret_user_sysexitEv>
            timeout.dequeue();
ffffffff81017141:	e8 ba 38 00 00       	callq  ffffffff8101aa00 <_ZN7Timeout7dequeueEv>
ffffffff81017146:	eb ba                	jmp    ffffffff81017102 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb1EEEvv+0x26>

    if (current->xcpu_sm)
        xcpu_return();

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());
ffffffff81017148:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff8101714d:	8b 35 b1 7e fe 3e    	mov    0x3efe7eb1(%rip),%esi        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81017153:	48 8b 8b 20 03 00 00 	mov    0x320(%rbx),%rcx
ffffffff8101715a:	48 8b 93 10 03 00 00 	mov    0x310(%rbx),%rdx
ffffffff81017161:	48 c7 c7 7c 0c 02 81 	mov    $0xffffffff81020c7c,%rdi
ffffffff81017168:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8101716e:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff81017174:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
ffffffff8101717b:	48 0f 45 f0          	cmovne %rax,%rsi
ffffffff8101717f:	31 c0                	xor    %eax,%eax
ffffffff81017181:	e8 06 af fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff81017186:	eb b4                	jmp    ffffffff8101713c <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb1EEEvv+0x60>

ffffffff81017188 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb1EEEvv>:
#include "syscall.hpp"
#include "utcb.hpp"
#include "vectors.hpp"

template <Sys_regs::Status S, bool T>
void Ec::sys_finish()
ffffffff81017188:	53                   	push   %rbx
ffffffff81017189:	48 83 ec 10          	sub    $0x10,%rsp
{
    if (T)
        current->clr_timeout();
ffffffff8101718d:	48 8b 05 74 7e fe 3e 	mov    0x3efe7e74(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81017194:	48 83 b8 00 03 00 00 	cmpq   $0x0,0x300(%rax)
ffffffff8101719b:	00 
            timeout.enqueue(t, s);
    }

    ALWAYS_INLINE
    inline void clr_timeout() {
        if (EXPECT_FALSE(timeout.active()))
ffffffff8101719c:	48 8d b8 f8 02 00 00 	lea    0x2f8(%rax),%rdi
ffffffff810171a3:	75 48                	jne    ffffffff810171ed <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb1EEEvv+0x65>
ffffffff810171a5:	48 39 3d 8c 8b fe 3e 	cmp    %rdi,0x3efe8b8c(%rip)        # ffffffffbffffd38 <_ZN7Timeout4listE>
ffffffff810171ac:	74 3f                	je     ffffffff810171ed <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb1EEEvv+0x65>

    current->regs.set_status (S);
ffffffff810171ae:	48 8b 05 53 7e fe 3e 	mov    0x3efe7e53(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>

    if (current->xcpu_sm)
ffffffff810171b5:	48 83 b8 30 03 00 00 	cmpq   $0x0,0x330(%rax)
ffffffff810171bc:	00 
ffffffff810171bd:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
ffffffff810171c4:	00 00 00 00 
ffffffff810171c8:	74 05                	je     ffffffff810171cf <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb1EEEvv+0x47>
        xcpu_return();
ffffffff810171ca:	e8 a7 e1 fe ff       	callq  ffffffff81005376 <_ZN2Ec11xcpu_returnEv>

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
ffffffff810171cf:	48 8b 1d 3a 7e fe 3e 	mov    0x3efe7e3a(%rip),%rbx        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff810171d6:	31 f6                	xor    %esi,%esi
ffffffff810171d8:	48 8d bb 08 03 00 00 	lea    0x308(%rbx),%rdi
ffffffff810171df:	e8 5e fe ff ff       	callq  ffffffff81017042 <_ZN5Quota9hit_limitEm>
ffffffff810171e4:	84 c0                	test   %al,%al
ffffffff810171e6:	75 0c                	jne    ffffffff810171f4 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb1EEEvv+0x6c>
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());

    ret_user_sysexit();
ffffffff810171e8:	e8 13 8e fe ff       	callq  ffffffff81000000 <_ZN2Ec16ret_user_sysexitEv>
            timeout.dequeue();
ffffffff810171ed:	e8 0e 38 00 00       	callq  ffffffff8101aa00 <_ZN7Timeout7dequeueEv>
ffffffff810171f2:	eb ba                	jmp    ffffffff810171ae <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb1EEEvv+0x26>

    if (current->xcpu_sm)
        xcpu_return();

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());
ffffffff810171f4:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff810171f9:	8b 35 05 7e fe 3e    	mov    0x3efe7e05(%rip),%esi        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff810171ff:	48 8b 8b 20 03 00 00 	mov    0x320(%rbx),%rcx
ffffffff81017206:	48 8b 93 10 03 00 00 	mov    0x310(%rbx),%rdx
ffffffff8101720d:	48 c7 c7 7c 0c 02 81 	mov    $0xffffffff81020c7c,%rdi
ffffffff81017214:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8101721a:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff81017220:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
ffffffff81017227:	48 0f 45 f0          	cmovne %rax,%rsi
ffffffff8101722b:	31 c0                	xor    %eax,%eax
ffffffff8101722d:	e8 5a ae fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff81017232:	eb b4                	jmp    ffffffff810171e8 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb1EEEvv+0x60>

ffffffff81017234 <_ZN2Ec14ret_xcpu_replyEv>:
    ret_xcpu_reply();
}

void Ec::ret_xcpu_reply()
{
    assert (current->xcpu_sm);
ffffffff81017234:	48 8b 05 cd 7d fe 3e 	mov    0x3efe7dcd(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>

    ret_xcpu_reply();
}

void Ec::ret_xcpu_reply()
{
ffffffff8101723b:	41 54                	push   %r12
ffffffff8101723d:	55                   	push   %rbp
ffffffff8101723e:	53                   	push   %rbx
    assert (current->xcpu_sm);
ffffffff8101723f:	48 8b 98 30 03 00 00 	mov    0x330(%rax),%rbx
ffffffff81017246:	48 85 db             	test   %rbx,%rbx
ffffffff81017249:	75 1f                	jne    ffffffff8101726a <_ZN2Ec14ret_xcpu_replyEv+0x36>
ffffffff8101724b:	49 c7 c0 e0 10 02 81 	mov    $0xffffffff810210e0,%r8
ffffffff81017252:	b9 a7 03 00 00       	mov    $0x3a7,%ecx
ffffffff81017257:	48 c7 c2 ab 0c 02 81 	mov    $0xffffffff81020cab,%rdx
ffffffff8101725e:	48 c7 c6 cc de 01 81 	mov    $0xffffffff8101decc,%rsi
ffffffff81017265:	e9 63 01 00 00       	jmpq   ffffffff810173cd <_ZN2Ec14ret_xcpu_replyEv+0x199>

    Sm::destroy(current->xcpu_sm, Pd::current->quota);
ffffffff8101726a:	48 8b 05 9f 7d fe 3e 	mov    0x3efe7d9f(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }

        ALWAYS_INLINE
        static inline void destroy(Sm *obj, Quota &quota) { obj->~Sm(); cache.free (obj, quota); }
ffffffff81017271:	48 89 df             	mov    %rbx,%rdi
ffffffff81017274:	48 8d a8 08 03 00 00 	lea    0x308(%rax),%rbp
ffffffff8101727b:	e8 40 46 ff ff       	callq  ffffffff8100b8c0 <_ZN2SmD1Ev>
ffffffff81017280:	48 89 de             	mov    %rbx,%rsi
ffffffff81017283:	48 89 ea             	mov    %rbp,%rdx
ffffffff81017286:	48 c7 c7 80 40 16 81 	mov    $0xffffffff81164080,%rdi
ffffffff8101728d:	e8 d8 e7 ff ff       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
    current->xcpu_sm = nullptr;
ffffffff81017292:	48 8b 1d 6f 7d fe 3e 	mov    0x3efe7d6f(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81017299:	48 8b 83 e8 00 00 00 	mov    0xe8(%rbx),%rax
ffffffff810172a0:	48 c7 83 30 03 00 00 	movq   $0x0,0x330(%rbx)
ffffffff810172a7:	00 00 00 00 

    if (current->regs.status() != Sys_regs::SUCCESS) {
ffffffff810172ab:	84 c0                	test   %al,%al
ffffffff810172ad:	74 16                	je     ffffffff810172c5 <_ZN2Ec14ret_xcpu_replyEv+0x91>
            else
                ARG_1 = (ARG_1 & ~0xfful) | s;
ffffffff810172af:	30 c0                	xor    %al,%al
        current->cont = sys_call;
ffffffff810172b1:	48 c7 83 a0 00 00 00 	movq   $0xffffffff810008ae,0xa0(%rbx)
ffffffff810172b8:	ae 08 00 81 
ffffffff810172bc:	48 89 83 e8 00 00 00 	mov    %rax,0xe8(%rbx)
ffffffff810172c3:	eb 0b                	jmp    ffffffff810172d0 <_ZN2Ec14ret_xcpu_replyEv+0x9c>
        current->regs.set_status (Sys_regs::SUCCESS, false);
    } else
        current->cont = ret_user_sysexit;
ffffffff810172c5:	48 c7 83 a0 00 00 00 	movq   $0xffffffff81000000,0xa0(%rbx)
ffffffff810172cc:	00 00 00 81 
        }

        ALWAYS_INLINE
        inline bool del_ref()
        {
            return Atomic::sub (ref, 1U) == 0;
ffffffff810172d0:	48 8d ab 8c 00 00 00 	lea    0x8c(%rbx),%rbp
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff810172d7:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff810172da:	f0 0f c1 45 00       	lock xadd %eax,0x0(%rbp)
        regs.ARG_3 = cnt;
    }

    ALWAYS_INLINE NORETURN
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
ffffffff810172df:	ff c8                	dec    %eax
ffffffff810172e1:	75 32                	jne    ffffffff81017315 <_ZN2Ec14ret_xcpu_replyEv+0xe1>
            delete current;
ffffffff810172e3:	4c 8b 25 1e 7d fe 3e 	mov    0x3efe7d1e(%rip),%r12        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff810172ea:	4d 85 e4             	test   %r12,%r12
ffffffff810172ed:	74 26                	je     ffffffff81017315 <_ZN2Ec14ret_xcpu_replyEv+0xe1>
ffffffff810172ef:	4c 89 e7             	mov    %r12,%rdi
ffffffff810172f2:	e8 45 d1 fe ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff810172f7:	49 8b 84 24 98 02 00 	mov    0x298(%r12),%rax
ffffffff810172fe:	00 
ffffffff810172ff:	4c 89 e6             	mov    %r12,%rsi
ffffffff81017302:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff81017309:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff81017310:	e8 55 e7 ff ff       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
            delete current;
        }

        current = this;
ffffffff81017315:	48 89 1d ec 7c fe 3e 	mov    %rbx,0x3efe7cec(%rip)        # ffffffffbffff008 <_ZN2Ec7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8101731c:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff81017322:	85 c0                	test   %eax,%eax
ffffffff81017324:	74 0a                	je     ffffffff81017330 <_ZN2Ec14ret_xcpu_replyEv+0xfc>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff81017326:	8d 50 01             	lea    0x1(%rax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff81017329:	f0 0f b1 55 00       	lock cmpxchg %edx,0x0(%rbp)
ffffffff8101732e:	75 ec                	jne    ffffffff8101731c <_ZN2Ec14ret_xcpu_replyEv+0xe8>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
ffffffff81017330:	48 8b 93 98 02 00 00 	mov    0x298(%rbx),%rdx

        current->add_ref();

        Tss::run.sp0 = reinterpret_cast<mword> (exc_regs() + 1);
ffffffff81017337:	48 8d 83 80 01 00 00 	lea    0x180(%rbx),%rax
ffffffff8101733e:	8b 0d c0 7c fe 3e    	mov    0x3efe7cc0(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81017344:	48 89 05 81 8a fe 3e 	mov    %rax,0x3efe8a81(%rip)        # ffffffffbffffdcc <tss_run+0x4>
ffffffff8101734b:	48 8b 82 c8 02 00 00 	mov    0x2c8(%rdx),%rax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
ffffffff81017352:	48 8b b2 b8 02 00 00 	mov    0x2b8(%rdx),%rsi

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
ffffffff81017359:	48 0f a3 c8          	bt     %rcx,%rax
ffffffff8101735d:	73 14                	jae    ffffffff81017373 <_ZN2Ec14ret_xcpu_replyEv+0x13f>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
ffffffff8101735f:	48 c7 c0 fe ff ff ff 	mov    $0xfffffffffffffffe,%rax
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
ffffffff81017366:	48 d3 c0             	rol    %cl,%rax
ffffffff81017369:	f0 48 21 82 c8 02 00 	lock and %rax,0x2c8(%rdx)
ffffffff81017370:	00 
ffffffff81017371:	eb 20                	jmp    ffffffff81017393 <_ZN2Ec14ret_xcpu_replyEv+0x15f>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
ffffffff81017373:	48 39 15 96 7c fe 3e 	cmp    %rdx,0x3efe7c96(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8101737a:	0f 84 e5 00 00 00    	je     ffffffff81017465 <_ZN2Ec14ret_xcpu_replyEv+0x231>
                    return;

                if (pcid != NO_PCID)
ffffffff81017380:	48 83 fe 02          	cmp    $0x2,%rsi
ffffffff81017384:	74 0d                	je     ffffffff81017393 <_ZN2Ec14ret_xcpu_replyEv+0x15f>
                    pcid |= static_cast<mword>(1ULL << 63);
ffffffff81017386:	48 b8 00 00 00 00 00 	movabs $0x8000000000000000,%rax
ffffffff8101738d:	00 00 80 
ffffffff81017390:	48 09 c6             	or     %rax,%rsi
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff81017393:	48 8b 05 76 7c fe 3e 	mov    0x3efe7c76(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8101739a:	83 c9 ff             	or     $0xffffffff,%ecx
ffffffff8101739d:	f0 0f c1 88 8c 00 00 	lock xadd %ecx,0x8c(%rax)
ffffffff810173a4:	00 
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
ffffffff810173a5:	83 f9 01             	cmp    $0x1,%ecx
ffffffff810173a8:	75 31                	jne    ffffffff810173db <_ZN2Ec14ret_xcpu_replyEv+0x1a7>
                assert (current != this);
ffffffff810173aa:	48 8b 2d 5f 7c fe 3e 	mov    0x3efe7c5f(%rip),%rbp        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff810173b1:	48 39 d5             	cmp    %rdx,%rbp
ffffffff810173b4:	75 27                	jne    ffffffff810173dd <_ZN2Ec14ret_xcpu_replyEv+0x1a9>
ffffffff810173b6:	49 c7 c0 a0 12 02 81 	mov    $0xffffffff810212a0,%r8
ffffffff810173bd:	b1 5e                	mov    $0x5e,%cl
ffffffff810173bf:	48 c7 c2 c7 e6 01 81 	mov    $0xffffffff8101e6c7,%rdx
ffffffff810173c6:	48 c7 c6 35 e7 01 81 	mov    $0xffffffff8101e735,%rsi
ffffffff810173cd:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff810173d4:	31 c0                	xor    %eax,%eax
ffffffff810173d6:	e8 75 ab fe ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
ffffffff810173db:	31 ed                	xor    %ebp,%ebp
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
ffffffff810173dd:	48 89 15 2c 7c fe 3e 	mov    %rdx,0x3efe7c2c(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff810173e4:	8b 82 8c 00 00 00    	mov    0x8c(%rdx),%eax
ffffffff810173ea:	85 c0                	test   %eax,%eax
ffffffff810173ec:	74 0d                	je     ffffffff810173fb <_ZN2Ec14ret_xcpu_replyEv+0x1c7>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff810173ee:	8d 48 01             	lea    0x1(%rax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff810173f1:	f0 0f b1 8a 8c 00 00 	lock cmpxchg %ecx,0x8c(%rdx)
ffffffff810173f8:	00 
ffffffff810173f9:	75 e9                	jne    ffffffff810173e4 <_ZN2Ec14ret_xcpu_replyEv+0x1b0>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
ffffffff810173fb:	f6 05 44 83 fe 3e 02 	testb  $0x2,0x3efe8344(%rip)        # ffffffffbffff746 <_ZN3Cpu8featuresE+0x6>
        return addr;
    }

    ALWAYS_INLINE
    inline void make_current(mword pcid) {
        asm volatile ("mov %0, %%cr3" : : "r" (val | pcid) : "memory");
ffffffff81017402:	8b 0d fc 7b fe 3e    	mov    0x3efe7bfc(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81017408:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff8101740d:	48 0f 45 c6          	cmovne %rsi,%rax
ffffffff81017411:	48 0b 84 ca a0 00 00 	or     0xa0(%rdx,%rcx,8),%rax
ffffffff81017418:	00 
ffffffff81017419:	0f 22 d8             	mov    %rax,%cr3

            if (del_pd)
ffffffff8101741c:	48 85 ed             	test   %rbp,%rbp
ffffffff8101741f:	74 44                	je     ffffffff81017465 <_ZN2Ec14ret_xcpu_replyEv+0x231>
                delete del_pd;
ffffffff81017421:	48 89 ef             	mov    %rbp,%rdi
ffffffff81017424:	e8 ff 9b ff ff       	callq  ffffffff81011028 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff81017429:	48 8b 45 50          	mov    0x50(%rbp),%rax
ffffffff8101742d:	31 d2                	xor    %edx,%edx

            pd_del->quota.free_up(pd_to->quota);
ffffffff8101742f:	48 8d bd 08 03 00 00 	lea    0x308(%rbp),%rdi

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff81017436:	48 8d 88 08 fd ff ff 	lea    -0x2f8(%rax),%rcx
ffffffff8101743d:	48 85 c0             	test   %rax,%rax
ffffffff81017440:	48 0f 45 d1          	cmovne %rcx,%rdx

            pd_del->quota.free_up(pd_to->quota);
ffffffff81017444:	4c 8d a2 08 03 00 00 	lea    0x308(%rdx),%r12
ffffffff8101744b:	4c 89 e6             	mov    %r12,%rsi
ffffffff8101744e:	e8 71 c1 fe ff       	callq  ffffffff810035c4 <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
ffffffff81017453:	4c 89 e2             	mov    %r12,%rdx
ffffffff81017456:	48 89 ee             	mov    %rbp,%rsi
ffffffff81017459:	48 c7 c7 d0 3f 16 81 	mov    $0xffffffff81163fd0,%rdi
ffffffff81017460:	e8 05 e6 ff ff       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>

        pd->make_current();

        asm volatile ("mov %0," EXPAND(PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory");
ffffffff81017465:	48 8b 83 a0 00 00 00 	mov    0xa0(%rbx),%rax
ffffffff8101746c:	48 c7 c4 00 e0 ff bf 	mov    $0xffffffffbfffe000,%rsp
ffffffff81017473:	ff e0                	jmpq   *%rax
ffffffff81017475:	90                   	nop

ffffffff81017476 <_ZN2Ec8activateEv>:

    ret_user_sysexit();
}

void Ec::activate()
{
ffffffff81017476:	41 54                	push   %r12
    Ec *ec = this;

    // XXX: Make the loop preemptible
    for (Sc::ctr_link = 0; ec->partner; ec = ec->partner)
ffffffff81017478:	31 c0                	xor    %eax,%eax

    ret_user_sysexit();
}

void Ec::activate()
{
ffffffff8101747a:	55                   	push   %rbp
ffffffff8101747b:	53                   	push   %rbx
ffffffff8101747c:	48 89 fb             	mov    %rdi,%rbx
    Ec *ec = this;

    // XXX: Make the loop preemptible
    for (Sc::ctr_link = 0; ec->partner; ec = ec->partner)
ffffffff8101747f:	48 8b 93 a0 02 00 00 	mov    0x2a0(%rbx),%rdx
ffffffff81017486:	8d 48 01             	lea    0x1(%rax),%ecx
ffffffff81017489:	48 85 d2             	test   %rdx,%rdx
ffffffff8101748c:	74 07                	je     ffffffff81017495 <_ZN2Ec8activateEv+0x1f>
ffffffff8101748e:	89 c8                	mov    %ecx,%eax
ffffffff81017490:	48 89 d3             	mov    %rdx,%rbx
ffffffff81017493:	eb ea                	jmp    ffffffff8101747f <_ZN2Ec8activateEv+0x9>
        regs.add_tsc_offset(tsc);
    }

    ALWAYS_INLINE
    inline bool blocked() const {
        return next || !cont;
ffffffff81017495:	48 83 bb b0 02 00 00 	cmpq   $0x0,0x2b0(%rbx)
ffffffff8101749c:	00 
ffffffff8101749d:	89 05 61 88 fe 3e    	mov    %eax,0x3efe8861(%rip)        # ffffffffbffffd04 <_ZN2Sc8ctr_linkE>
ffffffff810174a3:	0f 85 b8 01 00 00    	jne    ffffffff81017661 <_ZN2Ec8activateEv+0x1eb>
ffffffff810174a9:	48 83 bb a0 00 00 00 	cmpq   $0x0,0xa0(%rbx)
ffffffff810174b0:	00 
ffffffff810174b1:	0f 84 aa 01 00 00    	je     ffffffff81017661 <_ZN2Ec8activateEv+0x1eb>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff810174b7:	48 8b 05 4a 7b fe 3e 	mov    0x3efe7b4a(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff810174be:	83 ca ff             	or     $0xffffffff,%edx
ffffffff810174c1:	f0 0f c1 90 8c 00 00 	lock xadd %edx,0x8c(%rax)
ffffffff810174c8:	00 
        regs.ARG_3 = cnt;
    }

    ALWAYS_INLINE NORETURN
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
ffffffff810174c9:	ff ca                	dec    %edx
ffffffff810174cb:	75 31                	jne    ffffffff810174fe <_ZN2Ec8activateEv+0x88>
            delete current;
ffffffff810174cd:	48 8b 2d 34 7b fe 3e 	mov    0x3efe7b34(%rip),%rbp        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff810174d4:	48 85 ed             	test   %rbp,%rbp
ffffffff810174d7:	74 25                	je     ffffffff810174fe <_ZN2Ec8activateEv+0x88>
ffffffff810174d9:	48 89 ef             	mov    %rbp,%rdi
ffffffff810174dc:	e8 5b cf fe ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff810174e1:	48 8b 85 98 02 00 00 	mov    0x298(%rbp),%rax
ffffffff810174e8:	48 89 ee             	mov    %rbp,%rsi
ffffffff810174eb:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff810174f2:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff810174f9:	e8 6c e5 ff ff       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
            delete current;
        }

        current = this;
ffffffff810174fe:	48 89 1d 03 7b fe 3e 	mov    %rbx,0x3efe7b03(%rip)        # ffffffffbffff008 <_ZN2Ec7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff81017505:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff8101750b:	85 c0                	test   %eax,%eax
ffffffff8101750d:	74 0d                	je     ffffffff8101751c <_ZN2Ec8activateEv+0xa6>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff8101750f:	8d 50 01             	lea    0x1(%rax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff81017512:	f0 0f b1 93 8c 00 00 	lock cmpxchg %edx,0x8c(%rbx)
ffffffff81017519:	00 
ffffffff8101751a:	75 e9                	jne    ffffffff81017505 <_ZN2Ec8activateEv+0x8f>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
ffffffff8101751c:	48 8b 93 98 02 00 00 	mov    0x298(%rbx),%rdx

        current->add_ref();

        Tss::run.sp0 = reinterpret_cast<mword> (exc_regs() + 1);
ffffffff81017523:	48 8d 83 80 01 00 00 	lea    0x180(%rbx),%rax
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
ffffffff8101752a:	8b 0d d4 7a fe 3e    	mov    0x3efe7ad4(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81017530:	48 89 05 95 88 fe 3e 	mov    %rax,0x3efe8895(%rip)        # ffffffffbffffdcc <tss_run+0x4>
ffffffff81017537:	48 8b 82 c8 02 00 00 	mov    0x2c8(%rdx),%rax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
ffffffff8101753e:	48 8b b2 b8 02 00 00 	mov    0x2b8(%rdx),%rsi

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
ffffffff81017545:	48 0f a3 c8          	bt     %rcx,%rax
ffffffff81017549:	73 14                	jae    ffffffff8101755f <_ZN2Ec8activateEv+0xe9>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
ffffffff8101754b:	48 c7 c0 fe ff ff ff 	mov    $0xfffffffffffffffe,%rax
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
ffffffff81017552:	48 d3 c0             	rol    %cl,%rax
ffffffff81017555:	f0 48 21 82 c8 02 00 	lock and %rax,0x2c8(%rdx)
ffffffff8101755c:	00 
ffffffff8101755d:	eb 20                	jmp    ffffffff8101757f <_ZN2Ec8activateEv+0x109>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
ffffffff8101755f:	48 39 15 aa 7a fe 3e 	cmp    %rdx,0x3efe7aaa(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81017566:	0f 84 e5 00 00 00    	je     ffffffff81017651 <_ZN2Ec8activateEv+0x1db>
                    return;

                if (pcid != NO_PCID)
ffffffff8101756c:	48 83 fe 02          	cmp    $0x2,%rsi
ffffffff81017570:	74 0d                	je     ffffffff8101757f <_ZN2Ec8activateEv+0x109>
                    pcid |= static_cast<mword>(1ULL << 63);
ffffffff81017572:	48 b8 00 00 00 00 00 	movabs $0x8000000000000000,%rax
ffffffff81017579:	00 00 80 
ffffffff8101757c:	48 09 c6             	or     %rax,%rsi
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff8101757f:	48 8b 05 8a 7a fe 3e 	mov    0x3efe7a8a(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81017586:	83 c9 ff             	or     $0xffffffff,%ecx
ffffffff81017589:	f0 0f c1 88 8c 00 00 	lock xadd %ecx,0x8c(%rax)
ffffffff81017590:	00 
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
ffffffff81017591:	83 f9 01             	cmp    $0x1,%ecx
ffffffff81017594:	75 31                	jne    ffffffff810175c7 <_ZN2Ec8activateEv+0x151>
                assert (current != this);
ffffffff81017596:	48 8b 2d 73 7a fe 3e 	mov    0x3efe7a73(%rip),%rbp        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8101759d:	48 39 d5             	cmp    %rdx,%rbp
ffffffff810175a0:	75 27                	jne    ffffffff810175c9 <_ZN2Ec8activateEv+0x153>
ffffffff810175a2:	49 c7 c0 a0 12 02 81 	mov    $0xffffffff810212a0,%r8
ffffffff810175a9:	b1 5e                	mov    $0x5e,%cl
ffffffff810175ab:	48 c7 c2 c7 e6 01 81 	mov    $0xffffffff8101e6c7,%rdx
ffffffff810175b2:	48 c7 c6 35 e7 01 81 	mov    $0xffffffff8101e735,%rsi
ffffffff810175b9:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff810175c0:	31 c0                	xor    %eax,%eax
ffffffff810175c2:	e8 89 a9 fe ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
ffffffff810175c7:	31 ed                	xor    %ebp,%ebp
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
ffffffff810175c9:	48 89 15 40 7a fe 3e 	mov    %rdx,0x3efe7a40(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff810175d0:	8b 82 8c 00 00 00    	mov    0x8c(%rdx),%eax
ffffffff810175d6:	85 c0                	test   %eax,%eax
ffffffff810175d8:	74 0d                	je     ffffffff810175e7 <_ZN2Ec8activateEv+0x171>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff810175da:	8d 48 01             	lea    0x1(%rax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff810175dd:	f0 0f b1 8a 8c 00 00 	lock cmpxchg %ecx,0x8c(%rdx)
ffffffff810175e4:	00 
ffffffff810175e5:	75 e9                	jne    ffffffff810175d0 <_ZN2Ec8activateEv+0x15a>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
ffffffff810175e7:	f6 05 58 81 fe 3e 02 	testb  $0x2,0x3efe8158(%rip)        # ffffffffbffff746 <_ZN3Cpu8featuresE+0x6>
ffffffff810175ee:	8b 0d 10 7a fe 3e    	mov    0x3efe7a10(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff810175f4:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff810175f9:	48 0f 45 c6          	cmovne %rsi,%rax
ffffffff810175fd:	48 0b 84 ca a0 00 00 	or     0xa0(%rdx,%rcx,8),%rax
ffffffff81017604:	00 
ffffffff81017605:	0f 22 d8             	mov    %rax,%cr3

            if (del_pd)
ffffffff81017608:	48 85 ed             	test   %rbp,%rbp
ffffffff8101760b:	74 44                	je     ffffffff81017651 <_ZN2Ec8activateEv+0x1db>
                delete del_pd;
ffffffff8101760d:	48 89 ef             	mov    %rbp,%rdi
ffffffff81017610:	e8 13 9a ff ff       	callq  ffffffff81011028 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff81017615:	48 8b 45 50          	mov    0x50(%rbp),%rax
ffffffff81017619:	31 d2                	xor    %edx,%edx

            pd_del->quota.free_up(pd_to->quota);
ffffffff8101761b:	48 8d bd 08 03 00 00 	lea    0x308(%rbp),%rdi

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff81017622:	48 8d 88 08 fd ff ff 	lea    -0x2f8(%rax),%rcx
ffffffff81017629:	48 85 c0             	test   %rax,%rax
ffffffff8101762c:	48 0f 45 d1          	cmovne %rcx,%rdx

            pd_del->quota.free_up(pd_to->quota);
ffffffff81017630:	4c 8d a2 08 03 00 00 	lea    0x308(%rdx),%r12
ffffffff81017637:	4c 89 e6             	mov    %r12,%rsi
ffffffff8101763a:	e8 85 bf fe ff       	callq  ffffffff810035c4 <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
ffffffff8101763f:	4c 89 e2             	mov    %r12,%rdx
ffffffff81017642:	48 89 ee             	mov    %rbp,%rsi
ffffffff81017645:	48 c7 c7 d0 3f 16 81 	mov    $0xffffffff81163fd0,%rdi
ffffffff8101764c:	e8 19 e4 ff ff       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>

        pd->make_current();

        asm volatile ("mov %0," EXPAND(PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory");
ffffffff81017651:	48 8b 83 a0 00 00 00 	mov    0xa0(%rbx),%rax
ffffffff81017658:	48 c7 c4 00 e0 ff bf 	mov    $0xffffffffbfffe000,%rsp
ffffffff8101765f:	ff e0                	jmpq   *%rax
        Sc::ctr_link++;

    if (EXPECT_FALSE (ec->blocked()))
        ec->block_sc();
ffffffff81017661:	48 89 df             	mov    %rbx,%rdi
ffffffff81017664:	e8 05 41 ff ff       	callq  ffffffff8100b76e <_ZN2Ec8block_scEv>
ffffffff81017669:	e9 49 fe ff ff       	jmpq   ffffffff810174b7 <_ZN2Ec8activateEv+0x41>

ffffffff8101766e <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv>:
}

template <void (*C)()>
void Ec::send_msg()
{
    Exc_regs *r = &current->regs;
ffffffff8101766e:	48 8b 35 93 79 fe 3e 	mov    0x3efe7993(%rip),%rsi        # ffffffffbffff008 <_ZN2Ec7currentE>
        current->oom_delegate(dst, ec, src, user, C);
    }
}

template <void (*C)()>
void Ec::send_msg()
ffffffff81017675:	41 54                	push   %r12
ffffffff81017677:	55                   	push   %rbp
ffffffff81017678:	53                   	push   %rbx
{
    Exc_regs *r = &current->regs;

    Kobject *obj = Space_obj::lookup (current->evt + r->dst_portal).obj();
ffffffff81017679:	8b 86 f4 02 00 00    	mov    0x2f4(%rsi),%eax
ffffffff8101767f:	48 03 86 50 01 00 00 	add    0x150(%rsi),%rax
ffffffff81017686:	25 ff ff ff 03       	and    $0x3ffffff,%eax

        ALWAYS_INLINE
        inline Kobject *obj() const { return reinterpret_cast<Kobject *>(val & ~perm); }
ffffffff8101768b:	48 8b 14 c5 00 00 00 	mov    -0x20000000(,%rax,8),%rdx
ffffffff81017692:	e0 

    public:
        ALWAYS_INLINE
        inline Type type() const
        {
            return EXPECT_TRUE (this) ? Type (objtype) : INVALID;
ffffffff81017693:	48 83 e2 e0          	and    $0xffffffffffffffe0,%rdx
ffffffff81017697:	74 09                	je     ffffffff810176a2 <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x34>
    if (EXPECT_FALSE (obj->type() != Kobject::PT))
ffffffff81017699:	80 ba 88 00 00 00 03 	cmpb   $0x3,0x88(%rdx)
ffffffff810176a0:	74 10                	je     ffffffff810176b2 <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x44>
        die ("PT not found");
ffffffff810176a2:	48 81 c6 a8 00 00 00 	add    $0xa8,%rsi
ffffffff810176a9:	48 c7 c7 51 dc 01 81 	mov    $0xffffffff8101dc51,%rdi
ffffffff810176b0:	eb 24                	jmp    ffffffff810176d6 <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x68>
{
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
ffffffff810176b2:	48 8b 9a 90 00 00 00 	mov    0x90(%rdx),%rbx

    Pt *pt = static_cast<Pt *>(obj);
    Ec *ec = pt->ec;

    if (EXPECT_FALSE (current->cpu != ec->xcpu))
ffffffff810176b9:	0f b7 86 f0 02 00 00 	movzwl 0x2f0(%rsi),%eax
ffffffff810176c0:	3b 83 f0 02 00 00    	cmp    0x2f0(%rbx),%eax
ffffffff810176c6:	74 13                	je     ffffffff810176db <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x6d>
        die ("PT wrong CPU");
ffffffff810176c8:	48 81 c6 a8 00 00 00 	add    $0xa8,%rsi
ffffffff810176cf:	48 c7 c7 1a 0d 02 81 	mov    $0xffffffff81020d1a,%rdi
ffffffff810176d6:	e8 2f d5 fe ff       	callq  ffffffff81004c0a <_ZN2Ec3dieEPKcP8Exc_regs>

    if (EXPECT_TRUE (!ec->cont)) {
ffffffff810176db:	48 83 bb a0 00 00 00 	cmpq   $0x0,0xa0(%rbx)
ffffffff810176e2:	00 
ffffffff810176e3:	0f 85 46 02 00 00    	jne    ffffffff8101792f <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x2c1>
        current->cont = C;
ffffffff810176e9:	48 c7 86 a0 00 00 00 	movq   $0xffffffff81005152,0xa0(%rsi)
ffffffff810176f0:	52 51 00 81 
        return &regs;
    }

    ALWAYS_INLINE
    inline void set_partner(Ec *p) {
        partner = p;
ffffffff810176f4:	48 89 9e a0 02 00 00 	mov    %rbx,0x2a0(%rsi)
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff810176fb:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff81017701:	85 c0                	test   %eax,%eax
ffffffff81017703:	74 0d                	je     ffffffff81017712 <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0xa4>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff81017705:	8d 48 01             	lea    0x1(%rax),%ecx
ffffffff81017708:	f0 0f b1 8b 8c 00 00 	lock cmpxchg %ecx,0x8c(%rbx)
ffffffff8101770f:	00 
ffffffff81017710:	75 e9                	jne    ffffffff810176fb <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x8d>
        partner->add_ref();
        partner->rcap = this;
ffffffff81017712:	48 8b 86 a0 02 00 00 	mov    0x2a0(%rsi),%rax
ffffffff81017719:	48 89 b0 88 02 00 00 	mov    %rsi,0x288(%rax)
        partner->rcap->add_ref();
ffffffff81017720:	48 8b 86 a0 02 00 00 	mov    0x2a0(%rsi),%rax
ffffffff81017727:	48 8b 88 88 02 00 00 	mov    0x288(%rax),%rcx
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8101772e:	8b 81 8c 00 00 00    	mov    0x8c(%rcx),%eax
ffffffff81017734:	85 c0                	test   %eax,%eax
ffffffff81017736:	74 0d                	je     ffffffff81017745 <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0xd7>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff81017738:	8d 70 01             	lea    0x1(%rax),%esi
ffffffff8101773b:	f0 0f b1 b1 8c 00 00 	lock cmpxchg %esi,0x8c(%rcx)
ffffffff81017742:	00 
ffffffff81017743:	75 e9                	jne    ffffffff8101772e <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0xc0>
        current->set_partner (ec);
        current->regs.mtd = pt->mtd.val;
ffffffff81017745:	48 8b 8a 98 00 00 00 	mov    0x98(%rdx),%rcx
ffffffff8101774c:	48 8b 05 b5 78 fe 3e 	mov    0x3efe78b5(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
        Sc::ctr_link++;
ffffffff81017753:	ff 05 ab 85 fe 3e    	incl   0x3efe85ab(%rip)        # ffffffffbffffd04 <_ZN2Sc8ctr_linkE>
ffffffff81017759:	48 89 88 90 01 00 00 	mov    %rcx,0x190(%rax)
        ec->cont = recv_kern;
ffffffff81017760:	48 c7 83 a0 00 00 00 	movq   $0xffffffff81000148,0xa0(%rbx)
ffffffff81017767:	48 01 00 81 
        ec->regs.set_pt (pt->id);
ffffffff8101776b:	48 8b 8a a8 00 00 00 	mov    0xa8(%rdx),%rcx
        }

        ALWAYS_INLINE
        inline void set_pt (mword pt) { ARG_1 = pt; }
ffffffff81017772:	48 89 8b e8 00 00 00 	mov    %rcx,0xe8(%rbx)
        ec->regs.set_ip (pt->ip);
ffffffff81017779:	48 8b 92 a0 00 00 00 	mov    0xa0(%rdx),%rdx

        ALWAYS_INLINE
        inline void set_pt (mword pt, mword pt2, mword s) { ARG_1 = pt; ARG_2 = pt2; ARG_3 = s; }

        ALWAYS_INLINE
        inline void set_ip (mword ip) { ARG_IP = ip; }
ffffffff81017780:	48 89 93 18 01 00 00 	mov    %rdx,0x118(%rbx)
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff81017787:	83 ca ff             	or     $0xffffffff,%edx
ffffffff8101778a:	f0 0f c1 90 8c 00 00 	lock xadd %edx,0x8c(%rax)
ffffffff81017791:	00 
        regs.ARG_3 = cnt;
    }

    ALWAYS_INLINE NORETURN
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
ffffffff81017792:	ff ca                	dec    %edx
ffffffff81017794:	75 31                	jne    ffffffff810177c7 <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x159>
            delete current;
ffffffff81017796:	48 8b 2d 6b 78 fe 3e 	mov    0x3efe786b(%rip),%rbp        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8101779d:	48 85 ed             	test   %rbp,%rbp
ffffffff810177a0:	74 25                	je     ffffffff810177c7 <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x159>
ffffffff810177a2:	48 89 ef             	mov    %rbp,%rdi
ffffffff810177a5:	e8 92 cc fe ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff810177aa:	48 8b 85 98 02 00 00 	mov    0x298(%rbp),%rax
ffffffff810177b1:	48 89 ee             	mov    %rbp,%rsi
ffffffff810177b4:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff810177bb:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff810177c2:	e8 a3 e2 ff ff       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
            delete current;
        }

        current = this;
ffffffff810177c7:	48 89 1d 3a 78 fe 3e 	mov    %rbx,0x3efe783a(%rip)        # ffffffffbffff008 <_ZN2Ec7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff810177ce:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff810177d4:	85 c0                	test   %eax,%eax
ffffffff810177d6:	74 0d                	je     ffffffff810177e5 <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x177>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff810177d8:	8d 50 01             	lea    0x1(%rax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff810177db:	f0 0f b1 93 8c 00 00 	lock cmpxchg %edx,0x8c(%rbx)
ffffffff810177e2:	00 
ffffffff810177e3:	75 e9                	jne    ffffffff810177ce <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x160>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
ffffffff810177e5:	48 8b 93 98 02 00 00 	mov    0x298(%rbx),%rdx

        current->add_ref();

        Tss::run.sp0 = reinterpret_cast<mword> (exc_regs() + 1);
ffffffff810177ec:	48 8d 83 80 01 00 00 	lea    0x180(%rbx),%rax
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
ffffffff810177f3:	8b 0d 0b 78 fe 3e    	mov    0x3efe780b(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff810177f9:	48 89 05 cc 85 fe 3e 	mov    %rax,0x3efe85cc(%rip)        # ffffffffbffffdcc <tss_run+0x4>
ffffffff81017800:	48 8b 82 c8 02 00 00 	mov    0x2c8(%rdx),%rax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
ffffffff81017807:	48 8b ba b8 02 00 00 	mov    0x2b8(%rdx),%rdi

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
ffffffff8101780e:	48 0f a3 c8          	bt     %rcx,%rax
ffffffff81017812:	73 14                	jae    ffffffff81017828 <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x1ba>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
ffffffff81017814:	48 c7 c6 fe ff ff ff 	mov    $0xfffffffffffffffe,%rsi
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
ffffffff8101781b:	48 d3 c6             	rol    %cl,%rsi
ffffffff8101781e:	f0 48 21 b2 c8 02 00 	lock and %rsi,0x2c8(%rdx)
ffffffff81017825:	00 
ffffffff81017826:	eb 20                	jmp    ffffffff81017848 <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x1da>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
ffffffff81017828:	48 39 15 e1 77 fe 3e 	cmp    %rdx,0x3efe77e1(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8101782f:	0f 84 ea 00 00 00    	je     ffffffff8101791f <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x2b1>
                    return;

                if (pcid != NO_PCID)
ffffffff81017835:	48 83 ff 02          	cmp    $0x2,%rdi
ffffffff81017839:	74 0d                	je     ffffffff81017848 <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x1da>
                    pcid |= static_cast<mword>(1ULL << 63);
ffffffff8101783b:	48 b8 00 00 00 00 00 	movabs $0x8000000000000000,%rax
ffffffff81017842:	00 00 80 
ffffffff81017845:	48 09 c7             	or     %rax,%rdi
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff81017848:	48 8b 0d c1 77 fe 3e 	mov    0x3efe77c1(%rip),%rcx        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8101784f:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff81017852:	f0 0f c1 81 8c 00 00 	lock xadd %eax,0x8c(%rcx)
ffffffff81017859:	00 
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
ffffffff8101785a:	ff c8                	dec    %eax
ffffffff8101785c:	75 34                	jne    ffffffff81017892 <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x224>
                assert (current != this);
ffffffff8101785e:	4c 8b 25 ab 77 fe 3e 	mov    0x3efe77ab(%rip),%r12        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81017865:	49 39 d4             	cmp    %rdx,%r12
ffffffff81017868:	75 2b                	jne    ffffffff81017895 <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x227>
ffffffff8101786a:	49 c7 c0 a0 12 02 81 	mov    $0xffffffff810212a0,%r8
ffffffff81017871:	b9 5e 00 00 00       	mov    $0x5e,%ecx
ffffffff81017876:	48 c7 c2 c7 e6 01 81 	mov    $0xffffffff8101e6c7,%rdx
ffffffff8101787d:	48 c7 c6 35 e7 01 81 	mov    $0xffffffff8101e735,%rsi
ffffffff81017884:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8101788b:	31 c0                	xor    %eax,%eax
ffffffff8101788d:	e8 be a6 fe ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
ffffffff81017892:	45 31 e4             	xor    %r12d,%r12d
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
ffffffff81017895:	48 89 15 74 77 fe 3e 	mov    %rdx,0x3efe7774(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8101789c:	8b 82 8c 00 00 00    	mov    0x8c(%rdx),%eax
ffffffff810178a2:	85 c0                	test   %eax,%eax
ffffffff810178a4:	74 0d                	je     ffffffff810178b3 <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x245>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff810178a6:	8d 48 01             	lea    0x1(%rax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff810178a9:	f0 0f b1 8a 8c 00 00 	lock cmpxchg %ecx,0x8c(%rdx)
ffffffff810178b0:	00 
ffffffff810178b1:	75 e9                	jne    ffffffff8101789c <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x22e>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
ffffffff810178b3:	f6 05 8c 7e fe 3e 02 	testb  $0x2,0x3efe7e8c(%rip)        # ffffffffbffff746 <_ZN3Cpu8featuresE+0x6>
ffffffff810178ba:	8b 0d 44 77 fe 3e    	mov    0x3efe7744(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff810178c0:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff810178c5:	48 0f 45 c7          	cmovne %rdi,%rax
ffffffff810178c9:	48 0b 84 ca a0 00 00 	or     0xa0(%rdx,%rcx,8),%rax
ffffffff810178d0:	00 
ffffffff810178d1:	0f 22 d8             	mov    %rax,%cr3

            if (del_pd)
ffffffff810178d4:	4d 85 e4             	test   %r12,%r12
ffffffff810178d7:	74 46                	je     ffffffff8101791f <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x2b1>
                delete del_pd;
ffffffff810178d9:	4c 89 e7             	mov    %r12,%rdi
ffffffff810178dc:	e8 47 97 ff ff       	callq  ffffffff81011028 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff810178e1:	49 8b 44 24 50       	mov    0x50(%r12),%rax
ffffffff810178e6:	31 d2                	xor    %edx,%edx

            pd_del->quota.free_up(pd_to->quota);
ffffffff810178e8:	49 8d bc 24 08 03 00 	lea    0x308(%r12),%rdi
ffffffff810178ef:	00 

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff810178f0:	48 8d 88 08 fd ff ff 	lea    -0x2f8(%rax),%rcx
ffffffff810178f7:	48 85 c0             	test   %rax,%rax
ffffffff810178fa:	48 0f 45 d1          	cmovne %rcx,%rdx

            pd_del->quota.free_up(pd_to->quota);
ffffffff810178fe:	48 8d aa 08 03 00 00 	lea    0x308(%rdx),%rbp
ffffffff81017905:	48 89 ee             	mov    %rbp,%rsi
ffffffff81017908:	e8 b7 bc fe ff       	callq  ffffffff810035c4 <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
ffffffff8101790d:	48 89 ea             	mov    %rbp,%rdx
ffffffff81017910:	4c 89 e6             	mov    %r12,%rsi
ffffffff81017913:	48 c7 c7 d0 3f 16 81 	mov    $0xffffffff81163fd0,%rdi
ffffffff8101791a:	e8 4b e1 ff ff       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>

        pd->make_current();

        asm volatile ("mov %0," EXPAND(PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory");
ffffffff8101791f:	48 8b 83 a0 00 00 00 	mov    0xa0(%rbx),%rax
ffffffff81017926:	48 c7 c4 00 e0 ff bf 	mov    $0xffffffffbfffe000,%rsp
ffffffff8101792d:	ff e0                	jmpq   *%rax
        ec->make_current();
    }

    ec->help (send_msg<C>);
ffffffff8101792f:	48 c7 c6 6e 76 01 81 	mov    $0xffffffff8101766e,%rsi
ffffffff81017936:	48 89 df             	mov    %rbx,%rdi
ffffffff81017939:	e8 ae 3d ff ff       	callq  ffffffff8100b6ec <_ZN2Ec4helpEPFvvE>

    die ("IPC Timeout");
ffffffff8101793e:	48 8b 05 c3 76 fe 3e 	mov    0x3efe76c3(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81017945:	48 c7 c7 27 0d 02 81 	mov    $0xffffffff81020d27,%rdi
ffffffff8101794c:	48 8d b0 a8 00 00 00 	lea    0xa8(%rax),%rsi
ffffffff81017953:	e9 7e fd ff ff       	jmpq   ffffffff810176d6 <_ZN2Ec8send_msgIXadL_ZNS_17ret_user_vmresumeEvEEEEvv+0x68>

ffffffff81017958 <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv>:
}

template <void (*C)()>
void Ec::send_msg()
{
    Exc_regs *r = &current->regs;
ffffffff81017958:	48 8b 35 a9 76 fe 3e 	mov    0x3efe76a9(%rip),%rsi        # ffffffffbffff008 <_ZN2Ec7currentE>
        current->oom_delegate(dst, ec, src, user, C);
    }
}

template <void (*C)()>
void Ec::send_msg()
ffffffff8101795f:	41 54                	push   %r12
ffffffff81017961:	55                   	push   %rbp
ffffffff81017962:	53                   	push   %rbx
{
    Exc_regs *r = &current->regs;

    Kobject *obj = Space_obj::lookup (current->evt + r->dst_portal).obj();
ffffffff81017963:	8b 86 f4 02 00 00    	mov    0x2f4(%rsi),%eax
ffffffff81017969:	48 03 86 50 01 00 00 	add    0x150(%rsi),%rax
ffffffff81017970:	25 ff ff ff 03       	and    $0x3ffffff,%eax
ffffffff81017975:	48 8b 14 c5 00 00 00 	mov    -0x20000000(,%rax,8),%rdx
ffffffff8101797c:	e0 
ffffffff8101797d:	48 83 e2 e0          	and    $0xffffffffffffffe0,%rdx
ffffffff81017981:	74 09                	je     ffffffff8101798c <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x34>
    if (EXPECT_FALSE (obj->type() != Kobject::PT))
ffffffff81017983:	80 ba 88 00 00 00 03 	cmpb   $0x3,0x88(%rdx)
ffffffff8101798a:	74 10                	je     ffffffff8101799c <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x44>
        die ("PT not found");
ffffffff8101798c:	48 81 c6 a8 00 00 00 	add    $0xa8,%rsi
ffffffff81017993:	48 c7 c7 51 dc 01 81 	mov    $0xffffffff8101dc51,%rdi
ffffffff8101799a:	eb 24                	jmp    ffffffff810179c0 <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x68>
{
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
ffffffff8101799c:	48 8b 9a 90 00 00 00 	mov    0x90(%rdx),%rbx

    Pt *pt = static_cast<Pt *>(obj);
    Ec *ec = pt->ec;

    if (EXPECT_FALSE (current->cpu != ec->xcpu))
ffffffff810179a3:	0f b7 86 f0 02 00 00 	movzwl 0x2f0(%rsi),%eax
ffffffff810179aa:	3b 83 f0 02 00 00    	cmp    0x2f0(%rbx),%eax
ffffffff810179b0:	74 13                	je     ffffffff810179c5 <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x6d>
        die ("PT wrong CPU");
ffffffff810179b2:	48 81 c6 a8 00 00 00 	add    $0xa8,%rsi
ffffffff810179b9:	48 c7 c7 1a 0d 02 81 	mov    $0xffffffff81020d1a,%rdi
ffffffff810179c0:	e8 45 d2 fe ff       	callq  ffffffff81004c0a <_ZN2Ec3dieEPKcP8Exc_regs>

    if (EXPECT_TRUE (!ec->cont)) {
ffffffff810179c5:	48 83 bb a0 00 00 00 	cmpq   $0x0,0xa0(%rbx)
ffffffff810179cc:	00 
ffffffff810179cd:	0f 85 46 02 00 00    	jne    ffffffff81017c19 <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x2c1>
        current->cont = C;
ffffffff810179d3:	48 c7 86 a0 00 00 00 	movq   $0xffffffff81004a8a,0xa0(%rsi)
ffffffff810179da:	8a 4a 00 81 
        return &regs;
    }

    ALWAYS_INLINE
    inline void set_partner(Ec *p) {
        partner = p;
ffffffff810179de:	48 89 9e a0 02 00 00 	mov    %rbx,0x2a0(%rsi)
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff810179e5:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff810179eb:	85 c0                	test   %eax,%eax
ffffffff810179ed:	74 0d                	je     ffffffff810179fc <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0xa4>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff810179ef:	8d 48 01             	lea    0x1(%rax),%ecx
ffffffff810179f2:	f0 0f b1 8b 8c 00 00 	lock cmpxchg %ecx,0x8c(%rbx)
ffffffff810179f9:	00 
ffffffff810179fa:	75 e9                	jne    ffffffff810179e5 <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x8d>
        partner->add_ref();
        partner->rcap = this;
ffffffff810179fc:	48 8b 86 a0 02 00 00 	mov    0x2a0(%rsi),%rax
ffffffff81017a03:	48 89 b0 88 02 00 00 	mov    %rsi,0x288(%rax)
        partner->rcap->add_ref();
ffffffff81017a0a:	48 8b 86 a0 02 00 00 	mov    0x2a0(%rsi),%rax
ffffffff81017a11:	48 8b 88 88 02 00 00 	mov    0x288(%rax),%rcx
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff81017a18:	8b 81 8c 00 00 00    	mov    0x8c(%rcx),%eax
ffffffff81017a1e:	85 c0                	test   %eax,%eax
ffffffff81017a20:	74 0d                	je     ffffffff81017a2f <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0xd7>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff81017a22:	8d 70 01             	lea    0x1(%rax),%esi
ffffffff81017a25:	f0 0f b1 b1 8c 00 00 	lock cmpxchg %esi,0x8c(%rcx)
ffffffff81017a2c:	00 
ffffffff81017a2d:	75 e9                	jne    ffffffff81017a18 <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0xc0>
        current->set_partner (ec);
        current->regs.mtd = pt->mtd.val;
ffffffff81017a2f:	48 8b 8a 98 00 00 00 	mov    0x98(%rdx),%rcx
ffffffff81017a36:	48 8b 05 cb 75 fe 3e 	mov    0x3efe75cb(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
        Sc::ctr_link++;
ffffffff81017a3d:	ff 05 c1 82 fe 3e    	incl   0x3efe82c1(%rip)        # ffffffffbffffd04 <_ZN2Sc8ctr_linkE>
ffffffff81017a43:	48 89 88 90 01 00 00 	mov    %rcx,0x190(%rax)
        ec->cont = recv_kern;
ffffffff81017a4a:	48 c7 83 a0 00 00 00 	movq   $0xffffffff81000148,0xa0(%rbx)
ffffffff81017a51:	48 01 00 81 
        ec->regs.set_pt (pt->id);
ffffffff81017a55:	48 8b 8a a8 00 00 00 	mov    0xa8(%rdx),%rcx
            else
                ARG_1 = (ARG_1 & ~0xfful) | s;
        }

        ALWAYS_INLINE
        inline void set_pt (mword pt) { ARG_1 = pt; }
ffffffff81017a5c:	48 89 8b e8 00 00 00 	mov    %rcx,0xe8(%rbx)
        ec->regs.set_ip (pt->ip);
ffffffff81017a63:	48 8b 92 a0 00 00 00 	mov    0xa0(%rdx),%rdx

        ALWAYS_INLINE
        inline void set_pt (mword pt, mword pt2, mword s) { ARG_1 = pt; ARG_2 = pt2; ARG_3 = s; }

        ALWAYS_INLINE
        inline void set_ip (mword ip) { ARG_IP = ip; }
ffffffff81017a6a:	48 89 93 18 01 00 00 	mov    %rdx,0x118(%rbx)
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff81017a71:	83 ca ff             	or     $0xffffffff,%edx
ffffffff81017a74:	f0 0f c1 90 8c 00 00 	lock xadd %edx,0x8c(%rax)
ffffffff81017a7b:	00 
        regs.ARG_3 = cnt;
    }

    ALWAYS_INLINE NORETURN
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
ffffffff81017a7c:	ff ca                	dec    %edx
ffffffff81017a7e:	75 31                	jne    ffffffff81017ab1 <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x159>
            delete current;
ffffffff81017a80:	48 8b 2d 81 75 fe 3e 	mov    0x3efe7581(%rip),%rbp        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81017a87:	48 85 ed             	test   %rbp,%rbp
ffffffff81017a8a:	74 25                	je     ffffffff81017ab1 <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x159>
ffffffff81017a8c:	48 89 ef             	mov    %rbp,%rdi
ffffffff81017a8f:	e8 a8 c9 fe ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff81017a94:	48 8b 85 98 02 00 00 	mov    0x298(%rbp),%rax
ffffffff81017a9b:	48 89 ee             	mov    %rbp,%rsi
ffffffff81017a9e:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff81017aa5:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff81017aac:	e8 b9 df ff ff       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
            delete current;
        }

        current = this;
ffffffff81017ab1:	48 89 1d 50 75 fe 3e 	mov    %rbx,0x3efe7550(%rip)        # ffffffffbffff008 <_ZN2Ec7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff81017ab8:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff81017abe:	85 c0                	test   %eax,%eax
ffffffff81017ac0:	74 0d                	je     ffffffff81017acf <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x177>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff81017ac2:	8d 50 01             	lea    0x1(%rax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff81017ac5:	f0 0f b1 93 8c 00 00 	lock cmpxchg %edx,0x8c(%rbx)
ffffffff81017acc:	00 
ffffffff81017acd:	75 e9                	jne    ffffffff81017ab8 <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x160>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
ffffffff81017acf:	48 8b 93 98 02 00 00 	mov    0x298(%rbx),%rdx

        current->add_ref();

        Tss::run.sp0 = reinterpret_cast<mword> (exc_regs() + 1);
ffffffff81017ad6:	48 8d 83 80 01 00 00 	lea    0x180(%rbx),%rax
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
ffffffff81017add:	8b 0d 21 75 fe 3e    	mov    0x3efe7521(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81017ae3:	48 89 05 e2 82 fe 3e 	mov    %rax,0x3efe82e2(%rip)        # ffffffffbffffdcc <tss_run+0x4>
ffffffff81017aea:	48 8b 82 c8 02 00 00 	mov    0x2c8(%rdx),%rax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
ffffffff81017af1:	48 8b ba b8 02 00 00 	mov    0x2b8(%rdx),%rdi

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
ffffffff81017af8:	48 0f a3 c8          	bt     %rcx,%rax
ffffffff81017afc:	73 14                	jae    ffffffff81017b12 <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x1ba>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
ffffffff81017afe:	48 c7 c6 fe ff ff ff 	mov    $0xfffffffffffffffe,%rsi
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
ffffffff81017b05:	48 d3 c6             	rol    %cl,%rsi
ffffffff81017b08:	f0 48 21 b2 c8 02 00 	lock and %rsi,0x2c8(%rdx)
ffffffff81017b0f:	00 
ffffffff81017b10:	eb 20                	jmp    ffffffff81017b32 <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x1da>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
ffffffff81017b12:	48 39 15 f7 74 fe 3e 	cmp    %rdx,0x3efe74f7(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81017b19:	0f 84 ea 00 00 00    	je     ffffffff81017c09 <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x2b1>
                    return;

                if (pcid != NO_PCID)
ffffffff81017b1f:	48 83 ff 02          	cmp    $0x2,%rdi
ffffffff81017b23:	74 0d                	je     ffffffff81017b32 <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x1da>
                    pcid |= static_cast<mword>(1ULL << 63);
ffffffff81017b25:	48 b8 00 00 00 00 00 	movabs $0x8000000000000000,%rax
ffffffff81017b2c:	00 00 80 
ffffffff81017b2f:	48 09 c7             	or     %rax,%rdi
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff81017b32:	48 8b 0d d7 74 fe 3e 	mov    0x3efe74d7(%rip),%rcx        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81017b39:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff81017b3c:	f0 0f c1 81 8c 00 00 	lock xadd %eax,0x8c(%rcx)
ffffffff81017b43:	00 
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
ffffffff81017b44:	ff c8                	dec    %eax
ffffffff81017b46:	75 34                	jne    ffffffff81017b7c <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x224>
                assert (current != this);
ffffffff81017b48:	4c 8b 25 c1 74 fe 3e 	mov    0x3efe74c1(%rip),%r12        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81017b4f:	49 39 d4             	cmp    %rdx,%r12
ffffffff81017b52:	75 2b                	jne    ffffffff81017b7f <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x227>
ffffffff81017b54:	49 c7 c0 a0 12 02 81 	mov    $0xffffffff810212a0,%r8
ffffffff81017b5b:	b9 5e 00 00 00       	mov    $0x5e,%ecx
ffffffff81017b60:	48 c7 c2 c7 e6 01 81 	mov    $0xffffffff8101e6c7,%rdx
ffffffff81017b67:	48 c7 c6 35 e7 01 81 	mov    $0xffffffff8101e735,%rsi
ffffffff81017b6e:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81017b75:	31 c0                	xor    %eax,%eax
ffffffff81017b77:	e8 d4 a3 fe ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
ffffffff81017b7c:	45 31 e4             	xor    %r12d,%r12d
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
ffffffff81017b7f:	48 89 15 8a 74 fe 3e 	mov    %rdx,0x3efe748a(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff81017b86:	8b 82 8c 00 00 00    	mov    0x8c(%rdx),%eax
ffffffff81017b8c:	85 c0                	test   %eax,%eax
ffffffff81017b8e:	74 0d                	je     ffffffff81017b9d <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x245>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff81017b90:	8d 48 01             	lea    0x1(%rax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff81017b93:	f0 0f b1 8a 8c 00 00 	lock cmpxchg %ecx,0x8c(%rdx)
ffffffff81017b9a:	00 
ffffffff81017b9b:	75 e9                	jne    ffffffff81017b86 <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x22e>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
ffffffff81017b9d:	f6 05 a2 7b fe 3e 02 	testb  $0x2,0x3efe7ba2(%rip)        # ffffffffbffff746 <_ZN3Cpu8featuresE+0x6>
ffffffff81017ba4:	8b 0d 5a 74 fe 3e    	mov    0x3efe745a(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81017baa:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff81017baf:	48 0f 45 c7          	cmovne %rdi,%rax
ffffffff81017bb3:	48 0b 84 ca a0 00 00 	or     0xa0(%rdx,%rcx,8),%rax
ffffffff81017bba:	00 
ffffffff81017bbb:	0f 22 d8             	mov    %rax,%cr3

            if (del_pd)
ffffffff81017bbe:	4d 85 e4             	test   %r12,%r12
ffffffff81017bc1:	74 46                	je     ffffffff81017c09 <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x2b1>
                delete del_pd;
ffffffff81017bc3:	4c 89 e7             	mov    %r12,%rdi
ffffffff81017bc6:	e8 5d 94 ff ff       	callq  ffffffff81011028 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff81017bcb:	49 8b 44 24 50       	mov    0x50(%r12),%rax
ffffffff81017bd0:	31 d2                	xor    %edx,%edx

            pd_del->quota.free_up(pd_to->quota);
ffffffff81017bd2:	49 8d bc 24 08 03 00 	lea    0x308(%r12),%rdi
ffffffff81017bd9:	00 

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff81017bda:	48 8d 88 08 fd ff ff 	lea    -0x2f8(%rax),%rcx
ffffffff81017be1:	48 85 c0             	test   %rax,%rax
ffffffff81017be4:	48 0f 45 d1          	cmovne %rcx,%rdx

            pd_del->quota.free_up(pd_to->quota);
ffffffff81017be8:	48 8d aa 08 03 00 00 	lea    0x308(%rdx),%rbp
ffffffff81017bef:	48 89 ee             	mov    %rbp,%rsi
ffffffff81017bf2:	e8 cd b9 fe ff       	callq  ffffffff810035c4 <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
ffffffff81017bf7:	48 89 ea             	mov    %rbp,%rdx
ffffffff81017bfa:	4c 89 e6             	mov    %r12,%rsi
ffffffff81017bfd:	48 c7 c7 d0 3f 16 81 	mov    $0xffffffff81163fd0,%rdi
ffffffff81017c04:	e8 61 de ff ff       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>

        pd->make_current();

        asm volatile ("mov %0," EXPAND(PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory");
ffffffff81017c09:	48 8b 83 a0 00 00 00 	mov    0xa0(%rbx),%rax
ffffffff81017c10:	48 c7 c4 00 e0 ff bf 	mov    $0xffffffffbfffe000,%rsp
ffffffff81017c17:	ff e0                	jmpq   *%rax
        ec->make_current();
    }

    ec->help (send_msg<C>);
ffffffff81017c19:	48 c7 c6 58 79 01 81 	mov    $0xffffffff81017958,%rsi
ffffffff81017c20:	48 89 df             	mov    %rbx,%rdi
ffffffff81017c23:	e8 c4 3a ff ff       	callq  ffffffff8100b6ec <_ZN2Ec4helpEPFvvE>

    die ("IPC Timeout");
ffffffff81017c28:	48 8b 05 d9 73 fe 3e 	mov    0x3efe73d9(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81017c2f:	48 c7 c7 27 0d 02 81 	mov    $0xffffffff81020d27,%rdi
ffffffff81017c36:	48 8d b0 a8 00 00 00 	lea    0xa8(%rax),%rsi
ffffffff81017c3d:	e9 7e fd ff ff       	jmpq   ffffffff810179c0 <_ZN2Ec8send_msgIXadL_ZNS_14ret_user_vmrunEvEEEEvv+0x68>

ffffffff81017c42 <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv>:
}

template <void (*C)()>
void Ec::send_msg()
{
    Exc_regs *r = &current->regs;
ffffffff81017c42:	48 8b 35 bf 73 fe 3e 	mov    0x3efe73bf(%rip),%rsi        # ffffffffbffff008 <_ZN2Ec7currentE>
        current->oom_delegate(dst, ec, src, user, C);
    }
}

template <void (*C)()>
void Ec::send_msg()
ffffffff81017c49:	41 54                	push   %r12
ffffffff81017c4b:	55                   	push   %rbp
ffffffff81017c4c:	53                   	push   %rbx
{
    Exc_regs *r = &current->regs;

    Kobject *obj = Space_obj::lookup (current->evt + r->dst_portal).obj();
ffffffff81017c4d:	8b 86 f4 02 00 00    	mov    0x2f4(%rsi),%eax
ffffffff81017c53:	48 03 86 50 01 00 00 	add    0x150(%rsi),%rax
ffffffff81017c5a:	25 ff ff ff 03       	and    $0x3ffffff,%eax
ffffffff81017c5f:	48 8b 14 c5 00 00 00 	mov    -0x20000000(,%rax,8),%rdx
ffffffff81017c66:	e0 
ffffffff81017c67:	48 83 e2 e0          	and    $0xffffffffffffffe0,%rdx
ffffffff81017c6b:	74 09                	je     ffffffff81017c76 <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x34>
    if (EXPECT_FALSE (obj->type() != Kobject::PT))
ffffffff81017c6d:	80 ba 88 00 00 00 03 	cmpb   $0x3,0x88(%rdx)
ffffffff81017c74:	74 10                	je     ffffffff81017c86 <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x44>
        die ("PT not found");
ffffffff81017c76:	48 81 c6 a8 00 00 00 	add    $0xa8,%rsi
ffffffff81017c7d:	48 c7 c7 51 dc 01 81 	mov    $0xffffffff8101dc51,%rdi
ffffffff81017c84:	eb 24                	jmp    ffffffff81017caa <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x68>
{
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
ffffffff81017c86:	48 8b 9a 90 00 00 00 	mov    0x90(%rdx),%rbx

    Pt *pt = static_cast<Pt *>(obj);
    Ec *ec = pt->ec;

    if (EXPECT_FALSE (current->cpu != ec->xcpu))
ffffffff81017c8d:	0f b7 86 f0 02 00 00 	movzwl 0x2f0(%rsi),%eax
ffffffff81017c94:	3b 83 f0 02 00 00    	cmp    0x2f0(%rbx),%eax
ffffffff81017c9a:	74 13                	je     ffffffff81017caf <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x6d>
        die ("PT wrong CPU");
ffffffff81017c9c:	48 81 c6 a8 00 00 00 	add    $0xa8,%rsi
ffffffff81017ca3:	48 c7 c7 1a 0d 02 81 	mov    $0xffffffff81020d1a,%rdi
ffffffff81017caa:	e8 5b cf fe ff       	callq  ffffffff81004c0a <_ZN2Ec3dieEPKcP8Exc_regs>

    if (EXPECT_TRUE (!ec->cont)) {
ffffffff81017caf:	48 83 bb a0 00 00 00 	cmpq   $0x0,0xa0(%rbx)
ffffffff81017cb6:	00 
ffffffff81017cb7:	0f 85 46 02 00 00    	jne    ffffffff81017f03 <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x2c1>
        current->cont = C;
ffffffff81017cbd:	48 c7 86 a0 00 00 00 	movq   $0xffffffff8100008c,0xa0(%rsi)
ffffffff81017cc4:	8c 00 00 81 
        return &regs;
    }

    ALWAYS_INLINE
    inline void set_partner(Ec *p) {
        partner = p;
ffffffff81017cc8:	48 89 9e a0 02 00 00 	mov    %rbx,0x2a0(%rsi)
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff81017ccf:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff81017cd5:	85 c0                	test   %eax,%eax
ffffffff81017cd7:	74 0d                	je     ffffffff81017ce6 <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0xa4>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff81017cd9:	8d 48 01             	lea    0x1(%rax),%ecx
ffffffff81017cdc:	f0 0f b1 8b 8c 00 00 	lock cmpxchg %ecx,0x8c(%rbx)
ffffffff81017ce3:	00 
ffffffff81017ce4:	75 e9                	jne    ffffffff81017ccf <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x8d>
        partner->add_ref();
        partner->rcap = this;
ffffffff81017ce6:	48 8b 86 a0 02 00 00 	mov    0x2a0(%rsi),%rax
ffffffff81017ced:	48 89 b0 88 02 00 00 	mov    %rsi,0x288(%rax)
        partner->rcap->add_ref();
ffffffff81017cf4:	48 8b 86 a0 02 00 00 	mov    0x2a0(%rsi),%rax
ffffffff81017cfb:	48 8b 88 88 02 00 00 	mov    0x288(%rax),%rcx
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff81017d02:	8b 81 8c 00 00 00    	mov    0x8c(%rcx),%eax
ffffffff81017d08:	85 c0                	test   %eax,%eax
ffffffff81017d0a:	74 0d                	je     ffffffff81017d19 <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0xd7>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff81017d0c:	8d 70 01             	lea    0x1(%rax),%esi
ffffffff81017d0f:	f0 0f b1 b1 8c 00 00 	lock cmpxchg %esi,0x8c(%rcx)
ffffffff81017d16:	00 
ffffffff81017d17:	75 e9                	jne    ffffffff81017d02 <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0xc0>
        current->set_partner (ec);
        current->regs.mtd = pt->mtd.val;
ffffffff81017d19:	48 8b 8a 98 00 00 00 	mov    0x98(%rdx),%rcx
ffffffff81017d20:	48 8b 05 e1 72 fe 3e 	mov    0x3efe72e1(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
        Sc::ctr_link++;
ffffffff81017d27:	ff 05 d7 7f fe 3e    	incl   0x3efe7fd7(%rip)        # ffffffffbffffd04 <_ZN2Sc8ctr_linkE>
ffffffff81017d2d:	48 89 88 90 01 00 00 	mov    %rcx,0x190(%rax)
        ec->cont = recv_kern;
ffffffff81017d34:	48 c7 83 a0 00 00 00 	movq   $0xffffffff81000148,0xa0(%rbx)
ffffffff81017d3b:	48 01 00 81 
        ec->regs.set_pt (pt->id);
ffffffff81017d3f:	48 8b 8a a8 00 00 00 	mov    0xa8(%rdx),%rcx
            else
                ARG_1 = (ARG_1 & ~0xfful) | s;
        }

        ALWAYS_INLINE
        inline void set_pt (mword pt) { ARG_1 = pt; }
ffffffff81017d46:	48 89 8b e8 00 00 00 	mov    %rcx,0xe8(%rbx)
        ec->regs.set_ip (pt->ip);
ffffffff81017d4d:	48 8b 92 a0 00 00 00 	mov    0xa0(%rdx),%rdx

        ALWAYS_INLINE
        inline void set_pt (mword pt, mword pt2, mword s) { ARG_1 = pt; ARG_2 = pt2; ARG_3 = s; }

        ALWAYS_INLINE
        inline void set_ip (mword ip) { ARG_IP = ip; }
ffffffff81017d54:	48 89 93 18 01 00 00 	mov    %rdx,0x118(%rbx)
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff81017d5b:	83 ca ff             	or     $0xffffffff,%edx
ffffffff81017d5e:	f0 0f c1 90 8c 00 00 	lock xadd %edx,0x8c(%rax)
ffffffff81017d65:	00 
        regs.ARG_3 = cnt;
    }

    ALWAYS_INLINE NORETURN
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
ffffffff81017d66:	ff ca                	dec    %edx
ffffffff81017d68:	75 31                	jne    ffffffff81017d9b <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x159>
            delete current;
ffffffff81017d6a:	48 8b 2d 97 72 fe 3e 	mov    0x3efe7297(%rip),%rbp        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81017d71:	48 85 ed             	test   %rbp,%rbp
ffffffff81017d74:	74 25                	je     ffffffff81017d9b <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x159>
ffffffff81017d76:	48 89 ef             	mov    %rbp,%rdi
ffffffff81017d79:	e8 be c6 fe ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff81017d7e:	48 8b 85 98 02 00 00 	mov    0x298(%rbp),%rax
ffffffff81017d85:	48 89 ee             	mov    %rbp,%rsi
ffffffff81017d88:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff81017d8f:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff81017d96:	e8 cf dc ff ff       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
            delete current;
        }

        current = this;
ffffffff81017d9b:	48 89 1d 66 72 fe 3e 	mov    %rbx,0x3efe7266(%rip)        # ffffffffbffff008 <_ZN2Ec7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff81017da2:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff81017da8:	85 c0                	test   %eax,%eax
ffffffff81017daa:	74 0d                	je     ffffffff81017db9 <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x177>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff81017dac:	8d 50 01             	lea    0x1(%rax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff81017daf:	f0 0f b1 93 8c 00 00 	lock cmpxchg %edx,0x8c(%rbx)
ffffffff81017db6:	00 
ffffffff81017db7:	75 e9                	jne    ffffffff81017da2 <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x160>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
ffffffff81017db9:	48 8b 93 98 02 00 00 	mov    0x298(%rbx),%rdx

        current->add_ref();

        Tss::run.sp0 = reinterpret_cast<mword> (exc_regs() + 1);
ffffffff81017dc0:	48 8d 83 80 01 00 00 	lea    0x180(%rbx),%rax
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
ffffffff81017dc7:	8b 0d 37 72 fe 3e    	mov    0x3efe7237(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81017dcd:	48 89 05 f8 7f fe 3e 	mov    %rax,0x3efe7ff8(%rip)        # ffffffffbffffdcc <tss_run+0x4>
ffffffff81017dd4:	48 8b 82 c8 02 00 00 	mov    0x2c8(%rdx),%rax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
ffffffff81017ddb:	48 8b ba b8 02 00 00 	mov    0x2b8(%rdx),%rdi

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
ffffffff81017de2:	48 0f a3 c8          	bt     %rcx,%rax
ffffffff81017de6:	73 14                	jae    ffffffff81017dfc <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x1ba>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
ffffffff81017de8:	48 c7 c6 fe ff ff ff 	mov    $0xfffffffffffffffe,%rsi
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
ffffffff81017def:	48 d3 c6             	rol    %cl,%rsi
ffffffff81017df2:	f0 48 21 b2 c8 02 00 	lock and %rsi,0x2c8(%rdx)
ffffffff81017df9:	00 
ffffffff81017dfa:	eb 20                	jmp    ffffffff81017e1c <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x1da>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
ffffffff81017dfc:	48 39 15 0d 72 fe 3e 	cmp    %rdx,0x3efe720d(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81017e03:	0f 84 ea 00 00 00    	je     ffffffff81017ef3 <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x2b1>
                    return;

                if (pcid != NO_PCID)
ffffffff81017e09:	48 83 ff 02          	cmp    $0x2,%rdi
ffffffff81017e0d:	74 0d                	je     ffffffff81017e1c <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x1da>
                    pcid |= static_cast<mword>(1ULL << 63);
ffffffff81017e0f:	48 b8 00 00 00 00 00 	movabs $0x8000000000000000,%rax
ffffffff81017e16:	00 00 80 
ffffffff81017e19:	48 09 c7             	or     %rax,%rdi
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff81017e1c:	48 8b 0d ed 71 fe 3e 	mov    0x3efe71ed(%rip),%rcx        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81017e23:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff81017e26:	f0 0f c1 81 8c 00 00 	lock xadd %eax,0x8c(%rcx)
ffffffff81017e2d:	00 
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
ffffffff81017e2e:	ff c8                	dec    %eax
ffffffff81017e30:	75 34                	jne    ffffffff81017e66 <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x224>
                assert (current != this);
ffffffff81017e32:	4c 8b 25 d7 71 fe 3e 	mov    0x3efe71d7(%rip),%r12        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81017e39:	49 39 d4             	cmp    %rdx,%r12
ffffffff81017e3c:	75 2b                	jne    ffffffff81017e69 <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x227>
ffffffff81017e3e:	49 c7 c0 a0 12 02 81 	mov    $0xffffffff810212a0,%r8
ffffffff81017e45:	b9 5e 00 00 00       	mov    $0x5e,%ecx
ffffffff81017e4a:	48 c7 c2 c7 e6 01 81 	mov    $0xffffffff8101e6c7,%rdx
ffffffff81017e51:	48 c7 c6 35 e7 01 81 	mov    $0xffffffff8101e735,%rsi
ffffffff81017e58:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81017e5f:	31 c0                	xor    %eax,%eax
ffffffff81017e61:	e8 ea a0 fe ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
ffffffff81017e66:	45 31 e4             	xor    %r12d,%r12d
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
ffffffff81017e69:	48 89 15 a0 71 fe 3e 	mov    %rdx,0x3efe71a0(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff81017e70:	8b 82 8c 00 00 00    	mov    0x8c(%rdx),%eax
ffffffff81017e76:	85 c0                	test   %eax,%eax
ffffffff81017e78:	74 0d                	je     ffffffff81017e87 <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x245>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff81017e7a:	8d 48 01             	lea    0x1(%rax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff81017e7d:	f0 0f b1 8a 8c 00 00 	lock cmpxchg %ecx,0x8c(%rdx)
ffffffff81017e84:	00 
ffffffff81017e85:	75 e9                	jne    ffffffff81017e70 <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x22e>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
ffffffff81017e87:	f6 05 b8 78 fe 3e 02 	testb  $0x2,0x3efe78b8(%rip)        # ffffffffbffff746 <_ZN3Cpu8featuresE+0x6>
ffffffff81017e8e:	8b 0d 70 71 fe 3e    	mov    0x3efe7170(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81017e94:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff81017e99:	48 0f 45 c7          	cmovne %rdi,%rax
ffffffff81017e9d:	48 0b 84 ca a0 00 00 	or     0xa0(%rdx,%rcx,8),%rax
ffffffff81017ea4:	00 
ffffffff81017ea5:	0f 22 d8             	mov    %rax,%cr3

            if (del_pd)
ffffffff81017ea8:	4d 85 e4             	test   %r12,%r12
ffffffff81017eab:	74 46                	je     ffffffff81017ef3 <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x2b1>
                delete del_pd;
ffffffff81017ead:	4c 89 e7             	mov    %r12,%rdi
ffffffff81017eb0:	e8 73 91 ff ff       	callq  ffffffff81011028 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff81017eb5:	49 8b 44 24 50       	mov    0x50(%r12),%rax
ffffffff81017eba:	31 d2                	xor    %edx,%edx

            pd_del->quota.free_up(pd_to->quota);
ffffffff81017ebc:	49 8d bc 24 08 03 00 	lea    0x308(%r12),%rdi
ffffffff81017ec3:	00 

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff81017ec4:	48 8d 88 08 fd ff ff 	lea    -0x2f8(%rax),%rcx
ffffffff81017ecb:	48 85 c0             	test   %rax,%rax
ffffffff81017ece:	48 0f 45 d1          	cmovne %rcx,%rdx

            pd_del->quota.free_up(pd_to->quota);
ffffffff81017ed2:	48 8d aa 08 03 00 00 	lea    0x308(%rdx),%rbp
ffffffff81017ed9:	48 89 ee             	mov    %rbp,%rsi
ffffffff81017edc:	e8 e3 b6 fe ff       	callq  ffffffff810035c4 <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
ffffffff81017ee1:	48 89 ea             	mov    %rbp,%rdx
ffffffff81017ee4:	4c 89 e6             	mov    %r12,%rsi
ffffffff81017ee7:	48 c7 c7 d0 3f 16 81 	mov    $0xffffffff81163fd0,%rdi
ffffffff81017eee:	e8 77 db ff ff       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>

        pd->make_current();

        asm volatile ("mov %0," EXPAND(PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory");
ffffffff81017ef3:	48 8b 83 a0 00 00 00 	mov    0xa0(%rbx),%rax
ffffffff81017efa:	48 c7 c4 00 e0 ff bf 	mov    $0xffffffffbfffe000,%rsp
ffffffff81017f01:	ff e0                	jmpq   *%rax
        ec->make_current();
    }

    ec->help (send_msg<C>);
ffffffff81017f03:	48 c7 c6 42 7c 01 81 	mov    $0xffffffff81017c42,%rsi
ffffffff81017f0a:	48 89 df             	mov    %rbx,%rdi
ffffffff81017f0d:	e8 da 37 ff ff       	callq  ffffffff8100b6ec <_ZN2Ec4helpEPFvvE>

    die ("IPC Timeout");
ffffffff81017f12:	48 8b 05 ef 70 fe 3e 	mov    0x3efe70ef(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81017f19:	48 c7 c7 27 0d 02 81 	mov    $0xffffffff81020d27,%rdi
ffffffff81017f20:	48 8d b0 a8 00 00 00 	lea    0xa8(%rax),%rsi
ffffffff81017f27:	e9 7e fd ff ff       	jmpq   ffffffff81017caa <_ZN2Ec8send_msgIXadL_ZNS_13ret_user_iretEvEEEEvv+0x68>

ffffffff81017f2c <_ZN2Ec10sys_finishILN8Sys_regs6StatusE2ELb0EEEvv>:
#include "syscall.hpp"
#include "utcb.hpp"
#include "vectors.hpp"

template <Sys_regs::Status S, bool T>
void Ec::sys_finish()
ffffffff81017f2c:	53                   	push   %rbx
ffffffff81017f2d:	48 83 ec 10          	sub    $0x10,%rsp
{
    if (T)
        current->clr_timeout();

    current->regs.set_status (S);
ffffffff81017f31:	48 8b 05 d0 70 fe 3e 	mov    0x3efe70d0(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>

    if (current->xcpu_sm)
ffffffff81017f38:	48 83 b8 30 03 00 00 	cmpq   $0x0,0x330(%rax)
ffffffff81017f3f:	00 

        ALWAYS_INLINE
        inline void set_status (Status s, bool c = true)
        {
            if (c)
                ARG_1 = s;
ffffffff81017f40:	48 c7 80 e8 00 00 00 	movq   $0x2,0xe8(%rax)
ffffffff81017f47:	02 00 00 00 
ffffffff81017f4b:	74 05                	je     ffffffff81017f52 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE2ELb0EEEvv+0x26>
        xcpu_return();
ffffffff81017f4d:	e8 24 d4 fe ff       	callq  ffffffff81005376 <_ZN2Ec11xcpu_returnEv>

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
ffffffff81017f52:	48 8b 1d b7 70 fe 3e 	mov    0x3efe70b7(%rip),%rbx        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81017f59:	31 f6                	xor    %esi,%esi
ffffffff81017f5b:	48 8d bb 08 03 00 00 	lea    0x308(%rbx),%rdi
ffffffff81017f62:	e8 db f0 ff ff       	callq  ffffffff81017042 <_ZN5Quota9hit_limitEm>
ffffffff81017f67:	84 c0                	test   %al,%al
ffffffff81017f69:	75 05                	jne    ffffffff81017f70 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE2ELb0EEEvv+0x44>
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());

    ret_user_sysexit();
ffffffff81017f6b:	e8 90 80 fe ff       	callq  ffffffff81000000 <_ZN2Ec16ret_user_sysexitEv>

    if (current->xcpu_sm)
        xcpu_return();

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());
ffffffff81017f70:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff81017f75:	8b 35 89 70 fe 3e    	mov    0x3efe7089(%rip),%esi        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81017f7b:	48 8b 8b 20 03 00 00 	mov    0x320(%rbx),%rcx
ffffffff81017f82:	48 8b 93 10 03 00 00 	mov    0x310(%rbx),%rdx
ffffffff81017f89:	48 c7 c7 7c 0c 02 81 	mov    $0xffffffff81020c7c,%rdi
ffffffff81017f90:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81017f96:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff81017f9c:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
ffffffff81017fa3:	48 0f 45 f0          	cmovne %rax,%rsi
ffffffff81017fa7:	31 c0                	xor    %eax,%eax
ffffffff81017fa9:	e8 de a0 fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff81017fae:	eb bb                	jmp    ffffffff81017f6b <_ZN2Ec10sys_finishILN8Sys_regs6StatusE2ELb0EEEvv+0x3f>

ffffffff81017fb0 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE1ELb0EEEvv>:
#include "syscall.hpp"
#include "utcb.hpp"
#include "vectors.hpp"

template <Sys_regs::Status S, bool T>
void Ec::sys_finish()
ffffffff81017fb0:	53                   	push   %rbx
ffffffff81017fb1:	48 83 ec 10          	sub    $0x10,%rsp
{
    if (T)
        current->clr_timeout();

    current->regs.set_status (S);
ffffffff81017fb5:	48 8b 05 4c 70 fe 3e 	mov    0x3efe704c(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>

    if (current->xcpu_sm)
ffffffff81017fbc:	48 83 b8 30 03 00 00 	cmpq   $0x0,0x330(%rax)
ffffffff81017fc3:	00 
ffffffff81017fc4:	48 c7 80 e8 00 00 00 	movq   $0x1,0xe8(%rax)
ffffffff81017fcb:	01 00 00 00 
ffffffff81017fcf:	74 05                	je     ffffffff81017fd6 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE1ELb0EEEvv+0x26>
        xcpu_return();
ffffffff81017fd1:	e8 a0 d3 fe ff       	callq  ffffffff81005376 <_ZN2Ec11xcpu_returnEv>

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
ffffffff81017fd6:	48 8b 1d 33 70 fe 3e 	mov    0x3efe7033(%rip),%rbx        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81017fdd:	31 f6                	xor    %esi,%esi
ffffffff81017fdf:	48 8d bb 08 03 00 00 	lea    0x308(%rbx),%rdi
ffffffff81017fe6:	e8 57 f0 ff ff       	callq  ffffffff81017042 <_ZN5Quota9hit_limitEm>
ffffffff81017feb:	84 c0                	test   %al,%al
ffffffff81017fed:	75 05                	jne    ffffffff81017ff4 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE1ELb0EEEvv+0x44>
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());

    ret_user_sysexit();
ffffffff81017fef:	e8 0c 80 fe ff       	callq  ffffffff81000000 <_ZN2Ec16ret_user_sysexitEv>

    if (current->xcpu_sm)
        xcpu_return();

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());
ffffffff81017ff4:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff81017ff9:	8b 35 05 70 fe 3e    	mov    0x3efe7005(%rip),%esi        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81017fff:	48 8b 8b 20 03 00 00 	mov    0x320(%rbx),%rcx
ffffffff81018006:	48 8b 93 10 03 00 00 	mov    0x310(%rbx),%rdx
ffffffff8101800d:	48 c7 c7 7c 0c 02 81 	mov    $0xffffffff81020c7c,%rdi
ffffffff81018014:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8101801a:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff81018020:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
ffffffff81018027:	48 0f 45 f0          	cmovne %rax,%rsi
ffffffff8101802b:	31 c0                	xor    %eax,%eax
ffffffff8101802d:	e8 5a a0 fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff81018032:	eb bb                	jmp    ffffffff81017fef <_ZN2Ec10sys_finishILN8Sys_regs6StatusE1ELb0EEEvv+0x3f>

ffffffff81018034 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>:
#include "syscall.hpp"
#include "utcb.hpp"
#include "vectors.hpp"

template <Sys_regs::Status S, bool T>
void Ec::sys_finish()
ffffffff81018034:	53                   	push   %rbx
ffffffff81018035:	48 83 ec 10          	sub    $0x10,%rsp
{
    if (T)
        current->clr_timeout();

    current->regs.set_status (S);
ffffffff81018039:	48 8b 05 c8 6f fe 3e 	mov    0x3efe6fc8(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>

    if (current->xcpu_sm)
ffffffff81018040:	48 83 b8 30 03 00 00 	cmpq   $0x0,0x330(%rax)
ffffffff81018047:	00 
ffffffff81018048:	48 c7 80 e8 00 00 00 	movq   $0x4,0xe8(%rax)
ffffffff8101804f:	04 00 00 00 
ffffffff81018053:	74 05                	je     ffffffff8101805a <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv+0x26>
        xcpu_return();
ffffffff81018055:	e8 1c d3 fe ff       	callq  ffffffff81005376 <_ZN2Ec11xcpu_returnEv>

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
ffffffff8101805a:	48 8b 1d af 6f fe 3e 	mov    0x3efe6faf(%rip),%rbx        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81018061:	31 f6                	xor    %esi,%esi
ffffffff81018063:	48 8d bb 08 03 00 00 	lea    0x308(%rbx),%rdi
ffffffff8101806a:	e8 d3 ef ff ff       	callq  ffffffff81017042 <_ZN5Quota9hit_limitEm>
ffffffff8101806f:	84 c0                	test   %al,%al
ffffffff81018071:	75 05                	jne    ffffffff81018078 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv+0x44>
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());

    ret_user_sysexit();
ffffffff81018073:	e8 88 7f fe ff       	callq  ffffffff81000000 <_ZN2Ec16ret_user_sysexitEv>

    if (current->xcpu_sm)
        xcpu_return();

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());
ffffffff81018078:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff8101807d:	8b 35 81 6f fe 3e    	mov    0x3efe6f81(%rip),%esi        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81018083:	48 8b 8b 20 03 00 00 	mov    0x320(%rbx),%rcx
ffffffff8101808a:	48 8b 93 10 03 00 00 	mov    0x310(%rbx),%rdx
ffffffff81018091:	48 c7 c7 7c 0c 02 81 	mov    $0xffffffff81020c7c,%rdi
ffffffff81018098:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8101809e:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff810180a4:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
ffffffff810180ab:	48 0f 45 f0          	cmovne %rax,%rsi
ffffffff810180af:	31 c0                	xor    %eax,%eax
ffffffff810180b1:	e8 d6 9f fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff810180b6:	eb bb                	jmp    ffffffff81018073 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv+0x3f>

ffffffff810180b8 <_ZN2Ec10sys_revokeEv>:

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_revoke()
{
ffffffff810180b8:	41 54                	push   %r12
ffffffff810180ba:	55                   	push   %rbp
ffffffff810180bb:	53                   	push   %rbx
ffffffff810180bc:	48 83 ec 10          	sub    $0x10,%rsp
    Sys_revoke *r = static_cast<Sys_revoke *>(current->sys_regs());
ffffffff810180c0:	48 8b 1d 41 6f fe 3e 	mov    0x3efe6f41(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>

    trace (TRACE_SYSCALL, "EC:%p SYS_REVOKE", current);

    Pd * pd = Pd::current;
ffffffff810180c7:	48 8b 2d 42 6f fe 3e 	mov    0x3efe6f42(%rip),%rbp        # ffffffffbffff010 <_ZN2Pd7currentE>

    if (current->cont != sys_revoke) {
ffffffff810180ce:	48 81 bb a0 00 00 00 	cmpq   $0xffffffff810180b8,0xa0(%rbx)
ffffffff810180d5:	b8 80 01 81 
ffffffff810180d9:	0f 84 a0 00 00 00    	je     ffffffff8101817f <_ZN2Ec10sys_revokeEv+0xc7>
        if (r->remote()) {
ffffffff810180df:	f6 83 e8 00 00 00 20 	testb  $0x20,0xe8(%rbx)
ffffffff810180e6:	74 7c                	je     ffffffff81018164 <_ZN2Ec10sys_revokeEv+0xac>
ffffffff810180e8:	48 8b 8b 10 01 00 00 	mov    0x110(%rbx),%rcx
ffffffff810180ef:	48 89 c8             	mov    %rcx,%rax
ffffffff810180f2:	25 ff ff ff 03       	and    $0x3ffffff,%eax
ffffffff810180f7:	48 8b 14 c5 00 00 00 	mov    -0x20000000(,%rax,8),%rdx
ffffffff810180fe:	e0 
ffffffff810180ff:	48 83 e2 e0          	and    $0xffffffffffffffe0,%rdx
ffffffff81018103:	48 85 d2             	test   %rdx,%rdx
ffffffff81018106:	48 89 d5             	mov    %rdx,%rbp
ffffffff81018109:	74 09                	je     ffffffff81018114 <_ZN2Ec10sys_revokeEv+0x5c>
            Capability cap = Space_obj::lookup (r->pd());
            if (EXPECT_FALSE (cap.obj()->type() != Kobject::PD)) {
ffffffff8101810b:	80 ba 88 00 00 00 00 	cmpb   $0x0,0x88(%rdx)
ffffffff81018112:	74 46                	je     ffffffff8101815a <_ZN2Ec10sys_revokeEv+0xa2>
                trace (TRACE_ERROR, "%s: Bad PD CAP (%#lx)", __func__, r->pd());
ffffffff81018114:	8b 15 ea 6e fe 3e    	mov    0x3efe6eea(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8101811a:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff8101811f:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81018123:	48 c7 c7 33 0d 02 81 	mov    $0xffffffff81020d33,%rdi
ffffffff8101812a:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81018130:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff81018136:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff8101813a:	48 c7 c2 78 11 02 81 	mov    $0xffffffff81021178,%rdx
ffffffff81018141:	31 c0                	xor    %eax,%eax
ffffffff81018143:	e8 44 9f fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
                sys_finish<Sys_regs::BAD_CAP>();
ffffffff81018148:	e8 e7 fe ff ff       	callq  ffffffff81018034 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>
ffffffff8101814d:	8d 48 01             	lea    0x1(%rax),%ecx
ffffffff81018150:	f0 0f b1 8a 8c 00 00 	lock cmpxchg %ecx,0x8c(%rdx)
ffffffff81018157:	00 
ffffffff81018158:	74 0a                	je     ffffffff81018164 <_ZN2Ec10sys_revokeEv+0xac>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff8101815a:	8b 82 8c 00 00 00    	mov    0x8c(%rdx),%eax
ffffffff81018160:	85 c0                	test   %eax,%eax
ffffffff81018162:	75 e9                	jne    ffffffff8101814d <_ZN2Ec10sys_revokeEv+0x95>
            }
            pd = static_cast<Pd *>(cap.obj());
            pd->add_ref();
        }
        current->cont = sys_revoke;
ffffffff81018164:	48 8b 05 9d 6e fe 3e 	mov    0x3efe6e9d(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8101816b:	48 c7 80 a0 00 00 00 	movq   $0xffffffff810180b8,0xa0(%rax)
ffffffff81018172:	b8 80 01 81 
        inline mword pd() const { return ARG_3; }

        ALWAYS_INLINE
        inline mword sm() const { return ARG_1 >> 8; }

        inline void rem(Pd * p) { ARG_3 = reinterpret_cast<mword>(p); }
ffffffff81018176:	48 89 ab 10 01 00 00 	mov    %rbp,0x110(%rbx)
ffffffff8101817d:	eb 07                	jmp    ffffffff81018186 <_ZN2Ec10sys_revokeEv+0xce>

        r->rem(pd);
    } else
        pd = reinterpret_cast<Pd *>(r->pd());
ffffffff8101817f:	48 8b ab 10 01 00 00 	mov    0x110(%rbx),%rbp
            BAD_DEV,
            QUO_OOM,
        };

        ALWAYS_INLINE
        inline unsigned flags() const { return ARG_1 >> 4 & 0xf; }
ffffffff81018186:	48 8b 93 e8 00 00 00 	mov    0xe8(%rbx),%rdx
ffffffff8101818d:	48 8b b3 f0 00 00 00 	mov    0xf0(%rbx),%rsi

    pd->rev_crd (r->crd(), r->self(), true, r->keep());
ffffffff81018194:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff81018199:	48 89 ef             	mov    %rbp,%rdi
ffffffff8101819c:	48 c1 ea 04          	shr    $0x4,%rdx

        ALWAYS_INLINE
        inline bool remote() const { return flags() & 0x2; }

        ALWAYS_INLINE
        inline bool keep() const { return flags() & 0x4; }
ffffffff810181a0:	41 89 d0             	mov    %edx,%r8d
    public:
        ALWAYS_INLINE
        inline Crd crd() const { return Crd (ARG_2); }

        ALWAYS_INLINE
        inline bool self() const { return flags() & 0x1; }
ffffffff810181a3:	83 e2 01             	and    $0x1,%edx

        ALWAYS_INLINE
        inline bool remote() const { return flags() & 0x2; }

        ALWAYS_INLINE
        inline bool keep() const { return flags() & 0x4; }
ffffffff810181a6:	41 c1 e8 02          	shr    $0x2,%r8d
ffffffff810181aa:	41 83 e0 01          	and    $0x1,%r8d
ffffffff810181ae:	e8 5b 90 ff ff       	callq  ffffffff8101120e <_ZN2Pd7rev_crdE3Crdbbb>

    current->cont = sys_finish<Sys_regs::SUCCESS>;
ffffffff810181b3:	48 8b 05 4e 6e fe 3e 	mov    0x3efe6e4e(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff810181ba:	48 c7 80 a0 00 00 00 	movq   $0xffffffff81017058,0xa0(%rax)
ffffffff810181c1:	58 70 01 81 
    r->rem(nullptr);

    if (r->remote() && pd->del_ref()) {
ffffffff810181c5:	f6 83 e8 00 00 00 20 	testb  $0x20,0xe8(%rbx)
        inline mword pd() const { return ARG_3; }

        ALWAYS_INLINE
        inline mword sm() const { return ARG_1 >> 8; }

        inline void rem(Pd * p) { ARG_3 = reinterpret_cast<mword>(p); }
ffffffff810181cc:	48 c7 83 10 01 00 00 	movq   $0x0,0x110(%rbx)
ffffffff810181d3:	00 00 00 00 
ffffffff810181d7:	0f 84 8a 00 00 00    	je     ffffffff81018267 <_ZN2Ec10sys_revokeEv+0x1af>
        }

        ALWAYS_INLINE
        inline bool del_ref()
        {
            return Atomic::sub (ref, 1U) == 0;
ffffffff810181dd:	48 8d 95 8c 00 00 00 	lea    0x8c(%rbp),%rdx
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff810181e4:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff810181e7:	f0 0f c1 02          	lock xadd %eax,(%rdx)
ffffffff810181eb:	ff c8                	dec    %eax
ffffffff810181ed:	75 78                	jne    ffffffff81018267 <_ZN2Ec10sys_revokeEv+0x1af>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff810181ef:	8b 85 8c 00 00 00    	mov    0x8c(%rbp),%eax
ffffffff810181f5:	85 c0                	test   %eax,%eax
ffffffff810181f7:	74 09                	je     ffffffff81018202 <_ZN2Ec10sys_revokeEv+0x14a>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff810181f9:	8d 48 01             	lea    0x1(%rax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff810181fc:	f0 0f b1 0a          	lock cmpxchg %ecx,(%rdx)
ffffffff81018200:	75 ed                	jne    ffffffff810181ef <_ZN2Ec10sys_revokeEv+0x137>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
ffffffff81018202:	48 8b 45 28          	mov    0x28(%rbp),%rax
        pd->add_ref();
        Rcu::call(pd);
ffffffff81018206:	4c 8d 65 18          	lea    0x18(%rbp),%r12
ffffffff8101820a:	48 85 c0             	test   %rax,%rax
ffffffff8101820d:	74 05                	je     ffffffff81018214 <_ZN2Ec10sys_revokeEv+0x15c>
                e->pre_func(e);
ffffffff8101820f:	4c 89 e7             	mov    %r12,%rdi
ffffffff81018212:	ff d0                	callq  *%rax
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
ffffffff81018214:	48 83 7d 18 00       	cmpq   $0x0,0x18(%rbp)
ffffffff81018219:	75 0c                	jne    ffffffff81018227 <_ZN2Ec10sys_revokeEv+0x16f>
ffffffff8101821b:	48 8b 05 46 76 fe 3e 	mov    0x3efe7646(%rip),%rax        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff81018222:	4c 39 e0             	cmp    %r12,%rax
ffffffff81018225:	75 2f                	jne    ffffffff81018256 <_ZN2Ec10sys_revokeEv+0x19e>
                trace (0, "warning: rcu element already enqueued");
ffffffff81018227:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff8101822c:	8b 15 d2 6d fe 3e    	mov    0x3efe6dd2(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81018232:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81018236:	48 c7 c7 14 df 01 81 	mov    $0xffffffff8101df14,%rdi
ffffffff8101823d:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81018243:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff81018249:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff8101824d:	31 c0                	xor    %eax,%eax
ffffffff8101824f:	e8 38 9e fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff81018254:	eb 11                	jmp    ffffffff81018267 <_ZN2Ec10sys_revokeEv+0x1af>
                return;
            }

            count ++;
ffffffff81018256:	48 ff 05 13 76 fe 3e 	incq   0x3efe7613(%rip)        # ffffffffbffff870 <_ZN3Rcu4nextE+0x10>

           *tail = e;
ffffffff8101825d:	4c 89 20             	mov    %r12,(%rax)
            tail = &e->next;
ffffffff81018260:	4c 89 25 01 76 fe 3e 	mov    %r12,0x3efe7601(%rip)        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>

        ALWAYS_INLINE
        inline mword pd() const { return ARG_3; }

        ALWAYS_INLINE
        inline mword sm() const { return ARG_1 >> 8; }
ffffffff81018267:	48 8b 83 e8 00 00 00 	mov    0xe8(%rbx),%rax
    }

    if (EXPECT_FALSE (r->sm())) {
ffffffff8101826e:	48 c1 e8 08          	shr    $0x8,%rax
ffffffff81018272:	0f 84 4f 01 00 00    	je     ffffffff810183c7 <_ZN2Ec10sys_revokeEv+0x30f>
ffffffff81018278:	25 ff ff ff 03       	and    $0x3ffffff,%eax
        static unsigned const caps = (END_SPACE_LIM - SPC_LOCAL_OBJ) / sizeof (Capability);

        ALWAYS_INLINE
        static inline Capability lookup (unsigned long idx)
        {
            return *reinterpret_cast<Capability *>(idx_to_virt (idx));
ffffffff8101827d:	48 8b 04 c5 00 00 00 	mov    -0x20000000(,%rax,8),%rax
ffffffff81018284:	e0 
ffffffff81018285:	48 89 c3             	mov    %rax,%rbx
ffffffff81018288:	48 83 e3 e0          	and    $0xffffffffffffffe0,%rbx
ffffffff8101828c:	0f 84 35 01 00 00    	je     ffffffff810183c7 <_ZN2Ec10sys_revokeEv+0x30f>
        Capability cap_sm = Space_obj::lookup (r->sm());
        if (EXPECT_FALSE (cap_sm.obj()->type() == Kobject::SM && (cap_sm.prm() & 1))) {
ffffffff81018292:	80 bb 88 00 00 00 04 	cmpb   $0x4,0x88(%rbx)
ffffffff81018299:	0f 85 28 01 00 00    	jne    ffffffff810183c7 <_ZN2Ec10sys_revokeEv+0x30f>
ffffffff8101829f:	a8 01                	test   $0x1,%al
ffffffff810182a1:	0f 84 20 01 00 00    	je     ffffffff810183c7 <_ZN2Ec10sys_revokeEv+0x30f>
        }

        ALWAYS_INLINE
        inline void add_to_rcu()
        {
            Lock_guard <Spinlock> guard (lock);
ffffffff810182a7:	48 8d bb 8a 00 00 00 	lea    0x8a(%rbx),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff810182ae:	9c                   	pushfq 
ffffffff810182af:	58                   	pop    %rax
            return flags & 0x200;
ffffffff810182b0:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff810182b4:	41 88 c4             	mov    %al,%r12b
ffffffff810182b7:	41 80 e4 01          	and    $0x1,%r12b
ffffffff810182bb:	74 30                	je     ffffffff810182ed <_ZN2Ec10sys_revokeEv+0x235>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff810182bd:	80 3d 6c 74 fe 3e 00 	cmpb   $0x0,0x3efe746c(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff810182c4:	75 1f                	jne    ffffffff810182e5 <_ZN2Ec10sys_revokeEv+0x22d>
ffffffff810182c6:	49 c7 c0 f0 12 02 81 	mov    $0xffffffff810212f0,%r8
ffffffff810182cd:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff810182d2:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff810182d9:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff810182e0:	e9 cc 00 00 00       	jmpq   ffffffff810183b1 <_ZN2Ec10sys_revokeEv+0x2f9>

            asm volatile ("cli" : : : "memory");
ffffffff810182e5:	fa                   	cli    
            preemption = false;
ffffffff810182e6:	c6 05 43 74 fe 3e 00 	movb   $0x0,0x3efe7443(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff810182ed:	e8 9c 8b fe ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
        }

        ALWAYS_INLINE
        inline void call_rcu(bool r = false)
        {
            if (ACCESS_ONCE(rcu))
ffffffff810182f2:	8a 83 c8 00 00 00    	mov    0xc8(%rbx),%al
ffffffff810182f8:	84 c0                	test   %al,%al
ffffffff810182fa:	0f 85 83 00 00 00    	jne    ffffffff81018383 <_ZN2Ec10sys_revokeEv+0x2cb>
                return;

            rcu = true;
ffffffff81018300:	c6 83 c8 00 00 00 01 	movb   $0x1,0xc8(%rbx)
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff81018307:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff8101830d:	85 c0                	test   %eax,%eax
ffffffff8101830f:	74 0d                	je     ffffffff8101831e <_ZN2Ec10sys_revokeEv+0x266>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff81018311:	8d 50 01             	lea    0x1(%rax),%edx
ffffffff81018314:	f0 0f b1 93 8c 00 00 	lock cmpxchg %edx,0x8c(%rbx)
ffffffff8101831b:	00 
ffffffff8101831c:	75 e9                	jne    ffffffff81018307 <_ZN2Ec10sys_revokeEv+0x24f>
        static void invoke_batch();

    public:
        ALWAYS_INLINE
        static inline void call (Rcu_elem *e) {
            if (e->pre_func)
ffffffff8101831e:	48 8b 43 28          	mov    0x28(%rbx),%rax

            if (r)
                add_ref();

            Rcu::call (this);
ffffffff81018322:	48 8d 6b 18          	lea    0x18(%rbx),%rbp
ffffffff81018326:	48 85 c0             	test   %rax,%rax
ffffffff81018329:	74 05                	je     ffffffff81018330 <_ZN2Ec10sys_revokeEv+0x278>
                e->pre_func(e);
ffffffff8101832b:	48 89 ef             	mov    %rbp,%rdi
ffffffff8101832e:	ff d0                	callq  *%rax
        }

        ALWAYS_INLINE
        inline void enqueue (Rcu_elem *e)
        {
            if (e->next || tail == &e->next) {
ffffffff81018330:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
ffffffff81018335:	75 0c                	jne    ffffffff81018343 <_ZN2Ec10sys_revokeEv+0x28b>
ffffffff81018337:	48 8b 05 2a 75 fe 3e 	mov    0x3efe752a(%rip),%rax        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff8101833e:	48 39 e8             	cmp    %rbp,%rax
ffffffff81018341:	75 2f                	jne    ffffffff81018372 <_ZN2Ec10sys_revokeEv+0x2ba>
                trace (0, "warning: rcu element already enqueued");
ffffffff81018343:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff81018348:	8b 15 b6 6c fe 3e    	mov    0x3efe6cb6(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8101834e:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81018352:	48 c7 c7 14 df 01 81 	mov    $0xffffffff8101df14,%rdi
ffffffff81018359:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8101835f:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff81018365:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff81018369:	31 c0                	xor    %eax,%eax
ffffffff8101836b:	e8 1c 9d fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff81018370:	eb 11                	jmp    ffffffff81018383 <_ZN2Ec10sys_revokeEv+0x2cb>
                return;
            }

            count ++;
ffffffff81018372:	48 ff 05 f7 74 fe 3e 	incq   0x3efe74f7(%rip)        # ffffffffbffff870 <_ZN3Rcu4nextE+0x10>

           *tail = e;
ffffffff81018379:	48 89 28             	mov    %rbp,(%rax)
            tail = &e->next;
ffffffff8101837c:	48 89 2d e5 74 fe 3e 	mov    %rbp,0x3efe74e5(%rip)        # ffffffffbffff868 <_ZN3Rcu4nextE+0x8>
ffffffff81018383:	fe 83 8a 00 00 00    	incb   0x8a(%rbx)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81018389:	45 84 e4             	test   %r12b,%r12b
ffffffff8101838c:	74 39                	je     ffffffff810183c7 <_ZN2Ec10sys_revokeEv+0x30f>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8101838e:	80 3d 9b 73 fe 3e 00 	cmpb   $0x0,0x3efe739b(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81018395:	74 28                	je     ffffffff810183bf <_ZN2Ec10sys_revokeEv+0x307>
ffffffff81018397:	49 c7 c0 c0 12 02 81 	mov    $0xffffffff810212c0,%r8
ffffffff8101839e:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff810183a3:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff810183aa:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff810183b1:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff810183b8:	31 c0                	xor    %eax,%eax
ffffffff810183ba:	e8 91 9b fe ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            preemption = true;
ffffffff810183bf:	c6 05 6a 73 fe 3e 01 	movb   $0x1,0x3efe736a(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff810183c6:	fb                   	sti    
            Sm *sm = static_cast<Sm *>(cap_sm.obj());
            sm->add_to_rcu();
        }
    }

    sys_finish<Sys_regs::SUCCESS>();
ffffffff810183c7:	e8 8c ec ff ff       	callq  ffffffff81017058 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb0EEEvv>

ffffffff810183cc <_ZN2Ec10sys_finishILN8Sys_regs6StatusE9ELb0EEEvv>:
#include "syscall.hpp"
#include "utcb.hpp"
#include "vectors.hpp"

template <Sys_regs::Status S, bool T>
void Ec::sys_finish()
ffffffff810183cc:	50                   	push   %rax
{
    if (T)
        current->clr_timeout();

    current->regs.set_status (S);
ffffffff810183cd:	48 8b 05 34 6c fe 3e 	mov    0x3efe6c34(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>

    if (current->xcpu_sm)
ffffffff810183d4:	48 83 b8 30 03 00 00 	cmpq   $0x0,0x330(%rax)
ffffffff810183db:	00 

        ALWAYS_INLINE
        inline void set_status (Status s, bool c = true)
        {
            if (c)
                ARG_1 = s;
ffffffff810183dc:	48 c7 80 e8 00 00 00 	movq   $0x9,0xe8(%rax)
ffffffff810183e3:	09 00 00 00 
ffffffff810183e7:	74 05                	je     ffffffff810183ee <_ZN2Ec10sys_finishILN8Sys_regs6StatusE9ELb0EEEvv+0x22>
        xcpu_return();
ffffffff810183e9:	e8 88 cf fe ff       	callq  ffffffff81005376 <_ZN2Ec11xcpu_returnEv>

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());

    ret_user_sysexit();
ffffffff810183ee:	e8 0d 7c fe ff       	callq  ffffffff81000000 <_ZN2Ec16ret_user_sysexitEv>
ffffffff810183f3:	90                   	nop

ffffffff810183f4 <_ZN2Ec13sys_create_ptEv>:

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_create_pt()
{
ffffffff810183f4:	41 57                	push   %r15
ffffffff810183f6:	41 56                	push   %r14
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
ffffffff810183f8:	31 f6                	xor    %esi,%esi

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_create_pt()
{
ffffffff810183fa:	41 55                	push   %r13
ffffffff810183fc:	41 54                	push   %r12
ffffffff810183fe:	55                   	push   %rbp
ffffffff810183ff:	53                   	push   %rbx
ffffffff81018400:	48 83 ec 28          	sub    $0x28,%rsp
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
ffffffff81018404:	48 8b 05 05 6c fe 3e 	mov    0x3efe6c05(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8101840b:	48 8d b8 08 03 00 00 	lea    0x308(%rax),%rdi
ffffffff81018412:	e8 2b ec ff ff       	callq  ffffffff81017042 <_ZN5Quota9hit_limitEm>
ffffffff81018417:	84 c0                	test   %al,%al
ffffffff81018419:	74 05                	je     ffffffff81018420 <_ZN2Ec13sys_create_ptEv+0x2c>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu (%lu)", __func__, __LINE__, Pd::current->quota.usage(), Pd::current->quota.limit(), r);

        if (Ec::current->pt_oom && call)
            Ec::current->oom_call_cpu (Ec::current->pt_oom, Ec::current->pt_oom->id, C, C);

        sys_finish<Sys_regs::QUO_OOM>();
ffffffff8101841b:	e8 ac ff ff ff       	callq  ffffffff810183cc <_ZN2Ec10sys_finishILN8Sys_regs6StatusE9ELb0EEEvv>

void Ec::sys_create_pt()
{
    check<sys_create_pt>(0, false);

    Sys_create_pt *r = static_cast<Sys_create_pt *>(current->sys_regs());
ffffffff81018420:	4c 8b 2d e1 6b fe 3e 	mov    0x3efe6be1(%rip),%r13        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81018427:	48 8d 5c 24 17       	lea    0x17(%rsp),%rbx
ffffffff8101842c:	49 8b 8d f0 00 00 00 	mov    0xf0(%r13),%rcx
{
    private:
        ALWAYS_INLINE
        static inline mword idx_to_virt (unsigned long idx)
        {
            return SPC_LOCAL_OBJ + (idx % caps) * sizeof (Capability);
ffffffff81018433:	48 89 c8             	mov    %rcx,%rax
ffffffff81018436:	25 ff ff ff 03       	and    $0x3ffffff,%eax
        static unsigned const caps = (END_SPACE_LIM - SPC_LOCAL_OBJ) / sizeof (Capability);

        ALWAYS_INLINE
        static inline Capability lookup (unsigned long idx)
        {
            return *reinterpret_cast<Capability *>(idx_to_virt (idx));
ffffffff8101843b:	48 8b 04 c5 00 00 00 	mov    -0x20000000(,%rax,8),%rax
ffffffff81018442:	e0 
ffffffff81018443:	48 89 c5             	mov    %rax,%rbp
ffffffff81018446:	48 83 e5 e0          	and    $0xffffffffffffffe0,%rbp
ffffffff8101844a:	74 0d                	je     ffffffff81018459 <_ZN2Ec13sys_create_ptEv+0x65>

    trace (TRACE_SYSCALL, "EC:%p SYS_CREATE PT:%#lx EC:%#lx EIP:%#lx", current, r->sel(), r->ec(), r->eip());

    Capability cap = Space_obj::lookup (r->pd());
    if (EXPECT_FALSE (cap.obj()->type() != Kobject::PD) || !(cap.prm() & 1UL << Kobject::PT)) {
ffffffff8101844c:	80 bd 88 00 00 00 00 	cmpb   $0x0,0x88(%rbp)
ffffffff81018453:	75 04                	jne    ffffffff81018459 <_ZN2Ec13sys_create_ptEv+0x65>
ffffffff81018455:	a8 08                	test   $0x8,%al
ffffffff81018457:	75 2c                	jne    ffffffff81018485 <_ZN2Ec13sys_create_ptEv+0x91>
        trace (TRACE_ERROR, "%s: Non-PD CAP (%#lx)", __func__, r->pd());
ffffffff81018459:	8b 05 a5 6b fe 3e    	mov    0x3efe6ba5(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8101845f:	48 81 e3 00 f0 ff ff 	and    $0xfffffffffffff000,%rbx
ffffffff81018466:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff8101846a:	48 81 fb 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rbx
ffffffff81018471:	48 c7 c2 98 11 02 81 	mov    $0xffffffff81021198,%rdx
ffffffff81018478:	48 c7 c7 50 0d 02 81 	mov    $0xffffffff81020d50,%rdi
ffffffff8101847f:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff81018483:	eb 74                	jmp    ffffffff810184f9 <_ZN2Ec13sys_create_ptEv+0x105>
        sys_finish<Sys_regs::BAD_CAP>();
    }
    Pd *pd = static_cast<Pd *>(cap.obj());

    if (pd->quota.hit_limit(2)) {
ffffffff81018485:	48 81 c5 08 03 00 00 	add    $0x308,%rbp
ffffffff8101848c:	be 02 00 00 00       	mov    $0x2,%esi
ffffffff81018491:	48 89 ef             	mov    %rbp,%rdi
ffffffff81018494:	e8 a9 eb ff ff       	callq  ffffffff81017042 <_ZN5Quota9hit_limitEm>
ffffffff81018499:	84 c0                	test   %al,%al
ffffffff8101849b:	0f 85 7a ff ff ff    	jne    ffffffff8101841b <_ZN2Ec13sys_create_ptEv+0x27>
ffffffff810184a1:	49 8b 8d 10 01 00 00 	mov    0x110(%r13),%rcx
{
    private:
        ALWAYS_INLINE
        static inline mword idx_to_virt (unsigned long idx)
        {
            return SPC_LOCAL_OBJ + (idx % caps) * sizeof (Capability);
ffffffff810184a8:	48 89 c8             	mov    %rcx,%rax
ffffffff810184ab:	25 ff ff ff 03       	and    $0x3ffffff,%eax
        static unsigned const caps = (END_SPACE_LIM - SPC_LOCAL_OBJ) / sizeof (Capability);

        ALWAYS_INLINE
        static inline Capability lookup (unsigned long idx)
        {
            return *reinterpret_cast<Capability *>(idx_to_virt (idx));
ffffffff810184b0:	48 8b 04 c5 00 00 00 	mov    -0x20000000(,%rax,8),%rax
ffffffff810184b7:	e0 
ffffffff810184b8:	49 89 c7             	mov    %rax,%r15
ffffffff810184bb:	49 83 e7 e0          	and    $0xffffffffffffffe0,%r15
ffffffff810184bf:	74 0e                	je     ffffffff810184cf <_ZN2Ec13sys_create_ptEv+0xdb>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu", __func__, __LINE__, pd->quota.usage(), pd->quota.limit());
        sys_finish<Sys_regs::QUO_OOM>();
    }

    Capability cap_ec = Space_obj::lookup (r->ec());
    if (EXPECT_FALSE (cap_ec.obj()->type() != Kobject::EC) || !(cap_ec.prm() & 1UL << Kobject::PT)) {
ffffffff810184c1:	41 80 bf 88 00 00 00 	cmpb   $0x1,0x88(%r15)
ffffffff810184c8:	01 
ffffffff810184c9:	75 04                	jne    ffffffff810184cf <_ZN2Ec13sys_create_ptEv+0xdb>
ffffffff810184cb:	a8 08                	test   $0x8,%al
ffffffff810184cd:	75 36                	jne    ffffffff81018505 <_ZN2Ec13sys_create_ptEv+0x111>
        trace (TRACE_ERROR, "%s: Non-EC CAP (%#lx)", __func__, r->ec());
ffffffff810184cf:	8b 05 2f 6b fe 3e    	mov    0x3efe6b2f(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff810184d5:	48 81 e3 00 f0 ff ff 	and    $0xfffffffffffff000,%rbx
ffffffff810184dc:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff810184e0:	48 81 fb 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rbx
ffffffff810184e7:	48 c7 c2 98 11 02 81 	mov    $0xffffffff81021198,%rdx
ffffffff810184ee:	48 c7 c7 6d 0d 02 81 	mov    $0xffffffff81020d6d,%rdi
ffffffff810184f5:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff810184f9:	31 c0                	xor    %eax,%eax
ffffffff810184fb:	e8 8c 9b fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_CAP>();
ffffffff81018500:	e8 2f fb ff ff       	callq  ffffffff81018034 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>
    }
    Ec *ec = static_cast<Ec *>(cap_ec.obj());

    if (EXPECT_FALSE (ec->glb)) {
ffffffff81018505:	66 41 83 bf f2 02 00 	cmpw   $0x0,0x2f2(%r15)
ffffffff8101850c:	00 00 
ffffffff8101850e:	74 33                	je     ffffffff81018543 <_ZN2Ec13sys_create_ptEv+0x14f>
        trace (TRACE_ERROR, "%s: Cannot bind PT", __func__);
ffffffff81018510:	8b 05 ee 6a fe 3e    	mov    0x3efe6aee(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81018516:	48 81 e3 00 f0 ff ff 	and    $0xfffffffffffff000,%rbx
ffffffff8101851d:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81018521:	48 81 fb 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rbx
ffffffff81018528:	48 c7 c2 98 11 02 81 	mov    $0xffffffff81021198,%rdx
ffffffff8101852f:	48 c7 c7 8a 0d 02 81 	mov    $0xffffffff81020d8a,%rdi
ffffffff81018536:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff8101853a:	31 c0                	xor    %eax,%eax
ffffffff8101853c:	e8 4b 9b fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff81018541:	eb bd                	jmp    ffffffff81018500 <_ZN2Ec13sys_create_ptEv+0x10c>
        sys_finish<Sys_regs::BAD_CAP>();
    }

    Pt *pt = new (pd->quota) Pt (Pd::current, r->sel(), ec, r->mtd(), r->eip());
ffffffff81018543:	4d 8b 85 20 01 00 00 	mov    0x120(%r13),%r8
ffffffff8101854a:	4d 8b 8d e0 00 00 00 	mov    0xe0(%r13),%r9

        ALWAYS_INLINE
        inline void set_id (mword i) { id = i; }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
ffffffff81018551:	48 89 ee             	mov    %rbp,%rsi

class Sys_create_pt : public Sys_regs
{
    public:
        ALWAYS_INLINE
        inline unsigned long sel() const { return ARG_1 >> 8; }
ffffffff81018554:	4d 8b b5 e8 00 00 00 	mov    0xe8(%r13),%r14
ffffffff8101855b:	48 c7 c7 00 40 16 81 	mov    $0xffffffff81164000,%rdi
ffffffff81018562:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
ffffffff81018567:	4c 89 0c 24          	mov    %r9,(%rsp)
ffffffff8101856b:	e8 be d3 ff ff       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff81018570:	4c 8b 0c 24          	mov    (%rsp),%r9
ffffffff81018574:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
ffffffff81018579:	49 c1 ee 08          	shr    $0x8,%r14
ffffffff8101857d:	48 8b 35 8c 6a fe 3e 	mov    0x3efe6a8c(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81018584:	49 89 c4             	mov    %rax,%r12
ffffffff81018587:	48 89 c7             	mov    %rax,%rdi
ffffffff8101858a:	4c 89 f9             	mov    %r15,%rcx
ffffffff8101858d:	4c 89 f2             	mov    %r14,%rdx
ffffffff81018590:	e8 63 9c ff ff       	callq  ffffffff810121f8 <_ZN2PtC1EP2PdmP2Ec3Mtdm>
    if (!Space_obj::insert_root (pd->quota, pt)) {
ffffffff81018595:	4c 89 e6             	mov    %r12,%rsi
ffffffff81018598:	48 89 ef             	mov    %rbp,%rdi
ffffffff8101859b:	e8 ca e4 ff ff       	callq  ffffffff81016a6a <_ZN9Space_obj11insert_rootER5QuotaP7Kobject>
ffffffff810185a0:	84 c0                	test   %al,%al
ffffffff810185a2:	0f 85 a3 00 00 00    	jne    ffffffff8101864b <_ZN2Ec13sys_create_ptEv+0x257>
        trace (TRACE_ERROR, "%s: Non-NULL CAP (%#lx)", __func__, r->sel());
ffffffff810185a8:	8b 05 56 6a fe 3e    	mov    0x3efe6a56(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff810185ae:	49 8b 8d e8 00 00 00 	mov    0xe8(%r13),%rcx
ffffffff810185b5:	48 81 e3 00 f0 ff ff 	and    $0xfffffffffffff000,%rbx
ffffffff810185bc:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff810185c0:	48 c7 c2 98 11 02 81 	mov    $0xffffffff81021198,%rdx
ffffffff810185c7:	48 c7 c7 a4 0d 02 81 	mov    $0xffffffff81020da4,%rdi
ffffffff810185ce:	48 c1 e9 08          	shr    $0x8,%rcx
ffffffff810185d2:	48 81 fb 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rbx
ffffffff810185d9:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff810185dd:	31 c0                	xor    %eax,%eax
ffffffff810185df:	e8 a8 9a fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
        inline Refptr (T *p) : ptr (p->add_ref() ? p : nullptr) {}

        ALWAYS_INLINE
        inline ~Refptr()
        {
            if (ptr && ptr->del_ref())
ffffffff810185e4:	49 8b 84 24 90 00 00 	mov    0x90(%r12),%rax
ffffffff810185eb:	00 
ffffffff810185ec:	48 85 c0             	test   %rax,%rax
ffffffff810185ef:	74 43                	je     ffffffff81018634 <_ZN2Ec13sys_create_ptEv+0x240>
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff810185f1:	83 ca ff             	or     $0xffffffff,%edx
ffffffff810185f4:	f0 0f c1 90 8c 00 00 	lock xadd %edx,0x8c(%rax)
ffffffff810185fb:	00 
ffffffff810185fc:	ff ca                	dec    %edx
ffffffff810185fe:	75 34                	jne    ffffffff81018634 <_ZN2Ec13sys_create_ptEv+0x240>
                delete ptr;
ffffffff81018600:	49 8b bc 24 90 00 00 	mov    0x90(%r12),%rdi
ffffffff81018607:	00 
ffffffff81018608:	48 85 ff             	test   %rdi,%rdi
ffffffff8101860b:	74 27                	je     ffffffff81018634 <_ZN2Ec13sys_create_ptEv+0x240>
ffffffff8101860d:	e8 2a be fe ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
ffffffff81018612:	49 8b b4 24 90 00 00 	mov    0x90(%r12),%rsi
ffffffff81018619:	00 
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff8101861a:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff81018621:	48 8b 86 98 02 00 00 	mov    0x298(%rsi),%rax
ffffffff81018628:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff8101862f:	e8 36 d4 ff ff       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>

        ALWAYS_INLINE
        static inline void destroy(Pt *obj, Quota &quota) { obj->~Pt(); cache.free (obj, quota); }
ffffffff81018634:	48 89 ea             	mov    %rbp,%rdx
ffffffff81018637:	4c 89 e6             	mov    %r12,%rsi
ffffffff8101863a:	48 c7 c7 00 40 16 81 	mov    $0xffffffff81164000,%rdi
ffffffff81018641:	e8 24 d4 ff ff       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
ffffffff81018646:	e9 b5 fe ff ff       	jmpq   ffffffff81018500 <_ZN2Ec13sys_create_ptEv+0x10c>
        Pt::destroy (pt, pd->quota);
        sys_finish<Sys_regs::BAD_CAP>();
    }

    sys_finish<Sys_regs::SUCCESS>();
ffffffff8101864b:	e8 08 ea ff ff       	callq  ffffffff81017058 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb0EEEvv>

ffffffff81018650 <_ZN2Ec13sys_create_smEv>:
}

void Ec::sys_create_sm()
{
ffffffff81018650:	41 56                	push   %r14
ffffffff81018652:	41 55                	push   %r13
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
ffffffff81018654:	31 f6                	xor    %esi,%esi

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_create_sm()
{
ffffffff81018656:	41 54                	push   %r12
ffffffff81018658:	55                   	push   %rbp
ffffffff81018659:	53                   	push   %rbx
ffffffff8101865a:	48 83 ec 20          	sub    $0x20,%rsp
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
ffffffff8101865e:	48 8b 05 ab 69 fe 3e 	mov    0x3efe69ab(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81018665:	48 8d b8 08 03 00 00 	lea    0x308(%rax),%rdi
ffffffff8101866c:	e8 d1 e9 ff ff       	callq  ffffffff81017042 <_ZN5Quota9hit_limitEm>
ffffffff81018671:	84 c0                	test   %al,%al
ffffffff81018673:	74 05                	je     ffffffff8101867a <_ZN2Ec13sys_create_smEv+0x2a>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu (%lu)", __func__, __LINE__, Pd::current->quota.usage(), Pd::current->quota.limit(), r);

        if (Ec::current->pt_oom && call)
            Ec::current->oom_call_cpu (Ec::current->pt_oom, Ec::current->pt_oom->id, C, C);

        sys_finish<Sys_regs::QUO_OOM>();
ffffffff81018675:	e8 52 fd ff ff       	callq  ffffffff810183cc <_ZN2Ec10sys_finishILN8Sys_regs6StatusE9ELb0EEEvv>

void Ec::sys_create_sm()
{
    check<sys_create_sm>(0, false);

    Sys_create_sm *r = static_cast<Sys_create_sm *>(current->sys_regs());
ffffffff8101867a:	48 8b 2d 87 69 fe 3e 	mov    0x3efe6987(%rip),%rbp        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81018681:	48 8b 8d f0 00 00 00 	mov    0xf0(%rbp),%rcx
{
    private:
        ALWAYS_INLINE
        static inline mword idx_to_virt (unsigned long idx)
        {
            return SPC_LOCAL_OBJ + (idx % caps) * sizeof (Capability);
ffffffff81018688:	48 89 c8             	mov    %rcx,%rax
ffffffff8101868b:	25 ff ff ff 03       	and    $0x3ffffff,%eax
        static unsigned const caps = (END_SPACE_LIM - SPC_LOCAL_OBJ) / sizeof (Capability);

        ALWAYS_INLINE
        static inline Capability lookup (unsigned long idx)
        {
            return *reinterpret_cast<Capability *>(idx_to_virt (idx));
ffffffff81018690:	48 8b 04 c5 00 00 00 	mov    -0x20000000(,%rax,8),%rax
ffffffff81018697:	e0 
ffffffff81018698:	48 89 c3             	mov    %rax,%rbx
ffffffff8101869b:	48 83 e3 e0          	and    $0xffffffffffffffe0,%rbx
ffffffff8101869f:	74 0d                	je     ffffffff810186ae <_ZN2Ec13sys_create_smEv+0x5e>

    trace (TRACE_SYSCALL, "EC:%p SYS_CREATE SM:%#lx CNT:%lu", current, r->sel(), r->cnt());

    Capability cap = Space_obj::lookup (r->pd());
    if (EXPECT_FALSE (cap.obj()->type() != Kobject::PD) || !(cap.prm() & 1UL << Kobject::SM)) {
ffffffff810186a1:	80 bb 88 00 00 00 00 	cmpb   $0x0,0x88(%rbx)
ffffffff810186a8:	75 04                	jne    ffffffff810186ae <_ZN2Ec13sys_create_smEv+0x5e>
ffffffff810186aa:	a8 10                	test   $0x10,%al
ffffffff810186ac:	75 2f                	jne    ffffffff810186dd <_ZN2Ec13sys_create_smEv+0x8d>
        trace (TRACE_ERROR, "%s: Non-PD CAP (%#lx)", __func__, r->pd());
ffffffff810186ae:	8b 15 50 69 fe 3e    	mov    0x3efe6950(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff810186b4:	48 8d 44 24 17       	lea    0x17(%rsp),%rax
ffffffff810186b9:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff810186bd:	48 c7 c7 50 0d 02 81 	mov    $0xffffffff81020d50,%rdi
ffffffff810186c4:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff810186ca:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff810186d0:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff810186d4:	48 c7 c2 88 11 02 81 	mov    $0xffffffff81021188,%rdx
ffffffff810186db:	eb 75                	jmp    ffffffff81018752 <_ZN2Ec13sys_create_smEv+0x102>
        sys_finish<Sys_regs::BAD_CAP>();
    }
    Pd *pd = static_cast<Pd *>(cap.obj());

    if (pd->quota.hit_limit(1)) {
ffffffff810186dd:	48 81 c3 08 03 00 00 	add    $0x308,%rbx
ffffffff810186e4:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff810186e9:	48 89 df             	mov    %rbx,%rdi
ffffffff810186ec:	e8 51 e9 ff ff       	callq  ffffffff81017042 <_ZN5Quota9hit_limitEm>
ffffffff810186f1:	84 c0                	test   %al,%al
ffffffff810186f3:	75 80                	jne    ffffffff81018675 <_ZN2Ec13sys_create_smEv+0x25>
ffffffff810186f5:	48 8b 8d 20 01 00 00 	mov    0x120(%rbp),%rcx
        sys_finish<Sys_regs::QUO_OOM>();
    }

    Sm * sm;

    if (r->sm()) {
ffffffff810186fc:	48 85 c9             	test   %rcx,%rcx
ffffffff810186ff:	0f 84 cc 00 00 00    	je     ffffffff810187d1 <_ZN2Ec13sys_create_smEv+0x181>
{
    private:
        ALWAYS_INLINE
        static inline mword idx_to_virt (unsigned long idx)
        {
            return SPC_LOCAL_OBJ + (idx % caps) * sizeof (Capability);
ffffffff81018705:	48 89 c8             	mov    %rcx,%rax
ffffffff81018708:	25 ff ff ff 03       	and    $0x3ffffff,%eax
ffffffff8101870d:	4c 8b 04 c5 00 00 00 	mov    -0x20000000(,%rax,8),%r8
ffffffff81018714:	e0 
ffffffff81018715:	49 83 e0 e0          	and    $0xffffffffffffffe0,%r8
ffffffff81018719:	74 0a                	je     ffffffff81018725 <_ZN2Ec13sys_create_smEv+0xd5>
        /* check for valid SM to be chained with */
        Capability cap_si = Space_obj::lookup (r->sm());
        if (EXPECT_FALSE (cap_si.obj()->type() != Kobject::SM)) {
ffffffff8101871b:	41 80 b8 88 00 00 00 	cmpb   $0x4,0x88(%r8)
ffffffff81018722:	04 
ffffffff81018723:	74 39                	je     ffffffff8101875e <_ZN2Ec13sys_create_smEv+0x10e>
            trace (TRACE_ERROR, "%s: Non-SM CAP (%#lx)", __func__, r->sm());
ffffffff81018725:	8b 15 d9 68 fe 3e    	mov    0x3efe68d9(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8101872b:	48 8d 44 24 17       	lea    0x17(%rsp),%rax
ffffffff81018730:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81018734:	48 c7 c7 c3 0d 02 81 	mov    $0xffffffff81020dc3,%rdi
ffffffff8101873b:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81018741:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff81018747:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff8101874b:	48 c7 c2 88 11 02 81 	mov    $0xffffffff81021188,%rdx
ffffffff81018752:	31 c0                	xor    %eax,%eax
ffffffff81018754:	e8 33 99 fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
            sys_finish<Sys_regs::BAD_CAP>();
ffffffff81018759:	e8 d6 f8 ff ff       	callq  ffffffff81018034 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>
        }

        Sm * si = static_cast<Sm *>(cap_si.obj());
        if (si->is_signal()) {
ffffffff8101875e:	49 83 b8 a0 00 00 00 	cmpq   $0x0,0xa0(%r8)
ffffffff81018765:	00 
ffffffff81018766:	74 2f                	je     ffffffff81018797 <_ZN2Ec13sys_create_smEv+0x147>
            /* limit chaining to solely one level */
            trace (TRACE_ERROR, "%s: SM CAP (%#lx) is signal", __func__, r->sm());
ffffffff81018768:	8b 15 96 68 fe 3e    	mov    0x3efe6896(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8101876e:	48 8d 44 24 17       	lea    0x17(%rsp),%rax
ffffffff81018773:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81018777:	48 c7 c7 e0 0d 02 81 	mov    $0xffffffff81020de0,%rdi
ffffffff8101877e:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81018784:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff8101878a:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff8101878e:	48 c7 c2 88 11 02 81 	mov    $0xffffffff81021188,%rdx
ffffffff81018795:	eb bb                	jmp    ffffffff81018752 <_ZN2Ec13sys_create_smEv+0x102>
ffffffff81018797:	4c 8b 8d 10 01 00 00 	mov    0x110(%rbp),%r9

class Sys_create_sm : public Sys_regs
{
    public:
        ALWAYS_INLINE
        inline unsigned long sel() const { return ARG_1 >> 8; }
ffffffff8101879e:	4c 8b ad e8 00 00 00 	mov    0xe8(%rbp),%r13

            call_rcu(true);
        }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
ffffffff810187a5:	48 89 de             	mov    %rbx,%rsi
ffffffff810187a8:	48 c7 c7 80 40 16 81 	mov    $0xffffffff81164080,%rdi
ffffffff810187af:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
ffffffff810187b4:	4c 89 0c 24          	mov    %r9,(%rsp)
ffffffff810187b8:	49 c1 ed 08          	shr    $0x8,%r13
ffffffff810187bc:	e8 6d d1 ff ff       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
            sys_finish<Sys_regs::BAD_CAP>();
        }

        sm = new (pd->quota) Sm (Pd::current, r->sel(), 0, si, r->cnt());
ffffffff810187c1:	4c 8b 0c 24          	mov    (%rsp),%r9
ffffffff810187c5:	49 89 c4             	mov    %rax,%r12
ffffffff810187c8:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
ffffffff810187cd:	31 c9                	xor    %ecx,%ecx
ffffffff810187cf:	eb 2d                	jmp    ffffffff810187fe <_ZN2Ec13sys_create_smEv+0x1ae>
ffffffff810187d1:	4c 8b ad e8 00 00 00 	mov    0xe8(%rbp),%r13
ffffffff810187d8:	4c 8b b5 10 01 00 00 	mov    0x110(%rbp),%r14
ffffffff810187df:	48 89 de             	mov    %rbx,%rsi
ffffffff810187e2:	48 c7 c7 80 40 16 81 	mov    $0xffffffff81164080,%rdi
ffffffff810187e9:	e8 40 d1 ff ff       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff810187ee:	49 c1 ed 08          	shr    $0x8,%r13
ffffffff810187f2:	49 89 c4             	mov    %rax,%r12
    } else
        sm = new (pd->quota) Sm (Pd::current, r->sel(), r->cnt());
ffffffff810187f5:	45 31 c9             	xor    %r9d,%r9d
ffffffff810187f8:	45 31 c0             	xor    %r8d,%r8d
ffffffff810187fb:	4c 89 f1             	mov    %r14,%rcx
ffffffff810187fe:	48 8b 35 0b 68 fe 3e 	mov    0x3efe680b(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81018805:	4c 89 ea             	mov    %r13,%rdx
ffffffff81018808:	4c 89 e7             	mov    %r12,%rdi
ffffffff8101880b:	e8 52 d7 ff ff       	callq  ffffffff81015f62 <_ZN2SmC1EP2PdmmPS_m>

    if (!Space_obj::insert_root (pd->quota, sm)) {
ffffffff81018810:	4c 89 e6             	mov    %r12,%rsi
ffffffff81018813:	48 89 df             	mov    %rbx,%rdi
ffffffff81018816:	e8 4f e2 ff ff       	callq  ffffffff81016a6a <_ZN9Space_obj11insert_rootER5QuotaP7Kobject>
ffffffff8101881b:	84 c0                	test   %al,%al
ffffffff8101881d:	75 5e                	jne    ffffffff8101887d <_ZN2Ec13sys_create_smEv+0x22d>
ffffffff8101881f:	48 8b 8d e8 00 00 00 	mov    0xe8(%rbp),%rcx
        trace (TRACE_ERROR, "%s: Non-NULL CAP (%#lx)", __func__, r->sel());
ffffffff81018826:	8b 15 d8 67 fe 3e    	mov    0x3efe67d8(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8101882c:	48 8d 44 24 17       	lea    0x17(%rsp),%rax
ffffffff81018831:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81018835:	48 c7 c7 a4 0d 02 81 	mov    $0xffffffff81020da4,%rdi
ffffffff8101883c:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81018842:	48 c1 e9 08          	shr    $0x8,%rcx
ffffffff81018846:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff8101884c:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff81018850:	48 c7 c2 88 11 02 81 	mov    $0xffffffff81021188,%rdx
ffffffff81018857:	31 c0                	xor    %eax,%eax
ffffffff81018859:	e8 2e 98 fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>

        ALWAYS_INLINE
        static inline void destroy(Sm *obj, Quota &quota) { obj->~Sm(); cache.free (obj, quota); }
ffffffff8101885e:	4c 89 e7             	mov    %r12,%rdi
ffffffff81018861:	e8 5a 30 ff ff       	callq  ffffffff8100b8c0 <_ZN2SmD1Ev>
ffffffff81018866:	48 89 da             	mov    %rbx,%rdx
ffffffff81018869:	4c 89 e6             	mov    %r12,%rsi
ffffffff8101886c:	48 c7 c7 80 40 16 81 	mov    $0xffffffff81164080,%rdi
ffffffff81018873:	e8 f2 d1 ff ff       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
ffffffff81018878:	e9 dc fe ff ff       	jmpq   ffffffff81018759 <_ZN2Ec13sys_create_smEv+0x109>
        Sm::destroy(sm, pd->quota);
        sys_finish<Sys_regs::BAD_CAP>();
    }

    sys_finish<Sys_regs::SUCCESS>();
ffffffff8101887d:	e8 d6 e7 ff ff       	callq  ffffffff81017058 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb0EEEvv>

ffffffff81018882 <_ZN2Ec10sys_lookupEv>:

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_lookup()
{
ffffffff81018882:	55                   	push   %rbp
ffffffff81018883:	53                   	push   %rbx
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
ffffffff81018884:	be 02 00 00 00       	mov    $0x2,%esi

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_lookup()
{
ffffffff81018889:	50                   	push   %rax
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
ffffffff8101888a:	48 8b 1d 7f 67 fe 3e 	mov    0x3efe677f(%rip),%rbx        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81018891:	48 8d bb 08 03 00 00 	lea    0x308(%rbx),%rdi
ffffffff81018898:	e8 a5 e7 ff ff       	callq  ffffffff81017042 <_ZN5Quota9hit_limitEm>
ffffffff8101889d:	84 c0                	test   %al,%al
ffffffff8101889f:	48 8b 2d 62 67 fe 3e 	mov    0x3efe6762(%rip),%rbp        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff810188a6:	74 2a                	je     ffffffff810188d2 <_ZN2Ec10sys_lookupEv+0x50>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu (%lu)", __func__, __LINE__, Pd::current->quota.usage(), Pd::current->quota.limit(), r);

        if (Ec::current->pt_oom && call)
ffffffff810188a8:	48 8b b5 38 03 00 00 	mov    0x338(%rbp),%rsi
ffffffff810188af:	48 85 f6             	test   %rsi,%rsi
ffffffff810188b2:	74 19                	je     ffffffff810188cd <_ZN2Ec10sys_lookupEv+0x4b>
            Ec::current->oom_call_cpu (Ec::current->pt_oom, Ec::current->pt_oom->id, C, C);
ffffffff810188b4:	48 8b 96 a8 00 00 00 	mov    0xa8(%rsi),%rdx
ffffffff810188bb:	49 c7 c0 82 88 01 81 	mov    $0xffffffff81018882,%r8
ffffffff810188c2:	48 89 ef             	mov    %rbp,%rdi
ffffffff810188c5:	4c 89 c1             	mov    %r8,%rcx
ffffffff810188c8:	e8 cd 72 ff ff       	callq  ffffffff8100fb9a <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_>

        sys_finish<Sys_regs::QUO_OOM>();
ffffffff810188cd:	e8 fa fa ff ff       	callq  ffffffff810183cc <_ZN2Ec10sys_finishILN8Sys_regs6StatusE9ELb0EEEvv>

        ALWAYS_INLINE
        inline explicit Crd (Type t, mword b = 0, mword o = 0x1f, mword a = 0x1f) : val (b << 12 | o << 7 | a << 2 | t) {}

        ALWAYS_INLINE
        inline Type type() const { return static_cast<Type>(val & 0x3); }
ffffffff810188d2:	48 8b b5 f0 00 00 00 	mov    0xf0(%rbp),%rsi
ffffffff810188d9:	89 f0                	mov    %esi,%eax
ffffffff810188db:	83 e0 03             	and    $0x3,%eax
        }

        ALWAYS_INLINE
        inline Space *subspace (Crd::Type t)
        {
            switch (t) {
ffffffff810188de:	83 f8 02             	cmp    $0x2,%eax
ffffffff810188e1:	74 12                	je     ffffffff810188f5 <_ZN2Ec10sys_lookupEv+0x73>
ffffffff810188e3:	83 f8 03             	cmp    $0x3,%eax
ffffffff810188e6:	74 16                	je     ffffffff810188fe <_ZN2Ec10sys_lookupEv+0x7c>
ffffffff810188e8:	ff c8                	dec    %eax
ffffffff810188ea:	75 2e                	jne    ffffffff8101891a <_ZN2Ec10sys_lookupEv+0x98>
                case Crd::MEM:  return static_cast<Space_mem *>(this);
ffffffff810188ec:	48 8d bb 90 00 00 00 	lea    0x90(%rbx),%rdi
ffffffff810188f3:	eb 10                	jmp    ffffffff81018905 <_ZN2Ec10sys_lookupEv+0x83>
                case Crd::PIO:  return static_cast<Space_pio *>(this);
ffffffff810188f5:	48 8d bb d8 02 00 00 	lea    0x2d8(%rbx),%rdi
ffffffff810188fc:	eb 07                	jmp    ffffffff81018905 <_ZN2Ec10sys_lookupEv+0x83>
                case Crd::OBJ:  return static_cast<Space_obj *>(this);
ffffffff810188fe:	48 8d bb f8 02 00 00 	lea    0x2f8(%rbx),%rdi
    Sys_lookup *s = static_cast<Sys_lookup *>(current->sys_regs());

    trace (TRACE_SYSCALL, "EC:%p SYS_LOOKUP T:%d B:%#lx", current, s->crd().type(), s->crd().base());

    Space *space; Mdb *mdb;
    if ((space = Pd::current->subspace (s->crd().type())) && (mdb = space->tree_lookup (s->crd().base())))
ffffffff81018905:	48 85 ff             	test   %rdi,%rdi
ffffffff81018908:	74 10                	je     ffffffff8101891a <_ZN2Ec10sys_lookupEv+0x98>

        ALWAYS_INLINE
        inline unsigned order() const { return val >> 7 & 0x1f; }

        ALWAYS_INLINE
        inline mword base() const { return val >> 12; }
ffffffff8101890a:	48 c1 ee 0c          	shr    $0xc,%rsi
ffffffff8101890e:	31 d2                	xor    %edx,%edx
ffffffff81018910:	e8 51 75 ff ff       	callq  ffffffff8100fe66 <_ZN5Space11tree_lookupEmb>
ffffffff81018915:	48 85 c0             	test   %rax,%rax
ffffffff81018918:	75 10                	jne    ffffffff8101892a <_ZN2Ec10sys_lookupEv+0xa8>
        s->crd() = Crd (s->crd().type(), mdb->node_base, mdb->node_order, mdb->node_attr);
    else
        s->crd() = Crd (0);
ffffffff8101891a:	48 c7 85 f0 00 00 00 	movq   $0x0,0xf0(%rbp)
ffffffff81018921:	00 00 00 00 

    sys_finish<Sys_regs::SUCCESS>();
ffffffff81018925:	e8 2e e7 ff ff       	callq  ffffffff81017058 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb0EEEvv>

        ALWAYS_INLINE
        inline explicit Crd (mword v) : val (v) {}

        ALWAYS_INLINE
        inline explicit Crd (Type t, mword b = 0, mword o = 0x1f, mword a = 0x1f) : val (b << 12 | o << 7 | a << 2 | t) {}
ffffffff8101892a:	48 8b 48 68          	mov    0x68(%rax),%rcx
ffffffff8101892e:	48 8b 50 60          	mov    0x60(%rax),%rdx
ffffffff81018932:	48 c1 e1 07          	shl    $0x7,%rcx
ffffffff81018936:	48 c1 e2 0c          	shl    $0xc,%rdx
ffffffff8101893a:	48 09 d1             	or     %rdx,%rcx
ffffffff8101893d:	48 8b 50 70          	mov    0x70(%rax),%rdx
ffffffff81018941:	48 89 c8             	mov    %rcx,%rax
ffffffff81018944:	48 c1 e2 02          	shl    $0x2,%rdx
ffffffff81018948:	48 09 d0             	or     %rdx,%rax
ffffffff8101894b:	48 8b 95 f0 00 00 00 	mov    0xf0(%rbp),%rdx
ffffffff81018952:	83 e2 03             	and    $0x3,%edx
ffffffff81018955:	48 09 d0             	or     %rdx,%rax
ffffffff81018958:	48 89 85 f0 00 00 00 	mov    %rax,0xf0(%rbp)
ffffffff8101895f:	eb c4                	jmp    ffffffff81018925 <_ZN2Ec10sys_lookupEv+0xa3>
ffffffff81018961:	90                   	nop

ffffffff81018962 <_ZN2Ec11sys_sc_ctrlEv>:

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_sc_ctrl()
{
ffffffff81018962:	48 83 ec 18          	sub    $0x18,%rsp
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
ffffffff81018966:	48 8b 05 a3 66 fe 3e 	mov    0x3efe66a3(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8101896d:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff81018972:	48 8d b8 08 03 00 00 	lea    0x308(%rax),%rdi
ffffffff81018979:	e8 c4 e6 ff ff       	callq  ffffffff81017042 <_ZN5Quota9hit_limitEm>
ffffffff8101897e:	84 c0                	test   %al,%al
ffffffff81018980:	48 8b 3d 81 66 fe 3e 	mov    0x3efe6681(%rip),%rdi        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81018987:	74 27                	je     ffffffff810189b0 <_ZN2Ec11sys_sc_ctrlEv+0x4e>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu (%lu)", __func__, __LINE__, Pd::current->quota.usage(), Pd::current->quota.limit(), r);

        if (Ec::current->pt_oom && call)
ffffffff81018989:	48 8b b7 38 03 00 00 	mov    0x338(%rdi),%rsi
ffffffff81018990:	48 85 f6             	test   %rsi,%rsi
ffffffff81018993:	74 16                	je     ffffffff810189ab <_ZN2Ec11sys_sc_ctrlEv+0x49>
            Ec::current->oom_call_cpu (Ec::current->pt_oom, Ec::current->pt_oom->id, C, C);
ffffffff81018995:	48 8b 96 a8 00 00 00 	mov    0xa8(%rsi),%rdx
ffffffff8101899c:	49 c7 c0 62 89 01 81 	mov    $0xffffffff81018962,%r8
ffffffff810189a3:	4c 89 c1             	mov    %r8,%rcx
ffffffff810189a6:	e8 ef 71 ff ff       	callq  ffffffff8100fb9a <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_>

        sys_finish<Sys_regs::QUO_OOM>();
ffffffff810189ab:	e8 1c fa ff ff       	callq  ffffffff810183cc <_ZN2Ec10sys_finishILN8Sys_regs6StatusE9ELb0EEEvv>

class Sys_sc_ctrl : public Sys_regs
{
    public:
        ALWAYS_INLINE
        inline unsigned long sc() const { return ARG_1 >> 8; }
ffffffff810189b0:	48 8b 8f e8 00 00 00 	mov    0xe8(%rdi),%rcx
ffffffff810189b7:	48 c1 e9 08          	shr    $0x8,%rcx
ffffffff810189bb:	48 89 c8             	mov    %rcx,%rax
ffffffff810189be:	25 ff ff ff 03       	and    $0x3ffffff,%eax
        static unsigned const caps = (END_SPACE_LIM - SPC_LOCAL_OBJ) / sizeof (Capability);

        ALWAYS_INLINE
        static inline Capability lookup (unsigned long idx)
        {
            return *reinterpret_cast<Capability *>(idx_to_virt (idx));
ffffffff810189c3:	48 8b 04 c5 00 00 00 	mov    -0x20000000(,%rax,8),%rax
ffffffff810189ca:	e0 
ffffffff810189cb:	48 89 c2             	mov    %rax,%rdx
ffffffff810189ce:	48 83 e2 e0          	and    $0xffffffffffffffe0,%rdx
ffffffff810189d2:	74 0d                	je     ffffffff810189e1 <_ZN2Ec11sys_sc_ctrlEv+0x7f>
    check<sys_sc_ctrl>(1);

    Sys_sc_ctrl *r = static_cast<Sys_sc_ctrl *>(current->sys_regs());

    Capability cap = Space_obj::lookup (r->sc());
    if (EXPECT_FALSE (cap.obj()->type() != Kobject::SC || !(cap.prm() & 1UL << 0))) {
ffffffff810189d4:	80 ba 88 00 00 00 02 	cmpb   $0x2,0x88(%rdx)
ffffffff810189db:	75 04                	jne    ffffffff810189e1 <_ZN2Ec11sys_sc_ctrlEv+0x7f>
ffffffff810189dd:	a8 01                	test   $0x1,%al
ffffffff810189df:	75 39                	jne    ffffffff81018a1a <_ZN2Ec11sys_sc_ctrlEv+0xb8>
        trace (TRACE_ERROR, "%s: Bad SC CAP (%#lx)", __func__, r->sc());
ffffffff810189e1:	8b 15 1d 66 fe 3e    	mov    0x3efe661d(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff810189e7:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff810189ec:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff810189f0:	48 c7 c7 03 0e 02 81 	mov    $0xffffffff81020e03,%rdi
ffffffff810189f7:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff810189fd:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff81018a03:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff81018a07:	48 c7 c2 58 11 02 81 	mov    $0xffffffff81021158,%rdx
ffffffff81018a0e:	31 c0                	xor    %eax,%eax
ffffffff81018a10:	e8 77 96 fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_CAP>();
ffffffff81018a15:	e8 1a f6 ff ff       	callq  ffffffff81018034 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>
    }

    uint32 dummy;
    r->set_time (div64 (static_cast<Sc *>(cap.obj())->time * 1000, Lapic::freq_tsc, &dummy));
ffffffff81018a1a:	48 69 82 a8 00 00 00 	imul   $0x3e8,0xa8(%rdx),%rax
ffffffff81018a21:	e8 03 00 00 
                  : "a"  (static_cast<uint32>(n >> 32)),
                    "d"  (0),
                    "1"  (static_cast<uint32>(n)),
                    "rm" (d));
#else
     q = n / d;
ffffffff81018a25:	8b 0d 49 ae 14 00    	mov    0x14ae49(%rip),%ecx        # ffffffff81163874 <_ZN5Lapic8freq_tscE>
ffffffff81018a2b:	31 d2                	xor    %edx,%edx
ffffffff81018a2d:	48 f7 f1             	div    %rcx

        ALWAYS_INLINE
        inline void set_time (uint64 val)
        {
            ARG_2 = static_cast<mword>(val >> 32);
ffffffff81018a30:	48 89 c2             	mov    %rax,%rdx
            ARG_3 = static_cast<mword>(val);
ffffffff81018a33:	48 89 87 10 01 00 00 	mov    %rax,0x110(%rdi)
        inline unsigned long sc() const { return ARG_1 >> 8; }

        ALWAYS_INLINE
        inline void set_time (uint64 val)
        {
            ARG_2 = static_cast<mword>(val >> 32);
ffffffff81018a3a:	48 c1 ea 20          	shr    $0x20,%rdx
ffffffff81018a3e:	48 89 97 f0 00 00 00 	mov    %rdx,0xf0(%rdi)

    sys_finish<Sys_regs::SUCCESS>();
ffffffff81018a45:	e8 0e e6 ff ff       	callq  ffffffff81017058 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb0EEEvv>

ffffffff81018a4a <_ZN2Ec11sys_pt_ctrlEv>:
}

void Ec::sys_pt_ctrl()
{
ffffffff81018a4a:	48 83 ec 18          	sub    $0x18,%rsp
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
ffffffff81018a4e:	48 8b 05 bb 65 fe 3e 	mov    0x3efe65bb(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81018a55:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff81018a5a:	48 8d b8 08 03 00 00 	lea    0x308(%rax),%rdi
ffffffff81018a61:	e8 dc e5 ff ff       	callq  ffffffff81017042 <_ZN5Quota9hit_limitEm>
ffffffff81018a66:	84 c0                	test   %al,%al
ffffffff81018a68:	48 8b 3d 99 65 fe 3e 	mov    0x3efe6599(%rip),%rdi        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81018a6f:	74 27                	je     ffffffff81018a98 <_ZN2Ec11sys_pt_ctrlEv+0x4e>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu (%lu)", __func__, __LINE__, Pd::current->quota.usage(), Pd::current->quota.limit(), r);

        if (Ec::current->pt_oom && call)
ffffffff81018a71:	48 8b b7 38 03 00 00 	mov    0x338(%rdi),%rsi
ffffffff81018a78:	48 85 f6             	test   %rsi,%rsi
ffffffff81018a7b:	74 16                	je     ffffffff81018a93 <_ZN2Ec11sys_pt_ctrlEv+0x49>
            Ec::current->oom_call_cpu (Ec::current->pt_oom, Ec::current->pt_oom->id, C, C);
ffffffff81018a7d:	48 8b 96 a8 00 00 00 	mov    0xa8(%rsi),%rdx
ffffffff81018a84:	49 c7 c0 4a 8a 01 81 	mov    $0xffffffff81018a4a,%r8
ffffffff81018a8b:	4c 89 c1             	mov    %r8,%rcx
ffffffff81018a8e:	e8 07 71 ff ff       	callq  ffffffff8100fb9a <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_>

        sys_finish<Sys_regs::QUO_OOM>();
ffffffff81018a93:	e8 34 f9 ff ff       	callq  ffffffff810183cc <_ZN2Ec10sys_finishILN8Sys_regs6StatusE9ELb0EEEvv>

class Sys_pt_ctrl : public Sys_regs
{
    public:
        ALWAYS_INLINE
        inline unsigned long pt() const { return ARG_1 >> 8; }
ffffffff81018a98:	48 8b 8f e8 00 00 00 	mov    0xe8(%rdi),%rcx
ffffffff81018a9f:	48 c1 e9 08          	shr    $0x8,%rcx
{
    private:
        ALWAYS_INLINE
        static inline mword idx_to_virt (unsigned long idx)
        {
            return SPC_LOCAL_OBJ + (idx % caps) * sizeof (Capability);
ffffffff81018aa3:	48 89 c8             	mov    %rcx,%rax
ffffffff81018aa6:	25 ff ff ff 03       	and    $0x3ffffff,%eax
        static unsigned const caps = (END_SPACE_LIM - SPC_LOCAL_OBJ) / sizeof (Capability);

        ALWAYS_INLINE
        static inline Capability lookup (unsigned long idx)
        {
            return *reinterpret_cast<Capability *>(idx_to_virt (idx));
ffffffff81018aab:	48 8b 04 c5 00 00 00 	mov    -0x20000000(,%rax,8),%rax
ffffffff81018ab2:	e0 
ffffffff81018ab3:	48 89 c2             	mov    %rax,%rdx
ffffffff81018ab6:	48 83 e2 e0          	and    $0xffffffffffffffe0,%rdx
ffffffff81018aba:	74 0d                	je     ffffffff81018ac9 <_ZN2Ec11sys_pt_ctrlEv+0x7f>
    check<sys_pt_ctrl>(1);

    Sys_pt_ctrl *r = static_cast<Sys_pt_ctrl *>(current->sys_regs());

    Capability cap = Space_obj::lookup (r->pt());
    if (EXPECT_FALSE (cap.obj()->type() != Kobject::PT || !(cap.prm() & 1UL << 0))) {
ffffffff81018abc:	80 ba 88 00 00 00 03 	cmpb   $0x3,0x88(%rdx)
ffffffff81018ac3:	75 04                	jne    ffffffff81018ac9 <_ZN2Ec11sys_pt_ctrlEv+0x7f>
ffffffff81018ac5:	a8 01                	test   $0x1,%al
ffffffff81018ac7:	75 39                	jne    ffffffff81018b02 <_ZN2Ec11sys_pt_ctrlEv+0xb8>
        trace (TRACE_ERROR, "%s: Bad PT CAP (%#lx)", __func__, r->pt());
ffffffff81018ac9:	8b 15 35 65 fe 3e    	mov    0x3efe6535(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81018acf:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff81018ad4:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81018ad8:	48 c7 c7 20 0e 02 81 	mov    $0xffffffff81020e20,%rdi
ffffffff81018adf:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81018ae5:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff81018aeb:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff81018aef:	48 c7 c2 48 11 02 81 	mov    $0xffffffff81021148,%rdx
ffffffff81018af6:	31 c0                	xor    %eax,%eax
ffffffff81018af8:	e8 8f 95 fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_CAP>();
ffffffff81018afd:	e8 32 f5 ff ff       	callq  ffffffff81018034 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>
ffffffff81018b02:	48 8b 87 f0 00 00 00 	mov    0xf0(%rdi),%rax
        mword      id;

        Pt (Pd *, mword, Ec *, Mtd, mword);

        ALWAYS_INLINE
        inline void set_id (mword i) { id = i; }
ffffffff81018b09:	48 89 82 a8 00 00 00 	mov    %rax,0xa8(%rdx)

    Pt *pt = static_cast<Pt *>(cap.obj());

    pt->set_id (r->id());

    sys_finish<Sys_regs::SUCCESS>();
ffffffff81018b10:	e8 43 e5 ff ff       	callq  ffffffff81017058 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb0EEEvv>
ffffffff81018b15:	90                   	nop

ffffffff81018b16 <_ZN2Ec11sys_sm_ctrlEv>:
}

void Ec::sys_sm_ctrl()
{
ffffffff81018b16:	41 57                	push   %r15
ffffffff81018b18:	41 56                	push   %r14
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
ffffffff81018b1a:	be 01 00 00 00       	mov    $0x1,%esi

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_sm_ctrl()
{
ffffffff81018b1f:	41 55                	push   %r13
ffffffff81018b21:	41 54                	push   %r12
ffffffff81018b23:	55                   	push   %rbp
ffffffff81018b24:	53                   	push   %rbx
ffffffff81018b25:	50                   	push   %rax
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
ffffffff81018b26:	48 8b 05 e3 64 fe 3e 	mov    0x3efe64e3(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81018b2d:	48 8d b8 08 03 00 00 	lea    0x308(%rax),%rdi
ffffffff81018b34:	e8 09 e5 ff ff       	callq  ffffffff81017042 <_ZN5Quota9hit_limitEm>
ffffffff81018b39:	84 c0                	test   %al,%al
ffffffff81018b3b:	48 8b 1d c6 64 fe 3e 	mov    0x3efe64c6(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81018b42:	74 2a                	je     ffffffff81018b6e <_ZN2Ec11sys_sm_ctrlEv+0x58>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu (%lu)", __func__, __LINE__, Pd::current->quota.usage(), Pd::current->quota.limit(), r);

        if (Ec::current->pt_oom && call)
ffffffff81018b44:	48 8b b3 38 03 00 00 	mov    0x338(%rbx),%rsi
ffffffff81018b4b:	48 85 f6             	test   %rsi,%rsi
ffffffff81018b4e:	74 19                	je     ffffffff81018b69 <_ZN2Ec11sys_sm_ctrlEv+0x53>
            Ec::current->oom_call_cpu (Ec::current->pt_oom, Ec::current->pt_oom->id, C, C);
ffffffff81018b50:	48 8b 96 a8 00 00 00 	mov    0xa8(%rsi),%rdx
ffffffff81018b57:	49 c7 c0 16 8b 01 81 	mov    $0xffffffff81018b16,%r8
ffffffff81018b5e:	48 89 df             	mov    %rbx,%rdi
ffffffff81018b61:	4c 89 c1             	mov    %r8,%rcx
ffffffff81018b64:	e8 31 70 ff ff       	callq  ffffffff8100fb9a <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_>

        sys_finish<Sys_regs::QUO_OOM>();
ffffffff81018b69:	e8 5e f8 ff ff       	callq  ffffffff810183cc <_ZN2Ec10sys_finishILN8Sys_regs6StatusE9ELb0EEEvv>
ffffffff81018b6e:	4c 8b ab e8 00 00 00 	mov    0xe8(%rbx),%r13

class Sys_sm_ctrl : public Sys_regs
{
    public:
        ALWAYS_INLINE
        inline unsigned long sm() const { return ARG_1 >> 8; }
ffffffff81018b75:	4c 89 e8             	mov    %r13,%rax
ffffffff81018b78:	48 c1 e8 08          	shr    $0x8,%rax
{
    private:
        ALWAYS_INLINE
        static inline mword idx_to_virt (unsigned long idx)
        {
            return SPC_LOCAL_OBJ + (idx % caps) * sizeof (Capability);
ffffffff81018b7c:	25 ff ff ff 03       	and    $0x3ffffff,%eax
        static unsigned const caps = (END_SPACE_LIM - SPC_LOCAL_OBJ) / sizeof (Capability);

        ALWAYS_INLINE
        static inline Capability lookup (unsigned long idx)
        {
            return *reinterpret_cast<Capability *>(idx_to_virt (idx));
ffffffff81018b81:	48 8b 04 c5 00 00 00 	mov    -0x20000000(,%rax,8),%rax
ffffffff81018b88:	e0 
ffffffff81018b89:	48 89 c5             	mov    %rax,%rbp
ffffffff81018b8c:	48 83 e5 e0          	and    $0xffffffffffffffe0,%rbp
ffffffff81018b90:	74 1c                	je     ffffffff81018bae <_ZN2Ec11sys_sm_ctrlEv+0x98>
    check<sys_sm_ctrl>(1);

    Sys_sm_ctrl *r = static_cast<Sys_sm_ctrl *>(current->sys_regs());
    Capability cap = Space_obj::lookup (r->sm());

    if (EXPECT_FALSE (cap.obj()->type() != Kobject::SM || !(cap.prm() & 1UL << r->op()))) {
ffffffff81018b92:	80 bd 88 00 00 00 04 	cmpb   $0x4,0x88(%rbp)
ffffffff81018b99:	75 13                	jne    ffffffff81018bae <_ZN2Ec11sys_sm_ctrlEv+0x98>
            BAD_DEV,
            QUO_OOM,
        };

        ALWAYS_INLINE
        inline unsigned flags() const { return ARG_1 >> 4 & 0xf; }
ffffffff81018b9b:	49 c1 ed 04          	shr    $0x4,%r13
ffffffff81018b9f:	83 e0 1f             	and    $0x1f,%eax

        ALWAYS_INLINE
        inline unsigned op() const { return flags() & 0x1; }
ffffffff81018ba2:	44 89 ea             	mov    %r13d,%edx
ffffffff81018ba5:	83 e2 01             	and    $0x1,%edx
ffffffff81018ba8:	48 0f a3 d0          	bt     %rdx,%rax
ffffffff81018bac:	72 05                	jb     ffffffff81018bb3 <_ZN2Ec11sys_sm_ctrlEv+0x9d>
//        trace (TRACE_ERROR, "%s: Bad SM CAP (%#lx)", __func__, r->sm());
        sys_finish<Sys_regs::BAD_CAP>();
ffffffff81018bae:	e8 81 f4 ff ff       	callq  ffffffff81018034 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>
    }

    Sm *sm = static_cast<Sm *>(cap.obj());

    switch (r->op()) {
ffffffff81018bb3:	ff ca                	dec    %edx
ffffffff81018bb5:	74 11                	je     ffffffff81018bc8 <_ZN2Ec11sys_sm_ctrlEv+0xb2>

        case 0:
            sm->submit();
ffffffff81018bb7:	48 8d bd a0 00 00 00 	lea    0xa0(%rbp),%rdi
ffffffff81018bbe:	e8 f1 c4 ff ff       	callq  ffffffff810150b4 <_ZN2Si6submitEv>
            break;
ffffffff81018bc3:	e9 2d 02 00 00       	jmpq   ffffffff81018df5 <_ZN2Ec11sys_sm_ctrlEv+0x2df>

        case 1:
            if (sm->space == static_cast<Space_obj *>(&Pd::kern)) {
ffffffff81018bc8:	48 81 7d 50 98 3f 16 	cmpq   $0xffffffff81163f98,0x50(%rbp)
ffffffff81018bcf:	81 
ffffffff81018bd0:	75 11                	jne    ffffffff81018be3 <_ZN2Ec11sys_sm_ctrlEv+0xcd>
                Gsi::unmask (static_cast<unsigned>(sm->node_base - NUM_CPU));
ffffffff81018bd2:	48 8b 7d 60          	mov    0x60(%rbp),%rdi
ffffffff81018bd6:	83 ef 40             	sub    $0x40,%edi
ffffffff81018bd9:	e8 92 f1 fe ff       	callq  ffffffff81007d70 <_ZN3Gsi6unmaskEj>
                break;
ffffffff81018bde:	e9 12 02 00 00       	jmpq   ffffffff81018df5 <_ZN2Ec11sys_sm_ctrlEv+0x2df>
            }

            if (sm->is_signal())
ffffffff81018be3:	48 83 bd a0 00 00 00 	cmpq   $0x0,0xa0(%rbp)
ffffffff81018bea:	00 
ffffffff81018beb:	75 c1                	jne    ffffffff81018bae <_ZN2Ec11sys_sm_ctrlEv+0x98>
                sys_finish<Sys_regs::BAD_CAP>();

            current->cont = Ec::sys_finish<Sys_regs::SUCCESS, true>;
ffffffff81018bed:	48 c7 83 a0 00 00 00 	movq   $0xffffffff81017188,0xa0(%rbx)
ffffffff81018bf4:	88 71 01 81 

        ALWAYS_INLINE
        inline unsigned zc() const { return flags() & 0x2; }

        ALWAYS_INLINE
        inline uint64 time() const { return static_cast<uint64>(ARG_2) << 32 | ARG_3; }
ffffffff81018bf8:	4c 8b bb f0 00 00 00 	mov    0xf0(%rbx),%r15
        }

        ALWAYS_INLINE
        inline void dn (bool zero, uint64 t, Ec *ec = Ec::current, bool block = true)
        {
            {   Lock_guard <Spinlock> guard (lock);
ffffffff81018bff:	48 8d bd 8a 00 00 00 	lea    0x8a(%rbp),%rdi
ffffffff81018c06:	4c 8b b3 10 01 00 00 	mov    0x110(%rbx),%r14

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81018c0d:	9c                   	pushfq 
ffffffff81018c0e:	41 5c                	pop    %r12
            return flags & 0x200;
ffffffff81018c10:	49 c1 ec 09          	shr    $0x9,%r12

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff81018c14:	41 80 e4 01          	and    $0x1,%r12b
ffffffff81018c18:	74 30                	je     ffffffff81018c4a <_ZN2Ec11sys_sm_ctrlEv+0x134>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81018c1a:	80 3d 0f 6b fe 3e 00 	cmpb   $0x0,0x3efe6b0f(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81018c21:	75 1f                	jne    ffffffff81018c42 <_ZN2Ec11sys_sm_ctrlEv+0x12c>
ffffffff81018c23:	49 c7 c0 f0 12 02 81 	mov    $0xffffffff810212f0,%r8
ffffffff81018c2a:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff81018c2f:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81018c36:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff81018c3d:	e9 56 01 00 00       	jmpq   ffffffff81018d98 <_ZN2Ec11sys_sm_ctrlEv+0x282>

            asm volatile ("cli" : : : "memory");
ffffffff81018c42:	fa                   	cli    
            preemption = false;
ffffffff81018c43:	c6 05 e6 6a fe 3e 00 	movb   $0x0,0x3efe6ae6(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff81018c4a:	e8 3f 82 fe ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>

                if (counter) {
ffffffff81018c4f:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff81018c56:	48 85 c0             	test   %rax,%rax
ffffffff81018c59:	0f 84 b4 00 00 00    	je     ffffffff81018d13 <_ZN2Ec11sys_sm_ctrlEv+0x1fd>
                    counter = zero ? 0 : counter - 1;
ffffffff81018c5f:	48 ff c8             	dec    %rax
ffffffff81018c62:	31 d2                	xor    %edx,%edx
ffffffff81018c64:	41 80 e5 02          	and    $0x2,%r13b
ffffffff81018c68:	48 0f 44 d0          	cmove  %rax,%rdx

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff81018c6c:	48 8b 85 98 00 00 00 	mov    0x98(%rbp),%rax
ffffffff81018c73:	48 89 95 c0 00 00 00 	mov    %rdx,0xc0(%rbp)
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff81018c7a:	48 85 c0             	test   %rax,%rax
ffffffff81018c7d:	0f 84 2d 01 00 00    	je     ffffffff81018db0 <_ZN2Ec11sys_sm_ctrlEv+0x29a>
ffffffff81018c83:	48 8b 50 10          	mov    0x10(%rax),%rdx
ffffffff81018c87:	48 85 d2             	test   %rdx,%rdx
ffffffff81018c8a:	0f 84 20 01 00 00    	je     ffffffff81018db0 <_ZN2Ec11sys_sm_ctrlEv+0x29a>
ffffffff81018c90:	48 8b 48 08          	mov    0x8(%rax),%rcx
ffffffff81018c94:	48 85 c9             	test   %rcx,%rcx
ffffffff81018c97:	0f 84 13 01 00 00    	je     ffffffff81018db0 <_ZN2Ec11sys_sm_ctrlEv+0x29a>
                return false;

            if (t == t->next)
ffffffff81018c9d:	48 39 d0             	cmp    %rdx,%rax
ffffffff81018ca0:	75 0d                	jne    ffffffff81018caf <_ZN2Ec11sys_sm_ctrlEv+0x199>
                headptr = nullptr;
ffffffff81018ca2:	48 c7 85 98 00 00 00 	movq   $0x0,0x98(%rbp)
ffffffff81018ca9:	00 00 00 00 
ffffffff81018cad:	eb 24                	jmp    ffffffff81018cd3 <_ZN2Ec11sys_sm_ctrlEv+0x1bd>

            else {
                t->next->prev = t->prev;
ffffffff81018caf:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
                t->prev->next = t->next;
ffffffff81018cb3:	48 8b 50 08          	mov    0x8(%rax),%rdx
ffffffff81018cb7:	48 8b 48 10          	mov    0x10(%rax),%rcx
ffffffff81018cbb:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
                if (t == headptr)
ffffffff81018cbf:	48 3b 85 98 00 00 00 	cmp    0x98(%rbp),%rax
ffffffff81018cc6:	75 0b                	jne    ffffffff81018cd3 <_ZN2Ec11sys_sm_ctrlEv+0x1bd>
                    headptr = t->next;
ffffffff81018cc8:	48 8b 50 10          	mov    0x10(%rax),%rdx
ffffffff81018ccc:	48 89 95 98 00 00 00 	mov    %rdx,0x98(%rbp)

    public:

        mword reset(bool l = false) {
            if (l) lock.lock();
            mword c = counter;
ffffffff81018cd3:	48 8b 50 20          	mov    0x20(%rax),%rdx
            }

            t->next = t->prev = nullptr;
ffffffff81018cd7:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
ffffffff81018cde:	00 
ffffffff81018cdf:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
ffffffff81018ce6:	00 
            counter = 0;
ffffffff81018ce7:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
ffffffff81018cee:	00 
                if (counter) {
                    counter = zero ? 0 : counter - 1;

                    Si * si;
                    if (Queue<Si>::dequeue(si = Queue<Si>::head()))
                        ec->set_si_regs(si->value, static_cast <Sm *>(si)->reset());
ffffffff81018cef:	48 8b 40 18          	mov    0x18(%rax),%rax
    }

    ALWAYS_INLINE
    inline void set_si_regs(mword sig, mword cnt) {
        regs.ARG_2 = sig;
        regs.ARG_3 = cnt;
ffffffff81018cf3:	48 89 93 10 01 00 00 	mov    %rdx,0x110(%rbx)
            timeout.dequeue();
    }

    ALWAYS_INLINE
    inline void set_si_regs(mword sig, mword cnt) {
        regs.ARG_2 = sig;
ffffffff81018cfa:	48 89 83 f0 00 00 00 	mov    %rax,0xf0(%rbx)
ffffffff81018d01:	e9 aa 00 00 00       	jmpq   ffffffff81018db0 <_ZN2Ec11sys_sm_ctrlEv+0x29a>

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff81018d06:	8d 50 01             	lea    0x1(%rax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff81018d09:	f0 0f b1 93 8c 00 00 	lock cmpxchg %edx,0x8c(%rbx)
ffffffff81018d10:	00 
ffffffff81018d11:	74 0a                	je     ffffffff81018d1d <_ZN2Ec11sys_sm_ctrlEv+0x207>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff81018d13:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff81018d19:	85 c0                	test   %eax,%eax
ffffffff81018d1b:	75 e9                	jne    ffffffff81018d06 <_ZN2Ec11sys_sm_ctrlEv+0x1f0>
        inline T *head() const { return headptr; }

        ALWAYS_INLINE
        inline void enqueue (T *t)
        {
            if (!headptr)
ffffffff81018d1d:	48 8b 85 90 00 00 00 	mov    0x90(%rbp),%rax
ffffffff81018d24:	48 85 c0             	test   %rax,%rax
ffffffff81018d27:	75 17                	jne    ffffffff81018d40 <_ZN2Ec11sys_sm_ctrlEv+0x22a>
                headptr = t->prev = t->next = t;
ffffffff81018d29:	48 89 9b b0 02 00 00 	mov    %rbx,0x2b0(%rbx)
ffffffff81018d30:	48 89 9b a8 02 00 00 	mov    %rbx,0x2a8(%rbx)
ffffffff81018d37:	48 89 9d 90 00 00 00 	mov    %rbx,0x90(%rbp)
ffffffff81018d3e:	eb 2a                	jmp    ffffffff81018d6a <_ZN2Ec11sys_sm_ctrlEv+0x254>
            else {
                t->next = headptr;
ffffffff81018d40:	48 89 83 b0 02 00 00 	mov    %rax,0x2b0(%rbx)
                t->prev = headptr->prev;
ffffffff81018d47:	48 8b 95 90 00 00 00 	mov    0x90(%rbp),%rdx
ffffffff81018d4e:	48 8b 92 a8 02 00 00 	mov    0x2a8(%rdx),%rdx
ffffffff81018d55:	48 89 93 a8 02 00 00 	mov    %rdx,0x2a8(%rbx)
                t->next->prev = t->prev->next = t;
ffffffff81018d5c:	48 89 9a b0 02 00 00 	mov    %rbx,0x2b0(%rdx)
ffffffff81018d63:	48 89 98 a8 02 00 00 	mov    %rbx,0x2a8(%rax)
ffffffff81018d6a:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81018d70:	45 84 e4             	test   %r12b,%r12b
ffffffff81018d73:	74 59                	je     ffffffff81018dce <_ZN2Ec11sys_sm_ctrlEv+0x2b8>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81018d75:	80 3d b4 69 fe 3e 00 	cmpb   $0x0,0x3efe69b4(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81018d7c:	74 28                	je     ffffffff81018da6 <_ZN2Ec11sys_sm_ctrlEv+0x290>
ffffffff81018d7e:	49 c7 c0 c0 12 02 81 	mov    $0xffffffff810212c0,%r8
ffffffff81018d85:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff81018d8a:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81018d91:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff81018d98:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81018d9f:	31 c0                	xor    %eax,%eax
ffffffff81018da1:	e8 aa 91 fe ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            preemption = true;
ffffffff81018da6:	c6 05 83 69 fe 3e 01 	movb   $0x1,0x3efe6983(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81018dad:	fb                   	sti    
ffffffff81018dae:	eb 1e                	jmp    ffffffff81018dce <_ZN2Ec11sys_sm_ctrlEv+0x2b8>
ffffffff81018db0:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
ffffffff81018db6:	45 84 e4             	test   %r12b,%r12b
ffffffff81018db9:	74 3a                	je     ffffffff81018df5 <_ZN2Ec11sys_sm_ctrlEv+0x2df>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81018dbb:	80 3d 6e 69 fe 3e 00 	cmpb   $0x0,0x3efe696e(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81018dc2:	75 ba                	jne    ffffffff81018d7e <_ZN2Ec11sys_sm_ctrlEv+0x268>

            preemption = true;
ffffffff81018dc4:	c6 05 65 69 fe 3e 01 	movb   $0x1,0x3efe6965(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff81018dcb:	fb                   	sti    
ffffffff81018dcc:	eb 27                	jmp    ffffffff81018df5 <_ZN2Ec11sys_sm_ctrlEv+0x2df>
ffffffff81018dce:	4c 89 fe             	mov    %r15,%rsi
ffffffff81018dd1:	48 c1 e6 20          	shl    $0x20,%rsi
        return next || !cont;
    }

    ALWAYS_INLINE
    inline void set_timeout(uint64 t, Sm *s) {
        if (EXPECT_FALSE(t))
ffffffff81018dd5:	4c 09 f6             	or     %r14,%rsi
ffffffff81018dd8:	74 13                	je     ffffffff81018ded <_ZN2Ec11sys_sm_ctrlEv+0x2d7>

        ALWAYS_INLINE
        inline void enqueue (uint64 t, Sm *s) { sm = s; Timeout::enqueue (t); }
ffffffff81018dda:	48 8d bb f8 02 00 00 	lea    0x2f8(%rbx),%rdi
ffffffff81018de1:	48 89 ab 20 03 00 00 	mov    %rbp,0x320(%rbx)
ffffffff81018de8:	e8 69 1b 00 00       	callq  ffffffff8101a956 <_ZN7Timeout7enqueueEy>
            if (!block)
                Sc::schedule (false);

            ec->set_timeout (t, this);

            ec->block_sc();
ffffffff81018ded:	48 89 df             	mov    %rbx,%rdi
ffffffff81018df0:	e8 79 29 ff ff       	callq  ffffffff8100b76e <_ZN2Ec8block_scEv>
            sm->dn (r->zc(), r->time());
            break;
    }

    sys_finish<Sys_regs::SUCCESS>();
ffffffff81018df5:	e8 5e e2 ff ff       	callq  ffffffff81017058 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb0EEEvv>

ffffffff81018dfa <_ZN2Ec8delegateILb1EEEvv>:

    ec->make_current();
}

template <bool C>
void Ec::delegate()
ffffffff81018dfa:	41 54                	push   %r12
ffffffff81018dfc:	55                   	push   %rbp
ffffffff81018dfd:	53                   	push   %rbx
ffffffff81018dfe:	48 83 ec 10          	sub    $0x10,%rsp
{
    Ec *ec = current->rcap;
ffffffff81018e02:	48 8b 1d ff 61 fe 3e 	mov    0x3efe61ff(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81018e09:	48 8b ab 88 02 00 00 	mov    0x288(%rbx),%rbp
    assert (ec);
ffffffff81018e10:	48 85 ed             	test   %rbp,%rbp
ffffffff81018e13:	75 28                	jne    ffffffff81018e3d <_ZN2Ec8delegateILb1EEEvv+0x43>
ffffffff81018e15:	49 c7 c0 60 12 02 81 	mov    $0xffffffff81021260,%r8
ffffffff81018e1c:	b9 47 00 00 00       	mov    $0x47,%ecx
ffffffff81018e21:	48 c7 c2 ab 0c 02 81 	mov    $0xffffffff81020cab,%rdx
ffffffff81018e28:	48 c7 c6 3d 0e 02 81 	mov    $0xffffffff81020e3d,%rsi
ffffffff81018e2f:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81018e36:	31 c0                	xor    %eax,%eax
ffffffff81018e38:	e8 13 91 fe ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
    dst->pd->xfer_items (src->pd,
                         user ? dst->utcb->xlt : Crd (0),
                         user ? dst->utcb->del : Crd (Crd::MEM, (dst->cont == ret_user_iret ? dst->regs.cr2 : dst->regs.nst_fault) >> PAGE_BITS),
                         src->utcb->xfer(),
                         user ? dst->utcb->xfer() : nullptr,
                         src->utcb->ti());
ffffffff81018e3d:	4c 8b 95 90 02 00 00 	mov    0x290(%rbp),%r10

    dst->pd->xfer_items (src->pd,
                         user ? dst->utcb->xlt : Crd (0),
                         user ? dst->utcb->del : Crd (Crd::MEM, (dst->cont == ret_user_iret ? dst->regs.cr2 : dst->regs.nst_fault) >> PAGE_BITS),
                         src->utcb->xfer(),
                         user ? dst->utcb->xfer() : nullptr,
ffffffff81018e44:	4c 8b 83 90 02 00 00 	mov    0x290(%rbx),%r8
ffffffff81018e4b:	ba fe 00 00 00       	mov    $0xfe,%edx
        WARN_UNUSED_RESULT bool save_exc (Cpu_regs *);
        WARN_UNUSED_RESULT bool save_vmx (Cpu_regs *);
        WARN_UNUSED_RESULT bool save_svm (Cpu_regs *);

        inline mword ucnt() const { return static_cast<uint16>(items); }
        inline mword tcnt() const { return static_cast<uint16>(items >> 16); }
ffffffff81018e50:	41 0f b7 42 02       	movzwl 0x2(%r10),%eax
                         src->utcb->ti());
ffffffff81018e55:	49 8b 48 10          	mov    0x10(%r8),%rcx
    Ec *src = C ? ec : current;
    Ec *dst = C ? current : ec;

    bool user = C || ((dst->cont == ret_user_sysexit) || (dst->cont == xcpu_return));

    dst->pd->xfer_items (src->pd,
ffffffff81018e59:	4d 8d 88 f0 0f 00 00 	lea    0xff0(%r8),%r9
ffffffff81018e60:	48 3d fe 00 00 00    	cmp    $0xfe,%rax
ffffffff81018e66:	48 0f 47 c2          	cmova  %rdx,%rax
                         user ? dst->utcb->xlt : Crd (0),
                         user ? dst->utcb->del : Crd (Crd::MEM, (dst->cont == ret_user_iret ? dst->regs.cr2 : dst->regs.nst_fault) >> PAGE_BITS),
                         src->utcb->xfer(),
                         user ? dst->utcb->xfer() : nullptr,
                         src->utcb->ti());
ffffffff81018e6a:	49 8b 50 08          	mov    0x8(%r8),%rdx
    Ec *src = C ? ec : current;
    Ec *dst = C ? current : ec;

    bool user = C || ((dst->cont == ret_user_sysexit) || (dst->cont == xcpu_return));

    dst->pd->xfer_items (src->pd,
ffffffff81018e6e:	56                   	push   %rsi
ffffffff81018e6f:	48 8b bb 98 02 00 00 	mov    0x298(%rbx),%rdi
ffffffff81018e76:	48 8b b5 98 02 00 00 	mov    0x298(%rbp),%rsi
ffffffff81018e7d:	4d 8d 82 f0 0f 00 00 	lea    0xff0(%r10),%r8
ffffffff81018e84:	50                   	push   %rax
ffffffff81018e85:	e8 04 91 ff ff       	callq  ffffffff81011f8e <_ZN2Pd10xfer_itemsEPS_3CrdS1_P4XferS3_m>
                         user ? dst->utcb->del : Crd (Crd::MEM, (dst->cont == ret_user_iret ? dst->regs.cr2 : dst->regs.nst_fault) >> PAGE_BITS),
                         src->utcb->xfer(),
                         user ? dst->utcb->xfer() : nullptr,
                         src->utcb->ti());

    if (Cpu::hazard & HZD_OOM) {
ffffffff81018e8a:	f6 05 6f 61 fe 3e 20 	testb  $0x20,0x3efe616f(%rip)        # ffffffffbffff000 <_ZN3Cpu6hazardE>
ffffffff81018e91:	5f                   	pop    %rdi
ffffffff81018e92:	41 58                	pop    %r8
ffffffff81018e94:	74 7f                	je     ffffffff81018f15 <_ZN2Ec8delegateILb1EEEvv+0x11b>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
ffffffff81018e96:	4c 8b a3 98 02 00 00 	mov    0x298(%rbx),%r12
        if (dst->pd->quota.hit_limit())
ffffffff81018e9d:	31 f6                	xor    %esi,%esi
ffffffff81018e9f:	49 8d bc 24 08 03 00 	lea    0x308(%r12),%rdi
ffffffff81018ea6:	00 
ffffffff81018ea7:	e8 96 e1 ff ff       	callq  ffffffff81017042 <_ZN5Quota9hit_limitEm>
ffffffff81018eac:	84 c0                	test   %al,%al
ffffffff81018eae:	74 3d                	je     ffffffff81018eed <_ZN2Ec8delegateILb1EEEvv+0xf3>
            trace (0, "warning: insufficient resources %lx/%lx", dst->pd->quota.usage(), dst->pd->quota.limit());
ffffffff81018eb0:	8b 3d 4e 61 fe 3e    	mov    0x3efe614e(%rip),%edi        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81018eb6:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff81018ebb:	49 8b 8c 24 20 03 00 	mov    0x320(%r12),%rcx
ffffffff81018ec2:	00 
ffffffff81018ec3:	49 8b 94 24 10 03 00 	mov    0x310(%r12),%rdx
ffffffff81018eca:	00 
ffffffff81018ecb:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81018ecf:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81018ed5:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff81018edb:	48 0f 44 f7          	cmove  %rdi,%rsi
ffffffff81018edf:	48 c7 c7 40 0e 02 81 	mov    $0xffffffff81020e40,%rdi
ffffffff81018ee6:	31 c0                	xor    %eax,%eax
ffffffff81018ee8:	e8 9f 91 fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>

        Cpu::hazard ^= HZD_OOM;
        current->oom_delegate(dst, ec, src, user, C);
ffffffff81018eed:	48 8b 3d 14 61 fe 3e 	mov    0x3efe6114(%rip),%rdi        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81018ef4:	41 b9 01 00 00 00    	mov    $0x1,%r9d
ffffffff81018efa:	41 b8 01 00 00 00    	mov    $0x1,%r8d
ffffffff81018f00:	48 89 e9             	mov    %rbp,%rcx
ffffffff81018f03:	48 89 ea             	mov    %rbp,%rdx
ffffffff81018f06:	48 89 de             	mov    %rbx,%rsi

    if (Cpu::hazard & HZD_OOM) {
        if (dst->pd->quota.hit_limit())
            trace (0, "warning: insufficient resources %lx/%lx", dst->pd->quota.usage(), dst->pd->quota.limit());

        Cpu::hazard ^= HZD_OOM;
ffffffff81018f09:	83 35 f0 60 fe 3e 20 	xorl   $0x20,0x3efe60f0(%rip)        # ffffffffbffff000 <_ZN3Cpu6hazardE>
        current->oom_delegate(dst, ec, src, user, C);
ffffffff81018f10:	e8 91 4b ff ff       	callq  ffffffff8100daa6 <_ZN2Ec12oom_delegateEPS_S0_S0_bb>
    }
}
ffffffff81018f15:	48 83 c4 10          	add    $0x10,%rsp
ffffffff81018f19:	5b                   	pop    %rbx
ffffffff81018f1a:	5d                   	pop    %rbp
ffffffff81018f1b:	41 5c                	pop    %r12
ffffffff81018f1d:	c3                   	retq   

ffffffff81018f1e <_ZN2Ec8delegateILb0EEEvv>:

    ec->make_current();
}

template <bool C>
void Ec::delegate()
ffffffff81018f1e:	41 55                	push   %r13
ffffffff81018f20:	41 54                	push   %r12
ffffffff81018f22:	55                   	push   %rbp
ffffffff81018f23:	53                   	push   %rbx
ffffffff81018f24:	48 83 ec 18          	sub    $0x18,%rsp
{
    Ec *ec = current->rcap;
ffffffff81018f28:	4c 8b 25 d9 60 fe 3e 	mov    0x3efe60d9(%rip),%r12        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81018f2f:	49 8b 9c 24 88 02 00 	mov    0x288(%r12),%rbx
ffffffff81018f36:	00 
    assert (ec);
ffffffff81018f37:	48 85 db             	test   %rbx,%rbx
ffffffff81018f3a:	75 28                	jne    ffffffff81018f64 <_ZN2Ec8delegateILb0EEEvv+0x46>
ffffffff81018f3c:	49 c7 c0 e0 11 02 81 	mov    $0xffffffff810211e0,%r8
ffffffff81018f43:	b9 47 00 00 00       	mov    $0x47,%ecx
ffffffff81018f48:	48 c7 c2 ab 0c 02 81 	mov    $0xffffffff81020cab,%rdx
ffffffff81018f4f:	48 c7 c6 3d 0e 02 81 	mov    $0xffffffff81020e3d,%rsi
ffffffff81018f56:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81018f5d:	31 c0                	xor    %eax,%eax
ffffffff81018f5f:	e8 ec 8f fe ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
    dst->pd->xfer_items (src->pd,
                         user ? dst->utcb->xlt : Crd (0),
                         user ? dst->utcb->del : Crd (Crd::MEM, (dst->cont == ret_user_iret ? dst->regs.cr2 : dst->regs.nst_fault) >> PAGE_BITS),
                         src->utcb->xfer(),
                         user ? dst->utcb->xfer() : nullptr,
                         src->utcb->ti());
ffffffff81018f64:	4d 8b 84 24 90 02 00 	mov    0x290(%r12),%r8
ffffffff81018f6b:	00 
    assert (ec);

    Ec *src = C ? ec : current;
    Ec *dst = C ? current : ec;

    bool user = C || ((dst->cont == ret_user_sysexit) || (dst->cont == xcpu_return));
ffffffff81018f6c:	48 8b 83 a0 00 00 00 	mov    0xa0(%rbx),%rax
ffffffff81018f73:	be fe 00 00 00       	mov    $0xfe,%esi
ffffffff81018f78:	41 0f b7 48 02       	movzwl 0x2(%r8),%ecx
ffffffff81018f7d:	48 3d 00 00 00 81    	cmp    $0xffffffff81000000,%rax
ffffffff81018f83:	40 0f 94 c5          	sete   %bpl
ffffffff81018f87:	48 3d 76 53 00 81    	cmp    $0xffffffff81005376,%rax
ffffffff81018f8d:	0f 94 c2             	sete   %dl
ffffffff81018f90:	48 81 f9 fe 00 00 00 	cmp    $0xfe,%rcx
ffffffff81018f97:	48 0f 47 ce          	cmova  %rsi,%rcx
    dst->pd->xfer_items (src->pd,
                         user ? dst->utcb->xlt : Crd (0),
                         user ? dst->utcb->del : Crd (Crd::MEM, (dst->cont == ret_user_iret ? dst->regs.cr2 : dst->regs.nst_fault) >> PAGE_BITS),
                         src->utcb->xfer(),
                         user ? dst->utcb->xfer() : nullptr,
                         src->utcb->ti());
ffffffff81018f9b:	45 31 c9             	xor    %r9d,%r9d
ffffffff81018f9e:	40 08 d5             	or     %dl,%bpl
ffffffff81018fa1:	74 0e                	je     ffffffff81018fb1 <_ZN2Ec8delegateILb0EEEvv+0x93>
                dst->mr[i] = mr[i];
#endif
        }

        ALWAYS_INLINE
        inline Xfer *xfer() { return reinterpret_cast<Xfer *>(this) + PAGE_SIZE / sizeof (Xfer) - 1; }
ffffffff81018fa3:	48 8b bb 90 02 00 00 	mov    0x290(%rbx),%rdi
ffffffff81018faa:	4c 8d 8f f0 0f 00 00 	lea    0xff0(%rdi),%r9
ffffffff81018fb1:	49 81 c0 f0 0f 00 00 	add    $0xff0,%r8
ffffffff81018fb8:	40 84 ed             	test   %bpl,%bpl
ffffffff81018fbb:	74 11                	je     ffffffff81018fce <_ZN2Ec8delegateILb0EEEvv+0xb0>
ffffffff81018fbd:	48 8b 93 90 02 00 00 	mov    0x290(%rbx),%rdx
ffffffff81018fc4:	48 8b 42 10          	mov    0x10(%rdx),%rax
ffffffff81018fc8:	48 8b 52 08          	mov    0x8(%rdx),%rdx
ffffffff81018fcc:	eb 28                	jmp    ffffffff81018ff6 <_ZN2Ec8delegateILb0EEEvv+0xd8>
ffffffff81018fce:	48 3d 8c 00 00 81    	cmp    $0xffffffff8100008c,%rax
ffffffff81018fd4:	75 09                	jne    ffffffff81018fdf <_ZN2Ec8delegateILb0EEEvv+0xc1>
ffffffff81018fd6:	48 8b 83 00 01 00 00 	mov    0x100(%rbx),%rax
ffffffff81018fdd:	eb 07                	jmp    ffffffff81018fe6 <_ZN2Ec8delegateILb0EEEvv+0xc8>
ffffffff81018fdf:	48 8b 83 58 01 00 00 	mov    0x158(%rbx),%rax
ffffffff81018fe6:	48 c1 e8 0c          	shr    $0xc,%rax
ffffffff81018fea:	31 d2                	xor    %edx,%edx
ffffffff81018fec:	48 c1 e0 0c          	shl    $0xc,%rax
ffffffff81018ff0:	48 0d fd 0f 00 00    	or     $0xffd,%rax
    Ec *src = C ? ec : current;
    Ec *dst = C ? current : ec;

    bool user = C || ((dst->cont == ret_user_sysexit) || (dst->cont == xcpu_return));

    dst->pd->xfer_items (src->pd,
ffffffff81018ff6:	56                   	push   %rsi
ffffffff81018ff7:	48 8b bb 98 02 00 00 	mov    0x298(%rbx),%rdi
ffffffff81018ffe:	49 8b b4 24 98 02 00 	mov    0x298(%r12),%rsi
ffffffff81019005:	00 
ffffffff81019006:	51                   	push   %rcx
ffffffff81019007:	48 89 c1             	mov    %rax,%rcx
ffffffff8101900a:	e8 7f 8f ff ff       	callq  ffffffff81011f8e <_ZN2Pd10xfer_itemsEPS_3CrdS1_P4XferS3_m>
                         user ? dst->utcb->del : Crd (Crd::MEM, (dst->cont == ret_user_iret ? dst->regs.cr2 : dst->regs.nst_fault) >> PAGE_BITS),
                         src->utcb->xfer(),
                         user ? dst->utcb->xfer() : nullptr,
                         src->utcb->ti());

    if (Cpu::hazard & HZD_OOM) {
ffffffff8101900f:	f6 05 ea 5f fe 3e 20 	testb  $0x20,0x3efe5fea(%rip)        # ffffffffbffff000 <_ZN3Cpu6hazardE>
ffffffff81019016:	5f                   	pop    %rdi
ffffffff81019017:	41 58                	pop    %r8
ffffffff81019019:	74 7a                	je     ffffffff81019095 <_ZN2Ec8delegateILb0EEEvv+0x177>
ffffffff8101901b:	4c 8b ab 98 02 00 00 	mov    0x298(%rbx),%r13
        if (dst->pd->quota.hit_limit())
ffffffff81019022:	31 f6                	xor    %esi,%esi
ffffffff81019024:	49 8d bd 08 03 00 00 	lea    0x308(%r13),%rdi
ffffffff8101902b:	e8 12 e0 ff ff       	callq  ffffffff81017042 <_ZN5Quota9hit_limitEm>
ffffffff81019030:	84 c0                	test   %al,%al
ffffffff81019032:	74 3b                	je     ffffffff8101906f <_ZN2Ec8delegateILb0EEEvv+0x151>
            trace (0, "warning: insufficient resources %lx/%lx", dst->pd->quota.usage(), dst->pd->quota.limit());
ffffffff81019034:	8b 3d ca 5f fe 3e    	mov    0x3efe5fca(%rip),%edi        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8101903a:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff8101903f:	49 8b 8d 20 03 00 00 	mov    0x320(%r13),%rcx
ffffffff81019046:	49 8b 95 10 03 00 00 	mov    0x310(%r13),%rdx
ffffffff8101904d:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81019051:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81019057:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff8101905d:	48 0f 44 f7          	cmove  %rdi,%rsi
ffffffff81019061:	48 c7 c7 40 0e 02 81 	mov    $0xffffffff81020e40,%rdi
ffffffff81019068:	31 c0                	xor    %eax,%eax
ffffffff8101906a:	e8 1d 90 fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>

        Cpu::hazard ^= HZD_OOM;
        current->oom_delegate(dst, ec, src, user, C);
ffffffff8101906f:	48 8b 3d 92 5f fe 3e 	mov    0x3efe5f92(%rip),%rdi        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81019076:	41 89 e8             	mov    %ebp,%r8d
ffffffff81019079:	45 31 c9             	xor    %r9d,%r9d
ffffffff8101907c:	41 83 e0 01          	and    $0x1,%r8d
ffffffff81019080:	4c 89 e1             	mov    %r12,%rcx
ffffffff81019083:	48 89 da             	mov    %rbx,%rdx
ffffffff81019086:	48 89 de             	mov    %rbx,%rsi

    if (Cpu::hazard & HZD_OOM) {
        if (dst->pd->quota.hit_limit())
            trace (0, "warning: insufficient resources %lx/%lx", dst->pd->quota.usage(), dst->pd->quota.limit());

        Cpu::hazard ^= HZD_OOM;
ffffffff81019089:	83 35 70 5f fe 3e 20 	xorl   $0x20,0x3efe5f70(%rip)        # ffffffffbffff000 <_ZN3Cpu6hazardE>
        current->oom_delegate(dst, ec, src, user, C);
ffffffff81019090:	e8 11 4a ff ff       	callq  ffffffff8100daa6 <_ZN2Ec12oom_delegateEPS_S0_S0_bb>
    }
}
ffffffff81019095:	48 83 c4 18          	add    $0x18,%rsp
ffffffff81019099:	5b                   	pop    %rbx
ffffffff8101909a:	5d                   	pop    %rbp
ffffffff8101909b:	41 5c                	pop    %r12
ffffffff8101909d:	41 5d                	pop    %r13
ffffffff8101909f:	c3                   	retq   

ffffffff810190a0 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE5ELb0EEEvv>:
#include "syscall.hpp"
#include "utcb.hpp"
#include "vectors.hpp"

template <Sys_regs::Status S, bool T>
void Ec::sys_finish()
ffffffff810190a0:	53                   	push   %rbx
ffffffff810190a1:	48 83 ec 10          	sub    $0x10,%rsp
{
    if (T)
        current->clr_timeout();

    current->regs.set_status (S);
ffffffff810190a5:	48 8b 05 5c 5f fe 3e 	mov    0x3efe5f5c(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>

    if (current->xcpu_sm)
ffffffff810190ac:	48 83 b8 30 03 00 00 	cmpq   $0x0,0x330(%rax)
ffffffff810190b3:	00 

        ALWAYS_INLINE
        inline void set_status (Status s, bool c = true)
        {
            if (c)
                ARG_1 = s;
ffffffff810190b4:	48 c7 80 e8 00 00 00 	movq   $0x5,0xe8(%rax)
ffffffff810190bb:	05 00 00 00 
ffffffff810190bf:	74 05                	je     ffffffff810190c6 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE5ELb0EEEvv+0x26>
        xcpu_return();
ffffffff810190c1:	e8 b0 c2 fe ff       	callq  ffffffff81005376 <_ZN2Ec11xcpu_returnEv>

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
ffffffff810190c6:	48 8b 1d 43 5f fe 3e 	mov    0x3efe5f43(%rip),%rbx        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff810190cd:	31 f6                	xor    %esi,%esi
ffffffff810190cf:	48 8d bb 08 03 00 00 	lea    0x308(%rbx),%rdi
ffffffff810190d6:	e8 67 df ff ff       	callq  ffffffff81017042 <_ZN5Quota9hit_limitEm>
ffffffff810190db:	84 c0                	test   %al,%al
ffffffff810190dd:	75 05                	jne    ffffffff810190e4 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE5ELb0EEEvv+0x44>
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());

    ret_user_sysexit();
ffffffff810190df:	e8 1c 6f fe ff       	callq  ffffffff81000000 <_ZN2Ec16ret_user_sysexitEv>

    if (current->xcpu_sm)
        xcpu_return();

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());
ffffffff810190e4:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff810190e9:	8b 35 15 5f fe 3e    	mov    0x3efe5f15(%rip),%esi        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff810190ef:	48 8b 8b 20 03 00 00 	mov    0x320(%rbx),%rcx
ffffffff810190f6:	48 8b 93 10 03 00 00 	mov    0x310(%rbx),%rdx
ffffffff810190fd:	48 c7 c7 7c 0c 02 81 	mov    $0xffffffff81020c7c,%rdi
ffffffff81019104:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8101910a:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff81019110:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
ffffffff81019117:	48 0f 45 f0          	cmovne %rax,%rsi
ffffffff8101911b:	31 c0                	xor    %eax,%eax
ffffffff8101911d:	e8 6a 8f fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff81019122:	eb bb                	jmp    ffffffff810190df <_ZN2Ec10sys_finishILN8Sys_regs6StatusE5ELb0EEEvv+0x3f>

ffffffff81019124 <_ZN2Ec13sys_create_pdEv>:
        sys_finish<Sys_regs::QUO_OOM>();
    }
}

void Ec::sys_create_pd()
{
ffffffff81019124:	41 57                	push   %r15
ffffffff81019126:	41 56                	push   %r14
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
ffffffff81019128:	31 f6                	xor    %esi,%esi
        sys_finish<Sys_regs::QUO_OOM>();
    }
}

void Ec::sys_create_pd()
{
ffffffff8101912a:	41 55                	push   %r13
ffffffff8101912c:	41 54                	push   %r12
ffffffff8101912e:	55                   	push   %rbp
ffffffff8101912f:	53                   	push   %rbx
ffffffff81019130:	48 83 ec 18          	sub    $0x18,%rsp
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
ffffffff81019134:	48 8b 05 d5 5e fe 3e 	mov    0x3efe5ed5(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8101913b:	48 8d 98 08 03 00 00 	lea    0x308(%rax),%rbx
ffffffff81019142:	48 89 df             	mov    %rbx,%rdi
ffffffff81019145:	e8 f8 de ff ff       	callq  ffffffff81017042 <_ZN5Quota9hit_limitEm>
ffffffff8101914a:	84 c0                	test   %al,%al
ffffffff8101914c:	74 05                	je     ffffffff81019153 <_ZN2Ec13sys_create_pdEv+0x2f>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu (%lu)", __func__, __LINE__, Pd::current->quota.usage(), Pd::current->quota.limit(), r);

        if (Ec::current->pt_oom && call)
            Ec::current->oom_call_cpu (Ec::current->pt_oom, Ec::current->pt_oom->id, C, C);

        sys_finish<Sys_regs::QUO_OOM>();
ffffffff8101914e:	e8 79 f2 ff ff       	callq  ffffffff810183cc <_ZN2Ec10sys_finishILN8Sys_regs6StatusE9ELb0EEEvv>

void Ec::sys_create_pd()
{
    check<sys_create_pd>(0, false);

    Sys_create_pd *r = static_cast<Sys_create_pd *>(current->sys_regs());
ffffffff81019153:	4c 8b 25 ae 5e fe 3e 	mov    0x3efe5eae(%rip),%r12        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8101915a:	48 8d 6c 24 07       	lea    0x7(%rsp),%rbp
ffffffff8101915f:	49 8b 8c 24 f0 00 00 	mov    0xf0(%r12),%rcx
ffffffff81019166:	00 
{
    private:
        ALWAYS_INLINE
        static inline mword idx_to_virt (unsigned long idx)
        {
            return SPC_LOCAL_OBJ + (idx % caps) * sizeof (Capability);
ffffffff81019167:	48 89 c8             	mov    %rcx,%rax
ffffffff8101916a:	25 ff ff ff 03       	and    $0x3ffffff,%eax
        static unsigned const caps = (END_SPACE_LIM - SPC_LOCAL_OBJ) / sizeof (Capability);

        ALWAYS_INLINE
        static inline Capability lookup (unsigned long idx)
        {
            return *reinterpret_cast<Capability *>(idx_to_virt (idx));
ffffffff8101916f:	4c 8b 2c c5 00 00 00 	mov    -0x20000000(,%rax,8),%r13
ffffffff81019176:	e0 
ffffffff81019177:	4d 89 ee             	mov    %r13,%r14
ffffffff8101917a:	49 83 e6 e0          	and    $0xffffffffffffffe0,%r14
ffffffff8101917e:	74 10                	je     ffffffff81019190 <_ZN2Ec13sys_create_pdEv+0x6c>

    trace (TRACE_SYSCALL, "EC:%p SYS_CREATE PD:%#lx", current, r->sel());

    Capability cap = Space_obj::lookup (r->pd());
    if (EXPECT_FALSE (cap.obj()->type() != Kobject::PD) || !(cap.prm() & 1UL << Kobject::PD)) {
ffffffff81019180:	41 80 be 88 00 00 00 	cmpb   $0x0,0x88(%r14)
ffffffff81019187:	00 
ffffffff81019188:	75 06                	jne    ffffffff81019190 <_ZN2Ec13sys_create_pdEv+0x6c>
ffffffff8101918a:	41 f6 c5 01          	test   $0x1,%r13b
ffffffff8101918e:	75 36                	jne    ffffffff810191c6 <_ZN2Ec13sys_create_pdEv+0xa2>
        trace (TRACE_ERROR, "%s: Non-PD CAP (%#lx)", __func__, r->pd());
ffffffff81019190:	8b 05 6e 5e fe 3e    	mov    0x3efe5e6e(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81019196:	48 81 e5 00 f0 ff ff 	and    $0xfffffffffffff000,%rbp
ffffffff8101919d:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff810191a1:	48 81 fd 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rbp
ffffffff810191a8:	48 c7 c2 c8 11 02 81 	mov    $0xffffffff810211c8,%rdx
ffffffff810191af:	48 c7 c7 50 0d 02 81 	mov    $0xffffffff81020d50,%rdi
ffffffff810191b6:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff810191ba:	31 c0                	xor    %eax,%eax
ffffffff810191bc:	e8 cb 8e fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff810191c1:	e9 33 01 00 00       	jmpq   ffffffff810192f9 <_ZN2Ec13sys_create_pdEv+0x1d5>
ffffffff810191c6:	49 8b 84 24 20 01 00 	mov    0x120(%r12),%rax
ffffffff810191cd:	00 

        ALWAYS_INLINE
        inline Crd crd() const { return Crd (ARG_3); }

        ALWAYS_INLINE
        inline unsigned long limit_lower() const { return ARG_4 & (~0UL >> (sizeof(mword) * 4)); }
ffffffff810191ce:	89 c2                	mov    %eax,%edx

        ALWAYS_INLINE
        inline unsigned long limit_upper() const { return ARG_4 >> (sizeof(mword) * 4); }
ffffffff810191d0:	48 c1 e8 20          	shr    $0x20,%rax
        sys_finish<Sys_regs::BAD_CAP>();
    }
    Pd * pd_src = static_cast<Pd *>(cap.obj());

    if (r->limit_lower() > r->limit_upper())
ffffffff810191d4:	48 39 c2             	cmp    %rax,%rdx
ffffffff810191d7:	76 05                	jbe    ffffffff810191de <_ZN2Ec13sys_create_pdEv+0xba>
        sys_finish<Sys_regs::BAD_PAR>();
ffffffff810191d9:	e8 c2 fe ff ff       	callq  ffffffff810190a0 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE5ELb0EEEvv>

    if (pd_src->quota.hit_limit(1)) {
ffffffff810191de:	49 81 c6 08 03 00 00 	add    $0x308,%r14
ffffffff810191e5:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff810191ea:	4c 89 f7             	mov    %r14,%rdi
ffffffff810191ed:	e8 50 de ff ff       	callq  ffffffff81017042 <_ZN5Quota9hit_limitEm>
ffffffff810191f2:	84 c0                	test   %al,%al
ffffffff810191f4:	0f 85 54 ff ff ff    	jne    ffffffff8101914e <_ZN2Ec13sys_create_pdEv+0x2a>

class Sys_create_pd : public Sys_regs
{
    public:
        ALWAYS_INLINE
        inline unsigned long sel() const { return ARG_1 >> 8; }
ffffffff810191fa:	4d 8b bc 24 e8 00 00 	mov    0xe8(%r12),%r15
ffffffff81019201:	00 
        void xlt_crd (Pd *, Crd, Crd &);
        void del_crd (Pd *, Crd, Crd &, mword = 0, mword = 0);
        void rev_crd (Crd, bool, bool, bool);

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
ffffffff81019202:	48 89 de             	mov    %rbx,%rsi
ffffffff81019205:	48 c7 c7 d0 3f 16 81 	mov    $0xffffffff81163fd0,%rdi
ffffffff8101920c:	e8 1d c7 ff ff       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu", __func__, __LINE__, pd_src->quota.usage(), pd_src->quota.limit());
        sys_finish<Sys_regs::QUO_OOM>();
    }

    Pd *pd = new (Pd::current->quota) Pd (Pd::current, r->sel(), cap.prm());
ffffffff81019211:	48 8b 35 f8 5d fe 3e 	mov    0x3efe5df8(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81019218:	4c 89 e9             	mov    %r13,%rcx
ffffffff8101921b:	48 89 c7             	mov    %rax,%rdi
ffffffff8101921e:	49 c1 ef 08          	shr    $0x8,%r15
ffffffff81019222:	83 e1 1f             	and    $0x1f,%ecx
ffffffff81019225:	48 89 c3             	mov    %rax,%rbx
ffffffff81019228:	4c 89 fa             	mov    %r15,%rdx

    if (!pd->quota.set_limit(r->limit_lower(), r->limit_upper(), pd_src->quota)) {
ffffffff8101922b:	4c 8d ab 08 03 00 00 	lea    0x308(%rbx),%r13
    if (pd_src->quota.hit_limit(1)) {
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu", __func__, __LINE__, pd_src->quota.usage(), pd_src->quota.limit());
        sys_finish<Sys_regs::QUO_OOM>();
    }

    Pd *pd = new (Pd::current->quota) Pd (Pd::current, r->sel(), cap.prm());
ffffffff81019232:	e8 57 6e ff ff       	callq  ffffffff8101008e <_ZN2PdC1EPS_mm>
ffffffff81019237:	4d 8b bc 24 20 01 00 	mov    0x120(%r12),%r15
ffffffff8101923e:	00 
             return true;
        }

        bool set_limit(mword l, mword h, Quota &from)
        {
            if (!from.transfer_to(*this, h))
ffffffff8101923f:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff81019244:	4c 89 ee             	mov    %r13,%rsi
ffffffff81019247:	4c 89 f7             	mov    %r14,%rdi

        ALWAYS_INLINE
        inline unsigned long limit_lower() const { return ARG_4 & (~0UL >> (sizeof(mword) * 4)); }

        ALWAYS_INLINE
        inline unsigned long limit_upper() const { return ARG_4 >> (sizeof(mword) * 4); }
ffffffff8101924a:	4c 89 fa             	mov    %r15,%rdx
ffffffff8101924d:	48 c1 ea 20          	shr    $0x20,%rdx
ffffffff81019251:	e8 cc a4 fe ff       	callq  ffffffff81003722 <_ZN5Quota11transfer_toERS_mb>
ffffffff81019256:	84 c0                	test   %al,%al
ffffffff81019258:	0f 84 d1 00 00 00    	je     ffffffff8101932f <_ZN2Ec13sys_create_pdEv+0x20b>

        ALWAYS_INLINE
        inline Crd crd() const { return Crd (ARG_3); }

        ALWAYS_INLINE
        inline unsigned long limit_lower() const { return ARG_4 & (~0UL >> (sizeof(mword) * 4)); }
ffffffff8101925e:	41 83 e7 ff          	and    $0xffffffff,%r15d
        trace (0, "Insufficient kernel memory for creating new PD");
        delete pd;
        sys_finish<Sys_regs::BAD_PAR>();
    }

    if (!Space_obj::insert_root (pd->quota, pd)) {
ffffffff81019262:	48 89 de             	mov    %rbx,%rsi
ffffffff81019265:	4c 89 ef             	mov    %r13,%rdi
ffffffff81019268:	4c 89 bb 28 03 00 00 	mov    %r15,0x328(%rbx)
ffffffff8101926f:	e8 f6 d7 ff ff       	callq  ffffffff81016a6a <_ZN9Space_obj11insert_rootER5QuotaP7Kobject>
ffffffff81019274:	84 c0                	test   %al,%al
ffffffff81019276:	0f 85 82 00 00 00    	jne    ffffffff810192fe <_ZN2Ec13sys_create_pdEv+0x1da>
        trace (TRACE_ERROR, "%s: Non-NULL CAP (%#lx)", __func__, r->sel());
ffffffff8101927c:	8b 05 82 5d fe 3e    	mov    0x3efe5d82(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>

class Sys_create_pd : public Sys_regs
{
    public:
        ALWAYS_INLINE
        inline unsigned long sel() const { return ARG_1 >> 8; }
ffffffff81019282:	49 8b 8c 24 e8 00 00 	mov    0xe8(%r12),%rcx
ffffffff81019289:	00 
ffffffff8101928a:	48 81 e5 00 f0 ff ff 	and    $0xfffffffffffff000,%rbp
ffffffff81019291:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81019295:	48 c7 c2 c8 11 02 81 	mov    $0xffffffff810211c8,%rdx
ffffffff8101929c:	48 c7 c7 a4 0d 02 81 	mov    $0xffffffff81020da4,%rdi
ffffffff810192a3:	48 c1 e9 08          	shr    $0x8,%rcx
ffffffff810192a7:	48 81 fd 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rbp
ffffffff810192ae:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff810192b2:	31 c0                	xor    %eax,%eax
ffffffff810192b4:	e8 d3 8d fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
        delete pd;
ffffffff810192b9:	48 89 df             	mov    %rbx,%rdi
ffffffff810192bc:	e8 67 7d ff ff       	callq  ffffffff81011028 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff810192c1:	48 8b 43 50          	mov    0x50(%rbx),%rax
ffffffff810192c5:	31 d2                	xor    %edx,%edx

            pd_del->quota.free_up(pd_to->quota);
ffffffff810192c7:	4c 89 ef             	mov    %r13,%rdi

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff810192ca:	48 8d 88 08 fd ff ff 	lea    -0x2f8(%rax),%rcx
ffffffff810192d1:	48 85 c0             	test   %rax,%rax
ffffffff810192d4:	48 0f 45 d1          	cmovne %rcx,%rdx

            pd_del->quota.free_up(pd_to->quota);
ffffffff810192d8:	48 8d aa 08 03 00 00 	lea    0x308(%rdx),%rbp
ffffffff810192df:	48 89 ee             	mov    %rbp,%rsi
ffffffff810192e2:	e8 dd a2 fe ff       	callq  ffffffff810035c4 <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
ffffffff810192e7:	48 89 ea             	mov    %rbp,%rdx
ffffffff810192ea:	48 89 de             	mov    %rbx,%rsi
ffffffff810192ed:	48 c7 c7 d0 3f 16 81 	mov    $0xffffffff81163fd0,%rdi
ffffffff810192f4:	e8 71 c7 ff ff       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
        sys_finish<Sys_regs::BAD_CAP>();
ffffffff810192f9:	e8 36 ed ff ff       	callq  ffffffff81018034 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>
    }

    Crd crd = r->crd();
ffffffff810192fe:	49 8b 84 24 10 01 00 	mov    0x110(%r12),%rax
ffffffff81019305:	00 
    pd->del_crd (Pd::current, Crd (Crd::OBJ), crd);
ffffffff81019306:	48 8b 35 03 5d fe 3e 	mov    0x3efe5d03(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8101930d:	48 8d 4c 24 08       	lea    0x8(%rsp),%rcx
ffffffff81019312:	45 31 c9             	xor    %r9d,%r9d
ffffffff81019315:	45 31 c0             	xor    %r8d,%r8d
ffffffff81019318:	ba ff 0f 00 00       	mov    $0xfff,%edx
ffffffff8101931d:	48 89 df             	mov    %rbx,%rdi
        trace (TRACE_ERROR, "%s: Non-NULL CAP (%#lx)", __func__, r->sel());
        delete pd;
        sys_finish<Sys_regs::BAD_CAP>();
    }

    Crd crd = r->crd();
ffffffff81019320:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    pd->del_crd (Pd::current, Crd (Crd::OBJ), crd);
ffffffff81019325:	e8 ea 8a ff ff       	callq  ffffffff81011e14 <_ZN2Pd7del_crdEPS_3CrdRS1_mm>

    sys_finish<Sys_regs::SUCCESS>();
ffffffff8101932a:	e8 29 dd ff ff       	callq  ffffffff81017058 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb0EEEvv>
    }

    Pd *pd = new (Pd::current->quota) Pd (Pd::current, r->sel(), cap.prm());

    if (!pd->quota.set_limit(r->limit_lower(), r->limit_upper(), pd_src->quota)) {
        trace (0, "Insufficient kernel memory for creating new PD");
ffffffff8101932f:	8b 35 cf 5c fe 3e    	mov    0x3efe5ccf(%rip),%esi        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81019335:	48 81 e5 00 f0 ff ff 	and    $0xfffffffffffff000,%rbp
ffffffff8101933c:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
ffffffff81019343:	48 81 fd 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rbp
ffffffff8101934a:	48 c7 c7 d5 0e 02 81 	mov    $0xffffffff81020ed5,%rdi
ffffffff81019351:	48 0f 45 f0          	cmovne %rax,%rsi
ffffffff81019355:	31 c0                	xor    %eax,%eax
ffffffff81019357:	e8 30 8d fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
        delete pd;
ffffffff8101935c:	48 85 db             	test   %rbx,%rbx
ffffffff8101935f:	0f 84 74 fe ff ff    	je     ffffffff810191d9 <_ZN2Ec13sys_create_pdEv+0xb5>
ffffffff81019365:	48 89 df             	mov    %rbx,%rdi
ffffffff81019368:	e8 bb 7c ff ff       	callq  ffffffff81011028 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff8101936d:	48 8b 43 50          	mov    0x50(%rbx),%rax
ffffffff81019371:	31 d2                	xor    %edx,%edx

            pd_del->quota.free_up(pd_to->quota);
ffffffff81019373:	4c 89 ef             	mov    %r13,%rdi

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff81019376:	48 8d 88 08 fd ff ff 	lea    -0x2f8(%rax),%rcx
ffffffff8101937d:	48 85 c0             	test   %rax,%rax
ffffffff81019380:	48 0f 45 d1          	cmovne %rcx,%rdx

            pd_del->quota.free_up(pd_to->quota);
ffffffff81019384:	48 8d aa 08 03 00 00 	lea    0x308(%rdx),%rbp
ffffffff8101938b:	48 89 ee             	mov    %rbp,%rsi
ffffffff8101938e:	e8 31 a2 fe ff       	callq  ffffffff810035c4 <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
ffffffff81019393:	48 89 ea             	mov    %rbp,%rdx
ffffffff81019396:	48 89 de             	mov    %rbx,%rsi
ffffffff81019399:	48 c7 c7 d0 3f 16 81 	mov    $0xffffffff81163fd0,%rdi
ffffffff810193a0:	e8 c5 c6 ff ff       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
ffffffff810193a5:	e9 2f fe ff ff       	jmpq   ffffffff810191d9 <_ZN2Ec13sys_create_pdEv+0xb5>

ffffffff810193aa <_ZN2Ec11sys_pd_ctrlEv>:

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_pd_ctrl()
{
ffffffff810193aa:	53                   	push   %rbx
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
ffffffff810193ab:	be 01 00 00 00       	mov    $0x1,%esi

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_pd_ctrl()
{
ffffffff810193b0:	48 83 ec 10          	sub    $0x10,%rsp
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
ffffffff810193b4:	48 8b 05 55 5c fe 3e 	mov    0x3efe5c55(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff810193bb:	48 8d b8 08 03 00 00 	lea    0x308(%rax),%rdi
ffffffff810193c2:	e8 7b dc ff ff       	callq  ffffffff81017042 <_ZN5Quota9hit_limitEm>
ffffffff810193c7:	84 c0                	test   %al,%al
ffffffff810193c9:	48 8b 3d 38 5c fe 3e 	mov    0x3efe5c38(%rip),%rdi        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff810193d0:	74 27                	je     ffffffff810193f9 <_ZN2Ec11sys_pd_ctrlEv+0x4f>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu (%lu)", __func__, __LINE__, Pd::current->quota.usage(), Pd::current->quota.limit(), r);

        if (Ec::current->pt_oom && call)
ffffffff810193d2:	48 8b b7 38 03 00 00 	mov    0x338(%rdi),%rsi
ffffffff810193d9:	48 85 f6             	test   %rsi,%rsi
ffffffff810193dc:	74 16                	je     ffffffff810193f4 <_ZN2Ec11sys_pd_ctrlEv+0x4a>
            Ec::current->oom_call_cpu (Ec::current->pt_oom, Ec::current->pt_oom->id, C, C);
ffffffff810193de:	48 8b 96 a8 00 00 00 	mov    0xa8(%rsi),%rdx
ffffffff810193e5:	49 c7 c0 aa 93 01 81 	mov    $0xffffffff810193aa,%r8
ffffffff810193ec:	4c 89 c1             	mov    %r8,%rcx
ffffffff810193ef:	e8 a6 67 ff ff       	callq  ffffffff8100fb9a <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_>

        sys_finish<Sys_regs::QUO_OOM>();
ffffffff810193f4:	e8 d3 ef ff ff       	callq  ffffffff810183cc <_ZN2Ec10sys_finishILN8Sys_regs6StatusE9ELb0EEEvv>
ffffffff810193f9:	48 8b 87 e8 00 00 00 	mov    0xe8(%rdi),%rax

class Sys_pd_ctrl : public Sys_regs
{
    public:
        ALWAYS_INLINE
        inline unsigned long src() const { return ARG_1 >> 8; }
ffffffff81019400:	48 89 c1             	mov    %rax,%rcx
ffffffff81019403:	48 c1 e9 08          	shr    $0x8,%rcx
{
    private:
        ALWAYS_INLINE
        static inline mword idx_to_virt (unsigned long idx)
        {
            return SPC_LOCAL_OBJ + (idx % caps) * sizeof (Capability);
ffffffff81019407:	48 89 ca             	mov    %rcx,%rdx
ffffffff8101940a:	81 e2 ff ff ff 03    	and    $0x3ffffff,%edx
ffffffff81019410:	48 8b 1c d5 00 00 00 	mov    -0x20000000(,%rdx,8),%rbx
ffffffff81019417:	e0 
ffffffff81019418:	48 83 e3 e0          	and    $0xffffffffffffffe0,%rbx
ffffffff8101941c:	74 09                	je     ffffffff81019427 <_ZN2Ec11sys_pd_ctrlEv+0x7d>
    check<sys_pd_ctrl>(1);

    Sys_pd_ctrl *r = static_cast<Sys_pd_ctrl *>(current->sys_regs());

    Capability cap = Space_obj::lookup (r->src());
    if (EXPECT_FALSE (cap.obj()->type() != Kobject::PD)) {
ffffffff8101941e:	80 bb 88 00 00 00 00 	cmpb   $0x0,0x88(%rbx)
ffffffff81019425:	74 2f                	je     ffffffff81019456 <_ZN2Ec11sys_pd_ctrlEv+0xac>
        trace (TRACE_ERROR, "%s: Bad src PD CAP (%#lx)", __func__, r->src());
ffffffff81019427:	8b 15 d7 5b fe 3e    	mov    0x3efe5bd7(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8101942d:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff81019432:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81019436:	48 c7 c7 0b 0f 02 81 	mov    $0xffffffff81020f0b,%rdi
ffffffff8101943d:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81019443:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff81019449:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff8101944d:	48 c7 c2 38 11 02 81 	mov    $0xffffffff81021138,%rdx
ffffffff81019454:	eb 78                	jmp    ffffffff810194ce <_ZN2Ec11sys_pd_ctrlEv+0x124>
        sys_finish<Sys_regs::BAD_CAP>();
    }
    Pd *src = static_cast<Pd *>(cap.obj());

    if (r->dbg()) {
ffffffff81019456:	a8 20                	test   $0x20,%al
ffffffff81019458:	74 21                	je     ffffffff8101947b <_ZN2Ec11sys_pd_ctrlEv+0xd1>
ffffffff8101945a:	48 8b 83 10 03 00 00 	mov    0x310(%rbx),%rax
ffffffff81019461:	48 8b 93 20 03 00 00 	mov    0x320(%rbx),%rdx

        ALWAYS_INLINE
        inline void dump (mword l, mword u)
        {
            ARG_2 = l;
            ARG_3 = u;
ffffffff81019468:	48 89 87 10 01 00 00 	mov    %rax,0x110(%rdi)
        inline unsigned long tra() const { return ARG_3; }

        ALWAYS_INLINE
        inline void dump (mword l, mword u)
        {
            ARG_2 = l;
ffffffff8101946f:	48 89 97 f0 00 00 00 	mov    %rdx,0xf0(%rdi)
ffffffff81019476:	e9 be 00 00 00       	jmpq   ffffffff81019539 <_ZN2Ec11sys_pd_ctrlEv+0x18f>
ffffffff8101947b:	48 8b 8f f0 00 00 00 	mov    0xf0(%rdi),%rcx
ffffffff81019482:	48 89 c8             	mov    %rcx,%rax
ffffffff81019485:	25 ff ff ff 03       	and    $0x3ffffff,%eax
ffffffff8101948a:	48 8b 34 c5 00 00 00 	mov    -0x20000000(,%rax,8),%rsi
ffffffff81019491:	e0 
ffffffff81019492:	48 83 e6 e0          	and    $0xffffffffffffffe0,%rsi
ffffffff81019496:	74 09                	je     ffffffff810194a1 <_ZN2Ec11sys_pd_ctrlEv+0xf7>
        r->dump(src->quota.limit(), src->quota.usage());
        sys_finish<Sys_regs::SUCCESS>();
    }

    Capability cap_pd = Space_obj::lookup (r->dst());
    if (EXPECT_FALSE (cap_pd.obj()->type() != Kobject::PD)) {
ffffffff81019498:	80 be 88 00 00 00 00 	cmpb   $0x0,0x88(%rsi)
ffffffff8101949f:	74 39                	je     ffffffff810194da <_ZN2Ec11sys_pd_ctrlEv+0x130>
        trace (TRACE_ERROR, "%s: Bad dst PD CAP (%#lx)", __func__, r->dst());
ffffffff810194a1:	8b 15 5d 5b fe 3e    	mov    0x3efe5b5d(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff810194a7:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff810194ac:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff810194b0:	48 c7 c7 2c 0f 02 81 	mov    $0xffffffff81020f2c,%rdi
ffffffff810194b7:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff810194bd:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff810194c3:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff810194c7:	48 c7 c2 38 11 02 81 	mov    $0xffffffff81021138,%rdx
ffffffff810194ce:	31 c0                	xor    %eax,%eax
ffffffff810194d0:	e8 b7 8b fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_CAP>();
ffffffff810194d5:	e8 5a eb ff ff       	callq  ffffffff81018034 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>
    }
    Pd *dst = static_cast<Pd *>(cap_pd.obj());

    if (!src->quota.transfer_to(dst->quota, r->tra())) {
ffffffff810194da:	48 8b 97 10 01 00 00 	mov    0x110(%rdi),%rdx
ffffffff810194e1:	48 8d bb 08 03 00 00 	lea    0x308(%rbx),%rdi
ffffffff810194e8:	48 81 c6 08 03 00 00 	add    $0x308,%rsi
ffffffff810194ef:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff810194f4:	e8 29 a2 fe ff       	callq  ffffffff81003722 <_ZN5Quota11transfer_toERS_mb>
ffffffff810194f9:	84 c0                	test   %al,%al
ffffffff810194fb:	75 3c                	jne    ffffffff81019539 <_ZN2Ec11sys_pd_ctrlEv+0x18f>
        trace (TRACE_ERROR, "%s: PD %p has insufficient kernel memory quota", __func__, src);
ffffffff810194fd:	8b 15 01 5b fe 3e    	mov    0x3efe5b01(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81019503:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff81019508:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff8101950c:	48 89 d9             	mov    %rbx,%rcx
ffffffff8101950f:	48 c7 c7 4d 0f 02 81 	mov    $0xffffffff81020f4d,%rdi
ffffffff81019516:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8101951c:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff81019522:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff81019526:	48 c7 c2 38 11 02 81 	mov    $0xffffffff81021138,%rdx
ffffffff8101952d:	31 c0                	xor    %eax,%eax
ffffffff8101952f:	e8 58 8b fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_PAR>();
ffffffff81019534:	e8 67 fb ff ff       	callq  ffffffff810190a0 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE5ELb0EEEvv>
    }

    sys_finish<Sys_regs::SUCCESS>();
ffffffff81019539:	e8 1a db ff ff       	callq  ffffffff81017058 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb0EEEvv>

ffffffff8101953e <_ZN2Ec13sys_create_scEv>:

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_create_sc()
{
ffffffff8101953e:	41 57                	push   %r15
ffffffff81019540:	41 56                	push   %r14
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
ffffffff81019542:	31 f6                	xor    %esi,%esi

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_create_sc()
{
ffffffff81019544:	41 55                	push   %r13
ffffffff81019546:	41 54                	push   %r12
ffffffff81019548:	55                   	push   %rbp
ffffffff81019549:	53                   	push   %rbx
ffffffff8101954a:	48 83 ec 28          	sub    $0x28,%rsp
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
ffffffff8101954e:	48 8b 05 bb 5a fe 3e 	mov    0x3efe5abb(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81019555:	48 8d b8 08 03 00 00 	lea    0x308(%rax),%rdi
ffffffff8101955c:	e8 e1 da ff ff       	callq  ffffffff81017042 <_ZN5Quota9hit_limitEm>
ffffffff81019561:	84 c0                	test   %al,%al
ffffffff81019563:	74 05                	je     ffffffff8101956a <_ZN2Ec13sys_create_scEv+0x2c>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu (%lu)", __func__, __LINE__, Pd::current->quota.usage(), Pd::current->quota.limit(), r);

        if (Ec::current->pt_oom && call)
            Ec::current->oom_call_cpu (Ec::current->pt_oom, Ec::current->pt_oom->id, C, C);

        sys_finish<Sys_regs::QUO_OOM>();
ffffffff81019565:	e8 62 ee ff ff       	callq  ffffffff810183cc <_ZN2Ec10sys_finishILN8Sys_regs6StatusE9ELb0EEEvv>

void Ec::sys_create_sc()
{
    check<sys_create_sc>(0, false);

    Sys_create_sc *r = static_cast<Sys_create_sc *>(current->sys_regs());
ffffffff8101956a:	4c 8b 35 97 5a fe 3e 	mov    0x3efe5a97(%rip),%r14        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81019571:	48 8d 5c 24 17       	lea    0x17(%rsp),%rbx
ffffffff81019576:	49 8b 8e f0 00 00 00 	mov    0xf0(%r14),%rcx
ffffffff8101957d:	48 89 c8             	mov    %rcx,%rax
ffffffff81019580:	25 ff ff ff 03       	and    $0x3ffffff,%eax
        static unsigned const caps = (END_SPACE_LIM - SPC_LOCAL_OBJ) / sizeof (Capability);

        ALWAYS_INLINE
        static inline Capability lookup (unsigned long idx)
        {
            return *reinterpret_cast<Capability *>(idx_to_virt (idx));
ffffffff81019585:	48 8b 04 c5 00 00 00 	mov    -0x20000000(,%rax,8),%rax
ffffffff8101958c:	e0 
ffffffff8101958d:	49 89 c4             	mov    %rax,%r12
ffffffff81019590:	49 83 e4 e0          	and    $0xffffffffffffffe0,%r12
ffffffff81019594:	74 0f                	je     ffffffff810195a5 <_ZN2Ec13sys_create_scEv+0x67>

    trace (TRACE_SYSCALL, "EC:%p SYS_CREATE SC:%#lx EC:%#lx P:%#x Q:%#x", current, r->sel(), r->ec(), r->qpd().prio(), r->qpd().quantum());

    Capability cap = Space_obj::lookup (r->pd());
    if (EXPECT_FALSE (cap.obj()->type() != Kobject::PD) || !(cap.prm() & 1UL << Kobject::SC)) {
ffffffff81019596:	41 80 bc 24 88 00 00 	cmpb   $0x0,0x88(%r12)
ffffffff8101959d:	00 00 
ffffffff8101959f:	75 04                	jne    ffffffff810195a5 <_ZN2Ec13sys_create_scEv+0x67>
ffffffff810195a1:	a8 04                	test   $0x4,%al
ffffffff810195a3:	75 2c                	jne    ffffffff810195d1 <_ZN2Ec13sys_create_scEv+0x93>
        trace (TRACE_ERROR, "%s: Non-PD CAP (%#lx)", __func__, r->pd());
ffffffff810195a5:	8b 05 59 5a fe 3e    	mov    0x3efe5a59(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff810195ab:	48 81 e3 00 f0 ff ff 	and    $0xfffffffffffff000,%rbx
ffffffff810195b2:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff810195b6:	48 81 fb 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rbx
ffffffff810195bd:	48 c7 c2 a8 11 02 81 	mov    $0xffffffff810211a8,%rdx
ffffffff810195c4:	48 c7 c7 50 0d 02 81 	mov    $0xffffffff81020d50,%rdi
ffffffff810195cb:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff810195cf:	eb 74                	jmp    ffffffff81019645 <_ZN2Ec13sys_create_scEv+0x107>
        sys_finish<Sys_regs::BAD_CAP>();
    }
    Pd *pd = static_cast<Pd *>(cap.obj());

    if (pd->quota.hit_limit(2)) {
ffffffff810195d1:	49 81 c4 08 03 00 00 	add    $0x308,%r12
ffffffff810195d8:	be 02 00 00 00       	mov    $0x2,%esi
ffffffff810195dd:	4c 89 e7             	mov    %r12,%rdi
ffffffff810195e0:	e8 5d da ff ff       	callq  ffffffff81017042 <_ZN5Quota9hit_limitEm>
ffffffff810195e5:	84 c0                	test   %al,%al
ffffffff810195e7:	0f 85 78 ff ff ff    	jne    ffffffff81019565 <_ZN2Ec13sys_create_scEv+0x27>
ffffffff810195ed:	49 8b 8e 10 01 00 00 	mov    0x110(%r14),%rcx
{
    private:
        ALWAYS_INLINE
        static inline mword idx_to_virt (unsigned long idx)
        {
            return SPC_LOCAL_OBJ + (idx % caps) * sizeof (Capability);
ffffffff810195f4:	48 89 c8             	mov    %rcx,%rax
ffffffff810195f7:	25 ff ff ff 03       	and    $0x3ffffff,%eax
        static unsigned const caps = (END_SPACE_LIM - SPC_LOCAL_OBJ) / sizeof (Capability);

        ALWAYS_INLINE
        static inline Capability lookup (unsigned long idx)
        {
            return *reinterpret_cast<Capability *>(idx_to_virt (idx));
ffffffff810195fc:	48 8b 04 c5 00 00 00 	mov    -0x20000000(,%rax,8),%rax
ffffffff81019603:	e0 
ffffffff81019604:	49 89 c7             	mov    %rax,%r15
ffffffff81019607:	49 83 e7 e0          	and    $0xffffffffffffffe0,%r15
ffffffff8101960b:	74 0e                	je     ffffffff8101961b <_ZN2Ec13sys_create_scEv+0xdd>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu", __func__, __LINE__, pd->quota.usage(), pd->quota.limit());
        sys_finish<Sys_regs::QUO_OOM>();
    }

    Capability cap_sc = Space_obj::lookup (r->ec());
    if (EXPECT_FALSE (cap_sc.obj()->type() != Kobject::EC) || !(cap_sc.prm() & 1UL << Kobject::SC)) {
ffffffff8101960d:	41 80 bf 88 00 00 00 	cmpb   $0x1,0x88(%r15)
ffffffff81019614:	01 
ffffffff81019615:	75 04                	jne    ffffffff8101961b <_ZN2Ec13sys_create_scEv+0xdd>
ffffffff81019617:	a8 04                	test   $0x4,%al
ffffffff81019619:	75 36                	jne    ffffffff81019651 <_ZN2Ec13sys_create_scEv+0x113>
        trace (TRACE_ERROR, "%s: Non-EC CAP (%#lx)", __func__, r->ec());
ffffffff8101961b:	8b 05 e3 59 fe 3e    	mov    0x3efe59e3(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81019621:	48 81 e3 00 f0 ff ff 	and    $0xfffffffffffff000,%rbx
ffffffff81019628:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff8101962c:	48 81 fb 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rbx
ffffffff81019633:	48 c7 c2 a8 11 02 81 	mov    $0xffffffff810211a8,%rdx
ffffffff8101963a:	48 c7 c7 6d 0d 02 81 	mov    $0xffffffff81020d6d,%rdi
ffffffff81019641:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff81019645:	31 c0                	xor    %eax,%eax
ffffffff81019647:	e8 40 8a fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_CAP>();
ffffffff8101964c:	e8 e3 e9 ff ff       	callq  ffffffff81018034 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>
    }
    Ec *ec = static_cast<Ec *>(cap_sc.obj());

    if (EXPECT_FALSE (!ec->glb)) {
ffffffff81019651:	66 41 83 bf f2 02 00 	cmpw   $0x0,0x2f2(%r15)
ffffffff81019658:	00 00 
ffffffff8101965a:	75 33                	jne    ffffffff8101968f <_ZN2Ec13sys_create_scEv+0x151>
        trace (TRACE_ERROR, "%s: Cannot bind SC", __func__);
ffffffff8101965c:	8b 05 a2 59 fe 3e    	mov    0x3efe59a2(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81019662:	48 81 e3 00 f0 ff ff 	and    $0xfffffffffffff000,%rbx
ffffffff81019669:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff8101966d:	48 81 fb 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rbx
ffffffff81019674:	48 c7 c2 a8 11 02 81 	mov    $0xffffffff810211a8,%rdx
ffffffff8101967b:	48 c7 c7 83 0f 02 81 	mov    $0xffffffff81020f83,%rdi
ffffffff81019682:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff81019686:	31 c0                	xor    %eax,%eax
ffffffff81019688:	e8 ff 89 fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff8101968d:	eb bd                	jmp    ffffffff8101964c <_ZN2Ec13sys_create_scEv+0x10e>
ffffffff8101968f:	4d 8b ae 20 01 00 00 	mov    0x120(%r14),%r13
        }

        ALWAYS_INLINE
        inline unsigned prio() const
        {
            return static_cast<unsigned>(val & 0xff);
ffffffff81019696:	45 0f b6 cd          	movzbl %r13b,%r9d
        sys_finish<Sys_regs::BAD_CAP>();
    }

    if (EXPECT_FALSE (!r->qpd().prio() || !r->qpd().quantum() | (r->qpd().prio() >= Sc::priorities))) {
ffffffff8101969a:	45 85 c9             	test   %r9d,%r9d
ffffffff8101969d:	0f 84 dc 00 00 00    	je     ffffffff8101977f <_ZN2Ec13sys_create_scEv+0x241>
        inline explicit Qpd (mword v) : val (v) {}

        ALWAYS_INLINE
        inline unsigned quantum() const
        {
            return static_cast<unsigned>(val >> 12);
ffffffff810196a3:	49 c1 ed 0c          	shr    $0xc,%r13
ffffffff810196a7:	41 83 f9 7f          	cmp    $0x7f,%r9d
ffffffff810196ab:	0f 87 ce 00 00 00    	ja     ffffffff8101977f <_ZN2Ec13sys_create_scEv+0x241>
ffffffff810196b1:	45 85 ed             	test   %r13d,%r13d
ffffffff810196b4:	0f 84 c5 00 00 00    	je     ffffffff8101977f <_ZN2Ec13sys_create_scEv+0x241>

class Sys_create_sc : public Sys_regs
{
    public:
        ALWAYS_INLINE
        inline unsigned long sel() const { return ARG_1 >> 8; }
ffffffff810196ba:	49 8b 96 e8 00 00 00 	mov    0xe8(%r14),%rdx

        NORETURN
        static void schedule (bool = false, bool = true);

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
ffffffff810196c1:	4c 89 e6             	mov    %r12,%rsi
ffffffff810196c4:	48 c7 c7 40 40 16 81 	mov    $0xffffffff81164040,%rdi
ffffffff810196cb:	44 89 4c 24 0c       	mov    %r9d,0xc(%rsp)
ffffffff810196d0:	48 c1 ea 08          	shr    $0x8,%rdx
ffffffff810196d4:	48 89 14 24          	mov    %rdx,(%rsp)
ffffffff810196d8:	e8 51 c2 ff ff       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff810196dd:	48 89 c5             	mov    %rax,%rbp
        trace (TRACE_ERROR, "%s: Invalid QPD", __func__);
        sys_finish<Sys_regs::BAD_PAR>();
    }

    Sc *sc = new (pd->quota) Sc (Pd::current, r->sel(), ec, ec->cpu, r->qpd().prio(), r->qpd().quantum());
ffffffff810196e0:	50                   	push   %rax
ffffffff810196e1:	41 55                	push   %r13
ffffffff810196e3:	45 0f b7 87 f0 02 00 	movzwl 0x2f0(%r15),%r8d
ffffffff810196ea:	00 
ffffffff810196eb:	44 8b 4c 24 1c       	mov    0x1c(%rsp),%r9d
ffffffff810196f0:	4c 89 f9             	mov    %r15,%rcx
ffffffff810196f3:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
ffffffff810196f8:	48 8b 35 11 59 fe 3e 	mov    0x3efe5911(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff810196ff:	48 89 ef             	mov    %rbp,%rdi
ffffffff81019702:	e8 f7 ae ff ff       	callq  ffffffff810145fe <_ZN2ScC1EP2PdmP2Ecjjj>
    if (!Space_obj::insert_root (pd->quota, sc)) {
ffffffff81019707:	48 89 ee             	mov    %rbp,%rsi
ffffffff8101970a:	4c 89 e7             	mov    %r12,%rdi
ffffffff8101970d:	e8 58 d3 ff ff       	callq  ffffffff81016a6a <_ZN9Space_obj11insert_rootER5QuotaP7Kobject>
ffffffff81019712:	84 c0                	test   %al,%al
ffffffff81019714:	5a                   	pop    %rdx
ffffffff81019715:	59                   	pop    %rcx
ffffffff81019716:	75 5a                	jne    ffffffff81019772 <_ZN2Ec13sys_create_scEv+0x234>
        trace (TRACE_ERROR, "%s: Non-NULL CAP (%#lx)", __func__, r->sel());
ffffffff81019718:	8b 05 e6 58 fe 3e    	mov    0x3efe58e6(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8101971e:	49 8b 8e e8 00 00 00 	mov    0xe8(%r14),%rcx
ffffffff81019725:	48 81 e3 00 f0 ff ff 	and    $0xfffffffffffff000,%rbx
ffffffff8101972c:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81019730:	48 c7 c2 a8 11 02 81 	mov    $0xffffffff810211a8,%rdx
ffffffff81019737:	48 c7 c7 a4 0d 02 81 	mov    $0xffffffff81020da4,%rdi
ffffffff8101973e:	48 c1 e9 08          	shr    $0x8,%rcx
ffffffff81019742:	48 81 fb 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rbx
ffffffff81019749:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff8101974d:	31 c0                	xor    %eax,%eax
ffffffff8101974f:	e8 38 89 fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
        delete sc;
ffffffff81019754:	48 85 ed             	test   %rbp,%rbp
ffffffff81019757:	0f 84 ef fe ff ff    	je     ffffffff8101964c <_ZN2Ec13sys_create_scEv+0x10e>
ffffffff8101975d:	48 89 ef             	mov    %rbp,%rdi
ffffffff81019760:	e8 fb f3 fe ff       	callq  ffffffff81008b60 <_ZN2ScD1Ev>
ffffffff81019765:	48 89 ef             	mov    %rbp,%rdi
ffffffff81019768:	e8 bd b5 ff ff       	callq  ffffffff81014d2a <_ZN2ScdlEPv>
ffffffff8101976d:	e9 da fe ff ff       	jmpq   ffffffff8101964c <_ZN2Ec13sys_create_scEv+0x10e>
        sys_finish<Sys_regs::BAD_CAP>();
    }

    sc->remote_enqueue();
ffffffff81019772:	48 89 ef             	mov    %rbp,%rdi
ffffffff81019775:	e8 e6 b2 ff ff       	callq  ffffffff81014a60 <_ZN2Sc14remote_enqueueEv>

    sys_finish<Sys_regs::SUCCESS>();
ffffffff8101977a:	e8 d9 d8 ff ff       	callq  ffffffff81017058 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb0EEEvv>
        trace (TRACE_ERROR, "%s: Cannot bind SC", __func__);
        sys_finish<Sys_regs::BAD_CAP>();
    }

    if (EXPECT_FALSE (!r->qpd().prio() || !r->qpd().quantum() | (r->qpd().prio() >= Sc::priorities))) {
        trace (TRACE_ERROR, "%s: Invalid QPD", __func__);
ffffffff8101977f:	8b 35 7f 58 fe 3e    	mov    0x3efe587f(%rip),%esi        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81019785:	48 81 e3 00 f0 ff ff 	and    $0xfffffffffffff000,%rbx
ffffffff8101978c:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
ffffffff81019793:	48 81 fb 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rbx
ffffffff8101979a:	48 c7 c2 a8 11 02 81 	mov    $0xffffffff810211a8,%rdx
ffffffff810197a1:	48 c7 c7 9d 0f 02 81 	mov    $0xffffffff81020f9d,%rdi
ffffffff810197a8:	48 0f 45 f0          	cmovne %rax,%rsi
ffffffff810197ac:	31 c0                	xor    %eax,%eax
ffffffff810197ae:	e8 d9 88 fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_PAR>();
ffffffff810197b3:	e8 e8 f8 ff ff       	callq  ffffffff810190a0 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE5ELb0EEEvv>

ffffffff810197b8 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE7ELb0EEEvv>:
#include "syscall.hpp"
#include "utcb.hpp"
#include "vectors.hpp"

template <Sys_regs::Status S, bool T>
void Ec::sys_finish()
ffffffff810197b8:	53                   	push   %rbx
ffffffff810197b9:	48 83 ec 10          	sub    $0x10,%rsp
{
    if (T)
        current->clr_timeout();

    current->regs.set_status (S);
ffffffff810197bd:	48 8b 05 44 58 fe 3e 	mov    0x3efe5844(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>

    if (current->xcpu_sm)
ffffffff810197c4:	48 83 b8 30 03 00 00 	cmpq   $0x0,0x330(%rax)
ffffffff810197cb:	00 
ffffffff810197cc:	48 c7 80 e8 00 00 00 	movq   $0x7,0xe8(%rax)
ffffffff810197d3:	07 00 00 00 
ffffffff810197d7:	74 05                	je     ffffffff810197de <_ZN2Ec10sys_finishILN8Sys_regs6StatusE7ELb0EEEvv+0x26>
        xcpu_return();
ffffffff810197d9:	e8 98 bb fe ff       	callq  ffffffff81005376 <_ZN2Ec11xcpu_returnEv>

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
ffffffff810197de:	48 8b 1d 2b 58 fe 3e 	mov    0x3efe582b(%rip),%rbx        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff810197e5:	31 f6                	xor    %esi,%esi
ffffffff810197e7:	48 8d bb 08 03 00 00 	lea    0x308(%rbx),%rdi
ffffffff810197ee:	e8 4f d8 ff ff       	callq  ffffffff81017042 <_ZN5Quota9hit_limitEm>
ffffffff810197f3:	84 c0                	test   %al,%al
ffffffff810197f5:	75 05                	jne    ffffffff810197fc <_ZN2Ec10sys_finishILN8Sys_regs6StatusE7ELb0EEEvv+0x44>
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());

    ret_user_sysexit();
ffffffff810197f7:	e8 04 68 fe ff       	callq  ffffffff81000000 <_ZN2Ec16ret_user_sysexitEv>

    if (current->xcpu_sm)
        xcpu_return();

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());
ffffffff810197fc:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff81019801:	8b 35 fd 57 fe 3e    	mov    0x3efe57fd(%rip),%esi        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81019807:	48 8b 8b 20 03 00 00 	mov    0x320(%rbx),%rcx
ffffffff8101980e:	48 8b 93 10 03 00 00 	mov    0x310(%rbx),%rdx
ffffffff81019815:	48 c7 c7 7c 0c 02 81 	mov    $0xffffffff81020c7c,%rdi
ffffffff8101981c:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81019822:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff81019828:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
ffffffff8101982f:	48 0f 45 f0          	cmovne %rax,%rsi
ffffffff81019833:	31 c0                	xor    %eax,%eax
ffffffff81019835:	e8 52 88 fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff8101983a:	eb bb                	jmp    ffffffff810197f7 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE7ELb0EEEvv+0x3f>

ffffffff8101983c <_ZN2Ec11sys_ec_ctrlEv>:

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_ec_ctrl()
{
ffffffff8101983c:	41 54                	push   %r12
ffffffff8101983e:	55                   	push   %rbp
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
ffffffff8101983f:	be 01 00 00 00       	mov    $0x1,%esi

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_ec_ctrl()
{
ffffffff81019844:	53                   	push   %rbx
ffffffff81019845:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
ffffffff8101984c:	48 8b 05 bd 57 fe 3e 	mov    0x3efe57bd(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81019853:	48 8d b8 08 03 00 00 	lea    0x308(%rax),%rdi
ffffffff8101985a:	e8 e3 d7 ff ff       	callq  ffffffff81017042 <_ZN5Quota9hit_limitEm>
ffffffff8101985f:	84 c0                	test   %al,%al
ffffffff81019861:	48 8b 2d a0 57 fe 3e 	mov    0x3efe57a0(%rip),%rbp        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81019868:	74 2a                	je     ffffffff81019894 <_ZN2Ec11sys_ec_ctrlEv+0x58>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu (%lu)", __func__, __LINE__, Pd::current->quota.usage(), Pd::current->quota.limit(), r);

        if (Ec::current->pt_oom && call)
ffffffff8101986a:	48 8b b5 38 03 00 00 	mov    0x338(%rbp),%rsi
ffffffff81019871:	48 85 f6             	test   %rsi,%rsi
ffffffff81019874:	74 19                	je     ffffffff8101988f <_ZN2Ec11sys_ec_ctrlEv+0x53>
            Ec::current->oom_call_cpu (Ec::current->pt_oom, Ec::current->pt_oom->id, C, C);
ffffffff81019876:	48 8b 96 a8 00 00 00 	mov    0xa8(%rsi),%rdx
ffffffff8101987d:	49 c7 c0 3c 98 01 81 	mov    $0xffffffff8101983c,%r8
ffffffff81019884:	48 89 ef             	mov    %rbp,%rdi
ffffffff81019887:	4c 89 c1             	mov    %r8,%rcx
ffffffff8101988a:	e8 0b 63 ff ff       	callq  ffffffff8100fb9a <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_>

        sys_finish<Sys_regs::QUO_OOM>();
ffffffff8101988f:	e8 38 eb ff ff       	callq  ffffffff810183cc <_ZN2Ec10sys_finishILN8Sys_regs6StatusE9ELb0EEEvv>
ffffffff81019894:	48 8b 8d e8 00 00 00 	mov    0xe8(%rbp),%rcx
            BAD_DEV,
            QUO_OOM,
        };

        ALWAYS_INLINE
        inline unsigned flags() const { return ARG_1 >> 4 & 0xf; }
ffffffff8101989b:	48 89 c8             	mov    %rcx,%rax
ffffffff8101989e:	48 c1 e8 04          	shr    $0x4,%rax

        ALWAYS_INLINE
        inline unsigned long cnt() const { return ARG_2; }

        ALWAYS_INLINE
        inline unsigned op() const { return flags() & 0x3; }
ffffffff810198a2:	83 e0 03             	and    $0x3,%eax
{
    check<sys_ec_ctrl>(1);

    Sys_ec_ctrl *r = static_cast<Sys_ec_ctrl *>(current->sys_regs());

    switch (r->op()) {
ffffffff810198a5:	83 f8 02             	cmp    $0x2,%eax
ffffffff810198a8:	0f 84 a0 01 00 00    	je     ffffffff81019a4e <_ZN2Ec11sys_ec_ctrlEv+0x212>
ffffffff810198ae:	83 f8 03             	cmp    $0x3,%eax
ffffffff810198b1:	0f 84 10 02 00 00    	je     ffffffff81019ac7 <_ZN2Ec11sys_ec_ctrlEv+0x28b>
ffffffff810198b7:	ff c8                	dec    %eax
ffffffff810198b9:	0f 84 7d 01 00 00    	je     ffffffff81019a3c <_ZN2Ec11sys_ec_ctrlEv+0x200>

class Sys_ec_ctrl : public Sys_regs
{
    public:
        ALWAYS_INLINE
        inline unsigned long ec() const { return ARG_1 >> 8; }
ffffffff810198bf:	48 c1 e9 08          	shr    $0x8,%rcx
{
    private:
        ALWAYS_INLINE
        static inline mword idx_to_virt (unsigned long idx)
        {
            return SPC_LOCAL_OBJ + (idx % caps) * sizeof (Capability);
ffffffff810198c3:	48 89 c8             	mov    %rcx,%rax
ffffffff810198c6:	25 ff ff ff 03       	and    $0x3ffffff,%eax
        static unsigned const caps = (END_SPACE_LIM - SPC_LOCAL_OBJ) / sizeof (Capability);

        ALWAYS_INLINE
        static inline Capability lookup (unsigned long idx)
        {
            return *reinterpret_cast<Capability *>(idx_to_virt (idx));
ffffffff810198cb:	48 8b 04 c5 00 00 00 	mov    -0x20000000(,%rax,8),%rax
ffffffff810198d2:	e0 
ffffffff810198d3:	48 89 c3             	mov    %rax,%rbx
ffffffff810198d6:	48 83 e3 e0          	and    $0xffffffffffffffe0,%rbx
ffffffff810198da:	74 0d                	je     ffffffff810198e9 <_ZN2Ec11sys_ec_ctrlEv+0xad>
        case 0:
        {
            Capability cap = Space_obj::lookup (r->ec());
            if (EXPECT_FALSE (cap.obj()->type() != Kobject::EC || !(cap.prm() & 1UL << 0))) {
ffffffff810198dc:	80 bb 88 00 00 00 01 	cmpb   $0x1,0x88(%rbx)
ffffffff810198e3:	75 04                	jne    ffffffff810198e9 <_ZN2Ec11sys_ec_ctrlEv+0xad>
ffffffff810198e5:	a8 01                	test   $0x1,%al
ffffffff810198e7:	75 39                	jne    ffffffff81019922 <_ZN2Ec11sys_ec_ctrlEv+0xe6>
               trace (TRACE_ERROR, "%s: Bad EC CAP (%#lx)", __func__, r->ec());
ffffffff810198e9:	48 8d 44 24 ff       	lea    -0x1(%rsp),%rax
ffffffff810198ee:	8b 15 10 57 fe 3e    	mov    0x3efe5710(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff810198f4:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff810198f8:	48 c7 c7 b4 0f 02 81 	mov    $0xffffffff81020fb4,%rdi
ffffffff810198ff:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81019905:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff8101990b:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff8101990f:	48 c7 c2 68 11 02 81 	mov    $0xffffffff81021168,%rdx
ffffffff81019916:	31 c0                	xor    %eax,%eax
ffffffff81019918:	e8 6f 87 fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff8101991d:	e9 4d 01 00 00       	jmpq   ffffffff81019a6f <_ZN2Ec11sys_ec_ctrlEv+0x233>
               sys_finish<Sys_regs::BAD_CAP>();
            }

            Ec *ec = static_cast<Ec *>(cap.obj());

            if (!(ec->regs.hazard() & HZD_RECALL)) {
ffffffff81019922:	f6 83 83 01 00 00 80 	testb  $0x80,0x183(%rbx)
ffffffff81019929:	75 3a                	jne    ffffffff81019965 <_ZN2Ec11sys_ec_ctrlEv+0x129>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }
ffffffff8101992b:	b8 00 00 00 80       	mov    $0x80000000,%eax
ffffffff81019930:	f0 48 09 83 80 01 00 	lock or %rax,0x180(%rbx)
ffffffff81019937:	00 

                ec->regs.set_hazard (HZD_RECALL);

                if (Cpu::id != ec->cpu && Ec::remote (ec->cpu) == ec) {
ffffffff81019938:	0f b7 bb f0 02 00 00 	movzwl 0x2f0(%rbx),%edi
ffffffff8101993f:	39 3d bf 56 fe 3e    	cmp    %edi,0x3efe56bf(%rip)        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81019945:	74 1e                	je     ffffffff81019965 <_ZN2Ec11sys_ec_ctrlEv+0x129>
        UNREACHED;
    }

    ALWAYS_INLINE
    static inline Ec *remote(unsigned c) {
        return *reinterpret_cast<volatile typeof current *> (reinterpret_cast<mword> (&current) - CPU_LOCAL_DATA + HV_GLOBAL_CPUS + c * PAGE_SIZE);
ffffffff81019947:	89 f8                	mov    %edi,%eax
ffffffff81019949:	48 ba 08 00 e0 be ff 	movabs $0xffffffffbee00008,%rdx
ffffffff81019950:	ff ff ff 
ffffffff81019953:	c1 e0 0c             	shl    $0xc,%eax
ffffffff81019956:	48 01 d0             	add    %rdx,%rax
ffffffff81019959:	48 8b 00             	mov    (%rax),%rax
ffffffff8101995c:	48 39 d8             	cmp    %rbx,%rax
ffffffff8101995f:	0f 84 79 01 00 00    	je     ffffffff81019ade <_ZN2Ec11sys_ec_ctrlEv+0x2a2>
                    if (r->state())
                        sys_finish<Sys_regs::COM_TIM>();
                }
            }

            if (!(r->state() && current->utcb))
ffffffff81019965:	48 83 bd f0 00 00 00 	cmpq   $0x1,0xf0(%rbp)
ffffffff8101996c:	01 
ffffffff8101996d:	0f 85 c4 00 00 00    	jne    ffffffff81019a37 <_ZN2Ec11sys_ec_ctrlEv+0x1fb>
ffffffff81019973:	48 8b 05 8e 56 fe 3e 	mov    0x3efe568e(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8101997a:	48 8b 90 90 02 00 00 	mov    0x290(%rax),%rdx
ffffffff81019981:	48 85 d2             	test   %rdx,%rdx
ffffffff81019984:	0f 84 ad 00 00 00    	je     ffffffff81019a37 <_ZN2Ec11sys_ec_ctrlEv+0x1fb>
                break;

            Cpu_regs regs(ec->regs);
ffffffff8101998a:	48 89 e7             	mov    %rsp,%rdi
ffffffff8101998d:	48 8d b3 a8 00 00 00 	lea    0xa8(%rbx),%rsi
ffffffff81019994:	b9 3c 00 00 00       	mov    $0x3c,%ecx
ffffffff81019999:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
                       Mtd::GPR_R8_R15 |
#endif
                       Mtd::RSP |
                       Mtd::RIP_LEN |
                       Mtd::RFLAGS |
                       Mtd::QUAL;
ffffffff8101999b:	48 c7 84 24 e8 00 00 	movq   $0x40801f,0xe8(%rsp)
ffffffff810199a2:	00 1f 80 40 00 

            if (((ec->cont != ret_user_iret) && (ec->cont != recv_kern))) {
ffffffff810199a7:	48 8b 83 a0 00 00 00 	mov    0xa0(%rbx),%rax
ffffffff810199ae:	48 3d 8c 00 00 81    	cmp    $0xffffffff8100008c,%rax
ffffffff810199b4:	74 26                	je     ffffffff810199dc <_ZN2Ec11sys_ec_ctrlEv+0x1a0>
ffffffff810199b6:	48 3d 48 01 00 81    	cmp    $0xffffffff81000148,%rax
ffffffff810199bc:	74 1e                	je     ffffffff810199dc <_ZN2Ec11sys_ec_ctrlEv+0x1a0>
                /* in syscall */
                regs.REG(ip) = ec->regs.ARG_IP;
ffffffff810199be:	48 8b 83 18 01 00 00 	mov    0x118(%rbx),%rax
ffffffff810199c5:	48 89 84 24 b0 00 00 	mov    %rax,0xb0(%rsp)
ffffffff810199cc:	00 
                regs.REG(sp) = ec->regs.ARG_SP;
ffffffff810199cd:	48 8b 83 c8 00 00 00 	mov    0xc8(%rbx),%rax
ffffffff810199d4:	48 89 84 24 c8 00 00 	mov    %rax,0xc8(%rsp)
ffffffff810199db:	00 
             * numbers in the comparison are the ones handled as exception in
             * 'entry.S'. Page fault exceptions are not of interest for GDB,
             * which is currently the only user of this status information.
             */
            if ((ec->cont == ret_user_iret) &&
                (ec->partner != nullptr) && (ec->partner->cont == recv_kern) &&
ffffffff810199dc:	48 81 bb a0 00 00 00 	cmpq   $0xffffffff8100008c,0xa0(%rbx)
ffffffff810199e3:	8c 00 00 81 
ffffffff810199e7:	0f 85 3c 01 00 00    	jne    ffffffff81019b29 <_ZN2Ec11sys_ec_ctrlEv+0x2ed>
ffffffff810199ed:	48 8b 83 a0 02 00 00 	mov    0x2a0(%rbx),%rax
             * case if it has called an exception handler portal. The exception
             * numbers in the comparison are the ones handled as exception in
             * 'entry.S'. Page fault exceptions are not of interest for GDB,
             * which is currently the only user of this status information.
             */
            if ((ec->cont == ret_user_iret) &&
ffffffff810199f4:	48 85 c0             	test   %rax,%rax
ffffffff810199f7:	0f 84 2c 01 00 00    	je     ffffffff81019b29 <_ZN2Ec11sys_ec_ctrlEv+0x2ed>
                (ec->partner != nullptr) && (ec->partner->cont == recv_kern) &&
ffffffff810199fd:	48 81 b8 a0 00 00 00 	cmpq   $0xffffffff81000148,0xa0(%rax)
ffffffff81019a04:	48 01 00 81 
ffffffff81019a08:	0f 85 1b 01 00 00    	jne    ffffffff81019b29 <_ZN2Ec11sys_ec_ctrlEv+0x2ed>
                ((regs.dst_portal <= 0x01) ||
ffffffff81019a0e:	48 8b 84 24 a8 00 00 	mov    0xa8(%rsp),%rax
ffffffff81019a15:	00 
             * numbers in the comparison are the ones handled as exception in
             * 'entry.S'. Page fault exceptions are not of interest for GDB,
             * which is currently the only user of this status information.
             */
            if ((ec->cont == ret_user_iret) &&
                (ec->partner != nullptr) && (ec->partner->cont == recv_kern) &&
ffffffff81019a16:	48 83 f8 01          	cmp    $0x1,%rax
ffffffff81019a1a:	0f 87 df 00 00 00    	ja     ffffffff81019aff <_ZN2Ec11sys_ec_ctrlEv+0x2c3>
                ((regs.dst_portal <= 0x01) ||
                 ((regs.dst_portal >= 0x03) && (regs.dst_portal <= 0x07)) ||
                 ((regs.dst_portal >= 0x0a) && (regs.dst_portal <= 0x0d)) ||
                 ((regs.dst_portal >= 0x10) && (regs.dst_portal <= 0x13)))) {
                /* 'regs.err' will be transferred into utcb->qual[0] */
                regs.err = 1;
ffffffff81019a20:	48 c7 84 24 a0 00 00 	movq   $0x1,0xa0(%rsp)
ffffffff81019a27:	00 01 00 00 00 
            } else
                regs.err = 0;

            bool fpu = current->utcb->load_exc (&regs);
ffffffff81019a2c:	48 89 e6             	mov    %rsp,%rsi
ffffffff81019a2f:	48 89 d7             	mov    %rdx,%rdi
ffffffff81019a32:	e8 eb 13 00 00       	callq  ffffffff8101ae22 <_ZN4Utcb8load_excEP8Cpu_regs>

        default:
            sys_finish<Sys_regs::BAD_PAR>();
    }

    sys_finish<Sys_regs::SUCCESS>();
ffffffff81019a37:	e8 1c d6 ff ff       	callq  ffffffff81017058 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb0EEEvv>
            (void)fpu;
            break;
        }

        case 1: /* yield */
            current->cont = sys_finish<Sys_regs::SUCCESS>;
ffffffff81019a3c:	48 c7 85 a0 00 00 00 	movq   $0xffffffff81017058,0xa0(%rbp)
ffffffff81019a43:	58 70 01 81 
            Sc::schedule (false, false);
ffffffff81019a47:	31 f6                	xor    %esi,%esi
ffffffff81019a49:	e9 89 00 00 00       	jmpq   ffffffff81019ad7 <_ZN2Ec11sys_ec_ctrlEv+0x29b>
ffffffff81019a4e:	48 c1 e9 08          	shr    $0x8,%rcx
{
    private:
        ALWAYS_INLINE
        static inline mword idx_to_virt (unsigned long idx)
        {
            return SPC_LOCAL_OBJ + (idx % caps) * sizeof (Capability);
ffffffff81019a52:	81 e1 ff ff ff 03    	and    $0x3ffffff,%ecx
ffffffff81019a58:	48 8b 1c cd 00 00 00 	mov    -0x20000000(,%rcx,8),%rbx
ffffffff81019a5f:	e0 
ffffffff81019a60:	48 83 e3 e0          	and    $0xffffffffffffffe0,%rbx
ffffffff81019a64:	74 09                	je     ffffffff81019a6f <_ZN2Ec11sys_ec_ctrlEv+0x233>

        case 2: /* helping */
        {
            Kobject *obj = Space_obj::lookup (r->ec()).obj();

            if (EXPECT_FALSE (obj->type() != Kobject::EC))
ffffffff81019a66:	80 bb 88 00 00 00 01 	cmpb   $0x1,0x88(%rbx)
ffffffff81019a6d:	74 05                	je     ffffffff81019a74 <_ZN2Ec11sys_ec_ctrlEv+0x238>
                sys_finish<Sys_regs::BAD_CAP>();
ffffffff81019a6f:	e8 c0 e5 ff ff       	callq  ffffffff81018034 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>

            Ec *ec = static_cast<Ec *>(obj);

            if (EXPECT_FALSE(ec->cpu != current->cpu))
ffffffff81019a74:	8b 85 f0 02 00 00    	mov    0x2f0(%rbp),%eax
ffffffff81019a7a:	66 39 83 f0 02 00 00 	cmp    %ax,0x2f0(%rbx)
ffffffff81019a81:	74 05                	je     ffffffff81019a88 <_ZN2Ec11sys_ec_ctrlEv+0x24c>
                sys_finish<Sys_regs::BAD_CPU>();
ffffffff81019a83:	e8 30 fd ff ff       	callq  ffffffff810197b8 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE7ELb0EEEvv>

            if (EXPECT_FALSE(!ec->utcb || ec->blocked() || ec->partner || ec->pd != Ec::current->pd || (r->cnt() != ec->utcb->tls)))
ffffffff81019a88:	48 8b 83 90 02 00 00 	mov    0x290(%rbx),%rax
ffffffff81019a8f:	48 85 c0             	test   %rax,%rax
ffffffff81019a92:	74 2e                	je     ffffffff81019ac2 <_ZN2Ec11sys_ec_ctrlEv+0x286>
        regs.add_tsc_offset(tsc);
    }

    ALWAYS_INLINE
    inline bool blocked() const {
        return next || !cont;
ffffffff81019a94:	48 83 bb b0 02 00 00 	cmpq   $0x0,0x2b0(%rbx)
ffffffff81019a9b:	00 
ffffffff81019a9c:	75 24                	jne    ffffffff81019ac2 <_ZN2Ec11sys_ec_ctrlEv+0x286>
ffffffff81019a9e:	48 83 bb a0 00 00 00 	cmpq   $0x0,0xa0(%rbx)
ffffffff81019aa5:	00 
ffffffff81019aa6:	74 1a                	je     ffffffff81019ac2 <_ZN2Ec11sys_ec_ctrlEv+0x286>
ffffffff81019aa8:	48 83 bb a0 02 00 00 	cmpq   $0x0,0x2a0(%rbx)
ffffffff81019aaf:	00 
ffffffff81019ab0:	75 10                	jne    ffffffff81019ac2 <_ZN2Ec11sys_ec_ctrlEv+0x286>
ffffffff81019ab2:	48 8b bd 98 02 00 00 	mov    0x298(%rbp),%rdi
ffffffff81019ab9:	48 39 bb 98 02 00 00 	cmp    %rdi,0x298(%rbx)
ffffffff81019ac0:	74 78                	je     ffffffff81019b3a <_ZN2Ec11sys_ec_ctrlEv+0x2fe>
                sys_finish<Sys_regs::BAD_PAR>();
ffffffff81019ac2:	e8 d9 f5 ff ff       	callq  ffffffff810190a0 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE5ELb0EEEvv>

            break;
        }

        case 3: /* re-schedule */
            current->cont = sys_finish<Sys_regs::SUCCESS>;
ffffffff81019ac7:	48 c7 85 a0 00 00 00 	movq   $0xffffffff81017058,0xa0(%rbp)
ffffffff81019ace:	58 70 01 81 
            Sc::schedule (false, true);
ffffffff81019ad2:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff81019ad7:	31 ff                	xor    %edi,%edi
ffffffff81019ad9:	e8 d6 b2 ff ff       	callq  ffffffff81014db4 <_ZN2Sc8scheduleEbb>
            if (!(ec->regs.hazard() & HZD_RECALL)) {

                ec->regs.set_hazard (HZD_RECALL);

                if (Cpu::id != ec->cpu && Ec::remote (ec->cpu) == ec) {
                    Lapic::send_ipi (ec->cpu, VEC_IPI_RKE);
ffffffff81019ade:	31 c9                	xor    %ecx,%ecx
ffffffff81019ae0:	31 d2                	xor    %edx,%edx
ffffffff81019ae2:	be a8 00 00 00       	mov    $0xa8,%esi
ffffffff81019ae7:	e8 42 e9 fe ff       	callq  ffffffff8100842e <_ZN5Lapic8send_ipiEjjNS_13Delivery_modeENS_9ShorthandE>
                    if (r->state())
ffffffff81019aec:	48 83 bd f0 00 00 00 	cmpq   $0x1,0xf0(%rbp)
ffffffff81019af3:	01 
ffffffff81019af4:	0f 85 6b fe ff ff    	jne    ffffffff81019965 <_ZN2Ec11sys_ec_ctrlEv+0x129>
                        sys_finish<Sys_regs::COM_TIM>();
ffffffff81019afa:	e8 b1 e4 ff ff       	callq  ffffffff81017fb0 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE1ELb0EEEvv>
             * 'entry.S'. Page fault exceptions are not of interest for GDB,
             * which is currently the only user of this status information.
             */
            if ((ec->cont == ret_user_iret) &&
                (ec->partner != nullptr) && (ec->partner->cont == recv_kern) &&
                ((regs.dst_portal <= 0x01) ||
ffffffff81019aff:	48 8d 48 fd          	lea    -0x3(%rax),%rcx
             * numbers in the comparison are the ones handled as exception in
             * 'entry.S'. Page fault exceptions are not of interest for GDB,
             * which is currently the only user of this status information.
             */
            if ((ec->cont == ret_user_iret) &&
                (ec->partner != nullptr) && (ec->partner->cont == recv_kern) &&
ffffffff81019b03:	48 83 f9 04          	cmp    $0x4,%rcx
ffffffff81019b07:	0f 86 13 ff ff ff    	jbe    ffffffff81019a20 <_ZN2Ec11sys_ec_ctrlEv+0x1e4>
                ((regs.dst_portal <= 0x01) ||
                 ((regs.dst_portal >= 0x03) && (regs.dst_portal <= 0x07)) ||
                 ((regs.dst_portal >= 0x0a) && (regs.dst_portal <= 0x0d)) ||
ffffffff81019b0d:	48 8d 48 f6          	lea    -0xa(%rax),%rcx
             * which is currently the only user of this status information.
             */
            if ((ec->cont == ret_user_iret) &&
                (ec->partner != nullptr) && (ec->partner->cont == recv_kern) &&
                ((regs.dst_portal <= 0x01) ||
                 ((regs.dst_portal >= 0x03) && (regs.dst_portal <= 0x07)) ||
ffffffff81019b11:	48 83 f9 03          	cmp    $0x3,%rcx
ffffffff81019b15:	0f 86 05 ff ff ff    	jbe    ffffffff81019a20 <_ZN2Ec11sys_ec_ctrlEv+0x1e4>
                 ((regs.dst_portal >= 0x0a) && (regs.dst_portal <= 0x0d)) ||
                 ((regs.dst_portal >= 0x10) && (regs.dst_portal <= 0x13)))) {
ffffffff81019b1b:	48 83 e8 10          	sub    $0x10,%rax
             */
            if ((ec->cont == ret_user_iret) &&
                (ec->partner != nullptr) && (ec->partner->cont == recv_kern) &&
                ((regs.dst_portal <= 0x01) ||
                 ((regs.dst_portal >= 0x03) && (regs.dst_portal <= 0x07)) ||
                 ((regs.dst_portal >= 0x0a) && (regs.dst_portal <= 0x0d)) ||
ffffffff81019b1f:	48 83 f8 03          	cmp    $0x3,%rax
ffffffff81019b23:	0f 86 f7 fe ff ff    	jbe    ffffffff81019a20 <_ZN2Ec11sys_ec_ctrlEv+0x1e4>
                 ((regs.dst_portal >= 0x10) && (regs.dst_portal <= 0x13)))) {
                /* 'regs.err' will be transferred into utcb->qual[0] */
                regs.err = 1;
            } else
                regs.err = 0;
ffffffff81019b29:	48 c7 84 24 a0 00 00 	movq   $0x0,0xa0(%rsp)
ffffffff81019b30:	00 00 00 00 00 
ffffffff81019b35:	e9 f2 fe ff ff       	jmpq   ffffffff81019a2c <_ZN2Ec11sys_ec_ctrlEv+0x1f0>
            Ec *ec = static_cast<Ec *>(obj);

            if (EXPECT_FALSE(ec->cpu != current->cpu))
                sys_finish<Sys_regs::BAD_CPU>();

            if (EXPECT_FALSE(!ec->utcb || ec->blocked() || ec->partner || ec->pd != Ec::current->pd || (r->cnt() != ec->utcb->tls)))
ffffffff81019b3a:	48 8b 40 18          	mov    0x18(%rax),%rax
ffffffff81019b3e:	48 39 85 f0 00 00 00 	cmp    %rax,0xf0(%rbp)
ffffffff81019b45:	0f 85 77 ff ff ff    	jne    ffffffff81019ac2 <_ZN2Ec11sys_ec_ctrlEv+0x286>
                sys_finish<Sys_regs::BAD_PAR>();

            current->cont = sys_finish<Sys_regs::SUCCESS>;
ffffffff81019b4b:	48 c7 85 a0 00 00 00 	movq   $0xffffffff81017058,0xa0(%rbp)
ffffffff81019b52:	58 70 01 81 
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff81019b56:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff81019b59:	f0 0f c1 85 8c 00 00 	lock xadd %eax,0x8c(%rbp)
ffffffff81019b60:	00 
        regs.ARG_3 = cnt;
    }

    ALWAYS_INLINE NORETURN
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
ffffffff81019b61:	ff c8                	dec    %eax
ffffffff81019b63:	75 31                	jne    ffffffff81019b96 <_ZN2Ec11sys_ec_ctrlEv+0x35a>
            delete current;
ffffffff81019b65:	48 8b 2d 9c 54 fe 3e 	mov    0x3efe549c(%rip),%rbp        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81019b6c:	48 85 ed             	test   %rbp,%rbp
ffffffff81019b6f:	74 25                	je     ffffffff81019b96 <_ZN2Ec11sys_ec_ctrlEv+0x35a>
ffffffff81019b71:	48 89 ef             	mov    %rbp,%rdi
ffffffff81019b74:	e8 c3 a8 fe ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff81019b79:	48 8b 85 98 02 00 00 	mov    0x298(%rbp),%rax
ffffffff81019b80:	48 89 ee             	mov    %rbp,%rsi
ffffffff81019b83:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff81019b8a:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff81019b91:	e8 d4 be ff ff       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
    inline void make_current() {
        if (EXPECT_FALSE(current->del_ref())) {
            delete current;
        }

        current = this;
ffffffff81019b96:	48 89 1d 6b 54 fe 3e 	mov    %rbx,0x3efe546b(%rip)        # ffffffffbffff008 <_ZN2Ec7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff81019b9d:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff81019ba3:	85 c0                	test   %eax,%eax
ffffffff81019ba5:	74 0d                	je     ffffffff81019bb4 <_ZN2Ec11sys_ec_ctrlEv+0x378>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff81019ba7:	8d 50 01             	lea    0x1(%rax),%edx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff81019baa:	f0 0f b1 93 8c 00 00 	lock cmpxchg %edx,0x8c(%rbx)
ffffffff81019bb1:	00 
ffffffff81019bb2:	75 e9                	jne    ffffffff81019b9d <_ZN2Ec11sys_ec_ctrlEv+0x361>
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
        T * operator->() const  { return ptr; }
ffffffff81019bb4:	48 8b 93 98 02 00 00 	mov    0x298(%rbx),%rdx

        current->add_ref();

        Tss::run.sp0 = reinterpret_cast<mword> (exc_regs() + 1);
ffffffff81019bbb:	48 8d 83 80 01 00 00 	lea    0x180(%rbx),%rax
    public:
        ALWAYS_INLINE
        inline explicit Cpuset(mword v) : val (v) {}

        ALWAYS_INLINE
        inline bool chk (unsigned cpu) const { return val & 1UL << cpu; }
ffffffff81019bc2:	8b 0d 3c 54 fe 3e    	mov    0x3efe543c(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81019bc8:	48 89 05 fd 61 fe 3e 	mov    %rax,0x3efe61fd(%rip)        # ffffffffbffffdcc <tss_run+0x4>
ffffffff81019bcf:	48 8b 82 c8 02 00 00 	mov    0x2c8(%rdx),%rax
        Pd (Pd *own, mword sel, mword a);

        ALWAYS_INLINE HOT
        inline void make_current()
        {
            mword pcid = did;
ffffffff81019bd6:	48 8b b2 b8 02 00 00 	mov    0x2b8(%rdx),%rsi

            if (EXPECT_FALSE (htlb.chk (Cpu::id)))
ffffffff81019bdd:	48 0f a3 c8          	bt     %rcx,%rax
ffffffff81019be1:	73 14                	jae    ffffffff81019bf7 <_ZN2Ec11sys_ec_ctrlEv+0x3bb>

        ALWAYS_INLINE
        inline bool set (unsigned cpu) { return !Atomic::test_set_bit (val, cpu); }

        ALWAYS_INLINE
        inline void clr (unsigned cpu) { Atomic::clr_mask (val, 1UL << cpu); }
ffffffff81019be3:	48 c7 c0 fe ff ff ff 	mov    $0xfffffffffffffffe,%rax
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
ffffffff81019bea:	48 d3 c0             	rol    %cl,%rax
ffffffff81019bed:	f0 48 21 82 c8 02 00 	lock and %rax,0x2c8(%rdx)
ffffffff81019bf4:	00 
ffffffff81019bf5:	eb 20                	jmp    ffffffff81019c17 <_ZN2Ec11sys_ec_ctrlEv+0x3db>
                htlb.clr (Cpu::id);

            else {

                if (EXPECT_TRUE (current == this))
ffffffff81019bf7:	48 39 15 12 54 fe 3e 	cmp    %rdx,0x3efe5412(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81019bfe:	0f 84 e5 00 00 00    	je     ffffffff81019ce9 <_ZN2Ec11sys_ec_ctrlEv+0x4ad>
                    return;

                if (pcid != NO_PCID)
ffffffff81019c04:	48 83 fe 02          	cmp    $0x2,%rsi
ffffffff81019c08:	74 0d                	je     ffffffff81019c17 <_ZN2Ec11sys_ec_ctrlEv+0x3db>
                    pcid |= static_cast<mword>(1ULL << 63);
ffffffff81019c0a:	48 b8 00 00 00 00 00 	movabs $0x8000000000000000,%rax
ffffffff81019c11:	00 00 80 
ffffffff81019c14:	48 09 c6             	or     %rax,%rsi
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff81019c17:	48 8b 05 f2 53 fe 3e 	mov    0x3efe53f2(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81019c1e:	83 c9 ff             	or     $0xffffffff,%ecx
ffffffff81019c21:	f0 0f c1 88 8c 00 00 	lock xadd %ecx,0x8c(%rax)
ffffffff81019c28:	00 
            }

            Pd * del_pd = nullptr;
            if (current->del_ref()) {
ffffffff81019c29:	83 f9 01             	cmp    $0x1,%ecx
ffffffff81019c2c:	75 31                	jne    ffffffff81019c5f <_ZN2Ec11sys_ec_ctrlEv+0x423>
                assert (current != this);
ffffffff81019c2e:	48 8b 2d db 53 fe 3e 	mov    0x3efe53db(%rip),%rbp        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81019c35:	48 39 d5             	cmp    %rdx,%rbp
ffffffff81019c38:	75 27                	jne    ffffffff81019c61 <_ZN2Ec11sys_ec_ctrlEv+0x425>
ffffffff81019c3a:	49 c7 c0 a0 12 02 81 	mov    $0xffffffff810212a0,%r8
ffffffff81019c41:	b1 5e                	mov    $0x5e,%cl
ffffffff81019c43:	48 c7 c2 c7 e6 01 81 	mov    $0xffffffff8101e6c7,%rdx
ffffffff81019c4a:	48 c7 c6 35 e7 01 81 	mov    $0xffffffff8101e735,%rsi
ffffffff81019c51:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff81019c58:	31 c0                	xor    %eax,%eax
ffffffff81019c5a:	e8 f1 82 fe ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

                if (pcid != NO_PCID)
                    pcid |= static_cast<mword>(1ULL << 63);
            }

            Pd * del_pd = nullptr;
ffffffff81019c5f:	31 ed                	xor    %ebp,%ebp
            if (current->del_ref()) {
                assert (current != this);
                del_pd = current;
            }

            current = this;
ffffffff81019c61:	48 89 15 a8 53 fe 3e 	mov    %rdx,0x3efe53a8(%rip)        # ffffffffbffff010 <_ZN2Pd7currentE>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff81019c68:	8b 82 8c 00 00 00    	mov    0x8c(%rdx),%eax
ffffffff81019c6e:	85 c0                	test   %eax,%eax
ffffffff81019c70:	74 0d                	je     ffffffff81019c7f <_ZN2Ec11sys_ec_ctrlEv+0x443>
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff81019c72:	8d 48 01             	lea    0x1(%rax),%ecx
class Atomic
{
    public:
        template <typename T>
        ALWAYS_INLINE
        static inline bool cmp_swap (T &ptr, T o, T n) { return __sync_bool_compare_and_swap (&ptr, o, n); }
ffffffff81019c75:	f0 0f b1 8a 8c 00 00 	lock cmpxchg %ecx,0x8c(%rdx)
ffffffff81019c7c:	00 
ffffffff81019c7d:	75 e9                	jne    ffffffff81019c68 <_ZN2Ec11sys_ec_ctrlEv+0x42c>

            current->add_ref();

            loc[Cpu::id].make_current (Cpu::feature (Cpu::FEAT_PCID) ? pcid : 0);
ffffffff81019c7f:	f6 05 c0 5a fe 3e 02 	testb  $0x2,0x3efe5ac0(%rip)        # ffffffffbffff746 <_ZN3Cpu8featuresE+0x6>
ffffffff81019c86:	8b 0d 78 53 fe 3e    	mov    0x3efe5378(%rip),%ecx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81019c8c:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff81019c91:	48 0f 45 c6          	cmovne %rsi,%rax
ffffffff81019c95:	48 0b 84 ca a0 00 00 	or     0xa0(%rdx,%rcx,8),%rax
ffffffff81019c9c:	00 
ffffffff81019c9d:	0f 22 d8             	mov    %rax,%cr3

            if (del_pd)
ffffffff81019ca0:	48 85 ed             	test   %rbp,%rbp
ffffffff81019ca3:	74 44                	je     ffffffff81019ce9 <_ZN2Ec11sys_ec_ctrlEv+0x4ad>
                delete del_pd;
ffffffff81019ca5:	48 89 ef             	mov    %rbp,%rdi
ffffffff81019ca8:	e8 7b 73 ff ff       	callq  ffffffff81011028 <_ZN2PdD1Ev>

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff81019cad:	48 8b 45 50          	mov    0x50(%rbp),%rax
ffffffff81019cb1:	31 d2                	xor    %edx,%edx

            pd_del->quota.free_up(pd_to->quota);
ffffffff81019cb3:	48 8d bd 08 03 00 00 	lea    0x308(%rbp),%rdi

        ALWAYS_INLINE
        static inline void operator delete (void *ptr)
        {
            Pd *pd_del = static_cast<Pd *>(ptr);
            Pd *pd_to  = static_cast<Pd *>(static_cast<Space_obj *>(pd_del->space));
ffffffff81019cba:	48 8d 88 08 fd ff ff 	lea    -0x2f8(%rax),%rcx
ffffffff81019cc1:	48 85 c0             	test   %rax,%rax
ffffffff81019cc4:	48 0f 45 d1          	cmovne %rcx,%rdx

            pd_del->quota.free_up(pd_to->quota);
ffffffff81019cc8:	4c 8d a2 08 03 00 00 	lea    0x308(%rdx),%r12
ffffffff81019ccf:	4c 89 e6             	mov    %r12,%rsi
ffffffff81019cd2:	e8 ed 98 fe ff       	callq  ffffffff810035c4 <_ZN5Quota7free_upERS_>

            cache.free (ptr, pd_to->quota);
ffffffff81019cd7:	4c 89 e2             	mov    %r12,%rdx
ffffffff81019cda:	48 89 ee             	mov    %rbp,%rsi
ffffffff81019cdd:	48 c7 c7 d0 3f 16 81 	mov    $0xffffffff81163fd0,%rdi
ffffffff81019ce4:	e8 81 bd ff ff       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>

        pd->make_current();

        asm volatile ("mov %0," EXPAND(PREG(sp);) "jmp *%1" : : "g" (CPU_LOCAL_STCK + PAGE_SIZE), "q" (cont) : "memory");
ffffffff81019ce9:	48 8b 83 a0 00 00 00 	mov    0xa0(%rbx),%rax
ffffffff81019cf0:	48 c7 c4 00 e0 ff bf 	mov    $0xffffffffbfffe000,%rsp
ffffffff81019cf7:	ff e0                	jmpq   *%rax
ffffffff81019cf9:	90                   	nop

ffffffff81019cfa <_ZN2Ec13sys_xcpu_callEv>:

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_xcpu_call()
{
ffffffff81019cfa:	41 54                	push   %r12
ffffffff81019cfc:	55                   	push   %rbp
ffffffff81019cfd:	53                   	push   %rbx
ffffffff81019cfe:	48 83 ec 10          	sub    $0x10,%rsp
    Sys_call *s = static_cast<Sys_call *>(current->sys_regs());
ffffffff81019d02:	48 8b 15 ff 52 fe 3e 	mov    0x3efe52ff(%rip),%rdx        # ffffffffbffff008 <_ZN2Ec7currentE>
            DISABLE_DONATION    = 1ul << 1,
            DISABLE_REPLYCAP    = 1ul << 2
        };

        ALWAYS_INLINE
        inline unsigned long pt() const { return ARG_1 >> 8; }
ffffffff81019d09:	48 8b 8a e8 00 00 00 	mov    0xe8(%rdx),%rcx
ffffffff81019d10:	48 c1 e9 08          	shr    $0x8,%rcx
ffffffff81019d14:	48 89 c8             	mov    %rcx,%rax
ffffffff81019d17:	25 ff ff ff 03       	and    $0x3ffffff,%eax
ffffffff81019d1c:	48 8b 04 c5 00 00 00 	mov    -0x20000000(,%rax,8),%rax
ffffffff81019d23:	e0 
ffffffff81019d24:	48 83 e0 e0          	and    $0xffffffffffffffe0,%rax
ffffffff81019d28:	74 09                	je     ffffffff81019d33 <_ZN2Ec13sys_xcpu_callEv+0x39>

    Kobject *obj = Space_obj::lookup (s->pt()).obj();
    if (EXPECT_FALSE (obj->type() != Kobject::PT)) {
ffffffff81019d2a:	80 b8 88 00 00 00 03 	cmpb   $0x3,0x88(%rax)
ffffffff81019d31:	74 39                	je     ffffffff81019d6c <_ZN2Ec13sys_xcpu_callEv+0x72>
        trace (TRACE_ERROR, "%s: Bad PT CAP (%#lx)", __func__, s->pt());
ffffffff81019d33:	8b 15 cb 52 fe 3e    	mov    0x3efe52cb(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81019d39:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff81019d3e:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81019d42:	48 c7 c7 20 0e 02 81 	mov    $0xffffffff81020e20,%rdi
ffffffff81019d49:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81019d4f:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff81019d55:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff81019d59:	48 c7 c2 08 11 02 81 	mov    $0xffffffff81021108,%rdx
ffffffff81019d60:	31 c0                	xor    %eax,%eax
ffffffff81019d62:	e8 25 83 fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_CAP>();
ffffffff81019d67:	e8 c8 e2 ff ff       	callq  ffffffff81018034 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>
{
    private:
        T * const ptr;

    public:
        operator T*() const     { return ptr; }
ffffffff81019d6c:	48 8b a8 90 00 00 00 	mov    0x90(%rax),%rbp
    }

    Pt *pt = static_cast<Pt *>(obj);
    Ec *ec = pt->ec;

    if (EXPECT_FALSE (current->cpu == ec->cpu)) {
ffffffff81019d73:	8b 85 f0 02 00 00    	mov    0x2f0(%rbp),%eax
ffffffff81019d79:	66 39 82 f0 02 00 00 	cmp    %ax,0x2f0(%rdx)
ffffffff81019d80:	75 39                	jne    ffffffff81019dbb <_ZN2Ec13sys_xcpu_callEv+0xc1>
        trace (TRACE_ERROR, "%s: Bad CPU", __func__);
ffffffff81019d82:	8b 15 7c 52 fe 3e    	mov    0x3efe527c(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff81019d88:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff81019d8d:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff81019d91:	48 c7 c7 d1 0f 02 81 	mov    $0xffffffff81020fd1,%rdi
ffffffff81019d98:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff81019d9e:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff81019da4:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff81019da8:	48 c7 c2 08 11 02 81 	mov    $0xffffffff81021108,%rdx
ffffffff81019daf:	31 c0                	xor    %eax,%eax
ffffffff81019db1:	e8 d6 82 fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_CPU>();
ffffffff81019db6:	e8 fd f9 ff ff       	callq  ffffffff810197b8 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE7ELb0EEEvv>
    }

    enum { UNUSED = 0, CNT = 0 };

    current->xcpu_sm = new (Pd::current->quota) Sm (Pd::current, UNUSED, CNT);
ffffffff81019dbb:	48 8b 05 4e 52 fe 3e 	mov    0x3efe524e(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>

            call_rcu(true);
        }

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota) { return cache.alloc(quota); }
ffffffff81019dc2:	48 c7 c7 80 40 16 81 	mov    $0xffffffff81164080,%rdi
ffffffff81019dc9:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff81019dd0:	e8 59 bb ff ff       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff81019dd5:	48 8b 35 34 52 fe 3e 	mov    0x3efe5234(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81019ddc:	45 31 c9             	xor    %r9d,%r9d
ffffffff81019ddf:	45 31 c0             	xor    %r8d,%r8d
ffffffff81019de2:	31 c9                	xor    %ecx,%ecx
ffffffff81019de4:	31 d2                	xor    %edx,%edx
ffffffff81019de6:	48 89 c7             	mov    %rax,%rdi
ffffffff81019de9:	48 89 c3             	mov    %rax,%rbx
ffffffff81019dec:	e8 71 c1 ff ff       	callq  ffffffff81015f62 <_ZN2SmC1EP2PdmmPS_m>
ffffffff81019df1:	48 8b 05 10 52 fe 3e 	mov    0x3efe5210(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>

    static void idl_handler();

    ALWAYS_INLINE
    static inline void *operator new (size_t, Quota &quota) {
        return cache.alloc(quota);
ffffffff81019df8:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff81019dff:	48 89 98 30 03 00 00 	mov    %rbx,0x330(%rax)

    Ec *xcpu_ec = new (Pd::current->quota) Ec (Pd::current, Pd::current, Ec::sys_call, ec->cpu, current);
ffffffff81019e06:	48 8b 05 03 52 fe 3e 	mov    0x3efe5203(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81019e0d:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff81019e14:	e8 15 bb ff ff       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff81019e19:	44 0f b7 85 f0 02 00 	movzwl 0x2f0(%rbp),%r8d
ffffffff81019e20:	00 
ffffffff81019e21:	48 8b 35 e8 51 fe 3e 	mov    0x3efe51e8(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81019e28:	48 c7 c1 ae 08 00 81 	mov    $0xffffffff810008ae,%rcx
ffffffff81019e2f:	4c 8b 0d d2 51 fe 3e 	mov    0x3efe51d2(%rip),%r9        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81019e36:	48 89 c7             	mov    %rax,%rdi
ffffffff81019e39:	48 89 c3             	mov    %rax,%rbx
ffffffff81019e3c:	48 89 f2             	mov    %rsi,%rdx
ffffffff81019e3f:	e8 da a3 fe ff       	callq  ffffffff8100421e <_ZN2EcC1EP2PdS1_PFvvEjPS_>
    Sc *xcpu_sc = new (Pd::current->quota) Sc (Pd::current, xcpu_ec, xcpu_ec->cpu, Sc::current);
ffffffff81019e44:	48 8b 05 c5 51 fe 3e 	mov    0x3efe51c5(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81019e4b:	48 c7 c7 40 40 16 81 	mov    $0xffffffff81164040,%rdi
ffffffff81019e52:	48 8d b0 08 03 00 00 	lea    0x308(%rax),%rsi
ffffffff81019e59:	e8 d0 ba ff ff       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff81019e5e:	0f b7 8b f0 02 00 00 	movzwl 0x2f0(%rbx),%ecx
ffffffff81019e65:	4c 8b 05 ac 51 fe 3e 	mov    0x3efe51ac(%rip),%r8        # ffffffffbffff018 <_ZN2Sc7currentE>
ffffffff81019e6c:	48 89 c5             	mov    %rax,%rbp
ffffffff81019e6f:	48 8b 35 9a 51 fe 3e 	mov    0x3efe519a(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff81019e76:	48 89 da             	mov    %rbx,%rdx
ffffffff81019e79:	48 89 c7             	mov    %rax,%rdi
ffffffff81019e7c:	e8 51 a8 ff ff       	callq  ffffffff810146d2 <_ZN2ScC1EP2PdP2EcjPS_>

    xcpu_sc->remote_enqueue();
ffffffff81019e81:	48 89 ef             	mov    %rbp,%rdi
ffffffff81019e84:	e8 d7 ab ff ff       	callq  ffffffff81014a60 <_ZN2Sc14remote_enqueueEv>
    current->xcpu_sm->dn (false, 0);
ffffffff81019e89:	48 8b 1d 78 51 fe 3e 	mov    0x3efe5178(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff81019e90:	48 8b ab 30 03 00 00 	mov    0x330(%rbx),%rbp
        }

        ALWAYS_INLINE
        inline void dn (bool zero, uint64 t, Ec *ec = Ec::current, bool block = true)
        {
            {   Lock_guard <Spinlock> guard (lock);
ffffffff81019e97:	48 8d bd 8a 00 00 00 	lea    0x8a(%rbp),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff81019e9e:	9c                   	pushfq 
ffffffff81019e9f:	41 5c                	pop    %r12
            return flags & 0x200;
ffffffff81019ea1:	49 c1 ec 09          	shr    $0x9,%r12

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff81019ea5:	41 80 e4 01          	and    $0x1,%r12b
ffffffff81019ea9:	74 30                	je     ffffffff81019edb <_ZN2Ec13sys_xcpu_callEv+0x1e1>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff81019eab:	80 3d 7e 58 fe 3e 00 	cmpb   $0x0,0x3efe587e(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff81019eb2:	75 1f                	jne    ffffffff81019ed3 <_ZN2Ec13sys_xcpu_callEv+0x1d9>
ffffffff81019eb4:	49 c7 c0 f0 12 02 81 	mov    $0xffffffff810212f0,%r8
ffffffff81019ebb:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff81019ec0:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff81019ec7:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff81019ece:	e9 4c 01 00 00       	jmpq   ffffffff8101a01f <_ZN2Ec13sys_xcpu_callEv+0x325>

            asm volatile ("cli" : : : "memory");
ffffffff81019ed3:	fa                   	cli    
            preemption = false;
ffffffff81019ed4:	c6 05 55 58 fe 3e 00 	movb   $0x0,0x3efe5855(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff81019edb:	e8 ae 6f fe ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>

                if (counter) {
ffffffff81019ee0:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff81019ee7:	48 85 c0             	test   %rax,%rax
ffffffff81019eea:	0f 84 aa 00 00 00    	je     ffffffff81019f9a <_ZN2Ec13sys_xcpu_callEv+0x2a0>
                    counter = zero ? 0 : counter - 1;
ffffffff81019ef0:	48 ff c8             	dec    %rax
ffffffff81019ef3:	48 89 85 c0 00 00 00 	mov    %rax,0xc0(%rbp)
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff81019efa:	48 8b 85 98 00 00 00 	mov    0x98(%rbp),%rax
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff81019f01:	48 85 c0             	test   %rax,%rax
ffffffff81019f04:	0f 84 2d 01 00 00    	je     ffffffff8101a037 <_ZN2Ec13sys_xcpu_callEv+0x33d>
ffffffff81019f0a:	48 8b 50 10          	mov    0x10(%rax),%rdx
ffffffff81019f0e:	48 85 d2             	test   %rdx,%rdx
ffffffff81019f11:	0f 84 20 01 00 00    	je     ffffffff8101a037 <_ZN2Ec13sys_xcpu_callEv+0x33d>
ffffffff81019f17:	48 8b 48 08          	mov    0x8(%rax),%rcx
ffffffff81019f1b:	48 85 c9             	test   %rcx,%rcx
ffffffff81019f1e:	0f 84 13 01 00 00    	je     ffffffff8101a037 <_ZN2Ec13sys_xcpu_callEv+0x33d>
                return false;

            if (t == t->next)
ffffffff81019f24:	48 39 d0             	cmp    %rdx,%rax
ffffffff81019f27:	75 0d                	jne    ffffffff81019f36 <_ZN2Ec13sys_xcpu_callEv+0x23c>
                headptr = nullptr;
ffffffff81019f29:	48 c7 85 98 00 00 00 	movq   $0x0,0x98(%rbp)
ffffffff81019f30:	00 00 00 00 
ffffffff81019f34:	eb 24                	jmp    ffffffff81019f5a <_ZN2Ec13sys_xcpu_callEv+0x260>

            else {
                t->next->prev = t->prev;
ffffffff81019f36:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
                t->prev->next = t->next;
ffffffff81019f3a:	48 8b 50 08          	mov    0x8(%rax),%rdx
ffffffff81019f3e:	48 8b 48 10          	mov    0x10(%rax),%rcx
ffffffff81019f42:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
                if (t == headptr)
ffffffff81019f46:	48 3b 85 98 00 00 00 	cmp    0x98(%rbp),%rax
ffffffff81019f4d:	75 0b                	jne    ffffffff81019f5a <_ZN2Ec13sys_xcpu_callEv+0x260>
                    headptr = t->next;
ffffffff81019f4f:	48 8b 50 10          	mov    0x10(%rax),%rdx
ffffffff81019f53:	48 89 95 98 00 00 00 	mov    %rdx,0x98(%rbp)

    public:

        mword reset(bool l = false) {
            if (l) lock.lock();
            mword c = counter;
ffffffff81019f5a:	48 8b 50 20          	mov    0x20(%rax),%rdx
            }

            t->next = t->prev = nullptr;
ffffffff81019f5e:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
ffffffff81019f65:	00 
ffffffff81019f66:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
ffffffff81019f6d:	00 
            counter = 0;
ffffffff81019f6e:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
ffffffff81019f75:	00 
                if (counter) {
                    counter = zero ? 0 : counter - 1;

                    Si * si;
                    if (Queue<Si>::dequeue(si = Queue<Si>::head()))
                        ec->set_si_regs(si->value, static_cast <Sm *>(si)->reset());
ffffffff81019f76:	48 8b 40 18          	mov    0x18(%rax),%rax
    }

    ALWAYS_INLINE
    inline void set_si_regs(mword sig, mword cnt) {
        regs.ARG_2 = sig;
        regs.ARG_3 = cnt;
ffffffff81019f7a:	48 89 93 10 01 00 00 	mov    %rdx,0x110(%rbx)
            timeout.dequeue();
    }

    ALWAYS_INLINE
    inline void set_si_regs(mword sig, mword cnt) {
        regs.ARG_2 = sig;
ffffffff81019f81:	48 89 83 f0 00 00 00 	mov    %rax,0xf0(%rbx)
ffffffff81019f88:	e9 aa 00 00 00       	jmpq   ffffffff8101a037 <_ZN2Ec13sys_xcpu_callEv+0x33d>

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
                if (Atomic::cmp_swap (ref, r, r + 1))
ffffffff81019f8d:	8d 50 01             	lea    0x1(%rax),%edx
ffffffff81019f90:	f0 0f b1 93 8c 00 00 	lock cmpxchg %edx,0x8c(%rbx)
ffffffff81019f97:	00 
ffffffff81019f98:	74 0a                	je     ffffffff81019fa4 <_ZN2Ec13sys_xcpu_callEv+0x2aa>
        inline Refex() : ref (1) {}

        ALWAYS_INLINE
        inline bool add_ref()
        {
            for (uint32 r; (r = ref), (r != ex); )
ffffffff81019f9a:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
ffffffff81019fa0:	85 c0                	test   %eax,%eax
ffffffff81019fa2:	75 e9                	jne    ffffffff81019f8d <_ZN2Ec13sys_xcpu_callEv+0x293>
        inline T *head() const { return headptr; }

        ALWAYS_INLINE
        inline void enqueue (T *t)
        {
            if (!headptr)
ffffffff81019fa4:	48 8b 85 90 00 00 00 	mov    0x90(%rbp),%rax
ffffffff81019fab:	48 85 c0             	test   %rax,%rax
ffffffff81019fae:	75 17                	jne    ffffffff81019fc7 <_ZN2Ec13sys_xcpu_callEv+0x2cd>
                headptr = t->prev = t->next = t;
ffffffff81019fb0:	48 89 9b b0 02 00 00 	mov    %rbx,0x2b0(%rbx)
ffffffff81019fb7:	48 89 9b a8 02 00 00 	mov    %rbx,0x2a8(%rbx)
ffffffff81019fbe:	48 89 9d 90 00 00 00 	mov    %rbx,0x90(%rbp)
ffffffff81019fc5:	eb 2a                	jmp    ffffffff81019ff1 <_ZN2Ec13sys_xcpu_callEv+0x2f7>
            else {
                t->next = headptr;
ffffffff81019fc7:	48 89 83 b0 02 00 00 	mov    %rax,0x2b0(%rbx)
                t->prev = headptr->prev;
ffffffff81019fce:	48 8b 95 90 00 00 00 	mov    0x90(%rbp),%rdx
ffffffff81019fd5:	48 8b 92 a8 02 00 00 	mov    0x2a8(%rdx),%rdx
ffffffff81019fdc:	48 89 93 a8 02 00 00 	mov    %rdx,0x2a8(%rbx)
                t->next->prev = t->prev->next = t;
ffffffff81019fe3:	48 89 9a b0 02 00 00 	mov    %rbx,0x2b0(%rdx)
ffffffff81019fea:	48 89 98 a8 02 00 00 	mov    %rbx,0x2a8(%rax)
ffffffff81019ff1:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff81019ff7:	45 84 e4             	test   %r12b,%r12b
ffffffff81019ffa:	74 59                	je     ffffffff8101a055 <_ZN2Ec13sys_xcpu_callEv+0x35b>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff81019ffc:	80 3d 2d 57 fe 3e 00 	cmpb   $0x0,0x3efe572d(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8101a003:	74 28                	je     ffffffff8101a02d <_ZN2Ec13sys_xcpu_callEv+0x333>
ffffffff8101a005:	49 c7 c0 c0 12 02 81 	mov    $0xffffffff810212c0,%r8
ffffffff8101a00c:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff8101a011:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8101a018:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff8101a01f:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8101a026:	31 c0                	xor    %eax,%eax
ffffffff8101a028:	e8 23 7f fe ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            preemption = true;
ffffffff8101a02d:	c6 05 fc 56 fe 3e 01 	movb   $0x1,0x3efe56fc(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8101a034:	fb                   	sti    
ffffffff8101a035:	eb 1e                	jmp    ffffffff8101a055 <_ZN2Ec13sys_xcpu_callEv+0x35b>
ffffffff8101a037:	fe 85 8a 00 00 00    	incb   0x8a(%rbp)
ffffffff8101a03d:	45 84 e4             	test   %r12b,%r12b
ffffffff8101a040:	74 1b                	je     ffffffff8101a05d <_ZN2Ec13sys_xcpu_callEv+0x363>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8101a042:	80 3d e7 56 fe 3e 00 	cmpb   $0x0,0x3efe56e7(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8101a049:	75 ba                	jne    ffffffff8101a005 <_ZN2Ec13sys_xcpu_callEv+0x30b>

            preemption = true;
ffffffff8101a04b:	c6 05 de 56 fe 3e 01 	movb   $0x1,0x3efe56de(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8101a052:	fb                   	sti    
ffffffff8101a053:	eb 08                	jmp    ffffffff8101a05d <_ZN2Ec13sys_xcpu_callEv+0x363>
            if (!block)
                Sc::schedule (false);

            ec->set_timeout (t, this);

            ec->block_sc();
ffffffff8101a055:	48 89 df             	mov    %rbx,%rdi
ffffffff8101a058:	e8 11 17 ff ff       	callq  ffffffff8100b76e <_ZN2Ec8block_scEv>

    ret_xcpu_reply();
ffffffff8101a05d:	e8 d2 d1 ff ff       	callq  ffffffff81017234 <_ZN2Ec14ret_xcpu_replyEv>

ffffffff8101a062 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE6ELb0EEEvv>:
#include "syscall.hpp"
#include "utcb.hpp"
#include "vectors.hpp"

template <Sys_regs::Status S, bool T>
void Ec::sys_finish()
ffffffff8101a062:	53                   	push   %rbx
ffffffff8101a063:	48 83 ec 10          	sub    $0x10,%rsp
{
    if (T)
        current->clr_timeout();

    current->regs.set_status (S);
ffffffff8101a067:	48 8b 05 9a 4f fe 3e 	mov    0x3efe4f9a(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>

    if (current->xcpu_sm)
ffffffff8101a06e:	48 83 b8 30 03 00 00 	cmpq   $0x0,0x330(%rax)
ffffffff8101a075:	00 

        ALWAYS_INLINE
        inline void set_status (Status s, bool c = true)
        {
            if (c)
                ARG_1 = s;
ffffffff8101a076:	48 c7 80 e8 00 00 00 	movq   $0x6,0xe8(%rax)
ffffffff8101a07d:	06 00 00 00 
ffffffff8101a081:	74 05                	je     ffffffff8101a088 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE6ELb0EEEvv+0x26>
        xcpu_return();
ffffffff8101a083:	e8 ee b2 fe ff       	callq  ffffffff81005376 <_ZN2Ec11xcpu_returnEv>

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
ffffffff8101a088:	48 8b 1d 81 4f fe 3e 	mov    0x3efe4f81(%rip),%rbx        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8101a08f:	31 f6                	xor    %esi,%esi
ffffffff8101a091:	48 8d bb 08 03 00 00 	lea    0x308(%rbx),%rdi
ffffffff8101a098:	e8 a5 cf ff ff       	callq  ffffffff81017042 <_ZN5Quota9hit_limitEm>
ffffffff8101a09d:	84 c0                	test   %al,%al
ffffffff8101a09f:	75 05                	jne    ffffffff8101a0a6 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE6ELb0EEEvv+0x44>
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());

    ret_user_sysexit();
ffffffff8101a0a1:	e8 5a 5f fe ff       	callq  ffffffff81000000 <_ZN2Ec16ret_user_sysexitEv>

    if (current->xcpu_sm)
        xcpu_return();

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());
ffffffff8101a0a6:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff8101a0ab:	8b 35 53 4f fe 3e    	mov    0x3efe4f53(%rip),%esi        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8101a0b1:	48 8b 8b 20 03 00 00 	mov    0x320(%rbx),%rcx
ffffffff8101a0b8:	48 8b 93 10 03 00 00 	mov    0x310(%rbx),%rdx
ffffffff8101a0bf:	48 c7 c7 7c 0c 02 81 	mov    $0xffffffff81020c7c,%rdi
ffffffff8101a0c6:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8101a0cc:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff8101a0d2:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
ffffffff8101a0d9:	48 0f 45 f0          	cmovne %rax,%rsi
ffffffff8101a0dd:	31 c0                	xor    %eax,%eax
ffffffff8101a0df:	e8 a8 7f fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff8101a0e4:	eb bb                	jmp    ffffffff8101a0a1 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE6ELb0EEEvv+0x3f>

ffffffff8101a0e6 <_ZN2Ec13sys_create_ecEv>:

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_create_ec()
{
ffffffff8101a0e6:	41 57                	push   %r15
ffffffff8101a0e8:	41 56                	push   %r14
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
ffffffff8101a0ea:	31 f6                	xor    %esi,%esi

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_create_ec()
{
ffffffff8101a0ec:	41 55                	push   %r13
ffffffff8101a0ee:	41 54                	push   %r12
ffffffff8101a0f0:	55                   	push   %rbp
ffffffff8101a0f1:	53                   	push   %rbx
ffffffff8101a0f2:	48 83 ec 48          	sub    $0x48,%rsp
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
ffffffff8101a0f6:	48 8b 05 13 4f fe 3e 	mov    0x3efe4f13(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8101a0fd:	48 8d b8 08 03 00 00 	lea    0x308(%rax),%rdi
ffffffff8101a104:	e8 39 cf ff ff       	callq  ffffffff81017042 <_ZN5Quota9hit_limitEm>
ffffffff8101a109:	84 c0                	test   %al,%al
ffffffff8101a10b:	74 05                	je     ffffffff8101a112 <_ZN2Ec13sys_create_ecEv+0x2c>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu (%lu)", __func__, __LINE__, Pd::current->quota.usage(), Pd::current->quota.limit(), r);

        if (Ec::current->pt_oom && call)
            Ec::current->oom_call_cpu (Ec::current->pt_oom, Ec::current->pt_oom->id, C, C);

        sys_finish<Sys_regs::QUO_OOM>();
ffffffff8101a10d:	e8 ba e2 ff ff       	callq  ffffffff810183cc <_ZN2Ec10sys_finishILN8Sys_regs6StatusE9ELb0EEEvv>

void Ec::sys_create_ec()
{
    check<sys_create_ec>(0, false);

    Sys_create_ec *r = static_cast<Sys_create_ec *>(current->sys_regs());
ffffffff8101a112:	48 8b 2d ef 4e fe 3e 	mov    0x3efe4eef(%rip),%rbp        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8101a119:	48 8d 5c 24 37       	lea    0x37(%rsp),%rbx
ffffffff8101a11e:	48 8b 95 10 01 00 00 	mov    0x110(%rbp),%rdx

        ALWAYS_INLINE
        inline unsigned long pd() const { return ARG_2; }

        ALWAYS_INLINE
        inline unsigned cpu() const { return ARG_3 & 0xfff; }
ffffffff8101a125:	89 d1                	mov    %edx,%ecx
ffffffff8101a127:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
ffffffff8101a12d:	83 f9 3f             	cmp    $0x3f,%ecx
ffffffff8101a130:	77 0c                	ja     ffffffff8101a13e <_ZN2Ec13sys_create_ecEv+0x58>

    trace (TRACE_SYSCALL, "EC:%p SYS_CREATE EC:%#lx CPU:%#x UTCB:%#lx ESP:%#lx EVT:%#x", current, r->sel(), r->cpu(), r->utcb(), r->esp(), r->evt());

    if (EXPECT_FALSE (!Hip::cpu_online (r->cpu()))) {
ffffffff8101a132:	89 c8                	mov    %ecx,%eax
ffffffff8101a134:	f6 04 c5 38 70 16 81 	testb  $0x1,-0x7ee98fc8(,%rax,8)
ffffffff8101a13b:	01 
ffffffff8101a13c:	75 39                	jne    ffffffff8101a177 <_ZN2Ec13sys_create_ecEv+0x91>
        trace (TRACE_ERROR, "%s: Invalid CPU (%#x)", __func__, r->cpu());
ffffffff8101a13e:	8b 35 c0 4e fe 3e    	mov    0x3efe4ec0(%rip),%esi        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8101a144:	48 81 e3 00 f0 ff ff 	and    $0xfffffffffffff000,%rbx
ffffffff8101a14b:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
ffffffff8101a152:	48 81 fb 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rbx
ffffffff8101a159:	48 c7 c2 b8 11 02 81 	mov    $0xffffffff810211b8,%rdx
ffffffff8101a160:	48 c7 c7 e4 0f 02 81 	mov    $0xffffffff81020fe4,%rdi
ffffffff8101a167:	48 0f 45 f0          	cmovne %rax,%rsi
ffffffff8101a16b:	31 c0                	xor    %eax,%eax
ffffffff8101a16d:	e8 1a 7f fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_CPU>();
ffffffff8101a172:	e8 41 f6 ff ff       	callq  ffffffff810197b8 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE7ELb0EEEvv>
    }

    if (EXPECT_FALSE (!r->utcb() && !(Hip::feature() & (Hip::FEAT_VMX | Hip::FEAT_SVM)))) {
ffffffff8101a177:	48 81 e2 00 f0 ff ff 	and    $0xfffffffffffff000,%rdx
ffffffff8101a17e:	49 89 d4             	mov    %rdx,%r12
ffffffff8101a181:	75 42                	jne    ffffffff8101a1c5 <_ZN2Ec13sys_create_ecEv+0xdf>
ffffffff8101a183:	f6 05 86 ce 14 00 06 	testb  $0x6,0x14ce86(%rip)        # ffffffff81167010 <PAGE_H+0x10>
ffffffff8101a18a:	75 39                	jne    ffffffff8101a1c5 <_ZN2Ec13sys_create_ecEv+0xdf>
        trace (TRACE_ERROR, "%s: VCPUs not supported", __func__);
ffffffff8101a18c:	8b 35 72 4e fe 3e    	mov    0x3efe4e72(%rip),%esi        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8101a192:	48 81 e3 00 f0 ff ff 	and    $0xfffffffffffff000,%rbx
ffffffff8101a199:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
ffffffff8101a1a0:	48 81 fb 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rbx
ffffffff8101a1a7:	48 c7 c2 b8 11 02 81 	mov    $0xffffffff810211b8,%rdx
ffffffff8101a1ae:	48 c7 c7 01 10 02 81 	mov    $0xffffffff81021001,%rdi
ffffffff8101a1b5:	48 0f 45 f0          	cmovne %rax,%rsi
ffffffff8101a1b9:	31 c0                	xor    %eax,%eax
ffffffff8101a1bb:	e8 cc 7e fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_FTR>();
ffffffff8101a1c0:	e8 9d fe ff ff       	callq  ffffffff8101a062 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE6ELb0EEEvv>
ffffffff8101a1c5:	48 8b 8d f0 00 00 00 	mov    0xf0(%rbp),%rcx
ffffffff8101a1cc:	48 89 c8             	mov    %rcx,%rax
ffffffff8101a1cf:	25 ff ff ff 03       	and    $0x3ffffff,%eax
        static unsigned const caps = (END_SPACE_LIM - SPC_LOCAL_OBJ) / sizeof (Capability);

        ALWAYS_INLINE
        static inline Capability lookup (unsigned long idx)
        {
            return *reinterpret_cast<Capability *>(idx_to_virt (idx));
ffffffff8101a1d4:	48 8b 04 c5 00 00 00 	mov    -0x20000000(,%rax,8),%rax
ffffffff8101a1db:	e0 
ffffffff8101a1dc:	49 89 c6             	mov    %rax,%r14
ffffffff8101a1df:	49 83 e6 e0          	and    $0xffffffffffffffe0,%r14
ffffffff8101a1e3:	74 0e                	je     ffffffff8101a1f3 <_ZN2Ec13sys_create_ecEv+0x10d>
    }

    Capability cap_pd = Space_obj::lookup (r->pd());
    if (EXPECT_FALSE (cap_pd.obj()->type() != Kobject::PD) || !(cap_pd.prm() & 1UL << Kobject::EC)) {
ffffffff8101a1e5:	41 80 be 88 00 00 00 	cmpb   $0x0,0x88(%r14)
ffffffff8101a1ec:	00 
ffffffff8101a1ed:	75 04                	jne    ffffffff8101a1f3 <_ZN2Ec13sys_create_ecEv+0x10d>
ffffffff8101a1ef:	a8 02                	test   $0x2,%al
ffffffff8101a1f1:	75 36                	jne    ffffffff8101a229 <_ZN2Ec13sys_create_ecEv+0x143>
        trace (TRACE_ERROR, "%s: Non-PD CAP (%#lx)", __func__, r->pd());
ffffffff8101a1f3:	8b 05 0b 4e fe 3e    	mov    0x3efe4e0b(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8101a1f9:	48 81 e3 00 f0 ff ff 	and    $0xfffffffffffff000,%rbx
ffffffff8101a200:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff8101a204:	48 81 fb 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rbx
ffffffff8101a20b:	48 c7 c2 b8 11 02 81 	mov    $0xffffffff810211b8,%rdx
ffffffff8101a212:	48 c7 c7 50 0d 02 81 	mov    $0xffffffff81020d50,%rdi
ffffffff8101a219:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff8101a21d:	31 c0                	xor    %eax,%eax
ffffffff8101a21f:	e8 68 7e fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff8101a224:	e9 93 01 00 00       	jmpq   ffffffff8101a3bc <_ZN2Ec13sys_create_ecEv+0x2d6>
        sys_finish<Sys_regs::BAD_CAP>();
    }
    Pd *pd = static_cast<Pd *>(cap_pd.obj());

    if (pd->quota.hit_limit(7)) {
ffffffff8101a229:	4d 8d ae 08 03 00 00 	lea    0x308(%r14),%r13
ffffffff8101a230:	be 07 00 00 00       	mov    $0x7,%esi
ffffffff8101a235:	4c 89 ef             	mov    %r13,%rdi
ffffffff8101a238:	e8 05 ce ff ff       	callq  ffffffff81017042 <_ZN5Quota9hit_limitEm>
ffffffff8101a23d:	84 c0                	test   %al,%al
ffffffff8101a23f:	0f 85 c8 fe ff ff    	jne    ffffffff8101a10d <_ZN2Ec13sys_create_ecEv+0x27>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu", __func__, __LINE__, pd->quota.usage(), pd->quota.limit());
        sys_finish<Sys_regs::QUO_OOM>();
    }

    if (EXPECT_FALSE (r->utcb() >= USER_ADDR || r->utcb() & PAGE_MASK || !pd->insert_utcb (pd->quota, r->utcb()))) {
ffffffff8101a245:	48 b8 ff ef ff ff ff 	movabs $0x7fffffffefff,%rax
ffffffff8101a24c:	7f 00 00 
ffffffff8101a24f:	49 39 c4             	cmp    %rax,%r12
ffffffff8101a252:	0f 87 76 01 00 00    	ja     ffffffff8101a3ce <_ZN2Ec13sys_create_ecEv+0x2e8>
ffffffff8101a258:	49 8d be 90 00 00 00 	lea    0x90(%r14),%rdi
ffffffff8101a25f:	31 c9                	xor    %ecx,%ecx
ffffffff8101a261:	4c 89 e2             	mov    %r12,%rdx
ffffffff8101a264:	4c 89 ee             	mov    %r13,%rsi
ffffffff8101a267:	e8 c6 c4 ff ff       	callq  ffffffff81016732 <_ZN9Space_mem11insert_utcbER5Quotamm>
ffffffff8101a26c:	84 c0                	test   %al,%al
ffffffff8101a26e:	0f 84 5a 01 00 00    	je     ffffffff8101a3ce <_ZN2Ec13sys_create_ecEv+0x2e8>
ffffffff8101a274:	48 8b 8d e8 00 00 00 	mov    0xe8(%rbp),%rcx

class Sys_create_ec : public Sys_regs
{
    public:
        ALWAYS_INLINE
        inline unsigned long sel() const { return ARG_1 >> 8; }
ffffffff8101a27b:	48 89 ca             	mov    %rcx,%rdx
ffffffff8101a27e:	48 c1 ea 08          	shr    $0x8,%rdx
        trace (TRACE_ERROR, "%s: Invalid UTCB address (%#lx)", __func__, r->utcb());
        sys_finish<Sys_regs::BAD_PAR>();
    }

    Capability cap_pt = Space_obj::lookup (r->sel() + 1);
ffffffff8101a282:	48 8d 42 01          	lea    0x1(%rdx),%rax
{
    private:
        ALWAYS_INLINE
        static inline mword idx_to_virt (unsigned long idx)
        {
            return SPC_LOCAL_OBJ + (idx % caps) * sizeof (Capability);
ffffffff8101a286:	25 ff ff ff 03       	and    $0x3ffffff,%eax
ffffffff8101a28b:	4c 8b 24 c5 00 00 00 	mov    -0x20000000(,%rax,8),%r12
ffffffff8101a292:	e0 
ffffffff8101a293:	49 83 e4 e0          	and    $0xffffffffffffffe0,%r12
ffffffff8101a297:	0f 84 29 01 00 00    	je     ffffffff8101a3c6 <_ZN2Ec13sys_create_ecEv+0x2e0>
    Pt *pt = cap_pt.obj()->type() == Kobject::PT ? static_cast<Pt *>(cap_pt.obj()) : nullptr;
ffffffff8101a29d:	41 80 bc 24 88 00 00 	cmpb   $0x3,0x88(%r12)
ffffffff8101a2a4:	00 03 
ffffffff8101a2a6:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff8101a2ab:	4c 0f 45 e0          	cmovne %rax,%r12

    Ec *ec = new (pd->quota) Ec (Pd::current, r->sel(), pd, r->flags() & 1 ? static_cast<void (*)()>(send_msg<ret_user_iret>) : nullptr, r->cpu(), r->evt(), r->utcb(), r->esp(), pt);
ffffffff8101a2af:	80 e1 10             	and    $0x10,%cl
ffffffff8101a2b2:	4c 8b 8d 10 01 00 00 	mov    0x110(%rbp),%r9

        ALWAYS_INLINE
        inline mword esp() const { return ARG_4; }

        ALWAYS_INLINE
        inline unsigned evt() const { return static_cast<unsigned>(ARG_5); }
ffffffff8101a2b9:	48 8b 8d e0 00 00 00 	mov    0xe0(%rbp),%rcx
ffffffff8101a2c0:	4c 8b 95 20 01 00 00 	mov    0x120(%rbp),%r10
ffffffff8101a2c7:	b8 00 00 00 00       	mov    $0x0,%eax
ffffffff8101a2cc:	49 c7 c0 42 7c 01 81 	mov    $0xffffffff81017c42,%r8
ffffffff8101a2d3:	4c 0f 44 c0          	cmove  %rax,%r8

    static void idl_handler();

    ALWAYS_INLINE
    static inline void *operator new (size_t, Quota &quota) {
        return cache.alloc(quota);
ffffffff8101a2d7:	4c 89 ee             	mov    %r13,%rsi
ffffffff8101a2da:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff8101a2e1:	48 89 54 24 28       	mov    %rdx,0x28(%rsp)
ffffffff8101a2e6:	4c 89 44 24 20       	mov    %r8,0x20(%rsp)
ffffffff8101a2eb:	4c 89 4c 24 18       	mov    %r9,0x18(%rsp)
ffffffff8101a2f0:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
ffffffff8101a2f5:	4c 89 54 24 08       	mov    %r10,0x8(%rsp)
ffffffff8101a2fa:	e8 2f b6 ff ff       	callq  ffffffff8101592e <_ZN10Slab_cache5allocER5Quota>
ffffffff8101a2ff:	41 54                	push   %r12
ffffffff8101a301:	4c 8b 54 24 10       	mov    0x10(%rsp),%r10
ffffffff8101a306:	49 89 c7             	mov    %rax,%r15
ffffffff8101a309:	48 8b 35 00 4d fe 3e 	mov    0x3efe4d00(%rip),%rsi        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8101a310:	4c 89 ff             	mov    %r15,%rdi
ffffffff8101a313:	41 52                	push   %r10

        ALWAYS_INLINE
        inline unsigned cpu() const { return ARG_3 & 0xfff; }

        ALWAYS_INLINE
        inline mword utcb() const { return ARG_3 & ~0xfff; }
ffffffff8101a315:	4c 8b 4c 24 28       	mov    0x28(%rsp),%r9
ffffffff8101a31a:	4c 89 c8             	mov    %r9,%rax
ffffffff8101a31d:	41 81 e1 ff 0f 00 00 	and    $0xfff,%r9d
ffffffff8101a324:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8101a32a:	50                   	push   %rax
ffffffff8101a32b:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
ffffffff8101a330:	51                   	push   %rcx
ffffffff8101a331:	4c 8b 44 24 40       	mov    0x40(%rsp),%r8
ffffffff8101a336:	4c 89 f1             	mov    %r14,%rcx
ffffffff8101a339:	48 8b 54 24 48       	mov    0x48(%rsp),%rdx
ffffffff8101a33e:	e8 87 97 fe ff       	callq  ffffffff81003aca <_ZN2EcC1EP2PdmS1_PFvvEjjmmP2Pt>

    if (!Space_obj::insert_root (pd->quota, ec)) {
ffffffff8101a343:	48 83 c4 20          	add    $0x20,%rsp
ffffffff8101a347:	4c 89 fe             	mov    %r15,%rsi
ffffffff8101a34a:	4c 89 ef             	mov    %r13,%rdi
ffffffff8101a34d:	e8 18 c7 ff ff       	callq  ffffffff81016a6a <_ZN9Space_obj11insert_rootER5QuotaP7Kobject>
ffffffff8101a352:	84 c0                	test   %al,%al
ffffffff8101a354:	75 6b                	jne    ffffffff8101a3c1 <_ZN2Ec13sys_create_ecEv+0x2db>
        trace (TRACE_ERROR, "%s: Non-NULL CAP (%#lx)", __func__, r->sel());
ffffffff8101a356:	8b 05 a8 4c fe 3e    	mov    0x3efe4ca8(%rip),%eax        # ffffffffbffff004 <_ZN3Cpu2idE>

class Sys_create_ec : public Sys_regs
{
    public:
        ALWAYS_INLINE
        inline unsigned long sel() const { return ARG_1 >> 8; }
ffffffff8101a35c:	48 8b 8d e8 00 00 00 	mov    0xe8(%rbp),%rcx
ffffffff8101a363:	48 81 e3 00 f0 ff ff 	and    $0xfffffffffffff000,%rbx
ffffffff8101a36a:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff8101a36e:	48 c7 c2 b8 11 02 81 	mov    $0xffffffff810211b8,%rdx
ffffffff8101a375:	48 c7 c7 a4 0d 02 81 	mov    $0xffffffff81020da4,%rdi
ffffffff8101a37c:	48 c1 e9 08          	shr    $0x8,%rcx
ffffffff8101a380:	48 81 fb 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rbx
ffffffff8101a387:	48 0f 44 f0          	cmove  %rax,%rsi
ffffffff8101a38b:	31 c0                	xor    %eax,%eax
ffffffff8101a38d:	e8 fa 7c fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
        delete ec;
ffffffff8101a392:	4d 85 ff             	test   %r15,%r15
ffffffff8101a395:	74 25                	je     ffffffff8101a3bc <_ZN2Ec13sys_create_ecEv+0x2d6>
ffffffff8101a397:	4c 89 ff             	mov    %r15,%rdi
ffffffff8101a39a:	e8 9d a0 fe ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff8101a39f:	49 8b 87 98 02 00 00 	mov    0x298(%r15),%rax
ffffffff8101a3a6:	4c 89 fe             	mov    %r15,%rsi
ffffffff8101a3a9:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff8101a3b0:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff8101a3b7:	e8 ae b6 ff ff       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>
        sys_finish<Sys_regs::BAD_CAP>();
ffffffff8101a3bc:	e8 73 dc ff ff       	callq  ffffffff81018034 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>
    }

    sys_finish<Sys_regs::SUCCESS>();
ffffffff8101a3c1:	e8 92 cc ff ff       	callq  ffffffff81017058 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb0EEEvv>
        trace (TRACE_ERROR, "%s: Invalid UTCB address (%#lx)", __func__, r->utcb());
        sys_finish<Sys_regs::BAD_PAR>();
    }

    Capability cap_pt = Space_obj::lookup (r->sel() + 1);
    Pt *pt = cap_pt.obj()->type() == Kobject::PT ? static_cast<Pt *>(cap_pt.obj()) : nullptr;
ffffffff8101a3c6:	45 31 e4             	xor    %r12d,%r12d
ffffffff8101a3c9:	e9 e1 fe ff ff       	jmpq   ffffffff8101a2af <_ZN2Ec13sys_create_ecEv+0x1c9>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu", __func__, __LINE__, pd->quota.usage(), pd->quota.limit());
        sys_finish<Sys_regs::QUO_OOM>();
    }

    if (EXPECT_FALSE (r->utcb() >= USER_ADDR || r->utcb() & PAGE_MASK || !pd->insert_utcb (pd->quota, r->utcb()))) {
        trace (TRACE_ERROR, "%s: Invalid UTCB address (%#lx)", __func__, r->utcb());
ffffffff8101a3ce:	8b 35 30 4c fe 3e    	mov    0x3efe4c30(%rip),%esi        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8101a3d4:	48 8b 8d 10 01 00 00 	mov    0x110(%rbp),%rcx
ffffffff8101a3db:	48 81 e3 00 f0 ff ff 	and    $0xfffffffffffff000,%rbx
ffffffff8101a3e2:	48 81 fb 00 d0 ff bf 	cmp    $0xffffffffbfffd000,%rbx
ffffffff8101a3e9:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
ffffffff8101a3f0:	48 c7 c2 b8 11 02 81 	mov    $0xffffffff810211b8,%rdx
ffffffff8101a3f7:	48 c7 c7 20 10 02 81 	mov    $0xffffffff81021020,%rdi
ffffffff8101a3fe:	48 0f 45 f0          	cmovne %rax,%rsi

        ALWAYS_INLINE
        inline unsigned cpu() const { return ARG_3 & 0xfff; }

        ALWAYS_INLINE
        inline mword utcb() const { return ARG_3 & ~0xfff; }
ffffffff8101a402:	48 81 e1 00 f0 ff ff 	and    $0xfffffffffffff000,%rcx
ffffffff8101a409:	31 c0                	xor    %eax,%eax
ffffffff8101a40b:	e8 7c 7c fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_PAR>();
ffffffff8101a410:	e8 8b ec ff ff       	callq  ffffffff810190a0 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE5ELb0EEEvv>
ffffffff8101a415:	90                   	nop

ffffffff8101a416 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE8ELb0EEEvv>:
#include "syscall.hpp"
#include "utcb.hpp"
#include "vectors.hpp"

template <Sys_regs::Status S, bool T>
void Ec::sys_finish()
ffffffff8101a416:	53                   	push   %rbx
ffffffff8101a417:	48 83 ec 10          	sub    $0x10,%rsp
{
    if (T)
        current->clr_timeout();

    current->regs.set_status (S);
ffffffff8101a41b:	48 8b 05 e6 4b fe 3e 	mov    0x3efe4be6(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>

    if (current->xcpu_sm)
ffffffff8101a422:	48 83 b8 30 03 00 00 	cmpq   $0x0,0x330(%rax)
ffffffff8101a429:	00 
ffffffff8101a42a:	48 c7 80 e8 00 00 00 	movq   $0x8,0xe8(%rax)
ffffffff8101a431:	08 00 00 00 
ffffffff8101a435:	74 05                	je     ffffffff8101a43c <_ZN2Ec10sys_finishILN8Sys_regs6StatusE8ELb0EEEvv+0x26>
        xcpu_return();
ffffffff8101a437:	e8 3a af fe ff       	callq  ffffffff81005376 <_ZN2Ec11xcpu_returnEv>

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
ffffffff8101a43c:	48 8b 1d cd 4b fe 3e 	mov    0x3efe4bcd(%rip),%rbx        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8101a443:	31 f6                	xor    %esi,%esi
ffffffff8101a445:	48 8d bb 08 03 00 00 	lea    0x308(%rbx),%rdi
ffffffff8101a44c:	e8 f1 cb ff ff       	callq  ffffffff81017042 <_ZN5Quota9hit_limitEm>
ffffffff8101a451:	84 c0                	test   %al,%al
ffffffff8101a453:	75 05                	jne    ffffffff8101a45a <_ZN2Ec10sys_finishILN8Sys_regs6StatusE8ELb0EEEvv+0x44>
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());

    ret_user_sysexit();
ffffffff8101a455:	e8 a6 5b fe ff       	callq  ffffffff81000000 <_ZN2Ec16ret_user_sysexitEv>

    if (current->xcpu_sm)
        xcpu_return();

    if (Pd::current->quota.hit_limit() && S != Sys_regs::QUO_OOM)
        trace (0, "warning: insufficient resources %lu/%lu", Pd::current->quota.usage(), Pd::current->quota.limit());
ffffffff8101a45a:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff8101a45f:	8b 35 9f 4b fe 3e    	mov    0x3efe4b9f(%rip),%esi        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8101a465:	48 8b 8b 20 03 00 00 	mov    0x320(%rbx),%rcx
ffffffff8101a46c:	48 8b 93 10 03 00 00 	mov    0x310(%rbx),%rdx
ffffffff8101a473:	48 c7 c7 7c 0c 02 81 	mov    $0xffffffff81020c7c,%rdi
ffffffff8101a47a:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8101a480:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff8101a486:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
ffffffff8101a48d:	48 0f 45 f0          	cmovne %rax,%rsi
ffffffff8101a491:	31 c0                	xor    %eax,%eax
ffffffff8101a493:	e8 f4 7b fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff8101a498:	eb bb                	jmp    ffffffff8101a455 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE8ELb0EEEvv+0x3f>

ffffffff8101a49a <_ZN2Ec14sys_assign_pciEv>:

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_assign_pci()
{
ffffffff8101a49a:	55                   	push   %rbp
ffffffff8101a49b:	53                   	push   %rbx
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
ffffffff8101a49c:	be 04 00 00 00       	mov    $0x4,%esi

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_assign_pci()
{
ffffffff8101a4a1:	48 83 ec 18          	sub    $0x18,%rsp
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
ffffffff8101a4a5:	48 8b 05 64 4b fe 3e 	mov    0x3efe4b64(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8101a4ac:	48 8d b8 08 03 00 00 	lea    0x308(%rax),%rdi
ffffffff8101a4b3:	e8 8a cb ff ff       	callq  ffffffff81017042 <_ZN5Quota9hit_limitEm>
ffffffff8101a4b8:	84 c0                	test   %al,%al
ffffffff8101a4ba:	48 8b 2d 47 4b fe 3e 	mov    0x3efe4b47(%rip),%rbp        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8101a4c1:	74 25                	je     ffffffff8101a4e8 <_ZN2Ec14sys_assign_pciEv+0x4e>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu (%lu)", __func__, __LINE__, Pd::current->quota.usage(), Pd::current->quota.limit(), r);

        if (Ec::current->pt_oom && call)
ffffffff8101a4c3:	48 8b b5 38 03 00 00 	mov    0x338(%rbp),%rsi
ffffffff8101a4ca:	48 85 f6             	test   %rsi,%rsi
ffffffff8101a4cd:	74 58                	je     ffffffff8101a527 <_ZN2Ec14sys_assign_pciEv+0x8d>
            Ec::current->oom_call_cpu (Ec::current->pt_oom, Ec::current->pt_oom->id, C, C);
ffffffff8101a4cf:	48 8b 96 a8 00 00 00 	mov    0xa8(%rsi),%rdx
ffffffff8101a4d6:	49 c7 c0 9a a4 01 81 	mov    $0xffffffff8101a49a,%r8
ffffffff8101a4dd:	48 89 ef             	mov    %rbp,%rdi
ffffffff8101a4e0:	4c 89 c1             	mov    %r8,%rcx
ffffffff8101a4e3:	e8 b2 56 ff ff       	callq  ffffffff8100fb9a <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_>

class Sys_assign_pci : public Sys_regs
{
    public:
        ALWAYS_INLINE
        inline unsigned long pd() const { return ARG_1 >> 8; }
ffffffff8101a4e8:	48 8b 8d e8 00 00 00 	mov    0xe8(%rbp),%rcx
ffffffff8101a4ef:	48 c1 e9 08          	shr    $0x8,%rcx
ffffffff8101a4f3:	48 89 c8             	mov    %rcx,%rax
ffffffff8101a4f6:	25 ff ff ff 03       	and    $0x3ffffff,%eax
ffffffff8101a4fb:	48 8b 1c c5 00 00 00 	mov    -0x20000000(,%rax,8),%rbx
ffffffff8101a502:	e0 
ffffffff8101a503:	48 83 e3 e0          	and    $0xffffffffffffffe0,%rbx
ffffffff8101a507:	74 23                	je     ffffffff8101a52c <_ZN2Ec14sys_assign_pciEv+0x92>
    check<sys_assign_pci>(4);

    Sys_assign_pci *r = static_cast<Sys_assign_pci *>(current->sys_regs());

    Kobject *obj = Space_obj::lookup (r->pd()).obj();
    if (EXPECT_FALSE (obj->type() != Kobject::PD)) {
ffffffff8101a509:	80 bb 88 00 00 00 00 	cmpb   $0x0,0x88(%rbx)
ffffffff8101a510:	75 1a                	jne    ffffffff8101a52c <_ZN2Ec14sys_assign_pciEv+0x92>
        sys_finish<Sys_regs::BAD_CAP>();
    }

    Pd * pd = static_cast<Pd *>(obj);

    if (pd->quota.hit_limit(4)) {
ffffffff8101a512:	48 8d bb 08 03 00 00 	lea    0x308(%rbx),%rdi
ffffffff8101a519:	be 04 00 00 00       	mov    $0x4,%esi
ffffffff8101a51e:	e8 1f cb ff ff       	callq  ffffffff81017042 <_ZN5Quota9hit_limitEm>
ffffffff8101a523:	84 c0                	test   %al,%al
ffffffff8101a525:	74 3e                	je     ffffffff8101a565 <_ZN2Ec14sys_assign_pciEv+0xcb>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu (%lu)", __func__, __LINE__, Pd::current->quota.usage(), Pd::current->quota.limit(), r);

        if (Ec::current->pt_oom && call)
            Ec::current->oom_call_cpu (Ec::current->pt_oom, Ec::current->pt_oom->id, C, C);

        sys_finish<Sys_regs::QUO_OOM>();
ffffffff8101a527:	e8 a0 de ff ff       	callq  ffffffff810183cc <_ZN2Ec10sys_finishILN8Sys_regs6StatusE9ELb0EEEvv>

    Sys_assign_pci *r = static_cast<Sys_assign_pci *>(current->sys_regs());

    Kobject *obj = Space_obj::lookup (r->pd()).obj();
    if (EXPECT_FALSE (obj->type() != Kobject::PD)) {
        trace (TRACE_ERROR, "%s: Non-PD CAP (%#lx)", __func__, r->pd());
ffffffff8101a52c:	8b 15 d2 4a fe 3e    	mov    0x3efe4ad2(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8101a532:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff8101a537:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff8101a53b:	48 c7 c7 50 0d 02 81 	mov    $0xffffffff81020d50,%rdi
ffffffff8101a542:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8101a548:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff8101a54e:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff8101a552:	48 c7 c2 28 11 02 81 	mov    $0xffffffff81021128,%rdx
ffffffff8101a559:	31 c0                	xor    %eax,%eax
ffffffff8101a55b:	e8 2c 7b fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_CAP>();
ffffffff8101a560:	e8 cf da ff ff       	callq  ffffffff81018034 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>

        ALWAYS_INLINE
        inline size_t lookup (mword virt, Paddr &phys)
        {
            mword attr;
            return hpt.lookup (virt, phys, attr);
ffffffff8101a565:	48 8b b5 f0 00 00 00 	mov    0xf0(%rbp),%rsi
ffffffff8101a56c:	48 8d bb a0 02 00 00 	lea    0x2a0(%rbx),%rdi
ffffffff8101a573:	48 8d 4c 24 08       	lea    0x8(%rsp),%rcx
ffffffff8101a578:	48 89 e2             	mov    %rsp,%rdx
ffffffff8101a57b:	e8 54 86 ff ff       	callq  ffffffff81012bd4 <_ZN3PteI3HptmLj4ELj9ELb0EE6lookupEmRmS2_>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu", __func__, __LINE__, pd->quota.usage(), pd->quota.limit());
        sys_finish<Sys_regs::QUO_OOM>();
    }

    Paddr phys; unsigned rid;
    if (EXPECT_FALSE (!pd->Space_mem::lookup (r->dev(), phys) || (rid = Pci::phys_to_rid (phys)) == ~0U)) {
ffffffff8101a580:	48 85 c0             	test   %rax,%rax
ffffffff8101a583:	0f 84 90 00 00 00    	je     ffffffff8101a619 <_ZN2Ec14sys_assign_pciEv+0x17f>
        static void init (unsigned = 0, unsigned = 0);

        ALWAYS_INLINE
        static inline unsigned phys_to_rid (Paddr p)
        {
            return p - cfg_base < cfg_size ? static_cast<unsigned>((bus_base << 8) + (p - cfg_base) / PAGE_SIZE) : ~0U;
ffffffff8101a589:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff8101a58d:	48 2b 35 6c 93 14 00 	sub    0x14936c(%rip),%rsi        # ffffffff81163900 <_ZN3Pci8cfg_baseE>
ffffffff8101a594:	48 3b 35 5d 93 14 00 	cmp    0x14935d(%rip),%rsi        # ffffffff811638f8 <_ZN3Pci8cfg_sizeE>
ffffffff8101a59b:	73 7c                	jae    ffffffff8101a619 <_ZN2Ec14sys_assign_pciEv+0x17f>
ffffffff8101a59d:	8b 05 65 93 14 00    	mov    0x149365(%rip),%eax        # ffffffff81163908 <_ZN3Pci8bus_baseE>
ffffffff8101a5a3:	48 c1 ee 0c          	shr    $0xc,%rsi
ffffffff8101a5a7:	c1 e0 08             	shl    $0x8,%eax
ffffffff8101a5aa:	01 c6                	add    %eax,%esi
ffffffff8101a5ac:	83 fe ff             	cmp    $0xffffffff,%esi
ffffffff8101a5af:	74 68                	je     ffffffff8101a619 <_ZN2Ec14sys_assign_pciEv+0x17f>
ffffffff8101a5b1:	48 8b 8d 10 01 00 00 	mov    0x110(%rbp),%rcx
        inline void write (Register r, T v) { *reinterpret_cast<T volatile *>(reg_base + r) = v; }

        ALWAYS_INLINE
        static inline Pci *find_dev (unsigned long r)
        {
            for (Pci *pci = list; pci; pci = pci->next)
ffffffff8101a5b8:	48 8b 05 31 93 14 00 	mov    0x149331(%rip),%rax        # ffffffff811638f0 <_ZN3Pci4listE>
ffffffff8101a5bf:	48 85 c0             	test   %rax,%rax
ffffffff8101a5c2:	74 19                	je     ffffffff8101a5dd <_ZN2Ec14sys_assign_pciEv+0x143>
                if (pci->rid == r)
ffffffff8101a5c4:	0f b7 50 10          	movzwl 0x10(%rax),%edx
ffffffff8101a5c8:	48 39 ca             	cmp    %rcx,%rdx
ffffffff8101a5cb:	75 0b                	jne    ffffffff8101a5d8 <_ZN2Ec14sys_assign_pciEv+0x13e>
        ALWAYS_INLINE
        static inline Dmar *find_dmar (unsigned long r)
        {
            Pci *pci = find_dev (r);

            return pci ? pci->dmar : nullptr;
ffffffff8101a5cd:	48 8b 78 18          	mov    0x18(%rax),%rdi
        trace (TRACE_ERROR, "%s: Non-DEV CAP (%#lx)", __func__, r->dev());
        sys_finish<Sys_regs::BAD_DEV>();
    }

    Dmar *dmar = Pci::find_dmar (r->hnt());
    if (EXPECT_FALSE (!dmar)) {
ffffffff8101a5d1:	48 85 ff             	test   %rdi,%rdi
ffffffff8101a5d4:	75 36                	jne    ffffffff8101a60c <_ZN2Ec14sys_assign_pciEv+0x172>
ffffffff8101a5d6:	eb 05                	jmp    ffffffff8101a5dd <_ZN2Ec14sys_assign_pciEv+0x143>
        inline void write (Register r, T v) { *reinterpret_cast<T volatile *>(reg_base + r) = v; }

        ALWAYS_INLINE
        static inline Pci *find_dev (unsigned long r)
        {
            for (Pci *pci = list; pci; pci = pci->next)
ffffffff8101a5d8:	48 8b 00             	mov    (%rax),%rax
ffffffff8101a5db:	eb e2                	jmp    ffffffff8101a5bf <_ZN2Ec14sys_assign_pciEv+0x125>
        trace (TRACE_ERROR, "%s: Invalid Hint (%#lx)", __func__, r->hnt());
ffffffff8101a5dd:	8b 15 21 4a fe 3e    	mov    0x3efe4a21(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8101a5e3:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff8101a5e8:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff8101a5ec:	48 c7 c7 65 10 02 81 	mov    $0xffffffff81021065,%rdi
ffffffff8101a5f3:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8101a5f9:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff8101a5ff:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff8101a603:	48 c7 c2 28 11 02 81 	mov    $0xffffffff81021128,%rdx
ffffffff8101a60a:	eb 44                	jmp    ffffffff8101a650 <_ZN2Ec14sys_assign_pciEv+0x1b6>
        sys_finish<Sys_regs::BAD_DEV>();
    }

    dmar->assign (rid, static_cast<Pd *>(obj));
ffffffff8101a60c:	48 89 da             	mov    %rbx,%rdx
ffffffff8101a60f:	e8 f0 8a fe ff       	callq  ffffffff81003104 <_ZN4Dmar6assignEmP2Pd>

    sys_finish<Sys_regs::SUCCESS>();
ffffffff8101a614:	e8 3f ca ff ff       	callq  ffffffff81017058 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb0EEEvv>
        sys_finish<Sys_regs::QUO_OOM>();
    }

    Paddr phys; unsigned rid;
    if (EXPECT_FALSE (!pd->Space_mem::lookup (r->dev(), phys) || (rid = Pci::phys_to_rid (phys)) == ~0U)) {
        trace (TRACE_ERROR, "%s: Non-DEV CAP (%#lx)", __func__, r->dev());
ffffffff8101a619:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff8101a61e:	8b 35 e0 49 fe 3e    	mov    0x3efe49e0(%rip),%esi        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8101a624:	48 8b 8d f0 00 00 00 	mov    0xf0(%rbp),%rcx
ffffffff8101a62b:	48 c7 c2 28 11 02 81 	mov    $0xffffffff81021128,%rdx
ffffffff8101a632:	48 c7 c7 47 10 02 81 	mov    $0xffffffff81021047,%rdi
ffffffff8101a639:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8101a63f:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff8101a645:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
ffffffff8101a64c:	48 0f 45 f0          	cmovne %rax,%rsi
ffffffff8101a650:	31 c0                	xor    %eax,%eax
ffffffff8101a652:	e8 35 7a fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_DEV>();
ffffffff8101a657:	e8 ba fd ff ff       	callq  ffffffff8101a416 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE8ELb0EEEvv>

ffffffff8101a65c <_ZN2Ec14sys_assign_gsiEv>:

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_assign_gsi()
{
ffffffff8101a65c:	55                   	push   %rbp
ffffffff8101a65d:	53                   	push   %rbx
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
ffffffff8101a65e:	be 02 00 00 00       	mov    $0x2,%esi

    sys_finish<Sys_regs::SUCCESS>();
}

void Ec::sys_assign_gsi()
{
ffffffff8101a663:	48 83 ec 18          	sub    $0x18,%rsp
}

template <void(*C)()>
void Ec::check(mword r, bool call)
{
    if (Pd::current->quota.hit_limit(r)) {
ffffffff8101a667:	48 8b 05 a2 49 fe 3e 	mov    0x3efe49a2(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8101a66e:	48 8d b8 08 03 00 00 	lea    0x308(%rax),%rdi
ffffffff8101a675:	e8 c8 c9 ff ff       	callq  ffffffff81017042 <_ZN5Quota9hit_limitEm>
ffffffff8101a67a:	84 c0                	test   %al,%al
ffffffff8101a67c:	48 8b 1d 85 49 fe 3e 	mov    0x3efe4985(%rip),%rbx        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8101a683:	74 2a                	je     ffffffff8101a6af <_ZN2Ec14sys_assign_gsiEv+0x53>
        trace(TRACE_OOM, "%s:%u - not enough resources %lu/%lu (%lu)", __func__, __LINE__, Pd::current->quota.usage(), Pd::current->quota.limit(), r);

        if (Ec::current->pt_oom && call)
ffffffff8101a685:	48 8b b3 38 03 00 00 	mov    0x338(%rbx),%rsi
ffffffff8101a68c:	48 85 f6             	test   %rsi,%rsi
ffffffff8101a68f:	74 19                	je     ffffffff8101a6aa <_ZN2Ec14sys_assign_gsiEv+0x4e>
            Ec::current->oom_call_cpu (Ec::current->pt_oom, Ec::current->pt_oom->id, C, C);
ffffffff8101a691:	48 8b 96 a8 00 00 00 	mov    0xa8(%rsi),%rdx
ffffffff8101a698:	49 c7 c0 5c a6 01 81 	mov    $0xffffffff8101a65c,%r8
ffffffff8101a69f:	48 89 df             	mov    %rbx,%rdi
ffffffff8101a6a2:	4c 89 c1             	mov    %r8,%rcx
ffffffff8101a6a5:	e8 f0 54 ff ff       	callq  ffffffff8100fb9a <_ZN2Ec12oom_call_cpuEP2PtmPFvvES3_>

        sys_finish<Sys_regs::QUO_OOM>();
ffffffff8101a6aa:	e8 1d dd ff ff       	callq  ffffffff810183cc <_ZN2Ec10sys_finishILN8Sys_regs6StatusE9ELb0EEEvv>
ffffffff8101a6af:	48 8b 8b 10 01 00 00 	mov    0x110(%rbx),%rcx
{
    check<sys_assign_gsi>(2);

    Sys_assign_gsi *r = static_cast<Sys_assign_gsi *>(current->sys_regs());

    if (EXPECT_FALSE (!Hip::cpu_online (r->cpu()))) {
ffffffff8101a6b6:	89 c8                	mov    %ecx,%eax
ffffffff8101a6b8:	48 83 f8 3f          	cmp    $0x3f,%rax
ffffffff8101a6bc:	77 0a                	ja     ffffffff8101a6c8 <_ZN2Ec14sys_assign_gsiEv+0x6c>
ffffffff8101a6be:	f6 04 c5 38 70 16 81 	testb  $0x1,-0x7ee98fc8(,%rax,8)
ffffffff8101a6c5:	01 
ffffffff8101a6c6:	75 3c                	jne    ffffffff8101a704 <_ZN2Ec14sys_assign_gsiEv+0xa8>
        trace (TRACE_ERROR, "%s: Invalid CPU (%#x)", __func__, r->cpu());
ffffffff8101a6c8:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff8101a6cd:	8b 35 31 49 fe 3e    	mov    0x3efe4931(%rip),%esi        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8101a6d3:	48 c7 c2 18 11 02 81 	mov    $0xffffffff81021118,%rdx
ffffffff8101a6da:	48 c7 c7 e4 0f 02 81 	mov    $0xffffffff81020fe4,%rdi
ffffffff8101a6e1:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8101a6e7:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff8101a6ed:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
ffffffff8101a6f4:	48 0f 45 f0          	cmovne %rax,%rsi
ffffffff8101a6f8:	31 c0                	xor    %eax,%eax
ffffffff8101a6fa:	e8 8d 79 fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_CPU>();
ffffffff8101a6ff:	e8 b4 f0 ff ff       	callq  ffffffff810197b8 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE7ELb0EEEvv>

class Sys_assign_gsi : public Sys_regs
{
    public:
        ALWAYS_INLINE
        inline unsigned long sm() const { return ARG_1 >> 8; }
ffffffff8101a704:	48 8b 8b e8 00 00 00 	mov    0xe8(%rbx),%rcx
ffffffff8101a70b:	48 c1 e9 08          	shr    $0x8,%rcx
ffffffff8101a70f:	48 89 c8             	mov    %rcx,%rax
ffffffff8101a712:	25 ff ff ff 03       	and    $0x3ffffff,%eax
ffffffff8101a717:	48 8b 2c c5 00 00 00 	mov    -0x20000000(,%rax,8),%rbp
ffffffff8101a71e:	e0 
ffffffff8101a71f:	48 83 e5 e0          	and    $0xffffffffffffffe0,%rbp
ffffffff8101a723:	74 09                	je     ffffffff8101a72e <_ZN2Ec14sys_assign_gsiEv+0xd2>
    }

    Kobject *obj = Space_obj::lookup (r->sm()).obj();
    if (EXPECT_FALSE (obj->type() != Kobject::SM)) {
ffffffff8101a725:	80 bd 88 00 00 00 04 	cmpb   $0x4,0x88(%rbp)
ffffffff8101a72c:	74 2f                	je     ffffffff8101a75d <_ZN2Ec14sys_assign_gsiEv+0x101>
        trace (TRACE_ERROR, "%s: Non-SM CAP (%#lx)", __func__, r->sm());
ffffffff8101a72e:	8b 15 d0 48 fe 3e    	mov    0x3efe48d0(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8101a734:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff8101a739:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff8101a73d:	48 c7 c7 c3 0d 02 81 	mov    $0xffffffff81020dc3,%rdi
ffffffff8101a744:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8101a74a:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff8101a750:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff8101a754:	48 c7 c2 18 11 02 81 	mov    $0xffffffff81021118,%rdx
ffffffff8101a75b:	eb 37                	jmp    ffffffff8101a794 <_ZN2Ec14sys_assign_gsiEv+0x138>
        sys_finish<Sys_regs::BAD_CAP>();
    }

    Sm *sm = static_cast<Sm *>(obj);

    if (EXPECT_FALSE (sm->space != static_cast<Space_obj *>(&Pd::kern))) {
ffffffff8101a75d:	48 81 7d 50 98 3f 16 	cmpq   $0xffffffff81163f98,0x50(%rbp)
ffffffff8101a764:	81 
ffffffff8101a765:	74 39                	je     ffffffff8101a7a0 <_ZN2Ec14sys_assign_gsiEv+0x144>
        trace (TRACE_ERROR, "%s: Non-GSI SM (%#lx)", __func__, r->sm());
ffffffff8101a767:	8b 15 97 48 fe 3e    	mov    0x3efe4897(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8101a76d:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff8101a772:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff8101a776:	48 c7 c7 84 10 02 81 	mov    $0xffffffff81021084,%rdi
ffffffff8101a77d:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8101a783:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff8101a789:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff8101a78d:	48 c7 c2 18 11 02 81 	mov    $0xffffffff81021118,%rdx
ffffffff8101a794:	31 c0                	xor    %eax,%eax
ffffffff8101a796:	e8 f1 78 fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_CAP>();
ffffffff8101a79b:	e8 94 d8 ff ff       	callq  ffffffff81018034 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE4ELb0EEEvv>
ffffffff8101a7a0:	48 8b 8b 20 01 00 00 	mov    0x120(%rbx),%rcx
    }

    if (r->si() != ~0UL) {
ffffffff8101a7a7:	48 83 f9 ff          	cmp    $0xffffffffffffffff,%rcx
ffffffff8101a7ab:	0f 84 ae 00 00 00    	je     ffffffff8101a85f <_ZN2Ec14sys_assign_gsiEv+0x203>
ffffffff8101a7b1:	48 89 c8             	mov    %rcx,%rax
ffffffff8101a7b4:	25 ff ff ff 03       	and    $0x3ffffff,%eax
ffffffff8101a7b9:	48 8b 34 c5 00 00 00 	mov    -0x20000000(,%rax,8),%rsi
ffffffff8101a7c0:	e0 
ffffffff8101a7c1:	48 83 e6 e0          	and    $0xffffffffffffffe0,%rsi
ffffffff8101a7c5:	74 09                	je     ffffffff8101a7d0 <_ZN2Ec14sys_assign_gsiEv+0x174>
        Kobject *obj_si = Space_obj::lookup (r->si()).obj();
        if (EXPECT_FALSE (obj_si->type() != Kobject::SM)) {
ffffffff8101a7c7:	80 be 88 00 00 00 04 	cmpb   $0x4,0x88(%rsi)
ffffffff8101a7ce:	74 2f                	je     ffffffff8101a7ff <_ZN2Ec14sys_assign_gsiEv+0x1a3>
            trace (TRACE_ERROR, "%s: Non-SI CAP (%#lx)", __func__, r->si());
ffffffff8101a7d0:	8b 15 2e 48 fe 3e    	mov    0x3efe482e(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8101a7d6:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff8101a7db:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff8101a7df:	48 c7 c7 a1 10 02 81 	mov    $0xffffffff810210a1,%rdi
ffffffff8101a7e6:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8101a7ec:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff8101a7f2:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff8101a7f6:	48 c7 c2 18 11 02 81 	mov    $0xffffffff81021118,%rdx
ffffffff8101a7fd:	eb 95                	jmp    ffffffff8101a794 <_ZN2Ec14sys_assign_gsiEv+0x138>
            sys_finish<Sys_regs::BAD_CAP>();
        }

        Sm *si = static_cast<Sm *>(obj_si);

        if (si == sm) {
ffffffff8101a7ff:	48 39 ee             	cmp    %rbp,%rsi
ffffffff8101a802:	75 13                	jne    ffffffff8101a817 <_ZN2Ec14sys_assign_gsiEv+0x1bb>
            sm->chain(nullptr);
ffffffff8101a804:	48 8d be a0 00 00 00 	lea    0xa0(%rsi),%rdi
ffffffff8101a80b:	31 f6                	xor    %esi,%esi
ffffffff8101a80d:	e8 1e ae ff ff       	callq  ffffffff81015630 <_ZN2Si5chainEP2Sm>
ffffffff8101a812:	e9 3a 01 00 00       	jmpq   ffffffff8101a951 <_ZN2Ec14sys_assign_gsiEv+0x2f5>
            sys_finish<Sys_regs::SUCCESS>();
        }

        if (EXPECT_FALSE (si->space == static_cast<Space_obj *>(&Pd::kern))) {
ffffffff8101a817:	48 81 7e 50 98 3f 16 	cmpq   $0xffffffff81163f98,0x50(%rsi)
ffffffff8101a81e:	81 
ffffffff8101a81f:	75 32                	jne    ffffffff8101a853 <_ZN2Ec14sys_assign_gsiEv+0x1f7>
            trace (TRACE_ERROR, "%s: Invalid-SM CAP (%#lx)", __func__, r->si());
ffffffff8101a821:	8b 15 dd 47 fe 3e    	mov    0x3efe47dd(%rip),%edx        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8101a827:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff8101a82c:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
ffffffff8101a830:	48 c7 c7 be 10 02 81 	mov    $0xffffffff810210be,%rdi
ffffffff8101a837:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8101a83d:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff8101a843:	48 0f 44 f2          	cmove  %rdx,%rsi
ffffffff8101a847:	48 c7 c2 18 11 02 81 	mov    $0xffffffff81021118,%rdx
ffffffff8101a84e:	e9 41 ff ff ff       	jmpq   ffffffff8101a794 <_ZN2Ec14sys_assign_gsiEv+0x138>
            sys_finish<Sys_regs::BAD_CAP>();
        }

        sm->chain(si);
ffffffff8101a853:	48 8d bd a0 00 00 00 	lea    0xa0(%rbp),%rdi
ffffffff8101a85a:	e8 d1 ad ff ff       	callq  ffffffff81015630 <_ZN2Si5chainEP2Sm>
    }

    Paddr phys; unsigned rid = 0, gsi = static_cast<unsigned>(sm->node_base - NUM_CPU);
ffffffff8101a85f:	48 8b 6d 60          	mov    0x60(%rbp),%rbp
ffffffff8101a863:	31 d2                	xor    %edx,%edx
ffffffff8101a865:	8d 45 c0             	lea    -0x40(%rbp),%eax
ffffffff8101a868:	48 89 c5             	mov    %rax,%rbp
    if (EXPECT_FALSE (!Gsi::gsi_table[gsi].ioapic && (!Pd::current->Space_mem::lookup (r->dev(), phys) || ((rid = Pci::phys_to_rid (phys)) == ~0U && (rid = Hpet::phys_to_rid (phys)) == ~0U)))) {
ffffffff8101a86b:	48 6b c0 18          	imul   $0x18,%rax,%rax
ffffffff8101a86f:	48 83 b8 48 21 16 81 	cmpq   $0x0,-0x7ee9deb8(%rax)
ffffffff8101a876:	00 
ffffffff8101a877:	0f 85 b2 00 00 00    	jne    ffffffff8101a92f <_ZN2Ec14sys_assign_gsiEv+0x2d3>
ffffffff8101a87d:	48 8b 05 8c 47 fe 3e 	mov    0x3efe478c(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8101a884:	48 8b b3 f0 00 00 00 	mov    0xf0(%rbx),%rsi
ffffffff8101a88b:	48 8d 4c 24 08       	lea    0x8(%rsp),%rcx
ffffffff8101a890:	48 89 e2             	mov    %rsp,%rdx
ffffffff8101a893:	48 8d b8 a0 02 00 00 	lea    0x2a0(%rax),%rdi
ffffffff8101a89a:	e8 35 83 ff ff       	callq  ffffffff81012bd4 <_ZN3PteI3HptmLj4ELj9ELb0EE6lookupEmRmS2_>
ffffffff8101a89f:	48 85 c0             	test   %rax,%rax
ffffffff8101a8a2:	74 48                	je     ffffffff8101a8ec <_ZN2Ec14sys_assign_gsiEv+0x290>
ffffffff8101a8a4:	48 8b 0c 24          	mov    (%rsp),%rcx
        static void init (unsigned = 0, unsigned = 0);

        ALWAYS_INLINE
        static inline unsigned phys_to_rid (Paddr p)
        {
            return p - cfg_base < cfg_size ? static_cast<unsigned>((bus_base << 8) + (p - cfg_base) / PAGE_SIZE) : ~0U;
ffffffff8101a8a8:	48 89 ca             	mov    %rcx,%rdx
ffffffff8101a8ab:	48 2b 15 4e 90 14 00 	sub    0x14904e(%rip),%rdx        # ffffffff81163900 <_ZN3Pci8cfg_baseE>
ffffffff8101a8b2:	48 3b 15 3f 90 14 00 	cmp    0x14903f(%rip),%rdx        # ffffffff811638f8 <_ZN3Pci8cfg_sizeE>
ffffffff8101a8b9:	73 14                	jae    ffffffff8101a8cf <_ZN2Ec14sys_assign_gsiEv+0x273>
ffffffff8101a8bb:	8b 05 47 90 14 00    	mov    0x149047(%rip),%eax        # ffffffff81163908 <_ZN3Pci8bus_baseE>
ffffffff8101a8c1:	48 c1 ea 0c          	shr    $0xc,%rdx
ffffffff8101a8c5:	c1 e0 08             	shl    $0x8,%eax
ffffffff8101a8c8:	01 c2                	add    %eax,%edx
ffffffff8101a8ca:	83 fa ff             	cmp    $0xffffffff,%edx
ffffffff8101a8cd:	75 60                	jne    ffffffff8101a92f <_ZN2Ec14sys_assign_gsiEv+0x2d3>
        }

        ALWAYS_INLINE
        static inline unsigned phys_to_rid (Paddr p)
        {
            for (Hpet *hpet = list; hpet; hpet = hpet->next)
ffffffff8101a8cf:	48 8b 05 7a 84 14 00 	mov    0x14847a(%rip),%rax        # ffffffff81162d50 <_ZN4Hpet4listE>
ffffffff8101a8d6:	48 85 c0             	test   %rax,%rax
ffffffff8101a8d9:	74 11                	je     ffffffff8101a8ec <_ZN2Ec14sys_assign_gsiEv+0x290>
                if (hpet->phys == p)
ffffffff8101a8db:	48 39 48 08          	cmp    %rcx,0x8(%rax)
ffffffff8101a8df:	75 06                	jne    ffffffff8101a8e7 <_ZN2Ec14sys_assign_gsiEv+0x28b>
                    return hpet->rid;
ffffffff8101a8e1:	0f b7 50 14          	movzwl 0x14(%rax),%edx
ffffffff8101a8e5:	eb 48                	jmp    ffffffff8101a92f <_ZN2Ec14sys_assign_gsiEv+0x2d3>
        }

        ALWAYS_INLINE
        static inline unsigned phys_to_rid (Paddr p)
        {
            for (Hpet *hpet = list; hpet; hpet = hpet->next)
ffffffff8101a8e7:	48 8b 00             	mov    (%rax),%rax
ffffffff8101a8ea:	eb ea                	jmp    ffffffff8101a8d6 <_ZN2Ec14sys_assign_gsiEv+0x27a>
        trace (TRACE_ERROR, "%s: Non-DEV CAP (%#lx)", __func__, r->dev());
ffffffff8101a8ec:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
ffffffff8101a8f1:	8b 35 0d 47 fe 3e    	mov    0x3efe470d(%rip),%esi        # ffffffffbffff004 <_ZN3Cpu2idE>
ffffffff8101a8f7:	48 8b 8b f0 00 00 00 	mov    0xf0(%rbx),%rcx
ffffffff8101a8fe:	48 c7 c2 18 11 02 81 	mov    $0xffffffff81021118,%rdx
ffffffff8101a905:	48 c7 c7 47 10 02 81 	mov    $0xffffffff81021047,%rdi
ffffffff8101a90c:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8101a912:	48 3d 00 d0 ff bf    	cmp    $0xffffffffbfffd000,%rax
ffffffff8101a918:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
ffffffff8101a91f:	48 0f 45 f0          	cmovne %rax,%rsi
ffffffff8101a923:	31 c0                	xor    %eax,%eax
ffffffff8101a925:	e8 62 77 fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
        sys_finish<Sys_regs::BAD_DEV>();
ffffffff8101a92a:	e8 e7 fa ff ff       	callq  ffffffff8101a416 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE8ELb0EEEvv>
    }

    r->set_msi (Gsi::set (gsi, r->cpu(), rid));
ffffffff8101a92f:	8b b3 10 01 00 00    	mov    0x110(%rbx),%esi
ffffffff8101a935:	89 ef                	mov    %ebp,%edi
ffffffff8101a937:	e8 52 d1 fe ff       	callq  ffffffff81007a8e <_ZN3Gsi3setEjjj>
        inline mword si() const { return ARG_4; }

        ALWAYS_INLINE
        inline void set_msi (uint64 val)
        {
            ARG_2 = static_cast<mword>(val >> 32);
ffffffff8101a93c:	48 89 c2             	mov    %rax,%rdx
            ARG_3 = static_cast<mword>(val);
ffffffff8101a93f:	48 89 83 10 01 00 00 	mov    %rax,0x110(%rbx)
        inline mword si() const { return ARG_4; }

        ALWAYS_INLINE
        inline void set_msi (uint64 val)
        {
            ARG_2 = static_cast<mword>(val >> 32);
ffffffff8101a946:	48 c1 ea 20          	shr    $0x20,%rdx
ffffffff8101a94a:	48 89 93 f0 00 00 00 	mov    %rdx,0xf0(%rbx)

    sys_finish<Sys_regs::SUCCESS>();
ffffffff8101a951:	e8 02 c7 ff ff       	callq  ffffffff81017058 <_ZN2Ec10sys_finishILN8Sys_regs6StatusE0ELb0EEEvv>

ffffffff8101a956 <_ZN7Timeout7enqueueEy>:
{
    time = t;

    Timeout *p = nullptr;

    for (Timeout *n = list; n; p = n, n = n->next)
ffffffff8101a956:	48 8b 0d db 53 fe 3e 	mov    0x3efe53db(%rip),%rcx        # ffffffffbffffd38 <_ZN7Timeout4listE>

Timeout *Timeout::list;

void Timeout::enqueue (uint64 t)
{
    time = t;
ffffffff8101a95d:	48 89 77 18          	mov    %rsi,0x18(%rdi)

    Timeout *p = nullptr;
ffffffff8101a961:	31 c0                	xor    %eax,%eax

    for (Timeout *n = list; n; p = n, n = n->next)
ffffffff8101a963:	48 89 ca             	mov    %rcx,%rdx
ffffffff8101a966:	48 85 d2             	test   %rdx,%rdx
ffffffff8101a969:	74 06                	je     ffffffff8101a971 <_ZN7Timeout7enqueueEy+0x1b>
        if (n->time >= time)
ffffffff8101a96b:	48 39 72 18          	cmp    %rsi,0x18(%rdx)
ffffffff8101a96f:	72 0b                	jb     ffffffff8101a97c <_ZN7Timeout7enqueueEy+0x26>
            break;

    prev = p;

    if (!p) {
ffffffff8101a971:	48 85 c0             	test   %rax,%rax

    for (Timeout *n = list; n; p = n, n = n->next)
        if (n->time >= time)
            break;

    prev = p;
ffffffff8101a974:	48 89 47 08          	mov    %rax,0x8(%rdi)

    if (!p) {
ffffffff8101a978:	75 6b                	jne    ffffffff8101a9e5 <_ZN7Timeout7enqueueEy+0x8f>
ffffffff8101a97a:	eb 09                	jmp    ffffffff8101a985 <_ZN7Timeout7enqueueEy+0x2f>
{
    time = t;

    Timeout *p = nullptr;

    for (Timeout *n = list; n; p = n, n = n->next)
ffffffff8101a97c:	48 89 d0             	mov    %rdx,%rax
ffffffff8101a97f:	48 8b 52 10          	mov    0x10(%rdx),%rdx
ffffffff8101a983:	eb e1                	jmp    ffffffff8101a966 <_ZN7Timeout7enqueueEy+0x10>
            break;

    prev = p;

    if (!p) {
        next = list;
ffffffff8101a985:	48 89 4f 10          	mov    %rcx,0x10(%rdi)
        }

        ALWAYS_INLINE
        static inline void set_timer (uint64 tsc)
        {
            if (freq_bus) {
ffffffff8101a989:	8b 0d e1 8e 14 00    	mov    0x148ee1(%rip),%ecx        # ffffffff81163870 <_ZN5Lapic8freq_busE>
        list = this;
ffffffff8101a98f:	48 89 3d a2 53 fe 3e 	mov    %rdi,0x3efe53a2(%rip)        # ffffffffbffffd38 <_ZN7Timeout4listE>
ffffffff8101a996:	85 c9                	test   %ecx,%ecx
ffffffff8101a998:	74 38                	je     ffffffff8101a9d2 <_ZN7Timeout7enqueueEy+0x7c>

ALWAYS_INLINE
static inline uint64 rdtsc()
{
    mword h, l;
    asm volatile ("rdtsc" : "=a" (l), "=d" (h));
ffffffff8101a99a:	0f 31                	rdtsc  
    return static_cast<uint64>(h) << 32 | l;
ffffffff8101a99c:	48 c1 e2 20          	shl    $0x20,%rdx
                uint64 now = rdtsc();
                uint32 icr;
                write (LAPIC_TMR_ICR, tsc > now && (icr = static_cast<uint32>(tsc - now) / (freq_tsc / freq_bus)) > 0 ? icr : 1);
ffffffff8101a9a0:	41 b8 01 00 00 00    	mov    $0x1,%r8d
ffffffff8101a9a6:	48 09 d0             	or     %rdx,%rax
ffffffff8101a9a9:	48 39 c6             	cmp    %rax,%rsi
ffffffff8101a9ac:	76 1a                	jbe    ffffffff8101a9c8 <_ZN7Timeout7enqueueEy+0x72>
ffffffff8101a9ae:	29 c6                	sub    %eax,%esi
ffffffff8101a9b0:	8b 05 be 8e 14 00    	mov    0x148ebe(%rip),%eax        # ffffffff81163874 <_ZN5Lapic8freq_tscE>
ffffffff8101a9b6:	31 d2                	xor    %edx,%edx
ffffffff8101a9b8:	f7 f1                	div    %ecx
ffffffff8101a9ba:	31 d2                	xor    %edx,%edx
ffffffff8101a9bc:	89 c1                	mov    %eax,%ecx
ffffffff8101a9be:	89 f0                	mov    %esi,%eax
ffffffff8101a9c0:	f7 f1                	div    %ecx
ffffffff8101a9c2:	85 c0                	test   %eax,%eax
ffffffff8101a9c4:	44 0f 45 c0          	cmovne %eax,%r8d
        }

        ALWAYS_INLINE
        static inline void write (Register reg, uint32 val)
        {
            *reinterpret_cast<uint32 volatile *>(CPU_LOCAL_APIC + (reg << 4)) = val;
ffffffff8101a9c8:	44 89 04 25 80 e3 ff 	mov    %r8d,0xffffffffbfffe380
ffffffff8101a9cf:	bf 
ffffffff8101a9d0:	eb 1f                	jmp    ffffffff8101a9f1 <_ZN7Timeout7enqueueEy+0x9b>
ffffffff8101a9d2:	48 89 f2             	mov    %rsi,%rdx
ffffffff8101a9d5:	b9 e0 06 00 00       	mov    $0x6e0,%ecx
ffffffff8101a9da:	48 89 f0             	mov    %rsi,%rax
ffffffff8101a9dd:	48 c1 ea 20          	shr    $0x20,%rdx
ffffffff8101a9e1:	0f 30                	wrmsr  
ffffffff8101a9e3:	eb 0c                	jmp    ffffffff8101a9f1 <_ZN7Timeout7enqueueEy+0x9b>
        Lapic::set_timer (time);
    } else {
        next = p->next;
ffffffff8101a9e5:	48 8b 50 10          	mov    0x10(%rax),%rdx
ffffffff8101a9e9:	48 89 57 10          	mov    %rdx,0x10(%rdi)
        p->next = this;
ffffffff8101a9ed:	48 89 78 10          	mov    %rdi,0x10(%rax)
    }

    if (next)
ffffffff8101a9f1:	48 8b 47 10          	mov    0x10(%rdi),%rax
ffffffff8101a9f5:	48 85 c0             	test   %rax,%rax
ffffffff8101a9f8:	74 04                	je     ffffffff8101a9fe <_ZN7Timeout7enqueueEy+0xa8>
        next->prev = this;
ffffffff8101a9fa:	48 89 78 08          	mov    %rdi,0x8(%rax)
ffffffff8101a9fe:	c3                   	retq   
ffffffff8101a9ff:	90                   	nop

ffffffff8101aa00 <_ZN7Timeout7dequeueEv>:
ffffffff8101aa00:	48 8b 57 08          	mov    0x8(%rdi),%rdx
ffffffff8101aa04:	48 85 d2             	test   %rdx,%rdx
ffffffff8101aa07:	75 0d                	jne    ffffffff8101aa16 <_ZN7Timeout7dequeueEv+0x16>
ffffffff8101aa09:	48 39 3d 28 53 fe 3e 	cmp    %rdi,0x3efe5328(%rip)        # ffffffffbffffd38 <_ZN7Timeout4listE>
ffffffff8101aa10:	0f 85 83 00 00 00    	jne    ffffffff8101aa99 <_ZN7Timeout7dequeueEv+0x99>

uint64 Timeout::dequeue()
{
    if (active()) {

        if (next)
ffffffff8101aa16:	48 8b 47 10          	mov    0x10(%rdi),%rax
ffffffff8101aa1a:	48 85 c0             	test   %rax,%rax
ffffffff8101aa1d:	74 04                	je     ffffffff8101aa23 <_ZN7Timeout7dequeueEv+0x23>
            next->prev = prev;
ffffffff8101aa1f:	48 89 50 08          	mov    %rdx,0x8(%rax)

        if (prev)
ffffffff8101aa23:	48 8b 57 08          	mov    0x8(%rdi),%rdx
ffffffff8101aa27:	48 8b 47 10          	mov    0x10(%rdi),%rax
ffffffff8101aa2b:	48 85 d2             	test   %rdx,%rdx
ffffffff8101aa2e:	74 06                	je     ffffffff8101aa36 <_ZN7Timeout7dequeueEv+0x36>
            prev->next = next;
ffffffff8101aa30:	48 89 42 10          	mov    %rax,0x10(%rdx)
ffffffff8101aa34:	eb 63                	jmp    ffffffff8101aa99 <_ZN7Timeout7dequeueEv+0x99>

        else if ((list = next))
ffffffff8101aa36:	48 85 c0             	test   %rax,%rax
ffffffff8101aa39:	48 89 05 f8 52 fe 3e 	mov    %rax,0x3efe52f8(%rip)        # ffffffffbffffd38 <_ZN7Timeout4listE>
ffffffff8101aa40:	74 57                	je     ffffffff8101aa99 <_ZN7Timeout7dequeueEv+0x99>
        }

        ALWAYS_INLINE
        static inline void set_timer (uint64 tsc)
        {
            if (freq_bus) {
ffffffff8101aa42:	8b 0d 28 8e 14 00    	mov    0x148e28(%rip),%ecx        # ffffffff81163870 <_ZN5Lapic8freq_busE>
            Lapic::set_timer (list->time);
ffffffff8101aa48:	48 8b 70 18          	mov    0x18(%rax),%rsi
ffffffff8101aa4c:	85 c9                	test   %ecx,%ecx
ffffffff8101aa4e:	74 38                	je     ffffffff8101aa88 <_ZN7Timeout7dequeueEv+0x88>

ALWAYS_INLINE
static inline uint64 rdtsc()
{
    mword h, l;
    asm volatile ("rdtsc" : "=a" (l), "=d" (h));
ffffffff8101aa50:	0f 31                	rdtsc  
    return static_cast<uint64>(h) << 32 | l;
ffffffff8101aa52:	48 c1 e2 20          	shl    $0x20,%rdx
                uint64 now = rdtsc();
                uint32 icr;
                write (LAPIC_TMR_ICR, tsc > now && (icr = static_cast<uint32>(tsc - now) / (freq_tsc / freq_bus)) > 0 ? icr : 1);
ffffffff8101aa56:	41 b8 01 00 00 00    	mov    $0x1,%r8d
ffffffff8101aa5c:	48 09 d0             	or     %rdx,%rax
ffffffff8101aa5f:	48 39 c6             	cmp    %rax,%rsi
ffffffff8101aa62:	76 1a                	jbe    ffffffff8101aa7e <_ZN7Timeout7dequeueEv+0x7e>
ffffffff8101aa64:	29 c6                	sub    %eax,%esi
ffffffff8101aa66:	8b 05 08 8e 14 00    	mov    0x148e08(%rip),%eax        # ffffffff81163874 <_ZN5Lapic8freq_tscE>
ffffffff8101aa6c:	31 d2                	xor    %edx,%edx
ffffffff8101aa6e:	f7 f1                	div    %ecx
ffffffff8101aa70:	31 d2                	xor    %edx,%edx
ffffffff8101aa72:	89 c1                	mov    %eax,%ecx
ffffffff8101aa74:	89 f0                	mov    %esi,%eax
ffffffff8101aa76:	f7 f1                	div    %ecx
ffffffff8101aa78:	85 c0                	test   %eax,%eax
ffffffff8101aa7a:	44 0f 45 c0          	cmovne %eax,%r8d
        }

        ALWAYS_INLINE
        static inline void write (Register reg, uint32 val)
        {
            *reinterpret_cast<uint32 volatile *>(CPU_LOCAL_APIC + (reg << 4)) = val;
ffffffff8101aa7e:	44 89 04 25 80 e3 ff 	mov    %r8d,0xffffffffbfffe380
ffffffff8101aa85:	bf 
ffffffff8101aa86:	eb 11                	jmp    ffffffff8101aa99 <_ZN7Timeout7dequeueEv+0x99>
ffffffff8101aa88:	48 89 f2             	mov    %rsi,%rdx
ffffffff8101aa8b:	b9 e0 06 00 00       	mov    $0x6e0,%ecx
ffffffff8101aa90:	48 89 f0             	mov    %rsi,%rax
ffffffff8101aa93:	48 c1 ea 20          	shr    $0x20,%rdx
ffffffff8101aa97:	0f 30                	wrmsr  
    }

    prev = next = nullptr;
ffffffff8101aa99:	48 c7 47 10 00 00 00 	movq   $0x0,0x10(%rdi)
ffffffff8101aaa0:	00 
ffffffff8101aaa1:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
ffffffff8101aaa8:	00 

    return time;
ffffffff8101aaa9:	48 8b 47 18          	mov    0x18(%rdi),%rax
}
ffffffff8101aaad:	c3                   	retq   

ffffffff8101aaae <_ZN7Timeout5checkEv>:

void Timeout::check()
{
ffffffff8101aaae:	55                   	push   %rbp
ffffffff8101aaaf:	53                   	push   %rbx
ffffffff8101aab0:	52                   	push   %rdx
    Timeout *prev_list = list;
ffffffff8101aab1:	48 8b 2d 80 52 fe 3e 	mov    0x3efe5280(%rip),%rbp        # ffffffffbffffd38 <_ZN7Timeout4listE>

    while (list && list->time <= rdtsc()) {
ffffffff8101aab8:	48 8b 1d 79 52 fe 3e 	mov    0x3efe5279(%rip),%rbx        # ffffffffbffffd38 <_ZN7Timeout4listE>
ffffffff8101aabf:	48 85 db             	test   %rbx,%rbx
ffffffff8101aac2:	74 7a                	je     ffffffff8101ab3e <_ZN7Timeout5checkEv+0x90>

ALWAYS_INLINE
static inline uint64 rdtsc()
{
    mword h, l;
    asm volatile ("rdtsc" : "=a" (l), "=d" (h));
ffffffff8101aac4:	0f 31                	rdtsc  
    return static_cast<uint64>(h) << 32 | l;
ffffffff8101aac6:	48 c1 e2 20          	shl    $0x20,%rdx
ffffffff8101aaca:	48 09 d0             	or     %rdx,%rax
ffffffff8101aacd:	48 39 43 18          	cmp    %rax,0x18(%rbx)
ffffffff8101aad1:	77 12                	ja     ffffffff8101aae5 <_ZN7Timeout5checkEv+0x37>
        Timeout *t = list;
        t->dequeue();
ffffffff8101aad3:	48 89 df             	mov    %rbx,%rdi
ffffffff8101aad6:	e8 25 ff ff ff       	callq  ffffffff8101aa00 <_ZN7Timeout7dequeueEv>
        t->trigger();
ffffffff8101aadb:	48 8b 03             	mov    (%rbx),%rax
ffffffff8101aade:	48 89 df             	mov    %rbx,%rdi
ffffffff8101aae1:	ff 10                	callq  *(%rax)
ffffffff8101aae3:	eb d3                	jmp    ffffffff8101aab8 <_ZN7Timeout5checkEv+0xa>
    }

    if (list && (list == prev_list)) {
ffffffff8101aae5:	48 39 eb             	cmp    %rbp,%rbx
ffffffff8101aae8:	75 54                	jne    ffffffff8101ab3e <_ZN7Timeout5checkEv+0x90>
        }

        ALWAYS_INLINE
        static inline void set_timer (uint64 tsc)
        {
            if (freq_bus) {
ffffffff8101aaea:	8b 0d 80 8d 14 00    	mov    0x148d80(%rip),%ecx        # ffffffff81163870 <_ZN5Lapic8freq_busE>
        /*
         * No timeout was dequeued, which can happen if the TSC stops in CPU
         * sleep states (non-invariant TSC). In that case, we program the
         * LAPIC again for the next timeout.
         */
         Lapic::set_timer(list->time);
ffffffff8101aaf0:	48 8b 75 18          	mov    0x18(%rbp),%rsi
ffffffff8101aaf4:	85 c9                	test   %ecx,%ecx
ffffffff8101aaf6:	74 35                	je     ffffffff8101ab2d <_ZN7Timeout5checkEv+0x7f>

ALWAYS_INLINE
static inline uint64 rdtsc()
{
    mword h, l;
    asm volatile ("rdtsc" : "=a" (l), "=d" (h));
ffffffff8101aaf8:	0f 31                	rdtsc  
    return static_cast<uint64>(h) << 32 | l;
ffffffff8101aafa:	48 c1 e2 20          	shl    $0x20,%rdx
                uint64 now = rdtsc();
                uint32 icr;
                write (LAPIC_TMR_ICR, tsc > now && (icr = static_cast<uint32>(tsc - now) / (freq_tsc / freq_bus)) > 0 ? icr : 1);
ffffffff8101aafe:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff8101ab03:	48 09 d0             	or     %rdx,%rax
ffffffff8101ab06:	48 39 c6             	cmp    %rax,%rsi
ffffffff8101ab09:	76 19                	jbe    ffffffff8101ab24 <_ZN7Timeout5checkEv+0x76>
ffffffff8101ab0b:	29 c6                	sub    %eax,%esi
ffffffff8101ab0d:	8b 05 61 8d 14 00    	mov    0x148d61(%rip),%eax        # ffffffff81163874 <_ZN5Lapic8freq_tscE>
ffffffff8101ab13:	31 d2                	xor    %edx,%edx
ffffffff8101ab15:	f7 f1                	div    %ecx
ffffffff8101ab17:	31 d2                	xor    %edx,%edx
ffffffff8101ab19:	89 c1                	mov    %eax,%ecx
ffffffff8101ab1b:	89 f0                	mov    %esi,%eax
ffffffff8101ab1d:	f7 f1                	div    %ecx
ffffffff8101ab1f:	85 c0                	test   %eax,%eax
ffffffff8101ab21:	0f 45 f8             	cmovne %eax,%edi
        }

        ALWAYS_INLINE
        static inline void write (Register reg, uint32 val)
        {
            *reinterpret_cast<uint32 volatile *>(CPU_LOCAL_APIC + (reg << 4)) = val;
ffffffff8101ab24:	89 3c 25 80 e3 ff bf 	mov    %edi,0xffffffffbfffe380
ffffffff8101ab2b:	eb 11                	jmp    ffffffff8101ab3e <_ZN7Timeout5checkEv+0x90>
ffffffff8101ab2d:	48 89 f2             	mov    %rsi,%rdx
ffffffff8101ab30:	b9 e0 06 00 00       	mov    $0x6e0,%ecx
ffffffff8101ab35:	48 89 f0             	mov    %rsi,%rax
ffffffff8101ab38:	48 c1 ea 20          	shr    $0x20,%rdx
ffffffff8101ab3c:	0f 30                	wrmsr  
    }
}
ffffffff8101ab3e:	58                   	pop    %rax
ffffffff8101ab3f:	5b                   	pop    %rbx
ffffffff8101ab40:	5d                   	pop    %rbp
ffffffff8101ab41:	c3                   	retq   

ffffffff8101ab42 <_ZN14Timeout_budget7triggerEv>:
INIT_PRIORITY (PRIO_LOCAL)
Timeout_budget Timeout_budget::budget;

void Timeout_budget::trigger()
{
    Cpu::hazard |= HZD_SCHED;
ffffffff8101ab42:	83 0d b7 44 fe 3e 01 	orl    $0x1,0x3efe44b7(%rip)        # ffffffffbffff000 <_ZN3Cpu6hazardE>
ffffffff8101ab49:	c3                   	retq   

ffffffff8101ab4a <_GLOBAL__sub_I.65534__ZN14Timeout_budget6budgetE>:

    public:
        static Timeout *list CPULOCAL;

        ALWAYS_INLINE
        inline Timeout() : prev (nullptr), next (nullptr), time (0) {}
ffffffff8101ab4a:	48 c7 05 f3 51 fe 3e 	movq   $0x0,0x3efe51f3(%rip)        # ffffffffbffffd48 <_ZN14Timeout_budget6budgetE+0x8>
ffffffff8101ab51:	00 00 00 00 
ffffffff8101ab55:	48 c7 05 f0 51 fe 3e 	movq   $0x0,0x3efe51f0(%rip)        # ffffffffbffffd50 <_ZN14Timeout_budget6budgetE+0x10>
ffffffff8101ab5c:	00 00 00 00 
ffffffff8101ab60:	48 c7 05 ed 51 fe 3e 	movq   $0x0,0x3efe51ed(%rip)        # ffffffffbffffd58 <_ZN14Timeout_budget6budgetE+0x18>
ffffffff8101ab67:	00 00 00 00 

#pragma once

#include "timeout.hpp"

class Timeout_budget : public Timeout
ffffffff8101ab6b:	48 c7 05 ca 51 fe 3e 	movq   $0xffffffff810213d0,0x3efe51ca(%rip)        # ffffffffbffffd40 <_ZN14Timeout_budget6budgetE>
ffffffff8101ab72:	d0 13 02 81 
ffffffff8101ab76:	c3                   	retq   
ffffffff8101ab77:	90                   	nop

ffffffff8101ab78 <_ZN17Timeout_hypercall7triggerEv>:

#include "sm.hpp"
#include "timeout_hypercall.hpp"

void Timeout_hypercall::trigger()
{
ffffffff8101ab78:	41 54                	push   %r12
ffffffff8101ab7a:	55                   	push   %rbp
ffffffff8101ab7b:	53                   	push   %rbx
    sm->timeout (ec);
ffffffff8101ab7c:	4c 8b 67 28          	mov    0x28(%rdi),%r12
ffffffff8101ab80:	48 8b 5f 20          	mov    0x20(%rdi),%rbx
        }

        ALWAYS_INLINE
        inline void timeout (Ec *ec)
        {
            {   Lock_guard <Spinlock> guard (lock);
ffffffff8101ab84:	49 8d bc 24 8a 00 00 	lea    0x8a(%r12),%rdi
ffffffff8101ab8b:	00 

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff8101ab8c:	9c                   	pushfq 
ffffffff8101ab8d:	5d                   	pop    %rbp
            return flags & 0x200;
ffffffff8101ab8e:	48 c1 ed 09          	shr    $0x9,%rbp

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8101ab92:	40 80 e5 01          	and    $0x1,%bpl
ffffffff8101ab96:	74 30                	je     ffffffff8101abc8 <_ZN17Timeout_hypercall7triggerEv+0x50>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff8101ab98:	80 3d 91 4b fe 3e 00 	cmpb   $0x0,0x3efe4b91(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8101ab9f:	75 1f                	jne    ffffffff8101abc0 <_ZN17Timeout_hypercall7triggerEv+0x48>
ffffffff8101aba1:	49 c7 c0 10 14 02 81 	mov    $0xffffffff81021410,%r8
ffffffff8101aba8:	b9 b7 00 00 00       	mov    $0xb7,%ecx
ffffffff8101abad:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8101abb4:	48 c7 c6 92 d3 01 81 	mov    $0xffffffff8101d392,%rsi
ffffffff8101abbb:	e9 c4 00 00 00       	jmpq   ffffffff8101ac84 <_ZN17Timeout_hypercall7triggerEv+0x10c>

            asm volatile ("cli" : : : "memory");
ffffffff8101abc0:	fa                   	cli    
            preemption = false;
ffffffff8101abc1:	c6 05 68 4b fe 3e 00 	movb   $0x0,0x3efe4b68(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff8101abc8:	e8 c1 62 fe ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff8101abcd:	48 85 db             	test   %rbx,%rbx
ffffffff8101abd0:	0f 84 f0 01 00 00    	je     ffffffff8101adc6 <_ZN17Timeout_hypercall7triggerEv+0x24e>
ffffffff8101abd6:	48 8b 83 b0 02 00 00 	mov    0x2b0(%rbx),%rax
ffffffff8101abdd:	48 85 c0             	test   %rax,%rax
ffffffff8101abe0:	0f 84 e0 01 00 00    	je     ffffffff8101adc6 <_ZN17Timeout_hypercall7triggerEv+0x24e>
ffffffff8101abe6:	48 8b 93 a8 02 00 00 	mov    0x2a8(%rbx),%rdx
ffffffff8101abed:	48 85 d2             	test   %rdx,%rdx
ffffffff8101abf0:	0f 84 d0 01 00 00    	je     ffffffff8101adc6 <_ZN17Timeout_hypercall7triggerEv+0x24e>
                return false;

            if (t == t->next)
ffffffff8101abf6:	48 39 c3             	cmp    %rax,%rbx
ffffffff8101abf9:	75 0e                	jne    ffffffff8101ac09 <_ZN17Timeout_hypercall7triggerEv+0x91>
                headptr = nullptr;
ffffffff8101abfb:	49 c7 84 24 90 00 00 	movq   $0x0,0x90(%r12)
ffffffff8101ac02:	00 00 00 00 00 
ffffffff8101ac07:	eb 35                	jmp    ffffffff8101ac3e <_ZN17Timeout_hypercall7triggerEv+0xc6>

            else {
                t->next->prev = t->prev;
ffffffff8101ac09:	48 89 90 a8 02 00 00 	mov    %rdx,0x2a8(%rax)
                t->prev->next = t->next;
ffffffff8101ac10:	48 8b 83 a8 02 00 00 	mov    0x2a8(%rbx),%rax
ffffffff8101ac17:	48 8b 93 b0 02 00 00 	mov    0x2b0(%rbx),%rdx
ffffffff8101ac1e:	48 89 90 b0 02 00 00 	mov    %rdx,0x2b0(%rax)
                if (t == headptr)
ffffffff8101ac25:	49 3b 9c 24 90 00 00 	cmp    0x90(%r12),%rbx
ffffffff8101ac2c:	00 
ffffffff8101ac2d:	75 0f                	jne    ffffffff8101ac3e <_ZN17Timeout_hypercall7triggerEv+0xc6>
                    headptr = t->next;
ffffffff8101ac2f:	48 8b 83 b0 02 00 00 	mov    0x2b0(%rbx),%rax
ffffffff8101ac36:	49 89 84 24 90 00 00 	mov    %rax,0x90(%r12)
ffffffff8101ac3d:	00 
            }

            t->next = t->prev = nullptr;
ffffffff8101ac3e:	48 c7 83 a8 02 00 00 	movq   $0x0,0x2a8(%rbx)
ffffffff8101ac45:	00 00 00 00 
ffffffff8101ac49:	48 c7 83 b0 02 00 00 	movq   $0x0,0x2b0(%rbx)
ffffffff8101ac50:	00 00 00 00 
ffffffff8101ac54:	41 fe 84 24 8a 00 00 	incb   0x8a(%r12)
ffffffff8101ac5b:	00 
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff8101ac5c:	40 84 ed             	test   %bpl,%bpl
ffffffff8101ac5f:	74 39                	je     ffffffff8101ac9a <_ZN17Timeout_hypercall7triggerEv+0x122>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8101ac61:	80 3d c8 4a fe 3e 00 	cmpb   $0x0,0x3efe4ac8(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8101ac68:	74 28                	je     ffffffff8101ac92 <_ZN17Timeout_hypercall7triggerEv+0x11a>
ffffffff8101ac6a:	49 c7 c0 e0 13 02 81 	mov    $0xffffffff810213e0,%r8
ffffffff8101ac71:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff8101ac76:	48 c7 c2 22 d3 01 81 	mov    $0xffffffff8101d322,%rdx
ffffffff8101ac7d:	48 c7 c6 91 d3 01 81 	mov    $0xffffffff8101d391,%rsi
ffffffff8101ac84:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8101ac8b:	31 c0                	xor    %eax,%eax
ffffffff8101ac8d:	e8 be 72 fe ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

            preemption = true;
ffffffff8101ac92:	c6 05 97 4a fe 3e 01 	movb   $0x1,0x3efe4a97(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8101ac99:	fb                   	sti    
    }

    ALWAYS_INLINE
    inline void release(void (*c)()) {
        if (c)
            cont = c;
ffffffff8101ac9a:	48 c7 83 a0 00 00 00 	movq   $0xffffffff81017fb0,0xa0(%rbx)
ffffffff8101aca1:	b0 7f 01 81 

        Lock_guard <Spinlock> guard(lock);
ffffffff8101aca5:	48 8d bb 8a 00 00 00 	lea    0x8a(%rbx),%rdi

        ALWAYS_INLINE
        static inline bool preempt_status()
        {
            mword flags = 0;
            asm volatile ("pushf; pop %0" : "=r" (flags));
ffffffff8101acac:	9c                   	pushfq 
ffffffff8101acad:	58                   	pop    %rax
            return flags & 0x200;
ffffffff8101acae:	48 c1 e8 09          	shr    $0x9,%rax

    public:
        ALWAYS_INLINE
        inline Lock_guard (T &l) : _lock (l), pre(Cpu::preempt_status())
        {
            if (pre)
ffffffff8101acb2:	41 88 c4             	mov    %al,%r12b
ffffffff8101acb5:	41 80 e4 01          	and    $0x1,%r12b
ffffffff8101acb9:	74 15                	je     ffffffff8101acd0 <_ZN17Timeout_hypercall7triggerEv+0x158>
        }

        ALWAYS_INLINE
        static inline void preempt_disable()
        {
            assert (preemption);
ffffffff8101acbb:	80 3d 6e 4a fe 3e 00 	cmpb   $0x0,0x3efe4a6e(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8101acc2:	0f 84 d9 fe ff ff    	je     ffffffff8101aba1 <_ZN17Timeout_hypercall7triggerEv+0x29>

            asm volatile ("cli" : : : "memory");
ffffffff8101acc8:	fa                   	cli    
            preemption = false;
ffffffff8101acc9:	c6 05 60 4a fe 3e 00 	movb   $0x0,0x3efe4a60(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
                Cpu::preempt_disable();

            _lock.lock();
ffffffff8101acd0:	e8 b9 61 fe ff       	callq  ffffffff81000e8e <_ZN8Spinlock4lockEv>
    public:
        ALWAYS_INLINE
        inline Queue() : headptr (nullptr) {}

        ALWAYS_INLINE
        inline T *head() const { return headptr; }
ffffffff8101acd5:	48 8b ab 90 00 00 00 	mov    0x90(%rbx),%rbp
        }

        ALWAYS_INLINE
        inline bool dequeue (T *t)
        {
            if (!t || !t->next || !t->prev)
ffffffff8101acdc:	48 85 ed             	test   %rbp,%rbp
ffffffff8101acdf:	0f 84 fb 00 00 00    	je     ffffffff8101ade0 <_ZN17Timeout_hypercall7triggerEv+0x268>
ffffffff8101ace5:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff8101acec:	48 85 c0             	test   %rax,%rax
ffffffff8101acef:	0f 84 eb 00 00 00    	je     ffffffff8101ade0 <_ZN17Timeout_hypercall7triggerEv+0x268>
ffffffff8101acf5:	48 8b 95 b8 00 00 00 	mov    0xb8(%rbp),%rdx
ffffffff8101acfc:	48 85 d2             	test   %rdx,%rdx
ffffffff8101acff:	0f 84 db 00 00 00    	je     ffffffff8101ade0 <_ZN17Timeout_hypercall7triggerEv+0x268>
                return false;

            if (t == t->next)
ffffffff8101ad05:	48 39 c5             	cmp    %rax,%rbp
ffffffff8101ad08:	75 0d                	jne    ffffffff8101ad17 <_ZN17Timeout_hypercall7triggerEv+0x19f>
                headptr = nullptr;
ffffffff8101ad0a:	48 c7 83 90 00 00 00 	movq   $0x0,0x90(%rbx)
ffffffff8101ad11:	00 00 00 00 
ffffffff8101ad15:	eb 33                	jmp    ffffffff8101ad4a <_ZN17Timeout_hypercall7triggerEv+0x1d2>

            else {
                t->next->prev = t->prev;
ffffffff8101ad17:	48 89 90 b8 00 00 00 	mov    %rdx,0xb8(%rax)
                t->prev->next = t->next;
ffffffff8101ad1e:	48 8b 85 b8 00 00 00 	mov    0xb8(%rbp),%rax
ffffffff8101ad25:	48 8b 95 c0 00 00 00 	mov    0xc0(%rbp),%rdx
ffffffff8101ad2c:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
                if (t == headptr)
ffffffff8101ad33:	48 3b ab 90 00 00 00 	cmp    0x90(%rbx),%rbp
ffffffff8101ad3a:	75 0e                	jne    ffffffff8101ad4a <_ZN17Timeout_hypercall7triggerEv+0x1d2>
                    headptr = t->next;
ffffffff8101ad3c:	48 8b 85 c0 00 00 00 	mov    0xc0(%rbp),%rax
ffffffff8101ad43:	48 89 83 90 00 00 00 	mov    %rax,0x90(%rbx)
            }

            t->next = t->prev = nullptr;
ffffffff8101ad4a:	48 c7 85 b8 00 00 00 	movq   $0x0,0xb8(%rbp)
ffffffff8101ad51:	00 00 00 00 
ffffffff8101ad55:	48 c7 85 c0 00 00 00 	movq   $0x0,0xc0(%rbp)
ffffffff8101ad5c:	00 00 00 00 
        ALWAYS_INLINE
        static inline T add (T &ptr, T v) { return __sync_add_and_fetch (&ptr, v); }

        template <typename T>
        ALWAYS_INLINE
        static inline T sub (T &ptr, T v) { return __sync_sub_and_fetch (&ptr, v); }
ffffffff8101ad60:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff8101ad63:	f0 0f c1 85 8c 00 00 	lock xadd %eax,0x8c(%rbp)
ffffffff8101ad6a:	00 

        for (Sc *s; dequeue(s = head());) {
            if (EXPECT_FALSE(s->del_ref()) && (this == s->ec)) {
ffffffff8101ad6b:	ff c8                	dec    %eax
ffffffff8101ad6d:	75 64                	jne    ffffffff8101add3 <_ZN17Timeout_hypercall7triggerEv+0x25b>
ffffffff8101ad6f:	48 3b 9d 90 00 00 00 	cmp    0x90(%rbp),%rbx
ffffffff8101ad76:	75 5b                	jne    ffffffff8101add3 <_ZN17Timeout_hypercall7triggerEv+0x25b>
ffffffff8101ad78:	83 c8 ff             	or     $0xffffffff,%eax
ffffffff8101ad7b:	f0 0f c1 83 8c 00 00 	lock xadd %eax,0x8c(%rbx)
ffffffff8101ad82:	00 
        inline Refptr (T *p) : ptr (p->add_ref() ? p : nullptr) {}

        ALWAYS_INLINE
        inline ~Refptr()
        {
            if (ptr && ptr->del_ref())
ffffffff8101ad83:	ff c8                	dec    %eax
ffffffff8101ad85:	75 32                	jne    ffffffff8101adb9 <_ZN17Timeout_hypercall7triggerEv+0x241>
                delete ptr;
ffffffff8101ad87:	48 8b bd 90 00 00 00 	mov    0x90(%rbp),%rdi
ffffffff8101ad8e:	48 85 ff             	test   %rdi,%rdi
ffffffff8101ad91:	74 26                	je     ffffffff8101adb9 <_ZN17Timeout_hypercall7triggerEv+0x241>
ffffffff8101ad93:	e8 a4 96 fe ff       	callq  ffffffff8100443c <_ZN2EcD1Ev>
ffffffff8101ad98:	48 8b b5 90 00 00 00 	mov    0x90(%rbp),%rsi
        return cache.alloc(quota);
    }

    ALWAYS_INLINE
    static inline void operator delete (void *ptr) {
        cache.free(ptr, static_cast<Ec *> (ptr)->pd->quota);
ffffffff8101ad9f:	48 c7 c7 a0 20 16 81 	mov    $0xffffffff811620a0,%rdi
ffffffff8101ada6:	48 8b 86 98 02 00 00 	mov    0x298(%rsi),%rax
ffffffff8101adad:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff8101adb4:	e8 b1 ac ff ff       	callq  ffffffff81015a6a <_ZN10Slab_cache4freeEPvR5Quota>

        Lock_guard <Spinlock> guard(lock);

        for (Sc *s; dequeue(s = head());) {
            if (EXPECT_FALSE(s->del_ref()) && (this == s->ec)) {
                delete s;
ffffffff8101adb9:	48 89 ef             	mov    %rbp,%rdi
ffffffff8101adbc:	e8 69 9f ff ff       	callq  ffffffff81014d2a <_ZN2ScdlEPv>
ffffffff8101adc1:	e9 0f ff ff ff       	jmpq   ffffffff8101acd5 <_ZN17Timeout_hypercall7triggerEv+0x15d>
ffffffff8101adc6:	41 fe 84 24 8a 00 00 	incb   0x8a(%r12)
ffffffff8101adcd:	00 
        ALWAYS_INLINE
        inline ~Lock_guard()
        {
            _lock.unlock();

            if (pre)
ffffffff8101adce:	40 84 ed             	test   %bpl,%bpl
ffffffff8101add1:	eb 16                	jmp    ffffffff8101ade9 <_ZN17Timeout_hypercall7triggerEv+0x271>
                continue;
            }
            s->remote_enqueue();
ffffffff8101add3:	48 89 ef             	mov    %rbp,%rdi
ffffffff8101add6:	e8 85 9c ff ff       	callq  ffffffff81014a60 <_ZN2Sc14remote_enqueueEv>
ffffffff8101addb:	e9 f5 fe ff ff       	jmpq   ffffffff8101acd5 <_ZN17Timeout_hypercall7triggerEv+0x15d>
ffffffff8101ade0:	fe 83 8a 00 00 00    	incb   0x8a(%rbx)
ffffffff8101ade6:	45 84 e4             	test   %r12b,%r12b
ffffffff8101ade9:	74 15                	je     ffffffff8101ae00 <_ZN17Timeout_hypercall7triggerEv+0x288>
        }

        ALWAYS_INLINE
        static inline void preempt_enable()
        {
            assert (!preemption);
ffffffff8101adeb:	80 3d 3e 49 fe 3e 00 	cmpb   $0x0,0x3efe493e(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
ffffffff8101adf2:	0f 85 72 fe ff ff    	jne    ffffffff8101ac6a <_ZN17Timeout_hypercall7triggerEv+0xf2>

            preemption = true;
ffffffff8101adf8:	c6 05 31 49 fe 3e 01 	movb   $0x1,0x3efe4931(%rip)        # ffffffffbffff730 <_ZN3Cpu10preemptionE>
            asm volatile ("sti" : : : "memory");
ffffffff8101adff:	fb                   	sti    
}
ffffffff8101ae00:	5b                   	pop    %rbx
ffffffff8101ae01:	5d                   	pop    %rbp
ffffffff8101ae02:	41 5c                	pop    %r12
ffffffff8101ae04:	c3                   	retq   
ffffffff8101ae05:	90                   	nop

ffffffff8101ae06 <_ZN3Tss5buildEv>:
    dbf.ss      = SEL_KERN_DATA;
    run.ss0     = SEL_KERN_DATA;
#endif

    run.sp0     = CPU_LOCAL_STCK + PAGE_SIZE;
    run.iobm    = static_cast<uint16>(SPC_LOCAL_IOP - reinterpret_cast<mword>(&run));
ffffffff8101ae06:	48 c7 c0 c8 fd ff bf 	mov    $0xffffffffbffffdc8,%rax
    dbf.es      = SEL_KERN_DATA;
    dbf.ss      = SEL_KERN_DATA;
    run.ss0     = SEL_KERN_DATA;
#endif

    run.sp0     = CPU_LOCAL_STCK + PAGE_SIZE;
ffffffff8101ae0d:	48 c7 05 b4 4f fe 3e 	movq   $0xffffffffbfffe000,0x3efe4fb4(%rip)        # ffffffffbffffdcc <tss_run+0x4>
ffffffff8101ae14:	00 e0 ff bf 
    run.iobm    = static_cast<uint16>(SPC_LOCAL_IOP - reinterpret_cast<mword>(&run));
ffffffff8101ae18:	f7 d8                	neg    %eax
ffffffff8101ae1a:	66 89 05 0d 50 fe 3e 	mov    %ax,0x3efe500d(%rip)        # ffffffffbffffe2e <tss_run+0x66>
ffffffff8101ae21:	c3                   	retq   

ffffffff8101ae22 <_ZN4Utcb8load_excEP8Cpu_regs>:
#include "vmx.hpp"
#include "x86.hpp"

bool Utcb::load_exc (Cpu_regs *regs)
{
    mword m = regs->mtd;
ffffffff8101ae22:	48 8b 86 e8 00 00 00 	mov    0xe8(%rsi),%rax

    if (m & Mtd::GPR_ACDB) {
ffffffff8101ae29:	a8 01                	test   $0x1,%al
ffffffff8101ae2b:	74 20                	je     ffffffff8101ae4d <_ZN4Utcb8load_excEP8Cpu_regs+0x2b>
        rax = regs->REG(ax);
ffffffff8101ae2d:	48 8b 56 78          	mov    0x78(%rsi),%rdx
ffffffff8101ae31:	48 89 57 50          	mov    %rdx,0x50(%rdi)
        rcx = regs->REG(cx);
ffffffff8101ae35:	48 8b 56 70          	mov    0x70(%rsi),%rdx
ffffffff8101ae39:	48 89 57 58          	mov    %rdx,0x58(%rdi)
        rdx = regs->REG(dx);
ffffffff8101ae3d:	48 8b 56 68          	mov    0x68(%rsi),%rdx
ffffffff8101ae41:	48 89 57 60          	mov    %rdx,0x60(%rdi)
        rbx = regs->REG(bx);
ffffffff8101ae45:	48 8b 56 60          	mov    0x60(%rsi),%rdx
ffffffff8101ae49:	48 89 57 68          	mov    %rdx,0x68(%rdi)
    }

    if (m & Mtd::GPR_BSD) {
ffffffff8101ae4d:	a8 02                	test   $0x2,%al
ffffffff8101ae4f:	74 1e                	je     ffffffff8101ae6f <_ZN4Utcb8load_excEP8Cpu_regs+0x4d>
        rbp = regs->REG(bp);
ffffffff8101ae51:	48 8b 56 50          	mov    0x50(%rsi),%rdx
ffffffff8101ae55:	48 89 57 78          	mov    %rdx,0x78(%rdi)
        rsi = regs->REG(si);
ffffffff8101ae59:	48 8b 56 48          	mov    0x48(%rsi),%rdx
ffffffff8101ae5d:	48 89 97 80 00 00 00 	mov    %rdx,0x80(%rdi)
        rdi = regs->REG(di);
ffffffff8101ae64:	48 8b 56 40          	mov    0x40(%rsi),%rdx
ffffffff8101ae68:	48 89 97 88 00 00 00 	mov    %rdx,0x88(%rdi)
    }

#ifdef __x86_64__
    if (m & Mtd::GPR_R8_R15) {
ffffffff8101ae6f:	a9 00 00 40 00       	test   $0x400000,%eax
ffffffff8101ae74:	74 57                	je     ffffffff8101aecd <_ZN4Utcb8load_excEP8Cpu_regs+0xab>
        r8  = regs->r8;
ffffffff8101ae76:	48 8b 56 38          	mov    0x38(%rsi),%rdx
ffffffff8101ae7a:	48 89 97 90 00 00 00 	mov    %rdx,0x90(%rdi)
        r9  = regs->r9;
ffffffff8101ae81:	48 8b 56 30          	mov    0x30(%rsi),%rdx
ffffffff8101ae85:	48 89 97 98 00 00 00 	mov    %rdx,0x98(%rdi)
        r10 = regs->r10;
ffffffff8101ae8c:	48 8b 56 28          	mov    0x28(%rsi),%rdx
ffffffff8101ae90:	48 89 97 a0 00 00 00 	mov    %rdx,0xa0(%rdi)
        r11 = regs->r11;
ffffffff8101ae97:	48 8b 56 20          	mov    0x20(%rsi),%rdx
ffffffff8101ae9b:	48 89 97 a8 00 00 00 	mov    %rdx,0xa8(%rdi)
        r12 = regs->r12;
ffffffff8101aea2:	48 8b 56 18          	mov    0x18(%rsi),%rdx
ffffffff8101aea6:	48 89 97 b0 00 00 00 	mov    %rdx,0xb0(%rdi)
        r13 = regs->r13;
ffffffff8101aead:	48 8b 56 10          	mov    0x10(%rsi),%rdx
ffffffff8101aeb1:	48 89 97 b8 00 00 00 	mov    %rdx,0xb8(%rdi)
        r14 = regs->r14;
ffffffff8101aeb8:	48 8b 56 08          	mov    0x8(%rsi),%rdx
ffffffff8101aebc:	48 89 97 c0 00 00 00 	mov    %rdx,0xc0(%rdi)
        r15 = regs->r15;
ffffffff8101aec3:	48 8b 16             	mov    (%rsi),%rdx
ffffffff8101aec6:	48 89 97 c8 00 00 00 	mov    %rdx,0xc8(%rdi)
    }
#endif

    if (m & Mtd::RSP)
ffffffff8101aecd:	a8 04                	test   $0x4,%al
ffffffff8101aecf:	74 0b                	je     ffffffff8101aedc <_ZN4Utcb8load_excEP8Cpu_regs+0xba>
        rsp = regs->REG(sp);
ffffffff8101aed1:	48 8b 96 c8 00 00 00 	mov    0xc8(%rsi),%rdx
ffffffff8101aed8:	48 89 57 70          	mov    %rdx,0x70(%rdi)

    if (m & Mtd::RIP_LEN)
ffffffff8101aedc:	a8 08                	test   $0x8,%al
ffffffff8101aede:	74 0b                	je     ffffffff8101aeeb <_ZN4Utcb8load_excEP8Cpu_regs+0xc9>
        rip = regs->REG(ip);
ffffffff8101aee0:	48 8b 96 b0 00 00 00 	mov    0xb0(%rsi),%rdx
ffffffff8101aee7:	48 89 57 30          	mov    %rdx,0x30(%rdi)

    if (m & Mtd::RFLAGS)
ffffffff8101aeeb:	a8 10                	test   $0x10,%al
ffffffff8101aeed:	74 0b                	je     ffffffff8101aefa <_ZN4Utcb8load_excEP8Cpu_regs+0xd8>
        rflags = regs->REG(fl);
ffffffff8101aeef:	48 8b 96 c0 00 00 00 	mov    0xc0(%rsi),%rdx
ffffffff8101aef6:	48 89 57 38          	mov    %rdx,0x38(%rdi)

    if (m & Mtd::QUAL) {
ffffffff8101aefa:	f6 c4 80             	test   $0x80,%ah
ffffffff8101aefd:	74 19                	je     ffffffff8101af18 <_ZN4Utcb8load_excEP8Cpu_regs+0xf6>
        qual[0] = regs->err;
ffffffff8101aeff:	48 8b 96 a0 00 00 00 	mov    0xa0(%rsi),%rdx
ffffffff8101af06:	48 89 97 d0 00 00 00 	mov    %rdx,0xd0(%rdi)
        qual[1] = regs->cr2;
ffffffff8101af0d:	48 8b 56 58          	mov    0x58(%rsi),%rdx
ffffffff8101af11:	48 89 97 d8 00 00 00 	mov    %rdx,0xd8(%rdi)
    }

    barrier();
    mtd = m;
ffffffff8101af18:	48 89 47 20          	mov    %rax,0x20(%rdi)
    items = sizeof (Utcb_data) / sizeof (mword);

    return m & Mtd::FPU;
ffffffff8101af1c:	48 c1 e8 1f          	shr    $0x1f,%rax
        qual[1] = regs->cr2;
    }

    barrier();
    mtd = m;
    items = sizeof (Utcb_data) / sizeof (mword);
ffffffff8101af20:	48 c7 07 43 00 00 00 	movq   $0x43,(%rdi)

    return m & Mtd::FPU;
ffffffff8101af27:	83 e0 01             	and    $0x1,%eax
}
ffffffff8101af2a:	c3                   	retq   
ffffffff8101af2b:	90                   	nop

ffffffff8101af2c <_ZN4Utcb8save_excEP8Cpu_regs>:

bool Utcb::save_exc (Cpu_regs *regs)
{
    if (mtd & Mtd::GPR_ACDB) {
ffffffff8101af2c:	f6 47 20 01          	testb  $0x1,0x20(%rdi)
ffffffff8101af30:	74 20                	je     ffffffff8101af52 <_ZN4Utcb8save_excEP8Cpu_regs+0x26>
        regs->REG(ax) = rax;
ffffffff8101af32:	48 8b 47 50          	mov    0x50(%rdi),%rax
ffffffff8101af36:	48 89 46 78          	mov    %rax,0x78(%rsi)
        regs->REG(cx) = rcx;
ffffffff8101af3a:	48 8b 47 58          	mov    0x58(%rdi),%rax
ffffffff8101af3e:	48 89 46 70          	mov    %rax,0x70(%rsi)
        regs->REG(dx) = rdx;
ffffffff8101af42:	48 8b 47 60          	mov    0x60(%rdi),%rax
ffffffff8101af46:	48 89 46 68          	mov    %rax,0x68(%rsi)
        regs->REG(bx) = rbx;
ffffffff8101af4a:	48 8b 47 68          	mov    0x68(%rdi),%rax
ffffffff8101af4e:	48 89 46 60          	mov    %rax,0x60(%rsi)
    }

    if (mtd & Mtd::GPR_BSD) {
ffffffff8101af52:	f6 47 20 02          	testb  $0x2,0x20(%rdi)
ffffffff8101af56:	74 1e                	je     ffffffff8101af76 <_ZN4Utcb8save_excEP8Cpu_regs+0x4a>
        regs->REG(bp) = rbp;
ffffffff8101af58:	48 8b 47 78          	mov    0x78(%rdi),%rax
ffffffff8101af5c:	48 89 46 50          	mov    %rax,0x50(%rsi)
        regs->REG(si) = rsi;
ffffffff8101af60:	48 8b 87 80 00 00 00 	mov    0x80(%rdi),%rax
ffffffff8101af67:	48 89 46 48          	mov    %rax,0x48(%rsi)
        regs->REG(di) = rdi;
ffffffff8101af6b:	48 8b 87 88 00 00 00 	mov    0x88(%rdi),%rax
ffffffff8101af72:	48 89 46 40          	mov    %rax,0x40(%rsi)
    }

#ifdef __x86_64__
    if (mtd & Mtd::GPR_R8_R15) {
ffffffff8101af76:	f6 47 22 40          	testb  $0x40,0x22(%rdi)
ffffffff8101af7a:	74 57                	je     ffffffff8101afd3 <_ZN4Utcb8save_excEP8Cpu_regs+0xa7>
        regs->r8      = r8;
ffffffff8101af7c:	48 8b 87 90 00 00 00 	mov    0x90(%rdi),%rax
ffffffff8101af83:	48 89 46 38          	mov    %rax,0x38(%rsi)
        regs->r9      = r9;
ffffffff8101af87:	48 8b 87 98 00 00 00 	mov    0x98(%rdi),%rax
ffffffff8101af8e:	48 89 46 30          	mov    %rax,0x30(%rsi)
        regs->r10     = r10;
ffffffff8101af92:	48 8b 87 a0 00 00 00 	mov    0xa0(%rdi),%rax
ffffffff8101af99:	48 89 46 28          	mov    %rax,0x28(%rsi)
        regs->r11     = r11;
ffffffff8101af9d:	48 8b 87 a8 00 00 00 	mov    0xa8(%rdi),%rax
ffffffff8101afa4:	48 89 46 20          	mov    %rax,0x20(%rsi)
        regs->r12     = r12;
ffffffff8101afa8:	48 8b 87 b0 00 00 00 	mov    0xb0(%rdi),%rax
ffffffff8101afaf:	48 89 46 18          	mov    %rax,0x18(%rsi)
        regs->r13     = r13;
ffffffff8101afb3:	48 8b 87 b8 00 00 00 	mov    0xb8(%rdi),%rax
ffffffff8101afba:	48 89 46 10          	mov    %rax,0x10(%rsi)
        regs->r14     = r14;
ffffffff8101afbe:	48 8b 87 c0 00 00 00 	mov    0xc0(%rdi),%rax
ffffffff8101afc5:	48 89 46 08          	mov    %rax,0x8(%rsi)
        regs->r15     = r15;
ffffffff8101afc9:	48 8b 87 c8 00 00 00 	mov    0xc8(%rdi),%rax
ffffffff8101afd0:	48 89 06             	mov    %rax,(%rsi)
    }
#endif

    if (mtd & Mtd::RSP)
ffffffff8101afd3:	f6 47 20 04          	testb  $0x4,0x20(%rdi)
ffffffff8101afd7:	74 0b                	je     ffffffff8101afe4 <_ZN4Utcb8save_excEP8Cpu_regs+0xb8>
        regs->REG(sp) = rsp;
ffffffff8101afd9:	48 8b 47 70          	mov    0x70(%rdi),%rax
ffffffff8101afdd:	48 89 86 c8 00 00 00 	mov    %rax,0xc8(%rsi)

    if (mtd & Mtd::RIP_LEN)
ffffffff8101afe4:	f6 47 20 08          	testb  $0x8,0x20(%rdi)
ffffffff8101afe8:	74 0b                	je     ffffffff8101aff5 <_ZN4Utcb8save_excEP8Cpu_regs+0xc9>
        regs->REG(ip) = rip;
ffffffff8101afea:	48 8b 47 30          	mov    0x30(%rdi),%rax
ffffffff8101afee:	48 89 86 b0 00 00 00 	mov    %rax,0xb0(%rsi)

    if (mtd & Mtd::RFLAGS)
ffffffff8101aff5:	f6 47 20 10          	testb  $0x10,0x20(%rdi)
ffffffff8101aff9:	74 14                	je     ffffffff8101b00f <_ZN4Utcb8save_excEP8Cpu_regs+0xe3>
        regs->REG(fl) = (rflags & ~(Cpu::EFL_VIP | Cpu::EFL_VIF | Cpu::EFL_VM | Cpu::EFL_RF | Cpu::EFL_IOPL)) | Cpu::EFL_IF;
ffffffff8101affb:	48 8b 47 38          	mov    0x38(%rdi),%rax
ffffffff8101afff:	48 25 ff cd e4 ff    	and    $0xffffffffffe4cdff,%rax
ffffffff8101b005:	80 cc 02             	or     $0x2,%ah
ffffffff8101b008:	48 89 86 c0 00 00 00 	mov    %rax,0xc0(%rsi)

    return mtd & Mtd::FPU;
ffffffff8101b00f:	48 8b 47 20          	mov    0x20(%rdi),%rax
ffffffff8101b013:	48 c1 e8 1f          	shr    $0x1f,%rax
ffffffff8101b017:	83 e0 01             	and    $0x1,%eax
}
ffffffff8101b01a:	c3                   	retq   
ffffffff8101b01b:	90                   	nop

ffffffff8101b01c <_ZN4Utcb8load_vmxEP8Cpu_regs>:

bool Utcb::load_vmx (Cpu_regs *regs)
{
ffffffff8101b01c:	41 54                	push   %r12
ffffffff8101b01e:	55                   	push   %rbp
ffffffff8101b01f:	49 89 f4             	mov    %rsi,%r12
ffffffff8101b022:	53                   	push   %rbx
ffffffff8101b023:	48 89 fb             	mov    %rdi,%rbx
ffffffff8101b026:	48 83 ec 10          	sub    $0x10,%rsp
    mword m = regs->mtd;
ffffffff8101b02a:	48 8b ae e8 00 00 00 	mov    0xe8(%rsi),%rbp

    if (m & Mtd::GPR_ACDB) {
ffffffff8101b031:	40 f6 c5 01          	test   $0x1,%bpl
ffffffff8101b035:	74 20                	je     ffffffff8101b057 <_ZN4Utcb8load_vmxEP8Cpu_regs+0x3b>
        rax = regs->REG(ax);
ffffffff8101b037:	48 8b 46 78          	mov    0x78(%rsi),%rax
ffffffff8101b03b:	48 89 47 50          	mov    %rax,0x50(%rdi)
        rcx = regs->REG(cx);
ffffffff8101b03f:	48 8b 46 70          	mov    0x70(%rsi),%rax
ffffffff8101b043:	48 89 47 58          	mov    %rax,0x58(%rdi)
        rdx = regs->REG(dx);
ffffffff8101b047:	48 8b 46 68          	mov    0x68(%rsi),%rax
ffffffff8101b04b:	48 89 47 60          	mov    %rax,0x60(%rdi)
        rbx = regs->REG(bx);
ffffffff8101b04f:	48 8b 46 60          	mov    0x60(%rsi),%rax
ffffffff8101b053:	48 89 47 68          	mov    %rax,0x68(%rdi)
    }

    if (m & Mtd::GPR_BSD) {
ffffffff8101b057:	40 f6 c5 02          	test   $0x2,%bpl
ffffffff8101b05b:	74 21                	je     ffffffff8101b07e <_ZN4Utcb8load_vmxEP8Cpu_regs+0x62>
        rbp = regs->REG(bp);
ffffffff8101b05d:	49 8b 44 24 50       	mov    0x50(%r12),%rax
ffffffff8101b062:	48 89 43 78          	mov    %rax,0x78(%rbx)
        rsi = regs->REG(si);
ffffffff8101b066:	49 8b 44 24 48       	mov    0x48(%r12),%rax
ffffffff8101b06b:	48 89 83 80 00 00 00 	mov    %rax,0x80(%rbx)
        rdi = regs->REG(di);
ffffffff8101b072:	49 8b 44 24 40       	mov    0x40(%r12),%rax
ffffffff8101b077:	48 89 83 88 00 00 00 	mov    %rax,0x88(%rbx)
    }

#ifdef __x86_64__
    if (m & Mtd::GPR_R8_R15) {
ffffffff8101b07e:	f7 c5 00 00 40 00    	test   $0x400000,%ebp
ffffffff8101b084:	74 5f                	je     ffffffff8101b0e5 <_ZN4Utcb8load_vmxEP8Cpu_regs+0xc9>
        r8  = regs->r8;
ffffffff8101b086:	49 8b 44 24 38       	mov    0x38(%r12),%rax
ffffffff8101b08b:	48 89 83 90 00 00 00 	mov    %rax,0x90(%rbx)
        r9  = regs->r9;
ffffffff8101b092:	49 8b 44 24 30       	mov    0x30(%r12),%rax
ffffffff8101b097:	48 89 83 98 00 00 00 	mov    %rax,0x98(%rbx)
        r10 = regs->r10;
ffffffff8101b09e:	49 8b 44 24 28       	mov    0x28(%r12),%rax
ffffffff8101b0a3:	48 89 83 a0 00 00 00 	mov    %rax,0xa0(%rbx)
        r11 = regs->r11;
ffffffff8101b0aa:	49 8b 44 24 20       	mov    0x20(%r12),%rax
ffffffff8101b0af:	48 89 83 a8 00 00 00 	mov    %rax,0xa8(%rbx)
        r12 = regs->r12;
ffffffff8101b0b6:	49 8b 44 24 18       	mov    0x18(%r12),%rax
ffffffff8101b0bb:	48 89 83 b0 00 00 00 	mov    %rax,0xb0(%rbx)
        r13 = regs->r13;
ffffffff8101b0c2:	49 8b 44 24 10       	mov    0x10(%r12),%rax
ffffffff8101b0c7:	48 89 83 b8 00 00 00 	mov    %rax,0xb8(%rbx)
        r14 = regs->r14;
ffffffff8101b0ce:	49 8b 44 24 08       	mov    0x8(%r12),%rax
ffffffff8101b0d3:	48 89 83 c0 00 00 00 	mov    %rax,0xc0(%rbx)
        r15 = regs->r15;
ffffffff8101b0da:	49 8b 04 24          	mov    (%r12),%rax
ffffffff8101b0de:	48 89 83 c8 00 00 00 	mov    %rax,0xc8(%rbx)
    }
#endif

    regs->vmcs->make_current();
ffffffff8101b0e5:	49 8b 84 24 80 00 00 	mov    0x80(%r12),%rax
ffffffff8101b0ec:	00 
        Vmcs* clone();

        ALWAYS_INLINE
        inline void make_current()
        {
            if (EXPECT_TRUE (current == this))
ffffffff8101b0ed:	48 39 05 2c 3f fe 3e 	cmp    %rax,0x3efe3f2c(%rip)        # ffffffffbffff020 <_ZN4Vmcs7currentE>
ffffffff8101b0f4:	74 44                	je     ffffffff8101b13a <_ZN4Utcb8load_vmxEP8Cpu_regs+0x11e>
                return;

            uint64 phys = Buddy::ptr_to_phys (current = this);
ffffffff8101b0f6:	48 89 05 23 3f fe 3e 	mov    %rax,0x3efe3f23(%rip)        # ffffffffbffff020 <_ZN4Vmcs7currentE>
ffffffff8101b0fd:	48 2d 00 00 c0 80    	sub    $0xffffffff80c00000,%rax
ffffffff8101b103:	48 89 44 24 08       	mov    %rax,0x8(%rsp)

            bool ret;
            asm volatile ("vmptrld %1; seta %0" : "=q" (ret) : "m" (phys) : "cc");
ffffffff8101b108:	0f c7 74 24 08       	vmptrld 0x8(%rsp)
ffffffff8101b10d:	0f 97 c0             	seta   %al
            assert (ret);
ffffffff8101b110:	84 c0                	test   %al,%al
ffffffff8101b112:	75 26                	jne    ffffffff8101b13a <_ZN4Utcb8load_vmxEP8Cpu_regs+0x11e>
ffffffff8101b114:	49 c7 c0 60 14 02 81 	mov    $0xffffffff81021460,%r8
ffffffff8101b11b:	b9 9a 01 00 00       	mov    $0x19a,%ecx
ffffffff8101b120:	48 c7 c2 72 db 01 81 	mov    $0xffffffff8101db72,%rdx
ffffffff8101b127:	48 c7 c6 e1 db 01 81 	mov    $0xffffffff8101dbe1,%rsi
ffffffff8101b12e:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8101b135:	e8 16 6e fe ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

    if (m & Mtd::RSP)
ffffffff8101b13a:	40 f6 c5 04          	test   $0x4,%bpl
ffffffff8101b13e:	74 09                	je     ffffffff8101b149 <_ZN4Utcb8load_vmxEP8Cpu_regs+0x12d>
        rsp = Vmcs::read (Vmcs::GUEST_RSP);
ffffffff8101b140:	b8 1c 68 00 00       	mov    $0x681c,%eax
ffffffff8101b145:	0f 78 43 70          	vmread %rax,0x70(%rbx)

    if (m & Mtd::RIP_LEN) {
ffffffff8101b149:	40 f6 c5 08          	test   $0x8,%bpl
ffffffff8101b14d:	74 11                	je     ffffffff8101b160 <_ZN4Utcb8load_vmxEP8Cpu_regs+0x144>
        rip      = Vmcs::read (Vmcs::GUEST_RIP);
ffffffff8101b14f:	b8 1e 68 00 00       	mov    $0x681e,%eax
ffffffff8101b154:	0f 78 43 30          	vmread %rax,0x30(%rbx)
        inst_len = Vmcs::read (Vmcs::EXI_INST_LEN);
ffffffff8101b158:	66 b8 0c 44          	mov    $0x440c,%ax
ffffffff8101b15c:	0f 78 43 28          	vmread %rax,0x28(%rbx)
    }

    if (m & Mtd::RFLAGS)
ffffffff8101b160:	40 f6 c5 10          	test   $0x10,%bpl
ffffffff8101b164:	74 09                	je     ffffffff8101b16f <_ZN4Utcb8load_vmxEP8Cpu_regs+0x153>
        rflags = Vmcs::read (Vmcs::GUEST_RFLAGS);
ffffffff8101b166:	b8 20 68 00 00       	mov    $0x6820,%eax
ffffffff8101b16b:	0f 78 43 38          	vmread %rax,0x38(%rbx)

    if (m & Mtd::DS_ES) {
ffffffff8101b16f:	40 f6 c5 20          	test   $0x20,%bpl
ffffffff8101b173:	0f 84 98 00 00 00    	je     ffffffff8101b211 <_ZN4Utcb8load_vmxEP8Cpu_regs+0x1f5>

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
ffffffff8101b179:	b8 1a 48 00 00       	mov    $0x481a,%eax
ffffffff8101b17e:	0f 78 c0             	vmread %rax,%rax
ffffffff8101b181:	b9 06 48 00 00       	mov    $0x4806,%ecx
ffffffff8101b186:	0f 78 c9             	vmread %rcx,%rcx
ffffffff8101b189:	ba 0c 68 00 00       	mov    $0x680c,%edx
ffffffff8101b18e:	0f 78 d2             	vmread %rdx,%rdx
ffffffff8101b191:	be 06 08 00 00       	mov    $0x806,%esi
ffffffff8101b196:	0f 78 f6             	vmread %rsi,%rsi
        uint64  base;

        ALWAYS_INLINE
        inline void set_vmx (mword s, mword b, mword l, mword a)
        {
            sel   = static_cast<uint16>(s);
ffffffff8101b199:	66 89 b3 b8 01 00 00 	mov    %si,0x1b8(%rbx)
            ar    = static_cast<uint16>((a >> 4 & 0x1f00) | (a & 0xff));
ffffffff8101b1a0:	48 89 c6             	mov    %rax,%rsi
ffffffff8101b1a3:	0f b6 c0             	movzbl %al,%eax
ffffffff8101b1a6:	48 c1 ee 04          	shr    $0x4,%rsi
            limit = static_cast<uint32>(l);
ffffffff8101b1aa:	89 8b bc 01 00 00    	mov    %ecx,0x1bc(%rbx)
            base  = b;
ffffffff8101b1b0:	48 89 93 c0 01 00 00 	mov    %rdx,0x1c0(%rbx)

        ALWAYS_INLINE
        inline void set_vmx (mword s, mword b, mword l, mword a)
        {
            sel   = static_cast<uint16>(s);
            ar    = static_cast<uint16>((a >> 4 & 0x1f00) | (a & 0xff));
ffffffff8101b1b7:	66 81 e6 00 1f       	and    $0x1f00,%si
ffffffff8101b1bc:	09 f0                	or     %esi,%eax
ffffffff8101b1be:	66 89 83 ba 01 00 00 	mov    %ax,0x1ba(%rbx)
ffffffff8101b1c5:	b8 14 48 00 00       	mov    $0x4814,%eax
ffffffff8101b1ca:	0f 78 c0             	vmread %rax,%rax
ffffffff8101b1cd:	b9 00 48 00 00       	mov    $0x4800,%ecx
ffffffff8101b1d2:	0f 78 c9             	vmread %rcx,%rcx
ffffffff8101b1d5:	ba 06 68 00 00       	mov    $0x6806,%edx
ffffffff8101b1da:	0f 78 d2             	vmread %rdx,%rdx
ffffffff8101b1dd:	be 00 08 00 00       	mov    $0x800,%esi
ffffffff8101b1e2:	0f 78 f6             	vmread %rsi,%rsi
        uint64  base;

        ALWAYS_INLINE
        inline void set_vmx (mword s, mword b, mword l, mword a)
        {
            sel   = static_cast<uint16>(s);
ffffffff8101b1e5:	66 89 b3 88 01 00 00 	mov    %si,0x188(%rbx)
            ar    = static_cast<uint16>((a >> 4 & 0x1f00) | (a & 0xff));
ffffffff8101b1ec:	48 89 c6             	mov    %rax,%rsi
ffffffff8101b1ef:	0f b6 c0             	movzbl %al,%eax
ffffffff8101b1f2:	48 c1 ee 04          	shr    $0x4,%rsi
            limit = static_cast<uint32>(l);
ffffffff8101b1f6:	89 8b 8c 01 00 00    	mov    %ecx,0x18c(%rbx)
            base  = b;
ffffffff8101b1fc:	48 89 93 90 01 00 00 	mov    %rdx,0x190(%rbx)

        ALWAYS_INLINE
        inline void set_vmx (mword s, mword b, mword l, mword a)
        {
            sel   = static_cast<uint16>(s);
            ar    = static_cast<uint16>((a >> 4 & 0x1f00) | (a & 0xff));
ffffffff8101b203:	66 81 e6 00 1f       	and    $0x1f00,%si
ffffffff8101b208:	09 f0                	or     %esi,%eax
ffffffff8101b20a:	66 89 83 8a 01 00 00 	mov    %ax,0x18a(%rbx)
        ds.set_vmx (Vmcs::read (Vmcs::GUEST_SEL_DS), Vmcs::read (Vmcs::GUEST_BASE_DS), Vmcs::read (Vmcs::GUEST_LIMIT_DS), Vmcs::read (Vmcs::GUEST_AR_DS));
        es.set_vmx (Vmcs::read (Vmcs::GUEST_SEL_ES), Vmcs::read (Vmcs::GUEST_BASE_ES), Vmcs::read (Vmcs::GUEST_LIMIT_ES), Vmcs::read (Vmcs::GUEST_AR_ES));
    }

    if (m & Mtd::FS_GS) {
ffffffff8101b211:	40 f6 c5 40          	test   $0x40,%bpl
ffffffff8101b215:	0f 84 98 00 00 00    	je     ffffffff8101b2b3 <_ZN4Utcb8load_vmxEP8Cpu_regs+0x297>
ffffffff8101b21b:	b8 1c 48 00 00       	mov    $0x481c,%eax
ffffffff8101b220:	0f 78 c0             	vmread %rax,%rax
ffffffff8101b223:	b9 08 48 00 00       	mov    $0x4808,%ecx
ffffffff8101b228:	0f 78 c9             	vmread %rcx,%rcx
ffffffff8101b22b:	ba 0e 68 00 00       	mov    $0x680e,%edx
ffffffff8101b230:	0f 78 d2             	vmread %rdx,%rdx
ffffffff8101b233:	be 08 08 00 00       	mov    $0x808,%esi
ffffffff8101b238:	0f 78 f6             	vmread %rsi,%rsi
        uint64  base;

        ALWAYS_INLINE
        inline void set_vmx (mword s, mword b, mword l, mword a)
        {
            sel   = static_cast<uint16>(s);
ffffffff8101b23b:	66 89 b3 c8 01 00 00 	mov    %si,0x1c8(%rbx)
            ar    = static_cast<uint16>((a >> 4 & 0x1f00) | (a & 0xff));
ffffffff8101b242:	48 89 c6             	mov    %rax,%rsi
ffffffff8101b245:	0f b6 c0             	movzbl %al,%eax
ffffffff8101b248:	48 c1 ee 04          	shr    $0x4,%rsi
            limit = static_cast<uint32>(l);
ffffffff8101b24c:	89 8b cc 01 00 00    	mov    %ecx,0x1cc(%rbx)
            base  = b;
ffffffff8101b252:	48 89 93 d0 01 00 00 	mov    %rdx,0x1d0(%rbx)

        ALWAYS_INLINE
        inline void set_vmx (mword s, mword b, mword l, mword a)
        {
            sel   = static_cast<uint16>(s);
            ar    = static_cast<uint16>((a >> 4 & 0x1f00) | (a & 0xff));
ffffffff8101b259:	66 81 e6 00 1f       	and    $0x1f00,%si
ffffffff8101b25e:	09 f0                	or     %esi,%eax
ffffffff8101b260:	66 89 83 ca 01 00 00 	mov    %ax,0x1ca(%rbx)
ffffffff8101b267:	b8 1e 48 00 00       	mov    $0x481e,%eax
ffffffff8101b26c:	0f 78 c0             	vmread %rax,%rax
ffffffff8101b26f:	b9 0a 48 00 00       	mov    $0x480a,%ecx
ffffffff8101b274:	0f 78 c9             	vmread %rcx,%rcx
ffffffff8101b277:	ba 10 68 00 00       	mov    $0x6810,%edx
ffffffff8101b27c:	0f 78 d2             	vmread %rdx,%rdx
ffffffff8101b27f:	be 0a 08 00 00       	mov    $0x80a,%esi
ffffffff8101b284:	0f 78 f6             	vmread %rsi,%rsi
        uint64  base;

        ALWAYS_INLINE
        inline void set_vmx (mword s, mword b, mword l, mword a)
        {
            sel   = static_cast<uint16>(s);
ffffffff8101b287:	66 89 b3 d8 01 00 00 	mov    %si,0x1d8(%rbx)
            ar    = static_cast<uint16>((a >> 4 & 0x1f00) | (a & 0xff));
ffffffff8101b28e:	48 89 c6             	mov    %rax,%rsi
ffffffff8101b291:	0f b6 c0             	movzbl %al,%eax
ffffffff8101b294:	48 c1 ee 04          	shr    $0x4,%rsi
            limit = static_cast<uint32>(l);
ffffffff8101b298:	89 8b dc 01 00 00    	mov    %ecx,0x1dc(%rbx)
            base  = b;
ffffffff8101b29e:	48 89 93 e0 01 00 00 	mov    %rdx,0x1e0(%rbx)

        ALWAYS_INLINE
        inline void set_vmx (mword s, mword b, mword l, mword a)
        {
            sel   = static_cast<uint16>(s);
            ar    = static_cast<uint16>((a >> 4 & 0x1f00) | (a & 0xff));
ffffffff8101b2a5:	66 81 e6 00 1f       	and    $0x1f00,%si
ffffffff8101b2aa:	09 f0                	or     %esi,%eax
ffffffff8101b2ac:	66 89 83 da 01 00 00 	mov    %ax,0x1da(%rbx)
        fs.set_vmx (Vmcs::read (Vmcs::GUEST_SEL_FS), Vmcs::read (Vmcs::GUEST_BASE_FS), Vmcs::read (Vmcs::GUEST_LIMIT_FS), Vmcs::read (Vmcs::GUEST_AR_FS));
        gs.set_vmx (Vmcs::read (Vmcs::GUEST_SEL_GS), Vmcs::read (Vmcs::GUEST_BASE_GS), Vmcs::read (Vmcs::GUEST_LIMIT_GS), Vmcs::read (Vmcs::GUEST_AR_GS));
    }

    if (m & Mtd::CS_SS) {
ffffffff8101b2b3:	40 f6 c5 80          	test   $0x80,%bpl
ffffffff8101b2b7:	0f 84 98 00 00 00    	je     ffffffff8101b355 <_ZN4Utcb8load_vmxEP8Cpu_regs+0x339>
ffffffff8101b2bd:	b8 16 48 00 00       	mov    $0x4816,%eax
ffffffff8101b2c2:	0f 78 c0             	vmread %rax,%rax
ffffffff8101b2c5:	b9 02 48 00 00       	mov    $0x4802,%ecx
ffffffff8101b2ca:	0f 78 c9             	vmread %rcx,%rcx
ffffffff8101b2cd:	ba 08 68 00 00       	mov    $0x6808,%edx
ffffffff8101b2d2:	0f 78 d2             	vmread %rdx,%rdx
ffffffff8101b2d5:	be 02 08 00 00       	mov    $0x802,%esi
ffffffff8101b2da:	0f 78 f6             	vmread %rsi,%rsi
        uint64  base;

        ALWAYS_INLINE
        inline void set_vmx (mword s, mword b, mword l, mword a)
        {
            sel   = static_cast<uint16>(s);
ffffffff8101b2dd:	66 89 b3 98 01 00 00 	mov    %si,0x198(%rbx)
            ar    = static_cast<uint16>((a >> 4 & 0x1f00) | (a & 0xff));
ffffffff8101b2e4:	48 89 c6             	mov    %rax,%rsi
ffffffff8101b2e7:	0f b6 c0             	movzbl %al,%eax
ffffffff8101b2ea:	48 c1 ee 04          	shr    $0x4,%rsi
            limit = static_cast<uint32>(l);
ffffffff8101b2ee:	89 8b 9c 01 00 00    	mov    %ecx,0x19c(%rbx)
            base  = b;
ffffffff8101b2f4:	48 89 93 a0 01 00 00 	mov    %rdx,0x1a0(%rbx)

        ALWAYS_INLINE
        inline void set_vmx (mword s, mword b, mword l, mword a)
        {
            sel   = static_cast<uint16>(s);
            ar    = static_cast<uint16>((a >> 4 & 0x1f00) | (a & 0xff));
ffffffff8101b2fb:	66 81 e6 00 1f       	and    $0x1f00,%si
ffffffff8101b300:	09 f0                	or     %esi,%eax
ffffffff8101b302:	66 89 83 9a 01 00 00 	mov    %ax,0x19a(%rbx)
ffffffff8101b309:	b8 18 48 00 00       	mov    $0x4818,%eax
ffffffff8101b30e:	0f 78 c0             	vmread %rax,%rax
ffffffff8101b311:	b9 04 48 00 00       	mov    $0x4804,%ecx
ffffffff8101b316:	0f 78 c9             	vmread %rcx,%rcx
ffffffff8101b319:	ba 0a 68 00 00       	mov    $0x680a,%edx
ffffffff8101b31e:	0f 78 d2             	vmread %rdx,%rdx
ffffffff8101b321:	be 04 08 00 00       	mov    $0x804,%esi
ffffffff8101b326:	0f 78 f6             	vmread %rsi,%rsi
        uint64  base;

        ALWAYS_INLINE
        inline void set_vmx (mword s, mword b, mword l, mword a)
        {
            sel   = static_cast<uint16>(s);
ffffffff8101b329:	66 89 b3 a8 01 00 00 	mov    %si,0x1a8(%rbx)
            ar    = static_cast<uint16>((a >> 4 & 0x1f00) | (a & 0xff));
ffffffff8101b330:	48 89 c6             	mov    %rax,%rsi
ffffffff8101b333:	0f b6 c0             	movzbl %al,%eax
ffffffff8101b336:	48 c1 ee 04          	shr    $0x4,%rsi
            limit = static_cast<uint32>(l);
ffffffff8101b33a:	89 8b ac 01 00 00    	mov    %ecx,0x1ac(%rbx)
            base  = b;
ffffffff8101b340:	48 89 93 b0 01 00 00 	mov    %rdx,0x1b0(%rbx)

        ALWAYS_INLINE
        inline void set_vmx (mword s, mword b, mword l, mword a)
        {
            sel   = static_cast<uint16>(s);
            ar    = static_cast<uint16>((a >> 4 & 0x1f00) | (a & 0xff));
ffffffff8101b347:	66 81 e6 00 1f       	and    $0x1f00,%si
ffffffff8101b34c:	09 f0                	or     %esi,%eax
ffffffff8101b34e:	66 89 83 aa 01 00 00 	mov    %ax,0x1aa(%rbx)
        cs.set_vmx (Vmcs::read (Vmcs::GUEST_SEL_CS), Vmcs::read (Vmcs::GUEST_BASE_CS), Vmcs::read (Vmcs::GUEST_LIMIT_CS), Vmcs::read (Vmcs::GUEST_AR_CS));
        ss.set_vmx (Vmcs::read (Vmcs::GUEST_SEL_SS), Vmcs::read (Vmcs::GUEST_BASE_SS), Vmcs::read (Vmcs::GUEST_LIMIT_SS), Vmcs::read (Vmcs::GUEST_AR_SS));
    }

    if (m & Mtd::TR)
ffffffff8101b355:	f7 c5 00 01 00 00    	test   $0x100,%ebp
ffffffff8101b35b:	74 4c                	je     ffffffff8101b3a9 <_ZN4Utcb8load_vmxEP8Cpu_regs+0x38d>
ffffffff8101b35d:	b8 22 48 00 00       	mov    $0x4822,%eax
ffffffff8101b362:	0f 78 c0             	vmread %rax,%rax
ffffffff8101b365:	b9 0e 48 00 00       	mov    $0x480e,%ecx
ffffffff8101b36a:	0f 78 c9             	vmread %rcx,%rcx
ffffffff8101b36d:	ba 14 68 00 00       	mov    $0x6814,%edx
ffffffff8101b372:	0f 78 d2             	vmread %rdx,%rdx
ffffffff8101b375:	be 0e 08 00 00       	mov    $0x80e,%esi
ffffffff8101b37a:	0f 78 f6             	vmread %rsi,%rsi
        uint64  base;

        ALWAYS_INLINE
        inline void set_vmx (mword s, mword b, mword l, mword a)
        {
            sel   = static_cast<uint16>(s);
ffffffff8101b37d:	66 89 b3 f8 01 00 00 	mov    %si,0x1f8(%rbx)
            ar    = static_cast<uint16>((a >> 4 & 0x1f00) | (a & 0xff));
ffffffff8101b384:	48 89 c6             	mov    %rax,%rsi
ffffffff8101b387:	0f b6 c0             	movzbl %al,%eax
ffffffff8101b38a:	48 c1 ee 04          	shr    $0x4,%rsi
            limit = static_cast<uint32>(l);
ffffffff8101b38e:	89 8b fc 01 00 00    	mov    %ecx,0x1fc(%rbx)
            base  = b;
ffffffff8101b394:	48 89 93 00 02 00 00 	mov    %rdx,0x200(%rbx)

        ALWAYS_INLINE
        inline void set_vmx (mword s, mword b, mword l, mword a)
        {
            sel   = static_cast<uint16>(s);
            ar    = static_cast<uint16>((a >> 4 & 0x1f00) | (a & 0xff));
ffffffff8101b39b:	66 81 e6 00 1f       	and    $0x1f00,%si
ffffffff8101b3a0:	09 f0                	or     %esi,%eax
ffffffff8101b3a2:	66 89 83 fa 01 00 00 	mov    %ax,0x1fa(%rbx)
        tr.set_vmx (Vmcs::read (Vmcs::GUEST_SEL_TR), Vmcs::read (Vmcs::GUEST_BASE_TR), Vmcs::read (Vmcs::GUEST_LIMIT_TR), Vmcs::read (Vmcs::GUEST_AR_TR));

    if (m & Mtd::LDTR)
ffffffff8101b3a9:	f7 c5 00 02 00 00    	test   $0x200,%ebp
ffffffff8101b3af:	74 4c                	je     ffffffff8101b3fd <_ZN4Utcb8load_vmxEP8Cpu_regs+0x3e1>
ffffffff8101b3b1:	b8 20 48 00 00       	mov    $0x4820,%eax
ffffffff8101b3b6:	0f 78 c0             	vmread %rax,%rax
ffffffff8101b3b9:	b9 0c 48 00 00       	mov    $0x480c,%ecx
ffffffff8101b3be:	0f 78 c9             	vmread %rcx,%rcx
ffffffff8101b3c1:	ba 12 68 00 00       	mov    $0x6812,%edx
ffffffff8101b3c6:	0f 78 d2             	vmread %rdx,%rdx
ffffffff8101b3c9:	be 0c 08 00 00       	mov    $0x80c,%esi
ffffffff8101b3ce:	0f 78 f6             	vmread %rsi,%rsi
        uint64  base;

        ALWAYS_INLINE
        inline void set_vmx (mword s, mword b, mword l, mword a)
        {
            sel   = static_cast<uint16>(s);
ffffffff8101b3d1:	66 89 b3 e8 01 00 00 	mov    %si,0x1e8(%rbx)
            ar    = static_cast<uint16>((a >> 4 & 0x1f00) | (a & 0xff));
ffffffff8101b3d8:	48 89 c6             	mov    %rax,%rsi
ffffffff8101b3db:	0f b6 c0             	movzbl %al,%eax
ffffffff8101b3de:	48 c1 ee 04          	shr    $0x4,%rsi
            limit = static_cast<uint32>(l);
ffffffff8101b3e2:	89 8b ec 01 00 00    	mov    %ecx,0x1ec(%rbx)
            base  = b;
ffffffff8101b3e8:	48 89 93 f0 01 00 00 	mov    %rdx,0x1f0(%rbx)

        ALWAYS_INLINE
        inline void set_vmx (mword s, mword b, mword l, mword a)
        {
            sel   = static_cast<uint16>(s);
            ar    = static_cast<uint16>((a >> 4 & 0x1f00) | (a & 0xff));
ffffffff8101b3ef:	66 81 e6 00 1f       	and    $0x1f00,%si
ffffffff8101b3f4:	09 f0                	or     %esi,%eax
ffffffff8101b3f6:	66 89 83 ea 01 00 00 	mov    %ax,0x1ea(%rbx)
        ld.set_vmx (Vmcs::read (Vmcs::GUEST_SEL_LDTR), Vmcs::read (Vmcs::GUEST_BASE_LDTR), Vmcs::read (Vmcs::GUEST_LIMIT_LDTR), Vmcs::read (Vmcs::GUEST_AR_LDTR));

    if (m & Mtd::GDTR)
ffffffff8101b3fd:	f7 c5 00 04 00 00    	test   $0x400,%ebp
ffffffff8101b403:	74 2f                	je     ffffffff8101b434 <_ZN4Utcb8load_vmxEP8Cpu_regs+0x418>
ffffffff8101b405:	ba 10 48 00 00       	mov    $0x4810,%edx
ffffffff8101b40a:	0f 78 d2             	vmread %rdx,%rdx
ffffffff8101b40d:	b8 16 68 00 00       	mov    $0x6816,%eax
ffffffff8101b412:	0f 78 c0             	vmread %rax,%rax
        uint64  base;

        ALWAYS_INLINE
        inline void set_vmx (mword s, mword b, mword l, mword a)
        {
            sel   = static_cast<uint16>(s);
ffffffff8101b415:	66 c7 83 08 02 00 00 	movw   $0x0,0x208(%rbx)
ffffffff8101b41c:	00 00 
            ar    = static_cast<uint16>((a >> 4 & 0x1f00) | (a & 0xff));
ffffffff8101b41e:	66 c7 83 0a 02 00 00 	movw   $0x0,0x20a(%rbx)
ffffffff8101b425:	00 00 
            limit = static_cast<uint32>(l);
ffffffff8101b427:	89 93 0c 02 00 00    	mov    %edx,0x20c(%rbx)
            base  = b;
ffffffff8101b42d:	48 89 83 10 02 00 00 	mov    %rax,0x210(%rbx)
        gd.set_vmx (0, Vmcs::read (Vmcs::GUEST_BASE_GDTR), Vmcs::read (Vmcs::GUEST_LIMIT_GDTR), 0);

    if (m & Mtd::IDTR)
ffffffff8101b434:	f7 c5 00 08 00 00    	test   $0x800,%ebp
ffffffff8101b43a:	74 2f                	je     ffffffff8101b46b <_ZN4Utcb8load_vmxEP8Cpu_regs+0x44f>
ffffffff8101b43c:	ba 12 48 00 00       	mov    $0x4812,%edx
ffffffff8101b441:	0f 78 d2             	vmread %rdx,%rdx
ffffffff8101b444:	b8 18 68 00 00       	mov    $0x6818,%eax
ffffffff8101b449:	0f 78 c0             	vmread %rax,%rax
        uint64  base;

        ALWAYS_INLINE
        inline void set_vmx (mword s, mword b, mword l, mword a)
        {
            sel   = static_cast<uint16>(s);
ffffffff8101b44c:	66 c7 83 18 02 00 00 	movw   $0x0,0x218(%rbx)
ffffffff8101b453:	00 00 
            ar    = static_cast<uint16>((a >> 4 & 0x1f00) | (a & 0xff));
ffffffff8101b455:	66 c7 83 1a 02 00 00 	movw   $0x0,0x21a(%rbx)
ffffffff8101b45c:	00 00 
            limit = static_cast<uint32>(l);
ffffffff8101b45e:	89 93 1c 02 00 00    	mov    %edx,0x21c(%rbx)
            base  = b;
ffffffff8101b464:	48 89 83 20 02 00 00 	mov    %rax,0x220(%rbx)
        id.set_vmx (0, Vmcs::read (Vmcs::GUEST_BASE_IDTR), Vmcs::read (Vmcs::GUEST_LIMIT_IDTR), 0);

    if (m & Mtd::CR) {
ffffffff8101b46b:	f7 c5 00 10 00 00    	test   $0x1000,%ebp
ffffffff8101b471:	74 4d                	je     ffffffff8101b4c0 <_ZN4Utcb8load_vmxEP8Cpu_regs+0x4a4>
        cr0 = regs->read_cr<Vmcs> (0);
ffffffff8101b473:	31 f6                	xor    %esi,%esi
ffffffff8101b475:	4c 89 e7             	mov    %r12,%rdi
ffffffff8101b478:	e8 fb 8a ff ff       	callq  ffffffff81013f78 <_ZNK8Exc_regs7read_crI4VmcsEEmj>
        cr2 = regs->read_cr<Vmcs> (2);
ffffffff8101b47d:	be 02 00 00 00       	mov    $0x2,%esi
ffffffff8101b482:	4c 89 e7             	mov    %r12,%rdi

    if (m & Mtd::IDTR)
        id.set_vmx (0, Vmcs::read (Vmcs::GUEST_BASE_IDTR), Vmcs::read (Vmcs::GUEST_LIMIT_IDTR), 0);

    if (m & Mtd::CR) {
        cr0 = regs->read_cr<Vmcs> (0);
ffffffff8101b485:	48 89 83 f0 00 00 00 	mov    %rax,0xf0(%rbx)
        cr2 = regs->read_cr<Vmcs> (2);
ffffffff8101b48c:	e8 e7 8a ff ff       	callq  ffffffff81013f78 <_ZNK8Exc_regs7read_crI4VmcsEEmj>
        cr3 = regs->read_cr<Vmcs> (3);
ffffffff8101b491:	be 03 00 00 00       	mov    $0x3,%esi
ffffffff8101b496:	4c 89 e7             	mov    %r12,%rdi
    if (m & Mtd::IDTR)
        id.set_vmx (0, Vmcs::read (Vmcs::GUEST_BASE_IDTR), Vmcs::read (Vmcs::GUEST_LIMIT_IDTR), 0);

    if (m & Mtd::CR) {
        cr0 = regs->read_cr<Vmcs> (0);
        cr2 = regs->read_cr<Vmcs> (2);
ffffffff8101b499:	48 89 83 f8 00 00 00 	mov    %rax,0xf8(%rbx)
        cr3 = regs->read_cr<Vmcs> (3);
ffffffff8101b4a0:	e8 d3 8a ff ff       	callq  ffffffff81013f78 <_ZNK8Exc_regs7read_crI4VmcsEEmj>
        cr4 = regs->read_cr<Vmcs> (4);
ffffffff8101b4a5:	be 04 00 00 00       	mov    $0x4,%esi
        id.set_vmx (0, Vmcs::read (Vmcs::GUEST_BASE_IDTR), Vmcs::read (Vmcs::GUEST_LIMIT_IDTR), 0);

    if (m & Mtd::CR) {
        cr0 = regs->read_cr<Vmcs> (0);
        cr2 = regs->read_cr<Vmcs> (2);
        cr3 = regs->read_cr<Vmcs> (3);
ffffffff8101b4aa:	48 89 83 00 01 00 00 	mov    %rax,0x100(%rbx)
        cr4 = regs->read_cr<Vmcs> (4);
ffffffff8101b4b1:	4c 89 e7             	mov    %r12,%rdi
ffffffff8101b4b4:	e8 bf 8a ff ff       	callq  ffffffff81013f78 <_ZNK8Exc_regs7read_crI4VmcsEEmj>
ffffffff8101b4b9:	48 89 83 08 01 00 00 	mov    %rax,0x108(%rbx)
    }

    if (m & Mtd::DR)
ffffffff8101b4c0:	f7 c5 00 20 00 00    	test   $0x2000,%ebp
ffffffff8101b4c6:	74 0c                	je     ffffffff8101b4d4 <_ZN4Utcb8load_vmxEP8Cpu_regs+0x4b8>
        dr7 = Vmcs::read (Vmcs::GUEST_DR7);
ffffffff8101b4c8:	b8 1a 68 00 00       	mov    $0x681a,%eax
ffffffff8101b4cd:	0f 78 83 68 01 00 00 	vmread %rax,0x168(%rbx)

    if (m & Mtd::SYSENTER) {
ffffffff8101b4d4:	f7 c5 00 40 00 00    	test   $0x4000,%ebp
ffffffff8101b4da:	74 20                	je     ffffffff8101b4fc <_ZN4Utcb8load_vmxEP8Cpu_regs+0x4e0>
        sysenter_cs  = Vmcs::read (Vmcs::GUEST_SYSENTER_CS);
ffffffff8101b4dc:	b8 2a 48 00 00       	mov    $0x482a,%eax
ffffffff8101b4e1:	0f 78 83 70 01 00 00 	vmread %rax,0x170(%rbx)
        sysenter_rsp = Vmcs::read (Vmcs::GUEST_SYSENTER_ESP);
ffffffff8101b4e8:	66 b8 24 68          	mov    $0x6824,%ax
ffffffff8101b4ec:	0f 78 83 78 01 00 00 	vmread %rax,0x178(%rbx)
        sysenter_rip = Vmcs::read (Vmcs::GUEST_SYSENTER_EIP);
ffffffff8101b4f3:	b0 26                	mov    $0x26,%al
ffffffff8101b4f5:	0f 78 83 80 01 00 00 	vmread %rax,0x180(%rbx)
    }

    if (m & Mtd::QUAL) {
ffffffff8101b4fc:	f7 c5 00 80 00 00    	test   $0x8000,%ebp
ffffffff8101b502:	74 42                	je     ffffffff8101b546 <_ZN4Utcb8load_vmxEP8Cpu_regs+0x52a>
        if (regs->dst_portal == 48) {
ffffffff8101b504:	49 83 bc 24 a8 00 00 	cmpq   $0x30,0xa8(%r12)
ffffffff8101b50b:	00 30 
ffffffff8101b50d:	75 20                	jne    ffffffff8101b52f <_ZN4Utcb8load_vmxEP8Cpu_regs+0x513>
            qual[0] = regs->nst_error;
ffffffff8101b50f:	49 8b 84 24 b8 00 00 	mov    0xb8(%r12),%rax
ffffffff8101b516:	00 
ffffffff8101b517:	48 89 83 d0 00 00 00 	mov    %rax,0xd0(%rbx)
            qual[1] = regs->nst_fault;
ffffffff8101b51e:	49 8b 84 24 b0 00 00 	mov    0xb0(%r12),%rax
ffffffff8101b525:	00 
ffffffff8101b526:	48 89 83 d8 00 00 00 	mov    %rax,0xd8(%rbx)
ffffffff8101b52d:	eb 17                	jmp    ffffffff8101b546 <_ZN4Utcb8load_vmxEP8Cpu_regs+0x52a>
        } else {
            qual[0] = Vmcs::read (Vmcs::EXI_QUALIFICATION);
ffffffff8101b52f:	b8 00 64 00 00       	mov    $0x6400,%eax
ffffffff8101b534:	0f 78 83 d0 00 00 00 	vmread %rax,0xd0(%rbx)
            qual[1] = Vmcs::read (Vmcs::INFO_PHYS_ADDR);
ffffffff8101b53b:	66 b8 00 24          	mov    $0x2400,%ax
ffffffff8101b53f:	0f 78 83 d8 00 00 00 	vmread %rax,0xd8(%rbx)
        }
    }

    if (m & Mtd::INJ) {
ffffffff8101b546:	f7 c5 00 00 02 00    	test   $0x20000,%ebp
ffffffff8101b54c:	74 3e                	je     ffffffff8101b58c <_ZN4Utcb8load_vmxEP8Cpu_regs+0x570>
        if (regs->dst_portal == 33 || regs->dst_portal == NUM_VMI - 1) {
ffffffff8101b54e:	49 8b 84 24 a8 00 00 	mov    0xa8(%r12),%rax
ffffffff8101b555:	00 
ffffffff8101b556:	48 3d ff 00 00 00    	cmp    $0xff,%rax
ffffffff8101b55c:	74 06                	je     ffffffff8101b564 <_ZN4Utcb8load_vmxEP8Cpu_regs+0x548>
ffffffff8101b55e:	48 83 f8 21          	cmp    $0x21,%rax
ffffffff8101b562:	75 12                	jne    ffffffff8101b576 <_ZN4Utcb8load_vmxEP8Cpu_regs+0x55a>
ffffffff8101b564:	b8 16 40 00 00       	mov    $0x4016,%eax
ffffffff8101b569:	0f 78 c0             	vmread %rax,%rax
            intr_info  = static_cast<uint32>(Vmcs::read (Vmcs::ENT_INTR_INFO));
ffffffff8101b56c:	89 43 48             	mov    %eax,0x48(%rbx)
ffffffff8101b56f:	b8 18 40 00 00       	mov    $0x4018,%eax
ffffffff8101b574:	eb 10                	jmp    ffffffff8101b586 <_ZN4Utcb8load_vmxEP8Cpu_regs+0x56a>
ffffffff8101b576:	b8 08 44 00 00       	mov    $0x4408,%eax
ffffffff8101b57b:	0f 78 c0             	vmread %rax,%rax
            intr_error = static_cast<uint32>(Vmcs::read (Vmcs::ENT_INTR_ERROR));
        } else {
            intr_info  = static_cast<uint32>(Vmcs::read (Vmcs::IDT_VECT_INFO));
ffffffff8101b57e:	89 43 48             	mov    %eax,0x48(%rbx)
ffffffff8101b581:	b8 0a 44 00 00       	mov    $0x440a,%eax
ffffffff8101b586:	0f 78 c0             	vmread %rax,%rax
            intr_error = static_cast<uint32>(Vmcs::read (Vmcs::IDT_VECT_ERROR));
ffffffff8101b589:	89 43 4c             	mov    %eax,0x4c(%rbx)
        }
    }

    if (m & Mtd::STA) {
ffffffff8101b58c:	f7 c5 00 00 04 00    	test   $0x40000,%ebp
ffffffff8101b592:	74 16                	je     ffffffff8101b5aa <_ZN4Utcb8load_vmxEP8Cpu_regs+0x58e>
ffffffff8101b594:	b8 24 48 00 00       	mov    $0x4824,%eax
ffffffff8101b599:	0f 78 c0             	vmread %rax,%rax
        intr_state = static_cast<uint32>(Vmcs::read (Vmcs::GUEST_INTR_STATE));
ffffffff8101b59c:	89 43 40             	mov    %eax,0x40(%rbx)
ffffffff8101b59f:	b8 26 48 00 00       	mov    $0x4826,%eax
ffffffff8101b5a4:	0f 78 c0             	vmread %rax,%rax
        actv_state = static_cast<uint32>(Vmcs::read (Vmcs::GUEST_ACTV_STATE));
ffffffff8101b5a7:	89 43 44             	mov    %eax,0x44(%rbx)
    }

    if (m & Mtd::TSC) {
ffffffff8101b5aa:	f7 c5 00 00 08 00    	test   $0x80000,%ebp
ffffffff8101b5b0:	74 1f                	je     ffffffff8101b5d1 <_ZN4Utcb8load_vmxEP8Cpu_regs+0x5b5>

ALWAYS_INLINE
static inline uint64 rdtsc()
{
    mword h, l;
    asm volatile ("rdtsc" : "=a" (l), "=d" (h));
ffffffff8101b5b2:	0f 31                	rdtsc  
    return static_cast<uint64>(h) << 32 | l;
ffffffff8101b5b4:	48 c1 e2 20          	shl    $0x20,%rdx
ffffffff8101b5b8:	48 09 d0             	or     %rdx,%rax
ffffffff8101b5bb:	48 89 83 28 02 00 00 	mov    %rax,0x228(%rbx)
        tsc_val = rdtsc();
        tsc_off = regs->tsc_offset;
ffffffff8101b5c2:	49 8b 84 24 e0 00 00 	mov    0xe0(%r12),%rax
ffffffff8101b5c9:	00 
ffffffff8101b5ca:	48 89 83 30 02 00 00 	mov    %rax,0x230(%rbx)
    }

#ifdef __x86_64__
    if (m & Mtd::EFER)
ffffffff8101b5d1:	f7 c5 00 00 10 00    	test   $0x100000,%ebp
ffffffff8101b5d7:	74 0c                	je     ffffffff8101b5e5 <_ZN4Utcb8load_vmxEP8Cpu_regs+0x5c9>
        efer = Vmcs::read (Vmcs::GUEST_EFER);
ffffffff8101b5d9:	b8 06 28 00 00       	mov    $0x2806,%eax
ffffffff8101b5de:	0f 78 83 38 01 00 00 	vmread %rax,0x138(%rbx)

    if (m & Mtd::SYSCALL_SWAPGS) {
ffffffff8101b5e5:	f7 c5 00 00 80 00    	test   $0x800000,%ebp
ffffffff8101b5eb:	74 40                	je     ffffffff8101b62d <_ZN4Utcb8load_vmxEP8Cpu_regs+0x611>
ffffffff8101b5ed:	b8 06 20 00 00       	mov    $0x2006,%eax
ffffffff8101b5f2:	0f 78 c0             	vmread %rax,%rax
        mword guest_msr_area_phys = Vmcs::read(Vmcs::EXI_MSR_ST_ADDR);
        Msr_area *guest_msr_area = reinterpret_cast<Msr_area*>(Buddy::phys_to_ptr(guest_msr_area_phys));
        star = guest_msr_area->ia32_star.msr_data;
ffffffff8101b5f5:	48 8b 90 08 00 c0 80 	mov    -0x7f3ffff8(%rax),%rdx
ffffffff8101b5fc:	48 89 93 40 01 00 00 	mov    %rdx,0x140(%rbx)
        lstar = guest_msr_area->ia32_lstar.msr_data;
ffffffff8101b603:	48 8b 90 18 00 c0 80 	mov    -0x7f3fffe8(%rax),%rdx
ffffffff8101b60a:	48 89 93 48 01 00 00 	mov    %rdx,0x148(%rbx)
        fmask = guest_msr_area->ia32_fmask.msr_data;
ffffffff8101b611:	48 8b 90 28 00 c0 80 	mov    -0x7f3fffd8(%rax),%rdx
ffffffff8101b618:	48 89 93 50 01 00 00 	mov    %rdx,0x150(%rbx)
        kernel_gs_base = guest_msr_area->ia32_kernel_gs_base.msr_data;
ffffffff8101b61f:	48 8b 80 38 00 c0 80 	mov    -0x7f3fffc8(%rax),%rax
ffffffff8101b626:	48 89 83 58 01 00 00 	mov    %rax,0x158(%rbx)
    }

    if (m & Mtd::TPR) {
ffffffff8101b62d:	f7 c5 00 00 00 01    	test   $0x1000000,%ebp
ffffffff8101b633:	74 22                	je     ffffffff8101b657 <_ZN4Utcb8load_vmxEP8Cpu_regs+0x63b>
ffffffff8101b635:	b8 12 20 00 00       	mov    $0x2012,%eax
ffffffff8101b63a:	0f 78 c0             	vmread %rax,%rax
    static inline void destroy(Virtual_apic_page *obj, Quota &quota)
    {
        Buddy::allocator.free (reinterpret_cast<mword>(obj), quota);
    }

    uint32 vtpr() { return *reinterpret_cast<uint32*>(&data[VTPR]); }
ffffffff8101b63d:	8b 80 80 00 c0 80    	mov    -0x7f3fff80(%rax),%eax
        mword virtual_apic_page_phys = Vmcs::read(Vmcs::APIC_VIRT_ADDR);
        Virtual_apic_page *virtual_apic_page =
            reinterpret_cast<Virtual_apic_page*>(Buddy::phys_to_ptr(virtual_apic_page_phys));
        tpr = virtual_apic_page->vtpr();
ffffffff8101b643:	89 83 60 01 00 00    	mov    %eax,0x160(%rbx)

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
ffffffff8101b649:	b8 1c 40 00 00       	mov    $0x401c,%eax
ffffffff8101b64e:	0f 78 c0             	vmread %rax,%rax
        tpr_threshold = static_cast<uint32>(Vmcs::read(Vmcs::TPR_THRESHOLD));
ffffffff8101b651:	89 83 64 01 00 00    	mov    %eax,0x164(%rbx)
    }
#endif

    if (m & Mtd::PDPTE) {
ffffffff8101b657:	f7 c5 00 00 20 00    	test   $0x200000,%ebp
ffffffff8101b65d:	74 27                	je     ffffffff8101b686 <_ZN4Utcb8load_vmxEP8Cpu_regs+0x66a>
        pdpte[0] = Vmcs::read (Vmcs::GUEST_PDPTE0);
ffffffff8101b65f:	b8 0a 28 00 00       	mov    $0x280a,%eax
ffffffff8101b664:	0f 78 83 10 01 00 00 	vmread %rax,0x110(%rbx)
        pdpte[1] = Vmcs::read (Vmcs::GUEST_PDPTE1);
ffffffff8101b66b:	b0 0c                	mov    $0xc,%al
ffffffff8101b66d:	0f 78 83 18 01 00 00 	vmread %rax,0x118(%rbx)
        pdpte[2] = Vmcs::read (Vmcs::GUEST_PDPTE2);
ffffffff8101b674:	b0 0e                	mov    $0xe,%al
ffffffff8101b676:	0f 78 83 20 01 00 00 	vmread %rax,0x120(%rbx)
        pdpte[3] = Vmcs::read (Vmcs::GUEST_PDPTE3);
ffffffff8101b67d:	b0 10                	mov    $0x10,%al
ffffffff8101b67f:	0f 78 83 28 01 00 00 	vmread %rax,0x128(%rbx)

    barrier();
    mtd = m;
    items = sizeof (Utcb_data) / sizeof (mword);

    return m & Mtd::FPU;
ffffffff8101b686:	48 89 e8             	mov    %rbp,%rax
        pdpte[2] = Vmcs::read (Vmcs::GUEST_PDPTE2);
        pdpte[3] = Vmcs::read (Vmcs::GUEST_PDPTE3);
    }

    barrier();
    mtd = m;
ffffffff8101b689:	48 89 6b 20          	mov    %rbp,0x20(%rbx)
    items = sizeof (Utcb_data) / sizeof (mword);
ffffffff8101b68d:	48 c7 03 43 00 00 00 	movq   $0x43,(%rbx)

    return m & Mtd::FPU;
ffffffff8101b694:	48 c1 e8 1f          	shr    $0x1f,%rax
}
ffffffff8101b698:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8101b69c:	5b                   	pop    %rbx

    barrier();
    mtd = m;
    items = sizeof (Utcb_data) / sizeof (mword);

    return m & Mtd::FPU;
ffffffff8101b69d:	83 e0 01             	and    $0x1,%eax
}
ffffffff8101b6a0:	5d                   	pop    %rbp
ffffffff8101b6a1:	41 5c                	pop    %r12
ffffffff8101b6a3:	c3                   	retq   

ffffffff8101b6a4 <_ZN4Utcb8save_vmxEP8Cpu_regs>:

bool Utcb::save_vmx (Cpu_regs *regs)
{
ffffffff8101b6a4:	55                   	push   %rbp
ffffffff8101b6a5:	53                   	push   %rbx
ffffffff8101b6a6:	48 89 f5             	mov    %rsi,%rbp
ffffffff8101b6a9:	48 89 fb             	mov    %rdi,%rbx
ffffffff8101b6ac:	48 83 ec 18          	sub    $0x18,%rsp
    if (mtd & Mtd::GPR_ACDB) {
ffffffff8101b6b0:	f6 47 20 01          	testb  $0x1,0x20(%rdi)
ffffffff8101b6b4:	74 20                	je     ffffffff8101b6d6 <_ZN4Utcb8save_vmxEP8Cpu_regs+0x32>
        regs->REG(ax) = rax;
ffffffff8101b6b6:	48 8b 47 50          	mov    0x50(%rdi),%rax
ffffffff8101b6ba:	48 89 46 78          	mov    %rax,0x78(%rsi)
        regs->REG(cx) = rcx;
ffffffff8101b6be:	48 8b 47 58          	mov    0x58(%rdi),%rax
ffffffff8101b6c2:	48 89 46 70          	mov    %rax,0x70(%rsi)
        regs->REG(dx) = rdx;
ffffffff8101b6c6:	48 8b 47 60          	mov    0x60(%rdi),%rax
ffffffff8101b6ca:	48 89 46 68          	mov    %rax,0x68(%rsi)
        regs->REG(bx) = rbx;
ffffffff8101b6ce:	48 8b 47 68          	mov    0x68(%rdi),%rax
ffffffff8101b6d2:	48 89 46 60          	mov    %rax,0x60(%rsi)
    }

    if (mtd & Mtd::GPR_BSD) {
ffffffff8101b6d6:	f6 43 20 02          	testb  $0x2,0x20(%rbx)
ffffffff8101b6da:	74 1e                	je     ffffffff8101b6fa <_ZN4Utcb8save_vmxEP8Cpu_regs+0x56>
        regs->REG(bp) = rbp;
ffffffff8101b6dc:	48 8b 43 78          	mov    0x78(%rbx),%rax
ffffffff8101b6e0:	48 89 45 50          	mov    %rax,0x50(%rbp)
        regs->REG(si) = rsi;
ffffffff8101b6e4:	48 8b 83 80 00 00 00 	mov    0x80(%rbx),%rax
ffffffff8101b6eb:	48 89 45 48          	mov    %rax,0x48(%rbp)
        regs->REG(di) = rdi;
ffffffff8101b6ef:	48 8b 83 88 00 00 00 	mov    0x88(%rbx),%rax
ffffffff8101b6f6:	48 89 45 40          	mov    %rax,0x40(%rbp)
    }

#ifdef __x86_64__
    if (mtd & Mtd::GPR_R8_R15) {
ffffffff8101b6fa:	f6 43 22 40          	testb  $0x40,0x22(%rbx)
ffffffff8101b6fe:	74 58                	je     ffffffff8101b758 <_ZN4Utcb8save_vmxEP8Cpu_regs+0xb4>
        regs->r8      = r8;
ffffffff8101b700:	48 8b 83 90 00 00 00 	mov    0x90(%rbx),%rax
ffffffff8101b707:	48 89 45 38          	mov    %rax,0x38(%rbp)
        regs->r9      = r9;
ffffffff8101b70b:	48 8b 83 98 00 00 00 	mov    0x98(%rbx),%rax
ffffffff8101b712:	48 89 45 30          	mov    %rax,0x30(%rbp)
        regs->r10     = r10;
ffffffff8101b716:	48 8b 83 a0 00 00 00 	mov    0xa0(%rbx),%rax
ffffffff8101b71d:	48 89 45 28          	mov    %rax,0x28(%rbp)
        regs->r11     = r11;
ffffffff8101b721:	48 8b 83 a8 00 00 00 	mov    0xa8(%rbx),%rax
ffffffff8101b728:	48 89 45 20          	mov    %rax,0x20(%rbp)
        regs->r12     = r12;
ffffffff8101b72c:	48 8b 83 b0 00 00 00 	mov    0xb0(%rbx),%rax
ffffffff8101b733:	48 89 45 18          	mov    %rax,0x18(%rbp)
        regs->r13     = r13;
ffffffff8101b737:	48 8b 83 b8 00 00 00 	mov    0xb8(%rbx),%rax
ffffffff8101b73e:	48 89 45 10          	mov    %rax,0x10(%rbp)
        regs->r14     = r14;
ffffffff8101b742:	48 8b 83 c0 00 00 00 	mov    0xc0(%rbx),%rax
ffffffff8101b749:	48 89 45 08          	mov    %rax,0x8(%rbp)
        regs->r15     = r15;
ffffffff8101b74d:	48 8b 83 c8 00 00 00 	mov    0xc8(%rbx),%rax
ffffffff8101b754:	48 89 45 00          	mov    %rax,0x0(%rbp)
    }
#endif

    regs->vmcs->make_current();
ffffffff8101b758:	48 8b 85 80 00 00 00 	mov    0x80(%rbp),%rax
        Vmcs* clone();

        ALWAYS_INLINE
        inline void make_current()
        {
            if (EXPECT_TRUE (current == this))
ffffffff8101b75f:	48 39 05 ba 38 fe 3e 	cmp    %rax,0x3efe38ba(%rip)        # ffffffffbffff020 <_ZN4Vmcs7currentE>
ffffffff8101b766:	74 44                	je     ffffffff8101b7ac <_ZN4Utcb8save_vmxEP8Cpu_regs+0x108>
                return;

            uint64 phys = Buddy::ptr_to_phys (current = this);
ffffffff8101b768:	48 89 05 b1 38 fe 3e 	mov    %rax,0x3efe38b1(%rip)        # ffffffffbffff020 <_ZN4Vmcs7currentE>
ffffffff8101b76f:	48 2d 00 00 c0 80    	sub    $0xffffffff80c00000,%rax
ffffffff8101b775:	48 89 44 24 08       	mov    %rax,0x8(%rsp)

            bool ret;
            asm volatile ("vmptrld %1; seta %0" : "=q" (ret) : "m" (phys) : "cc");
ffffffff8101b77a:	0f c7 74 24 08       	vmptrld 0x8(%rsp)
ffffffff8101b77f:	0f 97 c0             	seta   %al
            assert (ret);
ffffffff8101b782:	84 c0                	test   %al,%al
ffffffff8101b784:	75 26                	jne    ffffffff8101b7ac <_ZN4Utcb8save_vmxEP8Cpu_regs+0x108>
ffffffff8101b786:	49 c7 c0 60 14 02 81 	mov    $0xffffffff81021460,%r8
ffffffff8101b78d:	b9 9a 01 00 00       	mov    $0x19a,%ecx
ffffffff8101b792:	48 c7 c2 72 db 01 81 	mov    $0xffffffff8101db72,%rdx
ffffffff8101b799:	48 c7 c6 e1 db 01 81 	mov    $0xffffffff8101dbe1,%rsi
ffffffff8101b7a0:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8101b7a7:	e8 a4 67 fe ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

    if (mtd & Mtd::RSP)
ffffffff8101b7ac:	48 8b 43 20          	mov    0x20(%rbx),%rax
ffffffff8101b7b0:	a8 04                	test   $0x4,%al
ffffffff8101b7b2:	74 09                	je     ffffffff8101b7bd <_ZN4Utcb8save_vmxEP8Cpu_regs+0x119>
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
ffffffff8101b7b4:	ba 1c 68 00 00       	mov    $0x681c,%edx
ffffffff8101b7b9:	0f 79 53 70          	vmwrite 0x70(%rbx),%rdx
        Vmcs::write (Vmcs::GUEST_RSP, rsp);

    if (mtd & Mtd::RIP_LEN) {
ffffffff8101b7bd:	a8 08                	test   $0x8,%al
ffffffff8101b7bf:	74 11                	je     ffffffff8101b7d2 <_ZN4Utcb8save_vmxEP8Cpu_regs+0x12e>
ffffffff8101b7c1:	ba 1e 68 00 00       	mov    $0x681e,%edx
ffffffff8101b7c6:	0f 79 53 30          	vmwrite 0x30(%rbx),%rdx
ffffffff8101b7ca:	66 ba 1a 40          	mov    $0x401a,%dx
ffffffff8101b7ce:	0f 79 53 28          	vmwrite 0x28(%rbx),%rdx
        Vmcs::write (Vmcs::GUEST_RIP, rip);
        Vmcs::write (Vmcs::ENT_INST_LEN, inst_len);
    }

    if (mtd & Mtd::RFLAGS)
ffffffff8101b7d2:	a8 10                	test   $0x10,%al
ffffffff8101b7d4:	74 09                	je     ffffffff8101b7df <_ZN4Utcb8save_vmxEP8Cpu_regs+0x13b>
ffffffff8101b7d6:	ba 20 68 00 00       	mov    $0x6820,%edx
ffffffff8101b7db:	0f 79 53 38          	vmwrite 0x38(%rbx),%rdx
        Vmcs::write (Vmcs::GUEST_RFLAGS, rflags);

    if (mtd & Mtd::DS_ES) {
ffffffff8101b7df:	a8 20                	test   $0x20,%al
ffffffff8101b7e1:	0f 84 93 00 00 00    	je     ffffffff8101b87a <_ZN4Utcb8save_vmxEP8Cpu_regs+0x1d6>
        Vmcs::write (Vmcs::GUEST_SEL_DS,   ds.sel);
ffffffff8101b7e7:	0f b7 93 b8 01 00 00 	movzwl 0x1b8(%rbx),%edx
ffffffff8101b7ee:	b9 06 08 00 00       	mov    $0x806,%ecx
ffffffff8101b7f3:	0f 79 ca             	vmwrite %rdx,%rcx
ffffffff8101b7f6:	ba 0c 68 00 00       	mov    $0x680c,%edx
ffffffff8101b7fb:	0f 79 93 c0 01 00 00 	vmwrite 0x1c0(%rbx),%rdx
        Vmcs::write (Vmcs::GUEST_BASE_DS,  static_cast<mword>(ds.base));
        Vmcs::write (Vmcs::GUEST_LIMIT_DS, ds.limit);
ffffffff8101b802:	8b 93 bc 01 00 00    	mov    0x1bc(%rbx),%edx
ffffffff8101b808:	66 b9 06 48          	mov    $0x4806,%cx
ffffffff8101b80c:	0f 79 ca             	vmwrite %rdx,%rcx
        Vmcs::write (Vmcs::GUEST_AR_DS,   (ds.ar << 4 & 0x1f000) | (ds.ar & 0xff));
ffffffff8101b80f:	66 8b 93 ba 01 00 00 	mov    0x1ba(%rbx),%dx
ffffffff8101b816:	89 d6                	mov    %edx,%esi
ffffffff8101b818:	0f b6 ca             	movzbl %dl,%ecx
ffffffff8101b81b:	c1 e6 04             	shl    $0x4,%esi
ffffffff8101b81e:	81 e6 00 f0 01 00    	and    $0x1f000,%esi
ffffffff8101b824:	09 ce                	or     %ecx,%esi
ffffffff8101b826:	b9 1a 48 00 00       	mov    $0x481a,%ecx
ffffffff8101b82b:	48 63 d6             	movslq %esi,%rdx
ffffffff8101b82e:	0f 79 ca             	vmwrite %rdx,%rcx
        Vmcs::write (Vmcs::GUEST_SEL_ES,   es.sel);
ffffffff8101b831:	0f b7 93 88 01 00 00 	movzwl 0x188(%rbx),%edx
ffffffff8101b838:	66 b9 00 08          	mov    $0x800,%cx
ffffffff8101b83c:	0f 79 ca             	vmwrite %rdx,%rcx
ffffffff8101b83f:	ba 06 68 00 00       	mov    $0x6806,%edx
ffffffff8101b844:	0f 79 93 90 01 00 00 	vmwrite 0x190(%rbx),%rdx
        Vmcs::write (Vmcs::GUEST_BASE_ES,  static_cast<mword>(es.base));
        Vmcs::write (Vmcs::GUEST_LIMIT_ES, es.limit);
ffffffff8101b84b:	8b 93 8c 01 00 00    	mov    0x18c(%rbx),%edx
ffffffff8101b851:	66 b9 00 48          	mov    $0x4800,%cx
ffffffff8101b855:	0f 79 ca             	vmwrite %rdx,%rcx
        Vmcs::write (Vmcs::GUEST_AR_ES,   (es.ar << 4 & 0x1f000) | (es.ar & 0xff));
ffffffff8101b858:	66 8b 93 8a 01 00 00 	mov    0x18a(%rbx),%dx
ffffffff8101b85f:	89 d6                	mov    %edx,%esi
ffffffff8101b861:	0f b6 ca             	movzbl %dl,%ecx
ffffffff8101b864:	c1 e6 04             	shl    $0x4,%esi
ffffffff8101b867:	81 e6 00 f0 01 00    	and    $0x1f000,%esi
ffffffff8101b86d:	09 ce                	or     %ecx,%esi
ffffffff8101b86f:	b9 14 48 00 00       	mov    $0x4814,%ecx
ffffffff8101b874:	48 63 d6             	movslq %esi,%rdx
ffffffff8101b877:	0f 79 ca             	vmwrite %rdx,%rcx
    }

    if (mtd & Mtd::FS_GS) {
ffffffff8101b87a:	a8 40                	test   $0x40,%al
ffffffff8101b87c:	0f 84 93 00 00 00    	je     ffffffff8101b915 <_ZN4Utcb8save_vmxEP8Cpu_regs+0x271>
        Vmcs::write (Vmcs::GUEST_SEL_FS,   fs.sel);
ffffffff8101b882:	0f b7 93 c8 01 00 00 	movzwl 0x1c8(%rbx),%edx
ffffffff8101b889:	b9 08 08 00 00       	mov    $0x808,%ecx
ffffffff8101b88e:	0f 79 ca             	vmwrite %rdx,%rcx
ffffffff8101b891:	ba 0e 68 00 00       	mov    $0x680e,%edx
ffffffff8101b896:	0f 79 93 d0 01 00 00 	vmwrite 0x1d0(%rbx),%rdx
        Vmcs::write (Vmcs::GUEST_BASE_FS,  static_cast<mword>(fs.base));
        Vmcs::write (Vmcs::GUEST_LIMIT_FS, fs.limit);
ffffffff8101b89d:	8b 93 cc 01 00 00    	mov    0x1cc(%rbx),%edx
ffffffff8101b8a3:	66 b9 08 48          	mov    $0x4808,%cx
ffffffff8101b8a7:	0f 79 ca             	vmwrite %rdx,%rcx
        Vmcs::write (Vmcs::GUEST_AR_FS,   (fs.ar << 4 & 0x1f000) | (fs.ar & 0xff));
ffffffff8101b8aa:	66 8b 93 ca 01 00 00 	mov    0x1ca(%rbx),%dx
ffffffff8101b8b1:	89 d6                	mov    %edx,%esi
ffffffff8101b8b3:	0f b6 ca             	movzbl %dl,%ecx
ffffffff8101b8b6:	c1 e6 04             	shl    $0x4,%esi
ffffffff8101b8b9:	81 e6 00 f0 01 00    	and    $0x1f000,%esi
ffffffff8101b8bf:	09 ce                	or     %ecx,%esi
ffffffff8101b8c1:	b9 1c 48 00 00       	mov    $0x481c,%ecx
ffffffff8101b8c6:	48 63 d6             	movslq %esi,%rdx
ffffffff8101b8c9:	0f 79 ca             	vmwrite %rdx,%rcx
        Vmcs::write (Vmcs::GUEST_SEL_GS,   gs.sel);
ffffffff8101b8cc:	0f b7 93 d8 01 00 00 	movzwl 0x1d8(%rbx),%edx
ffffffff8101b8d3:	66 b9 0a 08          	mov    $0x80a,%cx
ffffffff8101b8d7:	0f 79 ca             	vmwrite %rdx,%rcx
ffffffff8101b8da:	ba 10 68 00 00       	mov    $0x6810,%edx
ffffffff8101b8df:	0f 79 93 e0 01 00 00 	vmwrite 0x1e0(%rbx),%rdx
        Vmcs::write (Vmcs::GUEST_BASE_GS,  static_cast<mword>(gs.base));
        Vmcs::write (Vmcs::GUEST_LIMIT_GS, gs.limit);
ffffffff8101b8e6:	8b 93 dc 01 00 00    	mov    0x1dc(%rbx),%edx
ffffffff8101b8ec:	66 b9 0a 48          	mov    $0x480a,%cx
ffffffff8101b8f0:	0f 79 ca             	vmwrite %rdx,%rcx
        Vmcs::write (Vmcs::GUEST_AR_GS,   (gs.ar << 4 & 0x1f000) | (gs.ar & 0xff));
ffffffff8101b8f3:	66 8b 93 da 01 00 00 	mov    0x1da(%rbx),%dx
ffffffff8101b8fa:	89 d6                	mov    %edx,%esi
ffffffff8101b8fc:	0f b6 ca             	movzbl %dl,%ecx
ffffffff8101b8ff:	c1 e6 04             	shl    $0x4,%esi
ffffffff8101b902:	81 e6 00 f0 01 00    	and    $0x1f000,%esi
ffffffff8101b908:	09 ce                	or     %ecx,%esi
ffffffff8101b90a:	b9 1e 48 00 00       	mov    $0x481e,%ecx
ffffffff8101b90f:	48 63 d6             	movslq %esi,%rdx
ffffffff8101b912:	0f 79 ca             	vmwrite %rdx,%rcx
    }

    if (mtd & Mtd::CS_SS) {
ffffffff8101b915:	a8 80                	test   $0x80,%al
ffffffff8101b917:	0f 84 93 00 00 00    	je     ffffffff8101b9b0 <_ZN4Utcb8save_vmxEP8Cpu_regs+0x30c>
        Vmcs::write (Vmcs::GUEST_SEL_CS,   cs.sel);
ffffffff8101b91d:	0f b7 93 98 01 00 00 	movzwl 0x198(%rbx),%edx
ffffffff8101b924:	b9 02 08 00 00       	mov    $0x802,%ecx
ffffffff8101b929:	0f 79 ca             	vmwrite %rdx,%rcx
ffffffff8101b92c:	ba 08 68 00 00       	mov    $0x6808,%edx
ffffffff8101b931:	0f 79 93 a0 01 00 00 	vmwrite 0x1a0(%rbx),%rdx
        Vmcs::write (Vmcs::GUEST_BASE_CS,  static_cast<mword>(cs.base));
        Vmcs::write (Vmcs::GUEST_LIMIT_CS, cs.limit);
ffffffff8101b938:	8b 93 9c 01 00 00    	mov    0x19c(%rbx),%edx
ffffffff8101b93e:	66 b9 02 48          	mov    $0x4802,%cx
ffffffff8101b942:	0f 79 ca             	vmwrite %rdx,%rcx
        Vmcs::write (Vmcs::GUEST_AR_CS,   (cs.ar << 4 & 0x1f000) | (cs.ar & 0xff));
ffffffff8101b945:	66 8b 93 9a 01 00 00 	mov    0x19a(%rbx),%dx
ffffffff8101b94c:	89 d6                	mov    %edx,%esi
ffffffff8101b94e:	0f b6 ca             	movzbl %dl,%ecx
ffffffff8101b951:	c1 e6 04             	shl    $0x4,%esi
ffffffff8101b954:	81 e6 00 f0 01 00    	and    $0x1f000,%esi
ffffffff8101b95a:	09 ce                	or     %ecx,%esi
ffffffff8101b95c:	b9 16 48 00 00       	mov    $0x4816,%ecx
ffffffff8101b961:	48 63 d6             	movslq %esi,%rdx
ffffffff8101b964:	0f 79 ca             	vmwrite %rdx,%rcx
        Vmcs::write (Vmcs::GUEST_SEL_SS,   ss.sel);
ffffffff8101b967:	0f b7 93 a8 01 00 00 	movzwl 0x1a8(%rbx),%edx
ffffffff8101b96e:	66 b9 04 08          	mov    $0x804,%cx
ffffffff8101b972:	0f 79 ca             	vmwrite %rdx,%rcx
ffffffff8101b975:	ba 0a 68 00 00       	mov    $0x680a,%edx
ffffffff8101b97a:	0f 79 93 b0 01 00 00 	vmwrite 0x1b0(%rbx),%rdx
        Vmcs::write (Vmcs::GUEST_BASE_SS,  static_cast<mword>(ss.base));
        Vmcs::write (Vmcs::GUEST_LIMIT_SS, ss.limit);
ffffffff8101b981:	8b 93 ac 01 00 00    	mov    0x1ac(%rbx),%edx
ffffffff8101b987:	66 b9 04 48          	mov    $0x4804,%cx
ffffffff8101b98b:	0f 79 ca             	vmwrite %rdx,%rcx
        Vmcs::write (Vmcs::GUEST_AR_SS,   (ss.ar << 4 & 0x1f000) | (ss.ar & 0xff));
ffffffff8101b98e:	66 8b 93 aa 01 00 00 	mov    0x1aa(%rbx),%dx
ffffffff8101b995:	89 d6                	mov    %edx,%esi
ffffffff8101b997:	0f b6 ca             	movzbl %dl,%ecx
ffffffff8101b99a:	c1 e6 04             	shl    $0x4,%esi
ffffffff8101b99d:	81 e6 00 f0 01 00    	and    $0x1f000,%esi
ffffffff8101b9a3:	09 ce                	or     %ecx,%esi
ffffffff8101b9a5:	b9 18 48 00 00       	mov    $0x4818,%ecx
ffffffff8101b9aa:	48 63 d6             	movslq %esi,%rdx
ffffffff8101b9ad:	0f 79 ca             	vmwrite %rdx,%rcx
    }

    if (mtd & Mtd::TR) {
ffffffff8101b9b0:	f6 c4 01             	test   $0x1,%ah
ffffffff8101b9b3:	74 4a                	je     ffffffff8101b9ff <_ZN4Utcb8save_vmxEP8Cpu_regs+0x35b>
        Vmcs::write (Vmcs::GUEST_SEL_TR,     tr.sel);
ffffffff8101b9b5:	0f b7 93 f8 01 00 00 	movzwl 0x1f8(%rbx),%edx
ffffffff8101b9bc:	b9 0e 08 00 00       	mov    $0x80e,%ecx
ffffffff8101b9c1:	0f 79 ca             	vmwrite %rdx,%rcx
ffffffff8101b9c4:	ba 14 68 00 00       	mov    $0x6814,%edx
ffffffff8101b9c9:	0f 79 93 00 02 00 00 	vmwrite 0x200(%rbx),%rdx
        Vmcs::write (Vmcs::GUEST_BASE_TR,    static_cast<mword>(tr.base));
        Vmcs::write (Vmcs::GUEST_LIMIT_TR,   tr.limit);
ffffffff8101b9d0:	8b 93 fc 01 00 00    	mov    0x1fc(%rbx),%edx
ffffffff8101b9d6:	66 b9 0e 48          	mov    $0x480e,%cx
ffffffff8101b9da:	0f 79 ca             	vmwrite %rdx,%rcx
        Vmcs::write (Vmcs::GUEST_AR_TR,     (tr.ar << 4 & 0x1f000) | (tr.ar & 0xff));
ffffffff8101b9dd:	66 8b 93 fa 01 00 00 	mov    0x1fa(%rbx),%dx
ffffffff8101b9e4:	89 d6                	mov    %edx,%esi
ffffffff8101b9e6:	0f b6 ca             	movzbl %dl,%ecx
ffffffff8101b9e9:	c1 e6 04             	shl    $0x4,%esi
ffffffff8101b9ec:	81 e6 00 f0 01 00    	and    $0x1f000,%esi
ffffffff8101b9f2:	09 ce                	or     %ecx,%esi
ffffffff8101b9f4:	b9 22 48 00 00       	mov    $0x4822,%ecx
ffffffff8101b9f9:	48 63 d6             	movslq %esi,%rdx
ffffffff8101b9fc:	0f 79 ca             	vmwrite %rdx,%rcx
    }

    if (mtd & Mtd::LDTR) {
ffffffff8101b9ff:	f6 c4 02             	test   $0x2,%ah
ffffffff8101ba02:	74 4a                	je     ffffffff8101ba4e <_ZN4Utcb8save_vmxEP8Cpu_regs+0x3aa>
        Vmcs::write (Vmcs::GUEST_SEL_LDTR,   ld.sel);
ffffffff8101ba04:	0f b7 93 e8 01 00 00 	movzwl 0x1e8(%rbx),%edx
ffffffff8101ba0b:	b9 0c 08 00 00       	mov    $0x80c,%ecx
ffffffff8101ba10:	0f 79 ca             	vmwrite %rdx,%rcx
ffffffff8101ba13:	ba 12 68 00 00       	mov    $0x6812,%edx
ffffffff8101ba18:	0f 79 93 f0 01 00 00 	vmwrite 0x1f0(%rbx),%rdx
        Vmcs::write (Vmcs::GUEST_BASE_LDTR,  static_cast<mword>(ld.base));
        Vmcs::write (Vmcs::GUEST_LIMIT_LDTR, ld.limit);
ffffffff8101ba1f:	8b 93 ec 01 00 00    	mov    0x1ec(%rbx),%edx
ffffffff8101ba25:	66 b9 0c 48          	mov    $0x480c,%cx
ffffffff8101ba29:	0f 79 ca             	vmwrite %rdx,%rcx
        Vmcs::write (Vmcs::GUEST_AR_LDTR,   (ld.ar << 4 & 0x1f000) | (ld.ar & 0xff));
ffffffff8101ba2c:	66 8b 93 ea 01 00 00 	mov    0x1ea(%rbx),%dx
ffffffff8101ba33:	89 d6                	mov    %edx,%esi
ffffffff8101ba35:	0f b6 ca             	movzbl %dl,%ecx
ffffffff8101ba38:	c1 e6 04             	shl    $0x4,%esi
ffffffff8101ba3b:	81 e6 00 f0 01 00    	and    $0x1f000,%esi
ffffffff8101ba41:	09 ce                	or     %ecx,%esi
ffffffff8101ba43:	b9 20 48 00 00       	mov    $0x4820,%ecx
ffffffff8101ba48:	48 63 d6             	movslq %esi,%rdx
ffffffff8101ba4b:	0f 79 ca             	vmwrite %rdx,%rcx
    }

    if (mtd & Mtd::GDTR) {
ffffffff8101ba4e:	f6 c4 04             	test   $0x4,%ah
ffffffff8101ba51:	74 1a                	je     ffffffff8101ba6d <_ZN4Utcb8save_vmxEP8Cpu_regs+0x3c9>
ffffffff8101ba53:	ba 16 68 00 00       	mov    $0x6816,%edx
ffffffff8101ba58:	0f 79 93 10 02 00 00 	vmwrite 0x210(%rbx),%rdx
ffffffff8101ba5f:	b9 10 48 00 00       	mov    $0x4810,%ecx
        Vmcs::write (Vmcs::GUEST_BASE_GDTR,  static_cast<mword>(gd.base));
        Vmcs::write (Vmcs::GUEST_LIMIT_GDTR, gd.limit);
ffffffff8101ba64:	8b 93 0c 02 00 00    	mov    0x20c(%rbx),%edx
ffffffff8101ba6a:	0f 79 ca             	vmwrite %rdx,%rcx
    }

    if (mtd & Mtd::IDTR) {
ffffffff8101ba6d:	f6 c4 08             	test   $0x8,%ah
ffffffff8101ba70:	74 1a                	je     ffffffff8101ba8c <_ZN4Utcb8save_vmxEP8Cpu_regs+0x3e8>
ffffffff8101ba72:	ba 18 68 00 00       	mov    $0x6818,%edx
ffffffff8101ba77:	0f 79 93 20 02 00 00 	vmwrite 0x220(%rbx),%rdx
ffffffff8101ba7e:	b9 12 48 00 00       	mov    $0x4812,%ecx
        Vmcs::write (Vmcs::GUEST_BASE_IDTR,  static_cast<mword>(id.base));
        Vmcs::write (Vmcs::GUEST_LIMIT_IDTR, id.limit);
ffffffff8101ba83:	8b 93 1c 02 00 00    	mov    0x21c(%rbx),%edx
ffffffff8101ba89:	0f 79 ca             	vmwrite %rdx,%rcx
    }

    if (mtd & Mtd::CR) {
ffffffff8101ba8c:	f6 c4 10             	test   $0x10,%ah
ffffffff8101ba8f:	74 4d                	je     ffffffff8101bade <_ZN4Utcb8save_vmxEP8Cpu_regs+0x43a>
        regs->write_cr<Vmcs> (0, cr0);
ffffffff8101ba91:	48 8b 93 f0 00 00 00 	mov    0xf0(%rbx),%rdx
ffffffff8101ba98:	31 f6                	xor    %esi,%esi
ffffffff8101ba9a:	48 89 ef             	mov    %rbp,%rdi
ffffffff8101ba9d:	e8 06 88 ff ff       	callq  ffffffff810142a8 <_ZN8Exc_regs8write_crI4VmcsEEvjm>
        regs->write_cr<Vmcs> (2, cr2);
ffffffff8101baa2:	48 8b 93 f8 00 00 00 	mov    0xf8(%rbx),%rdx
ffffffff8101baa9:	be 02 00 00 00       	mov    $0x2,%esi
ffffffff8101baae:	48 89 ef             	mov    %rbp,%rdi
ffffffff8101bab1:	e8 f2 87 ff ff       	callq  ffffffff810142a8 <_ZN8Exc_regs8write_crI4VmcsEEvjm>
        regs->write_cr<Vmcs> (3, cr3);
ffffffff8101bab6:	48 8b 93 00 01 00 00 	mov    0x100(%rbx),%rdx
ffffffff8101babd:	be 03 00 00 00       	mov    $0x3,%esi
ffffffff8101bac2:	48 89 ef             	mov    %rbp,%rdi
ffffffff8101bac5:	e8 de 87 ff ff       	callq  ffffffff810142a8 <_ZN8Exc_regs8write_crI4VmcsEEvjm>
        regs->write_cr<Vmcs> (4, cr4);
ffffffff8101baca:	48 8b 93 08 01 00 00 	mov    0x108(%rbx),%rdx
ffffffff8101bad1:	be 04 00 00 00       	mov    $0x4,%esi
ffffffff8101bad6:	48 89 ef             	mov    %rbp,%rdi
ffffffff8101bad9:	e8 ca 87 ff ff       	callq  ffffffff810142a8 <_ZN8Exc_regs8write_crI4VmcsEEvjm>
    }

    if (mtd & Mtd::DR)
ffffffff8101bade:	48 8b 43 20          	mov    0x20(%rbx),%rax
ffffffff8101bae2:	f6 c4 20             	test   $0x20,%ah
ffffffff8101bae5:	74 0c                	je     ffffffff8101baf3 <_ZN4Utcb8save_vmxEP8Cpu_regs+0x44f>
ffffffff8101bae7:	ba 1a 68 00 00       	mov    $0x681a,%edx
ffffffff8101baec:	0f 79 93 68 01 00 00 	vmwrite 0x168(%rbx),%rdx
        Vmcs::write (Vmcs::GUEST_DR7, dr7);

    if (mtd & Mtd::SYSENTER) {
ffffffff8101baf3:	f6 c4 40             	test   $0x40,%ah
ffffffff8101baf6:	74 20                	je     ffffffff8101bb18 <_ZN4Utcb8save_vmxEP8Cpu_regs+0x474>
ffffffff8101baf8:	ba 2a 48 00 00       	mov    $0x482a,%edx
ffffffff8101bafd:	0f 79 93 70 01 00 00 	vmwrite 0x170(%rbx),%rdx
ffffffff8101bb04:	66 ba 24 68          	mov    $0x6824,%dx
ffffffff8101bb08:	0f 79 93 78 01 00 00 	vmwrite 0x178(%rbx),%rdx
ffffffff8101bb0f:	b2 26                	mov    $0x26,%dl
ffffffff8101bb11:	0f 79 93 80 01 00 00 	vmwrite 0x180(%rbx),%rdx
        Vmcs::write (Vmcs::GUEST_SYSENTER_CS,  sysenter_cs);
        Vmcs::write (Vmcs::GUEST_SYSENTER_ESP, sysenter_rsp);
        Vmcs::write (Vmcs::GUEST_SYSENTER_EIP, sysenter_rip);
    }

    if (mtd & Mtd::CTRL) {
ffffffff8101bb18:	a9 00 00 01 00       	test   $0x10000,%eax
ffffffff8101bb1d:	74 1c                	je     ffffffff8101bb3b <_ZN4Utcb8save_vmxEP8Cpu_regs+0x497>
        regs->vmx_set_cpu_ctrl0 (ctrl[0]);
ffffffff8101bb1f:	8b b3 e0 00 00 00    	mov    0xe0(%rbx),%esi
ffffffff8101bb25:	48 89 ef             	mov    %rbp,%rdi
ffffffff8101bb28:	e8 85 78 ff ff       	callq  ffffffff810133b2 <_ZN8Exc_regs17vmx_set_cpu_ctrl0Em>
        regs->vmx_set_cpu_ctrl1 (ctrl[1]);
ffffffff8101bb2d:	8b b3 e4 00 00 00    	mov    0xe4(%rbx),%esi
ffffffff8101bb33:	48 89 ef             	mov    %rbp,%rdi
ffffffff8101bb36:	e8 ab 78 ff ff       	callq  ffffffff810133e6 <_ZN8Exc_regs17vmx_set_cpu_ctrl1Em>
    }

    if (mtd & Mtd::INJ) {
ffffffff8101bb3b:	f6 43 22 02          	testb  $0x2,0x22(%rbx)
ffffffff8101bb3f:	74 4f                	je     ffffffff8101bb90 <_ZN4Utcb8save_vmxEP8Cpu_regs+0x4ec>

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
ffffffff8101bb41:	b8 02 40 00 00       	mov    $0x4002,%eax
ffffffff8101bb46:	0f 78 c0             	vmread %rax,%rax

        uint32 val = static_cast<uint32>(Vmcs::read (Vmcs::CPU_EXEC_CTRL0));

        if (intr_info & 0x1000)
ffffffff8101bb49:	8b 4b 48             	mov    0x48(%rbx),%ecx
            val |=  Vmcs::CPU_INTR_WINDOW;
        else
            val &= ~Vmcs::CPU_INTR_WINDOW;
ffffffff8101bb4c:	89 c2                	mov    %eax,%edx
ffffffff8101bb4e:	83 e2 fb             	and    $0xfffffffb,%edx

    if (mtd & Mtd::INJ) {

        uint32 val = static_cast<uint32>(Vmcs::read (Vmcs::CPU_EXEC_CTRL0));

        if (intr_info & 0x1000)
ffffffff8101bb51:	f6 c5 10             	test   $0x10,%ch
ffffffff8101bb54:	74 05                	je     ffffffff8101bb5b <_ZN4Utcb8save_vmxEP8Cpu_regs+0x4b7>
            val |=  Vmcs::CPU_INTR_WINDOW;
ffffffff8101bb56:	89 c2                	mov    %eax,%edx
ffffffff8101bb58:	83 ca 04             	or     $0x4,%edx
            val &= ~Vmcs::CPU_INTR_WINDOW;

        if (intr_info & 0x2000)
            val |=  Vmcs::CPU_NMI_WINDOW;
        else
            val &= ~Vmcs::CPU_NMI_WINDOW;
ffffffff8101bb5b:	89 d6                	mov    %edx,%esi
ffffffff8101bb5d:	81 e6 ff ff bf ff    	and    $0xffbfffff,%esi
        if (intr_info & 0x1000)
            val |=  Vmcs::CPU_INTR_WINDOW;
        else
            val &= ~Vmcs::CPU_INTR_WINDOW;

        if (intr_info & 0x2000)
ffffffff8101bb63:	80 e5 20             	and    $0x20,%ch
ffffffff8101bb66:	74 08                	je     ffffffff8101bb70 <_ZN4Utcb8save_vmxEP8Cpu_regs+0x4cc>
            val |=  Vmcs::CPU_NMI_WINDOW;
ffffffff8101bb68:	89 d6                	mov    %edx,%esi
ffffffff8101bb6a:	81 ce 00 00 40 00    	or     $0x400000,%esi
        else
            val &= ~Vmcs::CPU_NMI_WINDOW;

        regs->vmx_set_cpu_ctrl0 (val);
ffffffff8101bb70:	48 89 ef             	mov    %rbp,%rdi
ffffffff8101bb73:	e8 3a 78 ff ff       	callq  ffffffff810133b2 <_ZN8Exc_regs17vmx_set_cpu_ctrl0Em>

        Vmcs::write (Vmcs::ENT_INTR_INFO,  intr_info & ~0x3000);
ffffffff8101bb78:	8b 43 48             	mov    0x48(%rbx),%eax
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
ffffffff8101bb7b:	ba 16 40 00 00       	mov    $0x4016,%edx
ffffffff8101bb80:	25 ff cf ff ff       	and    $0xffffcfff,%eax
ffffffff8101bb85:	0f 79 d0             	vmwrite %rax,%rdx
        Vmcs::write (Vmcs::ENT_INTR_ERROR, intr_error);
ffffffff8101bb88:	8b 43 4c             	mov    0x4c(%rbx),%eax
ffffffff8101bb8b:	b2 18                	mov    $0x18,%dl
ffffffff8101bb8d:	0f 79 d0             	vmwrite %rax,%rdx
    }

    if (mtd & Mtd::STA) {
ffffffff8101bb90:	48 8b 43 20          	mov    0x20(%rbx),%rax
ffffffff8101bb94:	a9 00 00 04 00       	test   $0x40000,%eax
ffffffff8101bb99:	74 13                	je     ffffffff8101bbae <_ZN4Utcb8save_vmxEP8Cpu_regs+0x50a>
        Vmcs::write (Vmcs::GUEST_INTR_STATE, intr_state);
ffffffff8101bb9b:	8b 53 40             	mov    0x40(%rbx),%edx
ffffffff8101bb9e:	b9 24 48 00 00       	mov    $0x4824,%ecx
ffffffff8101bba3:	0f 79 ca             	vmwrite %rdx,%rcx
        Vmcs::write (Vmcs::GUEST_ACTV_STATE, actv_state);
ffffffff8101bba6:	8b 53 44             	mov    0x44(%rbx),%edx
ffffffff8101bba9:	b1 26                	mov    $0x26,%cl
ffffffff8101bbab:	0f 79 ca             	vmwrite %rdx,%rcx
    }

    if (mtd & Mtd::TSC)
ffffffff8101bbae:	a9 00 00 08 00       	test   $0x80000,%eax
ffffffff8101bbb3:	74 1a                	je     ffffffff8101bbcf <_ZN4Utcb8save_vmxEP8Cpu_regs+0x52b>
        inline void clr_hazard (mword h) { Atomic::clr_mask (hzd, h); }

        ALWAYS_INLINE
        inline void add_tsc_offset (uint64 tsc)
        {
            tsc_offset += tsc;
ffffffff8101bbb5:	48 8b 83 30 02 00 00 	mov    0x230(%rbx),%rax
ffffffff8101bbbc:	48 01 85 e0 00 00 00 	add    %rax,0xe0(%rbp)

        template <typename T>
        ALWAYS_INLINE
        static inline void set_mask (T &ptr, T v) { __sync_or_and_fetch (&ptr, v); }
ffffffff8101bbc3:	f0 48 81 8d d8 00 00 	lock orq $0x20000000,0xd8(%rbp)
ffffffff8101bbca:	00 00 00 00 20 
        regs->add_tsc_offset (tsc_off);

#ifdef __x86_64__
    if (mtd & Mtd::EFER)
ffffffff8101bbcf:	f6 43 22 10          	testb  $0x10,0x22(%rbx)
ffffffff8101bbd3:	74 0f                	je     ffffffff8101bbe4 <_ZN4Utcb8save_vmxEP8Cpu_regs+0x540>
        regs->write_efer<Vmcs> (efer);
ffffffff8101bbd5:	48 8b b3 38 01 00 00 	mov    0x138(%rbx),%rsi
ffffffff8101bbdc:	48 89 ef             	mov    %rbp,%rdi
ffffffff8101bbdf:	e8 20 82 ff ff       	callq  ffffffff81013e04 <_ZN8Exc_regs10write_eferI4VmcsEEvm>

        ALWAYS_INLINE
        static inline mword read (Encoding enc)
        {
            mword val;
            asm volatile ("vmread %1, %0" : "=rm" (val) : "r" (static_cast<mword>(enc)) : "cc");
ffffffff8101bbe4:	be 08 20 00 00       	mov    $0x2008,%esi
ffffffff8101bbe9:	0f 78 f6             	vmread %rsi,%rsi
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
ffffffff8101bbec:	b9 81 00 00 c0       	mov    $0xc0000081,%ecx
        }

        ALWAYS_INLINE
        inline mword phys_to_virt (mword phys)
        {
            return phys + reinterpret_cast<mword>(&OFFSET);
ffffffff8101bbf1:	48 81 c6 00 00 c0 80 	add    $0xffffffff80c00000,%rsi
ffffffff8101bbf8:	0f 32                	rdmsr  
            return static_cast<T>(static_cast<uint64>(h) << 32 | l);
ffffffff8101bbfa:	48 89 d1             	mov    %rdx,%rcx
ffffffff8101bbfd:	48 c1 e1 20          	shl    $0x20,%rcx
ffffffff8101bc01:	48 09 c1             	or     %rax,%rcx
ffffffff8101bc04:	48 89 4e 08          	mov    %rcx,0x8(%rsi)
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
ffffffff8101bc08:	b9 82 00 00 c0       	mov    $0xc0000082,%ecx
ffffffff8101bc0d:	0f 32                	rdmsr  
            return static_cast<T>(static_cast<uint64>(h) << 32 | l);
ffffffff8101bc0f:	48 89 d1             	mov    %rdx,%rcx
ffffffff8101bc12:	48 c1 e1 20          	shl    $0x20,%rcx
ffffffff8101bc16:	48 09 c1             	or     %rax,%rcx
ffffffff8101bc19:	48 89 4e 18          	mov    %rcx,0x18(%rsi)
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
ffffffff8101bc1d:	b9 84 00 00 c0       	mov    $0xc0000084,%ecx
ffffffff8101bc22:	0f 32                	rdmsr  
            return static_cast<T>(static_cast<uint64>(h) << 32 | l);
ffffffff8101bc24:	48 89 d1             	mov    %rdx,%rcx
ffffffff8101bc27:	48 c1 e1 20          	shl    $0x20,%rcx
ffffffff8101bc2b:	48 09 c1             	or     %rax,%rcx
ffffffff8101bc2e:	48 89 4e 28          	mov    %rcx,0x28(%rsi)
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
ffffffff8101bc32:	b9 02 01 00 c0       	mov    $0xc0000102,%ecx
ffffffff8101bc37:	0f 32                	rdmsr  
            return static_cast<T>(static_cast<uint64>(h) << 32 | l);
ffffffff8101bc39:	48 89 d1             	mov    %rdx,%rcx
ffffffff8101bc3c:	48 c1 e1 20          	shl    $0x20,%rcx
ffffffff8101bc40:	48 09 c1             	or     %rax,%rcx
ffffffff8101bc43:	48 89 4e 38          	mov    %rcx,0x38(%rsi)
    host_msr_area->ia32_star.msr_data = Msr::read<uint64>(Msr::IA32_STAR);
    host_msr_area->ia32_lstar.msr_data = Msr::read<uint64>(Msr::IA32_LSTAR);
    host_msr_area->ia32_fmask.msr_data = Msr::read<uint64>(Msr::IA32_FMASK);
    host_msr_area->ia32_kernel_gs_base.msr_data = Msr::read<uint64>(Msr::IA32_KERNEL_GS_BASE);

    if (mtd & Mtd::SYSCALL_SWAPGS) {
ffffffff8101bc47:	f6 43 22 80          	testb  $0x80,0x22(%rbx)
ffffffff8101bc4b:	74 40                	je     ffffffff8101bc8d <_ZN4Utcb8save_vmxEP8Cpu_regs+0x5e9>
ffffffff8101bc4d:	b8 06 20 00 00       	mov    $0x2006,%eax
ffffffff8101bc52:	0f 78 c0             	vmread %rax,%rax
        mword guest_msr_area_phys = Vmcs::read(Vmcs::EXI_MSR_ST_ADDR);
        Msr_area *guest_msr_area = reinterpret_cast<Msr_area*>(Buddy::phys_to_ptr(guest_msr_area_phys));
        guest_msr_area->ia32_star.msr_data = star;
ffffffff8101bc55:	48 8b 93 40 01 00 00 	mov    0x140(%rbx),%rdx
ffffffff8101bc5c:	48 89 90 08 00 c0 80 	mov    %rdx,-0x7f3ffff8(%rax)
        guest_msr_area->ia32_lstar.msr_data = lstar;
ffffffff8101bc63:	48 8b 93 48 01 00 00 	mov    0x148(%rbx),%rdx
ffffffff8101bc6a:	48 89 90 18 00 c0 80 	mov    %rdx,-0x7f3fffe8(%rax)
        guest_msr_area->ia32_fmask.msr_data = fmask;
ffffffff8101bc71:	48 8b 93 50 01 00 00 	mov    0x150(%rbx),%rdx
ffffffff8101bc78:	48 89 90 28 00 c0 80 	mov    %rdx,-0x7f3fffd8(%rax)
        guest_msr_area->ia32_kernel_gs_base.msr_data = kernel_gs_base;
ffffffff8101bc7f:	48 8b 93 58 01 00 00 	mov    0x158(%rbx),%rdx
ffffffff8101bc86:	48 89 90 38 00 c0 80 	mov    %rdx,-0x7f3fffc8(%rax)
    }

    if (mtd & Mtd::TPR) {
ffffffff8101bc8d:	f6 43 23 01          	testb  $0x1,0x23(%rbx)
ffffffff8101bc91:	74 22                	je     ffffffff8101bcb5 <_ZN4Utcb8save_vmxEP8Cpu_regs+0x611>
ffffffff8101bc93:	b8 12 20 00 00       	mov    $0x2012,%eax
ffffffff8101bc98:	0f 78 c0             	vmread %rax,%rax
        mword virtual_apic_page_phys = Vmcs::read(Vmcs::APIC_VIRT_ADDR);
        Virtual_apic_page *virtual_apic_page =
            reinterpret_cast<Virtual_apic_page*>(Buddy::phys_to_ptr(virtual_apic_page_phys));
        virtual_apic_page->vtpr(tpr);
ffffffff8101bc9b:	8b 93 60 01 00 00    	mov    0x160(%rbx),%edx
    {
        Buddy::allocator.free (reinterpret_cast<mword>(obj), quota);
    }

    uint32 vtpr() { return *reinterpret_cast<uint32*>(&data[VTPR]); }
    void vtpr(uint32 value) { *reinterpret_cast<uint32*>(&data[VTPR]) = value; }
ffffffff8101bca1:	89 90 80 00 c0 80    	mov    %edx,-0x7f3fff80(%rax)
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
ffffffff8101bca7:	ba 1c 40 00 00       	mov    $0x401c,%edx
        Vmcs::write(Vmcs::TPR_THRESHOLD, tpr_threshold);
ffffffff8101bcac:	8b 83 64 01 00 00    	mov    0x164(%rbx),%eax
ffffffff8101bcb2:	0f 79 d0             	vmwrite %rax,%rdx
    }
#endif

    if (mtd & Mtd::PDPTE) {
ffffffff8101bcb5:	48 8b 43 20          	mov    0x20(%rbx),%rax
ffffffff8101bcb9:	a9 00 00 20 00       	test   $0x200000,%eax
ffffffff8101bcbe:	74 27                	je     ffffffff8101bce7 <_ZN4Utcb8save_vmxEP8Cpu_regs+0x643>
ffffffff8101bcc0:	ba 0a 28 00 00       	mov    $0x280a,%edx
ffffffff8101bcc5:	0f 79 93 10 01 00 00 	vmwrite 0x110(%rbx),%rdx
ffffffff8101bccc:	b2 0c                	mov    $0xc,%dl
ffffffff8101bcce:	0f 79 93 18 01 00 00 	vmwrite 0x118(%rbx),%rdx
ffffffff8101bcd5:	b2 0e                	mov    $0xe,%dl
ffffffff8101bcd7:	0f 79 93 20 01 00 00 	vmwrite 0x120(%rbx),%rdx
ffffffff8101bcde:	b2 10                	mov    $0x10,%dl
ffffffff8101bce0:	0f 79 93 28 01 00 00 	vmwrite 0x128(%rbx),%rdx
        Vmcs::write (Vmcs::GUEST_PDPTE2, pdpte[2]);
        Vmcs::write (Vmcs::GUEST_PDPTE3, pdpte[3]);
    }

    return mtd & Mtd::FPU;
}
ffffffff8101bce7:	48 83 c4 18          	add    $0x18,%rsp
        Vmcs::write (Vmcs::GUEST_PDPTE1, pdpte[1]);
        Vmcs::write (Vmcs::GUEST_PDPTE2, pdpte[2]);
        Vmcs::write (Vmcs::GUEST_PDPTE3, pdpte[3]);
    }

    return mtd & Mtd::FPU;
ffffffff8101bceb:	48 c1 e8 1f          	shr    $0x1f,%rax
ffffffff8101bcef:	83 e0 01             	and    $0x1,%eax
}
ffffffff8101bcf2:	5b                   	pop    %rbx
ffffffff8101bcf3:	5d                   	pop    %rbp
ffffffff8101bcf4:	c3                   	retq   
ffffffff8101bcf5:	90                   	nop

ffffffff8101bcf6 <_ZN4Utcb8load_svmEP8Cpu_regs>:

bool Utcb::load_svm (Cpu_regs *regs)
{
ffffffff8101bcf6:	41 55                	push   %r13
ffffffff8101bcf8:	41 54                	push   %r12
ffffffff8101bcfa:	49 89 f4             	mov    %rsi,%r12
ffffffff8101bcfd:	55                   	push   %rbp
ffffffff8101bcfe:	53                   	push   %rbx
ffffffff8101bcff:	48 89 fb             	mov    %rdi,%rbx
ffffffff8101bd02:	51                   	push   %rcx
    Vmcb *const vmcb = regs->vmcb;

    mword m = regs->mtd;
ffffffff8101bd03:	48 8b ae e8 00 00 00 	mov    0xe8(%rsi),%rbp
    return mtd & Mtd::FPU;
}

bool Utcb::load_svm (Cpu_regs *regs)
{
    Vmcb *const vmcb = regs->vmcb;
ffffffff8101bd0a:	4c 8b ae 80 00 00 00 	mov    0x80(%rsi),%r13

    mword m = regs->mtd;

    if (m & Mtd::GPR_ACDB) {
ffffffff8101bd11:	40 f6 c5 01          	test   $0x1,%bpl
ffffffff8101bd15:	74 23                	je     ffffffff8101bd3a <_ZN4Utcb8load_svmEP8Cpu_regs+0x44>
        rax = static_cast<mword>(vmcb->rax);
ffffffff8101bd17:	49 8b 85 f8 05 00 00 	mov    0x5f8(%r13),%rax
ffffffff8101bd1e:	48 89 47 50          	mov    %rax,0x50(%rdi)
        rcx = regs->REG(cx);
ffffffff8101bd22:	48 8b 46 70          	mov    0x70(%rsi),%rax
ffffffff8101bd26:	48 89 47 58          	mov    %rax,0x58(%rdi)
        rdx = regs->REG(dx);
ffffffff8101bd2a:	48 8b 46 68          	mov    0x68(%rsi),%rax
ffffffff8101bd2e:	48 89 47 60          	mov    %rax,0x60(%rdi)
        rbx = regs->REG(bx);
ffffffff8101bd32:	48 8b 46 60          	mov    0x60(%rsi),%rax
ffffffff8101bd36:	48 89 47 68          	mov    %rax,0x68(%rdi)
    }

    if (m & Mtd::GPR_BSD) {
ffffffff8101bd3a:	40 f6 c5 02          	test   $0x2,%bpl
ffffffff8101bd3e:	74 21                	je     ffffffff8101bd61 <_ZN4Utcb8load_svmEP8Cpu_regs+0x6b>
        rbp = regs->REG(bp);
ffffffff8101bd40:	49 8b 44 24 50       	mov    0x50(%r12),%rax
ffffffff8101bd45:	48 89 43 78          	mov    %rax,0x78(%rbx)
        rsi = regs->REG(si);
ffffffff8101bd49:	49 8b 44 24 48       	mov    0x48(%r12),%rax
ffffffff8101bd4e:	48 89 83 80 00 00 00 	mov    %rax,0x80(%rbx)
        rdi = regs->REG(di);
ffffffff8101bd55:	49 8b 44 24 40       	mov    0x40(%r12),%rax
ffffffff8101bd5a:	48 89 83 88 00 00 00 	mov    %rax,0x88(%rbx)
    }

#ifdef __x86_64__
    if (m & Mtd::GPR_R8_R15) {
ffffffff8101bd61:	f7 c5 00 00 40 00    	test   $0x400000,%ebp
ffffffff8101bd67:	74 5f                	je     ffffffff8101bdc8 <_ZN4Utcb8load_svmEP8Cpu_regs+0xd2>
        r8  = regs->r8;
ffffffff8101bd69:	49 8b 44 24 38       	mov    0x38(%r12),%rax
ffffffff8101bd6e:	48 89 83 90 00 00 00 	mov    %rax,0x90(%rbx)
        r9  = regs->r9;
ffffffff8101bd75:	49 8b 44 24 30       	mov    0x30(%r12),%rax
ffffffff8101bd7a:	48 89 83 98 00 00 00 	mov    %rax,0x98(%rbx)
        r10 = regs->r10;
ffffffff8101bd81:	49 8b 44 24 28       	mov    0x28(%r12),%rax
ffffffff8101bd86:	48 89 83 a0 00 00 00 	mov    %rax,0xa0(%rbx)
        r11 = regs->r11;
ffffffff8101bd8d:	49 8b 44 24 20       	mov    0x20(%r12),%rax
ffffffff8101bd92:	48 89 83 a8 00 00 00 	mov    %rax,0xa8(%rbx)
        r12 = regs->r12;
ffffffff8101bd99:	49 8b 44 24 18       	mov    0x18(%r12),%rax
ffffffff8101bd9e:	48 89 83 b0 00 00 00 	mov    %rax,0xb0(%rbx)
        r13 = regs->r13;
ffffffff8101bda5:	49 8b 44 24 10       	mov    0x10(%r12),%rax
ffffffff8101bdaa:	48 89 83 b8 00 00 00 	mov    %rax,0xb8(%rbx)
        r14 = regs->r14;
ffffffff8101bdb1:	49 8b 44 24 08       	mov    0x8(%r12),%rax
ffffffff8101bdb6:	48 89 83 c0 00 00 00 	mov    %rax,0xc0(%rbx)
        r15 = regs->r15;
ffffffff8101bdbd:	49 8b 04 24          	mov    (%r12),%rax
ffffffff8101bdc1:	48 89 83 c8 00 00 00 	mov    %rax,0xc8(%rbx)
    }
#endif

    if (m & Mtd::RSP)
ffffffff8101bdc8:	40 f6 c5 04          	test   $0x4,%bpl
ffffffff8101bdcc:	74 0b                	je     ffffffff8101bdd9 <_ZN4Utcb8load_svmEP8Cpu_regs+0xe3>
        rsp = static_cast<mword>(vmcb->rsp);
ffffffff8101bdce:	49 8b 85 d8 05 00 00 	mov    0x5d8(%r13),%rax
ffffffff8101bdd5:	48 89 43 70          	mov    %rax,0x70(%rbx)

    if (m & Mtd::RIP_LEN)
ffffffff8101bdd9:	40 f6 c5 08          	test   $0x8,%bpl
ffffffff8101bddd:	74 0b                	je     ffffffff8101bdea <_ZN4Utcb8load_svmEP8Cpu_regs+0xf4>
        rip = static_cast<mword>(vmcb->rip);
ffffffff8101bddf:	49 8b 85 78 05 00 00 	mov    0x578(%r13),%rax
ffffffff8101bde6:	48 89 43 30          	mov    %rax,0x30(%rbx)

    if (m & Mtd::RFLAGS)
ffffffff8101bdea:	40 f6 c5 10          	test   $0x10,%bpl
ffffffff8101bdee:	74 0b                	je     ffffffff8101bdfb <_ZN4Utcb8load_svmEP8Cpu_regs+0x105>
        rflags = static_cast<mword>(vmcb->rflags);
ffffffff8101bdf0:	49 8b 85 70 05 00 00 	mov    0x570(%r13),%rax
ffffffff8101bdf7:	48 89 43 38          	mov    %rax,0x38(%rbx)

    if (m & Mtd::DS_ES) {
ffffffff8101bdfb:	40 f6 c5 20          	test   $0x20,%bpl
ffffffff8101bdff:	74 1e                	je     ffffffff8101be1f <_ZN4Utcb8load_svmEP8Cpu_regs+0x129>
        ds = vmcb->ds;
ffffffff8101be01:	41 0f 10 85 30 04 00 	movups 0x430(%r13),%xmm0
ffffffff8101be08:	00 
ffffffff8101be09:	0f 11 83 b8 01 00 00 	movups %xmm0,0x1b8(%rbx)
        es = vmcb->es;
ffffffff8101be10:	41 0f 10 8d 00 04 00 	movups 0x400(%r13),%xmm1
ffffffff8101be17:	00 
ffffffff8101be18:	0f 11 8b 88 01 00 00 	movups %xmm1,0x188(%rbx)
    }

    if (m & Mtd::FS_GS) {
ffffffff8101be1f:	40 f6 c5 40          	test   $0x40,%bpl
ffffffff8101be23:	74 1e                	je     ffffffff8101be43 <_ZN4Utcb8load_svmEP8Cpu_regs+0x14d>
        fs = vmcb->fs;
ffffffff8101be25:	41 0f 10 95 40 04 00 	movups 0x440(%r13),%xmm2
ffffffff8101be2c:	00 
ffffffff8101be2d:	0f 11 93 c8 01 00 00 	movups %xmm2,0x1c8(%rbx)
        gs = vmcb->gs;
ffffffff8101be34:	41 0f 10 9d 50 04 00 	movups 0x450(%r13),%xmm3
ffffffff8101be3b:	00 
ffffffff8101be3c:	0f 11 9b d8 01 00 00 	movups %xmm3,0x1d8(%rbx)
    }

    if (m & Mtd::CS_SS) {
ffffffff8101be43:	40 f6 c5 80          	test   $0x80,%bpl
ffffffff8101be47:	74 1e                	je     ffffffff8101be67 <_ZN4Utcb8load_svmEP8Cpu_regs+0x171>
        cs = vmcb->cs;
ffffffff8101be49:	41 0f 10 a5 10 04 00 	movups 0x410(%r13),%xmm4
ffffffff8101be50:	00 
ffffffff8101be51:	0f 11 a3 98 01 00 00 	movups %xmm4,0x198(%rbx)
        ss = vmcb->ss;
ffffffff8101be58:	41 0f 10 ad 20 04 00 	movups 0x420(%r13),%xmm5
ffffffff8101be5f:	00 
ffffffff8101be60:	0f 11 ab a8 01 00 00 	movups %xmm5,0x1a8(%rbx)
    }

    if (m & Mtd::TR)
ffffffff8101be67:	f7 c5 00 01 00 00    	test   $0x100,%ebp
ffffffff8101be6d:	74 0f                	je     ffffffff8101be7e <_ZN4Utcb8load_svmEP8Cpu_regs+0x188>
        tr = vmcb->tr;
ffffffff8101be6f:	41 0f 10 b5 90 04 00 	movups 0x490(%r13),%xmm6
ffffffff8101be76:	00 
ffffffff8101be77:	0f 11 b3 f8 01 00 00 	movups %xmm6,0x1f8(%rbx)

    if (m & Mtd::LDTR)
ffffffff8101be7e:	f7 c5 00 02 00 00    	test   $0x200,%ebp
ffffffff8101be84:	74 0f                	je     ffffffff8101be95 <_ZN4Utcb8load_svmEP8Cpu_regs+0x19f>
        ld = vmcb->ldtr;
ffffffff8101be86:	41 0f 10 bd 70 04 00 	movups 0x470(%r13),%xmm7
ffffffff8101be8d:	00 
ffffffff8101be8e:	0f 11 bb e8 01 00 00 	movups %xmm7,0x1e8(%rbx)

    if (m & Mtd::GDTR)
ffffffff8101be95:	f7 c5 00 04 00 00    	test   $0x400,%ebp
ffffffff8101be9b:	74 0f                	je     ffffffff8101beac <_ZN4Utcb8load_svmEP8Cpu_regs+0x1b6>
        gd = vmcb->gdtr;
ffffffff8101be9d:	41 0f 10 85 60 04 00 	movups 0x460(%r13),%xmm0
ffffffff8101bea4:	00 
ffffffff8101bea5:	0f 11 83 08 02 00 00 	movups %xmm0,0x208(%rbx)

    if (m & Mtd::IDTR)
ffffffff8101beac:	f7 c5 00 08 00 00    	test   $0x800,%ebp
ffffffff8101beb2:	74 0f                	je     ffffffff8101bec3 <_ZN4Utcb8load_svmEP8Cpu_regs+0x1cd>
        id = vmcb->idtr;
ffffffff8101beb4:	41 0f 10 8d 80 04 00 	movups 0x480(%r13),%xmm1
ffffffff8101bebb:	00 
ffffffff8101bebc:	0f 11 8b 18 02 00 00 	movups %xmm1,0x218(%rbx)

    if (m & Mtd::CR) {
ffffffff8101bec3:	f7 c5 00 10 00 00    	test   $0x1000,%ebp
ffffffff8101bec9:	74 4d                	je     ffffffff8101bf18 <_ZN4Utcb8load_svmEP8Cpu_regs+0x222>
        cr0 = regs->read_cr<Vmcb> (0);
ffffffff8101becb:	31 f6                	xor    %esi,%esi
ffffffff8101becd:	4c 89 e7             	mov    %r12,%rdi
ffffffff8101bed0:	e8 cb 7f ff ff       	callq  ffffffff81013ea0 <_ZNK8Exc_regs7read_crI4VmcbEEmj>
        cr2 = regs->read_cr<Vmcb> (2);
ffffffff8101bed5:	be 02 00 00 00       	mov    $0x2,%esi
ffffffff8101beda:	4c 89 e7             	mov    %r12,%rdi

    if (m & Mtd::IDTR)
        id = vmcb->idtr;

    if (m & Mtd::CR) {
        cr0 = regs->read_cr<Vmcb> (0);
ffffffff8101bedd:	48 89 83 f0 00 00 00 	mov    %rax,0xf0(%rbx)
        cr2 = regs->read_cr<Vmcb> (2);
ffffffff8101bee4:	e8 b7 7f ff ff       	callq  ffffffff81013ea0 <_ZNK8Exc_regs7read_crI4VmcbEEmj>
        cr3 = regs->read_cr<Vmcb> (3);
ffffffff8101bee9:	be 03 00 00 00       	mov    $0x3,%esi
ffffffff8101beee:	4c 89 e7             	mov    %r12,%rdi
    if (m & Mtd::IDTR)
        id = vmcb->idtr;

    if (m & Mtd::CR) {
        cr0 = regs->read_cr<Vmcb> (0);
        cr2 = regs->read_cr<Vmcb> (2);
ffffffff8101bef1:	48 89 83 f8 00 00 00 	mov    %rax,0xf8(%rbx)
        cr3 = regs->read_cr<Vmcb> (3);
ffffffff8101bef8:	e8 a3 7f ff ff       	callq  ffffffff81013ea0 <_ZNK8Exc_regs7read_crI4VmcbEEmj>
        cr4 = regs->read_cr<Vmcb> (4);
ffffffff8101befd:	be 04 00 00 00       	mov    $0x4,%esi
        id = vmcb->idtr;

    if (m & Mtd::CR) {
        cr0 = regs->read_cr<Vmcb> (0);
        cr2 = regs->read_cr<Vmcb> (2);
        cr3 = regs->read_cr<Vmcb> (3);
ffffffff8101bf02:	48 89 83 00 01 00 00 	mov    %rax,0x100(%rbx)
        cr4 = regs->read_cr<Vmcb> (4);
ffffffff8101bf09:	4c 89 e7             	mov    %r12,%rdi
ffffffff8101bf0c:	e8 8f 7f ff ff       	callq  ffffffff81013ea0 <_ZNK8Exc_regs7read_crI4VmcbEEmj>
ffffffff8101bf11:	48 89 83 08 01 00 00 	mov    %rax,0x108(%rbx)
    }

    if (m & Mtd::DR)
ffffffff8101bf18:	f7 c5 00 20 00 00    	test   $0x2000,%ebp
ffffffff8101bf1e:	74 0e                	je     ffffffff8101bf2e <_ZN4Utcb8load_svmEP8Cpu_regs+0x238>
        dr7 = static_cast<mword>(vmcb->dr7);
ffffffff8101bf20:	49 8b 85 60 05 00 00 	mov    0x560(%r13),%rax
ffffffff8101bf27:	48 89 83 68 01 00 00 	mov    %rax,0x168(%rbx)

    if (m & Mtd::SYSENTER) {
ffffffff8101bf2e:	f7 c5 00 40 00 00    	test   $0x4000,%ebp
ffffffff8101bf34:	74 2a                	je     ffffffff8101bf60 <_ZN4Utcb8load_svmEP8Cpu_regs+0x26a>
        sysenter_cs  = static_cast<mword>(vmcb->sysenter_cs);
ffffffff8101bf36:	49 8b 85 28 06 00 00 	mov    0x628(%r13),%rax
ffffffff8101bf3d:	48 89 83 70 01 00 00 	mov    %rax,0x170(%rbx)
        sysenter_rsp = static_cast<mword>(vmcb->sysenter_esp);
ffffffff8101bf44:	49 8b 85 30 06 00 00 	mov    0x630(%r13),%rax
ffffffff8101bf4b:	48 89 83 78 01 00 00 	mov    %rax,0x178(%rbx)
        sysenter_rip = static_cast<mword>(vmcb->sysenter_eip);
ffffffff8101bf52:	49 8b 85 38 06 00 00 	mov    0x638(%r13),%rax
ffffffff8101bf59:	48 89 83 80 01 00 00 	mov    %rax,0x180(%rbx)
    }

    if (m & Mtd::QUAL) {
ffffffff8101bf60:	f7 c5 00 80 00 00    	test   $0x8000,%ebp
ffffffff8101bf66:	74 40                	je     ffffffff8101bfa8 <_ZN4Utcb8load_svmEP8Cpu_regs+0x2b2>
        if (regs->dst_portal == NUM_VMI - 4) {
ffffffff8101bf68:	49 81 bc 24 a8 00 00 	cmpq   $0xfc,0xa8(%r12)
ffffffff8101bf6f:	00 fc 00 00 00 
ffffffff8101bf74:	75 19                	jne    ffffffff8101bf8f <_ZN4Utcb8load_svmEP8Cpu_regs+0x299>
            qual[0] = regs->nst_error;
ffffffff8101bf76:	49 8b 84 24 b8 00 00 	mov    0xb8(%r12),%rax
ffffffff8101bf7d:	00 
ffffffff8101bf7e:	48 89 83 d0 00 00 00 	mov    %rax,0xd0(%rbx)
            qual[1] = regs->nst_fault;
ffffffff8101bf85:	49 8b 84 24 b0 00 00 	mov    0xb0(%r12),%rax
ffffffff8101bf8c:	00 
ffffffff8101bf8d:	eb 12                	jmp    ffffffff8101bfa1 <_ZN4Utcb8load_svmEP8Cpu_regs+0x2ab>
        } else {
            qual[0] = vmcb->exitinfo1;
ffffffff8101bf8f:	49 8b 45 78          	mov    0x78(%r13),%rax
ffffffff8101bf93:	48 89 83 d0 00 00 00 	mov    %rax,0xd0(%rbx)
            qual[1] = vmcb->exitinfo2;
ffffffff8101bf9a:	49 8b 85 80 00 00 00 	mov    0x80(%r13),%rax
ffffffff8101bfa1:	48 89 83 d8 00 00 00 	mov    %rax,0xd8(%rbx)
        }
    }

    if (m & Mtd::INJ) {
ffffffff8101bfa8:	f7 c5 00 00 02 00    	test   $0x20000,%ebp
ffffffff8101bfae:	74 28                	je     ffffffff8101bfd8 <_ZN4Utcb8load_svmEP8Cpu_regs+0x2e2>
        if (regs->dst_portal == NUM_VMI - 3 || regs->dst_portal == NUM_VMI - 1)
ffffffff8101bfb0:	49 8b 84 24 a8 00 00 	mov    0xa8(%r12),%rax
ffffffff8101bfb7:	00 
ffffffff8101bfb8:	48 83 e0 fd          	and    $0xfffffffffffffffd,%rax
ffffffff8101bfbc:	48 3d fd 00 00 00    	cmp    $0xfd,%rax
ffffffff8101bfc2:	75 09                	jne    ffffffff8101bfcd <_ZN4Utcb8load_svmEP8Cpu_regs+0x2d7>
            inj = vmcb->inj_control;
ffffffff8101bfc4:	49 8b 85 a8 00 00 00 	mov    0xa8(%r13),%rax
ffffffff8101bfcb:	eb 07                	jmp    ffffffff8101bfd4 <_ZN4Utcb8load_svmEP8Cpu_regs+0x2de>
        else
            inj = vmcb->exitintinfo;
ffffffff8101bfcd:	49 8b 85 88 00 00 00 	mov    0x88(%r13),%rax
ffffffff8101bfd4:	48 89 43 48          	mov    %rax,0x48(%rbx)
    }

    if (m & Mtd::STA) {
ffffffff8101bfd8:	f7 c5 00 00 04 00    	test   $0x40000,%ebp
ffffffff8101bfde:	74 0e                	je     ffffffff8101bfee <_ZN4Utcb8load_svmEP8Cpu_regs+0x2f8>
        intr_state = static_cast<uint32>(vmcb->int_shadow);
ffffffff8101bfe0:	49 8b 45 68          	mov    0x68(%r13),%rax
        actv_state = 0;
ffffffff8101bfe4:	c7 43 44 00 00 00 00 	movl   $0x0,0x44(%rbx)
        else
            inj = vmcb->exitintinfo;
    }

    if (m & Mtd::STA) {
        intr_state = static_cast<uint32>(vmcb->int_shadow);
ffffffff8101bfeb:	89 43 40             	mov    %eax,0x40(%rbx)
        actv_state = 0;
    }

    if (m & Mtd::TSC) {
ffffffff8101bfee:	f7 c5 00 00 08 00    	test   $0x80000,%ebp
ffffffff8101bff4:	74 1f                	je     ffffffff8101c015 <_ZN4Utcb8load_svmEP8Cpu_regs+0x31f>

ALWAYS_INLINE
static inline uint64 rdtsc()
{
    mword h, l;
    asm volatile ("rdtsc" : "=a" (l), "=d" (h));
ffffffff8101bff6:	0f 31                	rdtsc  
    return static_cast<uint64>(h) << 32 | l;
ffffffff8101bff8:	48 c1 e2 20          	shl    $0x20,%rdx
ffffffff8101bffc:	48 09 d0             	or     %rdx,%rax
ffffffff8101bfff:	48 89 83 28 02 00 00 	mov    %rax,0x228(%rbx)
        tsc_val = rdtsc();
        tsc_off = regs->tsc_offset;
ffffffff8101c006:	49 8b 84 24 e0 00 00 	mov    0xe0(%r12),%rax
ffffffff8101c00d:	00 
ffffffff8101c00e:	48 89 83 30 02 00 00 	mov    %rax,0x230(%rbx)
    }

#ifdef __x86_64__
    if (m & Mtd::EFER)
ffffffff8101c015:	f7 c5 00 00 10 00    	test   $0x100000,%ebp
ffffffff8101c01b:	74 0e                	je     ffffffff8101c02b <_ZN4Utcb8load_svmEP8Cpu_regs+0x335>
        efer = vmcb->efer;
ffffffff8101c01d:	49 8b 85 d0 04 00 00 	mov    0x4d0(%r13),%rax
ffffffff8101c024:	48 89 83 38 01 00 00 	mov    %rax,0x138(%rbx)

    barrier();
    mtd = m;
    items = sizeof (Utcb_data) / sizeof (mword);

    return m & Mtd::FPU;
ffffffff8101c02b:	48 89 e8             	mov    %rbp,%rax
    if (m & Mtd::EFER)
        efer = vmcb->efer;
#endif

    barrier();
    mtd = m;
ffffffff8101c02e:	48 89 6b 20          	mov    %rbp,0x20(%rbx)
    items = sizeof (Utcb_data) / sizeof (mword);
ffffffff8101c032:	48 c7 03 43 00 00 00 	movq   $0x43,(%rbx)

    return m & Mtd::FPU;
ffffffff8101c039:	48 c1 e8 1f          	shr    $0x1f,%rax
}
ffffffff8101c03d:	5a                   	pop    %rdx

    barrier();
    mtd = m;
    items = sizeof (Utcb_data) / sizeof (mword);

    return m & Mtd::FPU;
ffffffff8101c03e:	83 e0 01             	and    $0x1,%eax
}
ffffffff8101c041:	5b                   	pop    %rbx
ffffffff8101c042:	5d                   	pop    %rbp
ffffffff8101c043:	41 5c                	pop    %r12
ffffffff8101c045:	41 5d                	pop    %r13
ffffffff8101c047:	c3                   	retq   

ffffffff8101c048 <_ZN4Utcb8save_svmEP8Cpu_regs>:

bool Utcb::save_svm (Cpu_regs *regs)
{
ffffffff8101c048:	41 54                	push   %r12
ffffffff8101c04a:	55                   	push   %rbp
ffffffff8101c04b:	49 89 f4             	mov    %rsi,%r12
ffffffff8101c04e:	53                   	push   %rbx
    Vmcb * const vmcb = regs->vmcb;

    if (mtd & Mtd::GPR_ACDB) {
ffffffff8101c04f:	f6 47 20 01          	testb  $0x1,0x20(%rdi)

    return m & Mtd::FPU;
}

bool Utcb::save_svm (Cpu_regs *regs)
{
ffffffff8101c053:	48 89 fb             	mov    %rdi,%rbx
    Vmcb * const vmcb = regs->vmcb;
ffffffff8101c056:	48 8b ae 80 00 00 00 	mov    0x80(%rsi),%rbp

    if (mtd & Mtd::GPR_ACDB) {
ffffffff8101c05d:	74 23                	je     ffffffff8101c082 <_ZN4Utcb8save_svmEP8Cpu_regs+0x3a>
        vmcb->rax = rax;
ffffffff8101c05f:	48 8b 47 50          	mov    0x50(%rdi),%rax
ffffffff8101c063:	48 89 85 f8 05 00 00 	mov    %rax,0x5f8(%rbp)
        regs->REG(cx) = rcx;
ffffffff8101c06a:	48 8b 47 58          	mov    0x58(%rdi),%rax
ffffffff8101c06e:	48 89 46 70          	mov    %rax,0x70(%rsi)
        regs->REG(dx) = rdx;
ffffffff8101c072:	48 8b 47 60          	mov    0x60(%rdi),%rax
ffffffff8101c076:	48 89 46 68          	mov    %rax,0x68(%rsi)
        regs->REG(bx) = rbx;
ffffffff8101c07a:	48 8b 47 68          	mov    0x68(%rdi),%rax
ffffffff8101c07e:	48 89 46 60          	mov    %rax,0x60(%rsi)
    }

    if (mtd & Mtd::GPR_BSD) {
ffffffff8101c082:	f6 43 20 02          	testb  $0x2,0x20(%rbx)
ffffffff8101c086:	74 21                	je     ffffffff8101c0a9 <_ZN4Utcb8save_svmEP8Cpu_regs+0x61>
        regs->REG(bp) = rbp;
ffffffff8101c088:	48 8b 43 78          	mov    0x78(%rbx),%rax
ffffffff8101c08c:	49 89 44 24 50       	mov    %rax,0x50(%r12)
        regs->REG(si) = rsi;
ffffffff8101c091:	48 8b 83 80 00 00 00 	mov    0x80(%rbx),%rax
ffffffff8101c098:	49 89 44 24 48       	mov    %rax,0x48(%r12)
        regs->REG(di) = rdi;
ffffffff8101c09d:	48 8b 83 88 00 00 00 	mov    0x88(%rbx),%rax
ffffffff8101c0a4:	49 89 44 24 40       	mov    %rax,0x40(%r12)
    }

#ifdef __x86_64__
    if (mtd & Mtd::GPR_R8_R15) {
ffffffff8101c0a9:	f6 43 22 40          	testb  $0x40,0x22(%rbx)
ffffffff8101c0ad:	74 5f                	je     ffffffff8101c10e <_ZN4Utcb8save_svmEP8Cpu_regs+0xc6>
        regs->r8      = r8;
ffffffff8101c0af:	48 8b 83 90 00 00 00 	mov    0x90(%rbx),%rax
ffffffff8101c0b6:	49 89 44 24 38       	mov    %rax,0x38(%r12)
        regs->r9      = r9;
ffffffff8101c0bb:	48 8b 83 98 00 00 00 	mov    0x98(%rbx),%rax
ffffffff8101c0c2:	49 89 44 24 30       	mov    %rax,0x30(%r12)
        regs->r10     = r10;
ffffffff8101c0c7:	48 8b 83 a0 00 00 00 	mov    0xa0(%rbx),%rax
ffffffff8101c0ce:	49 89 44 24 28       	mov    %rax,0x28(%r12)
        regs->r11     = r11;
ffffffff8101c0d3:	48 8b 83 a8 00 00 00 	mov    0xa8(%rbx),%rax
ffffffff8101c0da:	49 89 44 24 20       	mov    %rax,0x20(%r12)
        regs->r12     = r12;
ffffffff8101c0df:	48 8b 83 b0 00 00 00 	mov    0xb0(%rbx),%rax
ffffffff8101c0e6:	49 89 44 24 18       	mov    %rax,0x18(%r12)
        regs->r13     = r13;
ffffffff8101c0eb:	48 8b 83 b8 00 00 00 	mov    0xb8(%rbx),%rax
ffffffff8101c0f2:	49 89 44 24 10       	mov    %rax,0x10(%r12)
        regs->r14     = r14;
ffffffff8101c0f7:	48 8b 83 c0 00 00 00 	mov    0xc0(%rbx),%rax
ffffffff8101c0fe:	49 89 44 24 08       	mov    %rax,0x8(%r12)
        regs->r15     = r15;
ffffffff8101c103:	48 8b 83 c8 00 00 00 	mov    0xc8(%rbx),%rax
ffffffff8101c10a:	49 89 04 24          	mov    %rax,(%r12)
    }
#endif

    if (mtd & Mtd::RSP)
ffffffff8101c10e:	f6 43 20 04          	testb  $0x4,0x20(%rbx)
ffffffff8101c112:	74 0b                	je     ffffffff8101c11f <_ZN4Utcb8save_svmEP8Cpu_regs+0xd7>
        vmcb->rsp = rsp;
ffffffff8101c114:	48 8b 43 70          	mov    0x70(%rbx),%rax
ffffffff8101c118:	48 89 85 d8 05 00 00 	mov    %rax,0x5d8(%rbp)

    if (mtd & Mtd::RIP_LEN)
ffffffff8101c11f:	f6 43 20 08          	testb  $0x8,0x20(%rbx)
ffffffff8101c123:	74 0b                	je     ffffffff8101c130 <_ZN4Utcb8save_svmEP8Cpu_regs+0xe8>
        vmcb->rip = rip;
ffffffff8101c125:	48 8b 43 30          	mov    0x30(%rbx),%rax
ffffffff8101c129:	48 89 85 78 05 00 00 	mov    %rax,0x578(%rbp)

    if (mtd & Mtd::RFLAGS)
ffffffff8101c130:	f6 43 20 10          	testb  $0x10,0x20(%rbx)
ffffffff8101c134:	74 0b                	je     ffffffff8101c141 <_ZN4Utcb8save_svmEP8Cpu_regs+0xf9>
        vmcb->rflags = rflags;
ffffffff8101c136:	48 8b 43 38          	mov    0x38(%rbx),%rax
ffffffff8101c13a:	48 89 85 70 05 00 00 	mov    %rax,0x570(%rbp)

    if (mtd & Mtd::DS_ES) {
ffffffff8101c141:	f6 43 20 20          	testb  $0x20,0x20(%rbx)
ffffffff8101c145:	74 1c                	je     ffffffff8101c163 <_ZN4Utcb8save_svmEP8Cpu_regs+0x11b>
        vmcb->ds = ds;
ffffffff8101c147:	0f 10 83 b8 01 00 00 	movups 0x1b8(%rbx),%xmm0
ffffffff8101c14e:	0f 11 85 30 04 00 00 	movups %xmm0,0x430(%rbp)
        vmcb->es = es;
ffffffff8101c155:	0f 10 8b 88 01 00 00 	movups 0x188(%rbx),%xmm1
ffffffff8101c15c:	0f 11 8d 00 04 00 00 	movups %xmm1,0x400(%rbp)
    }

    if (mtd & Mtd::FS_GS) {
ffffffff8101c163:	f6 43 20 40          	testb  $0x40,0x20(%rbx)
ffffffff8101c167:	74 1c                	je     ffffffff8101c185 <_ZN4Utcb8save_svmEP8Cpu_regs+0x13d>
        vmcb->fs = fs;
ffffffff8101c169:	0f 10 93 c8 01 00 00 	movups 0x1c8(%rbx),%xmm2
ffffffff8101c170:	0f 11 95 40 04 00 00 	movups %xmm2,0x440(%rbp)
        vmcb->gs = gs;
ffffffff8101c177:	0f 10 9b d8 01 00 00 	movups 0x1d8(%rbx),%xmm3
ffffffff8101c17e:	0f 11 9d 50 04 00 00 	movups %xmm3,0x450(%rbp)
    }

    if (mtd & Mtd::CS_SS) {
ffffffff8101c185:	f6 43 20 80          	testb  $0x80,0x20(%rbx)
ffffffff8101c189:	74 1c                	je     ffffffff8101c1a7 <_ZN4Utcb8save_svmEP8Cpu_regs+0x15f>
        vmcb->cs = cs;
ffffffff8101c18b:	0f 10 a3 98 01 00 00 	movups 0x198(%rbx),%xmm4
ffffffff8101c192:	0f 11 a5 10 04 00 00 	movups %xmm4,0x410(%rbp)
        vmcb->ss = ss;
ffffffff8101c199:	0f 10 ab a8 01 00 00 	movups 0x1a8(%rbx),%xmm5
ffffffff8101c1a0:	0f 11 ad 20 04 00 00 	movups %xmm5,0x420(%rbp)
    }

    if (mtd & Mtd::TR)
ffffffff8101c1a7:	f6 43 21 01          	testb  $0x1,0x21(%rbx)
ffffffff8101c1ab:	74 0e                	je     ffffffff8101c1bb <_ZN4Utcb8save_svmEP8Cpu_regs+0x173>
        vmcb->tr = tr;
ffffffff8101c1ad:	0f 10 b3 f8 01 00 00 	movups 0x1f8(%rbx),%xmm6
ffffffff8101c1b4:	0f 11 b5 90 04 00 00 	movups %xmm6,0x490(%rbp)

    if (mtd & Mtd::LDTR)
ffffffff8101c1bb:	f6 43 21 02          	testb  $0x2,0x21(%rbx)
ffffffff8101c1bf:	74 0e                	je     ffffffff8101c1cf <_ZN4Utcb8save_svmEP8Cpu_regs+0x187>
        vmcb->ldtr = ld;
ffffffff8101c1c1:	0f 10 bb e8 01 00 00 	movups 0x1e8(%rbx),%xmm7
ffffffff8101c1c8:	0f 11 bd 70 04 00 00 	movups %xmm7,0x470(%rbp)

    if (mtd & Mtd::GDTR)
ffffffff8101c1cf:	f6 43 21 04          	testb  $0x4,0x21(%rbx)
ffffffff8101c1d3:	74 0e                	je     ffffffff8101c1e3 <_ZN4Utcb8save_svmEP8Cpu_regs+0x19b>
        vmcb->gdtr = gd;
ffffffff8101c1d5:	0f 10 83 08 02 00 00 	movups 0x208(%rbx),%xmm0
ffffffff8101c1dc:	0f 11 85 60 04 00 00 	movups %xmm0,0x460(%rbp)

    if (mtd & Mtd::IDTR)
ffffffff8101c1e3:	f6 43 21 08          	testb  $0x8,0x21(%rbx)
ffffffff8101c1e7:	74 0e                	je     ffffffff8101c1f7 <_ZN4Utcb8save_svmEP8Cpu_regs+0x1af>
        vmcb->idtr = id;
ffffffff8101c1e9:	0f 10 8b 18 02 00 00 	movups 0x218(%rbx),%xmm1
ffffffff8101c1f0:	0f 11 8d 80 04 00 00 	movups %xmm1,0x480(%rbp)

    if (mtd & Mtd::CR) {
ffffffff8101c1f7:	f6 43 21 10          	testb  $0x10,0x21(%rbx)
ffffffff8101c1fb:	74 4d                	je     ffffffff8101c24a <_ZN4Utcb8save_svmEP8Cpu_regs+0x202>
        regs->write_cr<Vmcb> (0, cr0);
ffffffff8101c1fd:	48 8b 93 f0 00 00 00 	mov    0xf0(%rbx),%rdx
ffffffff8101c204:	31 f6                	xor    %esi,%esi
ffffffff8101c206:	4c 89 e7             	mov    %r12,%rdi
ffffffff8101c209:	e8 44 7e ff ff       	callq  ffffffff81014052 <_ZN8Exc_regs8write_crI4VmcbEEvjm>
        regs->write_cr<Vmcb> (2, cr2);
ffffffff8101c20e:	48 8b 93 f8 00 00 00 	mov    0xf8(%rbx),%rdx
ffffffff8101c215:	be 02 00 00 00       	mov    $0x2,%esi
ffffffff8101c21a:	4c 89 e7             	mov    %r12,%rdi
ffffffff8101c21d:	e8 30 7e ff ff       	callq  ffffffff81014052 <_ZN8Exc_regs8write_crI4VmcbEEvjm>
        regs->write_cr<Vmcb> (3, cr3);
ffffffff8101c222:	48 8b 93 00 01 00 00 	mov    0x100(%rbx),%rdx
ffffffff8101c229:	be 03 00 00 00       	mov    $0x3,%esi
ffffffff8101c22e:	4c 89 e7             	mov    %r12,%rdi
ffffffff8101c231:	e8 1c 7e ff ff       	callq  ffffffff81014052 <_ZN8Exc_regs8write_crI4VmcbEEvjm>
        regs->write_cr<Vmcb> (4, cr4);
ffffffff8101c236:	48 8b 93 08 01 00 00 	mov    0x108(%rbx),%rdx
ffffffff8101c23d:	be 04 00 00 00       	mov    $0x4,%esi
ffffffff8101c242:	4c 89 e7             	mov    %r12,%rdi
ffffffff8101c245:	e8 08 7e ff ff       	callq  ffffffff81014052 <_ZN8Exc_regs8write_crI4VmcbEEvjm>
    }

    if (mtd & Mtd::DR)
ffffffff8101c24a:	f6 43 21 20          	testb  $0x20,0x21(%rbx)
ffffffff8101c24e:	74 0e                	je     ffffffff8101c25e <_ZN4Utcb8save_svmEP8Cpu_regs+0x216>
        vmcb->dr7 = dr7;
ffffffff8101c250:	48 8b 83 68 01 00 00 	mov    0x168(%rbx),%rax
ffffffff8101c257:	48 89 85 60 05 00 00 	mov    %rax,0x560(%rbp)

    if (mtd & Mtd::SYSENTER) {
ffffffff8101c25e:	f6 43 21 40          	testb  $0x40,0x21(%rbx)
ffffffff8101c262:	74 2a                	je     ffffffff8101c28e <_ZN4Utcb8save_svmEP8Cpu_regs+0x246>
        vmcb->sysenter_cs  = sysenter_cs;
ffffffff8101c264:	48 8b 83 70 01 00 00 	mov    0x170(%rbx),%rax
ffffffff8101c26b:	48 89 85 28 06 00 00 	mov    %rax,0x628(%rbp)
        vmcb->sysenter_esp = sysenter_rsp;
ffffffff8101c272:	48 8b 83 78 01 00 00 	mov    0x178(%rbx),%rax
ffffffff8101c279:	48 89 85 30 06 00 00 	mov    %rax,0x630(%rbp)
        vmcb->sysenter_eip = sysenter_rip;
ffffffff8101c280:	48 8b 83 80 01 00 00 	mov    0x180(%rbx),%rax
ffffffff8101c287:	48 89 85 38 06 00 00 	mov    %rax,0x638(%rbp)
    }

    if (mtd & Mtd::CTRL) {
ffffffff8101c28e:	f6 43 22 01          	testb  $0x1,0x22(%rbx)
ffffffff8101c292:	74 1c                	je     ffffffff8101c2b0 <_ZN4Utcb8save_svmEP8Cpu_regs+0x268>
        regs->svm_set_cpu_ctrl0 (ctrl[0]);
ffffffff8101c294:	8b b3 e0 00 00 00    	mov    0xe0(%rbx),%esi
ffffffff8101c29a:	4c 89 e7             	mov    %r12,%rdi
ffffffff8101c29d:	e8 58 70 ff ff       	callq  ffffffff810132fa <_ZN8Exc_regs17svm_set_cpu_ctrl0Em>
        regs->svm_set_cpu_ctrl1 (ctrl[1]);
ffffffff8101c2a2:	8b b3 e4 00 00 00    	mov    0xe4(%rbx),%esi
ffffffff8101c2a8:	4c 89 e7             	mov    %r12,%rdi
ffffffff8101c2ab:	e8 f4 70 ff ff       	callq  ffffffff810133a4 <_ZN8Exc_regs17svm_set_cpu_ctrl1Em>
    }

    if (mtd & Mtd::INJ) {
ffffffff8101c2b0:	f6 43 22 02          	testb  $0x2,0x22(%rbx)
ffffffff8101c2b4:	74 2e                	je     ffffffff8101c2e4 <_ZN4Utcb8save_svmEP8Cpu_regs+0x29c>

        if (intr_info & 0x1000) {
ffffffff8101c2b6:	f6 43 49 10          	testb  $0x10,0x49(%rbx)
ffffffff8101c2ba:	74 0e                	je     ffffffff8101c2ca <_ZN4Utcb8save_svmEP8Cpu_regs+0x282>
            vmcb->int_control      |=  (1ul << 8 | 1ul << 20);
ffffffff8101c2bc:	48 81 4d 60 00 01 10 	orq    $0x100100,0x60(%rbp)
ffffffff8101c2c3:	00 
            vmcb->intercept_cpu[0] |=  Vmcb::CPU_VINTR;
ffffffff8101c2c4:	83 4d 0c 10          	orl    $0x10,0xc(%rbp)
ffffffff8101c2c8:	eb 0c                	jmp    ffffffff8101c2d6 <_ZN4Utcb8save_svmEP8Cpu_regs+0x28e>
        } else {
            vmcb->int_control      &= ~(1ul << 8 | 1ul << 20);
ffffffff8101c2ca:	48 81 65 60 ff fe ef 	andq   $0xffffffffffeffeff,0x60(%rbp)
ffffffff8101c2d1:	ff 
            vmcb->intercept_cpu[0] &= ~Vmcb::CPU_VINTR;
ffffffff8101c2d2:	83 65 0c ef          	andl   $0xffffffef,0xc(%rbp)
        }

        vmcb->inj_control = inj & ~0x3000;
ffffffff8101c2d6:	48 8b 43 48          	mov    0x48(%rbx),%rax
ffffffff8101c2da:	80 e4 cf             	and    $0xcf,%ah
ffffffff8101c2dd:	48 89 85 a8 00 00 00 	mov    %rax,0xa8(%rbp)
    }

    if (mtd & Mtd::STA)
ffffffff8101c2e4:	f6 43 22 04          	testb  $0x4,0x22(%rbx)
ffffffff8101c2e8:	74 07                	je     ffffffff8101c2f1 <_ZN4Utcb8save_svmEP8Cpu_regs+0x2a9>
        vmcb->int_shadow = intr_state;
ffffffff8101c2ea:	8b 43 40             	mov    0x40(%rbx),%eax
ffffffff8101c2ed:	48 89 45 68          	mov    %rax,0x68(%rbp)

    if (mtd & Mtd::TSC)
ffffffff8101c2f1:	f6 43 22 08          	testb  $0x8,0x22(%rbx)
ffffffff8101c2f5:	74 1c                	je     ffffffff8101c313 <_ZN4Utcb8save_svmEP8Cpu_regs+0x2cb>
ffffffff8101c2f7:	48 8b 83 30 02 00 00 	mov    0x230(%rbx),%rax
ffffffff8101c2fe:	49 01 84 24 e0 00 00 	add    %rax,0xe0(%r12)
ffffffff8101c305:	00 
ffffffff8101c306:	f0 49 81 8c 24 d8 00 	lock orq $0x20000000,0xd8(%r12)
ffffffff8101c30d:	00 00 00 00 00 20 
        regs->add_tsc_offset (tsc_off);

#ifdef __x86_64__
    if (mtd & Mtd::EFER)
ffffffff8101c313:	f6 43 22 10          	testb  $0x10,0x22(%rbx)
ffffffff8101c317:	74 0f                	je     ffffffff8101c328 <_ZN4Utcb8save_svmEP8Cpu_regs+0x2e0>
        regs->write_efer<Vmcb> (efer);
ffffffff8101c319:	48 8b b3 38 01 00 00 	mov    0x138(%rbx),%rsi
ffffffff8101c320:	4c 89 e7             	mov    %r12,%rdi
ffffffff8101c323:	e8 cc 7a ff ff       	callq  ffffffff81013df4 <_ZN8Exc_regs10write_eferI4VmcbEEvm>
#endif

    return mtd & Mtd::FPU;
ffffffff8101c328:	48 8b 43 20          	mov    0x20(%rbx),%rax
}
ffffffff8101c32c:	5b                   	pop    %rbx
ffffffff8101c32d:	5d                   	pop    %rbp
#ifdef __x86_64__
    if (mtd & Mtd::EFER)
        regs->write_efer<Vmcb> (efer);
#endif

    return mtd & Mtd::FPU;
ffffffff8101c32e:	48 c1 e8 1f          	shr    $0x1f,%rax
ffffffff8101c332:	83 e0 01             	and    $0x1,%eax
}
ffffffff8101c335:	41 5c                	pop    %r12
ffffffff8101c337:	c3                   	retq   

ffffffff8101c338 <_ZN4VmcsC1Emmmy>:
Vmcs::vmx_ctrl_exi  Vmcs::ctrl_exi;
Vmcs::vmx_ctrl_ent  Vmcs::ctrl_ent;
mword               Vmcs::fix_cr0_set, Vmcs::fix_cr0_clr;
mword               Vmcs::fix_cr4_set, Vmcs::fix_cr4_clr;

Vmcs::Vmcs (mword esp, mword bmp, mword cr3, uint64 eptp) : rev (basic.revision)
ffffffff8101c338:	48 83 ec 18          	sub    $0x18,%rsp
ffffffff8101c33c:	8b 05 3e 3b fe 3e    	mov    0x3efe3b3e(%rip),%eax        # ffffffffbffffe80 <_ZN4Vmcs5basicE>
ffffffff8101c342:	49 89 c9             	mov    %rcx,%r9
ffffffff8101c345:	89 07                	mov    %eax,(%rdi)
        Vmcs* clone();

        ALWAYS_INLINE
        inline void make_current()
        {
            if (EXPECT_TRUE (current == this))
ffffffff8101c347:	48 39 3d d2 2c fe 3e 	cmp    %rdi,0x3efe2cd2(%rip)        # ffffffffbffff020 <_ZN4Vmcs7currentE>
ffffffff8101c34e:	74 45                	je     ffffffff8101c395 <_ZN4VmcsC1Emmmy+0x5d>
                return;

            uint64 phys = Buddy::ptr_to_phys (current = this);
ffffffff8101c350:	48 89 3d c9 2c fe 3e 	mov    %rdi,0x3efe2cc9(%rip)        # ffffffffbffff020 <_ZN4Vmcs7currentE>
        }

        ALWAYS_INLINE
        inline mword virt_to_phys (mword virt)
        {
            return virt - reinterpret_cast<mword>(&OFFSET);
ffffffff8101c357:	48 81 ef 00 00 c0 80 	sub    $0xffffffff80c00000,%rdi
ffffffff8101c35e:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)

            bool ret;
            asm volatile ("vmptrld %1; seta %0" : "=q" (ret) : "m" (phys) : "cc");
ffffffff8101c363:	0f c7 74 24 08       	vmptrld 0x8(%rsp)
ffffffff8101c368:	0f 97 c0             	seta   %al
            assert (ret);
ffffffff8101c36b:	84 c0                	test   %al,%al
ffffffff8101c36d:	75 26                	jne    ffffffff8101c395 <_ZN4VmcsC1Emmmy+0x5d>
ffffffff8101c36f:	49 c7 c0 c0 14 02 81 	mov    $0xffffffff810214c0,%r8
ffffffff8101c376:	b9 9a 01 00 00       	mov    $0x19a,%ecx
ffffffff8101c37b:	48 c7 c2 72 db 01 81 	mov    $0xffffffff8101db72,%rdx
ffffffff8101c382:	48 c7 c6 e1 db 01 81 	mov    $0xffffffff8101dbe1,%rsi
ffffffff8101c389:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8101c390:	e8 bb 5b fe ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
        }

        ALWAYS_INLINE
        static inline void write (Encoding enc, mword val)
        {
            asm volatile ("vmwrite %0, %1" : : "rm" (val), "r" (static_cast<mword>(enc)) : "cc");
ffffffff8101c395:	31 c9                	xor    %ecx,%ecx
ffffffff8101c397:	b8 06 40 00 00       	mov    $0x4006,%eax
ffffffff8101c39c:	0f 79 c1             	vmwrite %rcx,%rax
ffffffff8101c39f:	b0 08                	mov    $0x8,%al
ffffffff8101c3a1:	0f 79 c1             	vmwrite %rcx,%rax
ffffffff8101c3a4:	b0 0a                	mov    $0xa,%al
ffffffff8101c3a6:	0f 79 c1             	vmwrite %rcx,%rax
ffffffff8101c3a9:	48 83 c8 ff          	or     $0xffffffffffffffff,%rax
ffffffff8101c3ad:	bf 00 28 00 00       	mov    $0x2800,%edi
ffffffff8101c3b2:	0f 79 f8             	vmwrite %rax,%rdi
ffffffff8101c3b5:	40 b7 01             	mov    $0x1,%dil
ffffffff8101c3b8:	0f 79 f8             	vmwrite %rax,%rdi
    write (CR3_TARGET_COUNT, 0);

    write (VMCS_LINK_PTR,    ~0ul);
    write (VMCS_LINK_PTR_HI, ~0ul);

    write (VPID, ++vpid_ctr);
ffffffff8101c3bb:	8b 05 c7 3a fe 3e    	mov    0x3efe3ac7(%rip),%eax        # ffffffffbffffe88 <_ZN4Vmcs8vpid_ctrE>
ffffffff8101c3c1:	ff c0                	inc    %eax
ffffffff8101c3c3:	89 05 bf 3a fe 3e    	mov    %eax,0x3efe3abf(%rip)        # ffffffffbffffe88 <_ZN4Vmcs8vpid_ctrE>
ffffffff8101c3c9:	0f 79 c8             	vmwrite %rax,%rcx

    write (EPTP,    static_cast<mword>(eptp) | (Ept::max() - 1) << 3 | 6);
ffffffff8101c3cc:	4c 89 c0             	mov    %r8,%rax
ffffffff8101c3cf:	66 b9 1a 20          	mov    $0x201a,%cx
ffffffff8101c3d3:	48 83 c8 1e          	or     $0x1e,%rax
ffffffff8101c3d7:	0f 79 c8             	vmwrite %rax,%rcx
ffffffff8101c3da:	b8 1b 20 00 00       	mov    $0x201b,%eax
    write (EPTP_HI, static_cast<mword>(eptp >> 32));
ffffffff8101c3df:	49 c1 e8 20          	shr    $0x20,%r8
ffffffff8101c3e3:	41 0f 79 c0          	vmwrite %r8,%rax
ffffffff8101c3e7:	30 c0                	xor    %al,%al
ffffffff8101c3e9:	0f 79 c2             	vmwrite %rdx,%rax

    write (IO_BITMAP_A, bmp);
    write (IO_BITMAP_B, bmp + PAGE_SIZE);
ffffffff8101c3ec:	48 81 c2 00 10 00 00 	add    $0x1000,%rdx
ffffffff8101c3f3:	b0 02                	mov    $0x2,%al
ffffffff8101c3f5:	0f 79 c2             	vmwrite %rdx,%rax
ffffffff8101c3f8:	66 bf 08 00          	mov    $0x8,%di
ffffffff8101c3fc:	66 b8 02 0c          	mov    $0xc02,%ax
ffffffff8101c400:	0f 79 c7             	vmwrite %rdi,%rax
ffffffff8101c403:	ba 04 0c 00 00       	mov    $0xc04,%edx
ffffffff8101c408:	66 b8 10 00          	mov    $0x10,%ax
ffffffff8101c40c:	0f 79 d0             	vmwrite %rax,%rdx
ffffffff8101c40f:	b2 06                	mov    $0x6,%dl
ffffffff8101c411:	0f 79 d0             	vmwrite %rax,%rdx
ffffffff8101c414:	30 d2                	xor    %dl,%dl
ffffffff8101c416:	0f 79 d0             	vmwrite %rax,%rdx
ffffffff8101c419:	b2 0c                	mov    $0xc,%dl
ffffffff8101c41b:	b0 30                	mov    $0x30,%al
ffffffff8101c41d:	0f 79 d0             	vmwrite %rax,%rdx
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
ffffffff8101c420:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
ffffffff8101c425:	0f 32                	rdmsr  
            return static_cast<T>(static_cast<uint64>(h) << 32 | l);
ffffffff8101c427:	48 c1 e2 20          	shl    $0x20,%rdx
ffffffff8101c42b:	48 09 d0             	or     %rdx,%rax
ffffffff8101c42e:	ba 02 2c 00 00       	mov    $0x2c02,%edx
ffffffff8101c433:	0f 79 d0             	vmwrite %rax,%rdx
    write (HOST_EFER, Msr::read<uint64>(Msr::IA32_EFER));
    exi |= EXI_SAVE_EFER | EXI_LOAD_EFER | EXI_HOST_64;
    ent |= ENT_LOAD_EFER;
#endif

    write (PIN_CONTROLS, (pin | ctrl_pin.set) & ctrl_pin.clr);
ffffffff8101c436:	8b 05 34 3a fe 3e    	mov    0x3efe3a34(%rip),%eax        # ffffffffbffffe70 <_ZN4Vmcs8ctrl_pinE>
ffffffff8101c43c:	66 ba 00 40          	mov    $0x4000,%dx
ffffffff8101c440:	83 c8 29             	or     $0x29,%eax
ffffffff8101c443:	23 05 2b 3a fe 3e    	and    0x3efe3a2b(%rip),%eax        # ffffffffbffffe74 <_ZN4Vmcs8ctrl_pinE+0x4>
ffffffff8101c449:	0f 79 d0             	vmwrite %rax,%rdx
    write (EXI_CONTROLS, (exi | ctrl_exi.set) & ctrl_exi.clr);
ffffffff8101c44c:	8b 05 06 3a fe 3e    	mov    0x3efe3a06(%rip),%eax        # ffffffffbffffe58 <_ZN4Vmcs8ctrl_exiE>
ffffffff8101c452:	b2 0c                	mov    $0xc,%dl
ffffffff8101c454:	0d 00 82 30 00       	or     $0x308200,%eax
ffffffff8101c459:	23 05 fd 39 fe 3e    	and    0x3efe39fd(%rip),%eax        # ffffffffbffffe5c <_ZN4Vmcs8ctrl_exiE+0x4>
ffffffff8101c45f:	0f 79 d0             	vmwrite %rax,%rdx
    write (ENT_CONTROLS, (ent | ctrl_ent.set) & ctrl_ent.clr);
ffffffff8101c462:	8b 05 e8 39 fe 3e    	mov    0x3efe39e8(%rip),%eax        # ffffffffbffffe50 <_ZN4Vmcs8ctrl_entE>
ffffffff8101c468:	b2 12                	mov    $0x12,%dl
ffffffff8101c46a:	80 cc 80             	or     $0x80,%ah
ffffffff8101c46d:	23 05 e1 39 fe 3e    	and    0x3efe39e1(%rip),%eax        # ffffffffbffffe54 <_ZN4Vmcs8ctrl_entE+0x4>
ffffffff8101c473:	0f 79 d0             	vmwrite %rax,%rdx
ffffffff8101c476:	b8 02 6c 00 00       	mov    $0x6c02,%eax
ffffffff8101c47b:	41 0f 79 c1          	vmwrite %r9,%rax

ALWAYS_INLINE
static inline mword get_cr0()
{
    mword cr0;
    asm volatile ("mov %%cr0, %0" : "=r" (cr0));
ffffffff8101c47f:	0f 20 c0             	mov    %cr0,%rax

    write (HOST_CR3, cr3);
    write (HOST_CR0, get_cr0() | Cpu::CR0_TS);
ffffffff8101c482:	48 83 c8 08          	or     $0x8,%rax
ffffffff8101c486:	66 ba 00 6c          	mov    $0x6c00,%dx
ffffffff8101c48a:	0f 79 d0             	vmwrite %rax,%rdx

ALWAYS_INLINE
static inline mword get_cr4()
{
    mword cr4;
    asm volatile ("mov %%cr4, %0" : "=r" (cr4));
ffffffff8101c48d:	0f 20 e0             	mov    %cr4,%rax
ffffffff8101c490:	b2 04                	mov    $0x4,%dl
ffffffff8101c492:	0f 79 d0             	vmwrite %rax,%rdx
ffffffff8101c495:	48 c7 c0 c8 fd ff bf 	mov    $0xffffffffbffffdc8,%rax
ffffffff8101c49c:	b2 0a                	mov    $0xa,%dl
ffffffff8101c49e:	0f 79 d0             	vmwrite %rax,%rdx
ffffffff8101c4a1:	48 c7 c0 c8 f7 ff bf 	mov    $0xffffffffbffff7c8,%rax
ffffffff8101c4a8:	b2 0c                	mov    $0xc,%dl
ffffffff8101c4aa:	0f 79 d0             	vmwrite %rax,%rdx
ffffffff8101c4ad:	48 c7 c0 90 2d 16 81 	mov    $0xffffffff81162d90,%rax
ffffffff8101c4b4:	b2 0e                	mov    $0xe,%dl
ffffffff8101c4b6:	0f 79 d0             	vmwrite %rax,%rdx
ffffffff8101c4b9:	b8 00 4c 00 00       	mov    $0x4c00,%eax
ffffffff8101c4be:	0f 79 c7             	vmwrite %rdi,%rax
ffffffff8101c4c1:	48 c7 c0 cc fd ff bf 	mov    $0xffffffffbffffdcc,%rax
ffffffff8101c4c8:	b2 10                	mov    $0x10,%dl
ffffffff8101c4ca:	0f 79 d0             	vmwrite %rax,%rdx
ffffffff8101c4cd:	48 c7 c0 0c 79 00 81 	mov    $0xffffffff8100790c,%rax
ffffffff8101c4d4:	b2 12                	mov    $0x12,%dl
ffffffff8101c4d6:	0f 79 d0             	vmwrite %rax,%rdx
ffffffff8101c4d9:	b8 14 6c 00 00       	mov    $0x6c14,%eax
ffffffff8101c4de:	0f 79 c6             	vmwrite %rsi,%rax
ffffffff8101c4e1:	48 c7 c0 48 79 00 81 	mov    $0xffffffff81007948,%rax
ffffffff8101c4e8:	b2 16                	mov    $0x16,%dl
ffffffff8101c4ea:	0f 79 d0             	vmwrite %rax,%rdx
    write (HOST_SYSENTER_ESP, reinterpret_cast<mword>(&Tss::run.sp0));
    write (HOST_SYSENTER_EIP, reinterpret_cast<mword>(&entry_sysenter));

    write (HOST_RSP, esp);
    write (HOST_RIP, reinterpret_cast<mword>(&entry_vmx));
}
ffffffff8101c4ed:	48 83 c4 18          	add    $0x18,%rsp
ffffffff8101c4f1:	c3                   	retq   

ffffffff8101c4f2 <_ZN4Vmcs4initEv>:

void Vmcs::init()
{
ffffffff8101c4f2:	53                   	push   %rbx
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
ffffffff8101c4f3:	bb 3a 00 00 00       	mov    $0x3a,%ebx
ffffffff8101c4f8:	89 d9                	mov    %ebx,%ecx
ffffffff8101c4fa:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff8101c4fe:	0f 32                	rdmsr  
        static void init();

        ALWAYS_INLINE
        static inline bool feature (Feature f)
        {
            return features[f / 32] & 1U << f % 32;
ffffffff8101c500:	8b 35 3e 32 fe 3e    	mov    0x3efe323e(%rip),%esi        # ffffffffbffff744 <_ZN3Cpu8featuresE+0x4>
    Console::print("Feature %x  vmx %d IA32_FEATURE_CONTROL %d ", Cpu::features[1], Cpu::feature (Cpu::FEAT_VMX), Msr::read<uint32>(Msr::IA32_FEATURE_CONTROL));
ffffffff8101c506:	89 c1                	mov    %eax,%ecx
ffffffff8101c508:	48 c7 c7 7a 14 02 81 	mov    $0xffffffff8102147a,%rdi
ffffffff8101c50f:	31 c0                	xor    %eax,%eax
ffffffff8101c511:	89 f2                	mov    %esi,%edx
ffffffff8101c513:	c1 ea 05             	shr    $0x5,%edx
ffffffff8101c516:	83 e2 01             	and    $0x1,%edx
ffffffff8101c519:	e8 6e 5b fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
    if (!Cpu::feature (Cpu::FEAT_VMX) || (Msr::read<uint32>(Msr::IA32_FEATURE_CONTROL) & 0x5) != 0x5) {
ffffffff8101c51e:	f6 05 1f 32 fe 3e 20 	testb  $0x20,0x3efe321f(%rip)        # ffffffffbffff744 <_ZN3Cpu8featuresE+0x4>
ffffffff8101c525:	0f 84 91 02 00 00    	je     ffffffff8101c7bc <_ZN4Vmcs4initEv+0x2ca>
ffffffff8101c52b:	89 d9                	mov    %ebx,%ecx
ffffffff8101c52d:	0f 32                	rdmsr  
ffffffff8101c52f:	83 e0 05             	and    $0x5,%eax
ffffffff8101c532:	83 f8 05             	cmp    $0x5,%eax
ffffffff8101c535:	0f 85 81 02 00 00    	jne    ffffffff8101c7bc <_ZN4Vmcs4initEv+0x2ca>
ffffffff8101c53b:	b9 86 04 00 00       	mov    $0x486,%ecx
ffffffff8101c540:	0f 32                	rdmsr  
            return static_cast<T>(static_cast<uint64>(h) << 32 | l);
ffffffff8101c542:	48 c1 e2 20          	shl    $0x20,%rdx
ffffffff8101c546:	48 89 d1             	mov    %rdx,%rcx
ffffffff8101c549:	48 09 c1             	or     %rax,%rcx
ffffffff8101c54c:	49 89 c8             	mov    %rcx,%r8
        Hip::clr_feature (Hip::FEAT_VMX);
        return;
    }

    fix_cr0_set =  Msr::read<mword>(Msr::IA32_VMX_CR0_FIXED0);
ffffffff8101c54f:	48 89 0d f2 38 fe 3e 	mov    %rcx,0x3efe38f2(%rip)        # ffffffffbffffe48 <_ZN4Vmcs11fix_cr0_setE>
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
ffffffff8101c556:	b9 87 04 00 00       	mov    $0x487,%ecx
ffffffff8101c55b:	0f 32                	rdmsr  
            return static_cast<T>(static_cast<uint64>(h) << 32 | l);
ffffffff8101c55d:	48 c1 e2 20          	shl    $0x20,%rdx
ffffffff8101c561:	48 89 d1             	mov    %rdx,%rcx
ffffffff8101c564:	48 09 c1             	or     %rax,%rcx
    fix_cr0_clr = ~Msr::read<mword>(Msr::IA32_VMX_CR0_FIXED1);
ffffffff8101c567:	48 89 ce             	mov    %rcx,%rsi
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
ffffffff8101c56a:	b9 88 04 00 00       	mov    $0x488,%ecx
ffffffff8101c56f:	48 f7 d6             	not    %rsi
ffffffff8101c572:	0f 32                	rdmsr  
            return static_cast<T>(static_cast<uint64>(h) << 32 | l);
ffffffff8101c574:	48 c1 e2 20          	shl    $0x20,%rdx
ffffffff8101c578:	48 89 d1             	mov    %rdx,%rcx
ffffffff8101c57b:	48 09 c1             	or     %rax,%rcx
ffffffff8101c57e:	49 89 c9             	mov    %rcx,%r9
    fix_cr4_set =  Msr::read<mword>(Msr::IA32_VMX_CR4_FIXED0);
ffffffff8101c581:	48 89 0d b0 38 fe 3e 	mov    %rcx,0x3efe38b0(%rip)        # ffffffffbffffe38 <_ZN4Vmcs11fix_cr4_setE>
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
ffffffff8101c588:	b9 89 04 00 00       	mov    $0x489,%ecx
ffffffff8101c58d:	0f 32                	rdmsr  
            return static_cast<T>(static_cast<uint64>(h) << 32 | l);
ffffffff8101c58f:	48 c1 e2 20          	shl    $0x20,%rdx
ffffffff8101c593:	48 89 d1             	mov    %rdx,%rcx
ffffffff8101c596:	48 09 c1             	or     %rax,%rcx
    fix_cr4_clr = ~Msr::read<mword>(Msr::IA32_VMX_CR4_FIXED1);
ffffffff8101c599:	48 89 c8             	mov    %rcx,%rax
ffffffff8101c59c:	49 89 ca             	mov    %rcx,%r10
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
ffffffff8101c59f:	b9 80 04 00 00       	mov    $0x480,%ecx
ffffffff8101c5a4:	48 f7 d0             	not    %rax
ffffffff8101c5a7:	48 89 05 82 38 fe 3e 	mov    %rax,0x3efe3882(%rip)        # ffffffffbffffe30 <_ZN4Vmcs11fix_cr4_clrE>
ffffffff8101c5ae:	0f 32                	rdmsr  
            return static_cast<T>(static_cast<uint64>(h) << 32 | l);
ffffffff8101c5b0:	48 c1 e2 20          	shl    $0x20,%rdx
ffffffff8101c5b4:	48 89 d1             	mov    %rdx,%rcx
ffffffff8101c5b7:	48 09 c1             	or     %rax,%rcx
ffffffff8101c5ba:	48 89 0d bf 38 fe 3e 	mov    %rcx,0x3efe38bf(%rip)        # ffffffffbffffe80 <_ZN4Vmcs5basicE>

    basic.val       = Msr::read<uint64>(Msr::IA32_VMX_BASIC);
    ctrl_exi.val    = Msr::read<uint64>(basic.ctrl ? Msr::IA32_VMX_TRUE_EXIT  : Msr::IA32_VMX_CTRL_EXIT);
ffffffff8101c5c1:	40 8a 3d be 38 fe 3e 	mov    0x3efe38be(%rip),%dil        # ffffffffbffffe86 <_ZN4Vmcs5basicE+0x6>
ffffffff8101c5c8:	83 e7 80             	and    $0xffffff80,%edi
ffffffff8101c5cb:	40 80 ff 01          	cmp    $0x1,%dil
ffffffff8101c5cf:	19 c9                	sbb    %ecx,%ecx
ffffffff8101c5d1:	83 e1 f4             	and    $0xfffffff4,%ecx
ffffffff8101c5d4:	81 c1 8f 04 00 00    	add    $0x48f,%ecx
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
ffffffff8101c5da:	0f 32                	rdmsr  
            return static_cast<T>(static_cast<uint64>(h) << 32 | l);
ffffffff8101c5dc:	48 c1 e2 20          	shl    $0x20,%rdx
ffffffff8101c5e0:	48 89 d1             	mov    %rdx,%rcx
ffffffff8101c5e3:	48 09 c1             	or     %rax,%rcx
    ctrl_ent.val    = Msr::read<uint64>(basic.ctrl ? Msr::IA32_VMX_TRUE_ENTRY : Msr::IA32_VMX_CTRL_ENTRY);
ffffffff8101c5e6:	40 80 ff 01          	cmp    $0x1,%dil
ffffffff8101c5ea:	48 89 0d 67 38 fe 3e 	mov    %rcx,0x3efe3867(%rip)        # ffffffffbffffe58 <_ZN4Vmcs8ctrl_exiE>
ffffffff8101c5f1:	19 c9                	sbb    %ecx,%ecx
ffffffff8101c5f3:	83 e1 f4             	and    $0xfffffff4,%ecx
ffffffff8101c5f6:	81 c1 90 04 00 00    	add    $0x490,%ecx
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
ffffffff8101c5fc:	0f 32                	rdmsr  
            return static_cast<T>(static_cast<uint64>(h) << 32 | l);
ffffffff8101c5fe:	48 c1 e2 20          	shl    $0x20,%rdx
ffffffff8101c602:	48 89 d1             	mov    %rdx,%rcx
ffffffff8101c605:	48 09 c1             	or     %rax,%rcx
    ctrl_pin.val    = Msr::read<uint64>(basic.ctrl ? Msr::IA32_VMX_TRUE_PIN   : Msr::IA32_VMX_CTRL_PIN);
ffffffff8101c608:	40 80 ff 01          	cmp    $0x1,%dil
ffffffff8101c60c:	48 89 0d 3d 38 fe 3e 	mov    %rcx,0x3efe383d(%rip)        # ffffffffbffffe50 <_ZN4Vmcs8ctrl_entE>
ffffffff8101c613:	19 c9                	sbb    %ecx,%ecx
ffffffff8101c615:	83 e1 f4             	and    $0xfffffff4,%ecx
ffffffff8101c618:	81 c1 8d 04 00 00    	add    $0x48d,%ecx
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
ffffffff8101c61e:	0f 32                	rdmsr  
            return static_cast<T>(static_cast<uint64>(h) << 32 | l);
ffffffff8101c620:	48 c1 e2 20          	shl    $0x20,%rdx
ffffffff8101c624:	48 89 d1             	mov    %rdx,%rcx
ffffffff8101c627:	48 09 c1             	or     %rax,%rcx
    ctrl_cpu[0].val = Msr::read<uint64>(basic.ctrl ? Msr::IA32_VMX_TRUE_CPU0  : Msr::IA32_VMX_CTRL_CPU0);
ffffffff8101c62a:	40 80 ff 01          	cmp    $0x1,%dil
ffffffff8101c62e:	48 89 0d 3b 38 fe 3e 	mov    %rcx,0x3efe383b(%rip)        # ffffffffbffffe70 <_ZN4Vmcs8ctrl_pinE>
ffffffff8101c635:	19 c9                	sbb    %ecx,%ecx
ffffffff8101c637:	83 e1 f4             	and    $0xfffffff4,%ecx
ffffffff8101c63a:	81 c1 8e 04 00 00    	add    $0x48e,%ecx
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
ffffffff8101c640:	0f 32                	rdmsr  
            return static_cast<T>(static_cast<uint64>(h) << 32 | l);
ffffffff8101c642:	48 c1 e2 20          	shl    $0x20,%rdx
ffffffff8101c646:	48 89 d1             	mov    %rdx,%rcx
ffffffff8101c649:	48 09 c1             	or     %rax,%rcx
ffffffff8101c64c:	48 89 0d 0d 38 fe 3e 	mov    %rcx,0x3efe380d(%rip)        # ffffffffbffffe60 <_ZN4Vmcs8ctrl_cpuE>

    if (has_secondary())
ffffffff8101c653:	83 3d 0a 38 fe 3e 00 	cmpl   $0x0,0x3efe380a(%rip)        # ffffffffbffffe64 <_ZN4Vmcs8ctrl_cpuE+0x4>
ffffffff8101c65a:	79 18                	jns    ffffffff8101c674 <_ZN4Vmcs4initEv+0x182>
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
ffffffff8101c65c:	b9 8b 04 00 00       	mov    $0x48b,%ecx
ffffffff8101c661:	0f 32                	rdmsr  
            return static_cast<T>(static_cast<uint64>(h) << 32 | l);
ffffffff8101c663:	48 c1 e2 20          	shl    $0x20,%rdx
ffffffff8101c667:	48 89 d1             	mov    %rdx,%rcx
ffffffff8101c66a:	48 09 c1             	or     %rax,%rcx
ffffffff8101c66d:	48 89 0d f4 37 fe 3e 	mov    %rcx,0x3efe37f4(%rip)        # ffffffffbffffe68 <_ZN4Vmcs8ctrl_cpuE+0x8>
        {
            return has_vpid() ? read (VPID) : 0;
        }

        static bool has_secondary() { return ctrl_cpu[0].clr & CPU_SECONDARY; }
        static bool has_ept()       { return ctrl_cpu[1].clr & CPU_EPT; }
ffffffff8101c674:	44 8b 1d f1 37 fe 3e 	mov    0x3efe37f1(%rip),%r11d        # ffffffffbffffe6c <_ZN4Vmcs8ctrl_cpuE+0xc>
ffffffff8101c67b:	44 89 df             	mov    %r11d,%edi
ffffffff8101c67e:	83 e7 02             	and    $0x2,%edi
        ctrl_cpu[1].val = Msr::read<uint64>(Msr::IA32_VMX_CTRL_CPU1);
    if (has_ept() || has_vpid())
ffffffff8101c681:	41 f6 c3 22          	test   $0x22,%r11b
ffffffff8101c685:	0f 85 3b 01 00 00    	jne    ffffffff8101c7c6 <_ZN4Vmcs4initEv+0x2d4>
        ept_vpid.val = Msr::read<uint64>(Msr::IA32_VMX_EPT_VPID);
    if (has_ept())
ffffffff8101c68b:	85 ff                	test   %edi,%edi
ffffffff8101c68d:	74 33                	je     ffffffff8101c6c2 <_ZN4Vmcs4initEv+0x1d0>
        Ept::ord = min (Ept::ord, static_cast<mword>(bit_scan_reverse (static_cast<mword>(ept_vpid.super)) + 2) * Ept::bpl() - 1);
ffffffff8101c68f:	8a 05 e5 37 fe 3e    	mov    0x3efe37e5(%rip),%al        # ffffffffbffffe7a <_ZN4Vmcs8ept_vpidE+0x2>

ALWAYS_INLINE
inline long int bit_scan_reverse (mword val)
{
    if (EXPECT_FALSE (!val))
        return -1;
ffffffff8101c695:	48 83 cf ff          	or     $0xffffffffffffffff,%rdi
#include "util.hpp"

ALWAYS_INLINE
inline long int bit_scan_reverse (mword val)
{
    if (EXPECT_FALSE (!val))
ffffffff8101c699:	83 e0 03             	and    $0x3,%eax
ffffffff8101c69c:	74 04                	je     ffffffff8101c6a2 <_ZN4Vmcs4initEv+0x1b0>
        return -1;

    asm volatile ("bsr %1, %0" : "=r" (val) : "rm" (val));

    return val;
ffffffff8101c69e:	48 0f bd f8          	bsr    %rax,%rdi
ffffffff8101c6a2:	48 83 c7 02          	add    $0x2,%rdi
ffffffff8101c6a6:	48 8b 05 33 55 00 00 	mov    0x5533(%rip),%rax        # ffffffff81021be0 <_ZN3Ept3ordE>
ffffffff8101c6ad:	48 8d 3c ff          	lea    (%rdi,%rdi,8),%rdi
ffffffff8101c6b1:	48 ff cf             	dec    %rdi
ffffffff8101c6b4:	48 39 c7             	cmp    %rax,%rdi
ffffffff8101c6b7:	48 0f 47 f8          	cmova  %rax,%rdi
ffffffff8101c6bb:	48 89 3d 1e 55 00 00 	mov    %rdi,0x551e(%rip)        # ffffffff81021be0 <_ZN3Ept3ordE>
    if (has_urg())
ffffffff8101c6c2:	41 f6 c3 80          	test   $0x80,%r11b
ffffffff8101c6c6:	74 0e                	je     ffffffff8101c6d6 <_ZN4Vmcs4initEv+0x1e4>
        fix_cr0_set &= ~(Cpu::CR0_PG | Cpu::CR0_PE);
ffffffff8101c6c8:	41 81 e0 fe ff ff 7f 	and    $0x7ffffffe,%r8d
ffffffff8101c6cf:	4c 89 05 72 37 fe 3e 	mov    %r8,0x3efe3772(%rip)        # ffffffffbffffe48 <_ZN4Vmcs11fix_cr0_setE>

    fix_cr0_clr |= Cpu::CR0_CD | Cpu::CR0_NW;
ffffffff8101c6d6:	48 81 ce 00 00 00 60 	or     $0x60000000,%rsi

    ctrl_cpu[0].set |= CPU_HLT | CPU_IO | CPU_IO_BITMAP | CPU_SECONDARY;
ffffffff8101c6dd:	81 0d 79 37 fe 3e 80 	orl    $0x83000080,0x3efe3779(%rip)        # ffffffffbffffe60 <_ZN4Vmcs8ctrl_cpuE>
ffffffff8101c6e4:	00 00 83 
    ctrl_cpu[1].set |= CPU_VPID | CPU_URG;
ffffffff8101c6e7:	81 0d 77 37 fe 3e a0 	orl    $0xa0,0x3efe3777(%rip)        # ffffffffbffffe68 <_ZN4Vmcs8ctrl_cpuE+0x8>
ffffffff8101c6ee:	00 00 00 

    if (Cmdline::vtlb || !ept_vpid.invept)
ffffffff8101c6f1:	80 3d a4 56 00 00 00 	cmpb   $0x0,0x56a4(%rip)        # ffffffff81021d9c <_ZN7Cmdline4vtlbE>
    if (has_ept())
        Ept::ord = min (Ept::ord, static_cast<mword>(bit_scan_reverse (static_cast<mword>(ept_vpid.super)) + 2) * Ept::bpl() - 1);
    if (has_urg())
        fix_cr0_set &= ~(Cpu::CR0_PG | Cpu::CR0_PE);

    fix_cr0_clr |= Cpu::CR0_CD | Cpu::CR0_NW;
ffffffff8101c6f8:	48 89 35 41 37 fe 3e 	mov    %rsi,0x3efe3741(%rip)        # ffffffffbffffe40 <_ZN4Vmcs11fix_cr0_clrE>

    ctrl_cpu[0].set |= CPU_HLT | CPU_IO | CPU_IO_BITMAP | CPU_SECONDARY;
    ctrl_cpu[1].set |= CPU_VPID | CPU_URG;

    if (Cmdline::vtlb || !ept_vpid.invept)
ffffffff8101c6ff:	75 09                	jne    ffffffff8101c70a <_ZN4Vmcs4initEv+0x218>
ffffffff8101c701:	f6 05 72 37 fe 3e 10 	testb  $0x10,0x3efe3772(%rip)        # ffffffffbffffe7a <_ZN4Vmcs8ept_vpidE+0x2>
ffffffff8101c708:	75 0b                	jne    ffffffff8101c715 <_ZN4Vmcs4initEv+0x223>
        ctrl_cpu[1].clr &= ~(CPU_EPT | CPU_URG);
ffffffff8101c70a:	41 80 e3 7d          	and    $0x7d,%r11b
ffffffff8101c70e:	44 89 1d 57 37 fe 3e 	mov    %r11d,0x3efe3757(%rip)        # ffffffffbffffe6c <_ZN4Vmcs8ctrl_cpuE+0xc>
    if (Cmdline::novpid || !ept_vpid.invvpid)
ffffffff8101c715:	80 3d 7c 56 00 00 00 	cmpb   $0x0,0x567c(%rip)        # ffffffff81021d98 <_ZN7Cmdline6novpidE>
ffffffff8101c71c:	75 09                	jne    ffffffff8101c727 <_ZN4Vmcs4initEv+0x235>
ffffffff8101c71e:	f6 05 57 37 fe 3e 01 	testb  $0x1,0x3efe3757(%rip)        # ffffffffbffffe7c <_ZN4Vmcs8ept_vpidE+0x4>
ffffffff8101c725:	75 07                	jne    ffffffff8101c72e <_ZN4Vmcs4initEv+0x23c>
        ctrl_cpu[1].clr &= ~CPU_VPID;
ffffffff8101c727:	83 25 3e 37 fe 3e df 	andl   $0xffffffdf,0x3efe373e(%rip)        # ffffffffbffffe6c <_ZN4Vmcs8ctrl_cpuE+0xc>

ALWAYS_INLINE
static inline mword get_cr0()
{
    mword cr0;
    asm volatile ("mov %%cr0, %0" : "=r" (cr0));
ffffffff8101c72e:	0f 20 c0             	mov    %cr0,%rax

    set_cr0 ((get_cr0() & ~fix_cr0_clr) | fix_cr0_set);
ffffffff8101c731:	48 f7 d6             	not    %rsi
ffffffff8101c734:	48 21 c6             	and    %rax,%rsi
ffffffff8101c737:	48 0b 35 0a 37 fe 3e 	or     0x3efe370a(%rip),%rsi        # ffffffffbffffe48 <_ZN4Vmcs11fix_cr0_setE>
}

ALWAYS_INLINE
static inline void set_cr0 (mword cr0)
{
    asm volatile ("mov %0, %%cr0" : : "r" (cr0));
ffffffff8101c73e:	0f 22 c6             	mov    %rsi,%cr0

ALWAYS_INLINE
static inline mword get_cr4()
{
    mword cr4;
    asm volatile ("mov %%cr4, %0" : "=r" (cr4));
ffffffff8101c741:	0f 20 e0             	mov    %cr4,%rax
    set_cr4 ((get_cr4() & ~fix_cr4_clr) | fix_cr4_set);
ffffffff8101c744:	49 21 c2             	and    %rax,%r10
ffffffff8101c747:	4d 09 d1             	or     %r10,%r9
}

ALWAYS_INLINE
static inline void set_cr4 (mword cr4)
{
    asm volatile ("mov %0, %%cr4" : : "r" (cr4));
ffffffff8101c74a:	41 0f 22 e1          	mov    %r9,%cr4
        };

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota)
        {
            return Buddy::allocator.alloc (0, quota, Buddy::FILL_0);
ffffffff8101c74e:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff8101c753:	31 f6                	xor    %esi,%esi
ffffffff8101c755:	48 c7 c2 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rdx
ffffffff8101c75c:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff8101c763:	e8 8a 51 fe ff       	callq  ffffffff810018f2 <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
        }

        Vmcs (mword, mword, mword, uint64);

        ALWAYS_INLINE
        inline Vmcs() : rev (basic.revision)
ffffffff8101c768:	8b 15 12 37 fe 3e    	mov    0x3efe3712(%rip),%edx        # ffffffffbffffe80 <_ZN4Vmcs5basicE>
        {
            uint64 phys = Buddy::ptr_to_phys (this);
            Console::print("VMX OK");
ffffffff8101c76e:	48 c7 c7 a6 14 02 81 	mov    $0xffffffff810214a6,%rdi
        }

        Vmcs (mword, mword, mword, uint64);

        ALWAYS_INLINE
        inline Vmcs() : rev (basic.revision)
ffffffff8101c775:	89 10                	mov    %edx,(%rax)
ffffffff8101c777:	48 2d 00 00 c0 80    	sub    $0xffffffff80c00000,%rax
ffffffff8101c77d:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
        {
            uint64 phys = Buddy::ptr_to_phys (this);
            Console::print("VMX OK");
ffffffff8101c782:	31 c0                	xor    %eax,%eax
ffffffff8101c784:	e8 03 59 fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
            bool ret;
            asm volatile ("vmxon %1; seta %0" : "=q" (ret) : "m" (phys) : "cc");
ffffffff8101c789:	f3 0f c7 74 24 08    	vmxon  0x8(%rsp)
ffffffff8101c78f:	0f 97 c0             	seta   %al
            assert (ret);
ffffffff8101c792:	84 c0                	test   %al,%al
ffffffff8101c794:	75 4d                	jne    ffffffff8101c7e3 <_ZN4Vmcs4initEv+0x2f1>
ffffffff8101c796:	49 c7 c0 b0 14 02 81 	mov    $0xffffffff810214b0,%r8
ffffffff8101c79d:	b9 7e 01 00 00       	mov    $0x17e,%ecx
ffffffff8101c7a2:	48 c7 c2 72 db 01 81 	mov    $0xffffffff8101db72,%rdx
ffffffff8101c7a9:	48 c7 c6 e1 db 01 81 	mov    $0xffffffff8101dbe1,%rsi
ffffffff8101c7b0:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8101c7b7:	e8 94 57 fe ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>

        template <typename T>
        ALWAYS_INLINE
        static inline void clr_mask (T &ptr, T v) { __sync_and_and_fetch (&ptr, ~v); }
ffffffff8101c7bc:	f0 83 25 4c a8 14 00 	lock andl $0xfffffffd,0x14a84c(%rip)        # ffffffff81167010 <PAGE_H+0x10>
ffffffff8101c7c3:	fd 
ffffffff8101c7c4:	eb 1d                	jmp    ffffffff8101c7e3 <_ZN4Vmcs4initEv+0x2f1>
        template <typename T>
        ALWAYS_INLINE
        static inline T read (Register msr)
        {
            mword h, l;
            asm volatile ("rdmsr" : "=a" (l), "=d" (h) : "c" (msr));
ffffffff8101c7c6:	b9 8c 04 00 00       	mov    $0x48c,%ecx
ffffffff8101c7cb:	0f 32                	rdmsr  
            return static_cast<T>(static_cast<uint64>(h) << 32 | l);
ffffffff8101c7cd:	48 c1 e2 20          	shl    $0x20,%rdx
ffffffff8101c7d1:	48 89 d1             	mov    %rdx,%rcx
ffffffff8101c7d4:	48 09 c1             	or     %rax,%rcx
ffffffff8101c7d7:	48 89 0d 9a 36 fe 3e 	mov    %rcx,0x3efe369a(%rip)        # ffffffffbffffe78 <_ZN4Vmcs8ept_vpidE>
ffffffff8101c7de:	e9 a8 fe ff ff       	jmpq   ffffffff8101c68b <_ZN4Vmcs4initEv+0x199>

    Vmcs *root = new (Pd::kern.quota) Vmcs;

    trace (TRACE_VMX, "VMCS:%#010lx REV:%#x EPT:%d URG:%d VNMI:%d VPID:%d", Buddy::ptr_to_phys (root), basic.revision, has_ept(), has_urg(), has_vnmi(), has_vpid());
}
ffffffff8101c7e3:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8101c7e7:	5b                   	pop    %rbx
ffffffff8101c7e8:	c3                   	retq   
ffffffff8101c7e9:	90                   	nop

ffffffff8101c7ea <_ZN4Vmcs5cloneEv>:

Vmcs* Vmcs::clone() {
ffffffff8101c7ea:	55                   	push   %rbp
ffffffff8101c7eb:	53                   	push   %rbx
        };

        ALWAYS_INLINE
        static inline void *operator new (size_t, Quota &quota)
        {
            return Buddy::allocator.alloc (0, quota, Buddy::FILL_0);
ffffffff8101c7ec:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff8101c7f1:	48 c7 c2 a8 3f 16 81 	mov    $0xffffffff81163fa8,%rdx
ffffffff8101c7f8:	31 f6                	xor    %esi,%esi
ffffffff8101c7fa:	48 89 fd             	mov    %rdi,%rbp
ffffffff8101c7fd:	48 83 ec 18          	sub    $0x18,%rsp
ffffffff8101c801:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff8101c808:	e8 e5 50 fe ff       	callq  ffffffff810018f2 <_ZN5Buddy5allocEtR5QuotaNS_4FillE>
ffffffff8101c80d:	48 89 c3             	mov    %rax,%rbx
        }

        Vmcs (mword, mword, mword, uint64);

        ALWAYS_INLINE
        inline Vmcs() : rev (basic.revision)
ffffffff8101c810:	8b 05 6a 36 fe 3e    	mov    0x3efe366a(%rip),%eax        # ffffffffbffffe80 <_ZN4Vmcs5basicE>
        {
            uint64 phys = Buddy::ptr_to_phys (this);
            Console::print("VMX OK");
ffffffff8101c816:	48 c7 c7 a6 14 02 81 	mov    $0xffffffff810214a6,%rdi
        }

        Vmcs (mword, mword, mword, uint64);

        ALWAYS_INLINE
        inline Vmcs() : rev (basic.revision)
ffffffff8101c81d:	89 03                	mov    %eax,(%rbx)
ffffffff8101c81f:	48 89 d8             	mov    %rbx,%rax
ffffffff8101c822:	48 2d 00 00 c0 80    	sub    $0xffffffff80c00000,%rax
ffffffff8101c828:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
        {
            uint64 phys = Buddy::ptr_to_phys (this);
            Console::print("VMX OK");
ffffffff8101c82d:	31 c0                	xor    %eax,%eax
ffffffff8101c82f:	e8 58 58 fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
            bool ret;
            asm volatile ("vmxon %1; seta %0" : "=q" (ret) : "m" (phys) : "cc");
ffffffff8101c834:	f3 0f c7 74 24 08    	vmxon  0x8(%rsp)
ffffffff8101c83a:	0f 97 c0             	seta   %al
            assert (ret);
ffffffff8101c83d:	84 c0                	test   %al,%al
ffffffff8101c83f:	75 26                	jne    ffffffff8101c867 <_ZN4Vmcs5cloneEv+0x7d>
ffffffff8101c841:	49 c7 c0 b0 14 02 81 	mov    $0xffffffff810214b0,%r8
ffffffff8101c848:	b9 7e 01 00 00       	mov    $0x17e,%ecx
ffffffff8101c84d:	48 c7 c2 72 db 01 81 	mov    $0xffffffff8101db72,%rdx
ffffffff8101c854:	48 c7 c6 e1 db 01 81 	mov    $0xffffffff8101dbe1,%rsi
ffffffff8101c85b:	48 c7 c7 28 d2 01 81 	mov    $0xffffffff8101d228,%rdi
ffffffff8101c862:	e8 e9 56 fe ff       	callq  ffffffff81001f50 <_ZN7Console5panicEPKcz>
    const char *s;
    char *d;

    s = reinterpret_cast<const char*> (src);
    d = reinterpret_cast<char*> (dst);
    if (s < d && s + n > d) {
ffffffff8101c867:	48 39 dd             	cmp    %rbx,%rbp
ffffffff8101c86a:	73 44                	jae    ffffffff8101c8b0 <_ZN4Vmcs5cloneEv+0xc6>
ffffffff8101c86c:	48 8d 85 00 10 00 00 	lea    0x1000(%rbp),%rax
ffffffff8101c873:	48 39 d8             	cmp    %rbx,%rax
ffffffff8101c876:	76 38                	jbe    ffffffff8101c8b0 <_ZN4Vmcs5cloneEv+0xc6>
ffffffff8101c878:	48 09 d8             	or     %rbx,%rax
        s += n;
        d += n;
        if ((mword) s % 4 == 0 && (mword) d % 4 == 0 && n % 4 == 0)
ffffffff8101c87b:	a8 03                	test   $0x3,%al
ffffffff8101c87d:	75 18                	jne    ffffffff8101c897 <_ZN4Vmcs5cloneEv+0xad>
            asm volatile("std; rep movsl\n"
                        ::"D" (d - 4), "S" (s - 4), "c" (n / 4) : "cc", "memory");
ffffffff8101c87f:	48 8d bb fc 0f 00 00 	lea    0xffc(%rbx),%rdi
ffffffff8101c886:	48 8d b5 fc 0f 00 00 	lea    0xffc(%rbp),%rsi
ffffffff8101c88d:	b9 00 04 00 00       	mov    $0x400,%ecx
ffffffff8101c892:	fd                   	std    
ffffffff8101c893:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
ffffffff8101c895:	eb 16                	jmp    ffffffff8101c8ad <_ZN4Vmcs5cloneEv+0xc3>
        else
            asm volatile("std; rep movsb\n"
                        ::"D" (d - 1), "S" (s - 1), "c" (n) : "cc", "memory");
ffffffff8101c897:	48 8d bb ff 0f 00 00 	lea    0xfff(%rbx),%rdi
ffffffff8101c89e:	48 8d b5 ff 0f 00 00 	lea    0xfff(%rbp),%rsi
ffffffff8101c8a5:	b9 00 10 00 00       	mov    $0x1000,%ecx
ffffffff8101c8aa:	fd                   	std    
ffffffff8101c8ab:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
        // Some versions of GCC rely on DF being clear
        asm volatile("cld" :: : "cc");
ffffffff8101c8ad:	fc                   	cld    
ffffffff8101c8ae:	eb 28                	jmp    ffffffff8101c8d8 <_ZN4Vmcs5cloneEv+0xee>
ffffffff8101c8b0:	48 89 e8             	mov    %rbp,%rax
ffffffff8101c8b3:	48 09 d8             	or     %rbx,%rax
    } else {
        if ((mword) s % 4 == 0 && (mword) d % 4 == 0 && n % 4 == 0)
ffffffff8101c8b6:	a8 03                	test   $0x3,%al
ffffffff8101c8b8:	75 10                	jne    ffffffff8101c8ca <_ZN4Vmcs5cloneEv+0xe0>
            asm volatile("cld; rep movsl\n"
                        ::"D" (d), "S" (s), "c" (n / 4) : "cc", "memory");
ffffffff8101c8ba:	b9 00 04 00 00       	mov    $0x400,%ecx
ffffffff8101c8bf:	48 89 df             	mov    %rbx,%rdi
ffffffff8101c8c2:	48 89 ee             	mov    %rbp,%rsi
ffffffff8101c8c5:	fc                   	cld    
ffffffff8101c8c6:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
ffffffff8101c8c8:	eb 0e                	jmp    ffffffff8101c8d8 <_ZN4Vmcs5cloneEv+0xee>
        else
            asm volatile("cld; rep movsb\n"
                        ::"D" (d), "S" (s), "c" (n) : "cc", "memory");
ffffffff8101c8ca:	b9 00 10 00 00       	mov    $0x1000,%ecx
ffffffff8101c8cf:	48 89 df             	mov    %rbx,%rdi
ffffffff8101c8d2:	48 89 ee             	mov    %rbp,%rsi
ffffffff8101c8d5:	fc                   	cld    
ffffffff8101c8d6:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
    Vmcs *vmcs = new (Pd::kern.quota) Vmcs;
    memcpy(vmcs, this, PAGE_SIZE);
    return vmcs;
}
ffffffff8101c8d8:	48 83 c4 18          	add    $0x18,%rsp
ffffffff8101c8dc:	48 89 d8             	mov    %rbx,%rax
ffffffff8101c8df:	5b                   	pop    %rbx
ffffffff8101c8e0:	5d                   	pop    %rbp
ffffffff8101c8e1:	c3                   	retq   

ffffffff8101c8e2 <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_>:
#include "stdio.hpp"
#include "vtlb.hpp"
#include "ec.hpp"
#include "svm.hpp"

size_t Vtlb::gwalk(Exc_regs *regs, mword gla, mword &gpa, mword &attr, mword &error) {
ffffffff8101c8e2:	41 54                	push   %r12
ffffffff8101c8e4:	55                   	push   %rbp
ffffffff8101c8e5:	53                   	push   %rbx
    if (EXPECT_FALSE(!(regs->cr0_shadow & Cpu::CR0_PG))) {
ffffffff8101c8e6:	48 8b af 90 00 00 00 	mov    0x90(%rdi),%rbp
ffffffff8101c8ed:	f7 c5 00 00 00 80    	test   $0x80000000,%ebp
ffffffff8101c8f3:	75 08                	jne    ffffffff8101c8fd <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0x1b>
        gpa = gla;
ffffffff8101c8f5:	48 89 32             	mov    %rsi,(%rdx)
ffffffff8101c8f8:	e9 a4 00 00 00       	jmpq   ffffffff8101c9a1 <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0xbf>
        return ~0UL;
    }

    bool pse = regs->cr4_shadow & (Cpu::CR4_PSE | Cpu::CR4_PAE);
ffffffff8101c8fd:	48 8b 9f a0 00 00 00 	mov    0xa0(%rdi),%rbx
    bool pge = regs->cr4_shadow & Cpu::CR4_PGE;
    bool wp = regs->cr0_shadow & Cpu::CR0_WP;

    unsigned lev = 2;

    for (uint32 e, *pte = reinterpret_cast<uint32 *> (regs->cr3_shadow & ~PAGE_MASK);; pte = reinterpret_cast<uint32 *> (e & ~PAGE_MASK)) {
ffffffff8101c904:	48 8b bf 98 00 00 00 	mov    0x98(%rdi),%rdi
ffffffff8101c90b:	49 89 cb             	mov    %rcx,%r11
        return ~0UL;
    }

    bool pse = regs->cr4_shadow & (Cpu::CR4_PSE | Cpu::CR4_PAE);
    bool pge = regs->cr4_shadow & Cpu::CR4_PGE;
    bool wp = regs->cr0_shadow & Cpu::CR0_WP;
ffffffff8101c90e:	81 e5 00 00 01 00    	and    $0x10000,%ebp

    unsigned lev = 2;

    for (uint32 e, *pte = reinterpret_cast<uint32 *> (regs->cr3_shadow & ~PAGE_MASK);; pte = reinterpret_cast<uint32 *> (e & ~PAGE_MASK)) {
ffffffff8101c914:	48 89 f8             	mov    %rdi,%rax

        unsigned shift = --lev * 10 + PAGE_BITS;
        pte += gla >> shift & ((1UL << 10) - 1);
ffffffff8101c917:	48 89 f7             	mov    %rsi,%rdi
    if (EXPECT_FALSE(!(regs->cr0_shadow & Cpu::CR0_PG))) {
        gpa = gla;
        return ~0UL;
    }

    bool pse = regs->cr4_shadow & (Cpu::CR4_PSE | Cpu::CR4_PAE);
ffffffff8101c91a:	49 89 dc             	mov    %rbx,%r12
    unsigned lev = 2;

    for (uint32 e, *pte = reinterpret_cast<uint32 *> (regs->cr3_shadow & ~PAGE_MASK);; pte = reinterpret_cast<uint32 *> (e & ~PAGE_MASK)) {

        unsigned shift = --lev * 10 + PAGE_BITS;
        pte += gla >> shift & ((1UL << 10) - 1);
ffffffff8101c91d:	48 c1 ef 14          	shr    $0x14,%rdi
    bool pge = regs->cr4_shadow & Cpu::CR4_PGE;
    bool wp = regs->cr0_shadow & Cpu::CR0_WP;

    unsigned lev = 2;

    for (uint32 e, *pte = reinterpret_cast<uint32 *> (regs->cr3_shadow & ~PAGE_MASK);; pte = reinterpret_cast<uint32 *> (e & ~PAGE_MASK)) {
ffffffff8101c921:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
    if (EXPECT_FALSE(!(regs->cr0_shadow & Cpu::CR0_PG))) {
        gpa = gla;
        return ~0UL;
    }

    bool pse = regs->cr4_shadow & (Cpu::CR4_PSE | Cpu::CR4_PAE);
ffffffff8101c927:	41 83 e4 30          	and    $0x30,%r12d
    unsigned lev = 2;

    for (uint32 e, *pte = reinterpret_cast<uint32 *> (regs->cr3_shadow & ~PAGE_MASK);; pte = reinterpret_cast<uint32 *> (e & ~PAGE_MASK)) {

        unsigned shift = --lev * 10 + PAGE_BITS;
        pte += gla >> shift & ((1UL << 10) - 1);
ffffffff8101c92b:	81 e7 fc 0f 00 00    	and    $0xffc,%edi
ffffffff8101c931:	48 01 c7             	add    %rax,%rdi
ffffffff8101c934:	8b 0f                	mov    (%rdi),%ecx
ffffffff8101c936:	48 83 c8 ff          	or     $0xffffffffffffffff,%rax

        if (User::peek(pte, e) != ~0UL) {
ffffffff8101c93a:	48 ff c0             	inc    %rax
ffffffff8101c93d:	41 89 c9             	mov    %ecx,%r9d
ffffffff8101c940:	75 5c                	jne    ffffffff8101c99e <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0xbc>
            gpa = reinterpret_cast<Paddr> (pte);
            return ~0UL;
        }

        if (EXPECT_FALSE(!(e & TLB_P)))
ffffffff8101c942:	f6 c1 01             	test   $0x1,%cl
ffffffff8101c945:	0f 84 a8 00 00 00    	je     ffffffff8101c9f3 <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0x111>
ffffffff8101c94b:	4d 89 ca             	mov    %r9,%r10
ffffffff8101c94e:	4d 23 13             	and    (%r11),%r10
            return 0;

        attr &= e & PAGE_MASK;
ffffffff8101c951:	41 81 e2 ff 0f 00 00 	and    $0xfff,%r10d

        if (lev && (!pse || !(e & TLB_S))) {
ffffffff8101c958:	4d 85 e4             	test   %r12,%r12
        }

        if (EXPECT_FALSE(!(e & TLB_P)))
            return 0;

        attr &= e & PAGE_MASK;
ffffffff8101c95b:	4d 89 13             	mov    %r10,(%r11)

        if (lev && (!pse || !(e & TLB_S))) {
ffffffff8101c95e:	74 05                	je     ffffffff8101c965 <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0x83>
ffffffff8101c960:	f6 c1 80             	test   $0x80,%cl
ffffffff8101c963:	75 62                	jne    ffffffff8101c9c7 <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0xe5>
        return val & TLB_F;
    }

    ALWAYS_INLINE
    static inline bool mark_pte(uint32 *pte, uint32 old, uint32 bits) {
        return EXPECT_TRUE((old & bits) == bits) || User::cmp_swap(pte, old, old | bits) == ~0UL;
ffffffff8101c965:	f6 c1 20             	test   $0x20,%cl
ffffffff8101c968:	75 12                	jne    ffffffff8101c97c <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0x9a>
ffffffff8101c96a:	41 89 c9             	mov    %ecx,%r9d
        static inline mword cmp_swap (T *addr, T o, T n)
        {
            mword ret;
            asm volatile ("1: lock; cmpxchg %3, %1; or $-1, %0; 2:"
                          ".section .fixup,\"a\"; .align 8;" EXPAND (WORD) " 1b,2b; .previous"
                          : "=a" (ret), "+m" (*addr) : "a" (o), "q" (n));
ffffffff8101c96d:	89 c8                	mov    %ecx,%eax
ffffffff8101c96f:	41 83 c9 20          	or     $0x20,%r9d
ffffffff8101c973:	f0 44 0f b1 0f       	lock cmpxchg %r9d,(%rdi)
ffffffff8101c978:	48 83 c8 ff          	or     $0xffffffffffffffff,%rax
    unsigned lev = 2;

    for (uint32 e, *pte = reinterpret_cast<uint32 *> (regs->cr3_shadow & ~PAGE_MASK);; pte = reinterpret_cast<uint32 *> (e & ~PAGE_MASK)) {

        unsigned shift = --lev * 10 + PAGE_BITS;
        pte += gla >> shift & ((1UL << 10) - 1);
ffffffff8101c97c:	48 89 f7             	mov    %rsi,%rdi
    bool pge = regs->cr4_shadow & Cpu::CR4_PGE;
    bool wp = regs->cr0_shadow & Cpu::CR0_WP;

    unsigned lev = 2;

    for (uint32 e, *pte = reinterpret_cast<uint32 *> (regs->cr3_shadow & ~PAGE_MASK);; pte = reinterpret_cast<uint32 *> (e & ~PAGE_MASK)) {
ffffffff8101c97f:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx

        unsigned shift = --lev * 10 + PAGE_BITS;
        pte += gla >> shift & ((1UL << 10) - 1);
ffffffff8101c985:	48 c1 ef 0a          	shr    $0xa,%rdi
ffffffff8101c989:	81 e7 fc 0f 00 00    	and    $0xffc,%edi
ffffffff8101c98f:	48 01 cf             	add    %rcx,%rdi
        static inline mword peek (T *addr, T &val)
        {
            mword ret;
            asm volatile ("1: mov %2, %1; or $-1, %0; 2:"
                          ".section .fixup,\"a\"; .align 8;" EXPAND (WORD) " 1b,2b; .previous"
                          : "=a" (ret), "=q" (val) : "m" (*addr));
ffffffff8101c992:	44 8b 0f             	mov    (%rdi),%r9d
ffffffff8101c995:	48 83 c8 ff          	or     $0xffffffffffffffff,%rax

        if (User::peek(pte, e) != ~0UL) {
ffffffff8101c999:	48 ff c0             	inc    %rax
ffffffff8101c99c:	74 0c                	je     ffffffff8101c9aa <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0xc8>
            gpa = reinterpret_cast<Paddr> (pte);
ffffffff8101c99e:	48 89 3a             	mov    %rdi,(%rdx)
            return ~0UL;
ffffffff8101c9a1:	48 83 c8 ff          	or     $0xffffffffffffffff,%rax
ffffffff8101c9a5:	e9 d4 00 00 00       	jmpq   ffffffff8101ca7e <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0x19c>
        }

        if (EXPECT_FALSE(!(e & TLB_P)))
ffffffff8101c9aa:	41 f6 c1 01          	test   $0x1,%r9b
ffffffff8101c9ae:	74 43                	je     ffffffff8101c9f3 <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0x111>
ffffffff8101c9b0:	4d 89 ca             	mov    %r9,%r10
ffffffff8101c9b3:	4d 23 13             	and    (%r11),%r10
    unsigned lev = 2;

    for (uint32 e, *pte = reinterpret_cast<uint32 *> (regs->cr3_shadow & ~PAGE_MASK);; pte = reinterpret_cast<uint32 *> (e & ~PAGE_MASK)) {

        unsigned shift = --lev * 10 + PAGE_BITS;
        pte += gla >> shift & ((1UL << 10) - 1);
ffffffff8101c9b6:	b9 0c 00 00 00       	mov    $0xc,%ecx
        }

        if (EXPECT_FALSE(!(e & TLB_P)))
            return 0;

        attr &= e & PAGE_MASK;
ffffffff8101c9bb:	41 81 e2 ff 0f 00 00 	and    $0xfff,%r10d
ffffffff8101c9c2:	4d 89 13             	mov    %r10,(%r11)
ffffffff8101c9c5:	eb 05                	jmp    ffffffff8101c9cc <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0xea>
    unsigned lev = 2;

    for (uint32 e, *pte = reinterpret_cast<uint32 *> (regs->cr3_shadow & ~PAGE_MASK);; pte = reinterpret_cast<uint32 *> (e & ~PAGE_MASK)) {

        unsigned shift = --lev * 10 + PAGE_BITS;
        pte += gla >> shift & ((1UL << 10) - 1);
ffffffff8101c9c7:	b9 16 00 00 00       	mov    $0x16,%ecx
        if (lev && (!pse || !(e & TLB_S))) {
            mark_pte(pte, e, TLB_A);
            continue;
        }

        if (EXPECT_FALSE(!wp && error == ERR_W))
ffffffff8101c9cc:	48 85 ed             	test   %rbp,%rbp
ffffffff8101c9cf:	75 0a                	jne    ffffffff8101c9db <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0xf9>
ffffffff8101c9d1:	49 83 38 02          	cmpq   $0x2,(%r8)
ffffffff8101c9d5:	0f 84 93 00 00 00    	je     ffffffff8101ca6e <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0x18c>
            attr = (attr & ~TLB_U) | TLB_W;

        if (EXPECT_FALSE((attr & error) != error)) {
ffffffff8101c9db:	4d 8b 13             	mov    (%r11),%r10
ffffffff8101c9de:	49 8b 00             	mov    (%r8),%rax
ffffffff8101c9e1:	4c 89 d5             	mov    %r10,%rbp
ffffffff8101c9e4:	48 21 c5             	and    %rax,%rbp
ffffffff8101c9e7:	48 39 c5             	cmp    %rax,%rbp
ffffffff8101c9ea:	74 0e                	je     ffffffff8101c9fa <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0x118>
            error |= ERR_P;
ffffffff8101c9ec:	48 83 c8 01          	or     $0x1,%rax
ffffffff8101c9f0:	49 89 00             	mov    %rax,(%r8)
            return 0;
ffffffff8101c9f3:	31 c0                	xor    %eax,%eax
ffffffff8101c9f5:	e9 84 00 00 00       	jmpq   ffffffff8101ca7e <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0x19c>
        }

        if (!(error & ERR_W) && !(e & TLB_D))
ffffffff8101c9fa:	40 80 e5 02          	and    $0x2,%bpl
ffffffff8101c9fe:	75 0d                	jne    ffffffff8101ca0d <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0x12b>
ffffffff8101ca00:	41 f6 c1 40          	test   $0x40,%r9b
ffffffff8101ca04:	75 07                	jne    ffffffff8101ca0d <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0x12b>
            attr &= ~TLB_W;
ffffffff8101ca06:	49 83 e2 fd          	and    $0xfffffffffffffffd,%r10
ffffffff8101ca0a:	4d 89 13             	mov    %r10,(%r11)

        mark_pte(pte, e, static_cast<uint32> ((attr & 3) << 5));
ffffffff8101ca0d:	41 8b 03             	mov    (%r11),%eax
ffffffff8101ca10:	45 89 c8             	mov    %r9d,%r8d
ffffffff8101ca13:	83 e0 03             	and    $0x3,%eax
ffffffff8101ca16:	c1 e0 05             	shl    $0x5,%eax
ffffffff8101ca19:	41 21 c0             	and    %eax,%r8d
ffffffff8101ca1c:	41 39 c0             	cmp    %eax,%r8d
ffffffff8101ca1f:	74 12                	je     ffffffff8101ca33 <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0x151>
ffffffff8101ca21:	44 09 c8             	or     %r9d,%eax
ffffffff8101ca24:	41 89 c0             	mov    %eax,%r8d
        static inline mword cmp_swap (T *addr, T o, T n)
        {
            mword ret;
            asm volatile ("1: lock; cmpxchg %3, %1; or $-1, %0; 2:"
                          ".section .fixup,\"a\"; .align 8;" EXPAND (WORD) " 1b,2b; .previous"
                          : "=a" (ret), "+m" (*addr) : "a" (o), "q" (n));
ffffffff8101ca27:	44 89 c8             	mov    %r9d,%eax
ffffffff8101ca2a:	f0 44 0f b1 07       	lock cmpxchg %r8d,(%rdi)
ffffffff8101ca2f:	48 83 c8 ff          	or     $0xffffffffffffffff,%rax

        attr |= e & TLB_UC;
ffffffff8101ca33:	44 89 c8             	mov    %r9d,%eax
ffffffff8101ca36:	83 e0 10             	and    $0x10,%eax
ffffffff8101ca39:	49 0b 03             	or     (%r11),%rax

        if (EXPECT_TRUE(pge) && (e & TLB_G))
ffffffff8101ca3c:	80 e3 80             	and    $0x80,%bl
ffffffff8101ca3f:	74 0c                	je     ffffffff8101ca4d <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0x16b>
ffffffff8101ca41:	41 f7 c1 00 01 00 00 	test   $0x100,%r9d
ffffffff8101ca48:	74 03                	je     ffffffff8101ca4d <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0x16b>
            attr |= TLB_M;
ffffffff8101ca4a:	80 cc 04             	or     $0x4,%ah
ffffffff8101ca4d:	49 89 03             	mov    %rax,(%r11)

        size_t size = 1UL << shift;
ffffffff8101ca50:	b8 01 00 00 00       	mov    $0x1,%eax

        gpa = (e & ~PAGE_MASK) | (gla & (size - 1));
ffffffff8101ca55:	41 81 e1 00 f0 ff ff 	and    $0xfffff000,%r9d
        attr |= e & TLB_UC;

        if (EXPECT_TRUE(pge) && (e & TLB_G))
            attr |= TLB_M;

        size_t size = 1UL << shift;
ffffffff8101ca5c:	48 d3 e0             	shl    %cl,%rax

        gpa = (e & ~PAGE_MASK) | (gla & (size - 1));
ffffffff8101ca5f:	48 8d 48 ff          	lea    -0x1(%rax),%rcx
ffffffff8101ca63:	48 21 ce             	and    %rcx,%rsi
ffffffff8101ca66:	49 09 f1             	or     %rsi,%r9
ffffffff8101ca69:	4c 89 0a             	mov    %r9,(%rdx)

        return size;
ffffffff8101ca6c:	eb 10                	jmp    ffffffff8101ca7e <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0x19c>
            mark_pte(pte, e, TLB_A);
            continue;
        }

        if (EXPECT_FALSE(!wp && error == ERR_W))
            attr = (attr & ~TLB_U) | TLB_W;
ffffffff8101ca6e:	49 83 e2 f9          	and    $0xfffffffffffffff9,%r10
ffffffff8101ca72:	49 83 ca 02          	or     $0x2,%r10
ffffffff8101ca76:	4d 89 13             	mov    %r10,(%r11)
ffffffff8101ca79:	e9 5d ff ff ff       	jmpq   ffffffff8101c9db <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_+0xf9>

        gpa = (e & ~PAGE_MASK) | (gla & (size - 1));

        return size;
    }
}
ffffffff8101ca7e:	5b                   	pop    %rbx
ffffffff8101ca7f:	5d                   	pop    %rbp
ffffffff8101ca80:	41 5c                	pop    %r12
ffffffff8101ca82:	c3                   	retq   
ffffffff8101ca83:	90                   	nop

ffffffff8101ca84 <_ZN4Vtlb5hwalkEmRmS0_S0_>:

size_t Vtlb::hwalk(mword gpa, mword &hpa, mword &attr, mword &error) {
ffffffff8101ca84:	55                   	push   %rbp
ffffffff8101ca85:	53                   	push   %rbx
ffffffff8101ca86:	48 89 cd             	mov    %rcx,%rbp
ffffffff8101ca89:	48 89 f8             	mov    %rdi,%rax
ffffffff8101ca8c:	48 89 d3             	mov    %rdx,%rbx
    mword ept_attr;

    size_t size = Pd::current->ept.lookup(gpa, hpa, ept_attr);
ffffffff8101ca8f:	48 89 f2             	mov    %rsi,%rdx

        return size;
    }
}

size_t Vtlb::hwalk(mword gpa, mword &hpa, mword &attr, mword &error) {
ffffffff8101ca92:	48 83 ec 18          	sub    $0x18,%rsp
    mword ept_attr;

    size_t size = Pd::current->ept.lookup(gpa, hpa, ept_attr);
ffffffff8101ca96:	48 8b 0d 73 25 fe 3e 	mov    0x3efe2573(%rip),%rcx        # ffffffffbffff010 <_ZN2Pd7currentE>
ffffffff8101ca9d:	48 89 c6             	mov    %rax,%rsi
ffffffff8101caa0:	48 8d b9 b0 02 00 00 	lea    0x2b0(%rcx),%rdi
ffffffff8101caa7:	48 8d 4c 24 08       	lea    0x8(%rsp),%rcx
ffffffff8101caac:	e8 ed 5c ff ff       	callq  ffffffff8101279e <_ZN3PteI3EptyLj4ELj9ELb0EE6lookupEyRmS2_>
ffffffff8101cab1:	45 31 c0             	xor    %r8d,%r8d

    if (size) {
ffffffff8101cab4:	48 85 c0             	test   %rax,%rax
ffffffff8101cab7:	74 40                	je     ffffffff8101caf9 <_ZN4Vtlb5hwalkEmRmS0_S0_+0x75>
        if (EXPECT_FALSE(!(ept_attr & Ept::EPT_W)))
ffffffff8101cab9:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
ffffffff8101cabe:	40 f6 c6 02          	test   $0x2,%sil
ffffffff8101cac2:	75 04                	jne    ffffffff8101cac8 <_ZN4Vtlb5hwalkEmRmS0_S0_+0x44>
            attr &= ~TLB_W;
ffffffff8101cac4:	48 83 23 fd          	andq   $0xfffffffffffffffd,(%rbx)

        if (EXPECT_FALSE((attr & error) != error)) {
ffffffff8101cac8:	48 8b 7d 00          	mov    0x0(%rbp),%rdi
ffffffff8101cacc:	49 89 c0             	mov    %rax,%r8
ffffffff8101cacf:	48 89 fa             	mov    %rdi,%rdx
ffffffff8101cad2:	48 23 13             	and    (%rbx),%rdx
ffffffff8101cad5:	48 39 fa             	cmp    %rdi,%rdx
ffffffff8101cad8:	74 1f                	je     ffffffff8101caf9 <_ZN4Vtlb5hwalkEmRmS0_S0_+0x75>
            error = (ept_attr & 7) << 3 | 1UL << !!(error & ERR_W);
ffffffff8101cada:	83 e6 07             	and    $0x7,%esi
ffffffff8101cadd:	83 e7 02             	and    $0x2,%edi
ffffffff8101cae0:	48 c1 e6 03          	shl    $0x3,%rsi
ffffffff8101cae4:	48 83 ff 01          	cmp    $0x1,%rdi
ffffffff8101cae8:	48 19 c0             	sbb    %rax,%rax
            return 0;
ffffffff8101caeb:	45 31 c0             	xor    %r8d,%r8d
    if (size) {
        if (EXPECT_FALSE(!(ept_attr & Ept::EPT_W)))
            attr &= ~TLB_W;

        if (EXPECT_FALSE((attr & error) != error)) {
            error = (ept_attr & 7) << 3 | 1UL << !!(error & ERR_W);
ffffffff8101caee:	48 83 c0 02          	add    $0x2,%rax
ffffffff8101caf2:	48 09 c6             	or     %rax,%rsi
ffffffff8101caf5:	48 89 75 00          	mov    %rsi,0x0(%rbp)
            return 0;
        }
    }

    return size;
}
ffffffff8101caf9:	48 83 c4 18          	add    $0x18,%rsp
ffffffff8101cafd:	4c 89 c0             	mov    %r8,%rax
ffffffff8101cb00:	5b                   	pop    %rbx
ffffffff8101cb01:	5d                   	pop    %rbp
ffffffff8101cb02:	c3                   	retq   
ffffffff8101cb03:	90                   	nop

ffffffff8101cb04 <_ZN4Vtlb10flush_ptabEb>:
        }
        return SUCCESS;
    }
}

void Vtlb::flush_ptab(bool full) {
ffffffff8101cb04:	48 8d 97 00 10 00 00 	lea    0x1000(%rdi),%rdx
    for (Vtlb *e = this; e < this +(1UL << bpl()); e++) {
ffffffff8101cb0b:	48 39 d7             	cmp    %rdx,%rdi
ffffffff8101cb0e:	74 23                	je     ffffffff8101cb33 <_ZN4Vtlb10flush_ptabEb+0x2f>

    P *walk(Quota &quota, E, unsigned long, bool = true);

    ALWAYS_INLINE
    inline bool present() const {
        return val & P::PTE_P;
ffffffff8101cb10:	48 8b 07             	mov    (%rdi),%rax

        if (EXPECT_TRUE(!e->present()))
ffffffff8101cb13:	a8 01                	test   $0x1,%al
ffffffff8101cb15:	74 16                	je     ffffffff8101cb2d <_ZN4Vtlb10flush_ptabEb+0x29>
            continue;

        if (EXPECT_FALSE(full))
ffffffff8101cb17:	40 84 f6             	test   %sil,%sil
ffffffff8101cb1a:	74 08                	je     ffffffff8101cb24 <_ZN4Vtlb10flush_ptabEb+0x20>
            e->val |= TLB_M;
ffffffff8101cb1c:	80 cc 04             	or     $0x4,%ah
ffffffff8101cb1f:	48 89 07             	mov    %rax,(%rdi)
ffffffff8101cb22:	eb 05                	jmp    ffffffff8101cb29 <_ZN4Vtlb10flush_ptabEb+0x25>

        else if (EXPECT_FALSE(e->mark()))
ffffffff8101cb24:	f6 c4 04             	test   $0x4,%ah
ffffffff8101cb27:	75 04                	jne    ffffffff8101cb2d <_ZN4Vtlb10flush_ptabEb+0x29>
            continue;

        e->val &= ~TLB_P;
ffffffff8101cb29:	48 83 27 fe          	andq   $0xfffffffffffffffe,(%rdi)
        return SUCCESS;
    }
}

void Vtlb::flush_ptab(bool full) {
    for (Vtlb *e = this; e < this +(1UL << bpl()); e++) {
ffffffff8101cb2d:	48 83 c7 08          	add    $0x8,%rdi
ffffffff8101cb31:	eb d8                	jmp    ffffffff8101cb0b <_ZN4Vtlb10flush_ptabEb+0x7>
        else if (EXPECT_FALSE(e->mark()))
            continue;

        e->val &= ~TLB_P;
    }
}
ffffffff8101cb33:	c3                   	retq   

ffffffff8101cb34 <_ZN4Vtlb12is_cow_faultEmmmm>:

    Counter::print<1, 16> (++Counter::vtlb_flush, Console_vga::COLOR_LIGHT_RED, SPN_VFL);
}

bool Vtlb::is_cow_fault(mword virt, mword gpa, Paddr hpa, mword err) {
    if (val && (addr() == (hpa & ~PAGE_MASK)) && (val & TLB_COW)) {
ffffffff8101cb34:	4c 8b 0f             	mov    (%rdi),%r9
ffffffff8101cb37:	4d 85 c9             	test   %r9,%r9
ffffffff8101cb3a:	74 39                	je     ffffffff8101cb75 <_ZN4Vtlb12is_cow_faultEmmmm+0x41>
    flush_ptab(full);

    Counter::print<1, 16> (++Counter::vtlb_flush, Console_vga::COLOR_LIGHT_RED, SPN_VFL);
}

bool Vtlb::is_cow_fault(mword virt, mword gpa, Paddr hpa, mword err) {
ffffffff8101cb3c:	41 56                	push   %r14
    if (val && (addr() == (hpa & ~PAGE_MASK)) && (val & TLB_COW)) {
ffffffff8101cb3e:	49 89 ca             	mov    %rcx,%r10
    flush_ptab(full);

    Counter::print<1, 16> (++Counter::vtlb_flush, Console_vga::COLOR_LIGHT_RED, SPN_VFL);
}

bool Vtlb::is_cow_fault(mword virt, mword gpa, Paddr hpa, mword err) {
ffffffff8101cb41:	41 55                	push   %r13
        return static_cast<mword> (val) & PAGE_MASK;
    }

    ALWAYS_INLINE
    inline Paddr addr() const {
        return static_cast<Paddr> (val) & ~((1UL << order()) - 1);
ffffffff8101cb43:	4d 89 ce             	mov    %r9,%r14
ffffffff8101cb46:	41 54                	push   %r12
ffffffff8101cb48:	55                   	push   %rbp
ffffffff8101cb49:	53                   	push   %rbx
ffffffff8101cb4a:	49 81 e6 00 f0 ff ff 	and    $0xfffffffffffff000,%r14
    if (val && (addr() == (hpa & ~PAGE_MASK)) && (val & TLB_COW)) {
ffffffff8101cb51:	49 81 e2 00 f0 ff ff 	and    $0xfffffffffffff000,%r10
            //            Console::print("Memory space  hpa: %08lx  val: %08x  err: %08lx", hpa, val, err);
            return true;
        } else
            return false;
    } else
        return false;
ffffffff8101cb58:	31 c0                	xor    %eax,%eax
    flush_ptab(full);

    Counter::print<1, 16> (++Counter::vtlb_flush, Console_vga::COLOR_LIGHT_RED, SPN_VFL);
}

bool Vtlb::is_cow_fault(mword virt, mword gpa, Paddr hpa, mword err) {
ffffffff8101cb5a:	48 83 ec 10          	sub    $0x10,%rsp
    if (val && (addr() == (hpa & ~PAGE_MASK)) && (val & TLB_COW)) {
ffffffff8101cb5e:	4d 39 d6             	cmp    %r10,%r14
ffffffff8101cb61:	0f 85 70 01 00 00    	jne    ffffffff8101ccd7 <_ZN4Vtlb12is_cow_faultEmmmm+0x1a3>
ffffffff8101cb67:	41 f7 c1 00 08 00 00 	test   $0x800,%r9d
ffffffff8101cb6e:	75 08                	jne    ffffffff8101cb78 <_ZN4Vtlb12is_cow_faultEmmmm+0x44>
ffffffff8101cb70:	e9 62 01 00 00       	jmpq   ffffffff8101ccd7 <_ZN4Vtlb12is_cow_faultEmmmm+0x1a3>
            //            Console::print("Memory space  hpa: %08lx  val: %08x  err: %08lx", hpa, val, err);
            return true;
        } else
            return false;
    } else
        return false;
ffffffff8101cb75:	31 c0                	xor    %eax,%eax
}
ffffffff8101cb77:	c3                   	retq   
ffffffff8101cb78:	49 89 d4             	mov    %rdx,%r12
}

bool Vtlb::is_cow_fault(mword virt, mword gpa, Paddr hpa, mword err) {
    if (val && (addr() == (hpa & ~PAGE_MASK)) && (val & TLB_COW)) {
        mword a = attr();
        if (!(val & TLB_P) && (val & PTE_COW_IO)) { //Memory mapped IO
ffffffff8101cb7b:	4c 89 ca             	mov    %r9,%rdx
        return val & P::PTE_S;
    }

    ALWAYS_INLINE
    inline mword attr() const {
        return static_cast<mword> (val) & PAGE_MASK;
ffffffff8101cb7e:	4c 89 cb             	mov    %r9,%rbx
ffffffff8101cb81:	83 e2 09             	and    $0x9,%edx
ffffffff8101cb84:	81 e3 ff 0f 00 00    	and    $0xfff,%ebx
ffffffff8101cb8a:	49 89 ca             	mov    %rcx,%r10
ffffffff8101cb8d:	48 83 fa 08          	cmp    $0x8,%rdx
ffffffff8101cb91:	49 89 f5             	mov    %rsi,%r13
ffffffff8101cb94:	48 89 fd             	mov    %rdi,%rbp
ffffffff8101cb97:	75 24                	jne    ffffffff8101cbbd <_ZN4Vtlb12is_cow_faultEmmmm+0x89>
            val |= TLB_P;
ffffffff8101cb99:	4c 89 ca             	mov    %r9,%rdx
            Console::print("IO space  hpa: %08lx  val: %08x  err: %08lx", hpa, val, err);
ffffffff8101cb9c:	4c 89 c1             	mov    %r8,%rcx
ffffffff8101cb9f:	4c 89 d6             	mov    %r10,%rsi

bool Vtlb::is_cow_fault(mword virt, mword gpa, Paddr hpa, mword err) {
    if (val && (addr() == (hpa & ~PAGE_MASK)) && (val & TLB_COW)) {
        mword a = attr();
        if (!(val & TLB_P) && (val & PTE_COW_IO)) { //Memory mapped IO
            val |= TLB_P;
ffffffff8101cba2:	48 83 ca 01          	or     $0x1,%rdx
            Console::print("IO space  hpa: %08lx  val: %08x  err: %08lx", hpa, val, err);
ffffffff8101cba6:	48 c7 c7 da 14 02 81 	mov    $0xffffffff810214da,%rdi
ffffffff8101cbad:	31 c0                	xor    %eax,%eax

bool Vtlb::is_cow_fault(mword virt, mword gpa, Paddr hpa, mword err) {
    if (val && (addr() == (hpa & ~PAGE_MASK)) && (val & TLB_COW)) {
        mword a = attr();
        if (!(val & TLB_P) && (val & PTE_COW_IO)) { //Memory mapped IO
            val |= TLB_P;
ffffffff8101cbaf:	48 89 55 00          	mov    %rdx,0x0(%rbp)
            Console::print("IO space  hpa: %08lx  val: %08x  err: %08lx", hpa, val, err);
ffffffff8101cbb3:	e8 d4 54 fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
ffffffff8101cbb8:	e9 18 01 00 00       	jmpq   ffffffff8101ccd5 <_ZN4Vtlb12is_cow_faultEmmmm+0x1a1>
            return true;
        } else if ((val & TLB_P) && (err & ERR_W) && !(val & TLB_W)) {
ffffffff8101cbbd:	41 f6 c1 01          	test   $0x1,%r9b
ffffffff8101cbc1:	0f 84 10 01 00 00    	je     ffffffff8101ccd7 <_ZN4Vtlb12is_cow_faultEmmmm+0x1a3>
ffffffff8101cbc7:	41 f6 c0 02          	test   $0x2,%r8b
ffffffff8101cbcb:	0f 84 06 01 00 00    	je     ffffffff8101ccd7 <_ZN4Vtlb12is_cow_faultEmmmm+0x1a3>
ffffffff8101cbd1:	41 80 e1 02          	and    $0x2,%r9b
ffffffff8101cbd5:	0f 85 fc 00 00 00    	jne    ffffffff8101ccd7 <_ZN4Vtlb12is_cow_faultEmmmm+0x1a3>
            Cow::cow_elt *ce = nullptr;
            if (Ec::current->run_number == 1) {
ffffffff8101cbdb:	48 8b 05 26 24 fe 3e 	mov    0x3efe2426(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
        if (!(val & TLB_P) && (val & PTE_COW_IO)) { //Memory mapped IO
            val |= TLB_P;
            Console::print("IO space  hpa: %08lx  val: %08x  err: %08lx", hpa, val, err);
            return true;
        } else if ((val & TLB_P) && (err & ERR_W) && !(val & TLB_W)) {
            Cow::cow_elt *ce = nullptr;
ffffffff8101cbe2:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
ffffffff8101cbe9:	00 00 
            if (Ec::current->run_number == 1) {
ffffffff8101cbeb:	80 b8 4a 03 00 00 01 	cmpb   $0x1,0x34a(%rax)
ffffffff8101cbf2:	75 34                	jne    ffffffff8101cc28 <_ZN4Vtlb12is_cow_faultEmmmm+0xf4>
                Console::print("virt: %08lx  gpa: %08lx  hpa: %08lx  err: %08lx ", virt, gpa, hpa, err);
ffffffff8101cbf4:	4c 89 d1             	mov    %r10,%rcx
ffffffff8101cbf7:	4c 89 e2             	mov    %r12,%rdx
ffffffff8101cbfa:	4c 89 ee             	mov    %r13,%rsi
ffffffff8101cbfd:	48 c7 c7 06 15 02 81 	mov    $0xffffffff81021506,%rdi
ffffffff8101cc04:	31 c0                	xor    %eax,%eax
ffffffff8101cc06:	e8 81 54 fe ff       	callq  ffffffff8100208c <_ZN7Console5printEPKcz>
                ce = Ec::current->find_cow_elt(gpa);
ffffffff8101cc0b:	48 8b 3d f6 23 fe 3e 	mov    0x3efe23f6(%rip),%rdi        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8101cc12:	4c 89 e6             	mov    %r12,%rsi
ffffffff8101cc15:	e8 0a 95 fe ff       	callq  ffffffff81006124 <_ZN2Ec12find_cow_eltEm>
ffffffff8101cc1a:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
                val = ce->new_phys[1]->phys_addr | a | TLB_W;
ffffffff8101cc1f:	48 8b 40 28          	mov    0x28(%rax),%rax
ffffffff8101cc23:	e9 9f 00 00 00       	jmpq   ffffffff8101ccc7 <_ZN4Vtlb12is_cow_faultEmmmm+0x193>
                val &= ~TLB_COW;
                return true;
            }
            if (!Cow::get_cow_list_elt(&ce)) //get new cow_elt
ffffffff8101cc28:	48 8d 7c 24 08       	lea    0x8(%rsp),%rdi
ffffffff8101cc2d:	e8 cc 5a fe ff       	callq  ffffffff810026fe <_ZN3Cow16get_cow_list_eltEPPNS_7cow_eltE>
ffffffff8101cc32:	84 c0                	test   %al,%al
ffffffff8101cc34:	48 8b 3d cd 23 fe 3e 	mov    0x3efe23cd(%rip),%rdi        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8101cc3b:	75 13                	jne    ffffffff8101cc50 <_ZN4Vtlb12is_cow_faultEmmmm+0x11c>
                Ec::current->die("Cow elt exhausted");
ffffffff8101cc3d:	48 8d b7 a8 00 00 00 	lea    0xa8(%rdi),%rsi
ffffffff8101cc44:	48 c7 c7 37 15 02 81 	mov    $0xffffffff81021537,%rdi
ffffffff8101cc4b:	e8 ba 7f fe ff       	callq  ffffffff81004c0a <_ZN2Ec3dieEPKcP8Exc_regs>

            if (Ec::current->is_mapped_elsewhere(hpa & ~PAGE_MASK, ce) || Cow::subtitute(hpa & ~PAGE_MASK, ce, gpa & ~PAGE_MASK)) {
ffffffff8101cc50:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
ffffffff8101cc55:	4c 89 f6             	mov    %r14,%rsi
ffffffff8101cc58:	e8 bb 93 fe ff       	callq  ffffffff81006018 <_ZN2Ec19is_mapped_elsewhereEmPN3Cow7cow_eltE>
ffffffff8101cc5d:	84 c0                	test   %al,%al
ffffffff8101cc5f:	75 35                	jne    ffffffff8101cc96 <_ZN4Vtlb12is_cow_faultEmmmm+0x162>
ffffffff8101cc61:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
ffffffff8101cc66:	4c 89 e2             	mov    %r12,%rdx
ffffffff8101cc69:	4c 89 f7             	mov    %r14,%rdi
ffffffff8101cc6c:	48 81 e2 00 f0 ff ff 	and    $0xfffffffffffff000,%rdx
ffffffff8101cc73:	e8 62 5b fe ff       	callq  ffffffff810027da <_ZN3Cow9subtituteEmPNS_7cow_eltEm>
ffffffff8101cc78:	84 c0                	test   %al,%al
ffffffff8101cc7a:	75 1a                	jne    ffffffff8101cc96 <_ZN4Vtlb12is_cow_faultEmmmm+0x162>
                ce->gla = virt;
                ce->page_addr_or_gpa = gpa & ~PAGE_MASK;
                ce->attr = a;
            } else // Cow::subtitute will fill cow's fields old_phys, new_phys and frame_index 
                Ec::current->die("Cow frame exhausted");
ffffffff8101cc7c:	48 8b 05 85 23 fe 3e 	mov    0x3efe2385(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8101cc83:	48 c7 c7 49 15 02 81 	mov    $0xffffffff81021549,%rdi
ffffffff8101cc8a:	48 8d b0 a8 00 00 00 	lea    0xa8(%rax),%rsi
ffffffff8101cc91:	e8 74 7f fe ff       	callq  ffffffff81004c0a <_ZN2Ec3dieEPKcP8Exc_regs>
            }
            if (!Cow::get_cow_list_elt(&ce)) //get new cow_elt
                Ec::current->die("Cow elt exhausted");

            if (Ec::current->is_mapped_elsewhere(hpa & ~PAGE_MASK, ce) || Cow::subtitute(hpa & ~PAGE_MASK, ce, gpa & ~PAGE_MASK)) {
                ce->gla = virt;
ffffffff8101cc96:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
                ce->page_addr_or_gpa = gpa & ~PAGE_MASK;
ffffffff8101cc9b:	49 81 e4 00 f0 ff ff 	and    $0xfffffffffffff000,%r12
ffffffff8101cca2:	4c 89 20             	mov    %r12,(%rax)
                ce->attr = a;
ffffffff8101cca5:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
            } else // Cow::subtitute will fill cow's fields old_phys, new_phys and frame_index 
                Ec::current->die("Cow frame exhausted");
            Ec::current->add_cow(ce);
ffffffff8101ccaa:	48 8b 3d 57 23 fe 3e 	mov    0x3efe2357(%rip),%rdi        # ffffffffbffff008 <_ZN2Ec7currentE>
            }
            if (!Cow::get_cow_list_elt(&ce)) //get new cow_elt
                Ec::current->die("Cow elt exhausted");

            if (Ec::current->is_mapped_elsewhere(hpa & ~PAGE_MASK, ce) || Cow::subtitute(hpa & ~PAGE_MASK, ce, gpa & ~PAGE_MASK)) {
                ce->gla = virt;
ffffffff8101ccb1:	4c 89 68 08          	mov    %r13,0x8(%rax)
                ce->page_addr_or_gpa = gpa & ~PAGE_MASK;
                ce->attr = a;
ffffffff8101ccb5:	48 89 5e 18          	mov    %rbx,0x18(%rsi)
            } else // Cow::subtitute will fill cow's fields old_phys, new_phys and frame_index 
                Ec::current->die("Cow frame exhausted");
            Ec::current->add_cow(ce);
ffffffff8101ccb9:	e8 78 8b fe ff       	callq  ffffffff81005836 <_ZN2Ec7add_cowEPN3Cow7cow_eltE>
            val = ce->new_phys[0]->phys_addr | a | TLB_W;
ffffffff8101ccbe:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
ffffffff8101ccc3:	48 8b 40 20          	mov    0x20(%rax),%rax
ffffffff8101ccc7:	48 0b 18             	or     (%rax),%rbx
            val &= ~TLB_COW;
ffffffff8101ccca:	80 e7 f7             	and    $0xf7,%bh
ffffffff8101cccd:	48 83 cb 02          	or     $0x2,%rbx
ffffffff8101ccd1:	48 89 5d 00          	mov    %rbx,0x0(%rbp)
ffffffff8101ccd5:	b0 01                	mov    $0x1,%al
            return true;
        } else
            return false;
    } else
        return false;
}
ffffffff8101ccd7:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8101ccdb:	5b                   	pop    %rbx
ffffffff8101ccdc:	5d                   	pop    %rbp
ffffffff8101ccdd:	41 5c                	pop    %r12
ffffffff8101ccdf:	41 5d                	pop    %r13
ffffffff8101cce1:	41 5e                	pop    %r14
ffffffff8101cce3:	c3                   	retq   

ffffffff8101cce4 <_ZN4Vtlb6updateEmmm>:

void Vtlb::update(mword virt, Paddr hpa, mword a) {
    unsigned lev = max();
    for (Vtlb *tlb = this;; tlb = static_cast<Vtlb *> (Buddy::phys_to_ptr(tlb->addr()))) {
        unsigned shift = --lev * bpl() + PAGE_BITS;
        tlb += virt >> shift & ((1UL << bpl()) - 1);
ffffffff8101cce4:	48 89 f0             	mov    %rsi,%rax
        if (lev)
            continue;
        tlb->val = hpa | a;
ffffffff8101cce7:	48 09 ca             	or     %rcx,%rdx

void Vtlb::update(mword virt, Paddr hpa, mword a) {
    unsigned lev = max();
    for (Vtlb *tlb = this;; tlb = static_cast<Vtlb *> (Buddy::phys_to_ptr(tlb->addr()))) {
        unsigned shift = --lev * bpl() + PAGE_BITS;
        tlb += virt >> shift & ((1UL << bpl()) - 1);
ffffffff8101ccea:	48 c1 e8 1e          	shr    $0x1e,%rax
ffffffff8101ccee:	25 ff 01 00 00       	and    $0x1ff,%eax
    }

    ALWAYS_INLINE
    inline Paddr addr() const {
        return static_cast<Paddr> (val) & ~((1UL << order()) - 1);
ffffffff8101ccf3:	48 8b 04 c7          	mov    (%rdi,%rax,8),%rax
ffffffff8101ccf7:	48 89 f7             	mov    %rsi,%rdi
ffffffff8101ccfa:	48 c1 ee 0c          	shr    $0xc,%rsi
ffffffff8101ccfe:	48 c1 ef 15          	shr    $0x15,%rdi
ffffffff8101cd02:	81 e6 ff 01 00 00    	and    $0x1ff,%esi
ffffffff8101cd08:	81 e7 ff 01 00 00    	and    $0x1ff,%edi
ffffffff8101cd0e:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8101cd14:	48 8b 84 f8 00 00 c0 	mov    -0x7f400000(%rax,%rdi,8),%rax
ffffffff8101cd1b:	80 
ffffffff8101cd1c:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
        if (lev)
            continue;
        tlb->val = hpa | a;
ffffffff8101cd22:	48 89 94 f0 00 00 c0 	mov    %rdx,-0x7f400000(%rax,%rsi,8)
ffffffff8101cd29:	80 
ffffffff8101cd2a:	c3                   	retq   

ffffffff8101cd2b <_ZN7Counter5printILj1ELj16EEEvmN11Console_vga5ColorEj>:
        }

        template <unsigned D, unsigned B>
        static void print (mword val, Console_vga::Color c, unsigned col)
        {
            if (EXPECT_FALSE (Cpu::row))
ffffffff8101cd2b:	8b 05 5f 2a fe 3e    	mov    0x3efe2a5f(%rip),%eax        # ffffffffbffff790 <_ZN3Cpu3rowE>
ffffffff8101cd31:	85 c0                	test   %eax,%eax
ffffffff8101cd33:	74 21                	je     ffffffff8101cd56 <_ZN7Counter5printILj1ELj16EEEvmN11Console_vga5ColorEj+0x2b>
ffffffff8101cd35:	48 6b c0 50          	imul   $0x50,%rax,%rax
                for (unsigned i = 0; i < D; i++, val /= B)
                    Console_vga::con.put (Cpu::row, col - i, c, !i || val ? (val % B)["0123456789ABCDEF"] : ' ');
ffffffff8101cd39:	89 d2                	mov    %edx,%edx
ffffffff8101cd3b:	83 e7 0f             	and    $0xf,%edi
ffffffff8101cd3e:	c1 e6 08             	shl    $0x8,%esi
ffffffff8101cd41:	48 01 c2             	add    %rax,%rdx
ffffffff8101cd44:	66 0f be 87 d8 d7 01 	movsbw -0x7efe2828(%rdi),%ax
ffffffff8101cd4b:	81 
ffffffff8101cd4c:	09 c6                	or     %eax,%esi
ffffffff8101cd4e:	66 89 b4 12 00 f0 df 	mov    %si,-0x40201000(%rdx,%rdx,1)
ffffffff8101cd55:	bf 
ffffffff8101cd56:	c3                   	retq   
ffffffff8101cd57:	90                   	nop

ffffffff8101cd58 <_ZN4Vtlb5flushEb>:

        return;
    }
}

void Vtlb::flush(bool full) {
ffffffff8101cd58:	50                   	push   %rax
    flush_ptab(full);
ffffffff8101cd59:	40 0f b6 f6          	movzbl %sil,%esi
ffffffff8101cd5d:	e8 a2 fd ff ff       	callq  ffffffff8101cb04 <_ZN4Vtlb10flush_ptabEb>

    Counter::print<1, 16> (++Counter::vtlb_flush, Console_vga::COLOR_LIGHT_RED, SPN_VFL);
ffffffff8101cd62:	8b 05 e8 22 fe 3e    	mov    0x3efe22e8(%rip),%eax        # ffffffffbffff050 <_ZN7Counter10vtlb_flushE>
ffffffff8101cd68:	ba 05 00 00 00       	mov    $0x5,%edx
ffffffff8101cd6d:	be 0c 00 00 00       	mov    $0xc,%esi
ffffffff8101cd72:	8d 78 01             	lea    0x1(%rax),%edi
ffffffff8101cd75:	89 3d d5 22 fe 3e    	mov    %edi,0x3efe22d5(%rip)        # ffffffffbffff050 <_ZN7Counter10vtlb_flushE>
}
ffffffff8101cd7b:	59                   	pop    %rcx
}

void Vtlb::flush(bool full) {
    flush_ptab(full);

    Counter::print<1, 16> (++Counter::vtlb_flush, Console_vga::COLOR_LIGHT_RED, SPN_VFL);
ffffffff8101cd7c:	e9 aa ff ff ff       	jmpq   ffffffff8101cd2b <_ZN7Counter5printILj1ELj16EEEvmN11Console_vga5ColorEj>
ffffffff8101cd81:	90                   	nop

ffffffff8101cd82 <_ZN4Vtlb5flushEm>:
}

void Vtlb::flush(mword virt) {
    unsigned l = max();

    for (Vtlb *e = this;; e = static_cast<Vtlb *> (Buddy::phys_to_ptr(e->addr()))) {
ffffffff8101cd82:	b9 1e 00 00 00       	mov    $0x1e,%ecx

        unsigned shift = --l * bpl() + PAGE_BITS;
        e += virt >> shift & ((1UL << bpl()) - 1);
ffffffff8101cd87:	48 89 f0             	mov    %rsi,%rax
ffffffff8101cd8a:	48 d3 e8             	shr    %cl,%rax
ffffffff8101cd8d:	25 ff 01 00 00       	and    $0x1ff,%eax
ffffffff8101cd92:	48 8d 04 c7          	lea    (%rdi,%rax,8),%rax

    P *walk(Quota &quota, E, unsigned long, bool = true);

    ALWAYS_INLINE
    inline bool present() const {
        return val & P::PTE_P;
ffffffff8101cd96:	48 8b 38             	mov    (%rax),%rdi

        if (!e->present())
ffffffff8101cd99:	40 f6 c7 01          	test   $0x1,%dil
ffffffff8101cd9d:	74 4c                	je     ffffffff8101cdeb <_ZN4Vtlb5flushEm+0x69>
            return;

        if (l && !e->super() && !e->frag())
ffffffff8101cd9f:	83 f9 0c             	cmp    $0xc,%ecx
ffffffff8101cda2:	74 1b                	je     ffffffff8101cdbf <_ZN4Vtlb5flushEm+0x3d>
ffffffff8101cda4:	83 e9 09             	sub    $0x9,%ecx
ffffffff8101cda7:	f7 c7 80 02 00 00    	test   $0x280,%edi
ffffffff8101cdad:	75 10                	jne    ffffffff8101cdbf <_ZN4Vtlb5flushEm+0x3d>
        return static_cast<mword> (val) & PAGE_MASK;
    }

    ALWAYS_INLINE
    inline Paddr addr() const {
        return static_cast<Paddr> (val) & ~((1UL << order()) - 1);
ffffffff8101cdaf:	48 81 e7 00 f0 ff ff 	and    $0xfffffffffffff000,%rdi
        }

        ALWAYS_INLINE
        inline mword phys_to_virt (mword phys)
        {
            return phys + reinterpret_cast<mword>(&OFFSET);
ffffffff8101cdb6:	48 81 c7 00 00 c0 80 	add    $0xffffffff80c00000,%rdi
ffffffff8101cdbd:	eb c8                	jmp    ffffffff8101cd87 <_ZN4Vtlb5flushEm+0x5>
            continue;

        e->val |= TLB_M;
        e->val &= ~TLB_P;
ffffffff8101cdbf:	48 83 e7 fe          	and    $0xfffffffffffffffe,%rdi

        Counter::print<1, 16> (++Counter::vtlb_flush, Console_vga::COLOR_LIGHT_RED, SPN_VFL);
ffffffff8101cdc3:	ba 05 00 00 00       	mov    $0x5,%edx
ffffffff8101cdc8:	be 0c 00 00 00       	mov    $0xc,%esi

        if (l && !e->super() && !e->frag())
            continue;

        e->val |= TLB_M;
        e->val &= ~TLB_P;
ffffffff8101cdcd:	48 81 cf 00 04 00 00 	or     $0x400,%rdi
ffffffff8101cdd4:	48 89 38             	mov    %rdi,(%rax)

        Counter::print<1, 16> (++Counter::vtlb_flush, Console_vga::COLOR_LIGHT_RED, SPN_VFL);
ffffffff8101cdd7:	8b 05 73 22 fe 3e    	mov    0x3efe2273(%rip),%eax        # ffffffffbffff050 <_ZN7Counter10vtlb_flushE>
ffffffff8101cddd:	8d 78 01             	lea    0x1(%rax),%edi
ffffffff8101cde0:	89 3d 6a 22 fe 3e    	mov    %edi,0x3efe226a(%rip)        # ffffffffbffff050 <_ZN7Counter10vtlb_flushE>
ffffffff8101cde6:	e9 40 ff ff ff       	jmpq   ffffffff8101cd2b <_ZN7Counter5printILj1ELj16EEEvmN11Console_vga5ColorEj>
ffffffff8101cdeb:	c3                   	retq   

ffffffff8101cdec <_ZN4Vtlb4missEP8Exc_regsmRmS2_S2_>:
    }

    return size;
}

Vtlb::Reason Vtlb::miss(Exc_regs *regs, mword virt, mword &error, mword &phys1, Paddr &host1) {
ffffffff8101cdec:	41 57                	push   %r15
ffffffff8101cdee:	41 56                	push   %r14
ffffffff8101cdf0:	4d 89 c6             	mov    %r8,%r14
ffffffff8101cdf3:	41 55                	push   %r13
ffffffff8101cdf5:	41 54                	push   %r12

    trace(TRACE_VTLB, "VTLB Miss CR3:%#010lx A:%#010lx E:%#lx", regs->cr3_shadow, virt, error);

    error &= ERR_U | ERR_W;

    size_t gsize = gwalk(regs, virt, phys, attr, error);
ffffffff8101cdf7:	49 89 d0             	mov    %rdx,%r8
    }

    return size;
}

Vtlb::Reason Vtlb::miss(Exc_regs *regs, mword virt, mword &error, mword &phys1, Paddr &host1) {
ffffffff8101cdfa:	55                   	push   %rbp
ffffffff8101cdfb:	53                   	push   %rbx
ffffffff8101cdfc:	48 89 d5             	mov    %rdx,%rbp
ffffffff8101cdff:	49 89 cd             	mov    %rcx,%r13
ffffffff8101ce02:	49 89 fc             	mov    %rdi,%r12
ffffffff8101ce05:	48 83 ec 48          	sub    $0x48,%rsp
    mword phys, attr = TLB_U | TLB_W | TLB_P;
    Paddr host;

    trace(TRACE_VTLB, "VTLB Miss CR3:%#010lx A:%#010lx E:%#lx", regs->cr3_shadow, virt, error);

    error &= ERR_U | ERR_W;
ffffffff8101ce09:	48 83 22 06          	andq   $0x6,(%rdx)

    size_t gsize = gwalk(regs, virt, phys, attr, error);
ffffffff8101ce0d:	48 8d 4c 24 30       	lea    0x30(%rsp),%rcx
ffffffff8101ce12:	48 8d 54 24 28       	lea    0x28(%rsp),%rdx
    }

    return size;
}

Vtlb::Reason Vtlb::miss(Exc_regs *regs, mword virt, mword &error, mword &phys1, Paddr &host1) {
ffffffff8101ce17:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
    mword phys, attr = TLB_U | TLB_W | TLB_P;
ffffffff8101ce1c:	48 c7 44 24 30 07 00 	movq   $0x7,0x30(%rsp)
ffffffff8101ce23:	00 00 

    trace(TRACE_VTLB, "VTLB Miss CR3:%#010lx A:%#010lx E:%#lx", regs->cr3_shadow, virt, error);

    error &= ERR_U | ERR_W;

    size_t gsize = gwalk(regs, virt, phys, attr, error);
ffffffff8101ce25:	e8 b8 fa ff ff       	callq  ffffffff8101c8e2 <_ZN4Vtlb5gwalkEP8Exc_regsmRmS2_S2_>

    if (EXPECT_FALSE(!gsize)) {
ffffffff8101ce2a:	48 85 c0             	test   %rax,%rax

    trace(TRACE_VTLB, "VTLB Miss CR3:%#010lx A:%#010lx E:%#lx", regs->cr3_shadow, virt, error);

    error &= ERR_U | ERR_W;

    size_t gsize = gwalk(regs, virt, phys, attr, error);
ffffffff8101ce2d:	48 89 c3             	mov    %rax,%rbx
ffffffff8101ce30:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi

    if (EXPECT_FALSE(!gsize)) {
ffffffff8101ce35:	75 18                	jne    ffffffff8101ce4f <_ZN4Vtlb4missEP8Exc_regsmRmS2_S2_+0x63>
        Counter::vtlb_gpf++;
ffffffff8101ce37:	ff 05 1f 22 fe 3e    	incl   0x3efe221f(%rip)        # ffffffffbffff05c <_ZN7Counter8vtlb_gpfE>
        phys1 = phys;
        host1 = 0x0;
        return GLA_GPA;
ffffffff8101ce3d:	b3 02                	mov    $0x2,%bl

    size_t gsize = gwalk(regs, virt, phys, attr, error);

    if (EXPECT_FALSE(!gsize)) {
        Counter::vtlb_gpf++;
        phys1 = phys;
ffffffff8101ce3f:	49 89 7d 00          	mov    %rdi,0x0(%r13)
        host1 = 0x0;
ffffffff8101ce43:	49 c7 06 00 00 00 00 	movq   $0x0,(%r14)
        return GLA_GPA;
ffffffff8101ce4a:	e9 67 02 00 00       	jmpq   ffffffff8101d0b6 <_ZN4Vtlb4missEP8Exc_regsmRmS2_S2_+0x2ca>
    }

    size_t hsize = hwalk(phys, host, attr, error);
ffffffff8101ce4f:	48 8d 54 24 30       	lea    0x30(%rsp),%rdx
ffffffff8101ce54:	48 8d 74 24 38       	lea    0x38(%rsp),%rsi
ffffffff8101ce59:	48 89 e9             	mov    %rbp,%rcx
ffffffff8101ce5c:	e8 23 fc ff ff       	callq  ffffffff8101ca84 <_ZN4Vtlb5hwalkEmRmS0_S0_>

    if (EXPECT_FALSE(!hsize)) {
ffffffff8101ce61:	48 85 c0             	test   %rax,%rax
ffffffff8101ce64:	75 34                	jne    ffffffff8101ce9a <_ZN4Vtlb4missEP8Exc_regsmRmS2_S2_+0xae>
        regs->nst_fault = phys;
ffffffff8101ce66:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
        regs->nst_error = error;
        Counter::vtlb_hpf++;
        phys1 = phys;
        host1 = 0x0;
        return GPA_HPA;
ffffffff8101ce6b:	bb 03 00 00 00       	mov    $0x3,%ebx
    }

    size_t hsize = hwalk(phys, host, attr, error);

    if (EXPECT_FALSE(!hsize)) {
        regs->nst_fault = phys;
ffffffff8101ce70:	49 89 84 24 b0 00 00 	mov    %rax,0xb0(%r12)
ffffffff8101ce77:	00 
        regs->nst_error = error;
ffffffff8101ce78:	48 8b 55 00          	mov    0x0(%rbp),%rdx
        Counter::vtlb_hpf++;
ffffffff8101ce7c:	ff 05 d6 21 fe 3e    	incl   0x3efe21d6(%rip)        # ffffffffbffff058 <_ZN7Counter8vtlb_hpfE>

    size_t hsize = hwalk(phys, host, attr, error);

    if (EXPECT_FALSE(!hsize)) {
        regs->nst_fault = phys;
        regs->nst_error = error;
ffffffff8101ce82:	49 89 94 24 b8 00 00 	mov    %rdx,0xb8(%r12)
ffffffff8101ce89:	00 
        Counter::vtlb_hpf++;
        phys1 = phys;
ffffffff8101ce8a:	49 89 45 00          	mov    %rax,0x0(%r13)
        host1 = 0x0;
ffffffff8101ce8e:	49 c7 06 00 00 00 00 	movq   $0x0,(%r14)
        return GPA_HPA;
ffffffff8101ce95:	e9 1c 02 00 00       	jmpq   ffffffff8101d0b6 <_ZN4Vtlb4missEP8Exc_regsmRmS2_S2_+0x2ca>
ffffffff8101ce9a:	48 39 d8             	cmp    %rbx,%rax
ffffffff8101ce9d:	48 89 d9             	mov    %rbx,%rcx
ffffffff8101cea0:	48 0f 46 c8          	cmovbe %rax,%rcx
    }

    size_t size = min(gsize, hsize);

    if (gsize > hsize)
ffffffff8101cea4:	48 39 c3             	cmp    %rax,%rbx
ffffffff8101cea7:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
ffffffff8101ceac:	76 09                	jbe    ffffffff8101ceb7 <_ZN4Vtlb4missEP8Exc_regsmRmS2_S2_+0xcb>
        attr |= TLB_F;
ffffffff8101ceae:	48 81 4c 24 30 00 02 	orq    $0x200,0x30(%rsp)
ffffffff8101ceb5:	00 00 

    Counter::print<1, 16> (++Counter::vtlb_fill, Console_vga::COLOR_LIGHT_MAGENTA, SPN_VFI);
ffffffff8101ceb7:	8b 05 97 21 fe 3e    	mov    0x3efe2197(%rip),%eax        # ffffffffbffff054 <_ZN7Counter9vtlb_fillE>
ffffffff8101cebd:	ba 04 00 00 00       	mov    $0x4,%edx
ffffffff8101cec2:	be 0d 00 00 00       	mov    $0xd,%esi

    unsigned lev = max();
ffffffff8101cec7:	bb 03 00 00 00       	mov    $0x3,%ebx
    size_t size = min(gsize, hsize);

    if (gsize > hsize)
        attr |= TLB_F;

    Counter::print<1, 16> (++Counter::vtlb_fill, Console_vga::COLOR_LIGHT_MAGENTA, SPN_VFI);
ffffffff8101cecc:	8d 78 01             	lea    0x1(%rax),%edi
ffffffff8101cecf:	89 3d 7f 21 fe 3e    	mov    %edi,0x3efe217f(%rip)        # ffffffffbffff054 <_ZN7Counter9vtlb_fillE>
ffffffff8101ced5:	e8 51 fe ff ff       	callq  ffffffff8101cd2b <_ZN7Counter5printILj1ELj16EEEvmN11Console_vga5ColorEj>

    unsigned lev = max();

    //    Console::print("gla: %08lx  gpa: %08lx  host: %08lx", virt, phys, host);
    for (Vtlb *tlb = regs->vtlb;; tlb = static_cast<Vtlb *> (Buddy::phys_to_ptr(tlb->addr()))) {
ffffffff8101ceda:	49 8b 84 24 88 00 00 	mov    0x88(%r12),%rax
ffffffff8101cee1:	00 

        unsigned shift = --lev * bpl() + PAGE_BITS;
ffffffff8101cee2:	ff cb                	dec    %ebx
ffffffff8101cee4:	8d 14 db             	lea    (%rbx,%rbx,8),%edx
ffffffff8101cee7:	8d 4a 0c             	lea    0xc(%rdx),%ecx
        tlb += virt >> shift & ((1UL << bpl()) - 1);
ffffffff8101ceea:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
ffffffff8101ceef:	89 4c 24 0c          	mov    %ecx,0xc(%rsp)
ffffffff8101cef3:	8a 4c 24 0c          	mov    0xc(%rsp),%cl
ffffffff8101cef7:	48 d3 ea             	shr    %cl,%rdx
ffffffff8101cefa:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
ffffffff8101cf00:	4c 8d 3c d0          	lea    (%rax,%rdx,8),%r15

        //        Console::print("tlb.addr: %08lx  lev: %x  size: % %x  shift: %u  1<<shift: %08lx", tlb->addr(), lev, size, shift, (1UL << shift));
        if (!regs->vmcb->int_shadow && tlb->is_cow_fault(virt, phys, host, error)) { //avoid shadowed interrupt problem
ffffffff8101cf04:	49 8b 84 24 80 00 00 	mov    0x80(%r12),%rax
ffffffff8101cf0b:	00 
ffffffff8101cf0c:	48 83 78 68 00       	cmpq   $0x0,0x68(%rax)
ffffffff8101cf11:	75 35                	jne    ffffffff8101cf48 <_ZN4Vtlb4missEP8Exc_regsmRmS2_S2_+0x15c>
ffffffff8101cf13:	4c 8b 45 00          	mov    0x0(%rbp),%r8
ffffffff8101cf17:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
ffffffff8101cf1c:	4c 89 ff             	mov    %r15,%rdi
ffffffff8101cf1f:	48 8b 54 24 28       	mov    0x28(%rsp),%rdx
ffffffff8101cf24:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
ffffffff8101cf29:	e8 06 fc ff ff       	callq  ffffffff8101cb34 <_ZN4Vtlb12is_cow_faultEmmmm>
ffffffff8101cf2e:	84 c0                	test   %al,%al
ffffffff8101cf30:	74 16                	je     ffffffff8101cf48 <_ZN4Vtlb4missEP8Exc_regsmRmS2_S2_+0x15c>
            phys1 = phys;
ffffffff8101cf32:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
            host1 = tlb->val;
            return SUCCESS_COW;
ffffffff8101cf37:	31 db                	xor    %ebx,%ebx
        unsigned shift = --lev * bpl() + PAGE_BITS;
        tlb += virt >> shift & ((1UL << bpl()) - 1);

        //        Console::print("tlb.addr: %08lx  lev: %x  size: % %x  shift: %u  1<<shift: %08lx", tlb->addr(), lev, size, shift, (1UL << shift));
        if (!regs->vmcb->int_shadow && tlb->is_cow_fault(virt, phys, host, error)) { //avoid shadowed interrupt problem
            phys1 = phys;
ffffffff8101cf39:	49 89 45 00          	mov    %rax,0x0(%r13)
            host1 = tlb->val;
ffffffff8101cf3d:	49 8b 07             	mov    (%r15),%rax
ffffffff8101cf40:	49 89 06             	mov    %rax,(%r14)
            return SUCCESS_COW;
ffffffff8101cf43:	e9 6e 01 00 00       	jmpq   ffffffff8101d0b6 <_ZN4Vtlb4missEP8Exc_regsmRmS2_S2_+0x2ca>
        }

        if (lev) {
ffffffff8101cf48:	85 db                	test   %ebx,%ebx
ffffffff8101cf4a:	0f 84 1b 01 00 00    	je     ffffffff8101d06b <_ZN4Vtlb4missEP8Exc_regsmRmS2_S2_+0x27f>

            if (lev == 2 || size < 1UL << shift) {
ffffffff8101cf50:	83 fb 02             	cmp    $0x2,%ebx
ffffffff8101cf53:	74 15                	je     ffffffff8101cf6a <_ZN4Vtlb4missEP8Exc_regsmRmS2_S2_+0x17e>
ffffffff8101cf55:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
ffffffff8101cf5a:	8a 4c 24 0c          	mov    0xc(%rsp),%cl
ffffffff8101cf5e:	48 d3 e8             	shr    %cl,%rax
ffffffff8101cf61:	48 85 c0             	test   %rax,%rax
ffffffff8101cf64:	0f 85 c7 00 00 00    	jne    ffffffff8101d031 <_ZN4Vtlb4missEP8Exc_regsmRmS2_S2_+0x245>
        return val & P::PTE_P;
    }

    ALWAYS_INLINE
    inline bool super() const {
        return val & P::PTE_S;
ffffffff8101cf6a:	49 8b 3f             	mov    (%r15),%rdi

                if (tlb->super())
ffffffff8101cf6d:	40 f6 c7 80          	test   $0x80,%dil
ffffffff8101cf71:	74 61                	je     ffffffff8101cfd4 <_ZN4Vtlb4missEP8Exc_regsmRmS2_S2_+0x1e8>
                    tlb->val = static_cast<typeof tlb->val> (Buddy::ptr_to_phys(new (Pd::current->quota) Vtlb) | (lev == 2 ? 0 : TLB_A | TLB_U | TLB_W) | TLB_M | TLB_P);
ffffffff8101cf73:	48 8b 05 96 20 fe 3e 	mov    0x3efe2096(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
    bool is_cow_fault(mword virt, mword gpa, Paddr hpa, mword err);
    void update(mword, Paddr, mword);

    ALWAYS_INLINE
    static inline void *operator new (size_t, Quota &quota) {
        return Buddy::allocator.alloc(0, quota, Buddy::NOFILL);
ffffffff8101cf7a:	31 c9                	xor    %ecx,%ecx
ffffffff8101cf7c:	31 f6                	xor    %esi,%esi
ffffffff8101cf7e:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff8101cf85:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff8101cf8c:	e8 61 49 fe ff       	callq  ffffffff810018f2 <_ZN5Buddy5allocEtR5QuotaNS_4FillE>

    void free_up(Quota &quota, unsigned l, P *, mword, bool (*) (Paddr, mword, unsigned), bool (*) (unsigned, mword));

public:

    Pte() : val(0) {
ffffffff8101cf91:	31 d2                	xor    %edx,%edx
ffffffff8101cf93:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
        GPA_HPA
    };

    ALWAYS_INLINE
    inline Vtlb() {
        for (unsigned i = 0; i < 1UL << bpl(); i++)
ffffffff8101cf9a:	48 81 fa 00 02 00 00 	cmp    $0x200,%rdx
ffffffff8101cfa1:	74 0d                	je     ffffffff8101cfb0 <_ZN4Vtlb4missEP8Exc_regsmRmS2_S2_+0x1c4>
            this[i].val = TLB_S;
ffffffff8101cfa3:	48 c7 04 d0 80 00 00 	movq   $0x80,(%rax,%rdx,8)
ffffffff8101cfaa:	00 
ffffffff8101cfab:	48 ff c2             	inc    %rdx
ffffffff8101cfae:	eb ea                	jmp    ffffffff8101cf9a <_ZN4Vtlb4missEP8Exc_regsmRmS2_S2_+0x1ae>
        }

        ALWAYS_INLINE
        inline mword virt_to_phys (mword virt)
        {
            return virt - reinterpret_cast<mword>(&OFFSET);
ffffffff8101cfb0:	48 2d 00 00 c0 80    	sub    $0xffffffff80c00000,%rax
ffffffff8101cfb6:	66 ba 00 00          	mov    $0x0,%dx
ffffffff8101cfba:	83 fb 02             	cmp    $0x2,%ebx
ffffffff8101cfbd:	b9 26 00 00 00       	mov    $0x26,%ecx
ffffffff8101cfc2:	48 0f 45 d1          	cmovne %rcx,%rdx
ffffffff8101cfc6:	48 0d 01 04 00 00    	or     $0x401,%rax
ffffffff8101cfcc:	48 09 d0             	or     %rdx,%rax
ffffffff8101cfcf:	49 89 07             	mov    %rax,(%r15)
ffffffff8101cfd2:	eb 2a                	jmp    ffffffff8101cffe <_ZN4Vtlb4missEP8Exc_regsmRmS2_S2_+0x212>

                else if (!tlb->present()) {
ffffffff8101cfd4:	40 f6 c7 01          	test   $0x1,%dil
ffffffff8101cfd8:	75 24                	jne    ffffffff8101cffe <_ZN4Vtlb4missEP8Exc_regsmRmS2_S2_+0x212>
{
private:

    ALWAYS_INLINE
    inline bool mark() const {
        return val & TLB_M;
ffffffff8101cfda:	48 89 fe             	mov    %rdi,%rsi
        return static_cast<mword> (val) & PAGE_MASK;
    }

    ALWAYS_INLINE
    inline Paddr addr() const {
        return static_cast<Paddr> (val) & ~((1UL << order()) - 1);
ffffffff8101cfdd:	48 81 e7 00 f0 ff ff 	and    $0xfffffffffffff000,%rdi
ffffffff8101cfe4:	48 c1 ee 0a          	shr    $0xa,%rsi
        }

        ALWAYS_INLINE
        inline mword phys_to_virt (mword phys)
        {
            return phys + reinterpret_cast<mword>(&OFFSET);
ffffffff8101cfe8:	48 81 c7 00 00 c0 80 	add    $0xffffffff80c00000,%rdi
ffffffff8101cfef:	83 e6 01             	and    $0x1,%esi
                    static_cast<Vtlb *> (Buddy::phys_to_ptr(tlb->addr()))->flush_ptab(tlb->mark());
ffffffff8101cff2:	e8 0d fb ff ff       	callq  ffffffff8101cb04 <_ZN4Vtlb10flush_ptabEb>
                    tlb->val |= TLB_M | TLB_P;
ffffffff8101cff7:	49 81 0f 01 04 00 00 	orq    $0x401,(%r15)
                }

                tlb->val &= static_cast<typeof tlb->val> (attr | ~TLB_M);
ffffffff8101cffe:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
ffffffff8101d003:	48 0d ff fb ff ff    	or     $0xfffffffffffffbff,%rax
ffffffff8101d009:	49 23 07             	and    (%r15),%rax
ffffffff8101d00c:	49 89 07             	mov    %rax,(%r15)
                tlb->val |= static_cast<typeof tlb->val> (attr & TLB_F);
ffffffff8101d00f:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
ffffffff8101d014:	81 e2 00 02 00 00    	and    $0x200,%edx
ffffffff8101d01a:	48 09 d0             	or     %rdx,%rax
ffffffff8101d01d:	49 89 07             	mov    %rax,(%r15)
ffffffff8101d020:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff8101d026:	48 05 00 00 c0 80    	add    $0xffffffff80c00000,%rax
ffffffff8101d02c:	e9 b1 fe ff ff       	jmpq   ffffffff8101cee2 <_ZN4Vtlb4missEP8Exc_regsmRmS2_S2_+0xf6>
        return val & P::PTE_P;
    }

    ALWAYS_INLINE
    inline bool super() const {
        return val & P::PTE_S;
ffffffff8101d031:	49 8b 37             	mov    (%r15),%rsi

                continue;
            }

            if (!tlb->super())
ffffffff8101d034:	40 f6 c6 80          	test   $0x80,%sil
ffffffff8101d038:	75 28                	jne    ffffffff8101d062 <_ZN4Vtlb4missEP8Exc_regsmRmS2_S2_+0x276>
                Vtlb::destroy(static_cast<Vtlb *> (Buddy::phys_to_ptr(tlb->addr())), Pd::current->quota);
ffffffff8101d03a:	48 8b 05 cf 1f fe 3e 	mov    0x3efe1fcf(%rip),%rax        # ffffffffbffff010 <_ZN2Pd7currentE>
        return static_cast<mword> (val) & PAGE_MASK;
    }

    ALWAYS_INLINE
    inline Paddr addr() const {
        return static_cast<Paddr> (val) & ~((1UL << order()) - 1);
ffffffff8101d041:	48 81 e6 00 f0 ff ff 	and    $0xfffffffffffff000,%rsi
    }

    ALWAYS_INLINE
    static inline void destroy(Vtlb *obj, Quota &quota) {
        obj->~Vtlb();
        Buddy::allocator.free(reinterpret_cast<mword> (obj), quota);
ffffffff8101d048:	48 c7 c7 30 1d 02 81 	mov    $0xffffffff81021d30,%rdi
ffffffff8101d04f:	48 81 c6 00 00 c0 80 	add    $0xffffffff80c00000,%rsi
ffffffff8101d056:	48 8d 90 08 03 00 00 	lea    0x308(%rax),%rdx
ffffffff8101d05d:	e8 4c 45 fe ff       	callq  ffffffff810015ae <_ZN5Buddy4freeEmR5Quota>

            attr |= TLB_S;
ffffffff8101d062:	48 81 4c 24 30 80 00 	orq    $0x80,0x30(%rsp)
ffffffff8101d069:	00 00 
        }

        tlb->val = static_cast<typeof tlb->val> ((host & ~((1UL << shift) - 1)) | attr | TLB_D | TLB_A);
ffffffff8101d06b:	8a 4c 24 0c          	mov    0xc(%rsp),%cl
ffffffff8101d06f:	48 83 c8 ff          	or     $0xffffffffffffffff,%rax
ffffffff8101d073:	48 8b 54 24 30       	mov    0x30(%rsp),%rdx
        phys1 = phys;
        host1 = tlb->val;
        if(Ec::current->hardening_started){
            set_cow_page(phys, tlb->val);
        }
        return SUCCESS;
ffffffff8101d078:	bb 01 00 00 00       	mov    $0x1,%ebx
                Vtlb::destroy(static_cast<Vtlb *> (Buddy::phys_to_ptr(tlb->addr())), Pd::current->quota);

            attr |= TLB_S;
        }

        tlb->val = static_cast<typeof tlb->val> ((host & ~((1UL << shift) - 1)) | attr | TLB_D | TLB_A);
ffffffff8101d07d:	48 d3 e0             	shl    %cl,%rax
ffffffff8101d080:	48 23 44 24 38       	and    0x38(%rsp),%rax
ffffffff8101d085:	48 83 ca 60          	or     $0x60,%rdx
ffffffff8101d089:	48 09 d0             	or     %rdx,%rax
ffffffff8101d08c:	49 89 07             	mov    %rax,(%r15)
        phys1 = phys;
ffffffff8101d08f:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
ffffffff8101d094:	49 89 7d 00          	mov    %rdi,0x0(%r13)
        host1 = tlb->val;
ffffffff8101d098:	49 8b 07             	mov    (%r15),%rax
ffffffff8101d09b:	49 89 06             	mov    %rax,(%r14)
        if(Ec::current->hardening_started){
ffffffff8101d09e:	48 8b 05 63 1f fe 3e 	mov    0x3efe1f63(%rip),%rax        # ffffffffbffff008 <_ZN2Ec7currentE>
ffffffff8101d0a5:	80 b8 51 03 00 00 00 	cmpb   $0x0,0x351(%rax)
ffffffff8101d0ac:	74 08                	je     ffffffff8101d0b6 <_ZN4Vtlb4missEP8Exc_regsmRmS2_S2_+0x2ca>
            set_cow_page(phys, tlb->val);
ffffffff8101d0ae:	4c 89 fe             	mov    %r15,%rsi
ffffffff8101d0b1:	e8 ce 5d ff ff       	callq  ffffffff81012e84 <_ZN3PteI4VtlbyLj3ELj9ELb0EE12set_cow_pageEyRy>
        }
        return SUCCESS;
    }
}
ffffffff8101d0b6:	48 83 c4 48          	add    $0x48,%rsp
ffffffff8101d0ba:	89 d8                	mov    %ebx,%eax
ffffffff8101d0bc:	5b                   	pop    %rbx
ffffffff8101d0bd:	5d                   	pop    %rbp
ffffffff8101d0be:	41 5c                	pop    %r12
ffffffff8101d0c0:	41 5d                	pop    %r13
ffffffff8101d0c2:	41 5e                	pop    %r14
ffffffff8101d0c4:	41 5f                	pop    %r15
ffffffff8101d0c6:	c3                   	retq   
